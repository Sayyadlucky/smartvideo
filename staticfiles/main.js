var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 ||= {})
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a2, b2) => (typeof require !== "undefined" ? require : a2)[b2]
}) : x2)(function(x2) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/@angular/core/fesm2022/not_found.mjs
function getCurrentInjector() {
  return _currentInjector;
}
function setCurrentInjector(injector) {
  const former = _currentInjector;
  _currentInjector = injector;
  return former;
}
function isNotFound(e2) {
  return e2 === NOT_FOUND || e2?.name === "\u0275NotFound";
}
var _currentInjector, NOT_FOUND;
var init_not_found = __esm({
  "node_modules/@angular/core/fesm2022/not_found.mjs"() {
    "use strict";
    _currentInjector = void 0;
    NOT_FOUND = Symbol("NotFound");
  }
});

// node_modules/@angular/core/fesm2022/signal.mjs
function defaultEquals(a2, b2) {
  return Object.is(a2, b2);
}
function setActiveConsumer(consumer) {
  const prev = activeConsumer;
  activeConsumer = consumer;
  return prev;
}
function getActiveConsumer() {
  return activeConsumer;
}
function isInNotificationPhase() {
  return inNotificationPhase;
}
function producerAccessed(node) {
  if (inNotificationPhase) {
    throw new Error(typeof ngDevMode !== "undefined" && ngDevMode ? `Assertion error: signal read during notification phase` : "");
  }
  if (activeConsumer === null) {
    return;
  }
  activeConsumer.consumerOnSignalRead(node);
  const prevProducerLink = activeConsumer.producersTail;
  if (prevProducerLink !== void 0 && prevProducerLink.producer === node) {
    return;
  }
  let nextProducerLink = void 0;
  const isRecomputing = activeConsumer.recomputing;
  if (isRecomputing) {
    nextProducerLink = prevProducerLink !== void 0 ? prevProducerLink.nextProducer : activeConsumer.producers;
    if (nextProducerLink !== void 0 && nextProducerLink.producer === node) {
      activeConsumer.producersTail = nextProducerLink;
      nextProducerLink.lastReadVersion = node.version;
      return;
    }
  }
  const prevConsumerLink = node.consumersTail;
  if (prevConsumerLink !== void 0 && prevConsumerLink.consumer === activeConsumer && // However, we have to make sure that the link we've discovered isn't from a node that is incrementally rebuilding its producer list
  (!isRecomputing || isValidLink(prevConsumerLink, activeConsumer))) {
    return;
  }
  const isLive = consumerIsLive(activeConsumer);
  const newLink = {
    producer: node,
    consumer: activeConsumer,
    // instead of eagerly destroying the previous link, we delay until we've finished recomputing
    // the producers list, so that we can destroy all of the old links at once.
    nextProducer: nextProducerLink,
    prevConsumer: prevConsumerLink,
    lastReadVersion: node.version,
    nextConsumer: void 0
  };
  activeConsumer.producersTail = newLink;
  if (prevProducerLink !== void 0) {
    prevProducerLink.nextProducer = newLink;
  } else {
    activeConsumer.producers = newLink;
  }
  if (isLive) {
    producerAddLiveConsumer(node, newLink);
  }
}
function producerIncrementEpoch() {
  epoch++;
}
function producerUpdateValueVersion(node) {
  if (consumerIsLive(node) && !node.dirty) {
    return;
  }
  if (!node.dirty && node.lastCleanEpoch === epoch) {
    return;
  }
  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {
    producerMarkClean(node);
    return;
  }
  node.producerRecomputeValue(node);
  producerMarkClean(node);
}
function producerNotifyConsumers(node) {
  if (node.consumers === void 0) {
    return;
  }
  const prev = inNotificationPhase;
  inNotificationPhase = true;
  try {
    for (let link = node.consumers; link !== void 0; link = link.nextConsumer) {
      const consumer = link.consumer;
      if (!consumer.dirty) {
        consumerMarkDirty(consumer);
      }
    }
  } finally {
    inNotificationPhase = prev;
  }
}
function producerUpdatesAllowed() {
  return activeConsumer?.consumerAllowSignalWrites !== false;
}
function consumerMarkDirty(node) {
  node.dirty = true;
  producerNotifyConsumers(node);
  node.consumerMarkedDirty?.(node);
}
function producerMarkClean(node) {
  node.dirty = false;
  node.lastCleanEpoch = epoch;
}
function consumerBeforeComputation(node) {
  if (node) {
    node.producersTail = void 0;
    node.recomputing = true;
  }
  return setActiveConsumer(node);
}
function consumerAfterComputation(node, prevConsumer) {
  setActiveConsumer(prevConsumer);
  if (!node) {
    return;
  }
  node.recomputing = false;
  const producersTail = node.producersTail;
  let toRemove = producersTail !== void 0 ? producersTail.nextProducer : node.producers;
  if (toRemove !== void 0) {
    if (consumerIsLive(node)) {
      do {
        toRemove = producerRemoveLiveConsumerLink(toRemove);
      } while (toRemove !== void 0);
    }
    if (producersTail !== void 0) {
      producersTail.nextProducer = void 0;
    } else {
      node.producers = void 0;
    }
  }
}
function consumerPollProducersForChange(node) {
  for (let link = node.producers; link !== void 0; link = link.nextProducer) {
    const producer = link.producer;
    const seenVersion = link.lastReadVersion;
    if (seenVersion !== producer.version) {
      return true;
    }
    producerUpdateValueVersion(producer);
    if (seenVersion !== producer.version) {
      return true;
    }
  }
  return false;
}
function consumerDestroy(node) {
  if (consumerIsLive(node)) {
    let link = node.producers;
    while (link !== void 0) {
      link = producerRemoveLiveConsumerLink(link);
    }
  }
  node.producers = void 0;
  node.producersTail = void 0;
  node.consumers = void 0;
  node.consumersTail = void 0;
}
function producerAddLiveConsumer(node, link) {
  const consumersTail = node.consumersTail;
  const wasLive = consumerIsLive(node);
  if (consumersTail !== void 0) {
    link.nextConsumer = consumersTail.nextConsumer;
    consumersTail.nextConsumer = link;
  } else {
    link.nextConsumer = void 0;
    node.consumers = link;
  }
  link.prevConsumer = consumersTail;
  node.consumersTail = link;
  if (!wasLive) {
    for (let link2 = node.producers; link2 !== void 0; link2 = link2.nextProducer) {
      producerAddLiveConsumer(link2.producer, link2);
    }
  }
}
function producerRemoveLiveConsumerLink(link) {
  const producer = link.producer;
  const nextProducer = link.nextProducer;
  const nextConsumer = link.nextConsumer;
  const prevConsumer = link.prevConsumer;
  link.nextConsumer = void 0;
  link.prevConsumer = void 0;
  if (nextConsumer !== void 0) {
    nextConsumer.prevConsumer = prevConsumer;
  } else {
    producer.consumersTail = prevConsumer;
  }
  if (prevConsumer !== void 0) {
    prevConsumer.nextConsumer = nextConsumer;
  } else {
    producer.consumers = nextConsumer;
    if (!consumerIsLive(producer)) {
      let producerLink = producer.producers;
      while (producerLink !== void 0) {
        producerLink = producerRemoveLiveConsumerLink(producerLink);
      }
    }
  }
  return nextProducer;
}
function consumerIsLive(node) {
  return node.consumerIsAlwaysLive || node.consumers !== void 0;
}
function runPostProducerCreatedFn(node) {
  postProducerCreatedFn?.(node);
}
function isValidLink(checkLink, consumer) {
  const producersTail = consumer.producersTail;
  if (producersTail !== void 0) {
    let link = consumer.producers;
    do {
      if (link === checkLink) {
        return true;
      }
      if (link === producersTail) {
        break;
      }
      link = link.nextProducer;
    } while (link !== void 0);
  }
  return false;
}
function createComputed(computation, equal) {
  const node = Object.create(COMPUTED_NODE);
  node.computation = computation;
  if (equal !== void 0) {
    node.equal = equal;
  }
  const computed2 = () => {
    producerUpdateValueVersion(node);
    producerAccessed(node);
    if (node.value === ERRORED) {
      throw node.error;
    }
    return node.value;
  };
  computed2[SIGNAL] = node;
  if (typeof ngDevMode !== "undefined" && ngDevMode) {
    const debugName = node.debugName ? " (" + node.debugName + ")" : "";
    computed2.toString = () => `[Computed${debugName}: ${node.value}]`;
  }
  runPostProducerCreatedFn(node);
  return computed2;
}
function defaultThrowError() {
  throw new Error();
}
function throwInvalidWriteToSignalError(node) {
  throwInvalidWriteToSignalErrorFn(node);
}
function setThrowInvalidWriteToSignalError(fn) {
  throwInvalidWriteToSignalErrorFn = fn;
}
function createSignal(initialValue, equal) {
  const node = Object.create(SIGNAL_NODE);
  node.value = initialValue;
  if (equal !== void 0) {
    node.equal = equal;
  }
  const getter = () => signalGetFn(node);
  getter[SIGNAL] = node;
  if (typeof ngDevMode !== "undefined" && ngDevMode) {
    const debugName = node.debugName ? " (" + node.debugName + ")" : "";
    getter.toString = () => `[Signal${debugName}: ${node.value}]`;
  }
  runPostProducerCreatedFn(node);
  const set = (newValue) => signalSetFn(node, newValue);
  const update = (updateFn) => signalUpdateFn(node, updateFn);
  return [getter, set, update];
}
function signalGetFn(node) {
  producerAccessed(node);
  return node.value;
}
function signalSetFn(node, newValue) {
  if (!producerUpdatesAllowed()) {
    throwInvalidWriteToSignalError(node);
  }
  if (!node.equal(node.value, newValue)) {
    node.value = newValue;
    signalValueChanged(node);
  }
}
function signalUpdateFn(node, updater) {
  if (!producerUpdatesAllowed()) {
    throwInvalidWriteToSignalError(node);
  }
  signalSetFn(node, updater(node.value));
}
function signalValueChanged(node) {
  node.version++;
  producerIncrementEpoch();
  producerNotifyConsumers(node);
  postSignalSetFn?.(node);
}
var activeConsumer, inNotificationPhase, epoch, postProducerCreatedFn, SIGNAL, REACTIVE_NODE, UNSET, COMPUTING, ERRORED, COMPUTED_NODE, throwInvalidWriteToSignalErrorFn, postSignalSetFn, SIGNAL_NODE;
var init_signal = __esm({
  "node_modules/@angular/core/fesm2022/signal.mjs"() {
    "use strict";
    activeConsumer = null;
    inNotificationPhase = false;
    epoch = 1;
    postProducerCreatedFn = null;
    SIGNAL = /* @__PURE__ */ Symbol("SIGNAL");
    REACTIVE_NODE = {
      version: 0,
      lastCleanEpoch: 0,
      dirty: false,
      producers: void 0,
      producersTail: void 0,
      consumers: void 0,
      consumersTail: void 0,
      recomputing: false,
      consumerAllowSignalWrites: false,
      consumerIsAlwaysLive: false,
      kind: "unknown",
      producerMustRecompute: () => false,
      producerRecomputeValue: () => {
      },
      consumerMarkedDirty: () => {
      },
      consumerOnSignalRead: () => {
      }
    };
    UNSET = /* @__PURE__ */ Symbol("UNSET");
    COMPUTING = /* @__PURE__ */ Symbol("COMPUTING");
    ERRORED = /* @__PURE__ */ Symbol("ERRORED");
    COMPUTED_NODE = /* @__PURE__ */ (() => {
      return __spreadProps(__spreadValues({}, REACTIVE_NODE), {
        value: UNSET,
        dirty: true,
        error: null,
        equal: defaultEquals,
        kind: "computed",
        producerMustRecompute(node) {
          return node.value === UNSET || node.value === COMPUTING;
        },
        producerRecomputeValue(node) {
          if (node.value === COMPUTING) {
            throw new Error(typeof ngDevMode !== "undefined" && ngDevMode ? "Detected cycle in computations." : "");
          }
          const oldValue = node.value;
          node.value = COMPUTING;
          const prevConsumer = consumerBeforeComputation(node);
          let newValue;
          let wasEqual = false;
          try {
            newValue = node.computation();
            setActiveConsumer(null);
            wasEqual = oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue);
          } catch (err) {
            newValue = ERRORED;
            node.error = err;
          } finally {
            consumerAfterComputation(node, prevConsumer);
          }
          if (wasEqual) {
            node.value = oldValue;
            return;
          }
          node.value = newValue;
          node.version++;
        }
      });
    })();
    throwInvalidWriteToSignalErrorFn = defaultThrowError;
    postSignalSetFn = null;
    SIGNAL_NODE = /* @__PURE__ */ (() => {
      return __spreadProps(__spreadValues({}, REACTIVE_NODE), {
        equal: defaultEquals,
        value: void 0,
        kind: "signal"
      });
    })();
  }
});

// node_modules/rxjs/dist/esm/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}
var init_isFunction = __esm({
  "node_modules/rxjs/dist/esm/internal/util/isFunction.js"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  const _super = (instance) => {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  const ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var init_createErrorClass = __esm({
  "node_modules/rxjs/dist/esm/internal/util/createErrorClass.js"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/util/UnsubscriptionError.js
var UnsubscriptionError;
var init_UnsubscriptionError = __esm({
  "node_modules/rxjs/dist/esm/internal/util/UnsubscriptionError.js"() {
    "use strict";
    init_createErrorClass();
    UnsubscriptionError = createErrorClass((_super) => function UnsubscriptionErrorImpl(errors) {
      _super(this);
      this.message = errors ? `${errors.length} errors occurred during unsubscription:
${errors.map((err, i2) => `${i2 + 1}) ${err.toString()}`).join("\n  ")}` : "";
      this.name = "UnsubscriptionError";
      this.errors = errors;
    });
  }
});

// node_modules/rxjs/dist/esm/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    const index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
var init_arrRemove = __esm({
  "node_modules/rxjs/dist/esm/internal/util/arrRemove.js"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/Subscription.js
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var Subscription, EMPTY_SUBSCRIPTION;
var init_Subscription = __esm({
  "node_modules/rxjs/dist/esm/internal/Subscription.js"() {
    "use strict";
    init_isFunction();
    init_UnsubscriptionError();
    init_arrRemove();
    Subscription = class _Subscription {
      constructor(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
      }
      unsubscribe() {
        let errors;
        if (!this.closed) {
          this.closed = true;
          const { _parentage } = this;
          if (_parentage) {
            this._parentage = null;
            if (Array.isArray(_parentage)) {
              for (const parent of _parentage) {
                parent.remove(this);
              }
            } else {
              _parentage.remove(this);
            }
          }
          const { initialTeardown: initialFinalizer } = this;
          if (isFunction(initialFinalizer)) {
            try {
              initialFinalizer();
            } catch (e2) {
              errors = e2 instanceof UnsubscriptionError ? e2.errors : [e2];
            }
          }
          const { _finalizers } = this;
          if (_finalizers) {
            this._finalizers = null;
            for (const finalizer of _finalizers) {
              try {
                execFinalizer(finalizer);
              } catch (err) {
                errors = errors !== null && errors !== void 0 ? errors : [];
                if (err instanceof UnsubscriptionError) {
                  errors = [...errors, ...err.errors];
                } else {
                  errors.push(err);
                }
              }
            }
          }
          if (errors) {
            throw new UnsubscriptionError(errors);
          }
        }
      }
      add(teardown) {
        var _a2;
        if (teardown && teardown !== this) {
          if (this.closed) {
            execFinalizer(teardown);
          } else {
            if (teardown instanceof _Subscription) {
              if (teardown.closed || teardown._hasParent(this)) {
                return;
              }
              teardown._addParent(this);
            }
            (this._finalizers = (_a2 = this._finalizers) !== null && _a2 !== void 0 ? _a2 : []).push(teardown);
          }
        }
      }
      _hasParent(parent) {
        const { _parentage } = this;
        return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
      }
      _addParent(parent) {
        const { _parentage } = this;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
      }
      _removeParent(parent) {
        const { _parentage } = this;
        if (_parentage === parent) {
          this._parentage = null;
        } else if (Array.isArray(_parentage)) {
          arrRemove(_parentage, parent);
        }
      }
      remove(teardown) {
        const { _finalizers } = this;
        _finalizers && arrRemove(_finalizers, teardown);
        if (teardown instanceof _Subscription) {
          teardown._removeParent(this);
        }
      }
    };
    Subscription.EMPTY = (() => {
      const empty = new Subscription();
      empty.closed = true;
      return empty;
    })();
    EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  }
});

// node_modules/rxjs/dist/esm/internal/config.js
var config;
var init_config = __esm({
  "node_modules/rxjs/dist/esm/internal/config.js"() {
    "use strict";
    config = {
      onUnhandledError: null,
      onStoppedNotification: null,
      Promise: void 0,
      useDeprecatedSynchronousErrorHandling: false,
      useDeprecatedNextContext: false
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/timeoutProvider.js
var timeoutProvider;
var init_timeoutProvider = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/timeoutProvider.js"() {
    "use strict";
    timeoutProvider = {
      setTimeout(handler, timeout, ...args) {
        const { delegate } = timeoutProvider;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
          return delegate.setTimeout(handler, timeout, ...args);
        }
        return setTimeout(handler, timeout, ...args);
      },
      clearTimeout(handle) {
        const { delegate } = timeoutProvider;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(() => {
    const { onUnhandledError } = config;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}
var init_reportUnhandledError = __esm({
  "node_modules/rxjs/dist/esm/internal/util/reportUnhandledError.js"() {
    "use strict";
    init_config();
    init_timeoutProvider();
  }
});

// node_modules/rxjs/dist/esm/internal/util/noop.js
function noop() {
}
var init_noop = __esm({
  "node_modules/rxjs/dist/esm/internal/util/noop.js"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/NotificationFactories.js
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}
var COMPLETE_NOTIFICATION;
var init_NotificationFactories = __esm({
  "node_modules/rxjs/dist/esm/internal/NotificationFactories.js"() {
    "use strict";
    COMPLETE_NOTIFICATION = (() => createNotification("C", void 0, void 0))();
  }
});

// node_modules/rxjs/dist/esm/internal/util/errorContext.js
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    const isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      const { errorThrown, error } = context;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}
var context;
var init_errorContext = __esm({
  "node_modules/rxjs/dist/esm/internal/util/errorContext.js"() {
    "use strict";
    init_config();
    context = null;
  }
});

// node_modules/rxjs/dist/esm/internal/Subscriber.js
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  const { onStoppedNotification } = config;
  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));
}
var Subscriber, _bind, ConsumerObserver, SafeSubscriber, EMPTY_OBSERVER;
var init_Subscriber = __esm({
  "node_modules/rxjs/dist/esm/internal/Subscriber.js"() {
    "use strict";
    init_isFunction();
    init_Subscription();
    init_config();
    init_reportUnhandledError();
    init_noop();
    init_NotificationFactories();
    init_timeoutProvider();
    init_errorContext();
    Subscriber = class extends Subscription {
      constructor(destination) {
        super();
        this.isStopped = false;
        if (destination) {
          this.destination = destination;
          if (isSubscription(destination)) {
            destination.add(this);
          }
        } else {
          this.destination = EMPTY_OBSERVER;
        }
      }
      static create(next, error, complete) {
        return new SafeSubscriber(next, error, complete);
      }
      next(value) {
        if (this.isStopped) {
          handleStoppedNotification(nextNotification(value), this);
        } else {
          this._next(value);
        }
      }
      error(err) {
        if (this.isStopped) {
          handleStoppedNotification(errorNotification(err), this);
        } else {
          this.isStopped = true;
          this._error(err);
        }
      }
      complete() {
        if (this.isStopped) {
          handleStoppedNotification(COMPLETE_NOTIFICATION, this);
        } else {
          this.isStopped = true;
          this._complete();
        }
      }
      unsubscribe() {
        if (!this.closed) {
          this.isStopped = true;
          super.unsubscribe();
          this.destination = null;
        }
      }
      _next(value) {
        this.destination.next(value);
      }
      _error(err) {
        try {
          this.destination.error(err);
        } finally {
          this.unsubscribe();
        }
      }
      _complete() {
        try {
          this.destination.complete();
        } finally {
          this.unsubscribe();
        }
      }
    };
    _bind = Function.prototype.bind;
    ConsumerObserver = class {
      constructor(partialObserver) {
        this.partialObserver = partialObserver;
      }
      next(value) {
        const { partialObserver } = this;
        if (partialObserver.next) {
          try {
            partialObserver.next(value);
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      }
      error(err) {
        const { partialObserver } = this;
        if (partialObserver.error) {
          try {
            partialObserver.error(err);
          } catch (error) {
            handleUnhandledError(error);
          }
        } else {
          handleUnhandledError(err);
        }
      }
      complete() {
        const { partialObserver } = this;
        if (partialObserver.complete) {
          try {
            partialObserver.complete();
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      }
    };
    SafeSubscriber = class extends Subscriber {
      constructor(observerOrNext, error, complete) {
        super();
        let partialObserver;
        if (isFunction(observerOrNext) || !observerOrNext) {
          partialObserver = {
            next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
            error: error !== null && error !== void 0 ? error : void 0,
            complete: complete !== null && complete !== void 0 ? complete : void 0
          };
        } else {
          let context2;
          if (this && config.useDeprecatedNextContext) {
            context2 = Object.create(observerOrNext);
            context2.unsubscribe = () => this.unsubscribe();
            partialObserver = {
              next: observerOrNext.next && bind(observerOrNext.next, context2),
              error: observerOrNext.error && bind(observerOrNext.error, context2),
              complete: observerOrNext.complete && bind(observerOrNext.complete, context2)
            };
          } else {
            partialObserver = observerOrNext;
          }
        }
        this.destination = new ConsumerObserver(partialObserver);
      }
    };
    EMPTY_OBSERVER = {
      closed: true,
      next: noop,
      error: defaultErrorHandler,
      complete: noop
    };
  }
});

// node_modules/rxjs/dist/esm/internal/symbol/observable.js
var observable;
var init_observable = __esm({
  "node_modules/rxjs/dist/esm/internal/symbol/observable.js"() {
    "use strict";
    observable = (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
  }
});

// node_modules/rxjs/dist/esm/internal/util/identity.js
function identity(x2) {
  return x2;
}
var init_identity = __esm({
  "node_modules/rxjs/dist/esm/internal/util/identity.js"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/util/pipe.js
function pipe(...fns) {
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input2) {
    return fns.reduce((prev, fn) => fn(prev), input2);
  };
}
var init_pipe = __esm({
  "node_modules/rxjs/dist/esm/internal/util/pipe.js"() {
    "use strict";
    init_identity();
  }
});

// node_modules/rxjs/dist/esm/internal/Observable.js
function getPromiseCtor(promiseCtor) {
  var _a2;
  return (_a2 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a2 !== void 0 ? _a2 : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
var Observable;
var init_Observable = __esm({
  "node_modules/rxjs/dist/esm/internal/Observable.js"() {
    "use strict";
    init_Subscriber();
    init_Subscription();
    init_observable();
    init_pipe();
    init_config();
    init_isFunction();
    init_errorContext();
    Observable = class _Observable {
      constructor(subscribe) {
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      lift(operator) {
        const observable2 = new _Observable();
        observable2.source = this;
        observable2.operator = operator;
        return observable2;
      }
      subscribe(observerOrNext, error, complete) {
        const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
        errorContext(() => {
          const { operator, source } = this;
          subscriber.add(operator ? operator.call(subscriber, source) : source ? this._subscribe(subscriber) : this._trySubscribe(subscriber));
        });
        return subscriber;
      }
      _trySubscribe(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          sink.error(err);
        }
      }
      forEach(next, promiseCtor) {
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor((resolve, reject) => {
          const subscriber = new SafeSubscriber({
            next: (value) => {
              try {
                next(value);
              } catch (err) {
                reject(err);
                subscriber.unsubscribe();
              }
            },
            error: reject,
            complete: resolve
          });
          this.subscribe(subscriber);
        });
      }
      _subscribe(subscriber) {
        var _a2;
        return (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber);
      }
      [observable]() {
        return this;
      }
      pipe(...operations) {
        return pipeFromArray(operations)(this);
      }
      toPromise(promiseCtor) {
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor((resolve, reject) => {
          let value;
          this.subscribe((x2) => value = x2, (err) => reject(err), () => resolve(value));
        });
      }
    };
    Observable.create = (subscribe) => {
      return new Observable(subscribe);
    };
  }
});

// node_modules/rxjs/dist/esm/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return (source) => {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
var init_lift = __esm({
  "node_modules/rxjs/dist/esm/internal/util/lift.js"() {
    "use strict";
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber;
var init_OperatorSubscriber = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/OperatorSubscriber.js"() {
    "use strict";
    init_Subscriber();
    OperatorSubscriber = class extends Subscriber {
      constructor(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
        super(destination);
        this.onFinalize = onFinalize;
        this.shouldUnsubscribe = shouldUnsubscribe;
        this._next = onNext ? function(value) {
          try {
            onNext(value);
          } catch (err) {
            destination.error(err);
          }
        } : super._next;
        this._error = onError ? function(err) {
          try {
            onError(err);
          } catch (err2) {
            destination.error(err2);
          } finally {
            this.unsubscribe();
          }
        } : super._error;
        this._complete = onComplete ? function() {
          try {
            onComplete();
          } catch (err) {
            destination.error(err);
          } finally {
            this.unsubscribe();
          }
        } : super._complete;
      }
      unsubscribe() {
        var _a2;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
          const { closed } = this;
          super.unsubscribe();
          !closed && ((_a2 = this.onFinalize) === null || _a2 === void 0 ? void 0 : _a2.call(this));
        }
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/operators/refCount.js
function refCount() {
  return operate((source, subscriber) => {
    let connection = null;
    source._refCount++;
    const refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, () => {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      const sharedConnection = source._connection;
      const conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}
var init_refCount = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/refCount.js"() {
    "use strict";
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/ConnectableObservable.js
var ConnectableObservable;
var init_ConnectableObservable = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/ConnectableObservable.js"() {
    "use strict";
    init_Observable();
    init_Subscription();
    init_refCount();
    init_OperatorSubscriber();
    init_lift();
    ConnectableObservable = class extends Observable {
      constructor(source, subjectFactory) {
        super();
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._subject = null;
        this._refCount = 0;
        this._connection = null;
        if (hasLift(source)) {
          this.lift = source.lift;
        }
      }
      _subscribe(subscriber) {
        return this.getSubject().subscribe(subscriber);
      }
      getSubject() {
        const subject = this._subject;
        if (!subject || subject.isStopped) {
          this._subject = this.subjectFactory();
        }
        return this._subject;
      }
      _teardown() {
        this._refCount = 0;
        const { _connection } = this;
        this._subject = this._connection = null;
        _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
      }
      connect() {
        let connection = this._connection;
        if (!connection) {
          connection = this._connection = new Subscription();
          const subject = this.getSubject();
          connection.add(this.source.subscribe(createOperatorSubscriber(subject, void 0, () => {
            this._teardown();
            subject.complete();
          }, (err) => {
            this._teardown();
            subject.error(err);
          }, () => this._teardown())));
          if (connection.closed) {
            this._connection = null;
            connection = Subscription.EMPTY;
          }
        }
        return connection;
      }
      refCount() {
        return refCount()(this);
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/animationFrameProvider.js
var animationFrameProvider;
var init_animationFrameProvider = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/animationFrameProvider.js"() {
    "use strict";
    init_Subscription();
    animationFrameProvider = {
      schedule(callback) {
        let request = requestAnimationFrame;
        let cancel = cancelAnimationFrame;
        const { delegate } = animationFrameProvider;
        if (delegate) {
          request = delegate.requestAnimationFrame;
          cancel = delegate.cancelAnimationFrame;
        }
        const handle = request((timestamp) => {
          cancel = void 0;
          callback(timestamp);
        });
        return new Subscription(() => cancel === null || cancel === void 0 ? void 0 : cancel(handle));
      },
      requestAnimationFrame(...args) {
        const { delegate } = animationFrameProvider;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame)(...args);
      },
      cancelAnimationFrame(...args) {
        const { delegate } = animationFrameProvider;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame)(...args);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError;
var init_ObjectUnsubscribedError = __esm({
  "node_modules/rxjs/dist/esm/internal/util/ObjectUnsubscribedError.js"() {
    "use strict";
    init_createErrorClass();
    ObjectUnsubscribedError = createErrorClass((_super) => function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    });
  }
});

// node_modules/rxjs/dist/esm/internal/Subject.js
var Subject, AnonymousSubject;
var init_Subject = __esm({
  "node_modules/rxjs/dist/esm/internal/Subject.js"() {
    "use strict";
    init_Observable();
    init_Subscription();
    init_ObjectUnsubscribedError();
    init_arrRemove();
    init_errorContext();
    Subject = class extends Observable {
      constructor() {
        super();
        this.closed = false;
        this.currentObservers = null;
        this.observers = [];
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
      }
      lift(operator) {
        const subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      }
      _throwIfClosed() {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
      }
      next(value) {
        errorContext(() => {
          this._throwIfClosed();
          if (!this.isStopped) {
            if (!this.currentObservers) {
              this.currentObservers = Array.from(this.observers);
            }
            for (const observer of this.currentObservers) {
              observer.next(value);
            }
          }
        });
      }
      error(err) {
        errorContext(() => {
          this._throwIfClosed();
          if (!this.isStopped) {
            this.hasError = this.isStopped = true;
            this.thrownError = err;
            const { observers } = this;
            while (observers.length) {
              observers.shift().error(err);
            }
          }
        });
      }
      complete() {
        errorContext(() => {
          this._throwIfClosed();
          if (!this.isStopped) {
            this.isStopped = true;
            const { observers } = this;
            while (observers.length) {
              observers.shift().complete();
            }
          }
        });
      }
      unsubscribe() {
        this.isStopped = this.closed = true;
        this.observers = this.currentObservers = null;
      }
      get observed() {
        var _a2;
        return ((_a2 = this.observers) === null || _a2 === void 0 ? void 0 : _a2.length) > 0;
      }
      _trySubscribe(subscriber) {
        this._throwIfClosed();
        return super._trySubscribe(subscriber);
      }
      _subscribe(subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
      }
      _innerSubscribe(subscriber) {
        const { hasError, isStopped, observers } = this;
        if (hasError || isStopped) {
          return EMPTY_SUBSCRIPTION;
        }
        this.currentObservers = null;
        observers.push(subscriber);
        return new Subscription(() => {
          this.currentObservers = null;
          arrRemove(observers, subscriber);
        });
      }
      _checkFinalizedStatuses(subscriber) {
        const { hasError, thrownError, isStopped } = this;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped) {
          subscriber.complete();
        }
      }
      asObservable() {
        const observable2 = new Observable();
        observable2.source = this;
        return observable2;
      }
    };
    Subject.create = (destination, source) => {
      return new AnonymousSubject(destination, source);
    };
    AnonymousSubject = class extends Subject {
      constructor(destination, source) {
        super();
        this.destination = destination;
        this.source = source;
      }
      next(value) {
        var _a2, _b;
        (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.next) === null || _b === void 0 ? void 0 : _b.call(_a2, value);
      }
      error(err) {
        var _a2, _b;
        (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.error) === null || _b === void 0 ? void 0 : _b.call(_a2, err);
      }
      complete() {
        var _a2, _b;
        (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.complete) === null || _b === void 0 ? void 0 : _b.call(_a2);
      }
      _subscribe(subscriber) {
        var _a2, _b;
        return (_b = (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/BehaviorSubject.js
var BehaviorSubject;
var init_BehaviorSubject = __esm({
  "node_modules/rxjs/dist/esm/internal/BehaviorSubject.js"() {
    "use strict";
    init_Subject();
    BehaviorSubject = class extends Subject {
      constructor(_value) {
        super();
        this._value = _value;
      }
      get value() {
        return this.getValue();
      }
      _subscribe(subscriber) {
        const subscription = super._subscribe(subscriber);
        !subscription.closed && subscriber.next(this._value);
        return subscription;
      }
      getValue() {
        const { hasError, thrownError, _value } = this;
        if (hasError) {
          throw thrownError;
        }
        this._throwIfClosed();
        return _value;
      }
      next(value) {
        super.next(this._value = value);
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider;
var init_dateTimestampProvider = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/dateTimestampProvider.js"() {
    "use strict";
    dateTimestampProvider = {
      now() {
        return (dateTimestampProvider.delegate || Date).now();
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm/internal/ReplaySubject.js
var ReplaySubject;
var init_ReplaySubject = __esm({
  "node_modules/rxjs/dist/esm/internal/ReplaySubject.js"() {
    "use strict";
    init_Subject();
    init_dateTimestampProvider();
    ReplaySubject = class extends Subject {
      constructor(_bufferSize = Infinity, _windowTime = Infinity, _timestampProvider = dateTimestampProvider) {
        super();
        this._bufferSize = _bufferSize;
        this._windowTime = _windowTime;
        this._timestampProvider = _timestampProvider;
        this._buffer = [];
        this._infiniteTimeWindow = true;
        this._infiniteTimeWindow = _windowTime === Infinity;
        this._bufferSize = Math.max(1, _bufferSize);
        this._windowTime = Math.max(1, _windowTime);
      }
      next(value) {
        const { isStopped, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;
        if (!isStopped) {
          _buffer.push(value);
          !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
        }
        this._trimBuffer();
        super.next(value);
      }
      _subscribe(subscriber) {
        this._throwIfClosed();
        this._trimBuffer();
        const subscription = this._innerSubscribe(subscriber);
        const { _infiniteTimeWindow, _buffer } = this;
        const copy = _buffer.slice();
        for (let i2 = 0; i2 < copy.length && !subscriber.closed; i2 += _infiniteTimeWindow ? 1 : 2) {
          subscriber.next(copy[i2]);
        }
        this._checkFinalizedStatuses(subscriber);
        return subscription;
      }
      _trimBuffer() {
        const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;
        const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
        if (!_infiniteTimeWindow) {
          const now = _timestampProvider.now();
          let last4 = 0;
          for (let i2 = 1; i2 < _buffer.length && _buffer[i2] <= now; i2 += 2) {
            last4 = i2;
          }
          last4 && _buffer.splice(0, last4 + 1);
        }
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/Action.js
var Action;
var init_Action = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/Action.js"() {
    "use strict";
    init_Subscription();
    Action = class extends Subscription {
      constructor(scheduler, work) {
        super();
      }
      schedule(state, delay = 0) {
        return this;
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/intervalProvider.js
var intervalProvider;
var init_intervalProvider = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/intervalProvider.js"() {
    "use strict";
    intervalProvider = {
      setInterval(handler, timeout, ...args) {
        const { delegate } = intervalProvider;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
          return delegate.setInterval(handler, timeout, ...args);
        }
        return setInterval(handler, timeout, ...args);
      },
      clearInterval(handle) {
        const { delegate } = intervalProvider;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/AsyncAction.js
var AsyncAction;
var init_AsyncAction = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/AsyncAction.js"() {
    "use strict";
    init_Action();
    init_intervalProvider();
    init_arrRemove();
    AsyncAction = class extends Action {
      constructor(scheduler, work) {
        super(scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
      }
      schedule(state, delay = 0) {
        var _a2;
        if (this.closed) {
          return this;
        }
        this.state = state;
        const id2 = this.id;
        const scheduler = this.scheduler;
        if (id2 != null) {
          this.id = this.recycleAsyncId(scheduler, id2, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = (_a2 = this.id) !== null && _a2 !== void 0 ? _a2 : this.requestAsyncId(scheduler, this.id, delay);
        return this;
      }
      requestAsyncId(scheduler, _id, delay = 0) {
        return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
      }
      recycleAsyncId(_scheduler, id2, delay = 0) {
        if (delay != null && this.delay === delay && this.pending === false) {
          return id2;
        }
        if (id2 != null) {
          intervalProvider.clearInterval(id2);
        }
        return void 0;
      }
      execute(state, delay) {
        if (this.closed) {
          return new Error("executing a cancelled action");
        }
        this.pending = false;
        const error = this._execute(state, delay);
        if (error) {
          return error;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      }
      _execute(state, _delay) {
        let errored = false;
        let errorValue;
        try {
          this.work(state);
        } catch (e2) {
          errored = true;
          errorValue = e2 ? e2 : new Error("Scheduled action threw falsy error");
        }
        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      }
      unsubscribe() {
        if (!this.closed) {
          const { id: id2, scheduler } = this;
          const { actions } = scheduler;
          this.work = this.state = this.scheduler = null;
          this.pending = false;
          arrRemove(actions, this);
          if (id2 != null) {
            this.id = this.recycleAsyncId(scheduler, id2, null);
          }
          this.delay = null;
          super.unsubscribe();
        }
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/util/Immediate.js
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var nextHandle, resolved, activeHandles, Immediate;
var init_Immediate = __esm({
  "node_modules/rxjs/dist/esm/internal/util/Immediate.js"() {
    "use strict";
    nextHandle = 1;
    activeHandles = {};
    Immediate = {
      setImmediate(cb) {
        const handle = nextHandle++;
        activeHandles[handle] = true;
        if (!resolved) {
          resolved = Promise.resolve();
        }
        resolved.then(() => findAndClearHandle(handle) && cb());
        return handle;
      },
      clearImmediate(handle) {
        findAndClearHandle(handle);
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/immediateProvider.js
var setImmediate2, clearImmediate, immediateProvider;
var init_immediateProvider = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/immediateProvider.js"() {
    "use strict";
    init_Immediate();
    ({ setImmediate: setImmediate2, clearImmediate } = Immediate);
    immediateProvider = {
      setImmediate(...args) {
        const { delegate } = immediateProvider;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate2)(...args);
      },
      clearImmediate(handle) {
        const { delegate } = immediateProvider;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/AsapAction.js
var AsapAction;
var init_AsapAction = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/AsapAction.js"() {
    "use strict";
    init_AsyncAction();
    init_immediateProvider();
    AsapAction = class extends AsyncAction {
      constructor(scheduler, work) {
        super(scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
      }
      requestAsyncId(scheduler, id2, delay = 0) {
        if (delay !== null && delay > 0) {
          return super.requestAsyncId(scheduler, id2, delay);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
      }
      recycleAsyncId(scheduler, id2, delay = 0) {
        var _a2;
        if (delay != null ? delay > 0 : this.delay > 0) {
          return super.recycleAsyncId(scheduler, id2, delay);
        }
        const { actions } = scheduler;
        if (id2 != null && ((_a2 = actions[actions.length - 1]) === null || _a2 === void 0 ? void 0 : _a2.id) !== id2) {
          immediateProvider.clearImmediate(id2);
          if (scheduler._scheduled === id2) {
            scheduler._scheduled = void 0;
          }
        }
        return void 0;
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/Scheduler.js
var Scheduler;
var init_Scheduler = __esm({
  "node_modules/rxjs/dist/esm/internal/Scheduler.js"() {
    "use strict";
    init_dateTimestampProvider();
    Scheduler = class _Scheduler {
      constructor(schedulerActionCtor, now = _Scheduler.now) {
        this.schedulerActionCtor = schedulerActionCtor;
        this.now = now;
      }
      schedule(work, delay = 0, state) {
        return new this.schedulerActionCtor(this, work).schedule(state, delay);
      }
    };
    Scheduler.now = dateTimestampProvider.now;
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/AsyncScheduler.js
var AsyncScheduler;
var init_AsyncScheduler = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/AsyncScheduler.js"() {
    "use strict";
    init_Scheduler();
    AsyncScheduler = class extends Scheduler {
      constructor(SchedulerAction, now = Scheduler.now) {
        super(SchedulerAction, now);
        this.actions = [];
        this._active = false;
      }
      flush(action) {
        const { actions } = this;
        if (this._active) {
          actions.push(action);
          return;
        }
        let error;
        this._active = true;
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift());
        this._active = false;
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/AsapScheduler.js
var AsapScheduler;
var init_AsapScheduler = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/AsapScheduler.js"() {
    "use strict";
    init_AsyncScheduler();
    AsapScheduler = class extends AsyncScheduler {
      flush(action) {
        this._active = true;
        const flushId = this._scheduled;
        this._scheduled = void 0;
        const { actions } = this;
        let error;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/asap.js
var asapScheduler;
var init_asap = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/asap.js"() {
    "use strict";
    init_AsapAction();
    init_AsapScheduler();
    asapScheduler = new AsapScheduler(AsapAction);
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/async.js
var asyncScheduler, async;
var init_async = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/async.js"() {
    "use strict";
    init_AsyncAction();
    init_AsyncScheduler();
    asyncScheduler = new AsyncScheduler(AsyncAction);
    async = asyncScheduler;
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction;
var init_AnimationFrameAction = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/AnimationFrameAction.js"() {
    "use strict";
    init_AsyncAction();
    init_animationFrameProvider();
    AnimationFrameAction = class extends AsyncAction {
      constructor(scheduler, work) {
        super(scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
      }
      requestAsyncId(scheduler, id2, delay = 0) {
        if (delay !== null && delay > 0) {
          return super.requestAsyncId(scheduler, id2, delay);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(() => scheduler.flush(void 0)));
      }
      recycleAsyncId(scheduler, id2, delay = 0) {
        var _a2;
        if (delay != null ? delay > 0 : this.delay > 0) {
          return super.recycleAsyncId(scheduler, id2, delay);
        }
        const { actions } = scheduler;
        if (id2 != null && id2 === scheduler._scheduled && ((_a2 = actions[actions.length - 1]) === null || _a2 === void 0 ? void 0 : _a2.id) !== id2) {
          animationFrameProvider.cancelAnimationFrame(id2);
          scheduler._scheduled = void 0;
        }
        return void 0;
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler;
var init_AnimationFrameScheduler = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/AnimationFrameScheduler.js"() {
    "use strict";
    init_AsyncScheduler();
    AnimationFrameScheduler = class extends AsyncScheduler {
      flush(action) {
        this._active = true;
        let flushId;
        if (action) {
          flushId = action.id;
        } else {
          flushId = this._scheduled;
          this._scheduled = void 0;
        }
        const { actions } = this;
        let error;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/animationFrame.js
var animationFrameScheduler;
var init_animationFrame = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/animationFrame.js"() {
    "use strict";
    init_AnimationFrameAction();
    init_AnimationFrameScheduler();
    animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);
  }
});

// node_modules/rxjs/dist/esm/internal/observable/empty.js
var EMPTY;
var init_empty = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/empty.js"() {
    "use strict";
    init_Observable();
    EMPTY = new Observable((subscriber) => subscriber.complete());
  }
});

// node_modules/rxjs/dist/esm/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}
var init_isScheduler = __esm({
  "node_modules/rxjs/dist/esm/internal/util/isScheduler.js"() {
    "use strict";
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}
var init_args = __esm({
  "node_modules/rxjs/dist/esm/internal/util/args.js"() {
    "use strict";
    init_isFunction();
    init_isScheduler();
  }
});

// node_modules/tslib/tslib.es6.mjs
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o2[s2], i2 = 0;
  if (m) return m.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function awaitReturn(f2) {
    return function(v) {
      return Promise.resolve(v).then(f2, reject);
    };
  }
  function verb(n2, f2) {
    if (g2[n2]) {
      i2[n2] = function(v) {
        return new Promise(function(a2, b2) {
          q2.push([n2, v, a2, b2]) > 1 || resume(n2, v);
        });
      };
      if (f2) i2[n2] = f2(i2[n2]);
    }
  }
  function resume(n2, v) {
    try {
      step(g2[n2](v));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v) {
    if (f2(v), q2.shift(), q2.length) resume(q2[0][0], q2[0][1]);
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o2[Symbol.asyncIterator], i2;
  return m ? m.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o2[n2](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d2, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d2 });
    }, reject);
  }
}
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/util/isArrayLike.js
var isArrayLike;
var init_isArrayLike = __esm({
  "node_modules/rxjs/dist/esm/internal/util/isArrayLike.js"() {
    "use strict";
    isArrayLike = (x2) => x2 && typeof x2.length === "number" && typeof x2 !== "function";
  }
});

// node_modules/rxjs/dist/esm/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}
var init_isPromise = __esm({
  "node_modules/rxjs/dist/esm/internal/util/isPromise.js"() {
    "use strict";
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/util/isInteropObservable.js
function isInteropObservable(input2) {
  return isFunction(input2[observable]);
}
var init_isInteropObservable = __esm({
  "node_modules/rxjs/dist/esm/internal/util/isInteropObservable.js"() {
    "use strict";
    init_observable();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
var init_isAsyncIterable = __esm({
  "node_modules/rxjs/dist/esm/internal/util/isAsyncIterable.js"() {
    "use strict";
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input2) {
  return new TypeError(`You provided ${input2 !== null && typeof input2 === "object" ? "an invalid object" : `'${input2}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`);
}
var init_throwUnobservableError = __esm({
  "node_modules/rxjs/dist/esm/internal/util/throwUnobservableError.js"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator;
var init_iterator = __esm({
  "node_modules/rxjs/dist/esm/internal/symbol/iterator.js"() {
    "use strict";
    iterator = getSymbolIterator();
  }
});

// node_modules/rxjs/dist/esm/internal/util/isIterable.js
function isIterable(input2) {
  return isFunction(input2 === null || input2 === void 0 ? void 0 : input2[iterator]);
}
var init_isIterable = __esm({
  "node_modules/rxjs/dist/esm/internal/util/isIterable.js"() {
    "use strict";
    init_iterator();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function* readableStreamLikeToAsyncGenerator_1() {
    const reader = readableStream.getReader();
    try {
      while (true) {
        const { value, done } = yield __await(reader.read());
        if (done) {
          return yield __await(void 0);
        }
        yield yield __await(value);
      }
    } finally {
      reader.releaseLock();
    }
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
var init_isReadableStreamLike = __esm({
  "node_modules/rxjs/dist/esm/internal/util/isReadableStreamLike.js"() {
    "use strict";
    init_tslib_es6();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/innerFrom.js
function innerFrom(input2) {
  if (input2 instanceof Observable) {
    return input2;
  }
  if (input2 != null) {
    if (isInteropObservable(input2)) {
      return fromInteropObservable(input2);
    }
    if (isArrayLike(input2)) {
      return fromArrayLike(input2);
    }
    if (isPromise(input2)) {
      return fromPromise(input2);
    }
    if (isAsyncIterable(input2)) {
      return fromAsyncIterable(input2);
    }
    if (isIterable(input2)) {
      return fromIterable(input2);
    }
    if (isReadableStreamLike(input2)) {
      return fromReadableStreamLike(input2);
    }
  }
  throw createInvalidObservableTypeError(input2);
}
function fromInteropObservable(obj) {
  return new Observable((subscriber) => {
    const obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable((subscriber) => {
    for (let i2 = 0; i2 < array.length && !subscriber.closed; i2++) {
      subscriber.next(array[i2]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable((subscriber) => {
    promise.then((value) => {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, (err) => subscriber.error(err)).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable((subscriber) => {
    for (const value of iterable) {
      subscriber.next(value);
      if (subscriber.closed) {
        return;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable((subscriber) => {
    process2(asyncIterable, subscriber).catch((err) => subscriber.error(err));
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_1, _a2;
  return __awaiter(this, void 0, void 0, function* () {
    try {
      for (asyncIterable_1 = __asyncValues(asyncIterable); asyncIterable_1_1 = yield asyncIterable_1.next(), !asyncIterable_1_1.done; ) {
        const value = asyncIterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (asyncIterable_1_1 && !asyncIterable_1_1.done && (_a2 = asyncIterable_1.return)) yield _a2.call(asyncIterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
var init_innerFrom = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/innerFrom.js"() {
    "use strict";
    init_tslib_es6();
    init_isArrayLike();
    init_isPromise();
    init_Observable();
    init_isInteropObservable();
    init_isAsyncIterable();
    init_throwUnobservableError();
    init_isIterable();
    init_isReadableStreamLike();
    init_isFunction();
    init_reportUnhandledError();
    init_observable();
  }
});

// node_modules/rxjs/dist/esm/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay = 0, repeat = false) {
  const scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}
var init_executeSchedule = __esm({
  "node_modules/rxjs/dist/esm/internal/util/executeSchedule.js"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/operators/observeOn.js
function observeOn(scheduler, delay = 0) {
  return operate((source, subscriber) => {
    source.subscribe(createOperatorSubscriber(subscriber, (value) => executeSchedule(subscriber, scheduler, () => subscriber.next(value), delay), () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay), (err) => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)));
  });
}
var init_observeOn = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/observeOn.js"() {
    "use strict";
    init_executeSchedule();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay = 0) {
  return operate((source, subscriber) => {
    subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));
  });
}
var init_subscribeOn = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/subscribeOn.js"() {
    "use strict";
    init_lift();
  }
});

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleObservable.js
function scheduleObservable(input2, scheduler) {
  return innerFrom(input2).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
var init_scheduleObservable = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduled/scheduleObservable.js"() {
    "use strict";
    init_innerFrom();
    init_observeOn();
    init_subscribeOn();
  }
});

// node_modules/rxjs/dist/esm/internal/scheduled/schedulePromise.js
function schedulePromise(input2, scheduler) {
  return innerFrom(input2).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
var init_schedulePromise = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduled/schedulePromise.js"() {
    "use strict";
    init_innerFrom();
    init_observeOn();
    init_subscribeOn();
  }
});

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleArray.js
function scheduleArray(input2, scheduler) {
  return new Observable((subscriber) => {
    let i2 = 0;
    return scheduler.schedule(function() {
      if (i2 === input2.length) {
        subscriber.complete();
      } else {
        subscriber.next(input2[i2++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
var init_scheduleArray = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduled/scheduleArray.js"() {
    "use strict";
    init_Observable();
  }
});

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleIterable.js
function scheduleIterable(input2, scheduler) {
  return new Observable((subscriber) => {
    let iterator2;
    executeSchedule(subscriber, scheduler, () => {
      iterator2 = input2[iterator]();
      executeSchedule(subscriber, scheduler, () => {
        let value;
        let done;
        try {
          ({ value, done } = iterator2.next());
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return () => isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
  });
}
var init_scheduleIterable = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduled/scheduleIterable.js"() {
    "use strict";
    init_Observable();
    init_iterator();
    init_isFunction();
    init_executeSchedule();
  }
});

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input2, scheduler) {
  if (!input2) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable((subscriber) => {
    executeSchedule(subscriber, scheduler, () => {
      const iterator2 = input2[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, () => {
        iterator2.next().then((result) => {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
var init_scheduleAsyncIterable = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduled/scheduleAsyncIterable.js"() {
    "use strict";
    init_Observable();
    init_executeSchedule();
  }
});

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input2, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input2), scheduler);
}
var init_scheduleReadableStreamLike = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduled/scheduleReadableStreamLike.js"() {
    "use strict";
    init_scheduleAsyncIterable();
    init_isReadableStreamLike();
  }
});

// node_modules/rxjs/dist/esm/internal/scheduled/scheduled.js
function scheduled(input2, scheduler) {
  if (input2 != null) {
    if (isInteropObservable(input2)) {
      return scheduleObservable(input2, scheduler);
    }
    if (isArrayLike(input2)) {
      return scheduleArray(input2, scheduler);
    }
    if (isPromise(input2)) {
      return schedulePromise(input2, scheduler);
    }
    if (isAsyncIterable(input2)) {
      return scheduleAsyncIterable(input2, scheduler);
    }
    if (isIterable(input2)) {
      return scheduleIterable(input2, scheduler);
    }
    if (isReadableStreamLike(input2)) {
      return scheduleReadableStreamLike(input2, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input2);
}
var init_scheduled = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduled/scheduled.js"() {
    "use strict";
    init_scheduleObservable();
    init_schedulePromise();
    init_scheduleArray();
    init_scheduleIterable();
    init_scheduleAsyncIterable();
    init_isInteropObservable();
    init_isPromise();
    init_isArrayLike();
    init_isIterable();
    init_isAsyncIterable();
    init_throwUnobservableError();
    init_isReadableStreamLike();
    init_scheduleReadableStreamLike();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/from.js
function from(input2, scheduler) {
  return scheduler ? scheduled(input2, scheduler) : innerFrom(input2);
}
var init_from = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/from.js"() {
    "use strict";
    init_scheduled();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/of.js
function of(...args) {
  const scheduler = popScheduler(args);
  return from(args, scheduler);
}
var init_of = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/of.js"() {
    "use strict";
    init_args();
    init_from();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  const errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : () => errorOrErrorFactory;
  const init = (subscriber) => subscriber.error(errorFactory());
  return new Observable(scheduler ? (subscriber) => scheduler.schedule(init, 0, subscriber) : init);
}
var init_throwError = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/throwError.js"() {
    "use strict";
    init_Observable();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/util/isObservable.js
function isObservable(obj) {
  return !!obj && (obj instanceof Observable || isFunction(obj.lift) && isFunction(obj.subscribe));
}
var init_isObservable = __esm({
  "node_modules/rxjs/dist/esm/internal/util/isObservable.js"() {
    "use strict";
    init_Observable();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/util/EmptyError.js
var EmptyError;
var init_EmptyError = __esm({
  "node_modules/rxjs/dist/esm/internal/util/EmptyError.js"() {
    "use strict";
    init_createErrorClass();
    EmptyError = createErrorClass((_super) => function EmptyErrorImpl() {
      _super(this);
      this.name = "EmptyError";
      this.message = "no elements in sequence";
    });
  }
});

// node_modules/rxjs/dist/esm/internal/util/isDate.js
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}
var init_isDate = __esm({
  "node_modules/rxjs/dist/esm/internal/util/isDate.js"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/operators/map.js
function map(project, thisArg) {
  return operate((source, subscriber) => {
    let index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}
var init_map = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/map.js"() {
    "use strict";
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/util/mapOneOrManyArgs.js
function callOrApply(fn, args) {
  return isArray(args) ? fn(...args) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map((args) => callOrApply(fn, args));
}
var isArray;
var init_mapOneOrManyArgs = __esm({
  "node_modules/rxjs/dist/esm/internal/util/mapOneOrManyArgs.js"() {
    "use strict";
    init_map();
    ({ isArray } = Array);
  }
});

// node_modules/rxjs/dist/esm/internal/util/argsArgArrayOrObject.js
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    const first2 = args[0];
    if (isArray2(first2)) {
      return { args: first2, keys: null };
    }
    if (isPOJO(first2)) {
      const keys = getKeys(first2);
      return {
        args: keys.map((key) => first2[key]),
        keys
      };
    }
  }
  return { args, keys: null };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}
var isArray2, getPrototypeOf, objectProto, getKeys;
var init_argsArgArrayOrObject = __esm({
  "node_modules/rxjs/dist/esm/internal/util/argsArgArrayOrObject.js"() {
    "use strict";
    ({ isArray: isArray2 } = Array);
    ({ getPrototypeOf, prototype: objectProto, keys: getKeys } = Object);
  }
});

// node_modules/rxjs/dist/esm/internal/util/createObject.js
function createObject(keys, values) {
  return keys.reduce((result, key, i2) => (result[key] = values[i2], result), {});
}
var init_createObject = __esm({
  "node_modules/rxjs/dist/esm/internal/util/createObject.js"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/observable/combineLatest.js
function combineLatest(...args) {
  const scheduler = popScheduler(args);
  const resultSelector = popResultSelector(args);
  const { args: observables, keys } = argsArgArrayOrObject(args);
  if (observables.length === 0) {
    return from([], scheduler);
  }
  const result = new Observable(combineLatestInit(observables, scheduler, keys ? (values) => createObject(keys, values) : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform = identity) {
  return (subscriber) => {
    maybeSchedule(scheduler, () => {
      const { length } = observables;
      const values = new Array(length);
      let active = length;
      let remainingFirstValues = length;
      for (let i2 = 0; i2 < length; i2++) {
        maybeSchedule(scheduler, () => {
          const source = from(observables[i2], scheduler);
          let hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, (value) => {
            values[i2] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, () => {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}
var init_combineLatest = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/combineLatest.js"() {
    "use strict";
    init_Observable();
    init_argsArgArrayOrObject();
    init_from();
    init_identity();
    init_mapOneOrManyArgs();
    init_args();
    init_createObject();
    init_OperatorSubscriber();
    init_executeSchedule();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
  const buffer = [];
  let active = 0;
  let index = 0;
  let isComplete = false;
  const checkComplete = () => {
    if (isComplete && !buffer.length && !active) {
      subscriber.complete();
    }
  };
  const outerNext = (value) => active < concurrent ? doInnerSub(value) : buffer.push(value);
  const doInnerSub = (value) => {
    expand && subscriber.next(value);
    active++;
    let innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, (innerValue) => {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, () => {
      innerComplete = true;
    }, void 0, () => {
      if (innerComplete) {
        try {
          active--;
          while (buffer.length && active < concurrent) {
            const bufferedValue = buffer.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));
            } else {
              doInnerSub(bufferedValue);
            }
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, () => {
    isComplete = true;
    checkComplete();
  }));
  return () => {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}
var init_mergeInternals = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/mergeInternals.js"() {
    "use strict";
    init_innerFrom();
    init_executeSchedule();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent = Infinity) {
  if (isFunction(resultSelector)) {
    return mergeMap((a2, i2) => map((b2, ii2) => resultSelector(a2, b2, i2, ii2))(innerFrom(project(a2, i2))), concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));
}
var init_mergeMap = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/mergeMap.js"() {
    "use strict";
    init_map();
    init_innerFrom();
    init_lift();
    init_mergeInternals();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/mergeAll.js
function mergeAll(concurrent = Infinity) {
  return mergeMap(identity, concurrent);
}
var init_mergeAll = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/mergeAll.js"() {
    "use strict";
    init_mergeMap();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}
var init_concatAll = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/concatAll.js"() {
    "use strict";
    init_mergeAll();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/concat.js
function concat(...args) {
  return concatAll()(from(args, popScheduler(args)));
}
var init_concat = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/concat.js"() {
    "use strict";
    init_concatAll();
    init_args();
    init_from();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/defer.js
function defer(observableFactory) {
  return new Observable((subscriber) => {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}
var init_defer = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/defer.js"() {
    "use strict";
    init_Observable();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/forkJoin.js
function forkJoin(...args) {
  const resultSelector = popResultSelector(args);
  const { args: sources, keys } = argsArgArrayOrObject(args);
  const result = new Observable((subscriber) => {
    const { length } = sources;
    if (!length) {
      subscriber.complete();
      return;
    }
    const values = new Array(length);
    let remainingCompletions = length;
    let remainingEmissions = length;
    for (let sourceIndex = 0; sourceIndex < length; sourceIndex++) {
      let hasValue = false;
      innerFrom(sources[sourceIndex]).subscribe(createOperatorSubscriber(subscriber, (value) => {
        if (!hasValue) {
          hasValue = true;
          remainingEmissions--;
        }
        values[sourceIndex] = value;
      }, () => remainingCompletions--, void 0, () => {
        if (!remainingCompletions || !hasValue) {
          if (!remainingEmissions) {
            subscriber.next(keys ? createObject(keys, values) : values);
          }
          subscriber.complete();
        }
      }));
    }
  });
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
var init_forkJoin = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/forkJoin.js"() {
    "use strict";
    init_Observable();
    init_argsArgArrayOrObject();
    init_innerFrom();
    init_args();
    init_OperatorSubscriber();
    init_mapOneOrManyArgs();
    init_createObject();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/timer.js
function timer(dueTime = 0, intervalOrScheduler, scheduler = async) {
  let intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable((subscriber) => {
    let due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    let n2 = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n2++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}
var init_timer = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/timer.js"() {
    "use strict";
    init_Observable();
    init_async();
    init_isScheduler();
    init_isDate();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/interval.js
function interval(period = 0, scheduler = asyncScheduler) {
  if (period < 0) {
    period = 0;
  }
  return timer(period, period, scheduler);
}
var init_interval = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/interval.js"() {
    "use strict";
    init_async();
    init_timer();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/merge.js
function merge(...args) {
  const scheduler = popScheduler(args);
  const concurrent = popNumber(args, Infinity);
  const sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
}
var init_merge = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/merge.js"() {
    "use strict";
    init_mergeAll();
    init_innerFrom();
    init_empty();
    init_args();
    init_from();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/filter.js
function filter(predicate, thisArg) {
  return operate((source, subscriber) => {
    let index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index++) && subscriber.next(value)));
  });
}
var init_filter = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/filter.js"() {
    "use strict";
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/types.js
var init_types = __esm({
  "node_modules/rxjs/dist/esm/internal/types.js"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/operators/audit.js
function audit(durationSelector) {
  return operate((source, subscriber) => {
    let hasValue = false;
    let lastValue = null;
    let durationSubscriber = null;
    let isComplete = false;
    const endDuration = () => {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      durationSubscriber = null;
      if (hasValue) {
        hasValue = false;
        const value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
      isComplete && subscriber.complete();
    };
    const cleanupDuration = () => {
      durationSubscriber = null;
      isComplete && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      hasValue = true;
      lastValue = value;
      if (!durationSubscriber) {
        innerFrom(durationSelector(value)).subscribe(durationSubscriber = createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
      }
    }, () => {
      isComplete = true;
      (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
    }));
  });
}
var init_audit = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/audit.js"() {
    "use strict";
    init_lift();
    init_innerFrom();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/auditTime.js
function auditTime(duration, scheduler = asyncScheduler) {
  return audit(() => timer(duration, scheduler));
}
var init_auditTime = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/auditTime.js"() {
    "use strict";
    init_async();
    init_audit();
    init_timer();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/catchError.js
function catchError(selector) {
  return operate((source, subscriber) => {
    let innerSub = null;
    let syncUnsub = false;
    let handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, (err) => {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}
var init_catchError = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/catchError.js"() {
    "use strict";
    init_innerFrom();
    init_OperatorSubscriber();
    init_lift();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/scanInternals.js
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return (source, subscriber) => {
    let hasState = hasSeed;
    let state = seed;
    let index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      const i2 = index++;
      state = hasState ? accumulator(state, value, i2) : (hasState = true, value);
      emitOnNext && subscriber.next(state);
    }, emitBeforeComplete && (() => {
      hasState && subscriber.next(state);
      subscriber.complete();
    })));
  };
}
var init_scanInternals = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/scanInternals.js"() {
    "use strict";
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/concatMap.js
function concatMap(project, resultSelector) {
  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
}
var init_concatMap = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/concatMap.js"() {
    "use strict";
    init_mergeMap();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/defaultIfEmpty.js
function defaultIfEmpty(defaultValue) {
  return operate((source, subscriber) => {
    let hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      hasValue = true;
      subscriber.next(value);
    }, () => {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}
var init_defaultIfEmpty = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/defaultIfEmpty.js"() {
    "use strict";
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/take.js
function take(count) {
  return count <= 0 ? () => EMPTY : operate((source, subscriber) => {
    let seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      if (++seen <= count) {
        subscriber.next(value);
        if (count <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}
var init_take = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/take.js"() {
    "use strict";
    init_empty();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(comparator, keySelector = identity) {
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate((source, subscriber) => {
    let previousKey;
    let first2 = true;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      const currentKey = keySelector(value);
      if (first2 || !comparator(previousKey, currentKey)) {
        first2 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a2, b2) {
  return a2 === b2;
}
var init_distinctUntilChanged = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/distinctUntilChanged.js"() {
    "use strict";
    init_identity();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/throwIfEmpty.js
function throwIfEmpty(errorFactory = defaultErrorFactory) {
  return operate((source, subscriber) => {
    let hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      hasValue = true;
      subscriber.next(value);
    }, () => hasValue ? subscriber.complete() : subscriber.error(errorFactory())));
  });
}
function defaultErrorFactory() {
  return new EmptyError();
}
var init_throwIfEmpty = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/throwIfEmpty.js"() {
    "use strict";
    init_EmptyError();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/finalize.js
function finalize(callback) {
  return operate((source, subscriber) => {
    try {
      source.subscribe(subscriber);
    } finally {
      subscriber.add(callback);
    }
  });
}
var init_finalize = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/finalize.js"() {
    "use strict";
    init_lift();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/first.js
function first(predicate, defaultValue) {
  const hasDefaultValue = arguments.length >= 2;
  return (source) => source.pipe(predicate ? filter((v, i2) => predicate(v, i2, source)) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(() => new EmptyError()));
}
var init_first = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/first.js"() {
    "use strict";
    init_EmptyError();
    init_filter();
    init_take();
    init_defaultIfEmpty();
    init_throwIfEmpty();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/takeLast.js
function takeLast(count) {
  return count <= 0 ? () => EMPTY : operate((source, subscriber) => {
    let buffer = [];
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      buffer.push(value);
      count < buffer.length && buffer.shift();
    }, () => {
      for (const value of buffer) {
        subscriber.next(value);
      }
      subscriber.complete();
    }, void 0, () => {
      buffer = null;
    }));
  });
}
var init_takeLast = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/takeLast.js"() {
    "use strict";
    init_empty();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/last.js
function last2(predicate, defaultValue) {
  const hasDefaultValue = arguments.length >= 2;
  return (source) => source.pipe(predicate ? filter((v, i2) => predicate(v, i2, source)) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(() => new EmptyError()));
}
var init_last = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/last.js"() {
    "use strict";
    init_EmptyError();
    init_filter();
    init_takeLast();
    init_throwIfEmpty();
    init_defaultIfEmpty();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/pairwise.js
function pairwise() {
  return operate((source, subscriber) => {
    let prev;
    let hasPrev = false;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      const p2 = prev;
      prev = value;
      hasPrev && subscriber.next([p2, value]);
      hasPrev = true;
    }));
  });
}
var init_pairwise = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/pairwise.js"() {
    "use strict";
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/scan.js
function scan(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
}
var init_scan = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/scan.js"() {
    "use strict";
    init_lift();
    init_scanInternals();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/share.js
function share(options = {}) {
  const { connector = () => new Subject(), resetOnError = true, resetOnComplete = true, resetOnRefCountZero = true } = options;
  return (wrapperSource) => {
    let connection;
    let resetConnection;
    let subject;
    let refCount2 = 0;
    let hasCompleted = false;
    let hasErrored = false;
    const cancelReset = () => {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    const reset = () => {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    const resetAndUnsubscribe = () => {
      const conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate((source, subscriber) => {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      const dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(() => {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount2 > 0) {
        connection = new SafeSubscriber({
          next: (value) => dest.next(value),
          error: (err) => {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: () => {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on, ...args) {
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  const onSubscriber = new SafeSubscriber({
    next: () => {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom(on(...args)).subscribe(onSubscriber);
}
var init_share = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/share.js"() {
    "use strict";
    init_innerFrom();
    init_Subject();
    init_Subscriber();
    init_lift();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/shareReplay.js
function shareReplay(configOrBufferSize, windowTime, scheduler) {
  let bufferSize;
  let refCount2 = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    ({ bufferSize = Infinity, windowTime = Infinity, refCount: refCount2 = false, scheduler } = configOrBufferSize);
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share({
    connector: () => new ReplaySubject(bufferSize, windowTime, scheduler),
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount2
  });
}
var init_shareReplay = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/shareReplay.js"() {
    "use strict";
    init_ReplaySubject();
    init_share();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/startWith.js
function startWith(...values) {
  const scheduler = popScheduler(values);
  return operate((source, subscriber) => {
    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
  });
}
var init_startWith = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/startWith.js"() {
    "use strict";
    init_concat();
    init_args();
    init_lift();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  return operate((source, subscriber) => {
    let innerSubscriber = null;
    let index = 0;
    let isComplete = false;
    const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      let innerIndex = 0;
      const outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue), () => {
        innerSubscriber = null;
        checkComplete();
      }));
    }, () => {
      isComplete = true;
      checkComplete();
    }));
  });
}
var init_switchMap = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/switchMap.js"() {
    "use strict";
    init_innerFrom();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return operate((source, subscriber) => {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}
var init_takeUntil = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/takeUntil.js"() {
    "use strict";
    init_lift();
    init_OperatorSubscriber();
    init_innerFrom();
    init_noop();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/tap.js
function tap(observerOrNext, error, complete) {
  const tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate((source, subscriber) => {
    var _a2;
    (_a2 = tapObserver.subscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
    let isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      var _a3;
      (_a3 = tapObserver.next) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver, value);
      subscriber.next(value);
    }, () => {
      var _a3;
      isUnsub = false;
      (_a3 = tapObserver.complete) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver);
      subscriber.complete();
    }, (err) => {
      var _a3;
      isUnsub = false;
      (_a3 = tapObserver.error) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver, err);
      subscriber.error(err);
    }, () => {
      var _a3, _b;
      if (isUnsub) {
        (_a3 = tapObserver.unsubscribe) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}
var init_tap = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/tap.js"() {
    "use strict";
    init_isFunction();
    init_lift();
    init_OperatorSubscriber();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm/index.js
var init_esm = __esm({
  "node_modules/rxjs/dist/esm/index.js"() {
    "use strict";
    init_Observable();
    init_ConnectableObservable();
    init_Subject();
    init_BehaviorSubject();
    init_asap();
    init_animationFrame();
    init_Subscription();
    init_pipe();
    init_isObservable();
    init_EmptyError();
    init_combineLatest();
    init_concat();
    init_defer();
    init_forkJoin();
    init_from();
    init_interval();
    init_merge();
    init_of();
    init_throwError();
    init_empty();
    init_types();
  }
});

// node_modules/@angular/core/fesm2022/untracked.mjs
function createLinkedSignal(sourceFn, computationFn, equalityFn) {
  const node = Object.create(LINKED_SIGNAL_NODE);
  node.source = sourceFn;
  node.computation = computationFn;
  if (equalityFn != void 0) {
    node.equal = equalityFn;
  }
  const linkedSignalGetter = () => {
    producerUpdateValueVersion(node);
    producerAccessed(node);
    if (node.value === ERRORED) {
      throw node.error;
    }
    return node.value;
  };
  const getter = linkedSignalGetter;
  getter[SIGNAL] = node;
  if (typeof ngDevMode !== "undefined" && ngDevMode) {
    const debugName = node.debugName ? " (" + node.debugName + ")" : "";
    getter.toString = () => `[LinkedSignal${debugName}: ${node.value}]`;
  }
  runPostProducerCreatedFn(node);
  return getter;
}
function linkedSignalSetFn(node, newValue) {
  producerUpdateValueVersion(node);
  signalSetFn(node, newValue);
  producerMarkClean(node);
}
function linkedSignalUpdateFn(node, updater) {
  producerUpdateValueVersion(node);
  signalUpdateFn(node, updater);
  producerMarkClean(node);
}
function untracked(nonReactiveReadsFn) {
  const prevConsumer = setActiveConsumer(null);
  try {
    return nonReactiveReadsFn();
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
var LINKED_SIGNAL_NODE;
var init_untracked = __esm({
  "node_modules/@angular/core/fesm2022/untracked.mjs"() {
    "use strict";
    init_signal();
    LINKED_SIGNAL_NODE = /* @__PURE__ */ (() => {
      return __spreadProps(__spreadValues({}, REACTIVE_NODE), {
        value: UNSET,
        dirty: true,
        error: null,
        equal: defaultEquals,
        kind: "linkedSignal",
        producerMustRecompute(node) {
          return node.value === UNSET || node.value === COMPUTING;
        },
        producerRecomputeValue(node) {
          if (node.value === COMPUTING) {
            throw new Error(typeof ngDevMode !== "undefined" && ngDevMode ? "Detected cycle in computations." : "");
          }
          const oldValue = node.value;
          node.value = COMPUTING;
          const prevConsumer = consumerBeforeComputation(node);
          let newValue;
          try {
            const newSourceValue = node.source();
            const prev = oldValue === UNSET || oldValue === ERRORED ? void 0 : {
              source: node.sourceValue,
              value: oldValue
            };
            newValue = node.computation(newSourceValue, prev);
            node.sourceValue = newSourceValue;
          } catch (err) {
            newValue = ERRORED;
            node.error = err;
          } finally {
            consumerAfterComputation(node, prevConsumer);
          }
          if (oldValue !== UNSET && newValue !== ERRORED && node.equal(oldValue, newValue)) {
            node.value = oldValue;
            return;
          }
          node.value = newValue;
          node.version++;
        }
      });
    })();
  }
});

// node_modules/@angular/core/fesm2022/primitives/signals.mjs
var init_signals = __esm({
  "node_modules/@angular/core/fesm2022/primitives/signals.mjs"() {
    "use strict";
    init_signal();
  }
});

// node_modules/@angular/core/fesm2022/primitives/di.mjs
var init_di = __esm({
  "node_modules/@angular/core/fesm2022/primitives/di.mjs"() {
    "use strict";
    init_not_found();
  }
});

// node_modules/@angular/core/fesm2022/root_effect_scheduler.mjs
function formatRuntimeErrorCode(code) {
  return `NG0${Math.abs(code)}`;
}
function formatRuntimeError(code, message) {
  const fullCode = formatRuntimeErrorCode(code);
  let errorMessage = `${fullCode}${message ? ": " + message : ""}`;
  if (ngDevMode && code < 0) {
    const addPeriodSeparator = !errorMessage.match(/[.,;!?\n]$/);
    const separator = addPeriodSeparator ? "." : "";
    errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;
  }
  return errorMessage;
}
function ngDevModeResetPerfCounters() {
  const locationString = typeof location !== "undefined" ? location.toString() : "";
  const newCounters = {
    hydratedNodes: 0,
    hydratedComponents: 0,
    dehydratedViewsRemoved: 0,
    dehydratedViewsCleanupRuns: 0,
    componentsSkippedHydration: 0,
    deferBlocksWithIncrementalHydration: 0
  };
  const allowNgDevModeTrue = locationString.indexOf("ngDevMode=false") === -1;
  if (!allowNgDevModeTrue) {
    _global["ngDevMode"] = false;
  } else {
    if (typeof _global["ngDevMode"] !== "object") {
      _global["ngDevMode"] = {};
    }
    Object.assign(_global["ngDevMode"], newCounters);
  }
  return newCounters;
}
function initNgDevMode() {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (typeof ngDevMode !== "object" || Object.keys(ngDevMode).length === 0) {
      ngDevModeResetPerfCounters();
    }
    return typeof ngDevMode !== "undefined" && !!ngDevMode;
  }
  return false;
}
function getClosureSafeProperty(objWithPropertyToExtract) {
  for (let key in objWithPropertyToExtract) {
    if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
      return key;
    }
  }
  throw Error(typeof ngDevMode !== "undefined" && ngDevMode ? "Could not find renamed property on target object." : "");
}
function fillProperties(target, source) {
  for (const key in source) {
    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
      target[key] = source[key];
    }
  }
}
function stringify(token) {
  if (typeof token === "string") {
    return token;
  }
  if (Array.isArray(token)) {
    return `[${token.map(stringify).join(", ")}]`;
  }
  if (token == null) {
    return "" + token;
  }
  const name = token.overriddenName || token.name;
  if (name) {
    return `${name}`;
  }
  const result = token.toString();
  if (result == null) {
    return "" + result;
  }
  const newLineIndex = result.indexOf("\n");
  return newLineIndex >= 0 ? result.slice(0, newLineIndex) : result;
}
function concatStringsWithSpace(before, after) {
  if (!before)
    return after || "";
  if (!after)
    return before;
  return `${before} ${after}`;
}
function forwardRef(forwardRefFn) {
  forwardRefFn.__forward_ref__ = forwardRef;
  forwardRefFn.toString = function() {
    return stringify(this());
  };
  return forwardRefFn;
}
function resolveForwardRef(type) {
  return isForwardRef(type) ? type() : type;
}
function isForwardRef(fn) {
  return typeof fn === "function" && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;
}
function assertNumber(actual, msg) {
  if (!(typeof actual === "number")) {
    throwError2(msg, typeof actual, "number", "===");
  }
}
function assertNumberInRange(actual, minInclusive, maxInclusive) {
  assertNumber(actual, "Expected a number");
  assertLessThanOrEqual(actual, maxInclusive, "Expected number to be less than or equal to");
  assertGreaterThanOrEqual(actual, minInclusive, "Expected number to be greater than or equal to");
}
function assertString(actual, msg) {
  if (!(typeof actual === "string")) {
    throwError2(msg, actual === null ? "null" : typeof actual, "string", "===");
  }
}
function assertFunction(actual, msg) {
  if (!(typeof actual === "function")) {
    throwError2(msg, actual === null ? "null" : typeof actual, "function", "===");
  }
}
function assertEqual(actual, expected, msg) {
  if (!(actual == expected)) {
    throwError2(msg, actual, expected, "==");
  }
}
function assertNotEqual(actual, expected, msg) {
  if (!(actual != expected)) {
    throwError2(msg, actual, expected, "!=");
  }
}
function assertSame(actual, expected, msg) {
  if (!(actual === expected)) {
    throwError2(msg, actual, expected, "===");
  }
}
function assertNotSame(actual, expected, msg) {
  if (!(actual !== expected)) {
    throwError2(msg, actual, expected, "!==");
  }
}
function assertLessThan(actual, expected, msg) {
  if (!(actual < expected)) {
    throwError2(msg, actual, expected, "<");
  }
}
function assertLessThanOrEqual(actual, expected, msg) {
  if (!(actual <= expected)) {
    throwError2(msg, actual, expected, "<=");
  }
}
function assertGreaterThan(actual, expected, msg) {
  if (!(actual > expected)) {
    throwError2(msg, actual, expected, ">");
  }
}
function assertGreaterThanOrEqual(actual, expected, msg) {
  if (!(actual >= expected)) {
    throwError2(msg, actual, expected, ">=");
  }
}
function assertDefined(actual, msg) {
  if (actual == null) {
    throwError2(msg, actual, null, "!=");
  }
}
function throwError2(msg, actual, expected, comparison) {
  throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? "" : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));
}
function assertDomNode(node) {
  if (!(node instanceof Node)) {
    throwError2(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);
  }
}
function assertElement(node) {
  if (!(node instanceof Element)) {
    throwError2(`The provided value must be an element but got ${stringify(node)}`);
  }
}
function assertIndexInRange(arr, index) {
  assertDefined(arr, "Array must be defined.");
  const maxLen = arr.length;
  if (index < 0 || index >= maxLen) {
    throwError2(`Index expected to be less than ${maxLen} but got ${index}`);
  }
}
function assertOneOf(value, ...validValues) {
  if (validValues.indexOf(value) !== -1)
    return true;
  throwError2(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);
}
function assertNotReactive(fn) {
  if (getActiveConsumer() !== null) {
    throwError2(`${fn}() should never be called in a reactive context.`);
  }
}
function \u0275\u0275defineInjectable(opts) {
  return {
    token: opts.token,
    providedIn: opts.providedIn || null,
    factory: opts.factory,
    value: void 0
  };
}
function \u0275\u0275defineInjector(options) {
  return { providers: options.providers || [], imports: options.imports || [] };
}
function getInjectableDef(type) {
  return getOwnDefinition(type, NG_PROV_DEF);
}
function isInjectable(type) {
  return getInjectableDef(type) !== null;
}
function getOwnDefinition(type, field) {
  return type.hasOwnProperty(field) && type[field] || null;
}
function getInheritedInjectableDef(type) {
  const def = type?.[NG_PROV_DEF] ?? null;
  if (def) {
    ngDevMode && console.warn(`DEPRECATED: DI is instantiating a token "${type.name}" that inherits its @Injectable decorator but does not provide one itself.
This will become an error in a future version of Angular. Please add @Injectable() to the "${type.name}" class.`);
    return def;
  } else {
    return null;
  }
}
function getInjectorDef(type) {
  return type && type.hasOwnProperty(NG_INJ_DEF) ? type[NG_INJ_DEF] : null;
}
function getInjectorProfilerContext() {
  !ngDevMode && throwError2("getInjectorProfilerContext should never be called in production mode");
  return _injectorProfilerContext;
}
function setInjectorProfilerContext(context2) {
  !ngDevMode && throwError2("setInjectorProfilerContext should never be called in production mode");
  const previous = _injectorProfilerContext;
  _injectorProfilerContext = context2;
  return previous;
}
function removeProfiler(profiler2) {
  const profilerIdx = injectorProfilerCallbacks.indexOf(profiler2);
  if (profilerIdx !== -1) {
    injectorProfilerCallbacks.splice(profilerIdx, 1);
  }
}
function setInjectorProfiler(injectorProfiler2) {
  !ngDevMode && throwError2("setInjectorProfiler should never be called in production mode");
  if (injectorProfiler2 !== null) {
    if (!injectorProfilerCallbacks.includes(injectorProfiler2)) {
      injectorProfilerCallbacks.push(injectorProfiler2);
    }
    return () => removeProfiler(injectorProfiler2);
  } else {
    injectorProfilerCallbacks.length = 0;
    return NOOP_PROFILER_REMOVAL;
  }
}
function injectorProfiler(event) {
  !ngDevMode && throwError2("Injector profiler should never be called in production mode");
  for (let i2 = 0; i2 < injectorProfilerCallbacks.length; i2++) {
    const injectorProfilerCallback = injectorProfilerCallbacks[i2];
    injectorProfilerCallback(event);
  }
}
function emitProviderConfiguredEvent(eventProvider, isViewProvider = false) {
  !ngDevMode && throwError2("Injector profiler should never be called in production mode");
  let token;
  if (typeof eventProvider === "function") {
    token = eventProvider;
  } else if (eventProvider instanceof InjectionToken) {
    token = eventProvider;
  } else {
    token = resolveForwardRef(eventProvider.provide);
  }
  let provider = eventProvider;
  if (eventProvider instanceof InjectionToken) {
    provider = eventProvider.\u0275prov || eventProvider;
  }
  injectorProfiler({
    type: 2,
    context: getInjectorProfilerContext(),
    providerRecord: { token, provider, isViewProvider }
  });
}
function emitInjectorToCreateInstanceEvent(token) {
  !ngDevMode && throwError2("Injector profiler should never be called in production mode");
  injectorProfiler({
    type: 4,
    context: getInjectorProfilerContext(),
    token
  });
}
function emitInstanceCreatedByInjectorEvent(instance) {
  !ngDevMode && throwError2("Injector profiler should never be called in production mode");
  injectorProfiler({
    type: 1,
    context: getInjectorProfilerContext(),
    instance: { value: instance }
  });
}
function emitInjectEvent(token, value, flags) {
  !ngDevMode && throwError2("Injector profiler should never be called in production mode");
  injectorProfiler({
    type: 0,
    context: getInjectorProfilerContext(),
    service: { token, value, flags }
  });
}
function emitEffectCreatedEvent(effect2) {
  !ngDevMode && throwError2("Injector profiler should never be called in production mode");
  injectorProfiler({
    type: 3,
    context: getInjectorProfilerContext(),
    effect: effect2
  });
}
function runInInjectorProfilerContext(injector, token, callback) {
  !ngDevMode && throwError2("runInInjectorProfilerContext should never be called in production mode");
  const prevInjectContext = setInjectorProfilerContext({ injector, token });
  try {
    callback();
  } finally {
    setInjectorProfilerContext(prevInjectContext);
  }
}
function isEnvironmentProviders(value) {
  return value && !!value.\u0275providers;
}
function renderStringify(value) {
  if (typeof value === "string")
    return value;
  if (value == null)
    return "";
  return String(value);
}
function stringifyForError(value) {
  if (typeof value === "function")
    return value.name || value.toString();
  if (typeof value === "object" && value != null && typeof value.type === "function") {
    return value.type.name || value.type.toString();
  }
  return renderStringify(value);
}
function cyclicDependencyError(token, path) {
  const message = ngDevMode ? `Circular dependency detected for \`${token}\`.` : "";
  return createRuntimeError(message, -200, path);
}
function cyclicDependencyErrorWithDetails(token, path) {
  return augmentRuntimeError(cyclicDependencyError(token, path), null);
}
function throwMixedMultiProviderError() {
  throw new Error(`Cannot mix multi providers and regular providers`);
}
function throwInvalidProviderError(ngModuleType, providers, provider) {
  if (ngModuleType && providers) {
    const providerDetail = providers.map((v) => v == provider ? "?" + provider + "?" : "...");
    throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(", ")}]`);
  } else if (isEnvironmentProviders(provider)) {
    if (provider.\u0275fromNgModule) {
      throw new RuntimeError(207, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);
    } else {
      throw new RuntimeError(207, `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`);
    }
  } else {
    throw new Error("Invalid provider");
  }
}
function throwProviderNotFoundError(token, injectorName) {
  const errorMessage = ngDevMode && `No provider for ${stringifyForError(token)} found${injectorName ? ` in ${injectorName}` : ""}`;
  throw new RuntimeError(-201, errorMessage);
}
function prependTokenToDependencyPath(error, token) {
  error[NG_TOKEN_PATH] ??= [];
  const currentPath = error[NG_TOKEN_PATH];
  let pathStr;
  if (typeof token === "object" && "multi" in token && token?.multi === true) {
    assertDefined(token.provide, "Token with multi: true should have a provide property");
    pathStr = stringifyForError(token.provide);
  } else {
    pathStr = stringifyForError(token);
  }
  if (currentPath[0] !== pathStr) {
    error[NG_TOKEN_PATH].unshift(pathStr);
  }
}
function augmentRuntimeError(error, source) {
  const tokenPath = error[NG_TOKEN_PATH];
  const errorCode = error[NG_RUNTIME_ERROR_CODE];
  const message = error[NG_RUNTIME_ERROR_MESSAGE] || error.message;
  error.message = formatErrorMessage(message, errorCode, tokenPath, source);
  return error;
}
function createRuntimeError(message, code, path) {
  const error = new RuntimeError(code, message);
  error[NG_RUNTIME_ERROR_CODE] = code;
  error[NG_RUNTIME_ERROR_MESSAGE] = message;
  if (path) {
    error[NG_TOKEN_PATH] = path;
  }
  return error;
}
function getRuntimeErrorCode(error) {
  return error[NG_RUNTIME_ERROR_CODE];
}
function formatErrorMessage(text, code, path = [], source = null) {
  let pathDetails = "";
  if (path && path.length > 1) {
    pathDetails = ` Path: ${path.join(" -> ")}.`;
  }
  const sourceDetails = source ? ` Source: ${source}.` : "";
  return formatRuntimeError(code, `${text}${sourceDetails}${pathDetails}`);
}
function getInjectImplementation() {
  return _injectImplementation;
}
function setInjectImplementation(impl) {
  const previous = _injectImplementation;
  _injectImplementation = impl;
  return previous;
}
function injectRootLimpMode(token, notFoundValue, flags) {
  const injectableDef = getInjectableDef(token);
  if (injectableDef && injectableDef.providedIn == "root") {
    return injectableDef.value === void 0 ? injectableDef.value = injectableDef.factory() : injectableDef.value;
  }
  if (flags & 8)
    return null;
  if (notFoundValue !== void 0)
    return notFoundValue;
  throwProviderNotFoundError(token, "Injector");
}
function assertInjectImplementationNotEqual(fn) {
  ngDevMode && assertNotEqual(_injectImplementation, fn, "Calling \u0275\u0275inject would cause infinite recursion");
}
function injectInjectorOnly(token, flags = 0) {
  const currentInjector = getCurrentInjector();
  if (currentInjector === void 0) {
    throw new RuntimeError(-203, ngDevMode && `The \`${stringify(token)}\` token injection failed. \`inject()\` function must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \`runInInjectionContext\`.`);
  } else if (currentInjector === null) {
    return injectRootLimpMode(token, void 0, flags);
  } else {
    const options = convertToInjectOptions(flags);
    const value = currentInjector.retrieve(token, options);
    ngDevMode && emitInjectEvent(token, value, flags);
    if (isNotFound(value)) {
      if (options.optional) {
        return null;
      }
      throw value;
    }
    return value;
  }
}
function \u0275\u0275inject(token, flags = 0) {
  return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);
}
function \u0275\u0275invalidFactoryDep(index) {
  throw new RuntimeError(202, ngDevMode && `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.
This can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.

Please check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);
}
function inject2(token, options) {
  return \u0275\u0275inject(token, convertToBitFlags(options));
}
function convertToBitFlags(flags) {
  if (typeof flags === "undefined" || typeof flags === "number") {
    return flags;
  }
  return 0 | // comment to force a line break in the formatter
  (flags.optional && 8) | (flags.host && 1) | (flags.self && 2) | (flags.skipSelf && 4);
}
function convertToInjectOptions(flags) {
  return {
    optional: !!(flags & 8),
    host: !!(flags & 1),
    self: !!(flags & 2),
    skipSelf: !!(flags & 4)
  };
}
function injectArgs(types) {
  const args = [];
  for (let i2 = 0; i2 < types.length; i2++) {
    const arg = resolveForwardRef(types[i2]);
    if (Array.isArray(arg)) {
      if (arg.length === 0) {
        throw new RuntimeError(900, ngDevMode && "Arguments array must have arguments.");
      }
      let type = void 0;
      let flags = 0;
      for (let j2 = 0; j2 < arg.length; j2++) {
        const meta = arg[j2];
        const flag = getInjectFlag(meta);
        if (typeof flag === "number") {
          if (flag === -1) {
            type = meta.token;
          } else {
            flags |= flag;
          }
        } else {
          type = meta;
        }
      }
      args.push(\u0275\u0275inject(type, flags));
    } else {
      args.push(\u0275\u0275inject(arg));
    }
  }
  return args;
}
function attachInjectFlag(decorator, flag) {
  decorator[DI_DECORATOR_FLAG] = flag;
  decorator.prototype[DI_DECORATOR_FLAG] = flag;
  return decorator;
}
function getInjectFlag(token) {
  return token[DI_DECORATOR_FLAG];
}
function getFactoryDef(type, throwNotFound) {
  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);
  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {
    throw new Error(`Type ${stringify(type)} does not have '\u0275fac' property.`);
  }
  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;
}
function arrayEquals(a2, b2, identityAccessor) {
  if (a2.length !== b2.length)
    return false;
  for (let i2 = 0; i2 < a2.length; i2++) {
    let valueA = a2[i2];
    let valueB = b2[i2];
    if (identityAccessor) {
      valueA = identityAccessor(valueA);
      valueB = identityAccessor(valueB);
    }
    if (valueB !== valueA) {
      return false;
    }
  }
  return true;
}
function flatten(list) {
  return list.flat(Number.POSITIVE_INFINITY);
}
function deepForEach(input2, fn) {
  input2.forEach((value) => Array.isArray(value) ? deepForEach(value, fn) : fn(value));
}
function addToArray(arr, index, value) {
  if (index >= arr.length) {
    arr.push(value);
  } else {
    arr.splice(index, 0, value);
  }
}
function removeFromArray(arr, index) {
  if (index >= arr.length - 1) {
    return arr.pop();
  } else {
    return arr.splice(index, 1)[0];
  }
}
function newArray(size, value) {
  const list = [];
  for (let i2 = 0; i2 < size; i2++) {
    list.push(value);
  }
  return list;
}
function arraySplice(array, index, count) {
  const length = array.length - count;
  while (index < length) {
    array[index] = array[index + count];
    index++;
  }
  while (count--) {
    array.pop();
  }
}
function arrayInsert2(array, index, value1, value2) {
  ngDevMode && assertLessThanOrEqual(index, array.length, "Can't insert past array end.");
  let end = array.length;
  if (end == index) {
    array.push(value1, value2);
  } else if (end === 1) {
    array.push(value2, array[0]);
    array[0] = value1;
  } else {
    end--;
    array.push(array[end - 1], array[end]);
    while (end > index) {
      const previousEnd = end - 2;
      array[end] = array[previousEnd];
      end--;
    }
    array[index] = value1;
    array[index + 1] = value2;
  }
}
function keyValueArraySet(keyValueArray, key, value) {
  let index = keyValueArrayIndexOf(keyValueArray, key);
  if (index >= 0) {
    keyValueArray[index | 1] = value;
  } else {
    index = ~index;
    arrayInsert2(keyValueArray, index, key, value);
  }
  return index;
}
function keyValueArrayGet(keyValueArray, key) {
  const index = keyValueArrayIndexOf(keyValueArray, key);
  if (index >= 0) {
    return keyValueArray[index | 1];
  }
  return void 0;
}
function keyValueArrayIndexOf(keyValueArray, key) {
  return _arrayIndexOfSorted(keyValueArray, key, 1);
}
function _arrayIndexOfSorted(array, value, shift) {
  ngDevMode && assertEqual(Array.isArray(array), true, "Expecting an array");
  let start = 0;
  let end = array.length >> shift;
  while (end !== start) {
    const middle = start + (end - start >> 1);
    const current = array[middle << shift];
    if (value === current) {
      return middle << shift;
    } else if (current > value) {
      end = middle;
    } else {
      start = middle + 1;
    }
  }
  return ~(end << shift);
}
function getNgModuleDef(type) {
  return type[NG_MOD_DEF] || null;
}
function getNgModuleDefOrThrow(type) {
  const ngModuleDef = getNgModuleDef(type);
  if (!ngModuleDef) {
    throw new RuntimeError(915, (typeof ngDevMode === "undefined" || ngDevMode) && `Type ${stringify(type)} does not have '\u0275mod' property.`);
  }
  return ngModuleDef;
}
function getComponentDef(type) {
  return type[NG_COMP_DEF] || null;
}
function getDirectiveDefOrThrow(type) {
  const def = getDirectiveDef(type);
  if (!def) {
    throw new RuntimeError(916, (typeof ngDevMode === "undefined" || ngDevMode) && `Type ${stringify(type)} does not have '\u0275dir' property.`);
  }
  return def;
}
function getDirectiveDef(type) {
  return type[NG_DIR_DEF] || null;
}
function getPipeDef(type) {
  return type[NG_PIPE_DEF] || null;
}
function isStandalone(type) {
  const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);
  return def !== null && def.standalone;
}
function makeEnvironmentProviders(providers) {
  return {
    \u0275providers: providers
  };
}
function provideEnvironmentInitializer(initializerFn) {
  return makeEnvironmentProviders([
    {
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useValue: initializerFn
    }
  ]);
}
function importProvidersFrom(...sources) {
  return {
    \u0275providers: internalImportProvidersFrom(true, sources),
    \u0275fromNgModule: true
  };
}
function internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {
  const providersOut = [];
  const dedup = /* @__PURE__ */ new Set();
  let injectorTypesWithProviders;
  const collectProviders = (provider) => {
    providersOut.push(provider);
  };
  deepForEach(sources, (source) => {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && checkForStandaloneCmp) {
      const cmpDef = getComponentDef(source);
      if (cmpDef?.standalone) {
        throw new RuntimeError(800, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component "${stringifyForError(source)}"`);
      }
    }
    const internalSource = source;
    if (walkProviderTree(internalSource, collectProviders, [], dedup)) {
      injectorTypesWithProviders ||= [];
      injectorTypesWithProviders.push(internalSource);
    }
  });
  if (injectorTypesWithProviders !== void 0) {
    processInjectorTypesWithProviders(injectorTypesWithProviders, collectProviders);
  }
  return providersOut;
}
function processInjectorTypesWithProviders(typesWithProviders, visitor) {
  for (let i2 = 0; i2 < typesWithProviders.length; i2++) {
    const { ngModule, providers } = typesWithProviders[i2];
    deepForEachProvider(providers, (provider) => {
      ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);
      visitor(provider, ngModule);
    });
  }
}
function walkProviderTree(container, visitor, parents, dedup) {
  container = resolveForwardRef(container);
  if (!container)
    return false;
  let defType = null;
  let injDef = getInjectorDef(container);
  const cmpDef = !injDef && getComponentDef(container);
  if (!injDef && !cmpDef) {
    const ngModule = container.ngModule;
    injDef = getInjectorDef(ngModule);
    if (injDef) {
      defType = ngModule;
    } else {
      return false;
    }
  } else if (cmpDef && !cmpDef.standalone) {
    return false;
  } else {
    defType = container;
  }
  if (ngDevMode && parents.indexOf(defType) !== -1) {
    const defName = stringify(defType);
    const path = parents.map(stringify).concat(defName);
    throw cyclicDependencyErrorWithDetails(defName, path);
  }
  const isDuplicate = dedup.has(defType);
  if (cmpDef) {
    if (isDuplicate) {
      return false;
    }
    dedup.add(defType);
    if (cmpDef.dependencies) {
      const deps = typeof cmpDef.dependencies === "function" ? cmpDef.dependencies() : cmpDef.dependencies;
      for (const dep of deps) {
        walkProviderTree(dep, visitor, parents, dedup);
      }
    }
  } else if (injDef) {
    if (injDef.imports != null && !isDuplicate) {
      ngDevMode && parents.push(defType);
      dedup.add(defType);
      let importTypesWithProviders;
      try {
        deepForEach(injDef.imports, (imported) => {
          if (walkProviderTree(imported, visitor, parents, dedup)) {
            importTypesWithProviders ||= [];
            importTypesWithProviders.push(imported);
          }
        });
      } finally {
        ngDevMode && parents.pop();
      }
      if (importTypesWithProviders !== void 0) {
        processInjectorTypesWithProviders(importTypesWithProviders, visitor);
      }
    }
    if (!isDuplicate) {
      const factory = getFactoryDef(defType) || (() => new defType());
      visitor({ provide: defType, useFactory: factory, deps: EMPTY_ARRAY }, defType);
      visitor({ provide: INJECTOR_DEF_TYPES, useValue: defType, multi: true }, defType);
      visitor({ provide: ENVIRONMENT_INITIALIZER, useValue: () => \u0275\u0275inject(defType), multi: true }, defType);
    }
    const defProviders = injDef.providers;
    if (defProviders != null && !isDuplicate) {
      const injectorType = container;
      deepForEachProvider(defProviders, (provider) => {
        ngDevMode && validateProvider(provider, defProviders, injectorType);
        visitor(provider, injectorType);
      });
    }
  } else {
    return false;
  }
  return defType !== container && container.providers !== void 0;
}
function validateProvider(provider, providers, containerType) {
  if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) || isExistingProvider(provider)) {
    return;
  }
  const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
  if (!classRef) {
    throwInvalidProviderError(containerType, providers, provider);
  }
}
function deepForEachProvider(providers, fn) {
  for (let provider of providers) {
    if (isEnvironmentProviders(provider)) {
      provider = provider.\u0275providers;
    }
    if (Array.isArray(provider)) {
      deepForEachProvider(provider, fn);
    } else {
      fn(provider);
    }
  }
}
function isValueProvider(value) {
  return value !== null && typeof value == "object" && USE_VALUE in value;
}
function isExistingProvider(value) {
  return !!(value && value.useExisting);
}
function isFactoryProvider(value) {
  return !!(value && value.useFactory);
}
function isTypeProvider(value) {
  return typeof value === "function";
}
function isClassProvider(value) {
  return !!value.useClass;
}
function getNullInjector() {
  if (NULL_INJECTOR === void 0) {
    NULL_INJECTOR = new NullInjector();
  }
  return NULL_INJECTOR;
}
function injectableDefOrInjectorDefFactory(token) {
  const injectableDef = getInjectableDef(token);
  const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);
  if (factory !== null) {
    return factory;
  }
  if (token instanceof InjectionToken) {
    throw new RuntimeError(204, ngDevMode && `Token ${stringify(token)} is missing a \u0275prov definition.`);
  }
  if (token instanceof Function) {
    return getUndecoratedInjectableFactory(token);
  }
  throw new RuntimeError(204, ngDevMode && "unreachable");
}
function getUndecoratedInjectableFactory(token) {
  const paramLength = token.length;
  if (paramLength > 0) {
    throw new RuntimeError(204, ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${newArray(paramLength, "?").join(", ")}).`);
  }
  const inheritedInjectableDef = getInheritedInjectableDef(token);
  if (inheritedInjectableDef !== null) {
    return () => inheritedInjectableDef.factory(token);
  } else {
    return () => new token();
  }
}
function providerToRecord(provider) {
  if (isValueProvider(provider)) {
    return makeRecord(void 0, provider.useValue);
  } else {
    const factory = providerToFactory(provider);
    return makeRecord(factory, NOT_YET);
  }
}
function providerToFactory(provider, ngModuleType, providers) {
  let factory = void 0;
  if (ngDevMode && isEnvironmentProviders(provider)) {
    throwInvalidProviderError(void 0, providers, provider);
  }
  if (isTypeProvider(provider)) {
    const unwrappedProvider = resolveForwardRef(provider);
    return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);
  } else {
    if (isValueProvider(provider)) {
      factory = () => resolveForwardRef(provider.useValue);
    } else if (isFactoryProvider(provider)) {
      factory = () => provider.useFactory(...injectArgs(provider.deps || []));
    } else if (isExistingProvider(provider)) {
      factory = (_2, flags) => \u0275\u0275inject(resolveForwardRef(provider.useExisting), flags !== void 0 && flags & 8 ? 8 : void 0);
    } else {
      const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
      if (ngDevMode && !classRef) {
        throwInvalidProviderError(ngModuleType, providers, provider);
      }
      if (hasDeps(provider)) {
        factory = () => new classRef(...injectArgs(provider.deps));
      } else {
        return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);
      }
    }
  }
  return factory;
}
function assertNotDestroyed(injector) {
  if (injector.destroyed) {
    throw new RuntimeError(205, ngDevMode && "Injector has already been destroyed.");
  }
}
function makeRecord(factory, value, multi = false) {
  return {
    factory,
    value,
    multi: multi ? [] : void 0
  };
}
function hasDeps(value) {
  return !!value.deps;
}
function hasOnDestroy(value) {
  return value !== null && typeof value === "object" && typeof value.ngOnDestroy === "function";
}
function couldBeInjectableType(value) {
  return typeof value === "function" || typeof value === "object" && value.ngMetadataName === "InjectionToken";
}
function forEachSingleProvider(providers, fn) {
  for (const provider of providers) {
    if (Array.isArray(provider)) {
      forEachSingleProvider(provider, fn);
    } else if (provider && isEnvironmentProviders(provider)) {
      forEachSingleProvider(provider.\u0275providers, fn);
    } else {
      fn(provider);
    }
  }
}
function runInInjectionContext(injector, fn) {
  let internalInjector;
  if (injector instanceof R3Injector) {
    assertNotDestroyed(injector);
    internalInjector = injector;
  } else {
    internalInjector = new RetrievingInjector(injector);
  }
  let prevInjectorProfilerContext;
  if (ngDevMode) {
    prevInjectorProfilerContext = setInjectorProfilerContext({ injector, token: null });
  }
  const prevInjector = setCurrentInjector(internalInjector);
  const previousInjectImplementation = setInjectImplementation(void 0);
  try {
    return fn();
  } finally {
    setCurrentInjector(prevInjector);
    ngDevMode && setInjectorProfilerContext(prevInjectorProfilerContext);
    setInjectImplementation(previousInjectImplementation);
  }
}
function isInInjectionContext() {
  return getInjectImplementation() !== void 0 || getCurrentInjector() != null;
}
function assertInInjectionContext(debugFn) {
  if (!isInInjectionContext()) {
    throw new RuntimeError(-203, ngDevMode && debugFn.name + "() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`");
  }
}
function isLView(value) {
  return Array.isArray(value) && typeof value[TYPE] === "object";
}
function isLContainer(value) {
  return Array.isArray(value) && value[TYPE] === true;
}
function isContentQueryHost(tNode) {
  return (tNode.flags & 4) !== 0;
}
function isComponentHost(tNode) {
  return tNode.componentOffset > -1;
}
function isDirectiveHost(tNode) {
  return (tNode.flags & 1) === 1;
}
function isComponentDef(def) {
  return !!def.template;
}
function isRootView(target) {
  return (target[FLAGS] & 512) !== 0;
}
function isDestroyed(lView) {
  return (lView[FLAGS] & 256) === 256;
}
function assertTNodeForLView(tNode, lView) {
  assertTNodeForTView(tNode, lView[TVIEW]);
}
function assertTNodeCreationIndex(lView, index) {
  const adjustedIndex = index + HEADER_OFFSET;
  assertIndexInRange(lView, adjustedIndex);
  assertLessThan(adjustedIndex, lView[TVIEW].bindingStartIndex, "TNodes should be created before any bindings");
}
function assertTNodeForTView(tNode, tView) {
  assertTNode(tNode);
  const tData = tView.data;
  for (let i2 = HEADER_OFFSET; i2 < tData.length; i2++) {
    if (tData[i2] === tNode) {
      return;
    }
  }
  throwError2("This TNode does not belong to this TView.");
}
function assertTNode(tNode) {
  assertDefined(tNode, "TNode must be defined");
  if (!(tNode && typeof tNode === "object" && tNode.hasOwnProperty("directiveStylingLast"))) {
    throwError2("Not of type TNode, got: " + tNode);
  }
}
function assertTIcu(tIcu) {
  assertDefined(tIcu, "Expected TIcu to be defined");
  if (!(typeof tIcu.currentCaseLViewIndex === "number")) {
    throwError2("Object is not of TIcu type.");
  }
}
function assertComponentType(actual, msg = "Type passed in is not ComponentType, it does not have '\u0275cmp' property.") {
  if (!getComponentDef(actual)) {
    throwError2(msg);
  }
}
function assertNgModuleType(actual, msg = "Type passed in is not NgModuleType, it does not have '\u0275mod' property.") {
  if (!getNgModuleDef(actual)) {
    throwError2(msg);
  }
}
function assertHasParent(tNode) {
  assertDefined(tNode, "currentTNode should exist!");
  assertDefined(tNode.parent, "currentTNode should have a parent");
}
function assertLContainer(value) {
  assertDefined(value, "LContainer must be defined");
  assertEqual(isLContainer(value), true, "Expecting LContainer");
}
function assertLViewOrUndefined(value) {
  value && assertEqual(isLView(value), true, "Expecting LView or undefined or null");
}
function assertLView(value) {
  assertDefined(value, "LView must be defined");
  assertEqual(isLView(value), true, "Expecting LView");
}
function assertFirstCreatePass(tView, errMessage) {
  assertEqual(tView.firstCreatePass, true, errMessage || "Should only be called in first create pass.");
}
function assertFirstUpdatePass(tView, errMessage) {
  assertEqual(tView.firstUpdatePass, true, "Should only be called in first update pass.");
}
function assertDirectiveDef(obj) {
  if (obj.type === void 0 || obj.selectors == void 0 || obj.inputs === void 0) {
    throwError2(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);
  }
}
function assertIndexInDeclRange(tView, index) {
  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);
}
function assertIndexInExpandoRange(lView, index) {
  const tView = lView[1];
  assertBetween(tView.expandoStartIndex, lView.length, index);
}
function assertBetween(lower, upper, index) {
  if (!(lower <= index && index < upper)) {
    throwError2(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);
  }
}
function assertProjectionSlots(lView, errMessage) {
  assertDefined(lView[DECLARATION_COMPONENT_VIEW], "Component views should exist.");
  assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, "Components with projection nodes (<ng-content>) must have projection slots defined.");
}
function assertParentView(lView, errMessage) {
  assertDefined(lView, "Component views should always have a parent view (component's host view)");
}
function assertNodeInjector(lView, injectorIndex) {
  assertIndexInExpandoRange(lView, injectorIndex);
  assertIndexInExpandoRange(
    lView,
    injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  );
  assertNumber(lView[injectorIndex + 0], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 1], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 2], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 3], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 4], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 5], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 6], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 7], "injectorIndex should point to a bloom filter");
  assertNumber(lView[
    injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  ], "injectorIndex should point to parent injector");
}
function unwrapRNode(value) {
  while (Array.isArray(value)) {
    value = value[HOST];
  }
  return value;
}
function unwrapLView(value) {
  while (Array.isArray(value)) {
    if (typeof value[TYPE] === "object")
      return value;
    value = value[HOST];
  }
  return null;
}
function getNativeByIndex(index, lView) {
  ngDevMode && assertIndexInRange(lView, index);
  ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, "Expected to be past HEADER_OFFSET");
  return unwrapRNode(lView[index]);
}
function getNativeByTNode(tNode, lView) {
  ngDevMode && assertTNodeForLView(tNode, lView);
  ngDevMode && assertIndexInRange(lView, tNode.index);
  const node = unwrapRNode(lView[tNode.index]);
  return node;
}
function getTNode(tView, index) {
  ngDevMode && assertGreaterThan(index, -1, "wrong index for TNode");
  ngDevMode && assertLessThan(index, tView.data.length, "wrong index for TNode");
  const tNode = tView.data[index];
  ngDevMode && tNode !== null && assertTNode(tNode);
  return tNode;
}
function load(view, index) {
  ngDevMode && assertIndexInRange(view, index);
  return view[index];
}
function store(tView, lView, index, value) {
  if (index >= tView.data.length) {
    tView.data[index] = null;
    tView.blueprint[index] = null;
  }
  lView[index] = value;
}
function getComponentLViewByIndex(nodeIndex, hostView) {
  ngDevMode && assertIndexInRange(hostView, nodeIndex);
  const slotValue = hostView[nodeIndex];
  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];
  return lView;
}
function isCreationMode(view) {
  return (view[FLAGS] & 4) === 4;
}
function viewAttachedToChangeDetector(view) {
  return (view[FLAGS] & 128) === 128;
}
function viewAttachedToContainer(view) {
  return isLContainer(view[PARENT]);
}
function getConstant(consts, index) {
  if (index === null || index === void 0)
    return null;
  ngDevMode && assertIndexInRange(consts, index);
  return consts[index];
}
function resetPreOrderHookFlags(lView) {
  lView[PREORDER_HOOK_FLAGS] = 0;
}
function markViewForRefresh(lView) {
  if (lView[FLAGS] & 1024) {
    return;
  }
  lView[FLAGS] |= 1024;
  if (viewAttachedToChangeDetector(lView)) {
    markAncestorsForTraversal(lView);
  }
}
function walkUpViews(nestingLevel, currentView) {
  while (nestingLevel > 0) {
    ngDevMode && assertDefined(currentView[DECLARATION_VIEW], "Declaration view should be defined if nesting level is greater than 0.");
    currentView = currentView[DECLARATION_VIEW];
    nestingLevel--;
  }
  return currentView;
}
function requiresRefreshOrTraversal(lView) {
  return !!(lView[FLAGS] & (1024 | 8192) || lView[REACTIVE_TEMPLATE_CONSUMER]?.dirty);
}
function updateAncestorTraversalFlagsOnAttach(lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(
    8
    /* NotificationSource.ViewAttached */
  );
  if (lView[FLAGS] & 64) {
    lView[FLAGS] |= 1024;
  }
  if (requiresRefreshOrTraversal(lView)) {
    markAncestorsForTraversal(lView);
  }
}
function markAncestorsForTraversal(lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(
    0
    /* NotificationSource.MarkAncestorsForTraversal */
  );
  let parent = getLViewParent(lView);
  while (parent !== null) {
    if (parent[FLAGS] & 8192) {
      break;
    }
    parent[FLAGS] |= 8192;
    if (!viewAttachedToChangeDetector(parent)) {
      break;
    }
    parent = getLViewParent(parent);
  }
}
function storeLViewOnDestroy(lView, onDestroyCallback) {
  if (isDestroyed(lView)) {
    throw new RuntimeError(911, ngDevMode && "View has already been destroyed.");
  }
  if (lView[ON_DESTROY_HOOKS] === null) {
    lView[ON_DESTROY_HOOKS] = [];
  }
  lView[ON_DESTROY_HOOKS].push(onDestroyCallback);
}
function removeLViewOnDestroy(lView, onDestroyCallback) {
  if (lView[ON_DESTROY_HOOKS] === null)
    return;
  const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);
  if (destroyCBIdx !== -1) {
    lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);
  }
}
function getLViewParent(lView) {
  ngDevMode && assertLView(lView);
  const parent = lView[PARENT];
  return isLContainer(parent) ? parent[PARENT] : parent;
}
function getOrCreateLViewCleanup(view) {
  return view[CLEANUP] ??= [];
}
function getOrCreateTViewCleanup(tView) {
  return tView.cleanup ??= [];
}
function storeCleanupWithContext(tView, lView, context2, cleanupFn) {
  const lCleanup = getOrCreateLViewCleanup(lView);
  ngDevMode && assertDefined(context2, "Cleanup context is mandatory when registering framework-level destroy hooks");
  lCleanup.push(context2);
  if (tView.firstCreatePass) {
    getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);
  } else {
    if (ngDevMode) {
      Object.freeze(getOrCreateTViewCleanup(tView));
    }
  }
}
function getElementDepthCount() {
  return instructionState.lFrame.elementDepthCount;
}
function increaseElementDepthCount() {
  instructionState.lFrame.elementDepthCount++;
}
function decreaseElementDepthCount() {
  instructionState.lFrame.elementDepthCount--;
}
function getBindingsEnabled() {
  return instructionState.bindingsEnabled;
}
function isInSkipHydrationBlock() {
  return instructionState.skipHydrationRootTNode !== null;
}
function isSkipHydrationRootTNode(tNode) {
  return instructionState.skipHydrationRootTNode === tNode;
}
function \u0275\u0275enableBindings() {
  instructionState.bindingsEnabled = true;
}
function \u0275\u0275disableBindings() {
  instructionState.bindingsEnabled = false;
}
function leaveSkipHydrationBlock() {
  instructionState.skipHydrationRootTNode = null;
}
function getLView() {
  return instructionState.lFrame.lView;
}
function getTView() {
  return instructionState.lFrame.tView;
}
function \u0275\u0275restoreView(viewToRestore) {
  instructionState.lFrame.contextLView = viewToRestore;
  return viewToRestore[CONTEXT];
}
function \u0275\u0275resetView(value) {
  instructionState.lFrame.contextLView = null;
  return value;
}
function getCurrentTNode() {
  let currentTNode = getCurrentTNodePlaceholderOk();
  while (currentTNode !== null && currentTNode.type === 64) {
    currentTNode = currentTNode.parent;
  }
  return currentTNode;
}
function getCurrentTNodePlaceholderOk() {
  return instructionState.lFrame.currentTNode;
}
function getCurrentParentTNode() {
  const lFrame = instructionState.lFrame;
  const currentTNode = lFrame.currentTNode;
  return lFrame.isParent ? currentTNode : currentTNode.parent;
}
function setCurrentTNode(tNode, isParent) {
  ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);
  const lFrame = instructionState.lFrame;
  lFrame.currentTNode = tNode;
  lFrame.isParent = isParent;
}
function isCurrentTNodeParent() {
  return instructionState.lFrame.isParent;
}
function setCurrentTNodeAsNotParent() {
  instructionState.lFrame.isParent = false;
}
function getContextLView() {
  const contextLView = instructionState.lFrame.contextLView;
  ngDevMode && assertDefined(contextLView, "contextLView must be defined.");
  return contextLView;
}
function isInCheckNoChangesMode() {
  !ngDevMode && throwError2("Must never be called in production mode");
  return _checkNoChangesMode !== CheckNoChangesMode.Off;
}
function isExhaustiveCheckNoChanges() {
  !ngDevMode && throwError2("Must never be called in production mode");
  return _checkNoChangesMode === CheckNoChangesMode.Exhaustive;
}
function setIsInCheckNoChangesMode(mode) {
  !ngDevMode && throwError2("Must never be called in production mode");
  _checkNoChangesMode = mode;
}
function isRefreshingViews() {
  return _isRefreshingViews;
}
function setIsRefreshingViews(mode) {
  const prev = _isRefreshingViews;
  _isRefreshingViews = mode;
  return prev;
}
function getBindingRoot() {
  const lFrame = instructionState.lFrame;
  let index = lFrame.bindingRootIndex;
  if (index === -1) {
    index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;
  }
  return index;
}
function getBindingIndex() {
  return instructionState.lFrame.bindingIndex;
}
function setBindingIndex(value) {
  return instructionState.lFrame.bindingIndex = value;
}
function nextBindingIndex() {
  return instructionState.lFrame.bindingIndex++;
}
function incrementBindingIndex(count) {
  const lFrame = instructionState.lFrame;
  const index = lFrame.bindingIndex;
  lFrame.bindingIndex = lFrame.bindingIndex + count;
  return index;
}
function isInI18nBlock() {
  return instructionState.lFrame.inI18n;
}
function setInI18nBlock(isInI18nBlock2) {
  instructionState.lFrame.inI18n = isInI18nBlock2;
}
function setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {
  const lFrame = instructionState.lFrame;
  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;
  setCurrentDirectiveIndex(currentDirectiveIndex);
}
function getCurrentDirectiveIndex() {
  return instructionState.lFrame.currentDirectiveIndex;
}
function setCurrentDirectiveIndex(currentDirectiveIndex) {
  instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;
}
function getCurrentDirectiveDef(tData) {
  const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;
  return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];
}
function getCurrentQueryIndex() {
  return instructionState.lFrame.currentQueryIndex;
}
function setCurrentQueryIndex(value) {
  instructionState.lFrame.currentQueryIndex = value;
}
function getDeclarationTNode(lView) {
  const tView = lView[TVIEW];
  if (tView.type === 2) {
    ngDevMode && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents.");
    return tView.declTNode;
  }
  if (tView.type === 1) {
    return lView[T_HOST];
  }
  return null;
}
function enterDI(lView, tNode, flags) {
  ngDevMode && assertLViewOrUndefined(lView);
  if (flags & 4) {
    ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);
    let parentTNode = tNode;
    let parentLView = lView;
    while (true) {
      ngDevMode && assertDefined(parentTNode, "Parent TNode should be defined");
      parentTNode = parentTNode.parent;
      if (parentTNode === null && !(flags & 1)) {
        parentTNode = getDeclarationTNode(parentLView);
        if (parentTNode === null)
          break;
        ngDevMode && assertDefined(parentLView, "Parent LView should be defined");
        parentLView = parentLView[DECLARATION_VIEW];
        if (parentTNode.type & (2 | 8)) {
          break;
        }
      } else {
        break;
      }
    }
    if (parentTNode === null) {
      return false;
    } else {
      tNode = parentTNode;
      lView = parentLView;
    }
  }
  ngDevMode && assertTNodeForLView(tNode, lView);
  const lFrame = instructionState.lFrame = allocLFrame();
  lFrame.currentTNode = tNode;
  lFrame.lView = lView;
  return true;
}
function enterView(newView) {
  ngDevMode && assertNotEqual(newView[0], newView[1], "????");
  ngDevMode && assertLViewOrUndefined(newView);
  const newLFrame = allocLFrame();
  if (ngDevMode) {
    assertEqual(newLFrame.isParent, true, "Expected clean LFrame");
    assertEqual(newLFrame.lView, null, "Expected clean LFrame");
    assertEqual(newLFrame.tView, null, "Expected clean LFrame");
    assertEqual(newLFrame.selectedIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.elementDepthCount, 0, "Expected clean LFrame");
    assertEqual(newLFrame.currentDirectiveIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.currentNamespace, null, "Expected clean LFrame");
    assertEqual(newLFrame.bindingRootIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.currentQueryIndex, 0, "Expected clean LFrame");
  }
  const tView = newView[TVIEW];
  instructionState.lFrame = newLFrame;
  ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);
  newLFrame.currentTNode = tView.firstChild;
  newLFrame.lView = newView;
  newLFrame.tView = tView;
  newLFrame.contextLView = newView;
  newLFrame.bindingIndex = tView.bindingStartIndex;
  newLFrame.inI18n = false;
}
function allocLFrame() {
  const currentLFrame = instructionState.lFrame;
  const childLFrame = currentLFrame === null ? null : currentLFrame.child;
  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;
  return newLFrame;
}
function createLFrame(parent) {
  const lFrame = {
    currentTNode: null,
    isParent: true,
    lView: null,
    tView: null,
    selectedIndex: -1,
    contextLView: null,
    elementDepthCount: 0,
    currentNamespace: null,
    currentDirectiveIndex: -1,
    bindingRootIndex: -1,
    bindingIndex: -1,
    currentQueryIndex: 0,
    parent,
    child: null,
    inI18n: false
  };
  parent !== null && (parent.child = lFrame);
  return lFrame;
}
function leaveViewLight() {
  const oldLFrame = instructionState.lFrame;
  instructionState.lFrame = oldLFrame.parent;
  oldLFrame.currentTNode = null;
  oldLFrame.lView = null;
  return oldLFrame;
}
function leaveView() {
  const oldLFrame = leaveViewLight();
  oldLFrame.isParent = true;
  oldLFrame.tView = null;
  oldLFrame.selectedIndex = -1;
  oldLFrame.contextLView = null;
  oldLFrame.elementDepthCount = 0;
  oldLFrame.currentDirectiveIndex = -1;
  oldLFrame.currentNamespace = null;
  oldLFrame.bindingRootIndex = -1;
  oldLFrame.bindingIndex = -1;
  oldLFrame.currentQueryIndex = 0;
}
function nextContextImpl(level) {
  const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);
  return contextLView[CONTEXT];
}
function getSelectedIndex() {
  return instructionState.lFrame.selectedIndex;
}
function setSelectedIndex(index) {
  ngDevMode && index !== -1 && assertGreaterThanOrEqual(index, HEADER_OFFSET, "Index must be past HEADER_OFFSET (or -1).");
  ngDevMode && assertLessThan(index, instructionState.lFrame.lView.length, "Can't set index passed end of LView");
  instructionState.lFrame.selectedIndex = index;
}
function getSelectedTNode() {
  const lFrame = instructionState.lFrame;
  return getTNode(lFrame.tView, lFrame.selectedIndex);
}
function \u0275\u0275namespaceSVG() {
  instructionState.lFrame.currentNamespace = SVG_NAMESPACE;
}
function \u0275\u0275namespaceMathML() {
  instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;
}
function \u0275\u0275namespaceHTML() {
  namespaceHTMLInternal();
}
function namespaceHTMLInternal() {
  instructionState.lFrame.currentNamespace = null;
}
function getNamespace() {
  return instructionState.lFrame.currentNamespace;
}
function wasLastNodeCreated() {
  return _wasLastNodeCreated;
}
function lastNodeWasCreated(flag) {
  _wasLastNodeCreated = flag;
}
function createInjector(defType, parent = null, additionalProviders = null, name) {
  const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);
  injector.resolveInjectorInitializers();
  return injector;
}
function createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = /* @__PURE__ */ new Set()) {
  const providers = [additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType)];
  name = name || (typeof defType === "object" ? void 0 : stringify(defType));
  return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);
}
function injectDestroyRef() {
  return new NodeInjectorDestroyRef(getLView());
}
function provideBrowserGlobalErrorListeners() {
  return makeEnvironmentProviders([
    provideEnvironmentInitializer(() => void inject2(globalErrorListeners))
  ]);
}
function isSignal(value) {
  return typeof value === "function" && value[SIGNAL] !== void 0;
}
function signal(initialValue, options) {
  const [get, set, update] = createSignal(initialValue, options?.equal);
  const signalFn = get;
  const node = signalFn[SIGNAL];
  signalFn.set = set;
  signalFn.update = update;
  signalFn.asReadonly = signalAsReadonlyFn.bind(signalFn);
  if (ngDevMode) {
    signalFn.toString = () => `[Signal: ${signalFn()}]`;
    node.debugName = options?.debugName;
  }
  return signalFn;
}
function signalAsReadonlyFn() {
  const node = this[SIGNAL];
  if (node.readonlyFn === void 0) {
    const readonlyFn = () => this();
    readonlyFn[SIGNAL] = node;
    node.readonlyFn = readonlyFn;
  }
  return node.readonlyFn;
}
function isWritableSignal(value) {
  return isSignal(value) && typeof value.set === "function";
}
function assertNotInReactiveContext(debugFn, extraContext) {
  if (getActiveConsumer() !== null) {
    throw new RuntimeError(-602, ngDevMode && `${debugFn.name}() cannot be called from within a reactive context.${extraContext ? ` ${extraContext}` : ""}`);
  }
}
function injectViewContext() {
  return new ViewContext(getLView(), getCurrentTNode());
}
function noop2(...args) {
}
var ERROR_DETAILS_PAGE_BASE_URL, XSS_SECURITY_URL, RuntimeError, _global, __forward_ref__, NG_PROV_DEF, NG_INJ_DEF, InjectionToken, _injectorProfilerContext, injectorProfilerCallbacks, NOOP_PROFILER_REMOVAL, NG_COMP_DEF, NG_DIR_DEF, NG_PIPE_DEF, NG_MOD_DEF, NG_FACTORY_DEF, NG_ELEMENT_ID, NG_ENV_ID, NG_RUNTIME_ERROR_CODE, NG_RUNTIME_ERROR_MESSAGE, NG_TOKEN_PATH, _injectImplementation, _THROW_IF_NOT_FOUND, THROW_IF_NOT_FOUND, DI_DECORATOR_FLAG, RetrievingInjector, EMPTY_OBJ, EMPTY_ARRAY, ENVIRONMENT_INITIALIZER, INJECTOR$1, INJECTOR_DEF_TYPES, NullInjector, USE_VALUE, INJECTOR_SCOPE, NOT_YET, CIRCULAR, NULL_INJECTOR, EnvironmentInjector, R3Injector, HOST, TVIEW, FLAGS, PARENT, NEXT, T_HOST, HYDRATION, CLEANUP, CONTEXT, INJECTOR, ENVIRONMENT, RENDERER, CHILD_HEAD, CHILD_TAIL, DECLARATION_VIEW, DECLARATION_COMPONENT_VIEW, DECLARATION_LCONTAINER, PREORDER_HOOK_FLAGS, QUERIES, ID, EMBEDDED_VIEW_INJECTOR, ON_DESTROY_HOOKS, EFFECTS_TO_SCHEDULE, EFFECTS, REACTIVE_TEMPLATE_CONSUMER, AFTER_RENDER_SEQUENCES_TO_ADD, HEADER_OFFSET, TYPE, DEHYDRATED_VIEWS, NATIVE, VIEW_REFS, MOVED_VIEWS, CONTAINER_HEADER_OFFSET, SVG_NAMESPACE, MATH_ML_NAMESPACE, instructionState, CheckNoChangesMode, _checkNoChangesMode, _isRefreshingViews, leaveDI, _wasLastNodeCreated, Injector, DOCUMENT, DestroyRef, NodeInjectorDestroyRef, ErrorHandler, INTERNAL_APPLICATION_ERROR_HANDLER, errorHandlerEnvironmentInitializer, globalErrorListeners, ChangeDetectionScheduler, ZONELESS_ENABLED, PROVIDED_ZONELESS, ZONELESS_SCHEDULER_DISABLED, SCHEDULE_IN_ROOT_ZONE, ViewContext, PendingTasksInternal, PendingTasks, EffectScheduler, ZoneAwareEffectScheduler;
var init_root_effect_scheduler = __esm({
  "node_modules/@angular/core/fesm2022/root_effect_scheduler.mjs"() {
    "use strict";
    init_not_found();
    init_signal();
    init_esm();
    init_signals();
    init_di();
    ERROR_DETAILS_PAGE_BASE_URL = "https://angular.dev/errors";
    XSS_SECURITY_URL = "https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss";
    RuntimeError = class extends Error {
      code;
      constructor(code, message) {
        super(formatRuntimeError(code, message));
        this.code = code;
      }
    };
    _global = globalThis;
    __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });
    NG_PROV_DEF = getClosureSafeProperty({ \u0275prov: getClosureSafeProperty });
    NG_INJ_DEF = getClosureSafeProperty({ \u0275inj: getClosureSafeProperty });
    InjectionToken = class {
      _desc;
      /** @internal */
      ngMetadataName = "InjectionToken";
      \u0275prov;
      /**
       * @param _desc   Description for the token,
       *                used only for debugging purposes,
       *                it should but does not need to be unique
       * @param options Options for the token's usage, as described above
       */
      constructor(_desc, options) {
        this._desc = _desc;
        this.\u0275prov = void 0;
        if (typeof options == "number") {
          (typeof ngDevMode === "undefined" || ngDevMode) && assertLessThan(options, 0, "Only negative numbers are supported here");
          this.__NG_ELEMENT_ID__ = options;
        } else if (options !== void 0) {
          this.\u0275prov = \u0275\u0275defineInjectable({
            token: this,
            providedIn: options.providedIn || "root",
            factory: options.factory
          });
        }
      }
      /**
       * @internal
       */
      get multi() {
        return this;
      }
      toString() {
        return `InjectionToken ${this._desc}`;
      }
    };
    injectorProfilerCallbacks = [];
    NOOP_PROFILER_REMOVAL = () => {
    };
    NG_COMP_DEF = getClosureSafeProperty({ \u0275cmp: getClosureSafeProperty });
    NG_DIR_DEF = getClosureSafeProperty({ \u0275dir: getClosureSafeProperty });
    NG_PIPE_DEF = getClosureSafeProperty({ \u0275pipe: getClosureSafeProperty });
    NG_MOD_DEF = getClosureSafeProperty({ \u0275mod: getClosureSafeProperty });
    NG_FACTORY_DEF = getClosureSafeProperty({ \u0275fac: getClosureSafeProperty });
    NG_ELEMENT_ID = getClosureSafeProperty({
      __NG_ELEMENT_ID__: getClosureSafeProperty
    });
    NG_ENV_ID = getClosureSafeProperty({ __NG_ENV_ID__: getClosureSafeProperty });
    NG_RUNTIME_ERROR_CODE = getClosureSafeProperty({ "ngErrorCode": getClosureSafeProperty });
    NG_RUNTIME_ERROR_MESSAGE = getClosureSafeProperty({ "ngErrorMessage": getClosureSafeProperty });
    NG_TOKEN_PATH = getClosureSafeProperty({ "ngTokenPath": getClosureSafeProperty });
    _THROW_IF_NOT_FOUND = {};
    THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
    DI_DECORATOR_FLAG = "__NG_DI_FLAG__";
    RetrievingInjector = class {
      injector;
      constructor(injector) {
        this.injector = injector;
      }
      retrieve(token, options) {
        const flags = convertToBitFlags(options) || 0;
        try {
          return this.injector.get(
            token,
            // When a dependency is requested with an optional flag, DI returns null as the default value.
            flags & 8 ? null : THROW_IF_NOT_FOUND,
            flags
          );
        } catch (e2) {
          if (isNotFound(e2)) {
            return e2;
          }
          throw e2;
        }
      }
    };
    EMPTY_OBJ = {};
    EMPTY_ARRAY = [];
    if ((typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode()) {
      Object.freeze(EMPTY_OBJ);
      Object.freeze(EMPTY_ARRAY);
    }
    ENVIRONMENT_INITIALIZER = new InjectionToken(ngDevMode ? "ENVIRONMENT_INITIALIZER" : "");
    INJECTOR$1 = new InjectionToken(
      ngDevMode ? "INJECTOR" : "",
      // Disable tslint because this is const enum which gets inlined not top level prop access.
      // tslint:disable-next-line: no-toplevel-property-access
      -1
      /* InjectorMarkers.Injector */
    );
    INJECTOR_DEF_TYPES = new InjectionToken(ngDevMode ? "INJECTOR_DEF_TYPES" : "");
    NullInjector = class {
      get(token, notFoundValue = THROW_IF_NOT_FOUND) {
        if (notFoundValue === THROW_IF_NOT_FOUND) {
          const message = ngDevMode ? `No provider found for \`${stringify(token)}\`.` : "";
          const error = createRuntimeError(
            message,
            -201
            /* RuntimeErrorCode.PROVIDER_NOT_FOUND */
          );
          error.name = "\u0275NotFound";
          throw error;
        }
        return notFoundValue;
      }
    };
    USE_VALUE = getClosureSafeProperty({
      provide: String,
      useValue: getClosureSafeProperty
    });
    INJECTOR_SCOPE = new InjectionToken(ngDevMode ? "Set Injector scope." : "");
    NOT_YET = {};
    CIRCULAR = {};
    NULL_INJECTOR = void 0;
    EnvironmentInjector = class {
    };
    R3Injector = class extends EnvironmentInjector {
      parent;
      source;
      scopes;
      /**
       * Map of tokens to records which contain the instances of those tokens.
       * - `null` value implies that we don't have the record. Used by tree-shakable injectors
       * to prevent further searches.
       */
      records = /* @__PURE__ */ new Map();
      /**
       * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.
       */
      _ngOnDestroyHooks = /* @__PURE__ */ new Set();
      _onDestroyHooks = [];
      /**
       * Flag indicating that this injector was previously destroyed.
       */
      get destroyed() {
        return this._destroyed;
      }
      _destroyed = false;
      injectorDefTypes;
      constructor(providers, parent, source, scopes) {
        super();
        this.parent = parent;
        this.source = source;
        this.scopes = scopes;
        forEachSingleProvider(providers, (provider) => this.processProvider(provider));
        this.records.set(INJECTOR$1, makeRecord(void 0, this));
        if (scopes.has("environment")) {
          this.records.set(EnvironmentInjector, makeRecord(void 0, this));
        }
        const record = this.records.get(INJECTOR_SCOPE);
        if (record != null && typeof record.value === "string") {
          this.scopes.add(record.value);
        }
        this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES, EMPTY_ARRAY, { self: true }));
      }
      retrieve(token, options) {
        const flags = convertToBitFlags(options) || 0;
        try {
          return this.get(
            token,
            // When a dependency is requested with an optional flag, DI returns null as the default value.
            THROW_IF_NOT_FOUND,
            flags
          );
        } catch (e2) {
          if (isNotFound(e2)) {
            return e2;
          }
          throw e2;
        }
      }
      /**
       * Destroy the injector and release references to every instance or provider associated with it.
       *
       * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a
       * hook was found.
       */
      destroy() {
        assertNotDestroyed(this);
        this._destroyed = true;
        const prevConsumer = setActiveConsumer(null);
        try {
          for (const service of this._ngOnDestroyHooks) {
            service.ngOnDestroy();
          }
          const onDestroyHooks = this._onDestroyHooks;
          this._onDestroyHooks = [];
          for (const hook of onDestroyHooks) {
            hook();
          }
        } finally {
          this.records.clear();
          this._ngOnDestroyHooks.clear();
          this.injectorDefTypes.clear();
          setActiveConsumer(prevConsumer);
        }
      }
      onDestroy(callback) {
        assertNotDestroyed(this);
        this._onDestroyHooks.push(callback);
        return () => this.removeOnDestroy(callback);
      }
      runInContext(fn) {
        assertNotDestroyed(this);
        const previousInjector = setCurrentInjector(this);
        const previousInjectImplementation = setInjectImplementation(void 0);
        let prevInjectContext;
        if (ngDevMode) {
          prevInjectContext = setInjectorProfilerContext({ injector: this, token: null });
        }
        try {
          return fn();
        } finally {
          setCurrentInjector(previousInjector);
          setInjectImplementation(previousInjectImplementation);
          ngDevMode && setInjectorProfilerContext(prevInjectContext);
        }
      }
      get(token, notFoundValue = THROW_IF_NOT_FOUND, options) {
        assertNotDestroyed(this);
        if (token.hasOwnProperty(NG_ENV_ID)) {
          return token[NG_ENV_ID](this);
        }
        const flags = convertToBitFlags(options);
        let prevInjectContext;
        if (ngDevMode) {
          prevInjectContext = setInjectorProfilerContext({ injector: this, token });
        }
        const previousInjector = setCurrentInjector(this);
        const previousInjectImplementation = setInjectImplementation(void 0);
        try {
          if (!(flags & 4)) {
            let record = this.records.get(token);
            if (record === void 0) {
              const def = couldBeInjectableType(token) && getInjectableDef(token);
              if (def && this.injectableDefInScope(def)) {
                if (ngDevMode) {
                  runInInjectorProfilerContext(this, token, () => {
                    emitProviderConfiguredEvent(token);
                  });
                }
                record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);
              } else {
                record = null;
              }
              this.records.set(token, record);
            }
            if (record != null) {
              return this.hydrate(token, record, flags);
            }
          }
          const nextInjector = !(flags & 2) ? this.parent : getNullInjector();
          notFoundValue = flags & 8 && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;
          return nextInjector.get(token, notFoundValue);
        } catch (error) {
          const errorCode = getRuntimeErrorCode(error);
          if (errorCode === -200 || errorCode === -201) {
            if (!ngDevMode) {
              throw new RuntimeError(errorCode, null);
            }
            prependTokenToDependencyPath(error, token);
            if (previousInjector) {
              throw error;
            } else {
              throw augmentRuntimeError(error, this.source);
            }
          } else {
            throw error;
          }
        } finally {
          setInjectImplementation(previousInjectImplementation);
          setCurrentInjector(previousInjector);
          ngDevMode && setInjectorProfilerContext(prevInjectContext);
        }
      }
      /** @internal */
      resolveInjectorInitializers() {
        const prevConsumer = setActiveConsumer(null);
        const previousInjector = setCurrentInjector(this);
        const previousInjectImplementation = setInjectImplementation(void 0);
        let prevInjectContext;
        if (ngDevMode) {
          prevInjectContext = setInjectorProfilerContext({ injector: this, token: null });
        }
        try {
          const initializers = this.get(ENVIRONMENT_INITIALIZER, EMPTY_ARRAY, { self: true });
          if (ngDevMode && !Array.isArray(initializers)) {
            throw new RuntimeError(-209, `Unexpected type of the \`ENVIRONMENT_INITIALIZER\` token value (expected an array, but got ${typeof initializers}). Please check that the \`ENVIRONMENT_INITIALIZER\` token is configured as a \`multi: true\` provider.`);
          }
          for (const initializer of initializers) {
            initializer();
          }
        } finally {
          setCurrentInjector(previousInjector);
          setInjectImplementation(previousInjectImplementation);
          ngDevMode && setInjectorProfilerContext(prevInjectContext);
          setActiveConsumer(prevConsumer);
        }
      }
      toString() {
        const tokens = [];
        const records = this.records;
        for (const token of records.keys()) {
          tokens.push(stringify(token));
        }
        return `R3Injector[${tokens.join(", ")}]`;
      }
      /**
       * Process a `SingleProvider` and add it.
       */
      processProvider(provider) {
        provider = resolveForwardRef(provider);
        let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);
        const record = providerToRecord(provider);
        if (ngDevMode) {
          runInInjectorProfilerContext(this, token, () => {
            if (isValueProvider(provider)) {
              emitInjectorToCreateInstanceEvent(token);
              emitInstanceCreatedByInjectorEvent(provider.useValue);
            }
            emitProviderConfiguredEvent(provider);
          });
        }
        if (!isTypeProvider(provider) && provider.multi === true) {
          let multiRecord = this.records.get(token);
          if (multiRecord) {
            if (ngDevMode && multiRecord.multi === void 0) {
              throwMixedMultiProviderError();
            }
          } else {
            multiRecord = makeRecord(void 0, NOT_YET, true);
            multiRecord.factory = () => injectArgs(multiRecord.multi);
            this.records.set(token, multiRecord);
          }
          token = provider;
          multiRecord.multi.push(provider);
        } else {
          if (ngDevMode) {
            const existing = this.records.get(token);
            if (existing && existing.multi !== void 0) {
              throwMixedMultiProviderError();
            }
          }
        }
        this.records.set(token, record);
      }
      hydrate(token, record, flags) {
        const prevConsumer = setActiveConsumer(null);
        try {
          if (record.value === CIRCULAR) {
            throw cyclicDependencyError(stringify(token));
          } else if (record.value === NOT_YET) {
            record.value = CIRCULAR;
            if (ngDevMode) {
              runInInjectorProfilerContext(this, token, () => {
                emitInjectorToCreateInstanceEvent(token);
                record.value = record.factory(void 0, flags);
                emitInstanceCreatedByInjectorEvent(record.value);
              });
            } else {
              record.value = record.factory(void 0, flags);
            }
          }
          if (typeof record.value === "object" && record.value && hasOnDestroy(record.value)) {
            this._ngOnDestroyHooks.add(record.value);
          }
          return record.value;
        } finally {
          setActiveConsumer(prevConsumer);
        }
      }
      injectableDefInScope(def) {
        if (!def.providedIn) {
          return false;
        }
        const providedIn = resolveForwardRef(def.providedIn);
        if (typeof providedIn === "string") {
          return providedIn === "any" || this.scopes.has(providedIn);
        } else {
          return this.injectorDefTypes.has(providedIn);
        }
      }
      removeOnDestroy(callback) {
        const destroyCBIdx = this._onDestroyHooks.indexOf(callback);
        if (destroyCBIdx !== -1) {
          this._onDestroyHooks.splice(destroyCBIdx, 1);
        }
      }
    };
    HOST = 0;
    TVIEW = 1;
    FLAGS = 2;
    PARENT = 3;
    NEXT = 4;
    T_HOST = 5;
    HYDRATION = 6;
    CLEANUP = 7;
    CONTEXT = 8;
    INJECTOR = 9;
    ENVIRONMENT = 10;
    RENDERER = 11;
    CHILD_HEAD = 12;
    CHILD_TAIL = 13;
    DECLARATION_VIEW = 14;
    DECLARATION_COMPONENT_VIEW = 15;
    DECLARATION_LCONTAINER = 16;
    PREORDER_HOOK_FLAGS = 17;
    QUERIES = 18;
    ID = 19;
    EMBEDDED_VIEW_INJECTOR = 20;
    ON_DESTROY_HOOKS = 21;
    EFFECTS_TO_SCHEDULE = 22;
    EFFECTS = 23;
    REACTIVE_TEMPLATE_CONSUMER = 24;
    AFTER_RENDER_SEQUENCES_TO_ADD = 25;
    HEADER_OFFSET = 26;
    TYPE = 1;
    DEHYDRATED_VIEWS = 6;
    NATIVE = 7;
    VIEW_REFS = 8;
    MOVED_VIEWS = 9;
    CONTAINER_HEADER_OFFSET = 10;
    SVG_NAMESPACE = "svg";
    MATH_ML_NAMESPACE = "math";
    instructionState = {
      lFrame: createLFrame(null),
      bindingsEnabled: true,
      skipHydrationRootTNode: null
    };
    (function(CheckNoChangesMode2) {
      CheckNoChangesMode2[CheckNoChangesMode2["Off"] = 0] = "Off";
      CheckNoChangesMode2[CheckNoChangesMode2["Exhaustive"] = 1] = "Exhaustive";
      CheckNoChangesMode2[CheckNoChangesMode2["OnlyDirtyViews"] = 2] = "OnlyDirtyViews";
    })(CheckNoChangesMode || (CheckNoChangesMode = {}));
    _checkNoChangesMode = 0;
    _isRefreshingViews = false;
    leaveDI = leaveViewLight;
    _wasLastNodeCreated = true;
    Injector = class _Injector {
      static THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
      static NULL = new NullInjector();
      static create(options, parent) {
        if (Array.isArray(options)) {
          return createInjector({ name: "" }, parent, options, "");
        } else {
          const name = options.name ?? "";
          return createInjector({ name }, options.parent, options.providers, name);
        }
      }
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _Injector,
          providedIn: "any",
          factory: () => \u0275\u0275inject(INJECTOR$1)
        })
      );
      /**
       * @internal
       * @nocollapse
       */
      static __NG_ELEMENT_ID__ = -1;
    };
    DOCUMENT = new InjectionToken(ngDevMode ? "DocumentToken" : "");
    DestroyRef = class {
      /**
       * @internal
       * @nocollapse
       */
      static __NG_ELEMENT_ID__ = injectDestroyRef;
      /**
       * @internal
       * @nocollapse
       */
      static __NG_ENV_ID__ = (injector) => injector;
    };
    NodeInjectorDestroyRef = class extends DestroyRef {
      _lView;
      constructor(_lView) {
        super();
        this._lView = _lView;
      }
      get destroyed() {
        return isDestroyed(this._lView);
      }
      onDestroy(callback) {
        const lView = this._lView;
        storeLViewOnDestroy(lView, callback);
        return () => removeLViewOnDestroy(lView, callback);
      }
    };
    ErrorHandler = class {
      /**
       * @internal
       */
      _console = console;
      handleError(error) {
        this._console.error("ERROR", error);
      }
    };
    INTERNAL_APPLICATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "internal error handler" : "", {
      providedIn: "root",
      factory: () => {
        const injector = inject2(EnvironmentInjector);
        let userErrorHandler;
        return (e2) => {
          if (injector.destroyed && !userErrorHandler) {
            setTimeout(() => {
              throw e2;
            });
          } else {
            userErrorHandler ??= injector.get(ErrorHandler);
            userErrorHandler.handleError(e2);
          }
        };
      }
    });
    errorHandlerEnvironmentInitializer = {
      provide: ENVIRONMENT_INITIALIZER,
      useValue: () => void inject2(ErrorHandler),
      multi: true
    };
    globalErrorListeners = new InjectionToken(ngDevMode ? "GlobalErrorListeners" : "", {
      providedIn: "root",
      factory: () => {
        if (false) {
          return;
        }
        const window2 = inject2(DOCUMENT).defaultView;
        if (!window2) {
          return;
        }
        const errorHandler2 = inject2(INTERNAL_APPLICATION_ERROR_HANDLER);
        const rejectionListener = (e2) => {
          errorHandler2(e2.reason);
          e2.preventDefault();
        };
        const errorListener = (e2) => {
          if (e2.error) {
            errorHandler2(e2.error);
          } else {
            errorHandler2(new Error(ngDevMode ? `An ErrorEvent with no error occurred. See Error.cause for details: ${e2.message}` : e2.message, { cause: e2 }));
          }
          e2.preventDefault();
        };
        const setupEventListeners = () => {
          window2.addEventListener("unhandledrejection", rejectionListener);
          window2.addEventListener("error", errorListener);
        };
        if (typeof Zone !== "undefined") {
          Zone.root.run(setupEventListeners);
        } else {
          setupEventListeners();
        }
        inject2(DestroyRef).onDestroy(() => {
          window2.removeEventListener("error", errorListener);
          window2.removeEventListener("unhandledrejection", rejectionListener);
        });
      }
    });
    ChangeDetectionScheduler = class {
    };
    ZONELESS_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "Zoneless enabled" : "", { providedIn: "root", factory: () => false });
    PROVIDED_ZONELESS = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "Zoneless provided" : "", { providedIn: "root", factory: () => false });
    ZONELESS_SCHEDULER_DISABLED = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "scheduler disabled" : "");
    SCHEDULE_IN_ROOT_ZONE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "run changes outside zone in root" : "");
    ViewContext = class {
      view;
      node;
      constructor(view, node) {
        this.view = view;
        this.node = node;
      }
      /**
       * @internal
       * @nocollapse
       */
      static __NG_ELEMENT_ID__ = injectViewContext;
    };
    PendingTasksInternal = class _PendingTasksInternal {
      taskId = 0;
      pendingTasks = /* @__PURE__ */ new Set();
      destroyed = false;
      pendingTask = new BehaviorSubject(false);
      get hasPendingTasks() {
        return this.destroyed ? false : this.pendingTask.value;
      }
      /**
       * In case the service is about to be destroyed, return a self-completing observable.
       * Otherwise, return the observable that emits the current state of pending tasks.
       */
      get hasPendingTasksObservable() {
        if (this.destroyed) {
          return new Observable((subscriber) => {
            subscriber.next(false);
            subscriber.complete();
          });
        }
        return this.pendingTask;
      }
      add() {
        if (!this.hasPendingTasks && !this.destroyed) {
          this.pendingTask.next(true);
        }
        const taskId = this.taskId++;
        this.pendingTasks.add(taskId);
        return taskId;
      }
      has(taskId) {
        return this.pendingTasks.has(taskId);
      }
      remove(taskId) {
        this.pendingTasks.delete(taskId);
        if (this.pendingTasks.size === 0 && this.hasPendingTasks) {
          this.pendingTask.next(false);
        }
      }
      ngOnDestroy() {
        this.pendingTasks.clear();
        if (this.hasPendingTasks) {
          this.pendingTask.next(false);
        }
        this.destroyed = true;
        this.pendingTask.unsubscribe();
      }
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _PendingTasksInternal,
          providedIn: "root",
          factory: () => new _PendingTasksInternal()
        })
      );
    };
    PendingTasks = class _PendingTasks {
      internalPendingTasks = inject2(PendingTasksInternal);
      scheduler = inject2(ChangeDetectionScheduler);
      errorHandler = inject2(INTERNAL_APPLICATION_ERROR_HANDLER);
      /**
       * Adds a new task that should block application's stability.
       * @returns A cleanup function that removes a task when called.
       */
      add() {
        const taskId = this.internalPendingTasks.add();
        return () => {
          if (!this.internalPendingTasks.has(taskId)) {
            return;
          }
          this.scheduler.notify(
            11
            /* NotificationSource.PendingTaskRemoved */
          );
          this.internalPendingTasks.remove(taskId);
        };
      }
      /**
       * Runs an asynchronous function and blocks the application's stability until the function completes.
       *
       * ```ts
       * pendingTasks.run(async () => {
       *   const userData = await fetch('/api/user');
       *   this.userData.set(userData);
       * });
       * ```
       *
       * @param fn The asynchronous function to execute
       * @developerPreview 19.0
       */
      run(fn) {
        const removeTask = this.add();
        fn().catch(this.errorHandler).finally(removeTask);
      }
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _PendingTasks,
          providedIn: "root",
          factory: () => new _PendingTasks()
        })
      );
    };
    EffectScheduler = class _EffectScheduler {
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _EffectScheduler,
          providedIn: "root",
          factory: () => new ZoneAwareEffectScheduler()
        })
      );
    };
    ZoneAwareEffectScheduler = class {
      dirtyEffectCount = 0;
      queues = /* @__PURE__ */ new Map();
      add(handle) {
        this.enqueue(handle);
        this.schedule(handle);
      }
      schedule(handle) {
        if (!handle.dirty) {
          return;
        }
        this.dirtyEffectCount++;
      }
      remove(handle) {
        const zone = handle.zone;
        const queue = this.queues.get(zone);
        if (!queue.has(handle)) {
          return;
        }
        queue.delete(handle);
        if (handle.dirty) {
          this.dirtyEffectCount--;
        }
      }
      enqueue(handle) {
        const zone = handle.zone;
        if (!this.queues.has(zone)) {
          this.queues.set(zone, /* @__PURE__ */ new Set());
        }
        const queue = this.queues.get(zone);
        if (queue.has(handle)) {
          return;
        }
        queue.add(handle);
      }
      /**
       * Run all scheduled effects.
       *
       * Execution order of effects within the same zone is guaranteed to be FIFO, but there is no
       * ordering guarantee between effects scheduled in different zones.
       */
      flush() {
        while (this.dirtyEffectCount > 0) {
          let ranOneEffect = false;
          for (const [zone, queue] of this.queues) {
            if (zone === null) {
              ranOneEffect ||= this.flushQueue(queue);
            } else {
              ranOneEffect ||= zone.run(() => this.flushQueue(queue));
            }
          }
          if (!ranOneEffect) {
            this.dirtyEffectCount = 0;
          }
        }
      }
      flushQueue(queue) {
        let ranOneEffect = false;
        for (const handle of queue) {
          if (!handle.dirty) {
            continue;
          }
          this.dirtyEffectCount--;
          ranOneEffect = true;
          handle.run();
        }
        return ranOneEffect;
      }
    };
  }
});

// node_modules/rxjs/dist/esm/operators/index.js
var init_operators = __esm({
  "node_modules/rxjs/dist/esm/operators/index.js"() {
    "use strict";
    init_auditTime();
    init_catchError();
    init_concatMap();
    init_defaultIfEmpty();
    init_distinctUntilChanged();
    init_filter();
    init_finalize();
    init_first();
    init_last();
    init_map();
    init_mergeAll();
    init_mergeMap();
    init_pairwise();
    init_refCount();
    init_scan();
    init_shareReplay();
    init_startWith();
    init_switchMap();
    init_take();
    init_takeLast();
    init_takeUntil();
    init_tap();
  }
});

// node_modules/@angular/core/fesm2022/debug_node.mjs
function noSideEffects(fn) {
  return { toString: fn }.toString();
}
function makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function DecoratorFactory(...args) {
      if (this instanceof DecoratorFactory) {
        metaCtor.call(this, ...args);
        return this;
      }
      const annotationInstance = new DecoratorFactory(...args);
      return function TypeDecorator(cls) {
        if (typeFn)
          typeFn(cls, ...args);
        const annotations = cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, { value: [] })[ANNOTATIONS];
        annotations.push(annotationInstance);
        return cls;
      };
    }
    if (parentClass) {
      DecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    DecoratorFactory.prototype.ngMetadataName = name;
    DecoratorFactory.annotationCls = DecoratorFactory;
    return DecoratorFactory;
  });
}
function makeMetadataCtor(props) {
  return function ctor(...args) {
    if (props) {
      const values = props(...args);
      for (const propName in values) {
        this[propName] = values[propName];
      }
    }
  };
}
function makeParamDecorator(name, props, parentClass) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function ParamDecoratorFactory(...args) {
      if (this instanceof ParamDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      const annotationInstance = new ParamDecoratorFactory(...args);
      ParamDecorator.annotation = annotationInstance;
      return ParamDecorator;
      function ParamDecorator(cls, unusedKey, index) {
        const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, { value: [] })[PARAMETERS];
        while (parameters.length <= index) {
          parameters.push(null);
        }
        (parameters[index] = parameters[index] || []).push(annotationInstance);
        return cls;
      }
    }
    ParamDecoratorFactory.prototype.ngMetadataName = name;
    ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
    return ParamDecoratorFactory;
  });
}
function makePropDecorator(name, props, parentClass, additionalProcessing) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function PropDecoratorFactory(...args) {
      if (this instanceof PropDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      const decoratorInstance = new PropDecoratorFactory(...args);
      function PropDecorator(target, name2) {
        if (target === void 0) {
          throw new Error("Standard Angular field decorators are not supported in JIT mode.");
        }
        const constructor = target.constructor;
        const meta = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, { value: {} })[PROP_METADATA];
        meta[name2] = meta.hasOwnProperty(name2) && meta[name2] || [];
        meta[name2].unshift(decoratorInstance);
      }
      return PropDecorator;
    }
    if (parentClass) {
      PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    PropDecoratorFactory.prototype.ngMetadataName = name;
    PropDecoratorFactory.annotationCls = PropDecoratorFactory;
    return PropDecoratorFactory;
  });
}
function getCompilerFacade(request) {
  const globalNg = _global["ng"];
  if (globalNg && globalNg.\u0275compilerFacade) {
    return globalNg.\u0275compilerFacade;
  }
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    console.error(`JIT compilation failed for ${request.kind}`, request.type);
    let message = `The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.

`;
    if (request.usage === 1) {
      message += `The ${request.kind} is part of a library that has been partially compiled.
`;
      message += `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.
`;
      message += "\n";
      message += `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.
`;
    } else {
      message += `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.
`;
    }
    message += `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',
`;
    message += `or manually provide the compiler with 'import "@angular/compiler";' before bootstrapping.`;
    throw new Error(message);
  } else {
    throw new Error("JIT compiler unavailable");
  }
}
function isType(v) {
  return typeof v === "function";
}
function isDelegateCtor(typeStr) {
  return ES5_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr);
}
function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
  if (!decoratorInvocations) {
    return [];
  }
  return decoratorInvocations.map((decoratorInvocation) => {
    const decoratorType = decoratorInvocation.type;
    const annotationCls = decoratorType.annotationCls;
    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
    return new annotationCls(...annotationArgs);
  });
}
function getParentCtor(ctor) {
  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;
  const parentCtor = parentProto ? parentProto.constructor : null;
  return parentCtor || Object;
}
function applyValueToInputField(instance, inputSignalNode, privateName, value) {
  if (inputSignalNode !== null) {
    inputSignalNode.applyValueToInputSignal(inputSignalNode, value);
  } else {
    instance[privateName] = value;
  }
}
function NgOnChangesFeatureImpl(definition) {
  if (definition.type.prototype.ngOnChanges) {
    definition.setInput = ngOnChangesSetInput;
  }
  return rememberChangeHistoryAndInvokeOnChangesHook;
}
function rememberChangeHistoryAndInvokeOnChangesHook() {
  const simpleChangesStore = getSimpleChangesStore(this);
  const current = simpleChangesStore?.current;
  if (current) {
    const previous = simpleChangesStore.previous;
    if (previous === EMPTY_OBJ) {
      simpleChangesStore.previous = current;
    } else {
      for (let key in current) {
        previous[key] = current[key];
      }
    }
    simpleChangesStore.current = null;
    this.ngOnChanges(current);
  }
}
function ngOnChangesSetInput(instance, inputSignalNode, value, publicName, privateName) {
  const declaredName = this.declaredInputs[publicName];
  ngDevMode && assertString(declaredName, "Name of input in ngOnChanges has to be a string");
  const simpleChangesStore = getSimpleChangesStore(instance) || setSimpleChangesStore(instance, { previous: EMPTY_OBJ, current: null });
  const current = simpleChangesStore.current || (simpleChangesStore.current = {});
  const previous = simpleChangesStore.previous;
  const previousChange = previous[declaredName];
  current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);
  applyValueToInputField(instance, inputSignalNode, privateName, value);
}
function getSimpleChangesStore(instance) {
  return instance[SIMPLE_CHANGES_STORE] || null;
}
function setSimpleChangesStore(instance, store2) {
  return instance[SIMPLE_CHANGES_STORE] = store2;
}
function removeProfiler2(profiler2) {
  const profilerIdx = profilerCallbacks.indexOf(profiler2);
  if (profilerIdx !== -1) {
    profilerCallbacks.splice(profilerIdx, 1);
  }
}
function setProfiler(profiler2) {
  if (profiler2 !== null) {
    if (!profilerCallbacks.includes(profiler2)) {
      profilerCallbacks.push(profiler2);
    }
    return () => removeProfiler2(profiler2);
  } else {
    profilerCallbacks.length = 0;
    return NOOP_PROFILER_REMOVAL2;
  }
}
function registerPreOrderHooks(directiveIndex, directiveDef, tView) {
  ngDevMode && assertFirstCreatePass(tView);
  const { ngOnChanges, ngOnInit, ngDoCheck } = directiveDef.type.prototype;
  if (ngOnChanges) {
    const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);
    (tView.preOrderHooks ??= []).push(directiveIndex, wrappedOnChanges);
    (tView.preOrderCheckHooks ??= []).push(directiveIndex, wrappedOnChanges);
  }
  if (ngOnInit) {
    (tView.preOrderHooks ??= []).push(0 - directiveIndex, ngOnInit);
  }
  if (ngDoCheck) {
    (tView.preOrderHooks ??= []).push(directiveIndex, ngDoCheck);
    (tView.preOrderCheckHooks ??= []).push(directiveIndex, ngDoCheck);
  }
}
function registerPostOrderHooks(tView, tNode) {
  ngDevMode && assertFirstCreatePass(tView);
  for (let i2 = tNode.directiveStart, end = tNode.directiveEnd; i2 < end; i2++) {
    const directiveDef = tView.data[i2];
    ngDevMode && assertDefined(directiveDef, "Expecting DirectiveDef");
    const lifecycleHooks = directiveDef.type.prototype;
    const { ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked, ngOnDestroy } = lifecycleHooks;
    if (ngAfterContentInit) {
      (tView.contentHooks ??= []).push(-i2, ngAfterContentInit);
    }
    if (ngAfterContentChecked) {
      (tView.contentHooks ??= []).push(i2, ngAfterContentChecked);
      (tView.contentCheckHooks ??= []).push(i2, ngAfterContentChecked);
    }
    if (ngAfterViewInit) {
      (tView.viewHooks ??= []).push(-i2, ngAfterViewInit);
    }
    if (ngAfterViewChecked) {
      (tView.viewHooks ??= []).push(i2, ngAfterViewChecked);
      (tView.viewCheckHooks ??= []).push(i2, ngAfterViewChecked);
    }
    if (ngOnDestroy != null) {
      (tView.destroyHooks ??= []).push(i2, ngOnDestroy);
    }
  }
}
function executeCheckHooks(lView, hooks, nodeIndex) {
  callHooks(lView, hooks, 3, nodeIndex);
}
function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
  ngDevMode && assertNotEqual(initPhase, 3, "Init pre-order hooks should not be called more than once");
  if ((lView[FLAGS] & 3) === initPhase) {
    callHooks(lView, hooks, initPhase, nodeIndex);
  }
}
function incrementInitPhaseFlags(lView, initPhase) {
  ngDevMode && assertNotEqual(initPhase, 3, "Init hooks phase should not be incremented after all init hooks have been run.");
  let flags = lView[FLAGS];
  if ((flags & 3) === initPhase) {
    flags &= 16383;
    flags += 1;
    lView[FLAGS] = flags;
  }
}
function callHooks(currentView, arr, initPhase, currentNodeIndex) {
  ngDevMode && assertEqual(isInCheckNoChangesMode(), false, "Hooks should never be run when in check no changes mode.");
  const startIndex = currentNodeIndex !== void 0 ? currentView[PREORDER_HOOK_FLAGS] & 65535 : 0;
  const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;
  const max = arr.length - 1;
  let lastNodeIndexFound = 0;
  for (let i2 = startIndex; i2 < max; i2++) {
    const hook = arr[i2 + 1];
    if (typeof hook === "number") {
      lastNodeIndexFound = arr[i2];
      if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {
        break;
      }
    } else {
      const isInitHook = arr[i2] < 0;
      if (isInitHook) {
        currentView[PREORDER_HOOK_FLAGS] += 65536;
      }
      if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {
        callHook(currentView, initPhase, arr, i2);
        currentView[PREORDER_HOOK_FLAGS] = (currentView[PREORDER_HOOK_FLAGS] & 4294901760) + i2 + 2;
      }
      i2++;
    }
  }
}
function callHookInternal(directive, hook) {
  profiler(4, directive, hook);
  const prevConsumer = setActiveConsumer(null);
  try {
    hook.call(directive);
  } finally {
    setActiveConsumer(prevConsumer);
    profiler(5, directive, hook);
  }
}
function callHook(currentView, initPhase, arr, i2) {
  const isInitHook = arr[i2] < 0;
  const hook = arr[i2 + 1];
  const directiveIndex = isInitHook ? -arr[i2] : arr[i2];
  const directive = currentView[directiveIndex];
  if (isInitHook) {
    const indexWithintInitPhase = currentView[FLAGS] >> 14;
    if (indexWithintInitPhase < currentView[PREORDER_HOOK_FLAGS] >> 16 && (currentView[FLAGS] & 3) === initPhase) {
      currentView[FLAGS] += 16384;
      callHookInternal(directive, hook);
    }
  } else {
    callHookInternal(directive, hook);
  }
}
function toTNodeTypeAsString(tNodeType) {
  let text = "";
  tNodeType & 1 && (text += "|Text");
  tNodeType & 2 && (text += "|Element");
  tNodeType & 4 && (text += "|Container");
  tNodeType & 8 && (text += "|ElementContainer");
  tNodeType & 16 && (text += "|Projection");
  tNodeType & 32 && (text += "|IcuContainer");
  tNodeType & 64 && (text += "|Placeholder");
  tNodeType & 128 && (text += "|LetDeclaration");
  return text.length > 0 ? text.substring(1) : text;
}
function isTNodeShape(value) {
  return value != null && typeof value === "object" && (value.insertBeforeIndex === null || typeof value.insertBeforeIndex === "number" || Array.isArray(value.insertBeforeIndex));
}
function hasClassInput(tNode) {
  return (tNode.flags & 8) !== 0;
}
function hasStyleInput(tNode) {
  return (tNode.flags & 16) !== 0;
}
function assertTNodeType(tNode, expectedTypes, message) {
  assertDefined(tNode, "should be called with a TNode");
  if ((tNode.type & expectedTypes) === 0) {
    throwError2(message || `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);
  }
}
function assertPureTNodeType(type) {
  if (!(type === 2 || type === 1 || type === 4 || type === 8 || type === 32 || type === 16 || type === 64 || type === 128)) {
    throwError2(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);
  }
}
function setUpAttributes(renderer, native, attrs) {
  let i2 = 0;
  while (i2 < attrs.length) {
    const value = attrs[i2];
    if (typeof value === "number") {
      if (value !== 0) {
        break;
      }
      i2++;
      const namespaceURI = attrs[i2++];
      const attrName = attrs[i2++];
      const attrVal = attrs[i2++];
      renderer.setAttribute(native, attrName, attrVal, namespaceURI);
    } else {
      const attrName = value;
      const attrVal = attrs[++i2];
      if (isAnimationProp(attrName)) {
        renderer.setProperty(native, attrName, attrVal);
      } else {
        renderer.setAttribute(native, attrName, attrVal);
      }
      i2++;
    }
  }
  return i2;
}
function isNameOnlyAttributeMarker(marker) {
  return marker === 3 || marker === 4 || marker === 6;
}
function isAnimationProp(name) {
  return name.charCodeAt(0) === 64;
}
function mergeHostAttrs(dst, src) {
  if (src === null || src.length === 0) ;
  else if (dst === null || dst.length === 0) {
    dst = src.slice();
  } else {
    let srcMarker = -1;
    for (let i2 = 0; i2 < src.length; i2++) {
      const item = src[i2];
      if (typeof item === "number") {
        srcMarker = item;
      } else {
        if (srcMarker === 0) ;
        else if (srcMarker === -1 || srcMarker === 2) {
          mergeHostAttribute(dst, srcMarker, item, null, src[++i2]);
        } else {
          mergeHostAttribute(dst, srcMarker, item, null, null);
        }
      }
    }
  }
  return dst;
}
function mergeHostAttribute(dst, marker, key1, key2, value) {
  let i2 = 0;
  let markerInsertPosition = dst.length;
  if (marker === -1) {
    markerInsertPosition = -1;
  } else {
    while (i2 < dst.length) {
      const dstValue = dst[i2++];
      if (typeof dstValue === "number") {
        if (dstValue === marker) {
          markerInsertPosition = -1;
          break;
        } else if (dstValue > marker) {
          markerInsertPosition = i2 - 1;
          break;
        }
      }
    }
  }
  while (i2 < dst.length) {
    const item = dst[i2];
    if (typeof item === "number") {
      break;
    } else if (item === key1) {
      {
        if (value !== null) {
          dst[i2 + 1] = value;
        }
        return;
      }
    }
    i2++;
    if (value !== null)
      i2++;
  }
  if (markerInsertPosition !== -1) {
    dst.splice(markerInsertPosition, 0, marker);
    i2 = markerInsertPosition + 1;
  }
  dst.splice(i2++, 0, key1);
  if (value !== null) {
    dst.splice(i2++, 0, value);
  }
}
function hasParentInjector(parentLocation) {
  return parentLocation !== NO_PARENT_INJECTOR;
}
function getParentInjectorIndex(parentLocation) {
  if (ngDevMode) {
    assertNumber(parentLocation, "Number expected");
    assertNotEqual(parentLocation, -1, "Not a valid state.");
    const parentInjectorIndex = parentLocation & 32767;
    assertGreaterThan(parentInjectorIndex, HEADER_OFFSET, "Parent injector must be pointing past HEADER_OFFSET.");
  }
  return parentLocation & 32767;
}
function getParentInjectorViewOffset(parentLocation) {
  return parentLocation >> 16;
}
function getParentInjectorView(location2, startView) {
  let viewOffset = getParentInjectorViewOffset(location2);
  let parentView = startView;
  while (viewOffset > 0) {
    parentView = parentView[DECLARATION_VIEW];
    viewOffset--;
  }
  return parentView;
}
function setIncludeViewProviders(v) {
  const oldValue = includeViewProviders;
  includeViewProviders = v;
  return oldValue;
}
function bloomAdd(injectorIndex, tView, type) {
  ngDevMode && assertEqual(tView.firstCreatePass, true, "expected firstCreatePass to be true");
  let id2;
  if (typeof type === "string") {
    id2 = type.charCodeAt(0) || 0;
  } else if (type.hasOwnProperty(NG_ELEMENT_ID)) {
    id2 = type[NG_ELEMENT_ID];
  }
  if (id2 == null) {
    id2 = type[NG_ELEMENT_ID] = nextNgElementId++;
  }
  const bloomHash = id2 & BLOOM_MASK;
  const mask = 1 << bloomHash;
  tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;
}
function getOrCreateNodeInjectorForNode(tNode, lView) {
  const existingInjectorIndex = getInjectorIndex(tNode, lView);
  if (existingInjectorIndex !== -1) {
    return existingInjectorIndex;
  }
  const tView = lView[TVIEW];
  if (tView.firstCreatePass) {
    tNode.injectorIndex = lView.length;
    insertBloom(tView.data, tNode);
    insertBloom(lView, null);
    insertBloom(tView.blueprint, null);
  }
  const parentLoc = getParentInjectorLocation(tNode, lView);
  const injectorIndex = tNode.injectorIndex;
  if (hasParentInjector(parentLoc)) {
    const parentIndex = getParentInjectorIndex(parentLoc);
    const parentLView = getParentInjectorView(parentLoc, lView);
    const parentData = parentLView[TVIEW].data;
    for (let i2 = 0; i2 < 8; i2++) {
      lView[injectorIndex + i2] = parentLView[parentIndex + i2] | parentData[parentIndex + i2];
    }
  }
  lView[
    injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  ] = parentLoc;
  return injectorIndex;
}
function insertBloom(arr, footer) {
  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
}
function getInjectorIndex(tNode, lView) {
  if (tNode.injectorIndex === -1 || // If the injector index is the same as its parent's injector index, then the index has been
  // copied down from the parent node. No injector has been created yet on this node.
  tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || // After the first template pass, the injector index might exist but the parent values
  // might not have been calculated yet for this instance
  lView[
    tNode.injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  ] === null) {
    return -1;
  } else {
    ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);
    return tNode.injectorIndex;
  }
}
function getParentInjectorLocation(tNode, lView) {
  if (tNode.parent && tNode.parent.injectorIndex !== -1) {
    return tNode.parent.injectorIndex;
  }
  let declarationViewOffset = 0;
  let parentTNode = null;
  let lViewCursor = lView;
  while (lViewCursor !== null) {
    parentTNode = getTNodeFromLView(lViewCursor);
    if (parentTNode === null) {
      return NO_PARENT_INJECTOR;
    }
    ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]);
    declarationViewOffset++;
    lViewCursor = lViewCursor[DECLARATION_VIEW];
    if (parentTNode.injectorIndex !== -1) {
      return parentTNode.injectorIndex | declarationViewOffset << 16;
    }
  }
  return NO_PARENT_INJECTOR;
}
function diPublicInInjector(injectorIndex, tView, token) {
  bloomAdd(injectorIndex, tView, token);
}
function injectAttributeImpl(tNode, attrNameToInject) {
  ngDevMode && assertTNodeType(
    tNode,
    12 | 3
    /* TNodeType.AnyRNode */
  );
  ngDevMode && assertDefined(tNode, "expecting tNode");
  if (attrNameToInject === "class") {
    return tNode.classes;
  }
  if (attrNameToInject === "style") {
    return tNode.styles;
  }
  const attrs = tNode.attrs;
  if (attrs) {
    const attrsLength = attrs.length;
    let i2 = 0;
    while (i2 < attrsLength) {
      const value = attrs[i2];
      if (isNameOnlyAttributeMarker(value))
        break;
      if (value === 0) {
        i2 = i2 + 2;
      } else if (typeof value === "number") {
        i2++;
        while (i2 < attrsLength && typeof attrs[i2] === "string") {
          i2++;
        }
      } else if (value === attrNameToInject) {
        return attrs[i2 + 1];
      } else {
        i2 = i2 + 2;
      }
    }
  }
  return null;
}
function notFoundValueOrThrow(notFoundValue, token, flags) {
  if (flags & 8 || notFoundValue !== void 0) {
    return notFoundValue;
  } else {
    throwProviderNotFoundError(token, "NodeInjector");
  }
}
function lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {
  if (flags & 8 && notFoundValue === void 0) {
    notFoundValue = null;
  }
  if ((flags & (2 | 1)) === 0) {
    const moduleInjector = lView[INJECTOR];
    const previousInjectImplementation = setInjectImplementation(void 0);
    try {
      if (moduleInjector) {
        return moduleInjector.get(
          token,
          notFoundValue,
          flags & 8
          /* InternalInjectFlags.Optional */
        );
      } else {
        return injectRootLimpMode(
          token,
          notFoundValue,
          flags & 8
          /* InternalInjectFlags.Optional */
        );
      }
    } finally {
      setInjectImplementation(previousInjectImplementation);
    }
  }
  return notFoundValueOrThrow(notFoundValue, token, flags);
}
function getOrCreateInjectable(tNode, lView, token, flags = 0, notFoundValue) {
  if (tNode !== null) {
    if (lView[FLAGS] & 2048 && // The token must be present on the current node injector when the `Self`
    // flag is set, so the lookup on embedded view injector(s) can be skipped.
    !(flags & 2)) {
      const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND2);
      if (embeddedInjectorValue !== NOT_FOUND2) {
        return embeddedInjectorValue;
      }
    }
    const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND2);
    if (value !== NOT_FOUND2) {
      return value;
    }
  }
  return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
}
function lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {
  const bloomHash = bloomHashBitOrFactory(token);
  if (typeof bloomHash === "function") {
    if (!enterDI(lView, tNode, flags)) {
      return flags & 1 ? notFoundValueOrThrow(notFoundValue, token, flags) : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
    }
    try {
      let value;
      if (ngDevMode) {
        runInInjectorProfilerContext(new NodeInjector(getCurrentTNode(), getLView()), token, () => {
          emitInjectorToCreateInstanceEvent(token);
          value = bloomHash(flags);
          emitInstanceCreatedByInjectorEvent(value);
        });
      } else {
        value = bloomHash(flags);
      }
      if (value == null && !(flags & 8)) {
        throwProviderNotFoundError(token);
      } else {
        return value;
      }
    } finally {
      leaveDI();
    }
  } else if (typeof bloomHash === "number") {
    let previousTView = null;
    let injectorIndex = getInjectorIndex(tNode, lView);
    let parentLocation = NO_PARENT_INJECTOR;
    let hostTElementNode = flags & 1 ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;
    if (injectorIndex === -1 || flags & 4) {
      parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) : lView[
        injectorIndex + 8
        /* NodeInjectorOffset.PARENT */
      ];
      if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {
        injectorIndex = -1;
      } else {
        previousTView = lView[TVIEW];
        injectorIndex = getParentInjectorIndex(parentLocation);
        lView = getParentInjectorView(parentLocation, lView);
      }
    }
    while (injectorIndex !== -1) {
      ngDevMode && assertNodeInjector(lView, injectorIndex);
      const tView = lView[TVIEW];
      ngDevMode && assertTNodeForLView(tView.data[
        injectorIndex + 8
        /* NodeInjectorOffset.TNODE */
      ], lView);
      if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
        const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
        if (instance !== NOT_FOUND2) {
          return instance;
        }
      }
      parentLocation = lView[
        injectorIndex + 8
        /* NodeInjectorOffset.PARENT */
      ];
      if (parentLocation !== NO_PARENT_INJECTOR && shouldSearchParent(flags, lView[TVIEW].data[
        injectorIndex + 8
        /* NodeInjectorOffset.TNODE */
      ] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView)) {
        previousTView = tView;
        injectorIndex = getParentInjectorIndex(parentLocation);
        lView = getParentInjectorView(parentLocation, lView);
      } else {
        injectorIndex = -1;
      }
    }
  }
  return notFoundValue;
}
function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
  const currentTView = lView[TVIEW];
  const tNode = currentTView.data[
    injectorIndex + 8
    /* NodeInjectorOffset.TNODE */
  ];
  const canAccessViewProviders = previousTView == null ? (
    // 1) This is the first invocation `previousTView == null` which means that we are at the
    // `TNode` of where injector is starting to look. In such a case the only time we are allowed
    // to look into the ViewProviders is if:
    // - we are on a component
    // - AND the injector set `includeViewProviders` to true (implying that the token can see
    // ViewProviders because it is the Component or a Service which itself was declared in
    // ViewProviders)
    isComponentHost(tNode) && includeViewProviders
  ) : (
    // 2) `previousTView != null` which means that we are now walking across the parent nodes.
    // In such a case we are only allowed to look into the ViewProviders if:
    // - We just crossed from child View to Parent View `previousTView != currentTView`
    // - AND the parent TNode is an Element.
    // This means that we just came from the Component's View and therefore are allowed to see
    // into the ViewProviders.
    previousTView != currentTView && (tNode.type & 3) !== 0
  );
  const isHostSpecialCase = flags & 1 && hostTElementNode === tNode;
  const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);
  if (injectableIdx !== null) {
    return getNodeInjectable(lView, currentTView, injectableIdx, tNode, flags);
  } else {
    return NOT_FOUND2;
  }
}
function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
  const nodeProviderIndexes = tNode.providerIndexes;
  const tInjectables = tView.data;
  const injectablesStart = nodeProviderIndexes & 1048575;
  const directivesStart = tNode.directiveStart;
  const directiveEnd = tNode.directiveEnd;
  const cptViewProvidersCount = nodeProviderIndexes >> 20;
  const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;
  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;
  for (let i2 = startingIndex; i2 < endIndex; i2++) {
    const providerTokenOrDef = tInjectables[i2];
    if (i2 < directivesStart && token === providerTokenOrDef || i2 >= directivesStart && providerTokenOrDef.type === token) {
      return i2;
    }
  }
  if (isHostSpecialCase) {
    const dirDef = tInjectables[directivesStart];
    if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {
      return directivesStart;
    }
  }
  return null;
}
function getNodeInjectable(lView, tView, index, tNode, flags) {
  let value = lView[index];
  const tData = tView.data;
  if (value instanceof NodeInjectorFactory) {
    const factory = value;
    ngDevMode && injectionPath.push(factory.name ?? "unknown");
    if (factory.resolving) {
      const token2 = stringifyForError(tData[index]);
      if (ngDevMode) {
        throw cyclicDependencyErrorWithDetails(token2, injectionPath);
      } else {
        throw cyclicDependencyError(token2);
      }
    }
    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
    factory.resolving = true;
    const token = tData[index].type || tData[index];
    let prevInjectContext;
    if (ngDevMode) {
      const injector = new NodeInjector(tNode, lView);
      prevInjectContext = setInjectorProfilerContext({ injector, token });
    }
    const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;
    const success = enterDI(
      lView,
      tNode,
      0
      /* InternalInjectFlags.Default */
    );
    ngDevMode && assertEqual(success, true, "Because flags do not contain `SkipSelf' we expect this to always succeed.");
    try {
      ngDevMode && emitInjectorToCreateInstanceEvent(token);
      value = lView[index] = factory.factory(void 0, flags, tData, lView, tNode);
      ngDevMode && emitInstanceCreatedByInjectorEvent(value);
      if (tView.firstCreatePass && index >= tNode.directiveStart) {
        ngDevMode && assertDirectiveDef(tData[index]);
        registerPreOrderHooks(index, tData[index], tView);
      }
    } finally {
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
      previousInjectImplementation !== null && setInjectImplementation(previousInjectImplementation);
      setIncludeViewProviders(previousIncludeViewProviders);
      factory.resolving = false;
      leaveDI();
      ngDevMode && (injectionPath = []);
    }
  }
  return value;
}
function bloomHashBitOrFactory(token) {
  ngDevMode && assertDefined(token, "token must be defined");
  if (typeof token === "string") {
    return token.charCodeAt(0) || 0;
  }
  const tokenId = (
    // First check with `hasOwnProperty` so we don't get an inherited ID.
    token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : void 0
  );
  if (typeof tokenId === "number") {
    if (tokenId >= 0) {
      return tokenId & BLOOM_MASK;
    } else {
      ngDevMode && assertEqual(tokenId, -1, "Expecting to get Special Injector Id");
      return createNodeInjector;
    }
  } else {
    return tokenId;
  }
}
function bloomHasToken(bloomHash, injectorIndex, injectorView) {
  const mask = 1 << bloomHash;
  const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];
  return !!(value & mask);
}
function shouldSearchParent(flags, isFirstHostTNode) {
  return !(flags & 2) && !(flags & 1 && isFirstHostTNode);
}
function getNodeInjectorLView(nodeInjector) {
  return nodeInjector._lView;
}
function getNodeInjectorTNode(nodeInjector) {
  return nodeInjector._tNode;
}
function createNodeInjector() {
  return new NodeInjector(getCurrentTNode(), getLView());
}
function \u0275\u0275getInheritedFactory(type) {
  return noSideEffects(() => {
    const ownConstructor = type.prototype.constructor;
    const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);
    const objectPrototype = Object.prototype;
    let parent = Object.getPrototypeOf(type.prototype).constructor;
    while (parent && parent !== objectPrototype) {
      const factory = parent[NG_FACTORY_DEF] || getFactoryOf(parent);
      if (factory && factory !== ownFactory) {
        return factory;
      }
      parent = Object.getPrototypeOf(parent);
    }
    return (t2) => new t2();
  });
}
function getFactoryOf(type) {
  if (isForwardRef(type)) {
    return () => {
      const factory = getFactoryOf(resolveForwardRef(type));
      return factory && factory();
    };
  }
  return getFactoryDef(type);
}
function lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {
  let currentTNode = tNode;
  let currentLView = lView;
  while (currentTNode !== null && currentLView !== null && currentLView[FLAGS] & 2048 && !isRootView(currentLView)) {
    ngDevMode && assertTNodeForLView(currentTNode, currentLView);
    const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | 2, NOT_FOUND2);
    if (nodeInjectorValue !== NOT_FOUND2) {
      return nodeInjectorValue;
    }
    let parentTNode = currentTNode.parent;
    if (!parentTNode) {
      const embeddedViewInjector = currentLView[EMBEDDED_VIEW_INJECTOR];
      if (embeddedViewInjector) {
        const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND2, flags);
        if (embeddedViewInjectorValue !== NOT_FOUND2) {
          return embeddedViewInjectorValue;
        }
      }
      parentTNode = getTNodeFromLView(currentLView);
      currentLView = currentLView[DECLARATION_VIEW];
    }
    currentTNode = parentTNode;
  }
  return notFoundValue;
}
function getTNodeFromLView(lView) {
  const tView = lView[TVIEW];
  const tViewType = tView.type;
  if (tViewType === 2) {
    ngDevMode && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents.");
    return tView.declTNode;
  } else if (tViewType === 1) {
    return lView[T_HOST];
  }
  return null;
}
function \u0275\u0275injectAttribute(attrNameToInject) {
  return injectAttributeImpl(getCurrentTNode(), attrNameToInject);
}
function getReflect() {
  return _reflect = _reflect || new ReflectionCapabilities();
}
function reflectDependencies(type) {
  return convertDependencies(getReflect().parameters(type));
}
function convertDependencies(deps) {
  return deps.map((dep) => reflectDependency(dep));
}
function reflectDependency(dep) {
  const meta = {
    token: null,
    attribute: null,
    host: false,
    optional: false,
    self: false,
    skipSelf: false
  };
  if (Array.isArray(dep) && dep.length > 0) {
    for (let j2 = 0; j2 < dep.length; j2++) {
      const param = dep[j2];
      if (param === void 0) {
        continue;
      }
      const proto = Object.getPrototypeOf(param);
      if (param instanceof Optional || proto.ngMetadataName === "Optional") {
        meta.optional = true;
      } else if (param instanceof SkipSelf || proto.ngMetadataName === "SkipSelf") {
        meta.skipSelf = true;
      } else if (param instanceof Self || proto.ngMetadataName === "Self") {
        meta.self = true;
      } else if (param instanceof Host || proto.ngMetadataName === "Host") {
        meta.host = true;
      } else if (param instanceof Inject) {
        meta.token = param.token;
      } else if (param instanceof Attribute) {
        if (param.attributeName === void 0) {
          throw new RuntimeError(204, ngDevMode && `Attribute name must be defined.`);
        }
        meta.attribute = param.attributeName;
      } else {
        meta.token = param;
      }
    }
  } else if (dep === void 0 || Array.isArray(dep) && dep.length === 0) {
    meta.token = null;
  } else {
    meta.token = dep;
  }
  return meta;
}
function compileInjectable(type, meta) {
  let ngInjectableDef = null;
  let ngFactoryDef = null;
  if (!type.hasOwnProperty(NG_PROV_DEF)) {
    Object.defineProperty(type, NG_PROV_DEF, {
      get: () => {
        if (ngInjectableDef === null) {
          const compiler = getCompilerFacade({
            usage: 0,
            kind: "injectable",
            type
          });
          ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/\u0275prov.js`, getInjectableMetadata(type, meta));
        }
        return ngInjectableDef;
      }
    });
  }
  if (!type.hasOwnProperty(NG_FACTORY_DEF)) {
    Object.defineProperty(type, NG_FACTORY_DEF, {
      get: () => {
        if (ngFactoryDef === null) {
          const compiler = getCompilerFacade({
            usage: 0,
            kind: "injectable",
            type
          });
          ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/\u0275fac.js`, {
            name: type.name,
            type,
            typeArgumentCount: 0,
            // In JIT mode types are not available nor used.
            deps: reflectDependencies(type),
            target: compiler.FactoryTarget.Injectable
          });
        }
        return ngFactoryDef;
      },
      // Leave this configurable so that the factories from directives or pipes can take precedence.
      configurable: true
    });
  }
}
function isUseClassProvider(meta) {
  return meta.useClass !== void 0;
}
function isUseValueProvider(meta) {
  return USE_VALUE2 in meta;
}
function isUseFactoryProvider(meta) {
  return meta.useFactory !== void 0;
}
function isUseExistingProvider(meta) {
  return meta.useExisting !== void 0;
}
function getInjectableMetadata(type, srcMeta) {
  const meta = srcMeta || { providedIn: null };
  const compilerMeta = {
    name: type.name,
    type,
    typeArgumentCount: 0,
    providedIn: meta.providedIn
  };
  if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== void 0) {
    compilerMeta.deps = convertDependencies(meta.deps);
  }
  if (isUseClassProvider(meta)) {
    compilerMeta.useClass = meta.useClass;
  } else if (isUseValueProvider(meta)) {
    compilerMeta.useValue = meta.useValue;
  } else if (isUseFactoryProvider(meta)) {
    compilerMeta.useFactory = meta.useFactory;
  } else if (isUseExistingProvider(meta)) {
    compilerMeta.useExisting = meta.useExisting;
  }
  return compilerMeta;
}
function injectElementRef() {
  return createElementRef(getCurrentTNode(), getLView());
}
function createElementRef(tNode, lView) {
  return new ElementRef(getNativeByTNode(tNode, lView));
}
function unwrapElementRef(value) {
  return value instanceof ElementRef ? value.nativeElement : value;
}
function symbolIterator() {
  return this._results[Symbol.iterator]();
}
function hasInSkipHydrationBlockFlag(tNode) {
  return (tNode.flags & 128) === 128;
}
function getUniqueLViewId() {
  return uniqueIdCounter++;
}
function registerLView(lView) {
  ngDevMode && assertNumber(lView[ID], "LView must have an ID in order to be registered");
  TRACKED_LVIEWS.set(lView[ID], lView);
}
function getLViewById(id2) {
  ngDevMode && assertNumber(id2, "ID used for LView lookup must be a number");
  return TRACKED_LVIEWS.get(id2) || null;
}
function unregisterLView(lView) {
  ngDevMode && assertNumber(lView[ID], "Cannot stop tracking an LView that does not have an ID");
  TRACKED_LVIEWS.delete(lView[ID]);
}
function getTrackedLViews() {
  return TRACKED_LVIEWS;
}
function getLContext(target) {
  let mpValue = readPatchedData(target);
  if (mpValue) {
    if (isLView(mpValue)) {
      const lView = mpValue;
      let nodeIndex;
      let component = void 0;
      let directives = void 0;
      if (isComponentInstance(target)) {
        nodeIndex = findViaComponent(lView, target);
        if (nodeIndex == -1) {
          throw new Error("The provided component was not found in the application");
        }
        component = target;
      } else if (isDirectiveInstance(target)) {
        nodeIndex = findViaDirective(lView, target);
        if (nodeIndex == -1) {
          throw new Error("The provided directive was not found in the application");
        }
        directives = getDirectivesAtNodeIndex(nodeIndex, lView);
      } else {
        nodeIndex = findViaNativeElement(lView, target);
        if (nodeIndex == -1) {
          return null;
        }
      }
      const native = unwrapRNode(lView[nodeIndex]);
      const existingCtx = readPatchedData(native);
      const context2 = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);
      if (component && context2.component === void 0) {
        context2.component = component;
        attachPatchData(context2.component, context2);
      }
      if (directives && context2.directives === void 0) {
        context2.directives = directives;
        for (let i2 = 0; i2 < directives.length; i2++) {
          attachPatchData(directives[i2], context2);
        }
      }
      attachPatchData(context2.native, context2);
      mpValue = context2;
    }
  } else {
    const rElement = target;
    ngDevMode && assertDomNode(rElement);
    let parent = rElement;
    while (parent = parent.parentNode) {
      const parentContext = readPatchedData(parent);
      if (parentContext) {
        const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView;
        if (!lView) {
          return null;
        }
        const index = findViaNativeElement(lView, rElement);
        if (index >= 0) {
          const native = unwrapRNode(lView[index]);
          const context2 = createLContext(lView, index, native);
          attachPatchData(native, context2);
          mpValue = context2;
          break;
        }
      }
    }
  }
  return mpValue || null;
}
function createLContext(lView, nodeIndex, native) {
  return new LContext(lView[ID], nodeIndex, native);
}
function getComponentViewByInstance(componentInstance) {
  let patchedData = readPatchedData(componentInstance);
  let lView;
  if (isLView(patchedData)) {
    const contextLView = patchedData;
    const nodeIndex = findViaComponent(contextLView, componentInstance);
    lView = getComponentLViewByIndex(nodeIndex, contextLView);
    const context2 = createLContext(contextLView, nodeIndex, lView[HOST]);
    context2.component = componentInstance;
    attachPatchData(componentInstance, context2);
    attachPatchData(context2.native, context2);
  } else {
    const context2 = patchedData;
    const contextLView = context2.lView;
    ngDevMode && assertLView(contextLView);
    lView = getComponentLViewByIndex(context2.nodeIndex, contextLView);
  }
  return lView;
}
function attachPatchData(target, data) {
  ngDevMode && assertDefined(target, "Target expected");
  if (isLView(data)) {
    target[MONKEY_PATCH_KEY_NAME] = data[ID];
    registerLView(data);
  } else {
    target[MONKEY_PATCH_KEY_NAME] = data;
  }
}
function readPatchedData(target) {
  ngDevMode && assertDefined(target, "Target expected");
  const data = target[MONKEY_PATCH_KEY_NAME];
  return typeof data === "number" ? getLViewById(data) : data || null;
}
function readPatchedLView(target) {
  const value = readPatchedData(target);
  if (value) {
    return isLView(value) ? value : value.lView;
  }
  return null;
}
function isComponentInstance(instance) {
  return instance && instance.constructor && instance.constructor.\u0275cmp;
}
function isDirectiveInstance(instance) {
  return instance && instance.constructor && instance.constructor.\u0275dir;
}
function findViaNativeElement(lView, target) {
  const tView = lView[TVIEW];
  for (let i2 = HEADER_OFFSET; i2 < tView.bindingStartIndex; i2++) {
    if (unwrapRNode(lView[i2]) === target) {
      return i2;
    }
  }
  return -1;
}
function traverseNextElement(tNode) {
  if (tNode.child) {
    return tNode.child;
  } else if (tNode.next) {
    return tNode.next;
  } else {
    while (tNode.parent && !tNode.parent.next) {
      tNode = tNode.parent;
    }
    return tNode.parent && tNode.parent.next;
  }
}
function findViaComponent(lView, componentInstance) {
  const componentIndices = lView[TVIEW].components;
  if (componentIndices) {
    for (let i2 = 0; i2 < componentIndices.length; i2++) {
      const elementComponentIndex = componentIndices[i2];
      const componentView = getComponentLViewByIndex(elementComponentIndex, lView);
      if (componentView[CONTEXT] === componentInstance) {
        return elementComponentIndex;
      }
    }
  } else {
    const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);
    const rootComponent = rootComponentView[CONTEXT];
    if (rootComponent === componentInstance) {
      return HEADER_OFFSET;
    }
  }
  return -1;
}
function findViaDirective(lView, directiveInstance) {
  let tNode = lView[TVIEW].firstChild;
  while (tNode) {
    const directiveIndexStart = tNode.directiveStart;
    const directiveIndexEnd = tNode.directiveEnd;
    for (let i2 = directiveIndexStart; i2 < directiveIndexEnd; i2++) {
      if (lView[i2] === directiveInstance) {
        return tNode.index;
      }
    }
    tNode = traverseNextElement(tNode);
  }
  return -1;
}
function getDirectivesAtNodeIndex(nodeIndex, lView) {
  const tNode = lView[TVIEW].data[nodeIndex];
  if (tNode.directiveStart === 0)
    return EMPTY_ARRAY;
  const results = [];
  for (let i2 = tNode.directiveStart; i2 < tNode.directiveEnd; i2++) {
    const directiveInstance = lView[i2];
    if (!isComponentInstance(directiveInstance)) {
      results.push(directiveInstance);
    }
  }
  return results;
}
function getComponentAtNodeIndex(nodeIndex, lView) {
  const tNode = lView[TVIEW].data[nodeIndex];
  return isComponentHost(tNode) ? lView[tNode.directiveStart + tNode.componentOffset] : null;
}
function getRootView(componentOrLView) {
  ngDevMode && assertDefined(componentOrLView, "component");
  let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);
  while (lView && !isRootView(lView)) {
    lView = getLViewParent(lView);
  }
  ngDevMode && assertLView(lView);
  return lView;
}
function getRootContext(viewOrComponent) {
  const rootView = getRootView(viewOrComponent);
  ngDevMode && assertDefined(rootView[CONTEXT], "Root view has no context. Perhaps it is disconnected?");
  return rootView[CONTEXT];
}
function getFirstLContainer(lView) {
  return getNearestLContainer(lView[CHILD_HEAD]);
}
function getNextLContainer(container) {
  return getNearestLContainer(container[NEXT]);
}
function getNearestLContainer(viewOrContainer) {
  while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {
    viewOrContainer = viewOrContainer[NEXT];
  }
  return viewOrContainer;
}
function getComponent(element) {
  ngDevMode && assertDomElement(element);
  const context2 = getLContext(element);
  if (context2 === null)
    return null;
  if (context2.component === void 0) {
    const lView = context2.lView;
    if (lView === null) {
      return null;
    }
    context2.component = getComponentAtNodeIndex(context2.nodeIndex, lView);
  }
  return context2.component;
}
function getContext(element) {
  assertDomElement(element);
  const context2 = getLContext(element);
  const lView = context2 ? context2.lView : null;
  return lView === null ? null : lView[CONTEXT];
}
function getOwningComponent(elementOrDir) {
  const context2 = getLContext(elementOrDir);
  let lView = context2 ? context2.lView : null;
  if (lView === null)
    return null;
  let parent;
  while (lView[TVIEW].type === 2 && (parent = getLViewParent(lView))) {
    lView = parent;
  }
  return isRootView(lView) ? null : lView[CONTEXT];
}
function getRootComponents(elementOrDir) {
  const lView = readPatchedLView(elementOrDir);
  return lView !== null ? [getRootContext(lView)] : [];
}
function getInjector(elementOrDir) {
  const context2 = getLContext(elementOrDir);
  const lView = context2 ? context2.lView : null;
  if (lView === null)
    return Injector.NULL;
  const tNode = lView[TVIEW].data[context2.nodeIndex];
  return new NodeInjector(tNode, lView);
}
function getDirectives(node) {
  if (node instanceof Text) {
    return [];
  }
  const context2 = getLContext(node);
  const lView = context2 ? context2.lView : null;
  if (lView === null) {
    return [];
  }
  const tView = lView[TVIEW];
  const nodeIndex = context2.nodeIndex;
  if (!tView?.data[nodeIndex]) {
    return [];
  }
  if (context2.directives === void 0) {
    context2.directives = getDirectivesAtNodeIndex(nodeIndex, lView);
  }
  return context2.directives === null ? [] : [...context2.directives];
}
function getDirectiveMetadata$1(directiveOrComponentInstance) {
  const { constructor } = directiveOrComponentInstance;
  if (!constructor) {
    throw new Error("Unable to find the instance constructor");
  }
  const componentDef = getComponentDef(constructor);
  if (componentDef) {
    const inputs = extractInputDebugMetadata(componentDef.inputs);
    return {
      inputs,
      outputs: componentDef.outputs,
      encapsulation: componentDef.encapsulation,
      changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush : ChangeDetectionStrategy.Default
    };
  }
  const directiveDef = getDirectiveDef(constructor);
  if (directiveDef) {
    const inputs = extractInputDebugMetadata(directiveDef.inputs);
    return { inputs, outputs: directiveDef.outputs };
  }
  return null;
}
function getHostElement(componentOrDirective) {
  return getLContext(componentOrDirective).native;
}
function getListeners(element) {
  ngDevMode && assertDomElement(element);
  const lContext = getLContext(element);
  const lView = lContext === null ? null : lContext.lView;
  if (lView === null)
    return [];
  const tView = lView[TVIEW];
  const lCleanup = lView[CLEANUP];
  const tCleanup = tView.cleanup;
  const listeners = [];
  if (tCleanup && lCleanup) {
    for (let i2 = 0; i2 < tCleanup.length; ) {
      const firstParam = tCleanup[i2++];
      const secondParam = tCleanup[i2++];
      if (typeof firstParam === "string") {
        const name = firstParam;
        const listenerElement = unwrapRNode(lView[secondParam]);
        const callback = lCleanup[tCleanup[i2++]];
        const useCaptureOrIndx = tCleanup[i2++];
        const type = typeof useCaptureOrIndx === "boolean" || useCaptureOrIndx >= 0 ? "dom" : "output";
        const useCapture = typeof useCaptureOrIndx === "boolean" ? useCaptureOrIndx : false;
        if (element == listenerElement) {
          listeners.push({ element, name, callback, useCapture, type });
        }
      }
    }
  }
  listeners.sort(sortListeners);
  return listeners;
}
function sortListeners(a2, b2) {
  if (a2.name == b2.name)
    return 0;
  return a2.name < b2.name ? -1 : 1;
}
function assertDomElement(value) {
  if (typeof Element !== "undefined" && !(value instanceof Element)) {
    throw new Error("Expecting instance of DOM Element");
  }
}
function extractInputDebugMetadata(inputs) {
  const res = {};
  for (const key in inputs) {
    if (inputs.hasOwnProperty(key)) {
      const value = inputs[key];
      if (value !== void 0) {
        res[key] = value[0];
      }
    }
  }
  return res;
}
function setDocument(document2) {
  DOCUMENT2 = document2;
}
function getDocument() {
  if (DOCUMENT2 !== void 0) {
    return DOCUMENT2;
  } else if (typeof document !== "undefined") {
    return document;
  }
  throw new RuntimeError(210, (typeof ngDevMode === "undefined" || ngDevMode) && `The document object is not available in this context. Make sure the DOCUMENT injection token is provided.`);
}
function makeStateKey(key) {
  return key;
}
function initTransferState() {
  const transferState = new TransferState();
  if (true) {
    transferState.store = retrieveTransferredState(getDocument(), inject2(APP_ID));
  }
  return transferState;
}
function retrieveTransferredState(doc, appId) {
  const script = doc.getElementById(appId + "-state");
  if (script?.textContent) {
    try {
      return JSON.parse(script.textContent);
    } catch (e2) {
      console.warn("Exception while restoring TransferState for app " + appId, e2);
    }
  }
  return {};
}
function onInteraction(trigger, callback) {
  let entry = interactionTriggers.get(trigger);
  if (!entry) {
    entry = new DeferEventEntry();
    interactionTriggers.set(trigger, entry);
    for (const name of interactionEventNames) {
      trigger.addEventListener(name, entry.listener, eventListenerOptions);
    }
  }
  entry.callbacks.add(callback);
  return () => {
    const { callbacks, listener } = entry;
    callbacks.delete(callback);
    if (callbacks.size === 0) {
      interactionTriggers.delete(trigger);
      for (const name of interactionEventNames) {
        trigger.removeEventListener(name, listener, eventListenerOptions);
      }
    }
  };
}
function onHover(trigger, callback) {
  let entry = hoverTriggers.get(trigger);
  if (!entry) {
    entry = new DeferEventEntry();
    hoverTriggers.set(trigger, entry);
    for (const name of hoverEventNames) {
      trigger.addEventListener(name, entry.listener, eventListenerOptions);
    }
  }
  entry.callbacks.add(callback);
  return () => {
    const { callbacks, listener } = entry;
    callbacks.delete(callback);
    if (callbacks.size === 0) {
      for (const name of hoverEventNames) {
        trigger.removeEventListener(name, listener, eventListenerOptions);
      }
      hoverTriggers.delete(trigger);
    }
  };
}
function createIntersectionObserver() {
  return new IntersectionObserver((entries) => {
    for (const current of entries) {
      if (current.isIntersecting && viewportTriggers.has(current.target)) {
        viewportTriggers.get(current.target).listener();
      }
    }
  });
}
function onViewport(trigger, callback, observerFactoryFn) {
  let entry = viewportTriggers.get(trigger);
  intersectionObserver = intersectionObserver || observerFactoryFn();
  if (!entry) {
    entry = new DeferEventEntry();
    intersectionObserver.observe(trigger);
    viewportTriggers.set(trigger, entry);
    observedViewportElements++;
  }
  entry.callbacks.add(callback);
  return () => {
    if (!viewportTriggers.has(trigger)) {
      return;
    }
    entry.callbacks.delete(callback);
    if (entry.callbacks.size === 0) {
      intersectionObserver?.unobserve(trigger);
      viewportTriggers.delete(trigger);
      observedViewportElements--;
    }
    if (observedViewportElements === 0) {
      intersectionObserver?.disconnect();
      intersectionObserver = null;
    }
  };
}
function stashEventListenerImpl(lView, target, eventName, wrappedListener) {
  _stashEventListenerImpl(lView, target, eventName, wrappedListener);
}
function isDetachedByI18n(tNode) {
  return (tNode.flags & 32) === 32;
}
function retrieveHydrationInfo(rNode, injector, isRootView2 = false) {
  return _retrieveHydrationInfoImpl(rNode, injector, isRootView2);
}
function getLNodeForHydration(viewRef) {
  let lView = viewRef._lView;
  const tView = lView[TVIEW];
  if (tView.type === 2) {
    return null;
  }
  if (isRootView(lView)) {
    lView = lView[HEADER_OFFSET];
  }
  return lView;
}
function patchHydrationInfo(node, info) {
  node[HYDRATION_INFO_KEY] = info;
}
function markRNodeAsHavingHydrationMismatch(node, expectedNodeDetails = null, actualNodeDetails = null) {
  if (!ngDevMode) {
    throw new Error("Calling `markRNodeAsMismatchedByHydration` in prod mode is not supported and likely a mistake.");
  }
  while (node && !getComponent(node)) {
    node = node?.parentNode;
  }
  if (node) {
    patchHydrationInfo(node, {
      status: HydrationStatus.Mismatched,
      expectedNodeDetails,
      actualNodeDetails
    });
  }
}
function isIncrementalHydrationEnabled(injector) {
  return injector.get(IS_INCREMENTAL_HYDRATION_ENABLED, false, {
    optional: true
  });
}
function assertIncrementalHydrationIsConfigured(injector) {
  if (!isIncrementalHydrationEnabled(injector)) {
    throw new RuntimeError(508, "Angular has detected that some `@defer` blocks use `hydrate` triggers, but incremental hydration was not enabled. Please ensure that the `withIncrementalHydration()` call is added as an argument for the `provideClientHydration()` function call in your application config.");
  }
}
function assertSsrIdDefined(ssrUniqueId) {
  assertDefined(ssrUniqueId, "Internal error: expecting an SSR id for a defer block that should be hydrated, but the id is not present");
}
function getParentBlockHydrationQueue(deferBlockId, injector) {
  const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
  const transferState = injector.get(TransferState);
  const deferBlockParents = transferState.get(NGH_DEFER_BLOCKS_KEY, {});
  let isTopMostDeferBlock = false;
  let currentBlockId = deferBlockId;
  let parentBlockPromise = null;
  const hydrationQueue = [];
  while (!isTopMostDeferBlock && currentBlockId) {
    ngDevMode && assertEqual(hydrationQueue.indexOf(currentBlockId), -1, "Internal error: defer block hierarchy has a cycle.");
    isTopMostDeferBlock = dehydratedBlockRegistry.has(currentBlockId);
    const hydratingParentBlock = dehydratedBlockRegistry.hydrating.get(currentBlockId);
    if (parentBlockPromise === null && hydratingParentBlock != null) {
      parentBlockPromise = hydratingParentBlock.promise;
      break;
    }
    hydrationQueue.unshift(currentBlockId);
    currentBlockId = deferBlockParents[currentBlockId][DEFER_PARENT_BLOCK_ID];
  }
  return { parentBlockPromise, hydrationQueue };
}
function refreshContentQueries(tView, lView) {
  const contentQueries = tView.contentQueries;
  if (contentQueries !== null) {
    const prevConsumer = setActiveConsumer(null);
    try {
      for (let i2 = 0; i2 < contentQueries.length; i2 += 2) {
        const queryStartIdx = contentQueries[i2];
        const directiveDefIdx = contentQueries[i2 + 1];
        if (directiveDefIdx !== -1) {
          const directiveDef = tView.data[directiveDefIdx];
          ngDevMode && assertDefined(directiveDef, "DirectiveDef not found.");
          ngDevMode && assertDefined(directiveDef.contentQueries, "contentQueries function should be defined");
          setCurrentQueryIndex(queryStartIdx);
          directiveDef.contentQueries(2, lView[directiveDefIdx], directiveDefIdx);
        }
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function executeViewQueryFn(flags, viewQueryFn, component) {
  ngDevMode && assertDefined(viewQueryFn, "View queries function to execute must be defined.");
  setCurrentQueryIndex(0);
  const prevConsumer = setActiveConsumer(null);
  try {
    viewQueryFn(flags, component);
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function executeContentQueries(tView, tNode, lView) {
  if (isContentQueryHost(tNode)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      const start = tNode.directiveStart;
      const end = tNode.directiveEnd;
      for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {
        const def = tView.data[directiveIndex];
        if (def.contentQueries) {
          const directiveInstance = lView[directiveIndex];
          ngDevMode && assertDefined(directiveIndex, "Incorrect reference to a directive defining a content query");
          def.contentQueries(1, directiveInstance, directiveIndex);
        }
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function getPolicy$1() {
  if (policy$1 === void 0) {
    policy$1 = null;
    if (_global.trustedTypes) {
      try {
        policy$1 = _global.trustedTypes.createPolicy("angular", {
          createHTML: (s2) => s2,
          createScript: (s2) => s2,
          createScriptURL: (s2) => s2
        });
      } catch {
      }
    }
  }
  return policy$1;
}
function trustedHTMLFromString(html) {
  return getPolicy$1()?.createHTML(html) || html;
}
function trustedScriptURLFromString(url) {
  return getPolicy$1()?.createScriptURL(url) || url;
}
function getPolicy() {
  if (policy === void 0) {
    policy = null;
    if (_global.trustedTypes) {
      try {
        policy = _global.trustedTypes.createPolicy("angular#unsafe-bypass", {
          createHTML: (s2) => s2,
          createScript: (s2) => s2,
          createScriptURL: (s2) => s2
        });
      } catch {
      }
    }
  }
  return policy;
}
function trustedHTMLFromStringBypass(html) {
  return getPolicy()?.createHTML(html) || html;
}
function trustedScriptFromStringBypass(script) {
  return getPolicy()?.createScript(script) || script;
}
function trustedScriptURLFromStringBypass(url) {
  return getPolicy()?.createScriptURL(url) || url;
}
function unwrapSafeValue(value) {
  return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;
}
function allowSanitizationBypassAndThrow(value, type) {
  const actualType = getSanitizationBypassType(value);
  if (actualType != null && actualType !== type) {
    if (actualType === "ResourceURL" && type === "URL")
      return true;
    throw new Error(`Required a safe ${type}, got a ${actualType} (see ${XSS_SECURITY_URL})`);
  }
  return actualType === type;
}
function getSanitizationBypassType(value) {
  return value instanceof SafeValueImpl && value.getTypeName() || null;
}
function bypassSanitizationTrustHtml(trustedHtml) {
  return new SafeHtmlImpl(trustedHtml);
}
function bypassSanitizationTrustStyle(trustedStyle) {
  return new SafeStyleImpl(trustedStyle);
}
function bypassSanitizationTrustScript(trustedScript) {
  return new SafeScriptImpl(trustedScript);
}
function bypassSanitizationTrustUrl(trustedUrl) {
  return new SafeUrlImpl(trustedUrl);
}
function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {
  return new SafeResourceUrlImpl(trustedResourceUrl);
}
function getInertBodyHelper(defaultDoc) {
  const inertDocumentHelper = new InertDocumentHelper(defaultDoc);
  return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;
}
function isDOMParserAvailable() {
  try {
    return !!new window.DOMParser().parseFromString(trustedHTMLFromString(""), "text/html");
  } catch {
    return false;
  }
}
function _sanitizeUrl(url) {
  url = String(url);
  if (url.match(SAFE_URL_PATTERN))
    return url;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    console.warn(`WARNING: sanitizing unsafe URL value ${url} (see ${XSS_SECURITY_URL})`);
  }
  return "unsafe:" + url;
}
function tagSet(tags) {
  const res = {};
  for (const t2 of tags.split(","))
    res[t2] = true;
  return res;
}
function merge2(...sets) {
  const res = {};
  for (const s2 of sets) {
    for (const v in s2) {
      if (s2.hasOwnProperty(v))
        res[v] = true;
    }
  }
  return res;
}
function isClobberedElement(parentNode, childNode) {
  return (parentNode.compareDocumentPosition(childNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) !== Node.DOCUMENT_POSITION_CONTAINED_BY;
}
function getNextSibling(node) {
  const nextSibling = node.nextSibling;
  if (nextSibling && node !== nextSibling.previousSibling) {
    throw clobberedElementError(nextSibling);
  }
  return nextSibling;
}
function getFirstChild(node) {
  const firstChild = node.firstChild;
  if (firstChild && isClobberedElement(node, firstChild)) {
    throw clobberedElementError(firstChild);
  }
  return firstChild;
}
function getNodeName(node) {
  const nodeName = node.nodeName;
  return typeof nodeName === "string" ? nodeName : "FORM";
}
function clobberedElementError(node) {
  return new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);
}
function encodeEntities(value) {
  return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(match2) {
    const hi2 = match2.charCodeAt(0);
    const low = match2.charCodeAt(1);
    return "&#" + ((hi2 - 55296) * 1024 + (low - 56320) + 65536) + ";";
  }).replace(NON_ALPHANUMERIC_REGEXP, function(match2) {
    return "&#" + match2.charCodeAt(0) + ";";
  }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
  let inertBodyElement = null;
  try {
    inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);
    let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : "";
    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
    let mXSSAttempts = 5;
    let parsedHtml = unsafeHtml;
    do {
      if (mXSSAttempts === 0) {
        throw new Error("Failed to sanitize html because the input is unstable");
      }
      mXSSAttempts--;
      unsafeHtml = parsedHtml;
      parsedHtml = inertBodyElement.innerHTML;
      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
    } while (unsafeHtml !== parsedHtml);
    const sanitizer = new SanitizingHtmlSerializer();
    const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
    if ((typeof ngDevMode === "undefined" || ngDevMode) && sanitizer.sanitizedSomething) {
      console.warn(`WARNING: sanitizing HTML stripped some content, see ${XSS_SECURITY_URL}`);
    }
    return trustedHTMLFromString(safeHtml);
  } finally {
    if (inertBodyElement) {
      const parent = getTemplateContent(inertBodyElement) || inertBodyElement;
      while (parent.firstChild) {
        parent.firstChild.remove();
      }
    }
  }
}
function getTemplateContent(el2) {
  return "content" in el2 && isTemplateElement(el2) ? el2.content : null;
}
function isTemplateElement(el2) {
  return el2.nodeType === Node.ELEMENT_NODE && el2.nodeName === "TEMPLATE";
}
function \u0275\u0275sanitizeHtml(unsafeHtml) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeHtml,
    "HTML"
    /* BypassType.Html */
  )) {
    return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));
  }
  return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));
}
function \u0275\u0275sanitizeStyle(unsafeStyle) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || "";
  }
  if (allowSanitizationBypassAndThrow(
    unsafeStyle,
    "Style"
    /* BypassType.Style */
  )) {
    return unwrapSafeValue(unsafeStyle);
  }
  return renderStringify(unsafeStyle);
}
function \u0275\u0275sanitizeUrl(unsafeUrl) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || "";
  }
  if (allowSanitizationBypassAndThrow(
    unsafeUrl,
    "URL"
    /* BypassType.Url */
  )) {
    return unwrapSafeValue(unsafeUrl);
  }
  return _sanitizeUrl(renderStringify(unsafeUrl));
}
function \u0275\u0275sanitizeResourceUrl(unsafeResourceUrl) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeResourceUrl,
    "ResourceURL"
    /* BypassType.ResourceUrl */
  )) {
    return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));
  }
  throw new RuntimeError(904, ngDevMode && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);
}
function \u0275\u0275sanitizeScript(unsafeScript) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeScript,
    "Script"
    /* BypassType.Script */
  )) {
    return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));
  }
  throw new RuntimeError(905, ngDevMode && "unsafe value used in a script context");
}
function \u0275\u0275trustConstantHtml(html) {
  if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join("?")}`);
  }
  return trustedHTMLFromString(html[0]);
}
function \u0275\u0275trustConstantResourceUrl(url) {
  if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join("?")}`);
  }
  return trustedScriptURLFromString(url[0]);
}
function getUrlSanitizer(tag, prop) {
  if (prop === "src" && (tag === "embed" || tag === "frame" || tag === "iframe" || tag === "media" || tag === "script") || prop === "href" && (tag === "base" || tag === "link")) {
    return \u0275\u0275sanitizeResourceUrl;
  }
  return \u0275\u0275sanitizeUrl;
}
function \u0275\u0275sanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {
  return getUrlSanitizer(tag, prop)(unsafeUrl);
}
function validateAgainstEventProperties(name) {
  if (name.toLowerCase().startsWith("on")) {
    const errorMessage = `Binding to event property '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...
If '${name}' is a directive input, make sure the directive is imported by the current module.`;
    throw new RuntimeError(306, errorMessage);
  }
}
function validateAgainstEventAttributes(name) {
  if (name.toLowerCase().startsWith("on")) {
    const errorMessage = `Binding to event attribute '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...`;
    throw new RuntimeError(306, errorMessage);
  }
}
function getSanitizer() {
  const lView = getLView();
  return lView && lView[ENVIRONMENT].sanitizer;
}
function escapeCommentText(value) {
  return value.replace(COMMENT_DISALLOWED, (text) => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));
}
function normalizeDebugBindingName(name) {
  name = camelCaseToDashCase(name.replace(/[$@]/g, "_"));
  return `ng-reflect-${name}`;
}
function camelCaseToDashCase(input2) {
  return input2.replace(CAMEL_CASE_REGEXP, (...m) => "-" + m[1].toLowerCase());
}
function normalizeDebugBindingValue(value) {
  try {
    return value != null ? value.toString().slice(0, 30) : value;
  } catch (e2) {
    return "[ERROR] Exception while trying to serialize the value";
  }
}
function validateElementIsKnown(lView, tNode) {
  const tView = lView[TVIEW];
  if (tView.schemas === null)
    return;
  const tagName = tNode.value;
  if (!isDirectiveHost(tNode) && tagName !== null) {
    const isUnknown = (
      // Note that we can't check for `typeof HTMLUnknownElement === 'function'` because
      // Domino doesn't expose HTMLUnknownElement globally.
      typeof HTMLUnknownElement !== "undefined" && HTMLUnknownElement && getNativeByTNode(tNode, lView) instanceof HTMLUnknownElement || typeof customElements !== "undefined" && tagName.indexOf("-") > -1 && !customElements.get(tagName)
    );
    if (isUnknown && !matchingSchemas(tView.schemas, tagName)) {
      const isHostStandalone = isHostComponentStandalone(lView);
      const templateLocation = getTemplateLocationDetails(lView);
      const schemas = `'${isHostStandalone ? "@Component" : "@NgModule"}.schemas'`;
      let message = `'${tagName}' is not a known element${templateLocation}:
`;
      message += `1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone ? "included in the '@Component.imports' of this component" : "a part of an @NgModule where this component is declared"}.
`;
      if (tagName && tagName.indexOf("-") > -1) {
        message += `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;
      } else {
        message += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
      }
      if (shouldThrowErrorOnUnknownElement) {
        throw new RuntimeError(304, message);
      } else {
        console.error(formatRuntimeError(304, message));
      }
    }
  }
}
function isPropertyValid(element, propName, tagName, schemas) {
  if (schemas === null)
    return true;
  if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) {
    return true;
  }
  return typeof Node === "undefined" || Node === null || !(element instanceof Node);
}
function handleUnknownPropertyError(propName, tagName, nodeType, lView) {
  if (!tagName && nodeType === 4) {
    tagName = "ng-template";
  }
  const isHostStandalone = isHostComponentStandalone(lView);
  const templateLocation = getTemplateLocationDetails(lView);
  let message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${templateLocation}.`;
  const schemas = `'${isHostStandalone ? "@Component" : "@NgModule"}.schemas'`;
  const importLocation = isHostStandalone ? "included in the '@Component.imports' of this component" : "a part of an @NgModule where this component is declared";
  if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {
    const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName);
    message += `
If the '${propName}' is an Angular control flow directive, please make sure that either the '${correspondingImport}' directive or the 'CommonModule' is ${importLocation}.`;
  } else {
    message += `
1. If '${tagName}' is an Angular component and it has the '${propName}' input, then verify that it is ${importLocation}.`;
    if (tagName && tagName.indexOf("-") > -1) {
      message += `
2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;
      message += `
3. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
    } else {
      message += `
2. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
    }
  }
  reportUnknownPropertyError(message);
}
function reportUnknownPropertyError(message) {
  if (shouldThrowErrorOnUnknownProperty) {
    throw new RuntimeError(303, message);
  } else {
    console.error(formatRuntimeError(303, message));
  }
}
function getDeclarationComponentDef(lView) {
  !ngDevMode && throwError2("Must never be called in production mode");
  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
  const context2 = declarationLView[CONTEXT];
  if (!context2)
    return null;
  return context2.constructor ? getComponentDef(context2.constructor) : null;
}
function isHostComponentStandalone(lView) {
  !ngDevMode && throwError2("Must never be called in production mode");
  const componentDef = getDeclarationComponentDef(lView);
  return !!componentDef?.standalone;
}
function getTemplateLocationDetails(lView) {
  !ngDevMode && throwError2("Must never be called in production mode");
  const hostComponentDef = getDeclarationComponentDef(lView);
  const componentClassName = hostComponentDef?.type?.name;
  return componentClassName ? ` (used in the '${componentClassName}' component template)` : "";
}
function matchingSchemas(schemas, tagName) {
  if (schemas !== null) {
    for (let i2 = 0; i2 < schemas.length; i2++) {
      const schema = schemas[i2];
      if (schema === NO_ERRORS_SCHEMA || schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf("-") > -1) {
        return true;
      }
    }
  }
  return false;
}
function \u0275\u0275resolveWindow(element) {
  return element.ownerDocument.defaultView;
}
function \u0275\u0275resolveDocument(element) {
  return element.ownerDocument;
}
function \u0275\u0275resolveBody(element) {
  return element.ownerDocument.body;
}
function maybeUnwrapFn(value) {
  if (value instanceof Function) {
    return value();
  } else {
    return value;
  }
}
function assertStandaloneComponentType(type) {
  assertComponentDef(type);
  const componentDef = getComponentDef(type);
  if (!componentDef.standalone) {
    throw new RuntimeError(907, `The ${stringifyForError(type)} component is not marked as standalone, but Angular expects to have a standalone component here. Please make sure the ${stringifyForError(type)} component has the \`standalone: true\` flag in the decorator.`);
  }
}
function assertComponentDef(type) {
  if (!getComponentDef(type)) {
    throw new RuntimeError(906, `The ${stringifyForError(type)} is not an Angular component, make sure it has the \`@Component\` decorator.`);
  }
}
function throwMultipleComponentError(tNode, first2, second) {
  throw new RuntimeError(-300, `Multiple components match node with tagname ${tNode.value}: ${stringifyForError(first2)} and ${stringifyForError(second)}`);
}
function throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName, lView) {
  const hostComponentDef = getDeclarationComponentDef(lView);
  const componentClassName = hostComponentDef?.type?.name;
  const field = propName ? ` for '${propName}'` : "";
  let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${formatValue(oldValue)}'. Current value: '${formatValue(currValue)}'.${componentClassName ? ` Expression location: ${componentClassName} component` : ""}`;
  if (creationMode) {
    msg += ` It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook?`;
  }
  throw new RuntimeError(-100, msg);
}
function formatValue(value) {
  let strValue = String(value);
  try {
    if (Array.isArray(value) || strValue === "[object Object]") {
      strValue = JSON.stringify(value);
    }
  } catch (error) {
  }
  return strValue.length > VALUE_STRING_LENGTH_LIMIT ? strValue.substring(0, VALUE_STRING_LENGTH_LIMIT) + "\u2026" : strValue;
}
function constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {
  const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);
  let oldValue = prefix, newValue = prefix;
  for (let i2 = 0; i2 < chunks.length; i2++) {
    const slotIdx = rootIndex + i2;
    oldValue += `${lView[slotIdx]}${chunks[i2]}`;
    newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i2]}`;
  }
  return { propName, oldValue, newValue };
}
function getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {
  const tData = lView[TVIEW].data;
  const metadata = tData[bindingIndex];
  if (typeof metadata === "string") {
    if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {
      return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);
    }
    return { propName: metadata, oldValue, newValue };
  }
  if (metadata === null) {
    let idx = bindingIndex - 1;
    while (typeof tData[idx] !== "string" && tData[idx + 1] === null) {
      idx--;
    }
    const meta = tData[idx];
    if (typeof meta === "string") {
      const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, "g"));
      if (matches && matches.length - 1 > bindingIndex - idx) {
        return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);
      }
    }
  }
  return { propName: void 0, oldValue, newValue };
}
function classIndexOf(className, classToSearch, startingIndex) {
  ngDevMode && assertNotEqual(classToSearch, "", 'can not look for "" string.');
  let end = className.length;
  while (true) {
    const foundIndex = className.indexOf(classToSearch, startingIndex);
    if (foundIndex === -1)
      return foundIndex;
    if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32) {
      const length = classToSearch.length;
      if (foundIndex + length === end || className.charCodeAt(foundIndex + length) <= 32) {
        return foundIndex;
      }
    }
    startingIndex = foundIndex + 1;
  }
}
function isCssClassMatching(tNode, attrs, cssClassToMatch, isProjectionMode) {
  ngDevMode && assertEqual(cssClassToMatch, cssClassToMatch.toLowerCase(), "Class name expected to be lowercase.");
  let i2 = 0;
  if (isProjectionMode) {
    for (; i2 < attrs.length && typeof attrs[i2] === "string"; i2 += 2) {
      if (attrs[i2] === "class" && classIndexOf(attrs[i2 + 1].toLowerCase(), cssClassToMatch, 0) !== -1) {
        return true;
      }
    }
  } else if (isInlineTemplate(tNode)) {
    return false;
  }
  i2 = attrs.indexOf(1, i2);
  if (i2 > -1) {
    let item;
    while (++i2 < attrs.length && typeof (item = attrs[i2]) === "string") {
      if (item.toLowerCase() === cssClassToMatch) {
        return true;
      }
    }
  }
  return false;
}
function isInlineTemplate(tNode) {
  return tNode.type === 4 && tNode.value !== NG_TEMPLATE_SELECTOR;
}
function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
  const tagNameToCompare = tNode.type === 4 && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;
  return currentSelector === tagNameToCompare;
}
function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
  ngDevMode && assertDefined(selector[0], "Selector should have a tag name");
  let mode = 4;
  const nodeAttrs = tNode.attrs;
  const nameOnlyMarkerIdx = nodeAttrs !== null ? getNameOnlyMarkerIndex(nodeAttrs) : 0;
  let skipToNextSelector = false;
  for (let i2 = 0; i2 < selector.length; i2++) {
    const current = selector[i2];
    if (typeof current === "number") {
      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {
        return false;
      }
      if (skipToNextSelector && isPositive(current))
        continue;
      skipToNextSelector = false;
      mode = current | mode & 1;
      continue;
    }
    if (skipToNextSelector)
      continue;
    if (mode & 4) {
      mode = 2 | mode & 1;
      if (current !== "" && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || current === "" && selector.length === 1) {
        if (isPositive(mode))
          return false;
        skipToNextSelector = true;
      }
    } else if (mode & 8) {
      if (nodeAttrs === null || !isCssClassMatching(tNode, nodeAttrs, current, isProjectionMode)) {
        if (isPositive(mode))
          return false;
        skipToNextSelector = true;
      }
    } else {
      const selectorAttrValue = selector[++i2];
      const attrIndexInNode = findAttrIndexInNode(current, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);
      if (attrIndexInNode === -1) {
        if (isPositive(mode))
          return false;
        skipToNextSelector = true;
        continue;
      }
      if (selectorAttrValue !== "") {
        let nodeAttrValue;
        if (attrIndexInNode > nameOnlyMarkerIdx) {
          nodeAttrValue = "";
        } else {
          ngDevMode && assertNotEqual(nodeAttrs[attrIndexInNode], 0, "We do not match directives on namespaced attributes");
          nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();
        }
        if (mode & 2 && selectorAttrValue !== nodeAttrValue) {
          if (isPositive(mode))
            return false;
          skipToNextSelector = true;
        }
      }
    }
  }
  return isPositive(mode) || skipToNextSelector;
}
function isPositive(mode) {
  return (mode & 1) === 0;
}
function findAttrIndexInNode(name, attrs, isInlineTemplate2, isProjectionMode) {
  if (attrs === null)
    return -1;
  let i2 = 0;
  if (isProjectionMode || !isInlineTemplate2) {
    let bindingsMode = false;
    while (i2 < attrs.length) {
      const maybeAttrName = attrs[i2];
      if (maybeAttrName === name) {
        return i2;
      } else if (maybeAttrName === 3 || maybeAttrName === 6) {
        bindingsMode = true;
      } else if (maybeAttrName === 1 || maybeAttrName === 2) {
        let value = attrs[++i2];
        while (typeof value === "string") {
          value = attrs[++i2];
        }
        continue;
      } else if (maybeAttrName === 4) {
        break;
      } else if (maybeAttrName === 0) {
        i2 += 4;
        continue;
      }
      i2 += bindingsMode ? 1 : 2;
    }
    return -1;
  } else {
    return matchTemplateAttribute(attrs, name);
  }
}
function isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {
  for (let i2 = 0; i2 < selector.length; i2++) {
    if (isNodeMatchingSelector(tNode, selector[i2], isProjectionMode)) {
      return true;
    }
  }
  return false;
}
function getProjectAsAttrValue(tNode) {
  const nodeAttrs = tNode.attrs;
  if (nodeAttrs != null) {
    const ngProjectAsAttrIdx = nodeAttrs.indexOf(
      5
      /* AttributeMarker.ProjectAs */
    );
    if ((ngProjectAsAttrIdx & 1) === 0) {
      return nodeAttrs[ngProjectAsAttrIdx + 1];
    }
  }
  return null;
}
function getNameOnlyMarkerIndex(nodeAttrs) {
  for (let i2 = 0; i2 < nodeAttrs.length; i2++) {
    const nodeAttr = nodeAttrs[i2];
    if (isNameOnlyAttributeMarker(nodeAttr)) {
      return i2;
    }
  }
  return nodeAttrs.length;
}
function matchTemplateAttribute(attrs, name) {
  let i2 = attrs.indexOf(
    4
    /* AttributeMarker.Template */
  );
  if (i2 > -1) {
    i2++;
    while (i2 < attrs.length) {
      const attr = attrs[i2];
      if (typeof attr === "number")
        return -1;
      if (attr === name)
        return i2;
      i2++;
    }
  }
  return -1;
}
function isSelectorInSelectorList(selector, list) {
  selectorListLoop: for (let i2 = 0; i2 < list.length; i2++) {
    const currentSelectorInList = list[i2];
    if (selector.length !== currentSelectorInList.length) {
      continue;
    }
    for (let j2 = 0; j2 < selector.length; j2++) {
      if (selector[j2] !== currentSelectorInList[j2]) {
        continue selectorListLoop;
      }
    }
    return true;
  }
  return false;
}
function maybeWrapInNotSelector(isNegativeMode, chunk) {
  return isNegativeMode ? ":not(" + chunk.trim() + ")" : chunk;
}
function stringifyCSSSelector(selector) {
  let result = selector[0];
  let i2 = 1;
  let mode = 2;
  let currentChunk = "";
  let isNegativeMode = false;
  while (i2 < selector.length) {
    let valueOrMarker = selector[i2];
    if (typeof valueOrMarker === "string") {
      if (mode & 2) {
        const attrValue = selector[++i2];
        currentChunk += "[" + valueOrMarker + (attrValue.length > 0 ? '="' + attrValue + '"' : "") + "]";
      } else if (mode & 8) {
        currentChunk += "." + valueOrMarker;
      } else if (mode & 4) {
        currentChunk += " " + valueOrMarker;
      }
    } else {
      if (currentChunk !== "" && !isPositive(valueOrMarker)) {
        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
        currentChunk = "";
      }
      mode = valueOrMarker;
      isNegativeMode = isNegativeMode || !isPositive(mode);
    }
    i2++;
  }
  if (currentChunk !== "") {
    result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
  }
  return result;
}
function stringifyCSSSelectorList(selectorList) {
  return selectorList.map(stringifyCSSSelector).join(",");
}
function extractAttrsAndClassesFromSelector(selector) {
  const attrs = [];
  const classes = [];
  let i2 = 1;
  let mode = 2;
  while (i2 < selector.length) {
    let valueOrMarker = selector[i2];
    if (typeof valueOrMarker === "string") {
      if (mode === 2) {
        if (valueOrMarker !== "") {
          attrs.push(valueOrMarker, selector[++i2]);
        }
      } else if (mode === 8) {
        classes.push(valueOrMarker);
      }
    } else {
      if (!isPositive(mode))
        break;
      mode = valueOrMarker;
    }
    i2++;
  }
  if (classes.length) {
    attrs.push(1, ...classes);
  }
  return attrs;
}
function createTextNode(renderer, value) {
  return renderer.createText(value);
}
function updateTextNode(renderer, rNode, value) {
  renderer.setValue(rNode, value);
}
function createCommentNode(renderer, value) {
  return renderer.createComment(escapeCommentText(value));
}
function createElementNode(renderer, name, namespace) {
  return renderer.createElement(name, namespace);
}
function nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {
  renderer.insertBefore(parent, child, beforeNode, isMove);
}
function nativeAppendChild(renderer, parent, child) {
  ngDevMode && assertDefined(parent, "parent node must be defined");
  renderer.appendChild(parent, child);
}
function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {
  if (beforeNode !== null) {
    nativeInsertBefore(renderer, parent, child, beforeNode, isMove);
  } else {
    nativeAppendChild(renderer, parent, child);
  }
}
function nativeRemoveNode(renderer, rNode, isHostElement) {
  renderer.removeChild(null, rNode, isHostElement);
}
function writeDirectStyle(renderer, element, newValue) {
  ngDevMode && assertString(newValue, "'newValue' should be a string");
  renderer.setAttribute(element, "style", newValue);
}
function writeDirectClass(renderer, element, newValue) {
  ngDevMode && assertString(newValue, "'newValue' should be a string");
  if (newValue === "") {
    renderer.removeAttribute(element, "class");
  } else {
    renderer.setAttribute(element, "class", newValue);
  }
}
function setupStaticAttributes(renderer, element, tNode) {
  const { mergedAttrs, classes, styles } = tNode;
  if (mergedAttrs !== null) {
    setUpAttributes(renderer, element, mergedAttrs);
  }
  if (classes !== null) {
    writeDirectClass(renderer, element, classes);
  }
  if (styles !== null) {
    writeDirectStyle(renderer, element, styles);
  }
}
function createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory, ssrId) {
  const bindingStartIndex = HEADER_OFFSET + decls;
  const initialViewLength = bindingStartIndex + vars;
  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);
  const consts = typeof constsOrFactory === "function" ? constsOrFactory() : constsOrFactory;
  const tView = blueprint[TVIEW] = {
    type,
    blueprint,
    template: templateFn,
    queries: null,
    viewQuery,
    declTNode,
    data: blueprint.slice().fill(null, bindingStartIndex),
    bindingStartIndex,
    expandoStartIndex: initialViewLength,
    hostBindingOpCodes: null,
    firstCreatePass: true,
    firstUpdatePass: true,
    staticViewQueries: false,
    staticContentQueries: false,
    preOrderHooks: null,
    preOrderCheckHooks: null,
    contentHooks: null,
    contentCheckHooks: null,
    viewHooks: null,
    viewCheckHooks: null,
    destroyHooks: null,
    cleanup: null,
    contentQueries: null,
    components: null,
    directiveRegistry: typeof directives === "function" ? directives() : directives,
    pipeRegistry: typeof pipes === "function" ? pipes() : pipes,
    firstChild: null,
    schemas,
    consts,
    incompleteFirstPass: false,
    ssrId
  };
  if (ngDevMode) {
    Object.seal(tView);
  }
  return tView;
}
function createViewBlueprint(bindingStartIndex, initialViewLength) {
  const blueprint = [];
  for (let i2 = 0; i2 < initialViewLength; i2++) {
    blueprint.push(i2 < bindingStartIndex ? null : NO_CHANGE);
  }
  return blueprint;
}
function getOrCreateComponentTView(def) {
  const tView = def.tView;
  if (tView === null || tView.incompleteFirstPass) {
    const declTNode = null;
    return def.tView = createTView(1, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts, def.id);
  }
  return tView;
}
function createLView(parentLView, tView, context2, flags, host, tHostNode, environment2, renderer, injector, embeddedViewInjector, hydrationInfo) {
  const lView = tView.blueprint.slice();
  lView[HOST] = host;
  lView[FLAGS] = flags | 4 | 128 | 8 | 64 | 1024;
  if (embeddedViewInjector !== null || parentLView && parentLView[FLAGS] & 2048) {
    lView[FLAGS] |= 2048;
  }
  resetPreOrderHookFlags(lView);
  ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);
  lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;
  lView[CONTEXT] = context2;
  lView[ENVIRONMENT] = environment2 || parentLView && parentLView[ENVIRONMENT];
  ngDevMode && assertDefined(lView[ENVIRONMENT], "LViewEnvironment is required");
  lView[RENDERER] = renderer || parentLView && parentLView[RENDERER];
  ngDevMode && assertDefined(lView[RENDERER], "Renderer is required");
  lView[INJECTOR] = injector || parentLView && parentLView[INJECTOR] || null;
  lView[T_HOST] = tHostNode;
  lView[ID] = getUniqueLViewId();
  lView[HYDRATION] = hydrationInfo;
  lView[EMBEDDED_VIEW_INJECTOR] = embeddedViewInjector;
  ngDevMode && assertEqual(tView.type == 2 ? parentLView !== null : true, true, "Embedded views must have parentLView");
  lView[DECLARATION_COMPONENT_VIEW] = tView.type == 2 ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;
  return lView;
}
function createComponentLView(lView, hostTNode, def) {
  const native = getNativeByTNode(hostTNode, lView);
  const tView = getOrCreateComponentTView(def);
  const rendererFactory = lView[ENVIRONMENT].rendererFactory;
  const componentView = addToEndOfViewTree(lView, createLView(lView, tView, null, getInitialLViewFlagsFromDef(def), native, hostTNode, null, rendererFactory.createRenderer(native, def), null, null, null));
  return lView[hostTNode.index] = componentView;
}
function getInitialLViewFlagsFromDef(def) {
  let flags = 16;
  if (def.signals) {
    flags = 4096;
  } else if (def.onPush) {
    flags = 64;
  }
  return flags;
}
function allocExpando(tView, lView, numSlotsToAlloc, initialValue) {
  if (numSlotsToAlloc === 0)
    return -1;
  if (ngDevMode) {
    assertFirstCreatePass(tView);
    assertSame(tView, lView[TVIEW], "`LView` must be associated with `TView`!");
    assertEqual(tView.data.length, lView.length, "Expecting LView to be same size as TView");
    assertEqual(tView.data.length, tView.blueprint.length, "Expecting Blueprint to be same size as TView");
    assertFirstUpdatePass(tView);
  }
  const allocIdx = lView.length;
  for (let i2 = 0; i2 < numSlotsToAlloc; i2++) {
    lView.push(initialValue);
    tView.blueprint.push(initialValue);
    tView.data.push(null);
  }
  return allocIdx;
}
function addToEndOfViewTree(lView, lViewOrLContainer) {
  if (lView[CHILD_HEAD]) {
    lView[CHILD_TAIL][NEXT] = lViewOrLContainer;
  } else {
    lView[CHILD_HEAD] = lViewOrLContainer;
  }
  lView[CHILD_TAIL] = lViewOrLContainer;
  return lViewOrLContainer;
}
function \u0275\u0275advance(delta = 1) {
  ngDevMode && assertGreaterThan(delta, 0, "Can only advance forward");
  selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, !!ngDevMode && isInCheckNoChangesMode());
}
function selectIndexInternal(tView, lView, index, checkNoChangesMode) {
  ngDevMode && assertIndexInDeclRange(lView[TVIEW], index);
  if (!checkNoChangesMode) {
    const hooksInitPhaseCompleted = (lView[FLAGS] & 3) === 3;
    if (hooksInitPhaseCompleted) {
      const preOrderCheckHooks = tView.preOrderCheckHooks;
      if (preOrderCheckHooks !== null) {
        executeCheckHooks(lView, preOrderCheckHooks, index);
      }
    } else {
      const preOrderHooks = tView.preOrderHooks;
      if (preOrderHooks !== null) {
        executeInitAndCheckHooks(lView, preOrderHooks, 0, index);
      }
    }
  }
  setSelectedIndex(index);
}
function writeToDirectiveInput(def, instance, publicName, value) {
  const prevConsumer = setActiveConsumer(null);
  try {
    if (ngDevMode) {
      if (!def.inputs.hasOwnProperty(publicName)) {
        throw new Error(`ASSERTION ERROR: Directive ${def.type.name} does not have an input with a public name of "${publicName}"`);
      }
      if (instance instanceof NodeInjectorFactory) {
        throw new Error(`ASSERTION ERROR: Cannot write input to factory for type ${def.type.name}. Directive has not been created yet.`);
      }
    }
    const [privateName, flags, transform] = def.inputs[publicName];
    let inputSignalNode = null;
    if ((flags & InputFlags.SignalBased) !== 0) {
      const field = instance[privateName];
      inputSignalNode = field[SIGNAL];
    }
    if (inputSignalNode !== null && inputSignalNode.transformFn !== void 0) {
      value = inputSignalNode.transformFn(value);
    } else if (transform !== null) {
      value = transform.call(instance, value);
    }
    if (def.setInput !== null) {
      def.setInput(instance, inputSignalNode, value, publicName, privateName);
    } else {
      applyValueToInputField(instance, inputSignalNode, privateName, value);
    }
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function icuContainerIterate(tIcuContainerNode, lView) {
  return _icuContainerIterate(tIcuContainerNode, lView);
}
function ensureIcuContainerVisitorLoaded(loader) {
  if (_icuContainerIterate === void 0) {
    _icuContainerIterate = loader();
  }
}
function applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {
  if (lNodeToHandle != null) {
    let lContainer;
    let isComponent2 = false;
    if (isLContainer(lNodeToHandle)) {
      lContainer = lNodeToHandle;
    } else if (isLView(lNodeToHandle)) {
      isComponent2 = true;
      ngDevMode && assertDefined(lNodeToHandle[HOST], "HOST must be defined for a component LView");
      lNodeToHandle = lNodeToHandle[HOST];
    }
    const rNode = unwrapRNode(lNodeToHandle);
    if (action === 0 && parent !== null) {
      if (beforeNode == null) {
        nativeAppendChild(renderer, parent, rNode);
      } else {
        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
      }
    } else if (action === 1 && parent !== null) {
      nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
    } else if (action === 2) {
      nativeRemoveNode(renderer, rNode, isComponent2);
    } else if (action === 3) {
      renderer.destroyNode(rNode);
    }
    if (lContainer != null) {
      applyContainer(renderer, action, lContainer, parent, beforeNode);
    }
  }
}
function removeViewFromDOM(tView, lView) {
  detachViewFromDOM(tView, lView);
  lView[HOST] = null;
  lView[T_HOST] = null;
}
function addViewToDOM(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {
  lView[HOST] = parentNativeNode;
  lView[T_HOST] = parentTNode;
  applyView(tView, lView, renderer, 1, parentNativeNode, beforeNode);
}
function detachViewFromDOM(tView, lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(
    9
    /* NotificationSource.ViewDetachedFromDOM */
  );
  applyView(tView, lView, lView[RENDERER], 2, null, null);
}
function destroyViewTree(rootView) {
  let lViewOrLContainer = rootView[CHILD_HEAD];
  if (!lViewOrLContainer) {
    return cleanUpView(rootView[TVIEW], rootView);
  }
  while (lViewOrLContainer) {
    let next = null;
    if (isLView(lViewOrLContainer)) {
      next = lViewOrLContainer[CHILD_HEAD];
    } else {
      ngDevMode && assertLContainer(lViewOrLContainer);
      const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];
      if (firstView)
        next = firstView;
    }
    if (!next) {
      while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {
        if (isLView(lViewOrLContainer)) {
          cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
        }
        lViewOrLContainer = lViewOrLContainer[PARENT];
      }
      if (lViewOrLContainer === null)
        lViewOrLContainer = rootView;
      if (isLView(lViewOrLContainer)) {
        cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
      }
      next = lViewOrLContainer && lViewOrLContainer[NEXT];
    }
    lViewOrLContainer = next;
  }
}
function detachMovedView(declarationContainer, lView) {
  ngDevMode && assertLContainer(declarationContainer);
  ngDevMode && assertDefined(declarationContainer[MOVED_VIEWS], "A projected view should belong to a non-empty projected views collection");
  const movedViews = declarationContainer[MOVED_VIEWS];
  const declarationViewIndex = movedViews.indexOf(lView);
  movedViews.splice(declarationViewIndex, 1);
}
function destroyLView(tView, lView) {
  if (isDestroyed(lView)) {
    return;
  }
  const renderer = lView[RENDERER];
  if (renderer.destroyNode) {
    applyView(tView, lView, renderer, 3, null, null);
  }
  destroyViewTree(lView);
}
function cleanUpView(tView, lView) {
  if (isDestroyed(lView)) {
    return;
  }
  const prevConsumer = setActiveConsumer(null);
  try {
    lView[FLAGS] &= ~128;
    lView[FLAGS] |= 256;
    lView[REACTIVE_TEMPLATE_CONSUMER] && consumerDestroy(lView[REACTIVE_TEMPLATE_CONSUMER]);
    executeOnDestroys(tView, lView);
    processCleanups(tView, lView);
    if (lView[TVIEW].type === 1) {
      lView[RENDERER].destroy();
    }
    const declarationContainer = lView[DECLARATION_LCONTAINER];
    if (declarationContainer !== null && isLContainer(lView[PARENT])) {
      if (declarationContainer !== lView[PARENT]) {
        detachMovedView(declarationContainer, lView);
      }
      const lQueries = lView[QUERIES];
      if (lQueries !== null) {
        lQueries.detachView(tView);
      }
    }
    unregisterLView(lView);
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function processCleanups(tView, lView) {
  ngDevMode && assertNotReactive(processCleanups.name);
  const tCleanup = tView.cleanup;
  const lCleanup = lView[CLEANUP];
  if (tCleanup !== null) {
    for (let i2 = 0; i2 < tCleanup.length - 1; i2 += 2) {
      if (typeof tCleanup[i2] === "string") {
        const targetIdx = tCleanup[i2 + 3];
        ngDevMode && assertNumber(targetIdx, "cleanup target must be a number");
        if (targetIdx >= 0) {
          lCleanup[targetIdx]();
        } else {
          lCleanup[-targetIdx].unsubscribe();
        }
        i2 += 2;
      } else {
        const context2 = lCleanup[tCleanup[i2 + 1]];
        tCleanup[i2].call(context2);
      }
    }
  }
  if (lCleanup !== null) {
    lView[CLEANUP] = null;
  }
  const destroyHooks = lView[ON_DESTROY_HOOKS];
  if (destroyHooks !== null) {
    lView[ON_DESTROY_HOOKS] = null;
    for (let i2 = 0; i2 < destroyHooks.length; i2++) {
      const destroyHooksFn = destroyHooks[i2];
      ngDevMode && assertFunction(destroyHooksFn, "Expecting destroy hook to be a function.");
      destroyHooksFn();
    }
  }
  const effects = lView[EFFECTS];
  if (effects !== null) {
    lView[EFFECTS] = null;
    for (const effect2 of effects) {
      effect2.destroy();
    }
  }
}
function executeOnDestroys(tView, lView) {
  ngDevMode && assertNotReactive(executeOnDestroys.name);
  let destroyHooks;
  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {
    for (let i2 = 0; i2 < destroyHooks.length; i2 += 2) {
      const context2 = lView[destroyHooks[i2]];
      if (!(context2 instanceof NodeInjectorFactory)) {
        const toCall = destroyHooks[i2 + 1];
        if (Array.isArray(toCall)) {
          for (let j2 = 0; j2 < toCall.length; j2 += 2) {
            const callContext = context2[toCall[j2]];
            const hook = toCall[j2 + 1];
            profiler(4, callContext, hook);
            try {
              hook.call(callContext);
            } finally {
              profiler(5, callContext, hook);
            }
          }
        } else {
          profiler(4, context2, toCall);
          try {
            toCall.call(context2);
          } finally {
            profiler(5, context2, toCall);
          }
        }
      }
    }
  }
}
function getParentRElement(tView, tNode, lView) {
  return getClosestRElement(tView, tNode.parent, lView);
}
function getClosestRElement(tView, tNode, lView) {
  let parentTNode = tNode;
  while (parentTNode !== null && parentTNode.type & (8 | 32 | 128)) {
    tNode = parentTNode;
    parentTNode = tNode.parent;
  }
  if (parentTNode === null) {
    return lView[HOST];
  } else {
    ngDevMode && assertTNodeType(
      parentTNode,
      3 | 4
      /* TNodeType.Container */
    );
    if (isComponentHost(parentTNode)) {
      ngDevMode && assertTNodeForLView(parentTNode, lView);
      const { encapsulation } = tView.data[parentTNode.directiveStart + parentTNode.componentOffset];
      if (encapsulation === ViewEncapsulation.None || encapsulation === ViewEncapsulation.Emulated) {
        return null;
      }
    }
    return getNativeByTNode(parentTNode, lView);
  }
}
function getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {
  return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);
}
function getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {
  if (parentTNode.type & (8 | 32)) {
    return getNativeByTNode(parentTNode, lView);
  }
  return null;
}
function setI18nHandling(getInsertInFrontOfRNodeWithI18n2, processI18nInsertBefore2) {
  _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n2;
  _processI18nInsertBefore = processI18nInsertBefore2;
}
function appendChild(tView, lView, childRNode, childTNode) {
  const parentRNode = getParentRElement(tView, childTNode, lView);
  const renderer = lView[RENDERER];
  const parentTNode = childTNode.parent || lView[T_HOST];
  const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);
  if (parentRNode != null) {
    if (Array.isArray(childRNode)) {
      for (let i2 = 0; i2 < childRNode.length; i2++) {
        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i2], anchorNode, false);
      }
    } else {
      nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);
    }
  }
  _processI18nInsertBefore !== void 0 && _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);
}
function getFirstNativeNode(lView, tNode) {
  if (tNode !== null) {
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 32 | 16 | 128
      /* TNodeType.LetDeclaration */
    );
    const tNodeType = tNode.type;
    if (tNodeType & 3) {
      return getNativeByTNode(tNode, lView);
    } else if (tNodeType & 4) {
      return getBeforeNodeForView(-1, lView[tNode.index]);
    } else if (tNodeType & 8) {
      const elIcuContainerChild = tNode.child;
      if (elIcuContainerChild !== null) {
        return getFirstNativeNode(lView, elIcuContainerChild);
      } else {
        const rNodeOrLContainer = lView[tNode.index];
        if (isLContainer(rNodeOrLContainer)) {
          return getBeforeNodeForView(-1, rNodeOrLContainer);
        } else {
          return unwrapRNode(rNodeOrLContainer);
        }
      }
    } else if (tNodeType & 128) {
      return getFirstNativeNode(lView, tNode.next);
    } else if (tNodeType & 32) {
      let nextRNode = icuContainerIterate(tNode, lView);
      let rNode = nextRNode();
      return rNode || unwrapRNode(lView[tNode.index]);
    } else {
      const projectionNodes = getProjectionNodes(lView, tNode);
      if (projectionNodes !== null) {
        if (Array.isArray(projectionNodes)) {
          return projectionNodes[0];
        }
        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
        ngDevMode && assertParentView(parentView);
        return getFirstNativeNode(parentView, projectionNodes);
      } else {
        return getFirstNativeNode(lView, tNode.next);
      }
    }
  }
  return null;
}
function getProjectionNodes(lView, tNode) {
  if (tNode !== null) {
    const componentView = lView[DECLARATION_COMPONENT_VIEW];
    const componentHost = componentView[T_HOST];
    const slotIdx = tNode.projection;
    ngDevMode && assertProjectionSlots(lView);
    return componentHost.projection[slotIdx];
  }
  return null;
}
function getBeforeNodeForView(viewIndexInContainer, lContainer) {
  const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;
  if (nextViewIndex < lContainer.length) {
    const lView = lContainer[nextViewIndex];
    const firstTNodeOfView = lView[TVIEW].firstChild;
    if (firstTNodeOfView !== null) {
      return getFirstNativeNode(lView, firstTNodeOfView);
    }
  }
  return lContainer[NATIVE];
}
function applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {
  while (tNode != null) {
    ngDevMode && assertTNodeForLView(tNode, lView);
    if (tNode.type === 128) {
      tNode = tNode.next;
      continue;
    }
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 16 | 32
      /* TNodeType.Icu */
    );
    const rawSlotValue = lView[tNode.index];
    const tNodeType = tNode.type;
    if (isProjection) {
      if (action === 0) {
        rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);
        tNode.flags |= 2;
      }
    }
    if (!isDetachedByI18n(tNode)) {
      if (tNodeType & 8) {
        applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      } else if (tNodeType & 32) {
        const nextRNode = icuContainerIterate(tNode, lView);
        let rNode;
        while (rNode = nextRNode()) {
          applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
        }
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      } else if (tNodeType & 16) {
        applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);
      } else {
        ngDevMode && assertTNodeType(
          tNode,
          3 | 4
          /* TNodeType.Container */
        );
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      }
    }
    tNode = isProjection ? tNode.projectionNext : tNode.next;
  }
}
function applyView(tView, lView, renderer, action, parentRElement, beforeNode) {
  applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);
}
function applyProjection(tView, lView, tProjectionNode) {
  const renderer = lView[RENDERER];
  const parentRNode = getParentRElement(tView, tProjectionNode, lView);
  const parentTNode = tProjectionNode.parent || lView[T_HOST];
  let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);
  applyProjectionRecursive(renderer, 0, lView, tProjectionNode, parentRNode, beforeNode);
}
function applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {
  const componentLView = lView[DECLARATION_COMPONENT_VIEW];
  const componentNode = componentLView[T_HOST];
  ngDevMode && assertEqual(typeof tProjectionNode.projection, "number", "expecting projection index");
  const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];
  if (Array.isArray(nodeToProjectOrRNodes)) {
    for (let i2 = 0; i2 < nodeToProjectOrRNodes.length; i2++) {
      const rNode = nodeToProjectOrRNodes[i2];
      applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
    }
  } else {
    let nodeToProject = nodeToProjectOrRNodes;
    const projectedComponentLView = componentLView[PARENT];
    if (hasInSkipHydrationBlockFlag(tProjectionNode)) {
      nodeToProject.flags |= 128;
    }
    applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);
  }
}
function applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {
  ngDevMode && assertLContainer(lContainer);
  const anchor = lContainer[NATIVE];
  const native = unwrapRNode(lContainer);
  if (anchor !== native) {
    applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);
  }
  for (let i2 = CONTAINER_HEADER_OFFSET; i2 < lContainer.length; i2++) {
    const lView = lContainer[i2];
    applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);
  }
}
function applyStyling(renderer, isClassBased, rNode, prop, value) {
  if (isClassBased) {
    if (!value) {
      renderer.removeClass(rNode, prop);
    } else {
      renderer.addClass(rNode, prop);
    }
  } else {
    let flags = prop.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
    if (value == null) {
      renderer.removeStyle(rNode, prop, flags);
    } else {
      const isImportant = typeof value === "string" ? value.endsWith("!important") : false;
      if (isImportant) {
        value = value.slice(0, -10);
        flags |= RendererStyleFlags2.Important;
      }
      renderer.setStyle(rNode, prop, value, flags);
    }
  }
}
function executeTemplate(tView, lView, templateFn, rf2, context2) {
  const prevSelectedIndex = getSelectedIndex();
  const isUpdatePhase = rf2 & 2;
  try {
    setSelectedIndex(-1);
    if (isUpdatePhase && lView.length > HEADER_OFFSET) {
      selectIndexInternal(tView, lView, HEADER_OFFSET, !!ngDevMode && isInCheckNoChangesMode());
    }
    const preHookType = isUpdatePhase ? 2 : 0;
    profiler(preHookType, context2, templateFn);
    templateFn(rf2, context2);
  } finally {
    setSelectedIndex(prevSelectedIndex);
    const postHookType = isUpdatePhase ? 3 : 1;
    profiler(postHookType, context2, templateFn);
  }
}
function createDirectivesInstances(tView, lView, tNode) {
  instantiateAllDirectives(tView, lView, tNode);
  if ((tNode.flags & 64) === 64) {
    invokeDirectivesHostBindings(tView, lView, tNode);
  }
}
function saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {
  const localNames = tNode.localNames;
  if (localNames !== null) {
    let localIndex = tNode.index + 1;
    for (let i2 = 0; i2 < localNames.length; i2 += 2) {
      const index = localNames[i2 + 1];
      const value = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];
      viewData[localIndex++] = value;
    }
  }
}
function locateHostElement(renderer, elementOrSelector, encapsulation, injector) {
  const preserveHostContent = injector.get(PRESERVE_HOST_CONTENT, PRESERVE_HOST_CONTENT_DEFAULT);
  const preserveContent = preserveHostContent || encapsulation === ViewEncapsulation.ShadowDom;
  const rootElement = renderer.selectRootElement(elementOrSelector, preserveContent);
  applyRootElementTransform(rootElement);
  return rootElement;
}
function applyRootElementTransform(rootElement) {
  _applyRootElementTransformImpl(rootElement);
}
function mapPropName(name) {
  if (name === "class")
    return "className";
  if (name === "for")
    return "htmlFor";
  if (name === "formaction")
    return "formAction";
  if (name === "innerHtml")
    return "innerHTML";
  if (name === "readonly")
    return "readOnly";
  if (name === "tabindex")
    return "tabIndex";
  return name;
}
function setPropertyAndInputs(tNode, lView, propName, value, renderer, sanitizer) {
  ngDevMode && assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
  const tView = lView[TVIEW];
  const hasSetInput = setAllInputsForProperty(tNode, tView, lView, propName, value);
  if (hasSetInput) {
    isComponentHost(tNode) && markDirtyIfOnPush(lView, tNode.index);
    ngDevMode && setNgReflectProperties(lView, tView, tNode, propName, value);
    return;
  }
  if (tNode.type & 3) {
    propName = mapPropName(propName);
  }
  setDomProperty(tNode, lView, propName, value, renderer, sanitizer);
}
function setDomProperty(tNode, lView, propName, value, renderer, sanitizer) {
  if (tNode.type & 3) {
    const element = getNativeByTNode(tNode, lView);
    if (ngDevMode) {
      validateAgainstEventProperties(propName);
      if (!isPropertyValid(element, propName, tNode.value, lView[TVIEW].schemas)) {
        handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
      }
    }
    value = sanitizer != null ? sanitizer(value, tNode.value || "", propName) : value;
    renderer.setProperty(element, propName, value);
  } else if (tNode.type & 12) {
    if (ngDevMode && !matchingSchemas(lView[TVIEW].schemas, tNode.value)) {
      handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
    }
  }
}
function markDirtyIfOnPush(lView, viewIndex) {
  ngDevMode && assertLView(lView);
  const childComponentLView = getComponentLViewByIndex(viewIndex, lView);
  if (!(childComponentLView[FLAGS] & 16)) {
    childComponentLView[FLAGS] |= 64;
  }
}
function setNgReflectProperty(lView, tNode, attrName, value) {
  const environment2 = lView[ENVIRONMENT];
  if (!environment2.ngReflect) {
    return;
  }
  const element = getNativeByTNode(tNode, lView);
  const renderer = lView[RENDERER];
  attrName = normalizeDebugBindingName(attrName);
  const debugValue = normalizeDebugBindingValue(value);
  if (tNode.type & 3) {
    if (value == null) {
      renderer.removeAttribute(element, attrName);
    } else {
      renderer.setAttribute(element, attrName, debugValue);
    }
  } else {
    const textContent = escapeCommentText(`bindings=${JSON.stringify({ [attrName]: debugValue }, null, 2)}`);
    renderer.setValue(element, textContent);
  }
}
function setNgReflectProperties(lView, tView, tNode, publicName, value) {
  const environment2 = lView[ENVIRONMENT];
  if (!environment2.ngReflect || !(tNode.type & (3 | 4))) {
    return;
  }
  const inputConfig = tNode.inputs?.[publicName];
  const hostInputConfig = tNode.hostDirectiveInputs?.[publicName];
  if (hostInputConfig) {
    for (let i2 = 0; i2 < hostInputConfig.length; i2 += 2) {
      const index = hostInputConfig[i2];
      const publicName2 = hostInputConfig[i2 + 1];
      const def = tView.data[index];
      setNgReflectProperty(lView, tNode, def.inputs[publicName2][0], value);
    }
  }
  if (inputConfig) {
    for (const index of inputConfig) {
      const def = tView.data[index];
      setNgReflectProperty(lView, tNode, def.inputs[publicName][0], value);
    }
  }
}
function instantiateAllDirectives(tView, lView, tNode) {
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  if (isComponentHost(tNode)) {
    ngDevMode && assertTNodeType(
      tNode,
      3
      /* TNodeType.AnyRNode */
    );
    createComponentLView(lView, tNode, tView.data[start + tNode.componentOffset]);
  }
  if (!tView.firstCreatePass) {
    getOrCreateNodeInjectorForNode(tNode, lView);
  }
  const initialInputs = tNode.initialInputs;
  for (let i2 = start; i2 < end; i2++) {
    const def = tView.data[i2];
    const directive = getNodeInjectable(lView, tView, i2, tNode);
    attachPatchData(directive, lView);
    if (initialInputs !== null) {
      setInputsFromAttrs(lView, i2 - start, directive, def, tNode, initialInputs);
    }
    if (isComponentDef(def)) {
      const componentView = getComponentLViewByIndex(tNode.index, lView);
      componentView[CONTEXT] = getNodeInjectable(lView, tView, i2, tNode);
    }
  }
}
function invokeDirectivesHostBindings(tView, lView, tNode) {
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  const elementIndex = tNode.index;
  const currentDirectiveIndex = getCurrentDirectiveIndex();
  try {
    setSelectedIndex(elementIndex);
    for (let dirIndex = start; dirIndex < end; dirIndex++) {
      const def = tView.data[dirIndex];
      const directive = lView[dirIndex];
      setCurrentDirectiveIndex(dirIndex);
      if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {
        invokeHostBindingsInCreationMode(def, directive);
      }
    }
  } finally {
    setSelectedIndex(-1);
    setCurrentDirectiveIndex(currentDirectiveIndex);
  }
}
function invokeHostBindingsInCreationMode(def, directive) {
  if (def.hostBindings !== null) {
    def.hostBindings(1, directive);
  }
}
function findDirectiveDefMatches(tView, tNode) {
  ngDevMode && assertFirstCreatePass(tView);
  ngDevMode && assertTNodeType(
    tNode,
    3 | 12
    /* TNodeType.AnyContainer */
  );
  const registry = tView.directiveRegistry;
  let matches = null;
  if (registry) {
    for (let i2 = 0; i2 < registry.length; i2++) {
      const def = registry[i2];
      if (isNodeMatchingSelectorList(
        tNode,
        def.selectors,
        /* isProjectionMode */
        false
      )) {
        matches ??= [];
        if (isComponentDef(def)) {
          if (ngDevMode) {
            assertTNodeType(tNode, 2, `"${tNode.value}" tags cannot be used as component hosts. Please use a different tag to activate the ${stringify(def.type)} component.`);
            if (matches.length && isComponentDef(matches[0])) {
              throwMultipleComponentError(tNode, matches.find(isComponentDef).type, def.type);
            }
          }
          matches.unshift(def);
        } else {
          matches.push(def);
        }
      }
    }
  }
  return matches;
}
function elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {
  if (ngDevMode) {
    assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
    validateAgainstEventAttributes(name);
    assertTNodeType(tNode, 2, `Attempted to set attribute \`${name}\` on a container node. Host bindings are not valid on ng-container or ng-template.`);
  }
  const element = getNativeByTNode(tNode, lView);
  setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name, value, sanitizer);
}
function setElementAttribute(renderer, element, namespace, tagName, name, value, sanitizer) {
  if (value == null) {
    renderer.removeAttribute(element, name, namespace);
  } else {
    const strValue = sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || "", name);
    renderer.setAttribute(element, name, strValue, namespace);
  }
}
function setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {
  const initialInputs = initialInputData[directiveIndex];
  if (initialInputs !== null) {
    for (let i2 = 0; i2 < initialInputs.length; i2 += 2) {
      const lookupName = initialInputs[i2];
      const value = initialInputs[i2 + 1];
      writeToDirectiveInput(def, instance, lookupName, value);
      if (ngDevMode) {
        setNgReflectProperty(lView, tNode, def.inputs[lookupName][0], value);
      }
    }
  }
}
function elementLikeStartShared(tNode, lView, index, name, locateOrCreateNativeNode) {
  const adjustedIndex = HEADER_OFFSET + index;
  const tView = lView[TVIEW];
  const native = locateOrCreateNativeNode(tView, lView, tNode, name, index);
  lView[adjustedIndex] = native;
  setCurrentTNode(tNode, true);
  const isElement = tNode.type === 2;
  if (isElement) {
    setupStaticAttributes(lView[RENDERER], native, tNode);
    if (getElementDepthCount() === 0 || isDirectiveHost(tNode)) {
      attachPatchData(native, lView);
    }
    increaseElementDepthCount();
  } else {
    attachPatchData(native, lView);
  }
  if (wasLastNodeCreated() && (!isElement || !isDetachedByI18n(tNode))) {
    appendChild(tView, lView, native, tNode);
  }
  return tNode;
}
function elementLikeEndShared(tNode) {
  let currentTNode = tNode;
  if (isCurrentTNodeParent()) {
    setCurrentTNodeAsNotParent();
  } else {
    ngDevMode && assertHasParent(getCurrentTNode());
    currentTNode = currentTNode.parent;
    setCurrentTNode(currentTNode, false);
  }
  return currentTNode;
}
function storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {
  if (tData[bindingIndex] === null) {
    if (!tNode.inputs?.[propertyName] && !tNode.hostDirectiveInputs?.[propertyName]) {
      const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);
      propBindingIdxs.push(bindingIndex);
      let bindingMetadata = propertyName;
      if (interpolationParts.length > 0) {
        bindingMetadata += INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);
      }
      tData[bindingIndex] = bindingMetadata;
    }
  }
}
function loadComponentRenderer(currentDef, tNode, lView) {
  if (currentDef === null || isComponentDef(currentDef)) {
    lView = unwrapLView(lView[tNode.index]);
  }
  return lView[RENDERER];
}
function handleUncaughtError(lView, error) {
  const injector = lView[INJECTOR];
  if (!injector) {
    return;
  }
  const errorHandler2 = injector.get(INTERNAL_APPLICATION_ERROR_HANDLER, null);
  errorHandler2?.(error);
}
function setAllInputsForProperty(tNode, tView, lView, publicName, value) {
  const inputs = tNode.inputs?.[publicName];
  const hostDirectiveInputs = tNode.hostDirectiveInputs?.[publicName];
  let hasMatch = false;
  if (hostDirectiveInputs) {
    for (let i2 = 0; i2 < hostDirectiveInputs.length; i2 += 2) {
      const index = hostDirectiveInputs[i2];
      ngDevMode && assertIndexInRange(lView, index);
      const publicName2 = hostDirectiveInputs[i2 + 1];
      const def = tView.data[index];
      writeToDirectiveInput(def, lView[index], publicName2, value);
      hasMatch = true;
    }
  }
  if (inputs) {
    for (const index of inputs) {
      ngDevMode && assertIndexInRange(lView, index);
      const instance = lView[index];
      const def = tView.data[index];
      writeToDirectiveInput(def, instance, publicName, value);
      hasMatch = true;
    }
  }
  return hasMatch;
}
function renderComponent(hostLView, componentHostIdx) {
  ngDevMode && assertEqual(isCreationMode(hostLView), true, "Should be run in creation mode");
  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
  const componentTView = componentView[TVIEW];
  syncViewWithBlueprint(componentTView, componentView);
  const hostRNode = componentView[HOST];
  if (hostRNode !== null && componentView[HYDRATION] === null) {
    componentView[HYDRATION] = retrieveHydrationInfo(hostRNode, componentView[INJECTOR]);
  }
  profiler(
    18
    /* ProfilerEvent.ComponentStart */
  );
  renderView(componentTView, componentView, componentView[CONTEXT]);
  profiler(19, componentView[CONTEXT]);
}
function syncViewWithBlueprint(tView, lView) {
  for (let i2 = lView.length; i2 < tView.blueprint.length; i2++) {
    lView.push(tView.blueprint[i2]);
  }
}
function renderView(tView, lView, context2) {
  ngDevMode && assertEqual(isCreationMode(lView), true, "Should be run in creation mode");
  ngDevMode && assertNotReactive(renderView.name);
  enterView(lView);
  try {
    const viewQuery = tView.viewQuery;
    if (viewQuery !== null) {
      executeViewQueryFn(1, viewQuery, context2);
    }
    const templateFn = tView.template;
    if (templateFn !== null) {
      executeTemplate(tView, lView, templateFn, 1, context2);
    }
    if (tView.firstCreatePass) {
      tView.firstCreatePass = false;
    }
    lView[QUERIES]?.finishViewCreation(tView);
    if (tView.staticContentQueries) {
      refreshContentQueries(tView, lView);
    }
    if (tView.staticViewQueries) {
      executeViewQueryFn(2, tView.viewQuery, context2);
    }
    const components = tView.components;
    if (components !== null) {
      renderChildComponents(lView, components);
    }
  } catch (error) {
    if (tView.firstCreatePass) {
      tView.incompleteFirstPass = true;
      tView.firstCreatePass = false;
    }
    throw error;
  } finally {
    lView[FLAGS] &= ~4;
    leaveView();
  }
}
function renderChildComponents(hostLView, components) {
  for (let i2 = 0; i2 < components.length; i2++) {
    renderComponent(hostLView, components[i2]);
  }
}
function createAndRenderEmbeddedLView(declarationLView, templateTNode, context2, options) {
  const prevConsumer = setActiveConsumer(null);
  try {
    const embeddedTView = templateTNode.tView;
    ngDevMode && assertDefined(embeddedTView, "TView must be defined for a template node.");
    ngDevMode && assertTNodeForLView(templateTNode, declarationLView);
    const isSignalView = declarationLView[FLAGS] & 4096;
    const viewFlags = isSignalView ? 4096 : 16;
    const embeddedLView = createLView(declarationLView, embeddedTView, context2, viewFlags, null, templateTNode, null, null, options?.injector ?? null, options?.embeddedViewInjector ?? null, options?.dehydratedView ?? null);
    const declarationLContainer = declarationLView[templateTNode.index];
    ngDevMode && assertLContainer(declarationLContainer);
    embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;
    const declarationViewLQueries = declarationLView[QUERIES];
    if (declarationViewLQueries !== null) {
      embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);
    }
    renderView(embeddedTView, embeddedLView, context2);
    return embeddedLView;
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function shouldAddViewToDom(tNode, dehydratedView) {
  return !dehydratedView || dehydratedView.firstChild === null || hasInSkipHydrationBlockFlag(tNode);
}
function collectNativeNodes(tView, lView, tNode, result, isProjection = false) {
  while (tNode !== null) {
    if (tNode.type === 128) {
      tNode = isProjection ? tNode.projectionNext : tNode.next;
      continue;
    }
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 16 | 32
      /* TNodeType.Icu */
    );
    const lNode = lView[tNode.index];
    if (lNode !== null) {
      result.push(unwrapRNode(lNode));
    }
    if (isLContainer(lNode)) {
      collectNativeNodesInLContainer(lNode, result);
    }
    const tNodeType = tNode.type;
    if (tNodeType & 8) {
      collectNativeNodes(tView, lView, tNode.child, result);
    } else if (tNodeType & 32) {
      const nextRNode = icuContainerIterate(tNode, lView);
      let rNode;
      while (rNode = nextRNode()) {
        result.push(rNode);
      }
    } else if (tNodeType & 16) {
      const nodesInSlot = getProjectionNodes(lView, tNode);
      if (Array.isArray(nodesInSlot)) {
        result.push(...nodesInSlot);
      } else {
        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
        ngDevMode && assertParentView(parentView);
        collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);
      }
    }
    tNode = isProjection ? tNode.projectionNext : tNode.next;
  }
  return result;
}
function collectNativeNodesInLContainer(lContainer, result) {
  for (let i2 = CONTAINER_HEADER_OFFSET; i2 < lContainer.length; i2++) {
    const lViewInAContainer = lContainer[i2];
    const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;
    if (lViewFirstChildTNode !== null) {
      collectNativeNodes(lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);
    }
  }
  if (lContainer[NATIVE] !== lContainer[HOST]) {
    result.push(lContainer[NATIVE]);
  }
}
function addAfterRenderSequencesForView(lView) {
  if (lView[AFTER_RENDER_SEQUENCES_TO_ADD] !== null) {
    for (const sequence of lView[AFTER_RENDER_SEQUENCES_TO_ADD]) {
      sequence.impl.addSequence(sequence);
    }
    lView[AFTER_RENDER_SEQUENCES_TO_ADD].length = 0;
  }
}
function getOrBorrowReactiveLViewConsumer(lView) {
  return lView[REACTIVE_TEMPLATE_CONSUMER] ?? borrowReactiveLViewConsumer(lView);
}
function borrowReactiveLViewConsumer(lView) {
  const consumer = freeConsumers.pop() ?? Object.create(REACTIVE_LVIEW_CONSUMER_NODE);
  consumer.lView = lView;
  return consumer;
}
function maybeReturnReactiveLViewConsumer(consumer) {
  if (consumer.lView[REACTIVE_TEMPLATE_CONSUMER] === consumer) {
    return;
  }
  consumer.lView = null;
  freeConsumers.push(consumer);
}
function getOrCreateTemporaryConsumer(lView) {
  const consumer = lView[REACTIVE_TEMPLATE_CONSUMER] ?? Object.create(TEMPORARY_CONSUMER_NODE);
  consumer.lView = lView;
  return consumer;
}
function viewShouldHaveReactiveConsumer(tView) {
  return tView.type !== 2;
}
function isReactiveLViewConsumer(node) {
  return node.kind === "template";
}
function runEffectsInView(view) {
  if (view[EFFECTS] === null) {
    return;
  }
  let tryFlushEffects = true;
  while (tryFlushEffects) {
    let foundDirtyEffect = false;
    for (const effect2 of view[EFFECTS]) {
      if (!effect2.dirty) {
        continue;
      }
      foundDirtyEffect = true;
      if (effect2.zone === null || Zone.current === effect2.zone) {
        effect2.run();
      } else {
        effect2.zone.run(() => effect2.run());
      }
    }
    tryFlushEffects = foundDirtyEffect && !!(view[FLAGS] & 8192);
  }
}
function detectChangesInternal(lView, mode = 0) {
  const environment2 = lView[ENVIRONMENT];
  const rendererFactory = environment2.rendererFactory;
  const checkNoChangesMode = !!ngDevMode && isInCheckNoChangesMode();
  if (!checkNoChangesMode) {
    rendererFactory.begin?.();
  }
  try {
    detectChangesInViewWhileDirty(lView, mode);
  } finally {
    if (!checkNoChangesMode) {
      rendererFactory.end?.();
    }
  }
}
function detectChangesInViewWhileDirty(lView, mode) {
  const lastIsRefreshingViewsValue = isRefreshingViews();
  try {
    setIsRefreshingViews(true);
    detectChangesInView(lView, mode);
    if (ngDevMode && isExhaustiveCheckNoChanges()) {
      return;
    }
    let retries = 0;
    while (requiresRefreshOrTraversal(lView)) {
      if (retries === MAXIMUM_REFRESH_RERUNS$1) {
        throw new RuntimeError(103, ngDevMode && "Infinite change detection while trying to refresh views. There may be components which each cause the other to require a refresh, causing an infinite loop.");
      }
      retries++;
      detectChangesInView(
        lView,
        1
        /* ChangeDetectionMode.Targeted */
      );
    }
  } finally {
    setIsRefreshingViews(lastIsRefreshingViewsValue);
  }
}
function checkNoChangesInternal(lView, exhaustive) {
  setIsInCheckNoChangesMode(exhaustive ? CheckNoChangesMode.Exhaustive : CheckNoChangesMode.OnlyDirtyViews);
  try {
    detectChangesInternal(lView);
  } finally {
    setIsInCheckNoChangesMode(CheckNoChangesMode.Off);
  }
}
function refreshView(tView, lView, templateFn, context2) {
  ngDevMode && assertEqual(isCreationMode(lView), false, "Should be run in update mode");
  if (isDestroyed(lView))
    return;
  const flags = lView[FLAGS];
  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();
  const isInExhaustiveCheckNoChangesPass = ngDevMode && isExhaustiveCheckNoChanges();
  enterView(lView);
  let returnConsumerToPool = true;
  let prevConsumer = null;
  let currentConsumer = null;
  if (!isInCheckNoChangesPass) {
    if (viewShouldHaveReactiveConsumer(tView)) {
      currentConsumer = getOrBorrowReactiveLViewConsumer(lView);
      prevConsumer = consumerBeforeComputation(currentConsumer);
    } else if (getActiveConsumer() === null) {
      returnConsumerToPool = false;
      currentConsumer = getOrCreateTemporaryConsumer(lView);
      prevConsumer = consumerBeforeComputation(currentConsumer);
    } else if (lView[REACTIVE_TEMPLATE_CONSUMER]) {
      consumerDestroy(lView[REACTIVE_TEMPLATE_CONSUMER]);
      lView[REACTIVE_TEMPLATE_CONSUMER] = null;
    }
  }
  try {
    resetPreOrderHookFlags(lView);
    setBindingIndex(tView.bindingStartIndex);
    if (templateFn !== null) {
      executeTemplate(tView, lView, templateFn, 2, context2);
    }
    const hooksInitPhaseCompleted = (flags & 3) === 3;
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const preOrderCheckHooks = tView.preOrderCheckHooks;
        if (preOrderCheckHooks !== null) {
          executeCheckHooks(lView, preOrderCheckHooks, null);
        }
      } else {
        const preOrderHooks = tView.preOrderHooks;
        if (preOrderHooks !== null) {
          executeInitAndCheckHooks(lView, preOrderHooks, 0, null);
        }
        incrementInitPhaseFlags(
          lView,
          0
          /* InitPhaseState.OnInitHooksToBeRun */
        );
      }
    }
    if (!isInExhaustiveCheckNoChangesPass) {
      markTransplantedViewsForRefresh(lView);
    }
    runEffectsInView(lView);
    detectChangesInEmbeddedViews(
      lView,
      0
      /* ChangeDetectionMode.Global */
    );
    if (tView.contentQueries !== null) {
      refreshContentQueries(tView, lView);
    }
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const contentCheckHooks = tView.contentCheckHooks;
        if (contentCheckHooks !== null) {
          executeCheckHooks(lView, contentCheckHooks);
        }
      } else {
        const contentHooks = tView.contentHooks;
        if (contentHooks !== null) {
          executeInitAndCheckHooks(
            lView,
            contentHooks,
            1
            /* InitPhaseState.AfterContentInitHooksToBeRun */
          );
        }
        incrementInitPhaseFlags(
          lView,
          1
          /* InitPhaseState.AfterContentInitHooksToBeRun */
        );
      }
    }
    processHostBindingOpCodes(tView, lView);
    const components = tView.components;
    if (components !== null) {
      detectChangesInChildComponents(
        lView,
        components,
        0
        /* ChangeDetectionMode.Global */
      );
    }
    const viewQuery = tView.viewQuery;
    if (viewQuery !== null) {
      executeViewQueryFn(2, viewQuery, context2);
    }
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const viewCheckHooks = tView.viewCheckHooks;
        if (viewCheckHooks !== null) {
          executeCheckHooks(lView, viewCheckHooks);
        }
      } else {
        const viewHooks = tView.viewHooks;
        if (viewHooks !== null) {
          executeInitAndCheckHooks(
            lView,
            viewHooks,
            2
            /* InitPhaseState.AfterViewInitHooksToBeRun */
          );
        }
        incrementInitPhaseFlags(
          lView,
          2
          /* InitPhaseState.AfterViewInitHooksToBeRun */
        );
      }
    }
    if (tView.firstUpdatePass === true) {
      tView.firstUpdatePass = false;
    }
    if (lView[EFFECTS_TO_SCHEDULE]) {
      for (const notifyEffect of lView[EFFECTS_TO_SCHEDULE]) {
        notifyEffect();
      }
      lView[EFFECTS_TO_SCHEDULE] = null;
    }
    if (!isInCheckNoChangesPass) {
      addAfterRenderSequencesForView(lView);
      lView[FLAGS] &= ~(64 | 8);
    }
  } catch (e2) {
    if (!isInCheckNoChangesPass) {
      markAncestorsForTraversal(lView);
    }
    throw e2;
  } finally {
    if (currentConsumer !== null) {
      consumerAfterComputation(currentConsumer, prevConsumer);
      if (returnConsumerToPool) {
        maybeReturnReactiveLViewConsumer(currentConsumer);
      }
    }
    leaveView();
  }
}
function detectChangesInEmbeddedViews(lView, mode) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    for (let i2 = CONTAINER_HEADER_OFFSET; i2 < lContainer.length; i2++) {
      const embeddedLView = lContainer[i2];
      detectChangesInViewIfAttached(embeddedLView, mode);
    }
  }
}
function markTransplantedViewsForRefresh(lView) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    if (!(lContainer[FLAGS] & 2))
      continue;
    const movedViews = lContainer[MOVED_VIEWS];
    ngDevMode && assertDefined(movedViews, "Transplanted View flags set but missing MOVED_VIEWS");
    for (let i2 = 0; i2 < movedViews.length; i2++) {
      const movedLView = movedViews[i2];
      markViewForRefresh(movedLView);
    }
  }
}
function detectChangesInComponent(hostLView, componentHostIdx, mode) {
  ngDevMode && assertEqual(isCreationMode(hostLView), false, "Should be run in update mode");
  profiler(
    18
    /* ProfilerEvent.ComponentStart */
  );
  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
  detectChangesInViewIfAttached(componentView, mode);
  profiler(19, componentView[CONTEXT]);
}
function detectChangesInViewIfAttached(lView, mode) {
  if (!viewAttachedToChangeDetector(lView)) {
    return;
  }
  detectChangesInView(lView, mode);
}
function detectChangesInView(lView, mode) {
  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();
  const tView = lView[TVIEW];
  const flags = lView[FLAGS];
  const consumer = lView[REACTIVE_TEMPLATE_CONSUMER];
  let shouldRefreshView = !!(mode === 0 && flags & 16);
  shouldRefreshView ||= !!(flags & 64 && mode === 0 && !isInCheckNoChangesPass);
  shouldRefreshView ||= !!(flags & 1024);
  shouldRefreshView ||= !!(consumer?.dirty && consumerPollProducersForChange(consumer));
  shouldRefreshView ||= !!(ngDevMode && isExhaustiveCheckNoChanges());
  if (consumer) {
    consumer.dirty = false;
  }
  lView[FLAGS] &= ~(8192 | 1024);
  if (shouldRefreshView) {
    refreshView(tView, lView, tView.template, lView[CONTEXT]);
  } else if (flags & 8192) {
    const prevConsumer = setActiveConsumer(null);
    try {
      if (!isInCheckNoChangesPass) {
        runEffectsInView(lView);
      }
      detectChangesInEmbeddedViews(
        lView,
        1
        /* ChangeDetectionMode.Targeted */
      );
      const components = tView.components;
      if (components !== null) {
        detectChangesInChildComponents(
          lView,
          components,
          1
          /* ChangeDetectionMode.Targeted */
        );
      }
      if (!isInCheckNoChangesPass) {
        addAfterRenderSequencesForView(lView);
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function detectChangesInChildComponents(hostLView, components, mode) {
  for (let i2 = 0; i2 < components.length; i2++) {
    detectChangesInComponent(hostLView, components[i2], mode);
  }
}
function processHostBindingOpCodes(tView, lView) {
  const hostBindingOpCodes = tView.hostBindingOpCodes;
  if (hostBindingOpCodes === null)
    return;
  try {
    for (let i2 = 0; i2 < hostBindingOpCodes.length; i2++) {
      const opCode = hostBindingOpCodes[i2];
      if (opCode < 0) {
        setSelectedIndex(~opCode);
      } else {
        const directiveIdx = opCode;
        const bindingRootIndx = hostBindingOpCodes[++i2];
        const hostBindingFn = hostBindingOpCodes[++i2];
        setBindingRootForHostBindings(bindingRootIndx, directiveIdx);
        const context2 = lView[directiveIdx];
        profiler(24, context2);
        hostBindingFn(2, context2);
        profiler(25, context2);
      }
    }
  } finally {
    setSelectedIndex(-1);
  }
}
function markViewDirty(lView, source) {
  const dirtyBitsToUse = isRefreshingViews() ? (
    // When we are actively refreshing views, we only use the `Dirty` bit to mark a view
    64
  ) : (
    // When we are not actively refreshing a view tree, it is absolutely
    // valid to update state and mark views dirty. We use the `RefreshView` flag in this
    // case to allow synchronously rerunning change detection. This applies today to
    // afterRender hooks as well as animation listeners which execute after detecting
    // changes in a view when the render factory flushes.
    1024 | 64
  );
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(source);
  while (lView) {
    lView[FLAGS] |= dirtyBitsToUse;
    const parent = getLViewParent(lView);
    if (isRootView(lView) && !parent) {
      return lView;
    }
    lView = parent;
  }
  return null;
}
function createLContainer(hostNative, currentView, native, tNode) {
  ngDevMode && assertLView(currentView);
  const lContainer = [
    hostNative,
    // host native
    true,
    // Boolean `true` in this position signifies that this is an `LContainer`
    0,
    // flags
    currentView,
    // parent
    null,
    // next
    tNode,
    // t_host
    null,
    // dehydrated views
    native,
    // native,
    null,
    // view refs
    null
    // moved views
  ];
  ngDevMode && assertEqual(lContainer.length, CONTAINER_HEADER_OFFSET, "Should allocate correct number of slots for LContainer header.");
  return lContainer;
}
function getLViewFromLContainer(lContainer, index) {
  const adjustedIndex = CONTAINER_HEADER_OFFSET + index;
  if (adjustedIndex < lContainer.length) {
    const lView = lContainer[adjustedIndex];
    ngDevMode && assertLView(lView);
    return lView;
  }
  return void 0;
}
function addLViewToLContainer(lContainer, lView, index, addToDOM = true) {
  const tView = lView[TVIEW];
  insertView(tView, lView, lContainer, index);
  if (addToDOM) {
    const beforeNode = getBeforeNodeForView(index, lContainer);
    const renderer = lView[RENDERER];
    const parentRNode = renderer.parentNode(lContainer[NATIVE]);
    if (parentRNode !== null) {
      addViewToDOM(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);
    }
  }
  const hydrationInfo = lView[HYDRATION];
  if (hydrationInfo !== null && hydrationInfo.firstChild !== null) {
    hydrationInfo.firstChild = null;
  }
}
function removeLViewFromLContainer(lContainer, index) {
  const lView = detachView(lContainer, index);
  if (lView !== void 0) {
    destroyLView(lView[TVIEW], lView);
  }
  return lView;
}
function detachView(lContainer, removeIndex) {
  if (lContainer.length <= CONTAINER_HEADER_OFFSET)
    return;
  const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;
  const viewToDetach = lContainer[indexInContainer];
  if (viewToDetach) {
    const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];
    if (declarationLContainer !== null && declarationLContainer !== lContainer) {
      detachMovedView(declarationLContainer, viewToDetach);
    }
    if (removeIndex > 0) {
      lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];
    }
    const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);
    removeViewFromDOM(viewToDetach[TVIEW], viewToDetach);
    const lQueries = removedLView[QUERIES];
    if (lQueries !== null) {
      lQueries.detachView(removedLView[TVIEW]);
    }
    viewToDetach[PARENT] = null;
    viewToDetach[NEXT] = null;
    viewToDetach[FLAGS] &= ~128;
  }
  return viewToDetach;
}
function insertView(tView, lView, lContainer, index) {
  ngDevMode && assertLView(lView);
  ngDevMode && assertLContainer(lContainer);
  const indexInContainer = CONTAINER_HEADER_OFFSET + index;
  const containerLength = lContainer.length;
  if (index > 0) {
    lContainer[indexInContainer - 1][NEXT] = lView;
  }
  if (index < containerLength - CONTAINER_HEADER_OFFSET) {
    lView[NEXT] = lContainer[indexInContainer];
    addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);
  } else {
    lContainer.push(lView);
    lView[NEXT] = null;
  }
  lView[PARENT] = lContainer;
  const declarationLContainer = lView[DECLARATION_LCONTAINER];
  if (declarationLContainer !== null && lContainer !== declarationLContainer) {
    trackMovedView(declarationLContainer, lView);
  }
  const lQueries = lView[QUERIES];
  if (lQueries !== null) {
    lQueries.insertView(tView);
  }
  updateAncestorTraversalFlagsOnAttach(lView);
  lView[FLAGS] |= 128;
}
function trackMovedView(declarationContainer, lView) {
  ngDevMode && assertDefined(lView, "LView required");
  ngDevMode && assertLContainer(declarationContainer);
  const movedViews = declarationContainer[MOVED_VIEWS];
  const parent = lView[PARENT];
  ngDevMode && assertDefined(parent, "missing parent");
  if (isLView(parent)) {
    declarationContainer[FLAGS] |= 2;
  } else {
    const insertedComponentLView = parent[PARENT][DECLARATION_COMPONENT_VIEW];
    ngDevMode && assertDefined(insertedComponentLView, "Missing insertedComponentLView");
    const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];
    ngDevMode && assertDefined(declaredComponentLView, "Missing declaredComponentLView");
    if (declaredComponentLView !== insertedComponentLView) {
      declarationContainer[FLAGS] |= 2;
    }
  }
  if (movedViews === null) {
    declarationContainer[MOVED_VIEWS] = [lView];
  } else {
    movedViews.push(lView);
  }
}
function injectTemplateRef() {
  return createTemplateRef(getCurrentTNode(), getLView());
}
function createTemplateRef(hostTNode, hostLView) {
  if (hostTNode.type & 4) {
    ngDevMode && assertDefined(hostTNode.tView, "TView must be allocated");
    return new TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));
  }
  return null;
}
function getFriendlyStringFromTNodeType(tNodeType) {
  switch (tNodeType) {
    case 4:
      return "view container";
    case 2:
      return "element";
    case 8:
      return "ng-container";
    case 32:
      return "icu";
    case 64:
      return "i18n";
    case 16:
      return "projection";
    case 1:
      return "text";
    case 128:
      return "@let";
    default:
      return "<unknown>";
  }
}
function validateSiblingNodeExists(node) {
  validateNodeExists(node);
  if (!node.nextSibling) {
    const header = "During hydration Angular expected more sibling nodes to be present.\n\n";
    const actual = `Actual DOM is:

${describeDomFromNode(node)}

`;
    const footer = getHydrationErrorFooter();
    const message = header + actual + footer;
    markRNodeAsHavingHydrationMismatch(node, "", actual);
    throw new RuntimeError(-501, message);
  }
}
function validateNodeExists(node, lView = null, tNode = null) {
  if (!node) {
    const header = "During hydration, Angular expected an element to be present at this location.\n\n";
    let expected = "";
    let footer = "";
    if (lView !== null && tNode !== null) {
      expected = describeExpectedDom(lView, tNode, false);
      footer = getHydrationErrorFooter();
      markRNodeAsHavingHydrationMismatch(unwrapRNode(lView[HOST]), expected, "");
    }
    throw new RuntimeError(-502, `${header}${expected}

${footer}`);
  }
}
function stringifyTNodeAttrs(tNode) {
  const results = [];
  if (tNode.attrs) {
    for (let i2 = 0; i2 < tNode.attrs.length; ) {
      const attrName = tNode.attrs[i2++];
      if (typeof attrName == "number") {
        break;
      }
      const attrValue = tNode.attrs[i2++];
      results.push(`${attrName}="${shorten(attrValue)}"`);
    }
  }
  return results.join(" ");
}
function stringifyRNodeAttrs(rNode) {
  const results = [];
  for (let i2 = 0; i2 < rNode.attributes.length; i2++) {
    const attr = rNode.attributes[i2];
    if (internalAttrs.has(attr.name))
      continue;
    results.push(`${attr.name}="${shorten(attr.value)}"`);
  }
  return results.join(" ");
}
function describeTNode(tNode, innerContent = "\u2026") {
  switch (tNode.type) {
    case 1:
      const content = tNode.value ? `(${tNode.value})` : "";
      return `#text${content}`;
    case 2:
      const attrs = stringifyTNodeAttrs(tNode);
      const tag = tNode.value.toLowerCase();
      return `<${tag}${attrs ? " " + attrs : ""}>${innerContent}</${tag}>`;
    case 8:
      return "<!-- ng-container -->";
    case 4:
      return "<!-- container -->";
    default:
      const typeAsString = getFriendlyStringFromTNodeType(tNode.type);
      return `#node(${typeAsString})`;
  }
}
function describeRNode(rNode, innerContent = "\u2026") {
  const node = rNode;
  switch (node.nodeType) {
    case Node.ELEMENT_NODE:
      const tag = node.tagName.toLowerCase();
      const attrs = stringifyRNodeAttrs(node);
      return `<${tag}${attrs ? " " + attrs : ""}>${innerContent}</${tag}>`;
    case Node.TEXT_NODE:
      const content = node.textContent ? shorten(node.textContent) : "";
      return `#text${content ? `(${content})` : ""}`;
    case Node.COMMENT_NODE:
      return `<!-- ${shorten(node.textContent ?? "")} -->`;
    default:
      return `#node(${node.nodeType})`;
  }
}
function describeExpectedDom(lView, tNode, isViewContainerAnchor) {
  const spacer = "  ";
  let content = "";
  if (tNode.prev) {
    content += spacer + "\u2026\n";
    content += spacer + describeTNode(tNode.prev) + "\n";
  } else if (tNode.type && tNode.type & 12) {
    content += spacer + "\u2026\n";
  }
  if (isViewContainerAnchor) {
    content += spacer + describeTNode(tNode) + "\n";
    content += spacer + `<!-- container -->  ${AT_THIS_LOCATION}
`;
  } else {
    content += spacer + describeTNode(tNode) + `  ${AT_THIS_LOCATION}
`;
  }
  content += spacer + "\u2026\n";
  const parentRNode = tNode.type ? getParentRElement(lView[TVIEW], tNode, lView) : null;
  if (parentRNode) {
    content = describeRNode(parentRNode, "\n" + content);
  }
  return content;
}
function describeDomFromNode(node) {
  const spacer = "  ";
  let content = "";
  const currentNode = node;
  if (currentNode.previousSibling) {
    content += spacer + "\u2026\n";
    content += spacer + describeRNode(currentNode.previousSibling) + "\n";
  }
  content += spacer + describeRNode(currentNode) + `  ${AT_THIS_LOCATION}
`;
  if (node.nextSibling) {
    content += spacer + "\u2026\n";
  }
  if (node.parentNode) {
    content = describeRNode(currentNode.parentNode, "\n" + content);
  }
  return content;
}
function getHydrationErrorFooter(componentClassName) {
  const componentInfo = componentClassName ? `the "${componentClassName}"` : "corresponding";
  return `To fix this problem:
  * check ${componentInfo} component for hydration-related issues
  * check to see if your template has valid HTML structure
  * or skip hydration by adding the \`ngSkipHydration\` attribute to its host node in a template

`;
}
function stripNewlines(input2) {
  return input2.replace(/\s+/gm, "");
}
function shorten(input2, maxLength = 50) {
  if (!input2) {
    return "";
  }
  input2 = stripNewlines(input2);
  return input2.length > maxLength ? `${input2.substring(0, maxLength - 1)}\u2026` : input2;
}
function getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {
  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;
  const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;
  if (insertBeforeIndex === null) {
    return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);
  } else {
    ngDevMode && assertIndexInRange(lView, insertBeforeIndex);
    return unwrapRNode(lView[insertBeforeIndex]);
  }
}
function processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {
  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;
  if (Array.isArray(tNodeInsertBeforeIndex)) {
    ngDevMode && assertDomNode(childRNode);
    let i18nParent = childRNode;
    let anchorRNode = null;
    if (!(childTNode.type & 3)) {
      anchorRNode = i18nParent;
      i18nParent = parentRElement;
    }
    if (i18nParent !== null && childTNode.componentOffset === -1) {
      for (let i2 = 1; i2 < tNodeInsertBeforeIndex.length; i2++) {
        const i18nChild = lView[tNodeInsertBeforeIndex[i2]];
        nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);
      }
    }
  }
}
function getOrCreateTNode(tView, index, type, name, attrs) {
  ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in
  // `view_engine_compatibility` for additional context.
  assertGreaterThanOrEqual(index, HEADER_OFFSET, "TNodes can't be in the LView header.");
  ngDevMode && assertPureTNodeType(type);
  let tNode = tView.data[index];
  if (tNode === null) {
    tNode = createTNodeAtIndex(tView, index, type, name, attrs);
    if (isInI18nBlock()) {
      tNode.flags |= 32;
    }
  } else if (tNode.type & 64) {
    tNode.type = type;
    tNode.value = name;
    tNode.attrs = attrs;
    const parent = getCurrentParentTNode();
    tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;
    ngDevMode && assertTNodeForTView(tNode, tView);
    ngDevMode && assertEqual(index, tNode.index, "Expecting same index");
  }
  setCurrentTNode(tNode, true);
  return tNode;
}
function createTNodeAtIndex(tView, index, type, name, attrs) {
  const currentTNode = getCurrentTNodePlaceholderOk();
  const isParent = isCurrentTNodeParent();
  const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;
  const tNode = tView.data[index] = createTNode(tView, parent, type, index, name, attrs);
  linkTNodeInTView(tView, tNode, currentTNode, isParent);
  return tNode;
}
function linkTNodeInTView(tView, tNode, currentTNode, isParent) {
  if (tView.firstChild === null) {
    tView.firstChild = tNode;
  }
  if (currentTNode !== null) {
    if (isParent) {
      if (currentTNode.child == null && tNode.parent !== null) {
        currentTNode.child = tNode;
      }
    } else {
      if (currentTNode.next === null) {
        currentTNode.next = tNode;
        tNode.prev = currentTNode;
      }
    }
  }
}
function createTNode(tView, tParent, type, index, value, attrs) {
  ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in
  // `view_engine_compatibility` for additional context.
  assertGreaterThanOrEqual(index, HEADER_OFFSET, "TNodes can't be in the LView header.");
  ngDevMode && assertNotSame(attrs, void 0, "'undefined' is not valid value for 'attrs'");
  ngDevMode && tParent && assertTNodeForTView(tParent, tView);
  let injectorIndex = tParent ? tParent.injectorIndex : -1;
  let flags = 0;
  if (isInSkipHydrationBlock()) {
    flags |= 128;
  }
  const tNode = {
    type,
    index,
    insertBeforeIndex: null,
    injectorIndex,
    directiveStart: -1,
    directiveEnd: -1,
    directiveStylingLast: -1,
    componentOffset: -1,
    propertyBindings: null,
    flags,
    providerIndexes: 0,
    value,
    attrs,
    mergedAttrs: null,
    localNames: null,
    initialInputs: null,
    inputs: null,
    hostDirectiveInputs: null,
    outputs: null,
    hostDirectiveOutputs: null,
    directiveToIndex: null,
    tView: null,
    next: null,
    prev: null,
    projectionNext: null,
    child: null,
    parent: tParent,
    projection: null,
    styles: null,
    stylesWithoutHost: null,
    residualStyles: void 0,
    classes: null,
    classesWithoutHost: null,
    residualClasses: void 0,
    classBindings: 0,
    styleBindings: 0
  };
  if (ngDevMode) {
    Object.seal(tNode);
  }
  return tNode;
}
function addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {
  ngDevMode && assertEqual(newTNode.insertBeforeIndex, null, "We expect that insertBeforeIndex is not set");
  previousTNodes.push(newTNode);
  if (previousTNodes.length > 1) {
    for (let i2 = previousTNodes.length - 2; i2 >= 0; i2--) {
      const existingTNode = previousTNodes[i2];
      if (!isI18nText(existingTNode)) {
        if (isNewTNodeCreatedBefore(existingTNode, newTNode) && getInsertBeforeIndex(existingTNode) === null) {
          setInsertBeforeIndex(existingTNode, newTNode.index);
        }
      }
    }
  }
}
function isI18nText(tNode) {
  return !(tNode.type & 64);
}
function isNewTNodeCreatedBefore(existingTNode, newTNode) {
  return isI18nText(newTNode) || existingTNode.index > newTNode.index;
}
function getInsertBeforeIndex(tNode) {
  const index = tNode.insertBeforeIndex;
  return Array.isArray(index) ? index[0] : index;
}
function setInsertBeforeIndex(tNode, value) {
  const index = tNode.insertBeforeIndex;
  if (Array.isArray(index)) {
    index[0] = value;
  } else {
    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
    tNode.insertBeforeIndex = value;
  }
}
function getTIcu(tView, index) {
  const value = tView.data[index];
  if (value === null || typeof value === "string")
    return null;
  if (ngDevMode && !(value.hasOwnProperty("tView") || value.hasOwnProperty("currentCaseLViewIndex"))) {
    throwError2("We expect to get 'null'|'TIcu'|'TIcuContainer', but got: " + value);
  }
  const tIcu = value.hasOwnProperty("currentCaseLViewIndex") ? value : value.value;
  ngDevMode && assertTIcu(tIcu);
  return tIcu;
}
function setTIcu(tView, index, tIcu) {
  const tNode = tView.data[index];
  ngDevMode && assertEqual(tNode === null || tNode.hasOwnProperty("tView"), true, "We expect to get 'null'|'TIcuContainer'");
  if (tNode === null) {
    tView.data[index] = tIcu;
  } else {
    ngDevMode && assertTNodeType(
      tNode,
      32
      /* TNodeType.Icu */
    );
    tNode.value = tIcu;
  }
}
function setTNodeInsertBeforeIndex(tNode, index) {
  ngDevMode && assertTNode(tNode);
  let insertBeforeIndex = tNode.insertBeforeIndex;
  if (insertBeforeIndex === null) {
    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
    insertBeforeIndex = tNode.insertBeforeIndex = [
      null,
      index
    ];
  } else {
    assertEqual(Array.isArray(insertBeforeIndex), true, "Expecting array here");
    insertBeforeIndex.push(index);
  }
}
function createTNodePlaceholder(tView, previousTNodes, index) {
  const tNode = createTNodeAtIndex(tView, index, 64, null, null);
  addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);
  return tNode;
}
function getCurrentICUCaseIndex(tIcu, lView) {
  const currentCase = lView[tIcu.currentCaseLViewIndex];
  return currentCase === null ? currentCase : currentCase < 0 ? ~currentCase : currentCase;
}
function getParentFromIcuCreateOpCode(mergedCode) {
  return mergedCode >>> 17;
}
function getRefFromIcuCreateOpCode(mergedCode) {
  return (mergedCode & 131070) >>> 1;
}
function getInstructionFromIcuCreateOpCode(mergedCode) {
  return mergedCode & 1;
}
function icuCreateOpCode(opCode, parentIdx, refIdx) {
  ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, "Missing parent index");
  ngDevMode && assertGreaterThan(refIdx, 0, "Missing ref index");
  return opCode | parentIdx << 17 | refIdx << 1;
}
function isRootTemplateMessage(subTemplateIndex) {
  return subTemplateIndex === -1;
}
function enterIcu(state, tIcu, lView) {
  state.index = 0;
  const currentCase = getCurrentICUCaseIndex(tIcu, lView);
  if (currentCase !== null) {
    ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);
    state.removes = tIcu.remove[currentCase];
  } else {
    state.removes = EMPTY_ARRAY;
  }
}
function icuContainerIteratorNext(state) {
  if (state.index < state.removes.length) {
    const removeOpCode = state.removes[state.index++];
    ngDevMode && assertNumber(removeOpCode, "Expecting OpCode number");
    if (removeOpCode > 0) {
      const rNode = state.lView[removeOpCode];
      ngDevMode && assertDomNode(rNode);
      return rNode;
    } else {
      state.stack.push(state.index, state.removes);
      const tIcuIndex = ~removeOpCode;
      const tIcu = state.lView[TVIEW].data[tIcuIndex];
      ngDevMode && assertTIcu(tIcu);
      enterIcu(state, tIcu, state.lView);
      return icuContainerIteratorNext(state);
    }
  } else {
    if (state.stack.length === 0) {
      return null;
    } else {
      state.removes = state.stack.pop();
      state.index = state.stack.pop();
      return icuContainerIteratorNext(state);
    }
  }
}
function loadIcuContainerVisitor() {
  const _state = {
    stack: [],
    index: -1
  };
  function icuContainerIteratorStart(tIcuContainerNode, lView) {
    _state.lView = lView;
    while (_state.stack.length)
      _state.stack.pop();
    ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);
    enterIcu(_state, tIcuContainerNode.value, lView);
    return icuContainerIteratorNext.bind(null, _state);
  }
  return icuContainerIteratorStart;
}
function prepareI18nBlockForHydration(lView, index, parentTNode, subTemplateIndex) {
  _prepareI18nBlockForHydrationImpl(lView, index, parentTNode, subTemplateIndex);
}
function claimDehydratedIcuCase(lView, icuIndex, caseIndex) {
  _claimDehydratedIcuCaseImpl(lView, icuIndex, caseIndex);
}
function cleanupI18nHydrationData(lView) {
  const hydrationInfo = lView[HYDRATION];
  if (hydrationInfo) {
    const { i18nNodes, dehydratedIcuData: dehydratedIcuDataMap } = hydrationInfo;
    if (i18nNodes && dehydratedIcuDataMap) {
      const renderer = lView[RENDERER];
      for (const dehydratedIcuData of dehydratedIcuDataMap.values()) {
        cleanupDehydratedIcuData(renderer, i18nNodes, dehydratedIcuData);
      }
    }
    hydrationInfo.i18nNodes = void 0;
    hydrationInfo.dehydratedIcuData = void 0;
  }
}
function cleanupDehydratedIcuData(renderer, i18nNodes, dehydratedIcuData) {
  for (const node of dehydratedIcuData.node.cases[dehydratedIcuData.case]) {
    const rNode = i18nNodes.get(node.index - HEADER_OFFSET);
    if (rNode) {
      nativeRemoveNode(renderer, rNode, false);
    }
  }
}
function removeDehydratedViews(lContainer) {
  const views = lContainer[DEHYDRATED_VIEWS] ?? [];
  const parentLView = lContainer[PARENT];
  const renderer = parentLView[RENDERER];
  const retainedViews = [];
  for (const view of views) {
    if (view.data[DEFER_BLOCK_ID] !== void 0) {
      retainedViews.push(view);
    } else {
      removeDehydratedView(view, renderer);
      ngDevMode && ngDevMode.dehydratedViewsRemoved++;
    }
  }
  lContainer[DEHYDRATED_VIEWS] = retainedViews;
}
function removeDehydratedViewList(deferBlock) {
  const { lContainer } = deferBlock;
  const dehydratedViews = lContainer[DEHYDRATED_VIEWS];
  if (dehydratedViews === null)
    return;
  const parentLView = lContainer[PARENT];
  const renderer = parentLView[RENDERER];
  for (const view of dehydratedViews) {
    removeDehydratedView(view, renderer);
    ngDevMode && ngDevMode.dehydratedViewsRemoved++;
  }
}
function removeDehydratedView(dehydratedView, renderer) {
  let nodesRemoved = 0;
  let currentRNode = dehydratedView.firstChild;
  if (currentRNode) {
    const numNodes = dehydratedView.data[NUM_ROOT_NODES];
    while (nodesRemoved < numNodes) {
      ngDevMode && validateSiblingNodeExists(currentRNode);
      const nextSibling = currentRNode.nextSibling;
      nativeRemoveNode(renderer, currentRNode, false);
      currentRNode = nextSibling;
      nodesRemoved++;
    }
  }
}
function cleanupLContainer(lContainer) {
  removeDehydratedViews(lContainer);
  const hostLView = lContainer[HOST];
  if (isLView(hostLView)) {
    cleanupLView(hostLView);
  }
  for (let i2 = CONTAINER_HEADER_OFFSET; i2 < lContainer.length; i2++) {
    cleanupLView(lContainer[i2]);
  }
}
function cleanupLView(lView) {
  cleanupI18nHydrationData(lView);
  const tView = lView[TVIEW];
  for (let i2 = HEADER_OFFSET; i2 < tView.bindingStartIndex; i2++) {
    if (isLContainer(lView[i2])) {
      const lContainer = lView[i2];
      cleanupLContainer(lContainer);
    } else if (isLView(lView[i2])) {
      cleanupLView(lView[i2]);
    }
  }
}
function cleanupDehydratedViews(appRef) {
  const viewRefs = appRef._views;
  for (const viewRef of viewRefs) {
    const lNode = getLNodeForHydration(viewRef);
    if (lNode !== null && lNode[HOST] !== null) {
      if (isLView(lNode)) {
        cleanupLView(lNode);
      } else {
        cleanupLContainer(lNode);
      }
      ngDevMode && ngDevMode.dehydratedViewsCleanupRuns++;
    }
  }
}
function cleanupHydratedDeferBlocks(deferBlock, hydratedBlocks, registry, appRef) {
  if (deferBlock !== null) {
    registry.cleanup(hydratedBlocks);
    cleanupLContainer(deferBlock.lContainer);
    cleanupDehydratedViews(appRef);
  }
}
function findMatchingDehydratedView(lContainer, template) {
  return _findMatchingDehydratedViewImpl(lContainer, template);
}
function findAndReconcileMatchingDehydratedViews(lContainer, templateTNode, hostLView) {
  return _findAndReconcileMatchingDehydratedViewsImpl(lContainer, templateTNode, hostLView);
}
function injectRenderer2() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);
  return (isLView(nodeAtIndex) ? nodeAtIndex : lView)[RENDERER];
}
function isModuleWithProviders(value) {
  return value.ngModule !== void 0;
}
function isNgModule(value) {
  return !!getNgModuleDef(value);
}
function isPipe(value) {
  return !!getPipeDef(value);
}
function isDirective(value) {
  return !!getDirectiveDef(value);
}
function isComponent(value) {
  return !!getComponentDef(value);
}
function getDependencyTypeForError(type) {
  if (getComponentDef(type))
    return "component";
  if (getDirectiveDef(type))
    return "directive";
  if (getPipeDef(type))
    return "pipe";
  return "type";
}
function verifyStandaloneImport(depType, importingType) {
  if (isForwardRef(depType)) {
    depType = resolveForwardRef(depType);
    if (!depType) {
      throw new Error(`Expected forwardRef function, imported from "${stringifyForError(importingType)}", to return a standalone entity or NgModule but got "${stringifyForError(depType) || depType}".`);
    }
  }
  if (getNgModuleDef(depType) == null) {
    const def = getComponentDef(depType) || getDirectiveDef(depType) || getPipeDef(depType);
    if (def != null) {
      if (!def.standalone) {
        throw new Error(`The "${stringifyForError(depType)}" ${getDependencyTypeForError(depType)}, imported from "${stringifyForError(importingType)}", is not standalone. Did you forget to add the standalone: true flag?`);
      }
    } else {
      if (isModuleWithProviders(depType)) {
        throw new Error(`A module with providers was imported from "${stringifyForError(importingType)}". Modules with providers are not supported in standalone components imports.`);
      } else {
        throw new Error(`The "${stringifyForError(depType)}" type, imported from "${stringifyForError(importingType)}", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`);
      }
    }
  }
}
function addSet(sourceSet, targetSet) {
  for (const m of sourceSet) {
    targetSet.add(m);
  }
}
function computeStaticStyling(tNode, attrs, writeToHost) {
  ngDevMode && assertFirstCreatePass(getTView(), "Expecting to be called in first template pass only");
  let styles = writeToHost ? tNode.styles : null;
  let classes = writeToHost ? tNode.classes : null;
  let mode = 0;
  if (attrs !== null) {
    for (let i2 = 0; i2 < attrs.length; i2++) {
      const value = attrs[i2];
      if (typeof value === "number") {
        mode = value;
      } else if (mode == 1) {
        classes = concatStringsWithSpace(classes, value);
      } else if (mode == 2) {
        const style = value;
        const styleValue = attrs[++i2];
        styles = concatStringsWithSpace(styles, style + ": " + styleValue + ";");
      }
    }
  }
  writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;
  writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;
}
function \u0275\u0275directiveInject(token, flags = 0) {
  const lView = getLView();
  if (lView === null) {
    ngDevMode && assertInjectImplementationNotEqual(\u0275\u0275directiveInject);
    return \u0275\u0275inject(token, flags);
  }
  const tNode = getCurrentTNode();
  const value = getOrCreateInjectable(tNode, lView, resolveForwardRef(token), flags);
  ngDevMode && emitInjectEvent(token, value, flags);
  return value;
}
function \u0275\u0275invalidFactory() {
  const msg = ngDevMode ? `This constructor was not compatible with Dependency Injection.` : "invalid";
  throw new Error(msg);
}
function resolveDirectives(tView, lView, tNode, localRefs, directiveMatcher) {
  ngDevMode && assertFirstCreatePass(tView);
  const exportsMap = localRefs === null ? null : { "": -1 };
  const matchedDirectiveDefs = directiveMatcher(tView, tNode);
  if (matchedDirectiveDefs !== null) {
    let directiveDefs = matchedDirectiveDefs;
    let hostDirectiveDefs = null;
    let hostDirectiveRanges = null;
    for (const def of matchedDirectiveDefs) {
      if (def.resolveHostDirectives !== null) {
        [directiveDefs, hostDirectiveDefs, hostDirectiveRanges] = def.resolveHostDirectives(matchedDirectiveDefs);
        break;
      }
    }
    ngDevMode && assertNoDuplicateDirectives(directiveDefs);
    initializeDirectives(tView, lView, tNode, directiveDefs, exportsMap, hostDirectiveDefs, hostDirectiveRanges);
  }
  if (exportsMap !== null && localRefs !== null) {
    cacheMatchingLocalNames(tNode, localRefs, exportsMap);
  }
}
function cacheMatchingLocalNames(tNode, localRefs, exportsMap) {
  const localNames = tNode.localNames = [];
  for (let i2 = 0; i2 < localRefs.length; i2 += 2) {
    const index = exportsMap[localRefs[i2 + 1]];
    if (index == null)
      throw new RuntimeError(-301, ngDevMode && `Export of name '${localRefs[i2 + 1]}' not found!`);
    localNames.push(localRefs[i2], index);
  }
}
function markAsComponentHost(tView, hostTNode, componentOffset) {
  ngDevMode && assertFirstCreatePass(tView);
  ngDevMode && assertGreaterThan(componentOffset, -1, "componentOffset must be great than -1");
  hostTNode.componentOffset = componentOffset;
  (tView.components ??= []).push(hostTNode.index);
}
function initializeDirectives(tView, lView, tNode, directives, exportsMap, hostDirectiveDefs, hostDirectiveRanges) {
  ngDevMode && assertFirstCreatePass(tView);
  const directivesLength = directives.length;
  let hasSeenComponent = false;
  for (let i2 = 0; i2 < directivesLength; i2++) {
    const def = directives[i2];
    if (!hasSeenComponent && isComponentDef(def)) {
      hasSeenComponent = true;
      markAsComponentHost(tView, tNode, i2);
    }
    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, def.type);
  }
  initTNodeFlags(tNode, tView.data.length, directivesLength);
  for (let i2 = 0; i2 < directivesLength; i2++) {
    const def = directives[i2];
    if (def.providersResolver)
      def.providersResolver(def);
  }
  let preOrderHooksFound = false;
  let preOrderCheckHooksFound = false;
  let directiveIdx = allocExpando(tView, lView, directivesLength, null);
  ngDevMode && assertSame(directiveIdx, tNode.directiveStart, "TNode.directiveStart should point to just allocated space");
  if (directivesLength > 0) {
    tNode.directiveToIndex = /* @__PURE__ */ new Map();
  }
  for (let i2 = 0; i2 < directivesLength; i2++) {
    const def = directives[i2];
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
    configureViewWithDirective(tView, tNode, lView, directiveIdx, def);
    saveNameToExportMap(directiveIdx, def, exportsMap);
    if (hostDirectiveRanges !== null && hostDirectiveRanges.has(def)) {
      const [start, end] = hostDirectiveRanges.get(def);
      tNode.directiveToIndex.set(def.type, [
        directiveIdx,
        start + tNode.directiveStart,
        end + tNode.directiveStart
      ]);
    } else if (hostDirectiveDefs === null || !hostDirectiveDefs.has(def)) {
      tNode.directiveToIndex.set(def.type, directiveIdx);
    }
    if (def.contentQueries !== null)
      tNode.flags |= 4;
    if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0)
      tNode.flags |= 64;
    const lifeCycleHooks = def.type.prototype;
    if (!preOrderHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {
      (tView.preOrderHooks ??= []).push(tNode.index);
      preOrderHooksFound = true;
    }
    if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {
      (tView.preOrderCheckHooks ??= []).push(tNode.index);
      preOrderCheckHooksFound = true;
    }
    directiveIdx++;
  }
  initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs);
}
function initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs) {
  ngDevMode && assertFirstCreatePass(tView);
  for (let index = tNode.directiveStart; index < tNode.directiveEnd; index++) {
    const directiveDef = tView.data[index];
    if (hostDirectiveDefs === null || !hostDirectiveDefs.has(directiveDef)) {
      setupSelectorMatchedInputsOrOutputs(0, tNode, directiveDef, index);
      setupSelectorMatchedInputsOrOutputs(1, tNode, directiveDef, index);
      setupInitialInputs(tNode, index, false);
    } else {
      const hostDirectiveDef = hostDirectiveDefs.get(directiveDef);
      setupHostDirectiveInputsOrOutputs(0, tNode, hostDirectiveDef, index);
      setupHostDirectiveInputsOrOutputs(1, tNode, hostDirectiveDef, index);
      setupInitialInputs(tNode, index, true);
    }
  }
}
function setupSelectorMatchedInputsOrOutputs(mode, tNode, def, directiveIndex) {
  const aliasMap = mode === 0 ? def.inputs : def.outputs;
  for (const publicName in aliasMap) {
    if (aliasMap.hasOwnProperty(publicName)) {
      let bindings;
      if (mode === 0) {
        bindings = tNode.inputs ??= {};
      } else {
        bindings = tNode.outputs ??= {};
      }
      bindings[publicName] ??= [];
      bindings[publicName].push(directiveIndex);
      setShadowStylingInputFlags(tNode, publicName);
    }
  }
}
function setupHostDirectiveInputsOrOutputs(mode, tNode, config2, directiveIndex) {
  const aliasMap = mode === 0 ? config2.inputs : config2.outputs;
  for (const initialName in aliasMap) {
    if (aliasMap.hasOwnProperty(initialName)) {
      const publicName = aliasMap[initialName];
      let bindings;
      if (mode === 0) {
        bindings = tNode.hostDirectiveInputs ??= {};
      } else {
        bindings = tNode.hostDirectiveOutputs ??= {};
      }
      bindings[publicName] ??= [];
      bindings[publicName].push(directiveIndex, initialName);
      setShadowStylingInputFlags(tNode, publicName);
    }
  }
}
function setShadowStylingInputFlags(tNode, publicName) {
  if (publicName === "class") {
    tNode.flags |= 8;
  } else if (publicName === "style") {
    tNode.flags |= 16;
  }
}
function setupInitialInputs(tNode, directiveIndex, isHostDirective) {
  const { attrs, inputs, hostDirectiveInputs } = tNode;
  if (attrs === null || !isHostDirective && inputs === null || isHostDirective && hostDirectiveInputs === null || // Do not use unbound attributes as inputs to structural directives, since structural
  // directive inputs can only be set using microsyntax (e.g. `<div *dir="exp">`).
  isInlineTemplate(tNode)) {
    tNode.initialInputs ??= [];
    tNode.initialInputs.push(null);
    return;
  }
  let inputsToStore = null;
  let i2 = 0;
  while (i2 < attrs.length) {
    const attrName = attrs[i2];
    if (attrName === 0) {
      i2 += 4;
      continue;
    } else if (attrName === 5) {
      i2 += 2;
      continue;
    } else if (typeof attrName === "number") {
      break;
    }
    if (!isHostDirective && inputs.hasOwnProperty(attrName)) {
      const inputConfig = inputs[attrName];
      for (const index of inputConfig) {
        if (index === directiveIndex) {
          inputsToStore ??= [];
          inputsToStore.push(attrName, attrs[i2 + 1]);
          break;
        }
      }
    } else if (isHostDirective && hostDirectiveInputs.hasOwnProperty(attrName)) {
      const config2 = hostDirectiveInputs[attrName];
      for (let j2 = 0; j2 < config2.length; j2 += 2) {
        if (config2[j2] === directiveIndex) {
          inputsToStore ??= [];
          inputsToStore.push(config2[j2 + 1], attrs[i2 + 1]);
          break;
        }
      }
    }
    i2 += 2;
  }
  tNode.initialInputs ??= [];
  tNode.initialInputs.push(inputsToStore);
}
function configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {
  ngDevMode && assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, "Must be in Expando section");
  tView.data[directiveIndex] = def;
  const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));
  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), \u0275\u0275directiveInject, ngDevMode ? def.type.name : null);
  tView.blueprint[directiveIndex] = nodeInjectorFactory;
  lView[directiveIndex] = nodeInjectorFactory;
  registerHostBindingOpCodes(tView, tNode, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);
}
function registerHostBindingOpCodes(tView, tNode, directiveIdx, directiveVarsIdx, def) {
  ngDevMode && assertFirstCreatePass(tView);
  const hostBindings = def.hostBindings;
  if (hostBindings) {
    let hostBindingOpCodes = tView.hostBindingOpCodes;
    if (hostBindingOpCodes === null) {
      hostBindingOpCodes = tView.hostBindingOpCodes = [];
    }
    const elementIndx = ~tNode.index;
    if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {
      hostBindingOpCodes.push(elementIndx);
    }
    hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);
  }
}
function lastSelectedElementIdx(hostBindingOpCodes) {
  let i2 = hostBindingOpCodes.length;
  while (i2 > 0) {
    const value = hostBindingOpCodes[--i2];
    if (typeof value === "number" && value < 0) {
      return value;
    }
  }
  return 0;
}
function saveNameToExportMap(directiveIdx, def, exportsMap) {
  if (exportsMap) {
    if (def.exportAs) {
      for (let i2 = 0; i2 < def.exportAs.length; i2++) {
        exportsMap[def.exportAs[i2]] = directiveIdx;
      }
    }
    if (isComponentDef(def))
      exportsMap[""] = directiveIdx;
  }
}
function initTNodeFlags(tNode, index, numberOfDirectives) {
  ngDevMode && assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, "Reached the max number of directives");
  tNode.flags |= 1;
  tNode.directiveStart = index;
  tNode.directiveEnd = index + numberOfDirectives;
  tNode.providerIndexes = index;
}
function assertNoDuplicateDirectives(directives) {
  if (directives.length < 2) {
    return;
  }
  const seenDirectives = /* @__PURE__ */ new Set();
  for (const current of directives) {
    if (seenDirectives.has(current)) {
      throw new RuntimeError(309, `Directive ${current.type.name} matches multiple times on the same element. Directives can only match an element once.`);
    }
    seenDirectives.add(current);
  }
}
function directiveHostFirstCreatePass(index, lView, type, name, directiveMatcher, bindingsEnabled, attrsIndex, localRefsIndex) {
  const tView = lView[TVIEW];
  ngDevMode && assertFirstCreatePass(tView);
  const tViewConsts = tView.consts;
  const attrs = getConstant(tViewConsts, attrsIndex);
  const tNode = getOrCreateTNode(tView, index, type, name, attrs);
  if (bindingsEnabled) {
    resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex), directiveMatcher);
  }
  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
  if (tNode.attrs !== null) {
    computeStaticStyling(tNode, tNode.attrs, false);
  }
  if (tNode.mergedAttrs !== null) {
    computeStaticStyling(tNode, tNode.mergedAttrs, true);
  }
  if (tView.queries !== null) {
    tView.queries.elementStart(tView, tNode);
  }
  return tNode;
}
function directiveHostEndFirstCreatePass(tView, tNode) {
  ngDevMode && assertFirstCreatePass(tView);
  registerPostOrderHooks(tView, tNode);
  if (isContentQueryHost(tNode)) {
    tView.queries.elementEnd(tNode);
  }
}
function domOnlyFirstCreatePass(index, tView, type, name, attrsIndex, localRefsIndex) {
  ngDevMode && assertFirstCreatePass(tView);
  const tViewConsts = tView.consts;
  const attrs = getConstant(tViewConsts, attrsIndex);
  const tNode = getOrCreateTNode(tView, index, type, name, attrs);
  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
  if (localRefsIndex != null) {
    const refs = getConstant(tViewConsts, localRefsIndex);
    tNode.localNames = [];
    for (let i2 = 0; i2 < refs.length; i2 += 2) {
      tNode.localNames.push(refs[i2], -1);
    }
  }
  if (tNode.attrs !== null) {
    computeStaticStyling(tNode, tNode.attrs, false);
  }
  if (tNode.mergedAttrs !== null) {
    computeStaticStyling(tNode, tNode.mergedAttrs, true);
  }
  if (tView.queries !== null) {
    tView.queries.elementStart(tView, tNode);
  }
  return tNode;
}
function isListLikeIterable(obj) {
  if (!isJsObject(obj))
    return false;
  return Array.isArray(obj) || !(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]
  Symbol.iterator in obj;
}
function areIterablesEqual(a2, b2, comparator) {
  const iterator1 = a2[Symbol.iterator]();
  const iterator2 = b2[Symbol.iterator]();
  while (true) {
    const item1 = iterator1.next();
    const item2 = iterator2.next();
    if (item1.done && item2.done)
      return true;
    if (item1.done || item2.done)
      return false;
    if (!comparator(item1.value, item2.value))
      return false;
  }
}
function iterateListLike(obj, fn) {
  if (Array.isArray(obj)) {
    for (let i2 = 0; i2 < obj.length; i2++) {
      fn(obj[i2]);
    }
  } else {
    const iterator2 = obj[Symbol.iterator]();
    let item;
    while (!(item = iterator2.next()).done) {
      fn(item.value);
    }
  }
}
function isJsObject(o2) {
  return o2 !== null && (typeof o2 === "function" || typeof o2 === "object");
}
function devModeEqual(a2, b2) {
  const isListLikeIterableA = isListLikeIterable(a2);
  const isListLikeIterableB = isListLikeIterable(b2);
  if (isListLikeIterableA && isListLikeIterableB) {
    return areIterablesEqual(a2, b2, devModeEqual);
  } else {
    const isAObject = a2 && (typeof a2 === "object" || typeof a2 === "function");
    const isBObject = b2 && (typeof b2 === "object" || typeof b2 === "function");
    if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
      return true;
    } else {
      return Object.is(a2, b2);
    }
  }
}
function updateBinding(lView, bindingIndex, value) {
  return lView[bindingIndex] = value;
}
function getBinding(lView, bindingIndex) {
  ngDevMode && assertIndexInRange(lView, bindingIndex);
  ngDevMode && assertNotSame(lView[bindingIndex], NO_CHANGE, "Stored value should never be NO_CHANGE.");
  return lView[bindingIndex];
}
function bindingUpdated(lView, bindingIndex, value) {
  ngDevMode && assertLessThan(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);
  if (value === NO_CHANGE) {
    return false;
  }
  const oldValue = lView[bindingIndex];
  if (Object.is(oldValue, value)) {
    return false;
  } else {
    if (ngDevMode && isInCheckNoChangesMode()) {
      const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : void 0;
      if (!devModeEqual(oldValueToCompare, value)) {
        const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);
        throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName, lView);
      }
      return false;
    }
    lView[bindingIndex] = value;
    return true;
  }
}
function bindingUpdated2(lView, bindingIndex, exp1, exp2) {
  const different = bindingUpdated(lView, bindingIndex, exp1);
  return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
}
function bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {
  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
  return bindingUpdated(lView, bindingIndex + 2, exp3) || different;
}
function bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {
  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
  return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;
}
function wrapListener(tNode, lView, listenerFn) {
  return function wrapListenerIn_markDirtyAndPreventDefault(event) {
    const startView = isComponentHost(tNode) ? getComponentLViewByIndex(tNode.index, lView) : lView;
    markViewDirty(
      startView,
      5
      /* NotificationSource.Listener */
    );
    const context2 = lView[CONTEXT];
    let result = executeListenerWithErrorHandling(lView, context2, listenerFn, event);
    let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;
    while (nextListenerFn) {
      result = executeListenerWithErrorHandling(lView, context2, nextListenerFn, event) && result;
      nextListenerFn = nextListenerFn.__ngNextListenerFn__;
    }
    return result;
  };
}
function executeListenerWithErrorHandling(lView, context2, listenerFn, e2) {
  const prevConsumer = setActiveConsumer(null);
  try {
    profiler(6, context2, listenerFn);
    return listenerFn(e2) !== false;
  } catch (error) {
    handleUncaughtError(lView, error);
    return false;
  } finally {
    profiler(7, context2, listenerFn);
    setActiveConsumer(prevConsumer);
  }
}
function listenToDomEvent(tNode, tView, lView, eventTargetResolver, renderer, eventName, originalListener, wrappedListener) {
  ngDevMode && assertNotSame(wrappedListener, originalListener, "Expected wrapped and original listeners to be different.");
  const isTNodeDirectiveHost = isDirectiveHost(tNode);
  let hasCoalesced = false;
  let existingListener = null;
  if (!eventTargetResolver && isTNodeDirectiveHost) {
    existingListener = findExistingListener(tView, lView, eventName, tNode.index);
  }
  if (existingListener !== null) {
    const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;
    lastListenerFn.__ngNextListenerFn__ = originalListener;
    existingListener.__ngLastListenerFn__ = originalListener;
    hasCoalesced = true;
  } else {
    const native = getNativeByTNode(tNode, lView);
    const target = eventTargetResolver ? eventTargetResolver(native) : native;
    stashEventListenerImpl(lView, target, eventName, wrappedListener);
    const cleanupFn = renderer.listen(target, eventName, wrappedListener);
    const idxOrTargetGetter = eventTargetResolver ? (_lView) => eventTargetResolver(unwrapRNode(_lView[tNode.index])) : tNode.index;
    storeListenerCleanup(idxOrTargetGetter, tView, lView, eventName, wrappedListener, cleanupFn, false);
  }
  return hasCoalesced;
}
function findExistingListener(tView, lView, eventName, tNodeIndex) {
  const tCleanup = tView.cleanup;
  if (tCleanup != null) {
    for (let i2 = 0; i2 < tCleanup.length - 1; i2 += 2) {
      const cleanupEventName = tCleanup[i2];
      if (cleanupEventName === eventName && tCleanup[i2 + 1] === tNodeIndex) {
        const lCleanup = lView[CLEANUP];
        const listenerIdxInLCleanup = tCleanup[i2 + 2];
        return lCleanup && lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;
      }
      if (typeof cleanupEventName === "string") {
        i2 += 2;
      }
    }
  }
  return null;
}
function storeListenerCleanup(indexOrTargetGetter, tView, lView, eventName, listenerFn, cleanup, isOutput) {
  const tCleanup = tView.firstCreatePass ? getOrCreateTViewCleanup(tView) : null;
  const lCleanup = getOrCreateLViewCleanup(lView);
  const index = lCleanup.length;
  lCleanup.push(listenerFn, cleanup);
  tCleanup && tCleanup.push(eventName, indexOrTargetGetter, index, (index + 1) * (isOutput ? -1 : 1));
}
function listenToOutput(tNode, lView, directiveIndex, lookupName, eventName, listenerFn) {
  ngDevMode && assertIndexInRange(lView, directiveIndex);
  const instance = lView[directiveIndex];
  const tView = lView[TVIEW];
  const def = tView.data[directiveIndex];
  const propertyName = def.outputs[lookupName];
  const output = instance[propertyName];
  if (ngDevMode && !isOutputSubscribable(output)) {
    throw new Error(`@Output ${propertyName} not initialized in '${instance.constructor.name}'.`);
  }
  const subscription = output.subscribe(listenerFn);
  storeListenerCleanup(tNode.index, tView, lView, eventName, listenerFn, subscription, true);
}
function isOutputSubscribable(value) {
  return value != null && typeof value.subscribe === "function";
}
function toInputRefArray(map2) {
  return Object.keys(map2).map((name) => {
    const [propName, flags, transform] = map2[name];
    const inputData = {
      propName,
      templateName: name,
      isSignal: (flags & InputFlags.SignalBased) !== 0
    };
    if (transform) {
      inputData.transform = transform;
    }
    return inputData;
  });
}
function toOutputRefArray(map2) {
  return Object.keys(map2).map((name) => ({ propName: map2[name], templateName: name }));
}
function verifyNotAnOrphanComponent(componentDef) {
  if (false) {
    if (depsTracker.isOrphanComponent(componentDef.type)) {
      throw new RuntimeError(981, `Orphan component found! Trying to render the component ${debugStringifyTypeForError(componentDef.type)} without first loading the NgModule that declares it. It is recommended to make this component standalone in order to avoid this error. If this is not possible now, import the component's NgModule in the appropriate NgModule, or the standalone component in which you are trying to render this component. If this is a lazy import, load the NgModule lazily as well and use its module injector.`);
    }
  }
}
function createRootViewInjector(componentDef, environmentInjector, injector) {
  let realEnvironmentInjector = environmentInjector instanceof EnvironmentInjector ? environmentInjector : environmentInjector?.injector;
  if (realEnvironmentInjector && componentDef.getStandaloneInjector !== null) {
    realEnvironmentInjector = componentDef.getStandaloneInjector(realEnvironmentInjector) || realEnvironmentInjector;
  }
  const rootViewInjector = realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;
  return rootViewInjector;
}
function createRootLViewEnvironment(rootLViewInjector) {
  const rendererFactory = rootLViewInjector.get(RendererFactory2, null);
  if (rendererFactory === null) {
    throw new RuntimeError(407, ngDevMode && "Angular was not able to inject a renderer (RendererFactory2). Likely this is due to a broken DI hierarchy. Make sure that any injector used to create this component has a correct parent.");
  }
  const sanitizer = rootLViewInjector.get(Sanitizer, null);
  const changeDetectionScheduler = rootLViewInjector.get(ChangeDetectionScheduler, null);
  let ngReflect = false;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    ngReflect = rootLViewInjector.get(NG_REFLECT_ATTRS_FLAG, NG_REFLECT_ATTRS_FLAG_DEFAULT);
  }
  return {
    rendererFactory,
    sanitizer,
    changeDetectionScheduler,
    ngReflect
  };
}
function createHostElement(componentDef, render) {
  const tagName = (componentDef.selectors[0][0] || "div").toLowerCase();
  const namespace = tagName === "svg" ? SVG_NAMESPACE : tagName === "math" ? MATH_ML_NAMESPACE : null;
  return createElementNode(render, tagName, namespace);
}
function createRootTView(rootSelectorOrNode, componentDef, componentBindings, directives) {
  const tAttributes = rootSelectorOrNode ? ["ng-version", "20.1.7"] : (
    // Extract attributes and classes from the first selector only to match VE behavior.
    extractAttrsAndClassesFromSelector(componentDef.selectors[0])
  );
  let creationBindings = null;
  let updateBindings = null;
  let varsToAllocate = 0;
  if (componentBindings) {
    for (const binding of componentBindings) {
      varsToAllocate += binding[BINDING].requiredVars;
      if (binding.create) {
        binding.targetIdx = 0;
        (creationBindings ??= []).push(binding);
      }
      if (binding.update) {
        binding.targetIdx = 0;
        (updateBindings ??= []).push(binding);
      }
    }
  }
  if (directives) {
    for (let i2 = 0; i2 < directives.length; i2++) {
      const directive = directives[i2];
      if (typeof directive !== "function") {
        for (const binding of directive.bindings) {
          varsToAllocate += binding[BINDING].requiredVars;
          const targetDirectiveIdx = i2 + 1;
          if (binding.create) {
            binding.targetIdx = targetDirectiveIdx;
            (creationBindings ??= []).push(binding);
          }
          if (binding.update) {
            binding.targetIdx = targetDirectiveIdx;
            (updateBindings ??= []).push(binding);
          }
        }
      }
    }
  }
  const directivesToApply = [componentDef];
  if (directives) {
    for (const directive of directives) {
      const directiveType = typeof directive === "function" ? directive : directive.type;
      const directiveDef = ngDevMode ? getDirectiveDefOrThrow(directiveType) : getDirectiveDef(directiveType);
      if (ngDevMode && !directiveDef.standalone) {
        throw new RuntimeError(907, `The ${stringifyForError(directiveType)} directive must be standalone in order to be applied to a dynamically-created component.`);
      }
      directivesToApply.push(directiveDef);
    }
  }
  const rootTView = createTView(0, null, getRootTViewTemplate(creationBindings, updateBindings), 1, varsToAllocate, directivesToApply, null, null, null, [tAttributes], null);
  return rootTView;
}
function getRootTViewTemplate(creationBindings, updateBindings) {
  if (!creationBindings && !updateBindings) {
    return null;
  }
  return (flags) => {
    if (flags & 1 && creationBindings) {
      for (const binding of creationBindings) {
        binding.create();
      }
    }
    if (flags & 2 && updateBindings) {
      for (const binding of updateBindings) {
        binding.update();
      }
    }
  };
}
function isInputBinding(binding) {
  const kind = binding[BINDING].kind;
  return kind === "input" || kind === "twoWay";
}
function projectNodes(tNode, ngContentSelectors, projectableNodes) {
  const projection = tNode.projection = [];
  for (let i2 = 0; i2 < ngContentSelectors.length; i2++) {
    const nodesforSlot = projectableNodes[i2];
    projection.push(nodesforSlot != null && nodesforSlot.length ? Array.from(nodesforSlot) : null);
  }
}
function injectViewContainerRef() {
  const previousTNode = getCurrentTNode();
  return createContainerRef(previousTNode, getLView());
}
function getViewRefs(lContainer) {
  return lContainer[VIEW_REFS];
}
function getOrCreateViewRefs(lContainer) {
  return lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = []);
}
function createContainerRef(hostTNode, hostLView) {
  ngDevMode && assertTNodeType(
    hostTNode,
    12 | 3
    /* TNodeType.AnyRNode */
  );
  let lContainer;
  const slotValue = hostLView[hostTNode.index];
  if (isLContainer(slotValue)) {
    lContainer = slotValue;
  } else {
    lContainer = createLContainer(slotValue, hostLView, null, hostTNode);
    hostLView[hostTNode.index] = lContainer;
    addToEndOfViewTree(hostLView, lContainer);
  }
  _locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue);
  return new R3ViewContainerRef(lContainer, hostTNode, hostLView);
}
function insertAnchorNode(hostLView, hostTNode) {
  const renderer = hostLView[RENDERER];
  const commentNode = renderer.createComment(ngDevMode ? "container" : "");
  const hostNative = getNativeByTNode(hostTNode, hostLView);
  const parentOfHostNative = renderer.parentNode(hostNative);
  nativeInsertBefore(renderer, parentOfHostNative, commentNode, renderer.nextSibling(hostNative), false);
  return commentNode;
}
function populateDehydratedViewsInLContainer(lContainer, tNode, hostLView) {
  return _populateDehydratedViewsInLContainer(lContainer, tNode, hostLView);
}
function createAnchorNode(lContainer, hostLView, hostTNode, slotValue) {
  if (lContainer[NATIVE])
    return;
  let commentNode;
  if (hostTNode.type & 8) {
    commentNode = unwrapRNode(slotValue);
  } else {
    commentNode = insertAnchorNode(hostLView, hostTNode);
  }
  lContainer[NATIVE] = commentNode;
}
function getIdxOfMatchingSelector(tNode, selector) {
  const localNames = tNode.localNames;
  if (localNames !== null) {
    for (let i2 = 0; i2 < localNames.length; i2 += 2) {
      if (localNames[i2] === selector) {
        return localNames[i2 + 1];
      }
    }
  }
  return null;
}
function createResultByTNodeType(tNode, currentView) {
  if (tNode.type & (3 | 8)) {
    return createElementRef(tNode, currentView);
  } else if (tNode.type & 4) {
    return createTemplateRef(tNode, currentView);
  }
  return null;
}
function createResultForNode(lView, tNode, matchingIdx, read) {
  if (matchingIdx === -1) {
    return createResultByTNodeType(tNode, lView);
  } else if (matchingIdx === -2) {
    return createSpecialToken(lView, tNode, read);
  } else {
    return getNodeInjectable(lView, lView[TVIEW], matchingIdx, tNode);
  }
}
function createSpecialToken(lView, tNode, read) {
  if (read === ElementRef) {
    return createElementRef(tNode, lView);
  } else if (read === TemplateRef) {
    return createTemplateRef(tNode, lView);
  } else if (read === ViewContainerRef) {
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12
      /* TNodeType.AnyContainer */
    );
    return createContainerRef(tNode, lView);
  } else {
    ngDevMode && throwError2(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${stringify(read)}.`);
  }
}
function materializeViewResults(tView, lView, tQuery, queryIndex) {
  const lQuery = lView[QUERIES].queries[queryIndex];
  if (lQuery.matches === null) {
    const tViewData = tView.data;
    const tQueryMatches = tQuery.matches;
    const result = [];
    for (let i2 = 0; tQueryMatches !== null && i2 < tQueryMatches.length; i2 += 2) {
      const matchedNodeIdx = tQueryMatches[i2];
      if (matchedNodeIdx < 0) {
        result.push(null);
      } else {
        ngDevMode && assertIndexInRange(tViewData, matchedNodeIdx);
        const tNode = tViewData[matchedNodeIdx];
        result.push(createResultForNode(lView, tNode, tQueryMatches[i2 + 1], tQuery.metadata.read));
      }
    }
    lQuery.matches = result;
  }
  return lQuery.matches;
}
function collectQueryResults(tView, lView, queryIndex, result) {
  const tQuery = tView.queries.getByIndex(queryIndex);
  const tQueryMatches = tQuery.matches;
  if (tQueryMatches !== null) {
    const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);
    for (let i2 = 0; i2 < tQueryMatches.length; i2 += 2) {
      const tNodeIdx = tQueryMatches[i2];
      if (tNodeIdx > 0) {
        result.push(lViewResults[i2 / 2]);
      } else {
        const childQueryIndex = tQueryMatches[i2 + 1];
        const declarationLContainer = lView[-tNodeIdx];
        ngDevMode && assertLContainer(declarationLContainer);
        for (let i3 = CONTAINER_HEADER_OFFSET; i3 < declarationLContainer.length; i3++) {
          const embeddedLView = declarationLContainer[i3];
          if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) {
            collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
          }
        }
        if (declarationLContainer[MOVED_VIEWS] !== null) {
          const embeddedLViews = declarationLContainer[MOVED_VIEWS];
          for (let i3 = 0; i3 < embeddedLViews.length; i3++) {
            const embeddedLView = embeddedLViews[i3];
            collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
          }
        }
      }
    }
  }
  return result;
}
function loadQueryInternal(lView, queryIndex) {
  ngDevMode && assertDefined(lView[QUERIES], "LQueries should be defined when trying to load a query");
  ngDevMode && assertIndexInRange(lView[QUERIES].queries, queryIndex);
  return lView[QUERIES].queries[queryIndex].queryList;
}
function createLQuery(tView, lView, flags) {
  const queryList = new QueryList(
    (flags & 4) === 4
    /* QueryFlags.emitDistinctChangesOnly */
  );
  storeCleanupWithContext(tView, lView, queryList, queryList.destroy);
  const lQueries = (lView[QUERIES] ??= new LQueries_()).queries;
  return lQueries.push(new LQuery_(queryList)) - 1;
}
function createViewQuery(predicate, flags, read) {
  ngDevMode && assertNumber(flags, "Expecting flags");
  const tView = getTView();
  if (tView.firstCreatePass) {
    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);
    if ((flags & 2) === 2) {
      tView.staticViewQueries = true;
    }
  }
  return createLQuery(tView, getLView(), flags);
}
function createContentQuery(directiveIndex, predicate, flags, read) {
  ngDevMode && assertNumber(flags, "Expecting flags");
  const tView = getTView();
  if (tView.firstCreatePass) {
    const tNode = getCurrentTNode();
    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);
    saveContentQueryAndDirectiveIndex(tView, directiveIndex);
    if ((flags & 2) === 2) {
      tView.staticContentQueries = true;
    }
  }
  return createLQuery(tView, getLView(), flags);
}
function splitQueryMultiSelectors(locator) {
  return locator.split(",").map((s2) => s2.trim());
}
function createTQuery(tView, metadata, nodeIndex) {
  if (tView.queries === null)
    tView.queries = new TQueries_();
  tView.queries.track(new TQuery_(metadata, nodeIndex));
}
function saveContentQueryAndDirectiveIndex(tView, directiveIndex) {
  const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);
  const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;
  if (directiveIndex !== lastSavedDirectiveIndex) {
    tViewContentQueries.push(tView.queries.length - 1, directiveIndex);
  }
}
function getTQuery(tView, index) {
  ngDevMode && assertDefined(tView.queries, "TQueries must be defined to retrieve a TQuery");
  return tView.queries.getByIndex(index);
}
function getQueryResults(lView, queryIndex) {
  const tView = lView[TVIEW];
  const tQuery = getTQuery(tView, queryIndex);
  return tQuery.crossesNgTemplate ? collectQueryResults(tView, lView, queryIndex, []) : materializeViewResults(tView, lView, tQuery, queryIndex);
}
function createQuerySignalFn(firstOnly, required, opts) {
  let node;
  const signalFn = createComputed(() => {
    node._dirtyCounter();
    const value = refreshSignalQuery(node, firstOnly);
    if (required && value === void 0) {
      throw new RuntimeError(-951, ngDevMode && "Child query result is required but no value is available.");
    }
    return value;
  });
  node = signalFn[SIGNAL];
  node._dirtyCounter = signal(0);
  node._flatValue = void 0;
  if (ngDevMode) {
    signalFn.toString = () => `[Query Signal]`;
    node.debugName = opts?.debugName;
  }
  return signalFn;
}
function createSingleResultOptionalQuerySignalFn(opts) {
  return createQuerySignalFn(
    /* firstOnly */
    true,
    /* required */
    false,
    opts
  );
}
function createSingleResultRequiredQuerySignalFn(opts) {
  return createQuerySignalFn(
    /* firstOnly */
    true,
    /* required */
    true,
    opts
  );
}
function createMultiResultQuerySignalFn(opts) {
  return createQuerySignalFn(
    /* firstOnly */
    false,
    /* required */
    false,
    opts
  );
}
function bindQueryToSignal(target, queryIndex) {
  const node = target[SIGNAL];
  node._lView = getLView();
  node._queryIndex = queryIndex;
  node._queryList = loadQueryInternal(node._lView, queryIndex);
  node._queryList.onDirty(() => node._dirtyCounter.update((v) => v + 1));
}
function refreshSignalQuery(node, firstOnly) {
  const lView = node._lView;
  const queryIndex = node._queryIndex;
  if (lView === void 0 || queryIndex === void 0 || lView[FLAGS] & 4) {
    return firstOnly ? void 0 : EMPTY_ARRAY;
  }
  const queryList = loadQueryInternal(lView, queryIndex);
  const results = getQueryResults(lView, queryIndex);
  queryList.reset(results, unwrapElementRef);
  if (firstOnly) {
    return queryList.first;
  } else {
    const resultChanged = queryList._changesDetected;
    if (resultChanged || node._flatValue === void 0) {
      return node._flatValue = queryList.toArray();
    }
    return node._flatValue;
  }
}
function resolveComponentResources(resourceResolver) {
  const componentResolved = [];
  const urlMap = /* @__PURE__ */ new Map();
  function cachedResourceResolve(url) {
    let promise = urlMap.get(url);
    if (!promise) {
      const resp = resourceResolver(url);
      urlMap.set(url, promise = resp.then((res) => unwrapResponse(url, res)));
    }
    return promise;
  }
  componentResourceResolutionQueue.forEach((component, type) => {
    const promises = [];
    if (component.templateUrl) {
      promises.push(cachedResourceResolve(component.templateUrl).then((template) => {
        component.template = template;
      }));
    }
    const styles = typeof component.styles === "string" ? [component.styles] : component.styles || [];
    component.styles = styles;
    if (component.styleUrl && component.styleUrls?.length) {
      throw new Error("@Component cannot define both `styleUrl` and `styleUrls`. Use `styleUrl` if the component has one stylesheet, or `styleUrls` if it has multiple");
    } else if (component.styleUrls?.length) {
      const styleOffset = component.styles.length;
      const styleUrls = component.styleUrls;
      component.styleUrls.forEach((styleUrl, index) => {
        styles.push("");
        promises.push(cachedResourceResolve(styleUrl).then((style) => {
          styles[styleOffset + index] = style;
          styleUrls.splice(styleUrls.indexOf(styleUrl), 1);
          if (styleUrls.length == 0) {
            component.styleUrls = void 0;
          }
        }));
      });
    } else if (component.styleUrl) {
      promises.push(cachedResourceResolve(component.styleUrl).then((style) => {
        styles.push(style);
        component.styleUrl = void 0;
      }));
    }
    const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));
    componentResolved.push(fullyResolved);
  });
  clearResolutionOfComponentResourcesQueue();
  return Promise.all(componentResolved).then(() => void 0);
}
function maybeQueueResolutionOfComponentResources(type, metadata) {
  if (componentNeedsResolution(metadata)) {
    componentResourceResolutionQueue.set(type, metadata);
    componentDefPendingResolution.add(type);
  }
}
function componentNeedsResolution(component) {
  return !!(component.templateUrl && !component.hasOwnProperty("template") || component.styleUrls && component.styleUrls.length || component.styleUrl);
}
function clearResolutionOfComponentResourcesQueue() {
  const old = componentResourceResolutionQueue;
  componentResourceResolutionQueue = /* @__PURE__ */ new Map();
  return old;
}
function isComponentResourceResolutionQueueEmpty() {
  return componentResourceResolutionQueue.size === 0;
}
function unwrapResponse(url, response) {
  if (typeof response === "string") {
    return response;
  }
  if (response.status !== void 0 && response.status !== 200) {
    return Promise.reject(new RuntimeError(918, ngDevMode && `Could not load resource: ${url}. Response status: ${response.status}`));
  }
  return response.text();
}
function componentDefResolved(type) {
  componentDefPendingResolution.delete(type);
}
function assertSameOrNotExisting(id2, type, incoming) {
  if (type && type !== incoming && checkForDuplicateNgModules) {
    throw new Error(`Duplicate module registered for ${id2} - ${stringify(type)} vs ${stringify(type.name)}`);
  }
}
function registerNgModuleType(ngModuleType, id2) {
  const existing = modules.get(id2) || null;
  assertSameOrNotExisting(id2, existing, ngModuleType);
  modules.set(id2, ngModuleType);
}
function \u0275\u0275validateIframeAttribute(attrValue, tagName, attrName) {
  const lView = getLView();
  const tNode = getSelectedTNode();
  const element = getNativeByTNode(tNode, lView);
  if (tNode.type === 2 && tagName.toLowerCase() === "iframe") {
    const iframe = element;
    iframe.src = "";
    iframe.srcdoc = trustedHTMLFromString("");
    nativeRemoveNode(lView[RENDERER], iframe);
    const errorMessage = ngDevMode && `Angular has detected that the \`${attrName}\` was applied as a binding to an <iframe>${getTemplateLocationDetails(lView)}. For security reasons, the \`${attrName}\` can be set on an <iframe> as a static attribute only. 
To fix this, switch the \`${attrName}\` binding to a static attribute in a template or in host bindings section.`;
    throw new RuntimeError(-910, errorMessage);
  }
  return attrValue;
}
function performanceMarkFeature(feature) {
  if (markedFeatures.has(feature)) {
    return;
  }
  markedFeatures.add(feature);
  performance?.mark?.("mark_feature_usage", { detail: { feature } });
}
function createNgModule(ngModule, parentInjector) {
  return new NgModuleRef2(ngModule, parentInjector ?? null, []);
}
function createNgModuleRefWithProviders(moduleType, parentInjector, additionalProviders) {
  return new NgModuleRef2(moduleType, parentInjector, additionalProviders, false);
}
function createEnvironmentInjector(providers, parent, debugName = null) {
  const adapter = new EnvironmentNgModuleRefAdapter({
    providers,
    parent,
    debugName,
    runEnvironmentInitializers: true
  });
  return adapter.injector;
}
function \u0275\u0275defineComponent(componentDefinition) {
  return noSideEffects(() => {
    (typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode();
    const baseDef = getNgDirectiveDef(componentDefinition);
    const def = __spreadProps(__spreadValues({}, baseDef), {
      decls: componentDefinition.decls,
      vars: componentDefinition.vars,
      template: componentDefinition.template,
      consts: componentDefinition.consts || null,
      ngContentSelectors: componentDefinition.ngContentSelectors,
      onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
      directiveDefs: null,
      // assigned in noSideEffects
      pipeDefs: null,
      // assigned in noSideEffects
      dependencies: baseDef.standalone && componentDefinition.dependencies || null,
      getStandaloneInjector: baseDef.standalone ? (parentInjector) => {
        return parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(def);
      } : null,
      getExternalStyles: null,
      signals: componentDefinition.signals ?? false,
      data: componentDefinition.data || {},
      encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,
      styles: componentDefinition.styles || EMPTY_ARRAY,
      _: null,
      schemas: componentDefinition.schemas || null,
      tView: null,
      id: ""
    });
    if (baseDef.standalone) {
      performanceMarkFeature("NgStandalone");
    }
    initFeatures(def);
    const dependencies = componentDefinition.dependencies;
    def.directiveDefs = extractDefListOrFactory(dependencies, extractDirectiveDef);
    def.pipeDefs = extractDefListOrFactory(dependencies, getPipeDef);
    def.id = getComponentId(def);
    return def;
  });
}
function extractDirectiveDef(type) {
  return getComponentDef(type) || getDirectiveDef(type);
}
function \u0275\u0275defineNgModule(def) {
  return noSideEffects(() => {
    const res = {
      type: def.type,
      bootstrap: def.bootstrap || EMPTY_ARRAY,
      declarations: def.declarations || EMPTY_ARRAY,
      imports: def.imports || EMPTY_ARRAY,
      exports: def.exports || EMPTY_ARRAY,
      transitiveCompileScopes: null,
      schemas: def.schemas || null,
      id: def.id || null
    };
    return res;
  });
}
function parseAndConvertInputsForDefinition(obj, declaredInputs) {
  if (obj == null)
    return EMPTY_OBJ;
  const newLookup = {};
  for (const minifiedKey in obj) {
    if (obj.hasOwnProperty(minifiedKey)) {
      const value = obj[minifiedKey];
      let publicName;
      let declaredName;
      let inputFlags;
      let transform;
      if (Array.isArray(value)) {
        inputFlags = value[0];
        publicName = value[1];
        declaredName = value[2] ?? publicName;
        transform = value[3] || null;
      } else {
        publicName = value;
        declaredName = value;
        inputFlags = InputFlags.None;
        transform = null;
      }
      newLookup[publicName] = [minifiedKey, inputFlags, transform];
      declaredInputs[publicName] = declaredName;
    }
  }
  return newLookup;
}
function parseAndConvertOutputsForDefinition(obj) {
  if (obj == null)
    return EMPTY_OBJ;
  const newLookup = {};
  for (const minifiedKey in obj) {
    if (obj.hasOwnProperty(minifiedKey)) {
      newLookup[obj[minifiedKey]] = minifiedKey;
    }
  }
  return newLookup;
}
function \u0275\u0275defineDirective(directiveDefinition) {
  return noSideEffects(() => {
    const def = getNgDirectiveDef(directiveDefinition);
    initFeatures(def);
    return def;
  });
}
function \u0275\u0275definePipe(pipeDef) {
  return {
    type: pipeDef.type,
    name: pipeDef.name,
    factory: null,
    pure: pipeDef.pure !== false,
    standalone: pipeDef.standalone ?? true,
    onDestroy: pipeDef.type.prototype.ngOnDestroy || null
  };
}
function getNgDirectiveDef(directiveDefinition) {
  const declaredInputs = {};
  return {
    type: directiveDefinition.type,
    providersResolver: null,
    factory: null,
    hostBindings: directiveDefinition.hostBindings || null,
    hostVars: directiveDefinition.hostVars || 0,
    hostAttrs: directiveDefinition.hostAttrs || null,
    contentQueries: directiveDefinition.contentQueries || null,
    declaredInputs,
    inputConfig: directiveDefinition.inputs || EMPTY_OBJ,
    exportAs: directiveDefinition.exportAs || null,
    standalone: directiveDefinition.standalone ?? true,
    signals: directiveDefinition.signals === true,
    selectors: directiveDefinition.selectors || EMPTY_ARRAY,
    viewQuery: directiveDefinition.viewQuery || null,
    features: directiveDefinition.features || null,
    setInput: null,
    resolveHostDirectives: null,
    hostDirectives: null,
    inputs: parseAndConvertInputsForDefinition(directiveDefinition.inputs, declaredInputs),
    outputs: parseAndConvertOutputsForDefinition(directiveDefinition.outputs),
    debugInfo: null
  };
}
function initFeatures(definition) {
  definition.features?.forEach((fn) => fn(definition));
}
function extractDefListOrFactory(dependencies, defExtractor) {
  if (!dependencies) {
    return null;
  }
  return () => {
    const resolvedDependencies = typeof dependencies === "function" ? dependencies() : dependencies;
    const result = [];
    for (const dep of resolvedDependencies) {
      const definition = defExtractor(dep);
      if (definition !== null) {
        result.push(definition);
      }
    }
    return result;
  };
}
function getComponentId(componentDef) {
  let hash = 0;
  const componentDefConsts = typeof componentDef.consts === "function" ? "" : componentDef.consts;
  const hashSelectors = [
    componentDef.selectors,
    componentDef.ngContentSelectors,
    componentDef.hostVars,
    componentDef.hostAttrs,
    componentDefConsts,
    componentDef.vars,
    componentDef.decls,
    componentDef.encapsulation,
    componentDef.standalone,
    componentDef.signals,
    componentDef.exportAs,
    JSON.stringify(componentDef.inputs),
    JSON.stringify(componentDef.outputs),
    // We cannot use 'componentDef.type.name' as the name of the symbol will change and will not
    // match in the server and browser bundles.
    Object.getOwnPropertyNames(componentDef.type.prototype),
    !!componentDef.contentQueries,
    !!componentDef.viewQuery
  ];
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    for (const item of hashSelectors) {
      assertNotEqual(typeof item, "function", "Internal error: attempting to use a function in component id computation logic.");
    }
  }
  for (const char of hashSelectors.join("|")) {
    hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;
  }
  hash += 2147483647 + 1;
  const compId = "c" + hash;
  if ((typeof ngDevMode === "undefined" || ngDevMode) && true) {
    if (GENERATED_COMP_IDS.has(compId)) {
      const previousCompDefType = GENERATED_COMP_IDS.get(compId);
      if (previousCompDefType !== componentDef.type) {
        console.warn(formatRuntimeError(-912, `Component ID generation collision detected. Components '${previousCompDefType.name}' and '${componentDef.type.name}' with selector '${stringifyCSSSelectorList(componentDef.selectors)}' generated the same component ID. To fix this, you can change the selector of one of those components or add an extra host attribute to force a different ID.`));
      }
    } else {
      GENERATED_COMP_IDS.set(compId, componentDef.type);
    }
  }
  return compId;
}
function getSuperType(type) {
  return Object.getPrototypeOf(type.prototype).constructor;
}
function \u0275\u0275InheritDefinitionFeature(definition) {
  let superType = getSuperType(definition.type);
  let shouldInheritFields = true;
  const inheritanceChain = [definition];
  while (superType) {
    let superDef = void 0;
    if (isComponentDef(definition)) {
      superDef = superType.\u0275cmp || superType.\u0275dir;
    } else {
      if (superType.\u0275cmp) {
        throw new RuntimeError(903, ngDevMode && `Directives cannot inherit Components. Directive ${stringifyForError(definition.type)} is attempting to extend component ${stringifyForError(superType)}`);
      }
      superDef = superType.\u0275dir;
    }
    if (superDef) {
      if (shouldInheritFields) {
        inheritanceChain.push(superDef);
        const writeableDef = definition;
        writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);
        writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);
        writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);
        const superHostBindings = superDef.hostBindings;
        superHostBindings && inheritHostBindings(definition, superHostBindings);
        const superViewQuery = superDef.viewQuery;
        const superContentQueries = superDef.contentQueries;
        superViewQuery && inheritViewQuery(definition, superViewQuery);
        superContentQueries && inheritContentQueries(definition, superContentQueries);
        mergeInputsWithTransforms(definition, superDef);
        fillProperties(definition.outputs, superDef.outputs);
        if (isComponentDef(superDef) && superDef.data.animation) {
          const defData = definition.data;
          defData.animation = (defData.animation || []).concat(superDef.data.animation);
        }
      }
      const features = superDef.features;
      if (features) {
        for (let i2 = 0; i2 < features.length; i2++) {
          const feature = features[i2];
          if (feature && feature.ngInherit) {
            feature(definition);
          }
          if (feature === \u0275\u0275InheritDefinitionFeature) {
            shouldInheritFields = false;
          }
        }
      }
    }
    superType = Object.getPrototypeOf(superType);
  }
  mergeHostAttrsAcrossInheritance(inheritanceChain);
}
function mergeInputsWithTransforms(target, source) {
  for (const key in source.inputs) {
    if (!source.inputs.hasOwnProperty(key)) {
      continue;
    }
    if (target.inputs.hasOwnProperty(key)) {
      continue;
    }
    const value = source.inputs[key];
    if (value !== void 0) {
      target.inputs[key] = value;
      target.declaredInputs[key] = source.declaredInputs[key];
    }
  }
}
function mergeHostAttrsAcrossInheritance(inheritanceChain) {
  let hostVars = 0;
  let hostAttrs = null;
  for (let i2 = inheritanceChain.length - 1; i2 >= 0; i2--) {
    const def = inheritanceChain[i2];
    def.hostVars = hostVars += def.hostVars;
    def.hostAttrs = mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));
  }
}
function maybeUnwrapEmpty(value) {
  if (value === EMPTY_OBJ) {
    return {};
  } else if (value === EMPTY_ARRAY) {
    return [];
  } else {
    return value;
  }
}
function inheritViewQuery(definition, superViewQuery) {
  const prevViewQuery = definition.viewQuery;
  if (prevViewQuery) {
    definition.viewQuery = (rf2, ctx) => {
      superViewQuery(rf2, ctx);
      prevViewQuery(rf2, ctx);
    };
  } else {
    definition.viewQuery = superViewQuery;
  }
}
function inheritContentQueries(definition, superContentQueries) {
  const prevContentQueries = definition.contentQueries;
  if (prevContentQueries) {
    definition.contentQueries = (rf2, ctx, directiveIndex) => {
      superContentQueries(rf2, ctx, directiveIndex);
      prevContentQueries(rf2, ctx, directiveIndex);
    };
  } else {
    definition.contentQueries = superContentQueries;
  }
}
function inheritHostBindings(definition, superHostBindings) {
  const prevHostBindings = definition.hostBindings;
  if (prevHostBindings) {
    definition.hostBindings = (rf2, ctx) => {
      superHostBindings(rf2, ctx);
      prevHostBindings(rf2, ctx);
    };
  } else {
    definition.hostBindings = superHostBindings;
  }
}
function \u0275\u0275CopyDefinitionFeature(definition) {
  let superType = getSuperType(definition.type);
  let superDef = void 0;
  if (isComponentDef(definition)) {
    superDef = superType.\u0275cmp;
  } else {
    superDef = superType.\u0275dir;
  }
  const defAny = definition;
  for (const field of COPY_DIRECTIVE_FIELDS) {
    defAny[field] = superDef[field];
  }
  if (isComponentDef(superDef)) {
    for (const field of COPY_COMPONENT_FIELDS) {
      defAny[field] = superDef[field];
    }
  }
}
function \u0275\u0275HostDirectivesFeature(rawHostDirectives) {
  const feature = (definition) => {
    const isEager = Array.isArray(rawHostDirectives);
    if (definition.hostDirectives === null) {
      definition.resolveHostDirectives = resolveHostDirectives;
      definition.hostDirectives = isEager ? rawHostDirectives.map(createHostDirectiveDef) : [rawHostDirectives];
    } else if (isEager) {
      definition.hostDirectives.unshift(...rawHostDirectives.map(createHostDirectiveDef));
    } else {
      definition.hostDirectives.unshift(rawHostDirectives);
    }
  };
  feature.ngInherit = true;
  return feature;
}
function resolveHostDirectives(matches) {
  const allDirectiveDefs = [];
  let hasComponent = false;
  let hostDirectiveDefs = null;
  let hostDirectiveRanges = null;
  for (let i2 = 0; i2 < matches.length; i2++) {
    const def = matches[i2];
    if (def.hostDirectives !== null) {
      const start = allDirectiveDefs.length;
      hostDirectiveDefs ??= /* @__PURE__ */ new Map();
      hostDirectiveRanges ??= /* @__PURE__ */ new Map();
      findHostDirectiveDefs(def, allDirectiveDefs, hostDirectiveDefs);
      hostDirectiveRanges.set(def, [start, allDirectiveDefs.length - 1]);
    }
    if (i2 === 0 && isComponentDef(def)) {
      hasComponent = true;
      allDirectiveDefs.push(def);
    }
  }
  for (let i2 = hasComponent ? 1 : 0; i2 < matches.length; i2++) {
    allDirectiveDefs.push(matches[i2]);
  }
  return [allDirectiveDefs, hostDirectiveDefs, hostDirectiveRanges];
}
function findHostDirectiveDefs(currentDef, matchedDefs, hostDirectiveDefs) {
  if (currentDef.hostDirectives !== null) {
    for (const configOrFn of currentDef.hostDirectives) {
      if (typeof configOrFn === "function") {
        const resolved2 = configOrFn();
        for (const config2 of resolved2) {
          trackHostDirectiveDef(createHostDirectiveDef(config2), matchedDefs, hostDirectiveDefs);
        }
      } else {
        trackHostDirectiveDef(configOrFn, matchedDefs, hostDirectiveDefs);
      }
    }
  }
}
function trackHostDirectiveDef(def, matchedDefs, hostDirectiveDefs) {
  const hostDirectiveDef = getDirectiveDef(def.directive);
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    validateHostDirective(def, hostDirectiveDef);
  }
  patchDeclaredInputs(hostDirectiveDef.declaredInputs, def.inputs);
  findHostDirectiveDefs(hostDirectiveDef, matchedDefs, hostDirectiveDefs);
  hostDirectiveDefs.set(hostDirectiveDef, def);
  matchedDefs.push(hostDirectiveDef);
}
function createHostDirectiveDef(config2) {
  return typeof config2 === "function" ? { directive: resolveForwardRef(config2), inputs: EMPTY_OBJ, outputs: EMPTY_OBJ } : {
    directive: resolveForwardRef(config2.directive),
    inputs: bindingArrayToMap(config2.inputs),
    outputs: bindingArrayToMap(config2.outputs)
  };
}
function bindingArrayToMap(bindings) {
  if (bindings === void 0 || bindings.length === 0) {
    return EMPTY_OBJ;
  }
  const result = {};
  for (let i2 = 0; i2 < bindings.length; i2 += 2) {
    result[bindings[i2]] = bindings[i2 + 1];
  }
  return result;
}
function patchDeclaredInputs(declaredInputs, exposedInputs) {
  for (const publicName in exposedInputs) {
    if (exposedInputs.hasOwnProperty(publicName)) {
      const remappedPublicName = exposedInputs[publicName];
      const privateName = declaredInputs[publicName];
      if ((typeof ngDevMode === "undefined" || ngDevMode) && declaredInputs.hasOwnProperty(remappedPublicName)) {
        assertEqual(declaredInputs[remappedPublicName], declaredInputs[publicName], `Conflicting host directive input alias ${publicName}.`);
      }
      declaredInputs[remappedPublicName] = privateName;
    }
  }
}
function validateHostDirective(hostDirectiveConfig, directiveDef) {
  const type = hostDirectiveConfig.directive;
  if (directiveDef === null) {
    if (getComponentDef(type) !== null) {
      throw new RuntimeError(310, `Host directive ${type.name} cannot be a component.`);
    }
    throw new RuntimeError(307, `Could not resolve metadata for host directive ${type.name}. Make sure that the ${type.name} class is annotated with an @Directive decorator.`);
  }
  if (!directiveDef.standalone) {
    throw new RuntimeError(308, `Host directive ${directiveDef.type.name} must be standalone.`);
  }
  validateMappings("input", directiveDef, hostDirectiveConfig.inputs);
  validateMappings("output", directiveDef, hostDirectiveConfig.outputs);
}
function validateMappings(bindingType, def, hostDirectiveBindings) {
  const className = def.type.name;
  const bindings = bindingType === "input" ? def.inputs : def.outputs;
  for (const publicName in hostDirectiveBindings) {
    if (hostDirectiveBindings.hasOwnProperty(publicName)) {
      if (!bindings.hasOwnProperty(publicName)) {
        throw new RuntimeError(311, `Directive ${className} does not have an ${bindingType} with a public name of ${publicName}.`);
      }
      const remappedPublicName = hostDirectiveBindings[publicName];
      if (bindings.hasOwnProperty(remappedPublicName) && remappedPublicName !== publicName) {
        throw new RuntimeError(312, `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${remappedPublicName}, because it already has a different ${bindingType} with the same public name.`);
      }
    }
  }
}
function templateCreate(tNode, declarationLView, declarationTView, index, templateFn, decls, vars, flags) {
  if (declarationTView.firstCreatePass) {
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
    const embeddedTView = tNode.tView = createTView(
      2,
      tNode,
      templateFn,
      decls,
      vars,
      declarationTView.directiveRegistry,
      declarationTView.pipeRegistry,
      null,
      declarationTView.schemas,
      declarationTView.consts,
      null
      /* ssrId */
    );
    if (declarationTView.queries !== null) {
      declarationTView.queries.template(declarationTView, tNode);
      embeddedTView.queries = declarationTView.queries.embeddedTView(tNode);
    }
  }
  if (flags) {
    tNode.flags |= flags;
  }
  setCurrentTNode(tNode, false);
  const comment = _locateOrCreateContainerAnchor(declarationTView, declarationLView, tNode, index);
  if (wasLastNodeCreated()) {
    appendChild(declarationTView, declarationLView, comment, tNode);
  }
  attachPatchData(comment, declarationLView);
  const lContainer = createLContainer(comment, declarationLView, comment, tNode);
  declarationLView[index + HEADER_OFFSET] = lContainer;
  addToEndOfViewTree(declarationLView, lContainer);
  populateDehydratedViewsInLContainer(lContainer, tNode, declarationLView);
}
function declareDirectiveHostTemplate(declarationLView, declarationTView, index, templateFn, decls, vars, tagName, attrs, flags, localRefsIndex, localRefExtractor) {
  const adjustedIndex = index + HEADER_OFFSET;
  let tNode;
  if (declarationTView.firstCreatePass) {
    tNode = getOrCreateTNode(declarationTView, adjustedIndex, 4, tagName || null, attrs || null);
    if (getBindingsEnabled()) {
      resolveDirectives(declarationTView, declarationLView, tNode, getConstant(declarationTView.consts, localRefsIndex), findDirectiveDefMatches);
    }
    registerPostOrderHooks(declarationTView, tNode);
  } else {
    tNode = declarationTView.data[adjustedIndex];
  }
  templateCreate(tNode, declarationLView, declarationTView, index, templateFn, decls, vars, flags);
  if (isDirectiveHost(tNode)) {
    createDirectivesInstances(declarationTView, declarationLView, tNode);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(declarationLView, tNode, localRefExtractor);
  }
  return tNode;
}
function declareNoDirectiveHostTemplate(declarationLView, declarationTView, index, templateFn, decls, vars, tagName, attrs, flags, localRefsIndex, localRefExtractor) {
  const adjustedIndex = index + HEADER_OFFSET;
  let tNode;
  if (declarationTView.firstCreatePass) {
    tNode = getOrCreateTNode(declarationTView, adjustedIndex, 4, tagName || null, attrs || null);
    if (localRefsIndex != null) {
      const refs = getConstant(declarationTView.consts, localRefsIndex);
      tNode.localNames = [];
      for (let i2 = 0; i2 < refs.length; i2 += 2) {
        tNode.localNames.push(refs[i2], -1);
      }
    }
  } else {
    tNode = declarationTView.data[adjustedIndex];
  }
  templateCreate(tNode, declarationLView, declarationTView, index, templateFn, decls, vars, flags);
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(declarationLView, tNode, localRefExtractor);
  }
  return tNode;
}
function \u0275\u0275template(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  const lView = getLView();
  const tView = getTView();
  const attrs = getConstant(tView.consts, attrsIndex);
  declareDirectiveHostTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, void 0, localRefsIndex, localRefExtractor);
  return \u0275\u0275template;
}
function \u0275\u0275domTemplate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  const lView = getLView();
  const tView = getTView();
  const attrs = getConstant(tView.consts, attrsIndex);
  declareNoDirectiveHostTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, void 0, localRefsIndex, localRefExtractor);
  return \u0275\u0275domTemplate;
}
function createContainerAnchorImpl(tView, lView, tNode, index) {
  lastNodeWasCreated(true);
  return lView[RENDERER].createComment(ngDevMode ? "container" : "");
}
function storeTriggerCleanupFn(type, lDetails, cleanupFn) {
  const key = getCleanupFnKeyByType(type);
  if (lDetails[key] === null) {
    lDetails[key] = [];
  }
  lDetails[key].push(cleanupFn);
}
function invokeTriggerCleanupFns(type, lDetails) {
  const key = getCleanupFnKeyByType(type);
  const cleanupFns = lDetails[key];
  if (cleanupFns !== null) {
    for (const cleanupFn of cleanupFns) {
      cleanupFn();
    }
    lDetails[key] = null;
  }
}
function invokeAllTriggerCleanupFns(lDetails) {
  invokeTriggerCleanupFns(1, lDetails);
  invokeTriggerCleanupFns(0, lDetails);
  invokeTriggerCleanupFns(2, lDetails);
}
function getCleanupFnKeyByType(type) {
  let key = TRIGGER_CLEANUP_FNS;
  if (type === 1) {
    key = PREFETCH_TRIGGER_CLEANUP_FNS;
  } else if (type === 2) {
    key = HYDRATE_TRIGGER_CLEANUP_FNS;
  }
  return key;
}
function scheduleCallbackWithRafRace(callback) {
  let timeoutId;
  let animationFrameId;
  function cleanup() {
    callback = noop2;
    try {
      if (animationFrameId !== void 0 && typeof cancelAnimationFrame === "function") {
        cancelAnimationFrame(animationFrameId);
      }
      if (timeoutId !== void 0) {
        clearTimeout(timeoutId);
      }
    } catch {
    }
  }
  timeoutId = setTimeout(() => {
    callback();
    cleanup();
  });
  if (typeof requestAnimationFrame === "function") {
    animationFrameId = requestAnimationFrame(() => {
      callback();
      cleanup();
    });
  }
  return () => cleanup();
}
function scheduleCallbackWithMicrotask(callback) {
  queueMicrotask(() => callback());
  return () => {
    callback = noop2;
  };
}
function checkStable(zone) {
  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
    try {
      zone._nesting++;
      zone.onMicrotaskEmpty.emit(null);
    } finally {
      zone._nesting--;
      if (!zone.hasPendingMicrotasks) {
        try {
          zone.runOutsideAngular(() => zone.onStable.emit(null));
        } finally {
          zone.isStable = true;
        }
      }
    }
  }
}
function delayChangeDetectionForEvents(zone) {
  if (zone.isCheckStableRunning || zone.callbackScheduled) {
    return;
  }
  zone.callbackScheduled = true;
  function scheduleCheckStable() {
    scheduleCallbackWithRafRace(() => {
      zone.callbackScheduled = false;
      updateMicroTaskStatus(zone);
      zone.isCheckStableRunning = true;
      checkStable(zone);
      zone.isCheckStableRunning = false;
    });
  }
  if (zone.scheduleInRootZone) {
    Zone.root.run(() => {
      scheduleCheckStable();
    });
  } else {
    zone._outer.run(() => {
      scheduleCheckStable();
    });
  }
  updateMicroTaskStatus(zone);
}
function forkInnerZoneWithAngularBehavior(zone) {
  const delayChangeDetectionForEventsDelegate = () => {
    delayChangeDetectionForEvents(zone);
  };
  const instanceId = ngZoneInstanceId++;
  zone._inner = zone._inner.fork({
    name: "angular",
    properties: {
      [isAngularZoneProperty]: true,
      [angularZoneInstanceIdProperty]: instanceId,
      [angularZoneInstanceIdProperty + instanceId]: true
    },
    onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
      if (shouldBeIgnoredByZone(applyArgs)) {
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      }
      try {
        onEnter(zone);
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      } finally {
        if (zone.shouldCoalesceEventChangeDetection && task.type === "eventTask" || zone.shouldCoalesceRunChangeDetection) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
      try {
        onEnter(zone);
        return delegate.invoke(target, callback, applyThis, applyArgs, source);
      } finally {
        if (zone.shouldCoalesceRunChangeDetection && // Do not delay change detection when the task is the scheduler's tick.
        // We need to synchronously trigger the stability logic so that the
        // zone-based scheduler can prevent a duplicate ApplicationRef.tick
        // by first checking if the scheduler tick is running. This does seem a bit roundabout,
        // but we _do_ still want to trigger all the correct events when we exit the zone.run
        // (`onMicrotaskEmpty` and `onStable` _should_ emit; developers can have code which
        // relies on these events happening after change detection runs).
        // Note: `zone.callbackScheduled` is already in delayChangeDetectionForEventsDelegate
        // but is added here as well to prevent reads of applyArgs when not necessary
        !zone.callbackScheduled && !isSchedulerTick(applyArgs)) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onHasTask: (delegate, current, target, hasTaskState) => {
      delegate.hasTask(target, hasTaskState);
      if (current === target) {
        if (hasTaskState.change == "microTask") {
          zone._hasPendingMicrotasks = hasTaskState.microTask;
          updateMicroTaskStatus(zone);
          checkStable(zone);
        } else if (hasTaskState.change == "macroTask") {
          zone.hasPendingMacrotasks = hasTaskState.macroTask;
        }
      }
    },
    onHandleError: (delegate, current, target, error) => {
      delegate.handleError(target, error);
      zone.runOutsideAngular(() => zone.onError.emit(error));
      return false;
    }
  });
}
function updateMicroTaskStatus(zone) {
  if (zone._hasPendingMicrotasks || (zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) && zone.callbackScheduled === true) {
    zone.hasPendingMicrotasks = true;
  } else {
    zone.hasPendingMicrotasks = false;
  }
}
function onEnter(zone) {
  zone._nesting++;
  if (zone.isStable) {
    zone.isStable = false;
    zone.onUnstable.emit(null);
  }
}
function onLeave(zone) {
  zone._nesting--;
  checkStable(zone);
}
function shouldBeIgnoredByZone(applyArgs) {
  return hasApplyArgsData(applyArgs, "__ignore_ng_zone__");
}
function isSchedulerTick(applyArgs) {
  return hasApplyArgsData(applyArgs, "__scheduler_tick__");
}
function hasApplyArgsData(applyArgs, key) {
  if (!Array.isArray(applyArgs)) {
    return false;
  }
  if (applyArgs.length !== 1) {
    return false;
  }
  return applyArgs[0]?.data?.[key] === true;
}
function getNgZone(ngZoneToUse = "zone.js", options) {
  if (ngZoneToUse === "noop") {
    return new NoopNgZone();
  }
  if (ngZoneToUse === "zone.js") {
    return new NgZone(options);
  }
  return ngZoneToUse;
}
function afterEveryRender(callbackOrSpec, options) {
  ngDevMode && assertNotInReactiveContext(afterEveryRender, "Call `afterEveryRender` outside of a reactive context. For example, schedule the render callback inside the component constructor`.");
  if (ngDevMode && !options?.injector) {
    assertInInjectionContext(afterEveryRender);
  }
  const injector = options?.injector ?? inject2(Injector);
  if (false) {
    return NOOP_AFTER_RENDER_REF;
  }
  performanceMarkFeature("NgAfterRender");
  return afterEveryRenderImpl(
    callbackOrSpec,
    injector,
    options,
    /* once */
    false
  );
}
function afterNextRender(callbackOrSpec, options) {
  if (ngDevMode && !options?.injector) {
    assertInInjectionContext(afterNextRender);
  }
  const injector = options?.injector ?? inject2(Injector);
  if (false) {
    return NOOP_AFTER_RENDER_REF;
  }
  performanceMarkFeature("NgAfterNextRender");
  return afterEveryRenderImpl(
    callbackOrSpec,
    injector,
    options,
    /* once */
    true
  );
}
function getHooks(callbackOrSpec) {
  if (callbackOrSpec instanceof Function) {
    return [
      void 0,
      void 0,
      /* MixedReadWrite */
      callbackOrSpec,
      void 0
    ];
  } else {
    return [
      callbackOrSpec.earlyRead,
      callbackOrSpec.write,
      callbackOrSpec.mixedReadWrite,
      callbackOrSpec.read
    ];
  }
}
function afterEveryRenderImpl(callbackOrSpec, injector, options, once) {
  const manager = injector.get(AfterRenderManager);
  manager.impl ??= injector.get(AfterRenderImpl);
  const tracing = injector.get(TracingService, null, { optional: true });
  const destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;
  const viewContext = injector.get(ViewContext, null, { optional: true });
  const sequence = new AfterRenderSequence(manager.impl, getHooks(callbackOrSpec), viewContext?.view, once, destroyRef, tracing?.snapshot(null));
  manager.impl.register(sequence);
  return sequence;
}
function getDeferBlockDataIndex(deferBlockIndex) {
  return deferBlockIndex + 1;
}
function getLDeferBlockDetails(lView, tNode) {
  const tView = lView[TVIEW];
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  return lView[slotIndex];
}
function setLDeferBlockDetails(lView, deferBlockIndex, lDetails) {
  const tView = lView[TVIEW];
  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  lView[slotIndex] = lDetails;
}
function getTDeferBlockDetails(tView, tNode) {
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  return tView.data[slotIndex];
}
function setTDeferBlockDetails(tView, deferBlockIndex, deferBlockConfig) {
  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  tView.data[slotIndex] = deferBlockConfig;
}
function getTemplateIndexForState(newState, hostLView, tNode) {
  const tView = hostLView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  switch (newState) {
    case DeferBlockState.Complete:
      return tDetails.primaryTmplIndex;
    case DeferBlockState.Loading:
      return tDetails.loadingTmplIndex;
    case DeferBlockState.Error:
      return tDetails.errorTmplIndex;
    case DeferBlockState.Placeholder:
      return tDetails.placeholderTmplIndex;
    default:
      ngDevMode && throwError2(`Unexpected defer block state: ${newState}`);
      return null;
  }
}
function getMinimumDurationForState(tDetails, currentState) {
  if (currentState === DeferBlockState.Placeholder) {
    return tDetails.placeholderBlockConfig?.[MINIMUM_SLOT] ?? null;
  } else if (currentState === DeferBlockState.Loading) {
    return tDetails.loadingBlockConfig?.[MINIMUM_SLOT] ?? null;
  }
  return null;
}
function getLoadingBlockAfter(tDetails) {
  return tDetails.loadingBlockConfig?.[LOADING_AFTER_SLOT] ?? null;
}
function addDepsToRegistry(currentDeps, newDeps) {
  if (!currentDeps || currentDeps.length === 0) {
    return newDeps;
  }
  const currentDepSet = new Set(currentDeps);
  for (const dep of newDeps) {
    currentDepSet.add(dep);
  }
  return currentDeps.length === currentDepSet.size ? currentDeps : Array.from(currentDepSet);
}
function getPrimaryBlockTNode(tView, tDetails) {
  const adjustedIndex = tDetails.primaryTmplIndex + HEADER_OFFSET;
  return getTNode(tView, adjustedIndex);
}
function assertDeferredDependenciesLoaded(tDetails) {
  assertEqual(tDetails.loadingState, DeferDependenciesLoadingState.COMPLETE, "Expecting all deferred dependencies to be loaded.");
}
function isTDeferBlockDetails(value) {
  return value !== null && typeof value === "object" && typeof value.primaryTmplIndex === "number";
}
function trackTriggerForDebugging(tView, tNode, textRepresentation) {
  const tDetails = getTDeferBlockDetails(tView, tNode);
  tDetails.debug ??= {};
  tDetails.debug.triggers ??= /* @__PURE__ */ new Set();
  tDetails.debug.triggers.add(textRepresentation);
}
function onViewportWrapper(trigger, callback, injector) {
  const ngZone = injector.get(NgZone);
  return onViewport(trigger, () => ngZone.run(callback), () => ngZone.runOutsideAngular(() => createIntersectionObserver()));
}
function getTriggerLView(deferredHostLView, deferredTNode, walkUpTimes) {
  if (walkUpTimes == null) {
    return deferredHostLView;
  }
  if (walkUpTimes >= 0) {
    return walkUpViews(walkUpTimes, deferredHostLView);
  }
  const deferredContainer = deferredHostLView[deferredTNode.index];
  ngDevMode && assertLContainer(deferredContainer);
  const triggerLView = deferredContainer[CONTAINER_HEADER_OFFSET] ?? null;
  if (ngDevMode && triggerLView !== null) {
    const lDetails = getLDeferBlockDetails(deferredHostLView, deferredTNode);
    const renderedState = lDetails[DEFER_BLOCK_STATE];
    assertEqual(renderedState, DeferBlockState.Placeholder, "Expected a placeholder to be rendered in this defer block.");
    assertLView(triggerLView);
  }
  return triggerLView;
}
function getTriggerElement(triggerLView, triggerIndex) {
  const element = getNativeByIndex(HEADER_OFFSET + triggerIndex, triggerLView);
  ngDevMode && assertElement(element);
  return element;
}
function registerDomTrigger(initialLView, tNode, triggerIndex, walkUpTimes, registerFn, callback, type) {
  const injector = initialLView[INJECTOR];
  const zone = injector.get(NgZone);
  let poll;
  function pollDomTrigger() {
    if (isDestroyed(initialLView)) {
      poll.destroy();
      return;
    }
    const lDetails = getLDeferBlockDetails(initialLView, tNode);
    const renderedState = lDetails[DEFER_BLOCK_STATE];
    if (renderedState !== DeferBlockInternalState.Initial && renderedState !== DeferBlockState.Placeholder) {
      poll.destroy();
      return;
    }
    const triggerLView = getTriggerLView(initialLView, tNode, walkUpTimes);
    if (!triggerLView) {
      return;
    }
    poll.destroy();
    if (isDestroyed(triggerLView)) {
      return;
    }
    const element = getTriggerElement(triggerLView, triggerIndex);
    const cleanup = registerFn(element, () => {
      zone.run(() => {
        if (initialLView !== triggerLView) {
          removeLViewOnDestroy(triggerLView, cleanup);
        }
        callback();
      });
    }, injector);
    if (initialLView !== triggerLView) {
      storeLViewOnDestroy(triggerLView, cleanup);
    }
    storeTriggerCleanupFn(type, lDetails, cleanup);
  }
  poll = afterEveryRender({ read: pollDomTrigger }, { injector });
}
function onIdle(callback, injector) {
  const scheduler = injector.get(IdleScheduler);
  const cleanupFn = () => scheduler.remove(callback);
  scheduler.add(callback);
  return cleanupFn;
}
function onTimer(delay) {
  return (callback, injector) => scheduleTimerTrigger(delay, callback, injector);
}
function scheduleTimerTrigger(delay, callback, injector) {
  const scheduler = injector.get(TimerScheduler);
  const ngZone = injector.get(NgZone);
  const cleanupFn = () => scheduler.remove(callback);
  scheduler.add(delay, callback, ngZone);
  return cleanupFn;
}
function getOrCreateEnvironmentInjector(parentInjector, tDetails, providers) {
  return parentInjector.get(CachedInjectorService).getOrCreateInjector(tDetails, parentInjector, providers, ngDevMode ? "DeferBlock Injector" : "");
}
function createDeferBlockInjector(parentInjector, tDetails, providers) {
  if (parentInjector instanceof ChainedInjector) {
    const origInjector = parentInjector.injector;
    const parentEnvInjector2 = parentInjector.parentInjector;
    const envInjector = getOrCreateEnvironmentInjector(parentEnvInjector2, tDetails, providers);
    return new ChainedInjector(origInjector, envInjector);
  }
  const parentEnvInjector = parentInjector.get(EnvironmentInjector);
  if (parentEnvInjector !== parentInjector) {
    const envInjector = getOrCreateEnvironmentInjector(parentEnvInjector, tDetails, providers);
    return new ChainedInjector(parentInjector, envInjector);
  }
  return getOrCreateEnvironmentInjector(parentInjector, tDetails, providers);
}
function renderDeferBlockState(newState, tNode, lContainer, skipTimerScheduling = false) {
  const hostLView = lContainer[PARENT];
  const hostTView = hostLView[TVIEW];
  if (isDestroyed(hostLView))
    return;
  ngDevMode && assertTNodeForLView(tNode, hostLView);
  const lDetails = getLDeferBlockDetails(hostLView, tNode);
  ngDevMode && assertDefined(lDetails, "Expected a defer block state defined");
  const currentState = lDetails[DEFER_BLOCK_STATE];
  const ssrState = lDetails[SSR_BLOCK_STATE];
  if (ssrState !== null && newState < ssrState) {
    return;
  }
  if (isValidStateChange(currentState, newState) && isValidStateChange(lDetails[NEXT_DEFER_BLOCK_STATE] ?? -1, newState)) {
    const tDetails = getTDeferBlockDetails(hostTView, tNode);
    const needsScheduling = !skipTimerScheduling && true && (getLoadingBlockAfter(tDetails) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Loading) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Placeholder));
    if (ngDevMode && needsScheduling) {
      assertDefined(applyDeferBlockStateWithSchedulingImpl, "Expected scheduling function to be defined");
    }
    const applyStateFn = needsScheduling ? applyDeferBlockStateWithSchedulingImpl : applyDeferBlockState;
    try {
      applyStateFn(newState, lDetails, lContainer, tNode, hostLView);
    } catch (error) {
      handleUncaughtError(hostLView, error);
    }
  }
}
function findMatchingDehydratedViewForDeferBlock(lContainer, lDetails) {
  const dehydratedViewIx = lContainer[DEHYDRATED_VIEWS]?.findIndex((view) => view.data[DEFER_BLOCK_STATE$1] === lDetails[DEFER_BLOCK_STATE]) ?? -1;
  const dehydratedView = dehydratedViewIx > -1 ? lContainer[DEHYDRATED_VIEWS][dehydratedViewIx] : null;
  return { dehydratedView, dehydratedViewIx };
}
function applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView) {
  profiler(
    20
    /* ProfilerEvent.DeferBlockStateStart */
  );
  const stateTmplIndex = getTemplateIndexForState(newState, hostLView, tNode);
  if (stateTmplIndex !== null) {
    lDetails[DEFER_BLOCK_STATE] = newState;
    const hostTView = hostLView[TVIEW];
    const adjustedIndex = stateTmplIndex + HEADER_OFFSET;
    const activeBlockTNode = getTNode(hostTView, adjustedIndex);
    const viewIndex = 0;
    removeLViewFromLContainer(lContainer, viewIndex);
    let injector;
    if (newState === DeferBlockState.Complete) {
      const tDetails = getTDeferBlockDetails(hostTView, tNode);
      const providers = tDetails.providers;
      if (providers && providers.length > 0) {
        injector = createDeferBlockInjector(hostLView[INJECTOR], tDetails, providers);
      }
    }
    const { dehydratedView, dehydratedViewIx } = findMatchingDehydratedViewForDeferBlock(lContainer, lDetails);
    const embeddedLView = createAndRenderEmbeddedLView(hostLView, activeBlockTNode, null, {
      injector,
      dehydratedView
    });
    addLViewToLContainer(lContainer, embeddedLView, viewIndex, shouldAddViewToDom(activeBlockTNode, dehydratedView));
    markViewDirty(
      embeddedLView,
      2
      /* NotificationSource.DeferBlockStateUpdate */
    );
    if (dehydratedViewIx > -1) {
      lContainer[DEHYDRATED_VIEWS]?.splice(dehydratedViewIx, 1);
    }
    if ((newState === DeferBlockState.Complete || newState === DeferBlockState.Error) && Array.isArray(lDetails[ON_COMPLETE_FNS])) {
      for (const callback of lDetails[ON_COMPLETE_FNS]) {
        callback();
      }
      lDetails[ON_COMPLETE_FNS] = null;
    }
  }
  profiler(
    21
    /* ProfilerEvent.DeferBlockStateEnd */
  );
}
function applyDeferBlockStateWithScheduling(newState, lDetails, lContainer, tNode, hostLView) {
  const now = Date.now();
  const hostTView = hostLView[TVIEW];
  const tDetails = getTDeferBlockDetails(hostTView, tNode);
  if (lDetails[STATE_IS_FROZEN_UNTIL] === null || lDetails[STATE_IS_FROZEN_UNTIL] <= now) {
    lDetails[STATE_IS_FROZEN_UNTIL] = null;
    const loadingAfter = getLoadingBlockAfter(tDetails);
    const inLoadingAfterPhase = lDetails[LOADING_AFTER_CLEANUP_FN] !== null;
    if (newState === DeferBlockState.Loading && loadingAfter !== null && !inLoadingAfterPhase) {
      lDetails[NEXT_DEFER_BLOCK_STATE] = newState;
      const cleanupFn = scheduleDeferBlockUpdate(loadingAfter, lDetails, tNode, lContainer, hostLView);
      lDetails[LOADING_AFTER_CLEANUP_FN] = cleanupFn;
    } else {
      if (newState > DeferBlockState.Loading && inLoadingAfterPhase) {
        lDetails[LOADING_AFTER_CLEANUP_FN]();
        lDetails[LOADING_AFTER_CLEANUP_FN] = null;
        lDetails[NEXT_DEFER_BLOCK_STATE] = null;
      }
      applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView);
      const duration = getMinimumDurationForState(tDetails, newState);
      if (duration !== null) {
        lDetails[STATE_IS_FROZEN_UNTIL] = now + duration;
        scheduleDeferBlockUpdate(duration, lDetails, tNode, lContainer, hostLView);
      }
    }
  } else {
    lDetails[NEXT_DEFER_BLOCK_STATE] = newState;
  }
}
function scheduleDeferBlockUpdate(timeout, lDetails, tNode, lContainer, hostLView) {
  const callback = () => {
    const nextState = lDetails[NEXT_DEFER_BLOCK_STATE];
    lDetails[STATE_IS_FROZEN_UNTIL] = null;
    lDetails[NEXT_DEFER_BLOCK_STATE] = null;
    if (nextState !== null) {
      renderDeferBlockState(nextState, tNode, lContainer);
    }
  };
  return scheduleTimerTrigger(timeout, callback, hostLView[INJECTOR]);
}
function isValidStateChange(currentState, newState) {
  return currentState < newState;
}
function renderPlaceholder(lView, tNode) {
  const lContainer = lView[tNode.index];
  ngDevMode && assertLContainer(lContainer);
  renderDeferBlockState(DeferBlockState.Placeholder, tNode, lContainer);
}
function renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer) {
  ngDevMode && assertDefined(tDetails.loadingPromise, "Expected loading Promise to exist on this defer block");
  tDetails.loadingPromise.then(() => {
    if (tDetails.loadingState === DeferDependenciesLoadingState.COMPLETE) {
      ngDevMode && assertDeferredDependenciesLoaded(tDetails);
      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);
    } else if (tDetails.loadingState === DeferDependenciesLoadingState.FAILED) {
      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);
    }
  });
}
function \u0275\u0275deferEnableTimerScheduling(tView, tDetails, placeholderConfigIndex, loadingConfigIndex) {
  const tViewConsts = tView.consts;
  if (placeholderConfigIndex != null) {
    tDetails.placeholderBlockConfig = getConstant(tViewConsts, placeholderConfigIndex);
  }
  if (loadingConfigIndex != null) {
    tDetails.loadingBlockConfig = getConstant(tViewConsts, loadingConfigIndex);
  }
  if (applyDeferBlockStateWithSchedulingImpl === null) {
    applyDeferBlockStateWithSchedulingImpl = applyDeferBlockStateWithScheduling;
  }
}
function setClassMetadata(type, decorators, ctorParameters, propDecorators) {
  return noSideEffects(() => {
    const clazz = type;
    if (decorators !== null) {
      if (clazz.hasOwnProperty("decorators") && clazz.decorators !== void 0) {
        clazz.decorators.push(...decorators);
      } else {
        clazz.decorators = decorators;
      }
    }
    if (ctorParameters !== null) {
      clazz.ctorParameters = ctorParameters;
    }
    if (propDecorators !== null) {
      if (clazz.hasOwnProperty("propDecorators") && clazz.propDecorators !== void 0) {
        clazz.propDecorators = __spreadValues(__spreadValues({}, clazz.propDecorators), propDecorators);
      } else {
        clazz.propDecorators = propDecorators;
      }
    }
  });
}
function getFrameworkDIDebugData() {
  return frameworkDIDebugData;
}
function setupFrameworkInjectorProfiler() {
  frameworkDIDebugData.reset();
  setInjectorProfiler(injectorProfilerEventHandler);
}
function injectorProfilerEventHandler(injectorProfilerEvent) {
  const { context: context2, type } = injectorProfilerEvent;
  if (type === 0) {
    handleInjectEvent(context2, injectorProfilerEvent.service);
  } else if (type === 1) {
    handleInstanceCreatedByInjectorEvent(context2, injectorProfilerEvent.instance);
  } else if (type === 2) {
    handleProviderConfiguredEvent(context2, injectorProfilerEvent.providerRecord);
  } else if (type === 3) {
    handleEffectCreatedEvent(context2, injectorProfilerEvent.effect);
  }
}
function handleEffectCreatedEvent(context2, effect2) {
  const diResolver = getDIResolver(context2.injector);
  if (diResolver === null) {
    throwError2("An EffectCreated event must be run within an injection context.");
  }
  const { resolverToEffects } = frameworkDIDebugData;
  if (!resolverToEffects.has(diResolver)) {
    resolverToEffects.set(diResolver, []);
  }
  resolverToEffects.get(diResolver).push(effect2);
}
function handleInjectEvent(context2, data) {
  const diResolver = getDIResolver(context2.injector);
  if (diResolver === null) {
    throwError2("An Inject event must be run within an injection context.");
  }
  const diResolverToInstantiatedToken = frameworkDIDebugData.resolverToTokenToDependencies;
  if (!diResolverToInstantiatedToken.has(diResolver)) {
    diResolverToInstantiatedToken.set(diResolver, /* @__PURE__ */ new WeakMap());
  }
  if (!canBeHeldWeakly(context2.token)) {
    return;
  }
  const instantiatedTokenToDependencies = diResolverToInstantiatedToken.get(diResolver);
  if (!instantiatedTokenToDependencies.has(context2.token)) {
    instantiatedTokenToDependencies.set(context2.token, []);
  }
  const { token, value, flags } = data;
  assertDefined(context2.token, "Injector profiler context token is undefined.");
  const dependencies = instantiatedTokenToDependencies.get(context2.token);
  assertDefined(dependencies, "Could not resolve dependencies for token.");
  if (context2.injector instanceof NodeInjector) {
    dependencies.push({ token, value, flags, injectedIn: getNodeInjectorContext(context2.injector) });
  } else {
    dependencies.push({ token, value, flags });
  }
}
function getNodeInjectorContext(injector) {
  if (!(injector instanceof NodeInjector)) {
    throwError2("getNodeInjectorContext must be called with a NodeInjector");
  }
  const lView = getNodeInjectorLView(injector);
  const tNode = getNodeInjectorTNode(injector);
  if (tNode === null) {
    return;
  }
  assertTNodeForLView(tNode, lView);
  return { lView, tNode };
}
function handleInstanceCreatedByInjectorEvent(context2, data) {
  const { value } = data;
  if (data.value == null) {
    return;
  }
  if (getDIResolver(context2.injector) === null) {
    throwError2("An InjectorCreatedInstance event must be run within an injection context.");
  }
  let standaloneComponent = void 0;
  if (typeof value === "object") {
    standaloneComponent = value?.constructor;
  }
  if (standaloneComponent == void 0 || !isStandaloneComponent(standaloneComponent)) {
    return;
  }
  const environmentInjector = context2.injector.get(EnvironmentInjector, null, { optional: true });
  if (environmentInjector === null) {
    return;
  }
  const { standaloneInjectorToComponent } = frameworkDIDebugData;
  if (standaloneInjectorToComponent.has(environmentInjector)) {
    return;
  }
  standaloneInjectorToComponent.set(environmentInjector, standaloneComponent);
}
function isStandaloneComponent(value) {
  const def = getComponentDef(value);
  return !!def?.standalone;
}
function handleProviderConfiguredEvent(context2, data) {
  const { resolverToProviders } = frameworkDIDebugData;
  let diResolver;
  if (context2?.injector instanceof NodeInjector) {
    diResolver = getNodeInjectorTNode(context2.injector);
  } else {
    diResolver = context2.injector;
  }
  if (diResolver === null) {
    throwError2("A ProviderConfigured event must be run within an injection context.");
  }
  if (!resolverToProviders.has(diResolver)) {
    resolverToProviders.set(diResolver, []);
  }
  resolverToProviders.get(diResolver).push(data);
}
function getDIResolver(injector) {
  let diResolver = null;
  if (injector === void 0) {
    return diResolver;
  }
  if (injector instanceof NodeInjector) {
    diResolver = getNodeInjectorLView(injector);
  } else {
    diResolver = injector;
  }
  return diResolver;
}
function canBeHeldWeakly(value) {
  return value !== null && (typeof value === "object" || typeof value === "function" || typeof value === "symbol");
}
function applyChanges(component) {
  ngDevMode && assertDefined(component, "component");
  markViewDirty(
    getComponentViewByInstance(component),
    3
    /* NotificationSource.DebugApplyChanges */
  );
  getRootComponents(component).forEach((rootComponent) => detectChanges(rootComponent));
}
function detectChanges(component) {
  const view = getComponentViewByInstance(component);
  view[FLAGS] |= 1024;
  detectChangesInternal(view);
}
function getDeferBlocks$1(lView, deferBlocks) {
  const tView = lView[TVIEW];
  for (let i2 = HEADER_OFFSET; i2 < tView.bindingStartIndex; i2++) {
    if (isLContainer(lView[i2])) {
      const lContainer = lView[i2];
      const isLast = i2 === tView.bindingStartIndex - 1;
      if (!isLast) {
        const tNode = tView.data[i2];
        const tDetails = getTDeferBlockDetails(tView, tNode);
        if (isTDeferBlockDetails(tDetails)) {
          deferBlocks.push({ lContainer, lView, tNode, tDetails });
          continue;
        }
      }
      if (isLView(lContainer[HOST])) {
        getDeferBlocks$1(lContainer[HOST], deferBlocks);
      }
      for (let j2 = CONTAINER_HEADER_OFFSET; j2 < lContainer.length; j2++) {
        getDeferBlocks$1(lContainer[j2], deferBlocks);
      }
    } else if (isLView(lView[i2])) {
      getDeferBlocks$1(lView[i2], deferBlocks);
    }
  }
}
function getDeferBlocks(node) {
  const results = [];
  const lView = getLContext(node)?.lView;
  if (lView) {
    findDeferBlocks(node, lView, results);
  }
  return results;
}
function findDeferBlocks(node, lView, results) {
  const viewInjector = lView[INJECTOR];
  const registry = viewInjector.get(DEHYDRATED_BLOCK_REGISTRY, null, { optional: true });
  const blocks = [];
  getDeferBlocks$1(lView, blocks);
  const transferState = viewInjector.get(TransferState);
  const deferBlockParents = transferState.get(NGH_DEFER_BLOCKS_KEY, {});
  for (const details of blocks) {
    const native = getNativeByTNode(details.tNode, details.lView);
    const lDetails = getLDeferBlockDetails(details.lView, details.tNode);
    if (!node.contains(native)) {
      continue;
    }
    const tDetails = details.tDetails;
    const renderedLView = getRendererLView(details);
    const rootNodes = [];
    const hydrationState = inferHydrationState(tDetails, lDetails, registry);
    if (renderedLView !== null) {
      collectNativeNodes(renderedLView[TVIEW], renderedLView, renderedLView[TVIEW].firstChild, rootNodes);
    } else if (hydrationState === "dehydrated") {
      const deferId = lDetails[SSR_UNIQUE_ID];
      const deferData = deferBlockParents[deferId];
      const numberOfRootNodes = deferData[NUM_ROOT_NODES];
      let collectedNodeCount = 0;
      const deferBlockCommentNode = details.lContainer[NATIVE];
      let currentNode = deferBlockCommentNode.previousSibling;
      while (collectedNodeCount < numberOfRootNodes && currentNode) {
        rootNodes.unshift(currentNode);
        currentNode = currentNode.previousSibling;
        collectedNodeCount++;
      }
    }
    const data = {
      state: stringifyState(lDetails[DEFER_BLOCK_STATE]),
      incrementalHydrationState: hydrationState,
      hasErrorBlock: tDetails.errorTmplIndex !== null,
      loadingBlock: {
        exists: tDetails.loadingTmplIndex !== null,
        minimumTime: tDetails.loadingBlockConfig?.[MINIMUM_SLOT] ?? null,
        afterTime: tDetails.loadingBlockConfig?.[LOADING_AFTER_SLOT] ?? null
      },
      placeholderBlock: {
        exists: tDetails.placeholderTmplIndex !== null,
        minimumTime: tDetails.placeholderBlockConfig?.[MINIMUM_SLOT] ?? null
      },
      triggers: tDetails.debug?.triggers ? Array.from(tDetails.debug.triggers).sort() : [],
      rootNodes
    };
    results.push(data);
    if (renderedLView !== null) {
      findDeferBlocks(node, renderedLView, results);
    }
  }
}
function stringifyState(state) {
  switch (state) {
    case DeferBlockState.Complete:
      return "complete";
    case DeferBlockState.Loading:
      return "loading";
    case DeferBlockState.Placeholder:
      return "placeholder";
    case DeferBlockState.Error:
      return "error";
    case DeferBlockInternalState.Initial:
      return "initial";
    default:
      throw new Error(`Unrecognized state ${state}`);
  }
}
function inferHydrationState(tDetails, lDetails, registry) {
  if (registry === null || lDetails[SSR_UNIQUE_ID] === null || tDetails.hydrateTriggers === null || tDetails.hydrateTriggers.has(
    7
    /* DeferBlockTrigger.Never */
  )) {
    return "not-configured";
  }
  return registry.has(lDetails[SSR_UNIQUE_ID]) ? "dehydrated" : "hydrated";
}
function getRendererLView(details) {
  if (details.lContainer.length <= CONTAINER_HEADER_OFFSET) {
    return null;
  }
  const lView = details.lContainer[CONTAINER_HEADER_OFFSET];
  ngDevMode && assertLView(lView);
  return lView;
}
function getDependenciesFromInjectable(injector, token) {
  const instance = injector.get(token, null, { self: true, optional: true });
  if (instance === null) {
    throw new Error(`Unable to determine instance of ${token} in given injector`);
  }
  const unformattedDependencies = getDependenciesForTokenInInjector(token, injector);
  const resolutionPath = getInjectorResolutionPath(injector);
  const dependencies = unformattedDependencies.map((dep) => {
    const formattedDependency = {
      value: dep.value
    };
    const flags = dep.flags;
    formattedDependency.flags = {
      optional: (8 & flags) === 8,
      host: (1 & flags) === 1,
      self: (2 & flags) === 2,
      skipSelf: (4 & flags) === 4
    };
    for (let i2 = 0; i2 < resolutionPath.length; i2++) {
      const injectorToCheck = resolutionPath[i2];
      if (i2 === 0 && formattedDependency.flags.skipSelf) {
        continue;
      }
      if (formattedDependency.flags.host && injectorToCheck instanceof EnvironmentInjector) {
        break;
      }
      const instance2 = injectorToCheck.get(dep.token, null, {
        self: true,
        optional: true
      });
      if (instance2 !== null) {
        if (formattedDependency.flags.host) {
          const firstInjector = resolutionPath[0];
          const lookupFromFirstInjector = firstInjector.get(dep.token, null, __spreadProps(__spreadValues({}, formattedDependency.flags), {
            optional: true
          }));
          if (lookupFromFirstInjector !== null) {
            formattedDependency.providedIn = injectorToCheck;
          }
          break;
        }
        formattedDependency.providedIn = injectorToCheck;
        break;
      }
      if (i2 === 0 && formattedDependency.flags.self) {
        break;
      }
    }
    if (dep.token)
      formattedDependency.token = dep.token;
    return formattedDependency;
  });
  return { instance, dependencies };
}
function getDependenciesForTokenInInjector(token, injector) {
  const { resolverToTokenToDependencies } = getFrameworkDIDebugData();
  if (!(injector instanceof NodeInjector)) {
    return resolverToTokenToDependencies.get(injector)?.get?.(token) ?? [];
  }
  const lView = getNodeInjectorLView(injector);
  const tokenDependencyMap = resolverToTokenToDependencies.get(lView);
  const dependencies = tokenDependencyMap?.get(token) ?? [];
  return dependencies.filter((dependency) => {
    const dependencyNode = dependency.injectedIn?.tNode;
    if (dependencyNode === void 0) {
      return false;
    }
    const instanceNode = getNodeInjectorTNode(injector);
    assertTNode(dependencyNode);
    assertTNode(instanceNode);
    return dependencyNode === instanceNode;
  });
}
function getProviderImportsContainer(injector) {
  const { standaloneInjectorToComponent } = getFrameworkDIDebugData();
  if (standaloneInjectorToComponent.has(injector)) {
    return standaloneInjectorToComponent.get(injector);
  }
  const defTypeRef = injector.get(NgModuleRef$1, null, { self: true, optional: true });
  if (defTypeRef === null) {
    return null;
  }
  if (defTypeRef.instance === null) {
    return null;
  }
  return defTypeRef.instance.constructor;
}
function getNodeInjectorProviders(injector) {
  const diResolver = getNodeInjectorTNode(injector);
  const { resolverToProviders } = getFrameworkDIDebugData();
  return resolverToProviders.get(diResolver) ?? [];
}
function getProviderImportPaths(providerImportsContainer) {
  const providerToPath = /* @__PURE__ */ new Map();
  const visitedContainers = /* @__PURE__ */ new Set();
  const visitor = walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers);
  walkProviderTree(providerImportsContainer, visitor, [], /* @__PURE__ */ new Set());
  return providerToPath;
}
function walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers) {
  return (provider, container) => {
    if (!providerToPath.has(provider)) {
      providerToPath.set(provider, [container]);
    }
    if (!visitedContainers.has(container)) {
      for (const prov of providerToPath.keys()) {
        const existingImportPath = providerToPath.get(prov);
        let containerDef = getInjectorDef(container);
        if (!containerDef) {
          const ngModule = container.ngModule;
          containerDef = getInjectorDef(ngModule);
        }
        if (!containerDef) {
          return;
        }
        const lastContainerAddedToPath = existingImportPath[0];
        let isNextStepInPath = false;
        deepForEach(containerDef.imports, (moduleImport) => {
          if (isNextStepInPath) {
            return;
          }
          isNextStepInPath = moduleImport.ngModule === lastContainerAddedToPath || moduleImport === lastContainerAddedToPath;
          if (isNextStepInPath) {
            providerToPath.get(prov)?.unshift(container);
          }
        });
      }
    }
    visitedContainers.add(container);
  };
}
function getEnvironmentInjectorProviders(injector) {
  const providerRecordsWithoutImportPaths = getFrameworkDIDebugData().resolverToProviders.get(injector) ?? [];
  if (isPlatformInjector(injector)) {
    return providerRecordsWithoutImportPaths;
  }
  const providerImportsContainer = getProviderImportsContainer(injector);
  if (providerImportsContainer === null) {
    return providerRecordsWithoutImportPaths;
  }
  const providerToPath = getProviderImportPaths(providerImportsContainer);
  const providerRecords = [];
  for (const providerRecord of providerRecordsWithoutImportPaths) {
    const provider = providerRecord.provider;
    const token = provider.provide;
    if (token === ENVIRONMENT_INITIALIZER || token === INJECTOR_DEF_TYPES) {
      continue;
    }
    let importPath = providerToPath.get(provider) ?? [];
    const def = getComponentDef(providerImportsContainer);
    const isStandaloneComponent2 = !!def?.standalone;
    if (isStandaloneComponent2) {
      importPath = [providerImportsContainer, ...importPath];
    }
    providerRecords.push(__spreadProps(__spreadValues({}, providerRecord), { importPath }));
  }
  return providerRecords;
}
function isPlatformInjector(injector) {
  return injector instanceof R3Injector && injector.scopes.has("platform");
}
function getInjectorProviders(injector) {
  if (injector instanceof NodeInjector) {
    return getNodeInjectorProviders(injector);
  } else if (injector instanceof EnvironmentInjector) {
    return getEnvironmentInjectorProviders(injector);
  }
  throwError2("getInjectorProviders only supports NodeInjector and EnvironmentInjector");
}
function getInjectorMetadata(injector) {
  if (injector instanceof NodeInjector) {
    const lView = getNodeInjectorLView(injector);
    const tNode = getNodeInjectorTNode(injector);
    assertTNodeForLView(tNode, lView);
    return { type: "element", source: getNativeByTNode(tNode, lView) };
  }
  if (injector instanceof R3Injector) {
    return { type: "environment", source: injector.source ?? null };
  }
  if (injector instanceof NullInjector) {
    return { type: "null", source: null };
  }
  return null;
}
function getInjectorResolutionPath(injector) {
  const resolutionPath = [injector];
  getInjectorResolutionPathHelper(injector, resolutionPath);
  return resolutionPath;
}
function getInjectorResolutionPathHelper(injector, resolutionPath) {
  const parent = getInjectorParent(injector);
  if (parent === null) {
    if (injector instanceof NodeInjector) {
      const firstInjector = resolutionPath[0];
      if (firstInjector instanceof NodeInjector) {
        const moduleInjector = getModuleInjectorOfNodeInjector(firstInjector);
        if (moduleInjector === null) {
          throwError2("NodeInjector must have some connection to the module injector tree");
        }
        resolutionPath.push(moduleInjector);
        getInjectorResolutionPathHelper(moduleInjector, resolutionPath);
      }
      return resolutionPath;
    }
  } else {
    resolutionPath.push(parent);
    getInjectorResolutionPathHelper(parent, resolutionPath);
  }
  return resolutionPath;
}
function getInjectorParent(injector) {
  if (injector instanceof R3Injector) {
    return injector.parent;
  }
  let tNode;
  let lView;
  if (injector instanceof NodeInjector) {
    tNode = getNodeInjectorTNode(injector);
    lView = getNodeInjectorLView(injector);
  } else if (injector instanceof NullInjector) {
    return null;
  } else if (injector instanceof ChainedInjector) {
    return injector.parentInjector;
  } else {
    throwError2("getInjectorParent only support injectors of type R3Injector, NodeInjector, NullInjector");
  }
  const parentLocation = getParentInjectorLocation(tNode, lView);
  if (hasParentInjector(parentLocation)) {
    const parentInjectorIndex = getParentInjectorIndex(parentLocation);
    const parentLView = getParentInjectorView(parentLocation, lView);
    const parentTView = parentLView[TVIEW];
    const parentTNode = parentTView.data[
      parentInjectorIndex + 8
      /* NodeInjectorOffset.TNODE */
    ];
    return new NodeInjector(parentTNode, parentLView);
  } else {
    const chainedInjector = lView[INJECTOR];
    const injectorParent = chainedInjector.injector?.parent;
    if (injectorParent instanceof NodeInjector) {
      return injectorParent;
    }
  }
  return null;
}
function getModuleInjectorOfNodeInjector(injector) {
  let lView;
  if (injector instanceof NodeInjector) {
    lView = getNodeInjectorLView(injector);
  } else {
    throwError2("getModuleInjectorOfNodeInjector must be called with a NodeInjector");
  }
  const inj = lView[INJECTOR];
  const moduleInjector = inj instanceof ChainedInjector ? inj.parentInjector : inj.parent;
  if (!moduleInjector) {
    throwError2("NodeInjector must have some connection to the module injector tree");
  }
  return moduleInjector;
}
function isComputedNode(node) {
  return node.kind === "computed";
}
function isTemplateEffectNode(node) {
  return node.kind === "template";
}
function isSignalNode(node) {
  return node.kind === "signal";
}
function getTemplateConsumer(injector) {
  const tNode = getNodeInjectorTNode(injector);
  assertTNode(tNode);
  const lView = getNodeInjectorLView(injector);
  assertLView(lView);
  const templateLView = lView[tNode.index];
  if (isLView(templateLView)) {
    return templateLView[REACTIVE_TEMPLATE_CONSUMER] ?? null;
  }
  return null;
}
function getNodesAndEdgesFromSignalMap(signalMap) {
  const nodes = Array.from(signalMap.keys());
  const debugSignalGraphNodes = [];
  const edges = [];
  for (const [consumer, producers] of signalMap.entries()) {
    const consumerIndex = nodes.indexOf(consumer);
    let id2 = signalDebugMap.get(consumer);
    if (!id2) {
      counter$1++;
      id2 = counter$1.toString();
      signalDebugMap.set(consumer, id2);
    }
    if (isComputedNode(consumer)) {
      debugSignalGraphNodes.push({
        label: consumer.debugName,
        value: consumer.value,
        kind: consumer.kind,
        epoch: consumer.version,
        debuggableFn: consumer.computation,
        id: id2
      });
    } else if (isSignalNode(consumer)) {
      debugSignalGraphNodes.push({
        label: consumer.debugName,
        value: consumer.value,
        kind: consumer.kind,
        epoch: consumer.version,
        id: id2
      });
    } else if (isTemplateEffectNode(consumer)) {
      debugSignalGraphNodes.push({
        label: consumer.debugName ?? consumer.lView?.[HOST]?.tagName?.toLowerCase?.(),
        kind: consumer.kind,
        epoch: consumer.version,
        // The `lView[CONTEXT]` is a reference to an instance of the component's class.
        // We get the constructor so that `inspect(.constructor)` shows the component class.
        debuggableFn: consumer.lView?.[CONTEXT]?.constructor,
        id: id2
      });
    } else {
      debugSignalGraphNodes.push({
        label: consumer.debugName,
        kind: consumer.kind,
        epoch: consumer.version,
        id: id2
      });
    }
    for (const producer of producers) {
      edges.push({ consumer: consumerIndex, producer: nodes.indexOf(producer) });
    }
  }
  return { nodes: debugSignalGraphNodes, edges };
}
function extractEffectsFromInjector(injector) {
  let diResolver = injector;
  if (injector instanceof NodeInjector) {
    const lView = getNodeInjectorLView(injector);
    diResolver = lView;
  }
  const resolverToEffects = getFrameworkDIDebugData().resolverToEffects;
  const effects = resolverToEffects.get(diResolver) ?? [];
  return effects.map((effect2) => effect2[SIGNAL]);
}
function extractSignalNodesAndEdgesFromRoots(nodes, signalDependenciesMap = /* @__PURE__ */ new Map()) {
  for (const node of nodes) {
    if (signalDependenciesMap.has(node)) {
      continue;
    }
    const producerNodes = [];
    for (let link = node.producers; link !== void 0; link = link.nextProducer) {
      const producer = link.producer;
      producerNodes.push(producer);
    }
    signalDependenciesMap.set(node, producerNodes);
    extractSignalNodesAndEdgesFromRoots(producerNodes, signalDependenciesMap);
  }
  return signalDependenciesMap;
}
function getSignalGraph(injector) {
  let templateConsumer = null;
  if (!(injector instanceof NodeInjector) && !(injector instanceof R3Injector)) {
    return throwError2("getSignalGraph must be called with a NodeInjector or R3Injector");
  }
  if (injector instanceof NodeInjector) {
    templateConsumer = getTemplateConsumer(injector);
  }
  const nonTemplateEffectNodes = extractEffectsFromInjector(injector);
  const signalNodes = templateConsumer ? [templateConsumer, ...nonTemplateEffectNodes] : nonTemplateEffectNodes;
  const signalDependenciesMap = extractSignalNodesAndEdgesFromRoots(signalNodes);
  return getNodesAndEdgesFromSignalMap(signalDependenciesMap);
}
function measureStart(startEvent) {
  eventsStack.push([startEvent, counter]);
  console.timeStamp("Event_" + startEvent + "_" + counter++);
}
function measureEnd(startEvent, entryName, color) {
  const top = eventsStack.pop();
  assertDefined(top, "Profiling error: could not find start event entry " + startEvent);
  assertEqual(top[0], startEvent, `Profiling error: expected to see ${startEvent} event but got ${top[0]}`);
  console.timeStamp(entryName, "Event_" + top[0] + "_" + top[1], void 0, "\u{1F170}\uFE0F Angular", void 0, color);
}
function getComponentMeasureName(instance) {
  return instance.constructor.name;
}
function getProviderTokenMeasureName(token) {
  if (isTypeProvider(token)) {
    return token.name;
  } else if (token.provide != null) {
    return getProviderTokenMeasureName(token.provide);
  }
  return token.toString();
}
function enableProfiling() {
  performanceMarkFeature("Chrome DevTools profiling");
  if (typeof ngDevMode !== "undefined" && ngDevMode) {
    const removeInjectorProfiler = setInjectorProfiler(chromeDevToolsInjectorProfiler);
    const removeProfiler3 = setProfiler(devToolsProfiler);
    return () => {
      removeInjectorProfiler();
      removeProfiler3();
    };
  }
  return () => {
  };
}
function publishDefaultGlobalUtils$1() {
  if (!_published) {
    _published = true;
    if (typeof window !== "undefined") {
      setupFrameworkInjectorProfiler();
    }
    for (const [methodName, method] of Object.entries(globalUtilsFunctions)) {
      publishGlobalUtil(methodName, method);
    }
  }
}
function publishGlobalUtil(name, fn) {
  publishUtil(name, fn);
}
function publishUtil(name, fn) {
  if (typeof COMPILED === "undefined" || !COMPILED) {
    const w2 = _global;
    ngDevMode && assertDefined(fn, "function not defined");
    w2[GLOBAL_PUBLISH_EXPANDO_KEY] ??= {};
    w2[GLOBAL_PUBLISH_EXPANDO_KEY][name] = fn;
  }
}
function setTestabilityGetter(getter) {
  _testabilityGetter = getter;
}
function isPromise2(obj) {
  return !!obj && typeof obj.then === "function";
}
function isSubscribable(obj) {
  return !!obj && typeof obj.subscribe === "function";
}
function provideAppInitializer(initializerFn) {
  return makeEnvironmentProviders([
    {
      provide: APP_INITIALIZER,
      multi: true,
      useValue: initializerFn
    }
  ]);
}
function publishDefaultGlobalUtils() {
  ngDevMode && publishDefaultGlobalUtils$1();
}
function publishSignalConfiguration() {
  setThrowInvalidWriteToSignalError(() => {
    let errorMessage = "";
    if (ngDevMode) {
      const activeConsumer2 = getActiveConsumer();
      errorMessage = activeConsumer2 && isReactiveLViewConsumer(activeConsumer2) ? "Writing to signals is not allowed while Angular renders the template (eg. interpolations)" : "Writing to signals is not allowed in a `computed`";
    }
    throw new RuntimeError(600, errorMessage);
  });
}
function isBoundToModule(cf2) {
  return cf2.isBoundToModule;
}
function optionsReducer(dst, objs) {
  if (Array.isArray(objs)) {
    return objs.reduce(optionsReducer, dst);
  }
  return __spreadValues(__spreadValues({}, dst), objs);
}
function warnIfDestroyed(destroyed) {
  if (destroyed) {
    console.warn(formatRuntimeError(406, "This instance of the `ApplicationRef` has already been destroyed."));
  }
}
function remove(list, el2) {
  const index = list.indexOf(el2);
  if (index > -1) {
    list.splice(index, 1);
  }
}
function scheduleDelayedTrigger(scheduleFn) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  renderPlaceholder(lView, tNode);
  if (!shouldTriggerDeferBlock(0, lView))
    return;
  const injector = lView[INJECTOR];
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const cleanupFn = scheduleFn(() => triggerDeferBlock(0, lView, tNode), injector);
  storeTriggerCleanupFn(0, lDetails, cleanupFn);
}
function scheduleDelayedPrefetching(scheduleFn, trigger) {
  if (false)
    return;
  const lView = getLView();
  const injector = lView[INJECTOR];
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    const lDetails = getLDeferBlockDetails(lView, tNode);
    const prefetch = () => triggerPrefetching(tDetails, lView, tNode);
    const cleanupFn = scheduleFn(prefetch, injector);
    storeTriggerCleanupFn(1, lDetails, cleanupFn);
  }
}
function scheduleDelayedHydrating(scheduleFn, lView, tNode) {
  if (false)
    return;
  const injector = lView[INJECTOR];
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const ssrUniqueId = lDetails[SSR_UNIQUE_ID];
  ngDevMode && assertSsrIdDefined(ssrUniqueId);
  const cleanupFn = scheduleFn(() => triggerHydrationFromBlockName(injector, ssrUniqueId), injector);
  storeTriggerCleanupFn(2, lDetails, cleanupFn);
}
function triggerPrefetching(tDetails, lView, tNode) {
  triggerResourceLoading(tDetails, lView, tNode);
}
function triggerResourceLoading(tDetails, lView, tNode) {
  const injector = lView[INJECTOR];
  const tView = lView[TVIEW];
  if (tDetails.loadingState !== DeferDependenciesLoadingState.NOT_STARTED) {
    return tDetails.loadingPromise ?? Promise.resolve();
  }
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const primaryBlockTNode = getPrimaryBlockTNode(tView, tDetails);
  tDetails.loadingState = DeferDependenciesLoadingState.IN_PROGRESS;
  invokeTriggerCleanupFns(1, lDetails);
  let dependenciesFn = tDetails.dependencyResolverFn;
  if (ngDevMode) {
    const deferDependencyInterceptor = injector.get(DEFER_BLOCK_DEPENDENCY_INTERCEPTOR, null, {
      optional: true
    });
    if (deferDependencyInterceptor) {
      dependenciesFn = deferDependencyInterceptor.intercept(dependenciesFn);
    }
  }
  const removeTask = injector.get(PendingTasks).add();
  if (!dependenciesFn) {
    tDetails.loadingPromise = Promise.resolve().then(() => {
      tDetails.loadingPromise = null;
      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;
      removeTask();
    });
    return tDetails.loadingPromise;
  }
  tDetails.loadingPromise = Promise.allSettled(dependenciesFn()).then((results) => {
    let failed = false;
    const directiveDefs = [];
    const pipeDefs = [];
    for (const result of results) {
      if (result.status === "fulfilled") {
        const dependency = result.value;
        const directiveDef = getComponentDef(dependency) || getDirectiveDef(dependency);
        if (directiveDef) {
          directiveDefs.push(directiveDef);
        } else {
          const pipeDef = getPipeDef(dependency);
          if (pipeDef) {
            pipeDefs.push(pipeDef);
          }
        }
      } else {
        failed = true;
        break;
      }
    }
    if (failed) {
      tDetails.loadingState = DeferDependenciesLoadingState.FAILED;
      if (tDetails.errorTmplIndex === null) {
        const templateLocation = ngDevMode ? getTemplateLocationDetails(lView) : "";
        const error = new RuntimeError(-750, ngDevMode && `Loading dependencies for \`@defer\` block failed, but no \`@error\` block was configured${templateLocation}. Consider using the \`@error\` block to render an error state.`);
        handleUncaughtError(lView, error);
      }
    } else {
      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;
      const primaryBlockTView = primaryBlockTNode.tView;
      if (directiveDefs.length > 0) {
        primaryBlockTView.directiveRegistry = addDepsToRegistry(primaryBlockTView.directiveRegistry, directiveDefs);
        const directiveTypes = directiveDefs.map((def) => def.type);
        const providers = internalImportProvidersFrom(false, ...directiveTypes);
        tDetails.providers = providers;
      }
      if (pipeDefs.length > 0) {
        primaryBlockTView.pipeRegistry = addDepsToRegistry(primaryBlockTView.pipeRegistry, pipeDefs);
      }
    }
  });
  return tDetails.loadingPromise.finally(() => {
    tDetails.loadingPromise = null;
    removeTask();
  });
}
function shouldTriggerDeferBlock(triggerType, lView) {
  if (triggerType === 0 && true && false) {
    return false;
  }
  const injector = lView[INJECTOR];
  const config2 = injector.get(DEFER_BLOCK_CONFIG, null, { optional: true });
  if (config2?.behavior === DeferBlockBehavior.Manual) {
    return false;
  }
  return true;
}
function triggerDeferBlock(triggerType, lView, tNode) {
  const tView = lView[TVIEW];
  const lContainer = lView[tNode.index];
  ngDevMode && assertLContainer(lContainer);
  if (!shouldTriggerDeferBlock(triggerType, lView))
    return;
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const tDetails = getTDeferBlockDetails(tView, tNode);
  invokeAllTriggerCleanupFns(lDetails);
  switch (tDetails.loadingState) {
    case DeferDependenciesLoadingState.NOT_STARTED:
      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);
      triggerResourceLoading(tDetails, lView, tNode);
      if (tDetails.loadingState === DeferDependenciesLoadingState.IN_PROGRESS) {
        renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);
      }
      break;
    case DeferDependenciesLoadingState.IN_PROGRESS:
      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);
      renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);
      break;
    case DeferDependenciesLoadingState.COMPLETE:
      ngDevMode && assertDeferredDependenciesLoaded(tDetails);
      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);
      break;
    case DeferDependenciesLoadingState.FAILED:
      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);
      break;
    default:
      if (ngDevMode) {
        throwError2("Unknown defer block state");
      }
  }
}
function triggerHydrationFromBlockName(injector, blockName, replayQueuedEventsFn) {
  return __async(this, null, function* () {
    const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;
    if (blocksBeingHydrated.has(blockName)) {
      return;
    }
    const { parentBlockPromise, hydrationQueue } = getParentBlockHydrationQueue(blockName, injector);
    if (hydrationQueue.length === 0)
      return;
    if (parentBlockPromise !== null) {
      hydrationQueue.shift();
    }
    populateHydratingStateForQueue(dehydratedBlockRegistry, hydrationQueue);
    if (parentBlockPromise !== null) {
      yield parentBlockPromise;
    }
    const topmostParentBlock = hydrationQueue[0];
    if (dehydratedBlockRegistry.has(topmostParentBlock)) {
      yield triggerHydrationForBlockQueue(injector, hydrationQueue, replayQueuedEventsFn);
    } else {
      dehydratedBlockRegistry.awaitParentBlock(topmostParentBlock, () => __async(null, null, function* () {
        return yield triggerHydrationForBlockQueue(injector, hydrationQueue, replayQueuedEventsFn);
      }));
    }
  });
}
function triggerHydrationForBlockQueue(injector, hydrationQueue, replayQueuedEventsFn) {
  return __async(this, null, function* () {
    const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;
    const pendingTasks = injector.get(PendingTasksInternal);
    const taskId = pendingTasks.add();
    for (let blockQueueIdx = 0; blockQueueIdx < hydrationQueue.length; blockQueueIdx++) {
      const dehydratedBlockId = hydrationQueue[blockQueueIdx];
      const dehydratedDeferBlock = dehydratedBlockRegistry.get(dehydratedBlockId);
      if (dehydratedDeferBlock != null) {
        yield triggerResourceLoadingForHydration(dehydratedDeferBlock);
        yield nextRender(injector);
        if (deferBlockHasErrored(dehydratedDeferBlock)) {
          removeDehydratedViewList(dehydratedDeferBlock);
          cleanupRemainingHydrationQueue(hydrationQueue.slice(blockQueueIdx), dehydratedBlockRegistry);
          break;
        }
        blocksBeingHydrated.get(dehydratedBlockId).resolve();
      } else {
        cleanupParentContainer(blockQueueIdx, hydrationQueue, dehydratedBlockRegistry);
        cleanupRemainingHydrationQueue(hydrationQueue.slice(blockQueueIdx), dehydratedBlockRegistry);
        break;
      }
    }
    const lastBlockName = hydrationQueue[hydrationQueue.length - 1];
    yield blocksBeingHydrated.get(lastBlockName)?.promise;
    pendingTasks.remove(taskId);
    if (replayQueuedEventsFn) {
      replayQueuedEventsFn(hydrationQueue);
    }
    cleanupHydratedDeferBlocks(dehydratedBlockRegistry.get(lastBlockName), hydrationQueue, dehydratedBlockRegistry, injector.get(ApplicationRef));
  });
}
function deferBlockHasErrored(deferBlock) {
  return getLDeferBlockDetails(deferBlock.lView, deferBlock.tNode)[DEFER_BLOCK_STATE] === DeferBlockState.Error;
}
function cleanupParentContainer(currentBlockIdx, hydrationQueue, dehydratedBlockRegistry) {
  const parentDeferBlockIdx = currentBlockIdx - 1;
  const parentDeferBlock = parentDeferBlockIdx > -1 ? dehydratedBlockRegistry.get(hydrationQueue[parentDeferBlockIdx]) : null;
  if (parentDeferBlock) {
    cleanupLContainer(parentDeferBlock.lContainer);
  }
}
function cleanupRemainingHydrationQueue(hydrationQueue, dehydratedBlockRegistry) {
  const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;
  for (const dehydratedBlockId in hydrationQueue) {
    blocksBeingHydrated.get(dehydratedBlockId)?.reject();
  }
  dehydratedBlockRegistry.cleanup(hydrationQueue);
}
function populateHydratingStateForQueue(registry, queue) {
  for (let blockId of queue) {
    registry.hydrating.set(blockId, Promise.withResolvers());
  }
}
function nextRender(injector) {
  return new Promise((resolveFn) => afterNextRender(resolveFn, { injector }));
}
function triggerResourceLoadingForHydration(dehydratedBlock) {
  return __async(this, null, function* () {
    const { tNode, lView } = dehydratedBlock;
    const lDetails = getLDeferBlockDetails(lView, tNode);
    return new Promise((resolve) => {
      onDeferBlockCompletion(lDetails, resolve);
      triggerDeferBlock(2, lView, tNode);
    });
  });
}
function onDeferBlockCompletion(lDetails, callback) {
  if (!Array.isArray(lDetails[ON_COMPLETE_FNS])) {
    lDetails[ON_COMPLETE_FNS] = [];
  }
  lDetails[ON_COMPLETE_FNS].push(callback);
}
function shouldAttachTrigger(triggerType, lView, tNode) {
  if (triggerType === 0) {
    return shouldAttachRegularTrigger(lView, tNode);
  } else if (triggerType === 2) {
    return !shouldAttachRegularTrigger(lView, tNode);
  }
  return true;
}
function hasHydrateTriggers(flags) {
  return flags != null && (flags & 1) === 1;
}
function shouldAttachRegularTrigger(lView, tNode) {
  const injector = lView[INJECTOR];
  const tDetails = getTDeferBlockDetails(lView[TVIEW], tNode);
  const incrementalHydrationEnabled = isIncrementalHydrationEnabled(injector);
  const _hasHydrateTriggers = hasHydrateTriggers(tDetails.flags);
  if (false) {
    return !incrementalHydrationEnabled || !_hasHydrateTriggers;
  }
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const wasServerSideRendered = lDetails[SSR_UNIQUE_ID] !== null;
  if (_hasHydrateTriggers && wasServerSideRendered && incrementalHydrationEnabled) {
    return false;
  }
  return true;
}
function getHydrateTriggers(tView, tNode) {
  const tDetails = getTDeferBlockDetails(tView, tNode);
  return tDetails.hydrateTriggers ??= /* @__PURE__ */ new Map();
}
function \u0275\u0275defer(index, primaryTmplIndex, dependencyResolverFn, loadingTmplIndex, placeholderTmplIndex, errorTmplIndex, loadingConfigIndex, placeholderConfigIndex, enableTimerScheduling, flags) {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = declareNoDirectiveHostTemplate(lView, tView, index, null, 0, 0);
  const injector = lView[INJECTOR];
  if (tView.firstCreatePass) {
    performanceMarkFeature("NgDefer");
    if (ngDevMode) {
      if (false) {
        logHmrWarning(injector);
      }
      if (hasHydrateTriggers(flags)) {
        assertIncrementalHydrationIsConfigured(injector);
      }
    }
    const tDetails = {
      primaryTmplIndex,
      loadingTmplIndex: loadingTmplIndex ?? null,
      placeholderTmplIndex: placeholderTmplIndex ?? null,
      errorTmplIndex: errorTmplIndex ?? null,
      placeholderBlockConfig: null,
      loadingBlockConfig: null,
      dependencyResolverFn: dependencyResolverFn ?? null,
      loadingState: DeferDependenciesLoadingState.NOT_STARTED,
      loadingPromise: null,
      providers: null,
      hydrateTriggers: null,
      debug: null,
      flags: flags ?? 0
    };
    enableTimerScheduling?.(tView, tDetails, placeholderConfigIndex, loadingConfigIndex);
    setTDeferBlockDetails(tView, adjustedIndex, tDetails);
  }
  const lContainer = lView[adjustedIndex];
  populateDehydratedViewsInLContainer(lContainer, tNode, lView);
  let ssrBlockState = null;
  let ssrUniqueId = null;
  if (lContainer[DEHYDRATED_VIEWS]?.length > 0) {
    const info = lContainer[DEHYDRATED_VIEWS][0].data;
    ssrUniqueId = info[DEFER_BLOCK_ID] ?? null;
    ssrBlockState = info[DEFER_BLOCK_STATE$1];
  }
  const lDetails = [
    null,
    // NEXT_DEFER_BLOCK_STATE
    DeferBlockInternalState.Initial,
    // DEFER_BLOCK_STATE
    null,
    // STATE_IS_FROZEN_UNTIL
    null,
    // LOADING_AFTER_CLEANUP_FN
    null,
    // TRIGGER_CLEANUP_FNS
    null,
    // PREFETCH_TRIGGER_CLEANUP_FNS
    ssrUniqueId,
    // SSR_UNIQUE_ID
    ssrBlockState,
    // SSR_BLOCK_STATE
    null,
    // ON_COMPLETE_FNS
    null
    // HYDRATE_TRIGGER_CLEANUP_FNS
  ];
  setLDeferBlockDetails(lView, adjustedIndex, lDetails);
  let registry = null;
  if (ssrUniqueId !== null) {
    registry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    registry.add(ssrUniqueId, { lView, tNode, lContainer });
  }
  const onLViewDestroy = () => {
    invokeAllTriggerCleanupFns(lDetails);
    if (ssrUniqueId !== null) {
      registry?.cleanup([ssrUniqueId]);
    }
  };
  storeTriggerCleanupFn(0, lDetails, () => removeLViewOnDestroy(lView, onLViewDestroy));
  storeLViewOnDestroy(lView, onLViewDestroy);
}
function \u0275\u0275deferWhen(rawValue) {
  const lView = getLView();
  const tNode = getSelectedTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "when <expression>");
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      const value = Boolean(rawValue);
      const lDetails = getLDeferBlockDetails(lView, tNode);
      const renderedState = lDetails[DEFER_BLOCK_STATE];
      if (value === false && renderedState === DeferBlockInternalState.Initial) {
        renderPlaceholder(lView, tNode);
      } else if (value === true && (renderedState === DeferBlockInternalState.Initial || renderedState === DeferBlockState.Placeholder)) {
        triggerDeferBlock(0, lView, tNode);
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function \u0275\u0275deferPrefetchWhen(rawValue) {
  const lView = getLView();
  const tNode = getSelectedTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "prefetch when <expression>");
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      const value = Boolean(rawValue);
      const tView = lView[TVIEW];
      const tNode2 = getSelectedTNode();
      const tDetails = getTDeferBlockDetails(tView, tNode2);
      if (value === true && tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
        triggerPrefetching(tDetails, lView, tNode2);
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function \u0275\u0275deferHydrateWhen(rawValue) {
  const lView = getLView();
  const tNode = getSelectedTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "hydrate when <expression>");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const bindingIndex = nextBindingIndex();
  const tView = getTView();
  const hydrateTriggers = getHydrateTriggers(tView, tNode);
  hydrateTriggers.set(6, null);
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    if (false) {
      triggerDeferBlock(2, lView, tNode);
    } else {
      const injector = lView[INJECTOR];
      const prevConsumer = setActiveConsumer(null);
      try {
        const value = Boolean(rawValue);
        if (value === true) {
          const lDetails = getLDeferBlockDetails(lView, tNode);
          const ssrUniqueId = lDetails[SSR_UNIQUE_ID];
          ngDevMode && assertSsrIdDefined(ssrUniqueId);
          triggerHydrationFromBlockName(injector, ssrUniqueId);
        }
      } finally {
        setActiveConsumer(prevConsumer);
      }
    }
  }
}
function \u0275\u0275deferHydrateNever() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "hydrate never");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
  hydrateTriggers.set(7, null);
  if (false) {
    triggerDeferBlock(2, lView, tNode);
  }
}
function \u0275\u0275deferOnIdle() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "on idle");
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  scheduleDelayedTrigger(onIdle);
}
function \u0275\u0275deferPrefetchOnIdle() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "prefetch on idle");
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  scheduleDelayedPrefetching(onIdle);
}
function \u0275\u0275deferHydrateOnIdle() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "hydrate on idle");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
  hydrateTriggers.set(0, null);
  if (false) {
    triggerDeferBlock(2, lView, tNode);
  } else {
    scheduleDelayedHydrating(onIdle, lView, tNode);
  }
}
function \u0275\u0275deferOnImmediate() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "on immediate");
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  const tDetails = getTDeferBlockDetails(lView[TVIEW], tNode);
  if (tDetails.loadingTmplIndex === null) {
    renderPlaceholder(lView, tNode);
  }
  triggerDeferBlock(0, lView, tNode);
}
function \u0275\u0275deferPrefetchOnImmediate() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "prefetch on immediate");
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    triggerResourceLoading(tDetails, lView, tNode);
  }
}
function \u0275\u0275deferHydrateOnImmediate() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "hydrate on immediate");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
  hydrateTriggers.set(1, null);
  if (false) {
    triggerDeferBlock(2, lView, tNode);
  } else {
    const injector = lView[INJECTOR];
    const lDetails = getLDeferBlockDetails(lView, tNode);
    const ssrUniqueId = lDetails[SSR_UNIQUE_ID];
    ngDevMode && assertSsrIdDefined(ssrUniqueId);
    triggerHydrationFromBlockName(injector, ssrUniqueId);
  }
}
function \u0275\u0275deferOnTimer(delay) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, `on timer(${delay}ms)`);
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  scheduleDelayedTrigger(onTimer(delay));
}
function \u0275\u0275deferPrefetchOnTimer(delay) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, `prefetch on timer(${delay}ms)`);
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  scheduleDelayedPrefetching(onTimer(delay));
}
function \u0275\u0275deferHydrateOnTimer(delay) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, `hydrate on timer(${delay}ms)`);
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
  hydrateTriggers.set(5, { delay });
  if (false) {
    triggerDeferBlock(2, lView, tNode);
  } else {
    scheduleDelayedHydrating(onTimer(delay), lView, tNode);
  }
}
function \u0275\u0275deferOnHover(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, `on hover${walkUpTimes === -1 ? "" : "(<target>)"}`);
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  renderPlaceholder(lView, tNode);
  if (true) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onHover,
      () => triggerDeferBlock(0, lView, tNode),
      0
      /* TriggerType.Regular */
    );
  }
}
function \u0275\u0275deferPrefetchOnHover(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, `prefetch on hover${walkUpTimes === -1 ? "" : "(<target>)"}`);
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onHover,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function \u0275\u0275deferHydrateOnHover() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "hydrate on hover");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
  hydrateTriggers.set(4, null);
  if (false) {
    triggerDeferBlock(2, lView, tNode);
  }
}
function \u0275\u0275deferOnInteraction(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, `on interaction${walkUpTimes === -1 ? "" : "(<target>)"}`);
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  renderPlaceholder(lView, tNode);
  if (true) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onInteraction,
      () => triggerDeferBlock(0, lView, tNode),
      0
      /* TriggerType.Regular */
    );
  }
}
function \u0275\u0275deferPrefetchOnInteraction(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, `prefetch on interaction${walkUpTimes === -1 ? "" : "(<target>)"}`);
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onInteraction,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function \u0275\u0275deferHydrateOnInteraction() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "hydrate on interaction");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
  hydrateTriggers.set(3, null);
  if (false) {
    triggerDeferBlock(2, lView, tNode);
  }
}
function \u0275\u0275deferOnViewport(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, `on viewport${walkUpTimes === -1 ? "" : "(<target>)"}`);
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  renderPlaceholder(lView, tNode);
  if (true) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onViewportWrapper,
      () => triggerDeferBlock(0, lView, tNode),
      0
      /* TriggerType.Regular */
    );
  }
}
function \u0275\u0275deferPrefetchOnViewport(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, `prefetch on viewport${walkUpTimes === -1 ? "" : "(<target>)"}`);
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onViewportWrapper,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function \u0275\u0275deferHydrateOnViewport() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "hydrate on viewport");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
  hydrateTriggers.set(2, null);
  if (false) {
    triggerDeferBlock(2, lView, tNode);
  }
}
function \u0275\u0275attribute(name, value, sanitizer, namespace) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, "attr." + name, bindingIndex);
  }
  return \u0275\u0275attribute;
}
function \u0275\u0275componentInstance() {
  const instance = getLView()[DECLARATION_COMPONENT_VIEW][CONTEXT];
  ngDevMode && assertDefined(instance, "Expected component instance to be defined");
  return instance;
}
function valuesMatching(liveIdx, liveValue, newIdx, newValue, trackBy) {
  if (liveIdx === newIdx && Object.is(liveValue, newValue)) {
    return 1;
  } else if (Object.is(trackBy(liveIdx, liveValue), trackBy(newIdx, newValue))) {
    return -1;
  }
  return 0;
}
function recordDuplicateKeys(keyToIdx, key, idx) {
  const idxSoFar = keyToIdx.get(key);
  if (idxSoFar !== void 0) {
    idxSoFar.add(idx);
  } else {
    keyToIdx.set(key, /* @__PURE__ */ new Set([idx]));
  }
}
function reconcile(liveCollection, newCollection, trackByFn) {
  let detachedItems = void 0;
  let liveKeysInTheFuture = void 0;
  let liveStartIdx = 0;
  let liveEndIdx = liveCollection.length - 1;
  const duplicateKeys = ngDevMode ? /* @__PURE__ */ new Map() : void 0;
  if (Array.isArray(newCollection)) {
    let newEndIdx = newCollection.length - 1;
    while (liveStartIdx <= liveEndIdx && liveStartIdx <= newEndIdx) {
      const liveStartValue = liveCollection.at(liveStartIdx);
      const newStartValue = newCollection[liveStartIdx];
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(liveStartIdx, newStartValue), liveStartIdx);
      }
      const isStartMatching = valuesMatching(liveStartIdx, liveStartValue, liveStartIdx, newStartValue, trackByFn);
      if (isStartMatching !== 0) {
        if (isStartMatching < 0) {
          liveCollection.updateValue(liveStartIdx, newStartValue);
        }
        liveStartIdx++;
        continue;
      }
      const liveEndValue = liveCollection.at(liveEndIdx);
      const newEndValue = newCollection[newEndIdx];
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(newEndIdx, newEndValue), newEndIdx);
      }
      const isEndMatching = valuesMatching(liveEndIdx, liveEndValue, newEndIdx, newEndValue, trackByFn);
      if (isEndMatching !== 0) {
        if (isEndMatching < 0) {
          liveCollection.updateValue(liveEndIdx, newEndValue);
        }
        liveEndIdx--;
        newEndIdx--;
        continue;
      }
      const liveStartKey = trackByFn(liveStartIdx, liveStartValue);
      const liveEndKey = trackByFn(liveEndIdx, liveEndValue);
      const newStartKey = trackByFn(liveStartIdx, newStartValue);
      if (Object.is(newStartKey, liveEndKey)) {
        const newEndKey = trackByFn(newEndIdx, newEndValue);
        if (Object.is(newEndKey, liveStartKey)) {
          liveCollection.swap(liveStartIdx, liveEndIdx);
          liveCollection.updateValue(liveEndIdx, newEndValue);
          newEndIdx--;
          liveEndIdx--;
        } else {
          liveCollection.move(liveEndIdx, liveStartIdx);
        }
        liveCollection.updateValue(liveStartIdx, newStartValue);
        liveStartIdx++;
        continue;
      }
      detachedItems ??= new UniqueValueMultiKeyMap();
      liveKeysInTheFuture ??= initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);
      if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newStartKey)) {
        liveCollection.updateValue(liveStartIdx, newStartValue);
        liveStartIdx++;
        liveEndIdx++;
      } else if (!liveKeysInTheFuture.has(newStartKey)) {
        const newItem = liveCollection.create(liveStartIdx, newCollection[liveStartIdx]);
        liveCollection.attach(liveStartIdx, newItem);
        liveStartIdx++;
        liveEndIdx++;
      } else {
        detachedItems.set(liveStartKey, liveCollection.detach(liveStartIdx));
        liveEndIdx--;
      }
    }
    while (liveStartIdx <= newEndIdx) {
      createOrAttach(liveCollection, detachedItems, trackByFn, liveStartIdx, newCollection[liveStartIdx]);
      liveStartIdx++;
    }
  } else if (newCollection != null) {
    const newCollectionIterator = newCollection[Symbol.iterator]();
    let newIterationResult = newCollectionIterator.next();
    while (!newIterationResult.done && liveStartIdx <= liveEndIdx) {
      const liveValue = liveCollection.at(liveStartIdx);
      const newValue = newIterationResult.value;
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(liveStartIdx, newValue), liveStartIdx);
      }
      const isStartMatching = valuesMatching(liveStartIdx, liveValue, liveStartIdx, newValue, trackByFn);
      if (isStartMatching !== 0) {
        if (isStartMatching < 0) {
          liveCollection.updateValue(liveStartIdx, newValue);
        }
        liveStartIdx++;
        newIterationResult = newCollectionIterator.next();
      } else {
        detachedItems ??= new UniqueValueMultiKeyMap();
        liveKeysInTheFuture ??= initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);
        const newKey = trackByFn(liveStartIdx, newValue);
        if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newKey)) {
          liveCollection.updateValue(liveStartIdx, newValue);
          liveStartIdx++;
          liveEndIdx++;
          newIterationResult = newCollectionIterator.next();
        } else if (!liveKeysInTheFuture.has(newKey)) {
          liveCollection.attach(liveStartIdx, liveCollection.create(liveStartIdx, newValue));
          liveStartIdx++;
          liveEndIdx++;
          newIterationResult = newCollectionIterator.next();
        } else {
          const liveKey = trackByFn(liveStartIdx, liveValue);
          detachedItems.set(liveKey, liveCollection.detach(liveStartIdx));
          liveEndIdx--;
        }
      }
    }
    while (!newIterationResult.done) {
      createOrAttach(liveCollection, detachedItems, trackByFn, liveCollection.length, newIterationResult.value);
      newIterationResult = newCollectionIterator.next();
    }
  }
  while (liveStartIdx <= liveEndIdx) {
    liveCollection.destroy(liveCollection.detach(liveEndIdx--));
  }
  detachedItems?.forEach((item) => {
    liveCollection.destroy(item);
  });
  if (ngDevMode) {
    let duplicatedKeysMsg = [];
    for (const [key, idxSet] of duplicateKeys) {
      if (idxSet.size > 1) {
        const idx = [...idxSet].sort((a2, b2) => a2 - b2);
        for (let i2 = 1; i2 < idx.length; i2++) {
          duplicatedKeysMsg.push(`key "${stringifyForError(key)}" at index "${idx[i2 - 1]}" and "${idx[i2]}"`);
        }
      }
    }
    if (duplicatedKeysMsg.length > 0) {
      const message = formatRuntimeError(-955, "The provided track expression resulted in duplicated keys for a given collection. Adjust the tracking expression such that it uniquely identifies all the items in the collection. Duplicated keys were: \n" + duplicatedKeysMsg.join(", \n") + ".");
      console.warn(message);
    }
  }
}
function attachPreviouslyDetached(prevCollection, detachedItems, index, key) {
  if (detachedItems !== void 0 && detachedItems.has(key)) {
    prevCollection.attach(index, detachedItems.get(key));
    detachedItems.delete(key);
    return true;
  }
  return false;
}
function createOrAttach(liveCollection, detachedItems, trackByFn, index, value) {
  if (!attachPreviouslyDetached(liveCollection, detachedItems, index, trackByFn(index, value))) {
    const newItem = liveCollection.create(index, value);
    liveCollection.attach(index, newItem);
  } else {
    liveCollection.updateValue(index, value);
  }
}
function initLiveItemsInTheFuture(liveCollection, start, end, trackByFn) {
  const keys = /* @__PURE__ */ new Set();
  for (let i2 = start; i2 <= end; i2++) {
    keys.add(trackByFn(i2, liveCollection.at(i2)));
  }
  return keys;
}
function \u0275\u0275conditionalCreate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  performanceMarkFeature("NgControlFlow");
  const lView = getLView();
  const tView = getTView();
  const attrs = getConstant(tView.consts, attrsIndex);
  declareNoDirectiveHostTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, 256, localRefsIndex, localRefExtractor);
  return \u0275\u0275conditionalBranchCreate;
}
function \u0275\u0275conditionalBranchCreate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  performanceMarkFeature("NgControlFlow");
  const lView = getLView();
  const tView = getTView();
  const attrs = getConstant(tView.consts, attrsIndex);
  declareNoDirectiveHostTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, 512, localRefsIndex, localRefExtractor);
  return \u0275\u0275conditionalBranchCreate;
}
function \u0275\u0275conditional(matchingTemplateIndex, contextValue) {
  performanceMarkFeature("NgControlFlow");
  const hostLView = getLView();
  const bindingIndex = nextBindingIndex();
  const prevMatchingTemplateIndex = hostLView[bindingIndex] !== NO_CHANGE ? hostLView[bindingIndex] : -1;
  const prevContainer = prevMatchingTemplateIndex !== -1 ? getLContainer(hostLView, HEADER_OFFSET + prevMatchingTemplateIndex) : void 0;
  const viewInContainerIdx = 0;
  if (bindingUpdated(hostLView, bindingIndex, matchingTemplateIndex)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      if (prevContainer !== void 0) {
        removeLViewFromLContainer(prevContainer, viewInContainerIdx);
      }
      if (matchingTemplateIndex !== -1) {
        const nextLContainerIndex = HEADER_OFFSET + matchingTemplateIndex;
        const nextContainer = getLContainer(hostLView, nextLContainerIndex);
        const templateTNode = getExistingTNode(hostLView[TVIEW], nextLContainerIndex);
        const dehydratedView = findAndReconcileMatchingDehydratedViews(nextContainer, templateTNode, hostLView);
        const embeddedLView = createAndRenderEmbeddedLView(hostLView, templateTNode, contextValue, {
          dehydratedView
        });
        addLViewToLContainer(nextContainer, embeddedLView, viewInContainerIdx, shouldAddViewToDom(templateTNode, dehydratedView));
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  } else if (prevContainer !== void 0) {
    const lView = getLViewFromLContainer(prevContainer, viewInContainerIdx);
    if (lView !== void 0) {
      lView[CONTEXT] = contextValue;
    }
  }
}
function \u0275\u0275repeaterTrackByIndex(index) {
  return index;
}
function \u0275\u0275repeaterTrackByIdentity(_2, value) {
  return value;
}
function \u0275\u0275repeaterCreate(index, templateFn, decls, vars, tagName, attrsIndex, trackByFn, trackByUsesComponentInstance, emptyTemplateFn, emptyDecls, emptyVars, emptyTagName, emptyAttrsIndex) {
  performanceMarkFeature("NgControlFlow");
  ngDevMode && assertFunction(trackByFn, `A track expression must be a function, was ${typeof trackByFn} instead.`);
  const lView = getLView();
  const tView = getTView();
  const hasEmptyBlock = emptyTemplateFn !== void 0;
  const hostLView = getLView();
  const boundTrackBy = trackByUsesComponentInstance ? (
    // We only want to bind when necessary, because it produces a
    // new function. For pure functions it's not necessary.
    trackByFn.bind(hostLView[DECLARATION_COMPONENT_VIEW][CONTEXT])
  ) : trackByFn;
  const metadata = new RepeaterMetadata(hasEmptyBlock, boundTrackBy);
  hostLView[HEADER_OFFSET + index] = metadata;
  declareNoDirectiveHostTemplate(
    lView,
    tView,
    index + 1,
    templateFn,
    decls,
    vars,
    tagName,
    getConstant(tView.consts, attrsIndex),
    256
    /* TNodeFlags.isControlFlowStart */
  );
  if (hasEmptyBlock) {
    ngDevMode && assertDefined(emptyDecls, "Missing number of declarations for the empty repeater block.");
    ngDevMode && assertDefined(emptyVars, "Missing number of bindings for the empty repeater block.");
    declareNoDirectiveHostTemplate(
      lView,
      tView,
      index + 2,
      emptyTemplateFn,
      emptyDecls,
      emptyVars,
      emptyTagName,
      getConstant(tView.consts, emptyAttrsIndex),
      512
      /* TNodeFlags.isInControlFlow */
    );
  }
}
function isViewExpensiveToRecreate(lView) {
  return lView.length - HEADER_OFFSET > 2;
}
function \u0275\u0275repeater(collection) {
  const prevConsumer = setActiveConsumer(null);
  const metadataSlotIdx = getSelectedIndex();
  try {
    const hostLView = getLView();
    const hostTView = hostLView[TVIEW];
    const metadata = hostLView[metadataSlotIdx];
    const containerIndex = metadataSlotIdx + 1;
    const lContainer = getLContainer(hostLView, containerIndex);
    if (metadata.liveCollection === void 0) {
      const itemTemplateTNode = getExistingTNode(hostTView, containerIndex);
      metadata.liveCollection = new LiveCollectionLContainerImpl(lContainer, hostLView, itemTemplateTNode);
    } else {
      metadata.liveCollection.reset();
    }
    const liveCollection = metadata.liveCollection;
    reconcile(liveCollection, collection, metadata.trackByFn);
    if (ngDevMode && metadata.trackByFn === \u0275\u0275repeaterTrackByIdentity && liveCollection.operationsCounter?.wasReCreated(liveCollection.length) && isViewExpensiveToRecreate(getExistingLViewFromLContainer(lContainer, 0))) {
      const message = formatRuntimeError(-956, `The configured tracking expression (track by identity) caused re-creation of the entire collection of size ${liveCollection.length}. This is an expensive operation requiring destruction and subsequent creation of DOM nodes, directives, components etc. Please review the "track expression" and make sure that it uniquely identifies items in a collection.`);
      console.warn(message);
    }
    liveCollection.updateIndexes();
    if (metadata.hasEmptyBlock) {
      const bindingIndex = nextBindingIndex();
      const isCollectionEmpty = liveCollection.length === 0;
      if (bindingUpdated(hostLView, bindingIndex, isCollectionEmpty)) {
        const emptyTemplateIndex = metadataSlotIdx + 2;
        const lContainerForEmpty = getLContainer(hostLView, emptyTemplateIndex);
        if (isCollectionEmpty) {
          const emptyTemplateTNode = getExistingTNode(hostTView, emptyTemplateIndex);
          const dehydratedView = findAndReconcileMatchingDehydratedViews(lContainerForEmpty, emptyTemplateTNode, hostLView);
          const embeddedLView = createAndRenderEmbeddedLView(hostLView, emptyTemplateTNode, void 0, { dehydratedView });
          addLViewToLContainer(lContainerForEmpty, embeddedLView, 0, shouldAddViewToDom(emptyTemplateTNode, dehydratedView));
        } else {
          if (hostTView.firstUpdatePass) {
            removeDehydratedViews(lContainerForEmpty);
          }
          removeLViewFromLContainer(lContainerForEmpty, 0);
        }
      }
    }
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function getLContainer(lView, index) {
  const lContainer = lView[index];
  ngDevMode && assertLContainer(lContainer);
  return lContainer;
}
function detachExistingView(lContainer, index) {
  const existingLView = detachView(lContainer, index);
  ngDevMode && assertLView(existingLView);
  return existingLView;
}
function getExistingLViewFromLContainer(lContainer, index) {
  const existingLView = getLViewFromLContainer(lContainer, index);
  ngDevMode && assertLView(existingLView);
  return existingLView;
}
function getExistingTNode(tView, index) {
  const tNode = getTNode(tView, index);
  ngDevMode && assertTNode(tNode);
  return tNode;
}
function \u0275\u0275property(propName, value, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    setPropertyAndInputs(tNode, lView, propName, value, lView[RENDERER], sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275property;
}
function setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {
  setAllInputsForProperty(tNode, tView, lView, isClassBased ? "class" : "style", value);
}
function \u0275\u0275elementStart(index, name, attrsIndex, localRefsIndex) {
  const lView = getLView();
  ngDevMode && assertTNodeCreationIndex(lView, index);
  const tView = lView[TVIEW];
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? directiveHostFirstCreatePass(adjustedIndex, lView, 2, name, findDirectiveDefMatches, getBindingsEnabled(), attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  elementLikeStartShared(tNode, lView, index, name, _locateOrCreateElementNode);
  if (isDirectiveHost(tNode)) {
    const tView2 = lView[TVIEW];
    createDirectivesInstances(tView2, lView, tNode);
    executeContentQueries(tView2, tNode, lView);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  if (ngDevMode && lView[TVIEW].firstCreatePass) {
    validateElementIsKnown(lView, tNode);
  }
  return \u0275\u0275elementStart;
}
function \u0275\u0275elementEnd() {
  const tView = getTView();
  const initialTNode = getCurrentTNode();
  ngDevMode && assertDefined(initialTNode, "No parent node to close.");
  const currentTNode = elementLikeEndShared(initialTNode);
  ngDevMode && assertTNodeType(
    currentTNode,
    3
    /* TNodeType.AnyRNode */
  );
  if (tView.firstCreatePass) {
    directiveHostEndFirstCreatePass(tView, currentTNode);
  }
  if (isSkipHydrationRootTNode(currentTNode)) {
    leaveSkipHydrationBlock();
  }
  decreaseElementDepthCount();
  if (currentTNode.classesWithoutHost != null && hasClassInput(currentTNode)) {
    setDirectiveInputsWhichShadowsStyling(tView, currentTNode, getLView(), currentTNode.classesWithoutHost, true);
  }
  if (currentTNode.stylesWithoutHost != null && hasStyleInput(currentTNode)) {
    setDirectiveInputsWhichShadowsStyling(tView, currentTNode, getLView(), currentTNode.stylesWithoutHost, false);
  }
  return \u0275\u0275elementEnd;
}
function \u0275\u0275element(index, name, attrsIndex, localRefsIndex) {
  \u0275\u0275elementStart(index, name, attrsIndex, localRefsIndex);
  \u0275\u0275elementEnd();
  return \u0275\u0275element;
}
function \u0275\u0275domElementStart(index, name, attrsIndex, localRefsIndex) {
  const lView = getLView();
  ngDevMode && assertTNodeCreationIndex(lView, index);
  const tView = lView[TVIEW];
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? domOnlyFirstCreatePass(adjustedIndex, tView, 2, name, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  elementLikeStartShared(tNode, lView, index, name, _locateOrCreateElementNode);
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  if (ngDevMode && lView[TVIEW].firstCreatePass) {
    validateElementIsKnown(lView, tNode);
  }
  return \u0275\u0275domElementStart;
}
function \u0275\u0275domElementEnd() {
  const initialTNode = getCurrentTNode();
  ngDevMode && assertDefined(initialTNode, "No parent node to close.");
  const currentTNode = elementLikeEndShared(initialTNode);
  ngDevMode && assertTNodeType(
    currentTNode,
    3
    /* TNodeType.AnyRNode */
  );
  if (isSkipHydrationRootTNode(currentTNode)) {
    leaveSkipHydrationBlock();
  }
  decreaseElementDepthCount();
  return \u0275\u0275domElementEnd;
}
function \u0275\u0275domElement(index, name, attrsIndex, localRefsIndex) {
  \u0275\u0275domElementStart(index, name, attrsIndex, localRefsIndex);
  \u0275\u0275domElementEnd();
  return \u0275\u0275domElement;
}
function \u0275\u0275elementContainerStart(index, attrsIndex, localRefsIndex) {
  const lView = getLView();
  ngDevMode && assertTNodeCreationIndex(lView, index);
  const tView = lView[TVIEW];
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? directiveHostFirstCreatePass(adjustedIndex, lView, 8, "ng-container", findDirectiveDefMatches, getBindingsEnabled(), attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  elementLikeStartShared(tNode, lView, index, "ng-container", _locateOrCreateElementContainerNode);
  if (isDirectiveHost(tNode)) {
    const tView2 = lView[TVIEW];
    createDirectivesInstances(tView2, lView, tNode);
    executeContentQueries(tView2, tNode, lView);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  return \u0275\u0275elementContainerStart;
}
function \u0275\u0275elementContainerEnd() {
  const tView = getTView();
  const initialTNode = getCurrentTNode();
  ngDevMode && assertDefined(initialTNode, "No parent node to close.");
  const currentTNode = elementLikeEndShared(initialTNode);
  if (tView.firstCreatePass) {
    directiveHostEndFirstCreatePass(tView, currentTNode);
  }
  ngDevMode && assertTNodeType(
    currentTNode,
    8
    /* TNodeType.ElementContainer */
  );
  return \u0275\u0275elementContainerEnd;
}
function \u0275\u0275elementContainer(index, attrsIndex, localRefsIndex) {
  \u0275\u0275elementContainerStart(index, attrsIndex, localRefsIndex);
  \u0275\u0275elementContainerEnd();
  return \u0275\u0275elementContainer;
}
function \u0275\u0275domElementContainerStart(index, attrsIndex, localRefsIndex) {
  const lView = getLView();
  ngDevMode && assertTNodeCreationIndex(lView, index);
  const tView = lView[TVIEW];
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? domOnlyFirstCreatePass(adjustedIndex, tView, 8, "ng-container", attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  elementLikeStartShared(tNode, lView, index, "ng-container", _locateOrCreateElementContainerNode);
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  return \u0275\u0275domElementContainerStart;
}
function \u0275\u0275domElementContainerEnd() {
  const initialTNode = getCurrentTNode();
  ngDevMode && assertDefined(initialTNode, "No parent node to close.");
  const currentTNode = elementLikeEndShared(initialTNode);
  ngDevMode && assertTNodeType(
    currentTNode,
    8
    /* TNodeType.ElementContainer */
  );
  return \u0275\u0275elementContainerEnd;
}
function \u0275\u0275domElementContainer(index, attrsIndex, localRefsIndex) {
  \u0275\u0275domElementContainerStart(index, attrsIndex, localRefsIndex);
  \u0275\u0275domElementContainerEnd();
  return \u0275\u0275domElementContainer;
}
function \u0275\u0275getCurrentView() {
  return getLView();
}
function \u0275\u0275domProperty(propName, value, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    setDomProperty(tNode, lView, propName, value, lView[RENDERER], sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275domProperty;
}
function \u0275\u0275syntheticHostProperty(propName, value, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    const currentDef = getCurrentDirectiveDef(tView.data);
    const renderer = loadComponentRenderer(currentDef, tNode, lView);
    setDomProperty(tNode, lView, propName, value, renderer, sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275syntheticHostProperty;
}
function plural(val) {
  const i2 = Math.floor(Math.abs(val)), v = val.toString().replace(/^[^.]*\.?/, "").length;
  if (i2 === 1 && v === 0)
    return 1;
  return 5;
}
function findLocaleData(locale) {
  const normalizedLocale = normalizeLocale(locale);
  let match2 = getLocaleData(normalizedLocale);
  if (match2) {
    return match2;
  }
  const parentLocale = normalizedLocale.split("-")[0];
  match2 = getLocaleData(parentLocale);
  if (match2) {
    return match2;
  }
  if (parentLocale === "en") {
    return localeEn;
  }
  throw new RuntimeError(701, ngDevMode && `Missing locale data for the locale "${locale}".`);
}
function getLocalePluralCase(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.PluralCase];
}
function getLocaleData(normalizedLocale) {
  if (!(normalizedLocale in LOCALE_DATA)) {
    LOCALE_DATA[normalizedLocale] = _global.ng && _global.ng.common && _global.ng.common.locales && _global.ng.common.locales[normalizedLocale];
  }
  return LOCALE_DATA[normalizedLocale];
}
function normalizeLocale(locale) {
  return locale.toLowerCase().replace(/_/g, "-");
}
function getPluralCase(value, locale) {
  const plural2 = getLocalePluralCase(locale)(parseInt(value, 10));
  const result = pluralMapping[plural2];
  return result !== void 0 ? result : "other";
}
function setLocaleId(localeId) {
  ngDevMode && assertDefined(localeId, `Expected localeId to be defined`);
  if (typeof localeId === "string") {
    LOCALE_ID$1 = localeId.toLowerCase().replace(/_/g, "-");
  }
}
function getLocaleId() {
  return LOCALE_ID$1;
}
function setMaskBit(hasChange) {
  if (hasChange) {
    changeMask = changeMask | 1 << Math.min(changeMaskCounter, 31);
  }
  changeMaskCounter++;
}
function applyI18n(tView, lView, index) {
  if (changeMaskCounter > 0) {
    ngDevMode && assertDefined(tView, `tView should be defined`);
    const tI18n = tView.data[index];
    const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;
    const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;
    applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);
  }
  changeMask = 0;
  changeMaskCounter = 0;
}
function createNodeWithoutHydration(lView, textOrName, nodeType) {
  const renderer = lView[RENDERER];
  switch (nodeType) {
    case Node.COMMENT_NODE:
      return createCommentNode(renderer, textOrName);
    case Node.TEXT_NODE:
      return createTextNode(renderer, textOrName);
    case Node.ELEMENT_NODE:
      return createElementNode(renderer, textOrName, null);
  }
}
function applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {
  const renderer = lView[RENDERER];
  for (let i2 = 0; i2 < createOpCodes.length; i2++) {
    const opCode = createOpCodes[i2++];
    const text = createOpCodes[i2];
    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
    const index = opCode >>> I18nCreateOpCode.SHIFT;
    let rNode = lView[index];
    let lastNodeWasCreated2 = false;
    if (rNode === null) {
      rNode = lView[index] = _locateOrCreateNode(lView, index, text, isComment ? Node.COMMENT_NODE : Node.TEXT_NODE);
      lastNodeWasCreated2 = wasLastNodeCreated();
    }
    if (appendNow && parentRNode !== null && lastNodeWasCreated2) {
      nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);
    }
  }
}
function applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {
  ngDevMode && assertDomNode(anchorRNode);
  const renderer = lView[RENDERER];
  let rootIdx = null;
  let rootRNode;
  for (let i2 = 0; i2 < mutableOpCodes.length; i2++) {
    const opCode = mutableOpCodes[i2];
    if (typeof opCode == "string") {
      const textNodeIndex = mutableOpCodes[++i2];
      if (lView[textNodeIndex] === null) {
        ngDevMode && assertIndexInRange(lView, textNodeIndex);
        lView[textNodeIndex] = _locateOrCreateNode(lView, textNodeIndex, opCode, Node.TEXT_NODE);
      }
    } else if (typeof opCode == "number") {
      switch (opCode & 1) {
        case 0:
          const parentIdx = getParentFromIcuCreateOpCode(opCode);
          if (rootIdx === null) {
            rootIdx = parentIdx;
            rootRNode = renderer.parentNode(anchorRNode);
          }
          let insertInFrontOf;
          let parentRNode;
          if (parentIdx === rootIdx) {
            insertInFrontOf = anchorRNode;
            parentRNode = rootRNode;
          } else {
            insertInFrontOf = null;
            parentRNode = unwrapRNode(lView[parentIdx]);
          }
          if (parentRNode !== null) {
            ngDevMode && assertDomNode(parentRNode);
            const refIdx = getRefFromIcuCreateOpCode(opCode);
            ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, "Missing ref");
            const child = lView[refIdx];
            ngDevMode && assertDomNode(child);
            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);
            const tIcu = getTIcu(tView, refIdx);
            if (tIcu !== null && typeof tIcu === "object") {
              ngDevMode && assertTIcu(tIcu);
              const caseIndex = getCurrentICUCaseIndex(tIcu, lView);
              if (caseIndex !== null) {
                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);
              }
            }
          }
          break;
        case 1:
          const elementNodeIndex = opCode >>> 1;
          const attrName = mutableOpCodes[++i2];
          const attrValue = mutableOpCodes[++i2];
          setElementAttribute(renderer, getNativeByIndex(elementNodeIndex, lView), null, null, attrName, attrValue, null);
          break;
        default:
          if (ngDevMode) {
            throw new RuntimeError(700, `Unable to determine the type of mutate operation for "${opCode}"`);
          }
      }
    } else {
      switch (opCode) {
        case ICU_MARKER:
          const commentValue = mutableOpCodes[++i2];
          const commentNodeIndex = mutableOpCodes[++i2];
          if (lView[commentNodeIndex] === null) {
            ngDevMode && assertEqual(typeof commentValue, "string", `Expected "${commentValue}" to be a comment node value`);
            ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);
            const commentRNode = lView[commentNodeIndex] = _locateOrCreateNode(lView, commentNodeIndex, commentValue, Node.COMMENT_NODE);
            attachPatchData(commentRNode, lView);
          }
          break;
        case ELEMENT_MARKER:
          const tagName = mutableOpCodes[++i2];
          const elementNodeIndex = mutableOpCodes[++i2];
          if (lView[elementNodeIndex] === null) {
            ngDevMode && assertEqual(typeof tagName, "string", `Expected "${tagName}" to be an element node tag name`);
            ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);
            const elementRNode = lView[elementNodeIndex] = _locateOrCreateNode(lView, elementNodeIndex, tagName, Node.ELEMENT_NODE);
            attachPatchData(elementRNode, lView);
          }
          break;
        default:
          ngDevMode && throwError2(`Unable to determine the type of mutate operation for "${opCode}"`);
      }
    }
  }
}
function applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask2) {
  for (let i2 = 0; i2 < updateOpCodes.length; i2++) {
    const checkBit = updateOpCodes[i2];
    const skipCodes = updateOpCodes[++i2];
    if (checkBit & changeMask2) {
      let value = "";
      for (let j2 = i2 + 1; j2 <= i2 + skipCodes; j2++) {
        const opCode = updateOpCodes[j2];
        if (typeof opCode == "string") {
          value += opCode;
        } else if (typeof opCode == "number") {
          if (opCode < 0) {
            value += renderStringify(lView[bindingsStartIndex - opCode]);
          } else {
            const nodeIndex = opCode >>> 2;
            switch (opCode & 3) {
              case 1:
                const propName = updateOpCodes[++j2];
                const sanitizeFn = updateOpCodes[++j2];
                const tNodeOrTagName = tView.data[nodeIndex];
                ngDevMode && assertDefined(tNodeOrTagName, "Experting TNode or string");
                if (typeof tNodeOrTagName === "string") {
                  setElementAttribute(lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value, sanitizeFn);
                } else {
                  setPropertyAndInputs(tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn);
                }
                break;
              case 0:
                const rText = lView[nodeIndex];
                rText !== null && updateTextNode(lView[RENDERER], rText, value);
                break;
              case 2:
                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);
                break;
              case 3:
                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);
                break;
            }
          }
        }
      }
    } else {
      const opCode = updateOpCodes[i2 + 1];
      if (opCode > 0 && (opCode & 3) === 3) {
        const nodeIndex = opCode >>> 2;
        const tIcu = getTIcu(tView, nodeIndex);
        const currentIndex = lView[tIcu.currentCaseLViewIndex];
        if (currentIndex < 0) {
          applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);
        }
      }
    }
    i2 += skipCodes;
  }
}
function applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {
  ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);
  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];
  if (activeCaseIndex !== null) {
    let mask = changeMask;
    if (activeCaseIndex < 0) {
      activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;
      mask = -1;
    }
    applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);
  }
}
function applyIcuSwitchCase(tView, tIcu, lView, value) {
  const caseIndex = getCaseIndex(tIcu, value);
  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
  if (activeCaseIndex !== caseIndex) {
    applyIcuSwitchCaseRemove(tView, tIcu, lView);
    lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;
    if (caseIndex !== null) {
      const anchorRNode = lView[tIcu.anchorIdx];
      if (anchorRNode) {
        ngDevMode && assertDomNode(anchorRNode);
        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);
      }
      claimDehydratedIcuCase(lView, tIcu.anchorIdx, caseIndex);
    }
  }
}
function applyIcuSwitchCaseRemove(tView, tIcu, lView) {
  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
  if (activeCaseIndex !== null) {
    const removeCodes = tIcu.remove[activeCaseIndex];
    for (let i2 = 0; i2 < removeCodes.length; i2++) {
      const nodeOrIcuIndex = removeCodes[i2];
      if (nodeOrIcuIndex > 0) {
        const rNode = getNativeByIndex(nodeOrIcuIndex, lView);
        rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);
      } else {
        applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);
      }
    }
  }
}
function getCaseIndex(icuExpression, bindingValue) {
  let index = icuExpression.cases.indexOf(bindingValue);
  if (index === -1) {
    switch (icuExpression.type) {
      case 1: {
        const resolvedCase = getPluralCase(bindingValue, getLocaleId());
        index = icuExpression.cases.indexOf(resolvedCase);
        if (index === -1 && resolvedCase !== "other") {
          index = icuExpression.cases.indexOf("other");
        }
        break;
      }
      case 0: {
        index = icuExpression.cases.indexOf("other");
        break;
      }
    }
  }
  return index === -1 ? null : index;
}
function i18nCreateOpCodesToString(opcodes) {
  const createOpCodes = opcodes || (Array.isArray(this) ? this : []);
  let lines = [];
  for (let i2 = 0; i2 < createOpCodes.length; i2++) {
    const opCode = createOpCodes[i2++];
    const text = createOpCodes[i2];
    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
    const index = opCode >>> I18nCreateOpCode.SHIFT;
    lines.push(`lView[${index}] = document.${isComment ? "createComment" : "createText"}(${JSON.stringify(text)});`);
    if (appendNow) {
      lines.push(`parent.appendChild(lView[${index}]);`);
    }
  }
  return lines;
}
function i18nUpdateOpCodesToString(opcodes) {
  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
  let lines = [];
  function consumeOpCode(value) {
    const ref = value >>> 2;
    const opCode = value & 3;
    switch (opCode) {
      case 0:
        return `(lView[${ref}] as Text).textContent = $$$`;
      case 1:
        const attrName = parser.consumeString();
        const sanitizationFn = parser.consumeFunction();
        const value2 = sanitizationFn ? `(${sanitizationFn})($$$)` : "$$$";
        return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value2})`;
      case 2:
        return `icuSwitchCase(${ref}, $$$)`;
      case 3:
        return `icuUpdateCase(${ref})`;
    }
    throw new Error("unexpected OpCode");
  }
  while (parser.hasMore()) {
    let mask = parser.consumeNumber();
    let size = parser.consumeNumber();
    const end = parser.i + size;
    const statements = [];
    let statement = "";
    while (parser.i < end) {
      let value = parser.consumeNumberOrString();
      if (typeof value === "string") {
        statement += value;
      } else if (value < 0) {
        statement += "${lView[i" + value + "]}";
      } else {
        const opCodeText = consumeOpCode(value);
        statements.push(opCodeText.replace("$$$", "`" + statement + "`") + ";");
        statement = "";
      }
    }
    lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(" ")} }`);
  }
  return lines;
}
function icuCreateOpCodesToString(opcodes) {
  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
  let lines = [];
  function consumeOpCode(opCode) {
    const parent = getParentFromIcuCreateOpCode(opCode);
    const ref = getRefFromIcuCreateOpCode(opCode);
    switch (getInstructionFromIcuCreateOpCode(opCode)) {
      case 0:
        return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;
      case 1:
        return `(lView[${ref}] as Element).setAttribute("${parser.consumeString()}", "${parser.consumeString()}")`;
    }
    throw new Error("Unexpected OpCode: " + getInstructionFromIcuCreateOpCode(opCode));
  }
  let lastRef = -1;
  while (parser.hasMore()) {
    let value = parser.consumeNumberStringOrMarker();
    if (value === ICU_MARKER) {
      const text = parser.consumeString();
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createComment("${text}")`);
    } else if (value === ELEMENT_MARKER) {
      const text = parser.consumeString();
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createElement("${text}")`);
    } else if (typeof value === "string") {
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createTextNode("${value}")`);
    } else if (typeof value === "number") {
      const line = consumeOpCode(value);
      line && lines.push(line);
    } else {
      throw new Error("Unexpected value");
    }
  }
  return lines;
}
function i18nRemoveOpCodesToString(opcodes) {
  const removeCodes = opcodes || (Array.isArray(this) ? this : []);
  let lines = [];
  for (let i2 = 0; i2 < removeCodes.length; i2++) {
    const nodeOrIcuIndex = removeCodes[i2];
    if (nodeOrIcuIndex > 0) {
      lines.push(`remove(lView[${nodeOrIcuIndex}])`);
    } else {
      lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);
    }
  }
  return lines;
}
function replaceNgsp(value) {
  return value.replace(NGSP_UNICODE_REGEXP, " ");
}
function attachDebugGetter(obj, debugGetter) {
  if (ngDevMode) {
    Object.defineProperty(obj, "debug", { get: debugGetter, enumerable: false });
  } else {
    throw new Error("This method should be guarded with `ngDevMode` so that it can be tree shaken in production!");
  }
}
function i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index, message, subTemplateIndex) {
  const rootTNode = getCurrentParentTNode();
  const createOpCodes = [];
  const updateOpCodes = [];
  const existingTNodeStack = [[]];
  const astStack = [[]];
  if (ngDevMode) {
    attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  message = getTranslationForTemplate(message, subTemplateIndex);
  const msgParts = replaceNgsp(message).split(PH_REGEXP);
  for (let i2 = 0; i2 < msgParts.length; i2++) {
    let value = msgParts[i2];
    if ((i2 & 1) === 0) {
      const parts = i18nParseTextIntoPartsAndICU(value);
      for (let j2 = 0; j2 < parts.length; j2++) {
        let part = parts[j2];
        if ((j2 & 1) === 0) {
          const text = part;
          ngDevMode && assertString(text, "Parsed ICU part should be string");
          if (text !== "") {
            i18nStartFirstCreatePassProcessTextNode(astStack[0], tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);
          }
        } else {
          const icuExpression = part;
          if (typeof icuExpression !== "object") {
            throw new Error(`Unable to parse ICU expression in "${message}" message.`);
          }
          const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : "", true);
          const icuNodeIndex = icuContainerTNode.index;
          ngDevMode && assertGreaterThanOrEqual(icuNodeIndex, HEADER_OFFSET, "Index must be in absolute LView offset");
          icuStart(astStack[0], tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);
        }
      }
    } else {
      const isClosing = value.charCodeAt(0) === 47;
      const type = value.charCodeAt(isClosing ? 1 : 0);
      ngDevMode && assertOneOf(
        type,
        42,
        35
        /* CharCode.HASH */
      );
      const index2 = HEADER_OFFSET + Number.parseInt(value.substring(isClosing ? 2 : 1));
      if (isClosing) {
        existingTNodeStack.shift();
        astStack.shift();
        setCurrentTNode(getCurrentParentTNode(), false);
      } else {
        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index2);
        existingTNodeStack.unshift([]);
        setCurrentTNode(tNode, true);
        const placeholderNode = {
          kind: 2,
          index: index2,
          children: [],
          type: type === 35 ? 0 : 1
        };
        astStack[0].push(placeholderNode);
        astStack.unshift(placeholderNode.children);
      }
    }
  }
  tView.data[index] = {
    create: createOpCodes,
    update: updateOpCodes,
    ast: astStack[0],
    parentTNodeIndex
  };
}
function createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {
  const i18nNodeIdx = allocExpando(tView, lView, 1, null);
  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;
  let parentTNode = getCurrentParentTNode();
  if (rootTNode === parentTNode) {
    parentTNode = null;
  }
  if (parentTNode === null) {
    opCode |= I18nCreateOpCode.APPEND_EAGERLY;
  }
  if (isICU) {
    opCode |= I18nCreateOpCode.COMMENT;
    ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);
  }
  createOpCodes.push(opCode, text === null ? "" : text);
  const tNode = createTNodeAtIndex(tView, i18nNodeIdx, isICU ? 32 : 1, text === null ? ngDevMode ? "{{?}}" : "" : text, null);
  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);
  const tNodeIdx = tNode.index;
  setCurrentTNode(
    tNode,
    false
    /* Text nodes are self closing */
  );
  if (parentTNode !== null && rootTNode !== parentTNode) {
    setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);
  }
  return tNode;
}
function i18nStartFirstCreatePassProcessTextNode(ast, tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {
  const hasBinding = text.match(BINDING_REGEXP);
  const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);
  const index = tNode.index;
  if (hasBinding) {
    generateBindingUpdateOpCodes(updateOpCodes, text, index, null, 0, null);
  }
  ast.push({ kind: 0, index });
}
function i18nAttributesFirstPass(tView, index, values) {
  const previousElement = getCurrentTNode();
  const previousElementIndex = previousElement.index;
  const updateOpCodes = [];
  if (ngDevMode) {
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  if (tView.firstCreatePass && tView.data[index] === null) {
    for (let i2 = 0; i2 < values.length; i2 += 2) {
      const attrName = values[i2];
      const message = values[i2 + 1];
      if (message !== "") {
        if (ICU_REGEXP.test(message)) {
          throw new Error(`ICU expressions are not supported in attributes. Message: "${message}".`);
        }
        generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes), null);
      }
    }
    tView.data[index] = updateOpCodes;
  }
}
function generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {
  ngDevMode && assertGreaterThanOrEqual(destinationNode, HEADER_OFFSET, "Index must be in absolute LView offset");
  const maskIndex = updateOpCodes.length;
  const sizeIndex = maskIndex + 1;
  updateOpCodes.push(null, null);
  const startIndex = maskIndex + 2;
  if (ngDevMode) {
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  const textParts = str.split(BINDING_REGEXP);
  let mask = 0;
  for (let j2 = 0; j2 < textParts.length; j2++) {
    const textValue = textParts[j2];
    if (j2 & 1) {
      const bindingIndex = bindingStart + parseInt(textValue, 10);
      updateOpCodes.push(-1 - bindingIndex);
      mask = mask | toMaskBit(bindingIndex);
    } else if (textValue !== "") {
      updateOpCodes.push(textValue);
    }
  }
  updateOpCodes.push(destinationNode << 2 | (attrName ? 1 : 0));
  if (attrName) {
    updateOpCodes.push(attrName, sanitizeFn);
  }
  updateOpCodes[maskIndex] = mask;
  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;
  return mask;
}
function countBindings(opCodes) {
  let count = 0;
  for (let i2 = 0; i2 < opCodes.length; i2++) {
    const opCode = opCodes[i2];
    if (typeof opCode === "number" && opCode < 0) {
      count++;
    }
  }
  return count;
}
function toMaskBit(bindingIndex) {
  return 1 << Math.min(bindingIndex, 31);
}
function removeInnerTemplateTranslation(message) {
  let match2;
  let res = "";
  let index = 0;
  let inTemplate = false;
  let tagMatched;
  while ((match2 = SUBTEMPLATE_REGEXP.exec(message)) !== null) {
    if (!inTemplate) {
      res += message.substring(index, match2.index + match2[0].length);
      tagMatched = match2[1];
      inTemplate = true;
    } else {
      if (match2[0] === `${MARKER}/*${tagMatched}${MARKER}`) {
        index = match2.index;
        inTemplate = false;
      }
    }
  }
  ngDevMode && assertEqual(inTemplate, false, `Tag mismatch: unable to find the end of the sub-template in the translation "${message}"`);
  res += message.slice(index);
  return res;
}
function getTranslationForTemplate(message, subTemplateIndex) {
  if (isRootTemplateMessage(subTemplateIndex)) {
    return removeInnerTemplateTranslation(message);
  } else {
    const start = message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;
    const end = message.search(new RegExp(`${MARKER}\\/\\*\\d+:${subTemplateIndex}${MARKER}`));
    return removeInnerTemplateTranslation(message.substring(start, end));
  }
}
function icuStart(ast, tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {
  ngDevMode && assertDefined(icuExpression, "ICU expression must be defined");
  let bindingMask = 0;
  const tIcu = {
    type: icuExpression.type,
    currentCaseLViewIndex: allocExpando(tView, lView, 1, null),
    anchorIdx,
    cases: [],
    create: [],
    remove: [],
    update: []
  };
  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);
  setTIcu(tView, anchorIdx, tIcu);
  const values = icuExpression.values;
  const cases = [];
  for (let i2 = 0; i2 < values.length; i2++) {
    const valueArr = values[i2];
    const nestedIcus = [];
    for (let j2 = 0; j2 < valueArr.length; j2++) {
      const value = valueArr[j2];
      if (typeof value !== "string") {
        const icuIndex = nestedIcus.push(value) - 1;
        valueArr[j2] = `<!--\uFFFD${icuIndex}\uFFFD-->`;
      }
    }
    const caseAst = [];
    cases.push(caseAst);
    bindingMask = parseIcuCase(caseAst, tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i2], valueArr.join(""), nestedIcus) | bindingMask;
  }
  if (bindingMask) {
    addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);
  }
  ast.push({
    kind: 3,
    index: anchorIdx,
    cases,
    currentCaseLViewIndex: tIcu.currentCaseLViewIndex
  });
}
function parseICUBlock(pattern) {
  const cases = [];
  const values = [];
  let icuType = 1;
  let mainBinding = 0;
  pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str, binding, type) {
    if (type === "select") {
      icuType = 0;
    } else {
      icuType = 1;
    }
    mainBinding = parseInt(binding.slice(1), 10);
    return "";
  });
  const parts = i18nParseTextIntoPartsAndICU(pattern);
  for (let pos = 0; pos < parts.length; ) {
    let key = parts[pos++].trim();
    if (icuType === 1) {
      key = key.replace(/\s*(?:=)?(\w+)\s*/, "$1");
    }
    if (key.length) {
      cases.push(key);
    }
    const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);
    if (cases.length > values.length) {
      values.push(blocks);
    }
  }
  return { type: icuType, mainBinding, cases, values };
}
function i18nParseTextIntoPartsAndICU(pattern) {
  if (!pattern) {
    return [];
  }
  let prevPos = 0;
  const braceStack = [];
  const results = [];
  const braces = /[{}]/g;
  braces.lastIndex = 0;
  let match2;
  while (match2 = braces.exec(pattern)) {
    const pos = match2.index;
    if (match2[0] == "}") {
      braceStack.pop();
      if (braceStack.length == 0) {
        const block = pattern.substring(prevPos, pos);
        if (ICU_BLOCK_REGEXP.test(block)) {
          results.push(parseICUBlock(block));
        } else {
          results.push(block);
        }
        prevPos = pos + 1;
      }
    } else {
      if (braceStack.length == 0) {
        const substring2 = pattern.substring(prevPos, pos);
        results.push(substring2);
        prevPos = pos + 1;
      }
      braceStack.push("{");
    }
  }
  const substring = pattern.substring(prevPos);
  results.push(substring);
  return results;
}
function parseIcuCase(ast, tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {
  const create = [];
  const remove2 = [];
  const update = [];
  if (ngDevMode) {
    attachDebugGetter(create, icuCreateOpCodesToString);
    attachDebugGetter(remove2, i18nRemoveOpCodesToString);
    attachDebugGetter(update, i18nUpdateOpCodesToString);
  }
  tIcu.cases.push(caseName);
  tIcu.create.push(create);
  tIcu.remove.push(remove2);
  tIcu.update.push(update);
  const inertBodyHelper2 = getInertBodyHelper(getDocument());
  const inertBodyElement = inertBodyHelper2.getInertBodyElement(unsafeCaseHtml);
  ngDevMode && assertDefined(inertBodyElement, "Unable to generate inert body element");
  const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;
  if (inertRootNode) {
    return walkIcuTree(ast, tView, tIcu, lView, updateOpCodes, create, remove2, update, inertRootNode, parentIdx, nestedIcus, 0);
  } else {
    return 0;
  }
}
function walkIcuTree(ast, tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, parentNode, parentIdx, nestedIcus, depth) {
  let bindingMask = 0;
  let currentNode = parentNode.firstChild;
  while (currentNode) {
    const newIndex = allocExpando(tView, lView, 1, null);
    switch (currentNode.nodeType) {
      case Node.ELEMENT_NODE:
        const element = currentNode;
        const tagName = element.tagName.toLowerCase();
        if (VALID_ELEMENTS.hasOwnProperty(tagName)) {
          addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);
          tView.data[newIndex] = tagName;
          const elAttrs = element.attributes;
          for (let i2 = 0; i2 < elAttrs.length; i2++) {
            const attr = elAttrs.item(i2);
            const lowerAttrName = attr.name.toLowerCase();
            const hasBinding2 = !!attr.value.match(BINDING_REGEXP);
            if (hasBinding2) {
              if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {
                if (URI_ATTRS[lowerAttrName]) {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);
                } else {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);
                }
              } else {
                ngDevMode && console.warn(`WARNING: ignoring unsafe attribute value ${lowerAttrName} on element ${tagName} (see ${XSS_SECURITY_URL})`);
              }
            } else {
              addCreateAttribute(create, newIndex, attr);
            }
          }
          const elementNode = {
            kind: 1,
            index: newIndex,
            children: []
          };
          ast.push(elementNode);
          bindingMask = walkIcuTree(elementNode.children, tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, currentNode, newIndex, nestedIcus, depth + 1) | bindingMask;
          addRemoveNode(remove2, newIndex, depth);
        }
        break;
      case Node.TEXT_NODE:
        const value = currentNode.textContent || "";
        const hasBinding = value.match(BINDING_REGEXP);
        addCreateNodeAndAppend(create, null, hasBinding ? "" : value, parentIdx, newIndex);
        addRemoveNode(remove2, newIndex, depth);
        if (hasBinding) {
          bindingMask = generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;
        }
        ast.push({
          kind: 0,
          index: newIndex
        });
        break;
      case Node.COMMENT_NODE:
        const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || "");
        if (isNestedIcu) {
          const nestedIcuIndex = parseInt(isNestedIcu[1], 10);
          const icuExpression = nestedIcus[nestedIcuIndex];
          addCreateNodeAndAppend(create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : "", parentIdx, newIndex);
          icuStart(ast, tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);
          addRemoveNestedIcu(remove2, newIndex, depth);
        }
        break;
    }
    currentNode = currentNode.nextSibling;
  }
  return bindingMask;
}
function addRemoveNode(remove2, index, depth) {
  if (depth === 0) {
    remove2.push(index);
  }
}
function addRemoveNestedIcu(remove2, index, depth) {
  if (depth === 0) {
    remove2.push(~index);
    remove2.push(index);
  }
}
function addUpdateIcuSwitch(update, icuExpression, index) {
  update.push(
    toMaskBit(icuExpression.mainBinding),
    2,
    -1 - icuExpression.mainBinding,
    index << 2 | 2
    /* I18nUpdateOpCode.IcuSwitch */
  );
}
function addUpdateIcuUpdate(update, bindingMask, index) {
  update.push(
    bindingMask,
    1,
    index << 2 | 3
    /* I18nUpdateOpCode.IcuUpdate */
  );
}
function addCreateNodeAndAppend(create, marker, text, appendToParentIdx, createAtIdx) {
  if (marker !== null) {
    create.push(marker);
  }
  create.push(text, createAtIdx, icuCreateOpCode(0, appendToParentIdx, createAtIdx));
}
function addCreateAttribute(create, newIndex, attr) {
  create.push(newIndex << 1 | 1, attr.name, attr.value);
}
function i18nPostprocess(message, replacements = {}) {
  let result = message;
  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {
    const matches = {};
    const templateIdsStack = [ROOT_TEMPLATE_ID];
    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl) => {
      const content = phs || tmpl;
      const placeholders = matches[content] || [];
      if (!placeholders.length) {
        content.split("|").forEach((placeholder2) => {
          const match2 = placeholder2.match(PP_TEMPLATE_ID_REGEXP);
          const templateId2 = match2 ? parseInt(match2[1], 10) : ROOT_TEMPLATE_ID;
          const isCloseTemplateTag2 = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder2);
          placeholders.push([templateId2, isCloseTemplateTag2, placeholder2]);
        });
        matches[content] = placeholders;
      }
      if (!placeholders.length) {
        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);
      }
      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];
      let idx = 0;
      for (let i2 = 0; i2 < placeholders.length; i2++) {
        if (placeholders[i2][0] === currentTemplateId) {
          idx = i2;
          break;
        }
      }
      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];
      if (isCloseTemplateTag) {
        templateIdsStack.pop();
      } else if (currentTemplateId !== templateId) {
        templateIdsStack.push(templateId);
      }
      placeholders.splice(idx, 1);
      return placeholder;
    });
  }
  if (!Object.keys(replacements).length) {
    return result;
  }
  result = result.replace(PP_ICU_VARS_REGEXP, (match2, start, key, _type, _idx, end) => {
    return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match2;
  });
  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match2, key) => {
    return replacements.hasOwnProperty(key) ? replacements[key] : match2;
  });
  result = result.replace(PP_ICUS_REGEXP, (match2, key) => {
    if (replacements.hasOwnProperty(key)) {
      const list = replacements[key];
      if (!list.length) {
        throw new Error(`i18n postprocess: unmatched ICU - ${match2} with key: ${key}`);
      }
      return list.shift();
    }
    return match2;
  });
  return result;
}
function \u0275\u0275i18nStart(index, messageIndex, subTemplateIndex = -1) {
  const tView = getTView();
  const lView = getLView();
  const adjustedIndex = HEADER_OFFSET + index;
  ngDevMode && assertDefined(tView, `tView should be defined`);
  const message = getConstant(tView.consts, messageIndex);
  const parentTNode = getCurrentParentTNode();
  if (tView.firstCreatePass) {
    i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message, subTemplateIndex);
  }
  if (tView.type === 2) {
    const componentLView = lView[DECLARATION_COMPONENT_VIEW];
    componentLView[FLAGS] |= 32;
  } else {
    lView[FLAGS] |= 32;
  }
  const tI18n = tView.data[adjustedIndex];
  const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;
  const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);
  const insertInFrontOf = parentTNode && parentTNode.type & 8 ? lView[parentTNode.index] : null;
  prepareI18nBlockForHydration(lView, adjustedIndex, parentTNode, subTemplateIndex);
  applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);
  setInI18nBlock(true);
}
function \u0275\u0275i18nEnd() {
  setInI18nBlock(false);
}
function \u0275\u0275i18n(index, messageIndex, subTemplateIndex) {
  \u0275\u0275i18nStart(index, messageIndex, subTemplateIndex);
  \u0275\u0275i18nEnd();
}
function \u0275\u0275i18nAttributes(index, attrsIndex) {
  const tView = getTView();
  ngDevMode && assertDefined(tView, `tView should be defined`);
  const attrs = getConstant(tView.consts, attrsIndex);
  i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);
}
function \u0275\u0275i18nExp(value) {
  const lView = getLView();
  setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));
  return \u0275\u0275i18nExp;
}
function \u0275\u0275i18nApply(index) {
  applyI18n(getTView(), getLView(), index + HEADER_OFFSET);
}
function \u0275\u0275i18nPostprocess(message, replacements = {}) {
  return i18nPostprocess(message, replacements);
}
function \u0275\u0275listener(eventName, listenerFn, eventTargetResolver) {
  const lView = getLView();
  const tView = getTView();
  const tNode = getCurrentTNode();
  listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn, eventTargetResolver);
  return \u0275\u0275listener;
}
function \u0275\u0275syntheticHostListener(eventName, listenerFn) {
  const tNode = getCurrentTNode();
  const lView = getLView();
  const tView = getTView();
  const currentDef = getCurrentDirectiveDef(tView.data);
  const renderer = loadComponentRenderer(currentDef, tNode, lView);
  listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn);
  return \u0275\u0275syntheticHostListener;
}
function \u0275\u0275domListener(eventName, listenerFn, eventTargetResolver) {
  const lView = getLView();
  const tView = getTView();
  const tNode = getCurrentTNode();
  if (tNode.type & 3 || eventTargetResolver) {
    listenToDomEvent(tNode, tView, lView, eventTargetResolver, lView[RENDERER], eventName, listenerFn, wrapListener(tNode, lView, listenerFn));
  }
  return \u0275\u0275domListener;
}
function listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, eventTargetResolver) {
  ngDevMode && assertTNodeType(
    tNode,
    3 | 12
    /* TNodeType.AnyContainer */
  );
  let processOutputs = true;
  let wrappedListener = null;
  if (tNode.type & 3 || eventTargetResolver) {
    wrappedListener ??= wrapListener(tNode, lView, listenerFn);
    const hasCoalescedDomEvent = listenToDomEvent(tNode, tView, lView, eventTargetResolver, renderer, eventName, listenerFn, wrappedListener);
    if (hasCoalescedDomEvent) {
      processOutputs = false;
    }
  }
  if (processOutputs) {
    const outputConfig = tNode.outputs?.[eventName];
    const hostDirectiveOutputConfig = tNode.hostDirectiveOutputs?.[eventName];
    if (hostDirectiveOutputConfig && hostDirectiveOutputConfig.length) {
      for (let i2 = 0; i2 < hostDirectiveOutputConfig.length; i2 += 2) {
        const index = hostDirectiveOutputConfig[i2];
        const lookupName = hostDirectiveOutputConfig[i2 + 1];
        wrappedListener ??= wrapListener(tNode, lView, listenerFn);
        listenToOutput(tNode, lView, index, lookupName, eventName, wrappedListener);
      }
    }
    if (outputConfig && outputConfig.length) {
      for (const index of outputConfig) {
        wrappedListener ??= wrapListener(tNode, lView, listenerFn);
        listenToOutput(tNode, lView, index, eventName, eventName, wrappedListener);
      }
    }
  }
}
function \u0275\u0275nextContext(level = 1) {
  return nextContextImpl(level);
}
function matchingProjectionSlotIndex(tNode, projectionSlots) {
  let wildcardNgContentIndex = null;
  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);
  for (let i2 = 0; i2 < projectionSlots.length; i2++) {
    const slotValue = projectionSlots[i2];
    if (slotValue === "*") {
      wildcardNgContentIndex = i2;
      continue;
    }
    if (ngProjectAsAttrVal === null ? isNodeMatchingSelectorList(
      tNode,
      slotValue,
      /* isProjectionMode */
      true
    ) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {
      return i2;
    }
  }
  return wildcardNgContentIndex;
}
function \u0275\u0275projectionDef(projectionSlots) {
  const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST];
  if (!componentNode.projection) {
    const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;
    const projectionHeads = componentNode.projection = newArray(numProjectionSlots, null);
    const tails = projectionHeads.slice();
    let componentChild = componentNode.child;
    while (componentChild !== null) {
      if (componentChild.type !== 128) {
        const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;
        if (slotIndex !== null) {
          if (tails[slotIndex]) {
            tails[slotIndex].projectionNext = componentChild;
          } else {
            projectionHeads[slotIndex] = componentChild;
          }
          tails[slotIndex] = componentChild;
        }
      }
      componentChild = componentChild.next;
    }
  }
}
function \u0275\u0275projection(nodeIndex, selectorIndex = 0, attrs, fallbackTemplateFn, fallbackDecls, fallbackVars) {
  const lView = getLView();
  const tView = getTView();
  const fallbackIndex = fallbackTemplateFn ? nodeIndex + 1 : null;
  if (fallbackIndex !== null) {
    declareNoDirectiveHostTemplate(lView, tView, fallbackIndex, fallbackTemplateFn, fallbackDecls, fallbackVars, null, attrs);
  }
  const tProjectionNode = getOrCreateTNode(tView, HEADER_OFFSET + nodeIndex, 16, null, attrs || null);
  if (tProjectionNode.projection === null) {
    tProjectionNode.projection = selectorIndex;
  }
  setCurrentTNodeAsNotParent();
  const hydrationInfo = lView[HYDRATION];
  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock();
  const componentHostNode = lView[DECLARATION_COMPONENT_VIEW][T_HOST];
  const isEmpty = componentHostNode.projection[tProjectionNode.projection] === null;
  if (isEmpty && fallbackIndex !== null) {
    insertFallbackContent(lView, tView, fallbackIndex);
  } else if (isNodeCreationMode && !isDetachedByI18n(tProjectionNode)) {
    applyProjection(tView, lView, tProjectionNode);
  }
}
function insertFallbackContent(lView, tView, fallbackIndex) {
  const adjustedIndex = HEADER_OFFSET + fallbackIndex;
  const fallbackTNode = tView.data[adjustedIndex];
  const fallbackLContainer = lView[adjustedIndex];
  ngDevMode && assertTNode(fallbackTNode);
  ngDevMode && assertLContainer(fallbackLContainer);
  const dehydratedView = findMatchingDehydratedView(fallbackLContainer, fallbackTNode.tView.ssrId);
  const fallbackLView = createAndRenderEmbeddedLView(lView, fallbackTNode, void 0, {
    dehydratedView
  });
  addLViewToLContainer(fallbackLContainer, fallbackLView, 0, shouldAddViewToDom(fallbackTNode, dehydratedView));
}
function \u0275\u0275contentQuery(directiveIndex, predicate, flags, read) {
  createContentQuery(directiveIndex, predicate, flags, read);
}
function \u0275\u0275viewQuery(predicate, flags, read) {
  createViewQuery(predicate, flags, read);
}
function \u0275\u0275queryRefresh(queryList) {
  const lView = getLView();
  const tView = getTView();
  const queryIndex = getCurrentQueryIndex();
  setCurrentQueryIndex(queryIndex + 1);
  const tQuery = getTQuery(tView, queryIndex);
  if (queryList.dirty && isCreationMode(lView) === ((tQuery.metadata.flags & 2) === 2)) {
    if (tQuery.matches === null) {
      queryList.reset([]);
    } else {
      const result = getQueryResults(lView, queryIndex);
      queryList.reset(result, unwrapElementRef);
      queryList.notifyOnChanges();
    }
    return true;
  }
  return false;
}
function \u0275\u0275loadQuery() {
  return loadQueryInternal(getLView(), getCurrentQueryIndex());
}
function \u0275\u0275contentQuerySignal(directiveIndex, target, predicate, flags, read) {
  bindQueryToSignal(target, createContentQuery(directiveIndex, predicate, flags, read));
}
function \u0275\u0275viewQuerySignal(target, predicate, flags, read) {
  bindQueryToSignal(target, createViewQuery(predicate, flags, read));
}
function \u0275\u0275queryAdvance(indexOffset = 1) {
  setCurrentQueryIndex(getCurrentQueryIndex() + indexOffset);
}
function \u0275\u0275reference(index) {
  const contextLView = getContextLView();
  return load(contextLView, HEADER_OFFSET + index);
}
function toTStylingRange(prev, next) {
  ngDevMode && assertNumberInRange(
    prev,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  ngDevMode && assertNumberInRange(
    next,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return prev << 17 | next << 2;
}
function getTStylingRangePrev(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return tStylingRange >> 17 & 32767;
}
function getTStylingRangePrevDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 2) == 2;
}
function setTStylingRangePrev(tStylingRange, previous) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  ngDevMode && assertNumberInRange(
    previous,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return tStylingRange & ~4294836224 | previous << 17;
}
function setTStylingRangePrevDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return tStylingRange | 2;
}
function getTStylingRangeNext(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 131068) >> 2;
}
function setTStylingRangeNext(tStylingRange, next) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  ngDevMode && assertNumberInRange(
    next,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return tStylingRange & ~131068 | //
  next << 2;
}
function getTStylingRangeNextDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 1) === 1;
}
function setTStylingRangeNextDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return tStylingRange | 1;
}
function insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index, isHostBinding, isClassBinding) {
  ngDevMode && assertFirstUpdatePass(getTView());
  let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;
  let tmplHead = getTStylingRangePrev(tBindings);
  let tmplTail = getTStylingRangeNext(tBindings);
  tData[index] = tStylingKeyWithStatic;
  let isKeyDuplicateOfStatic = false;
  let tStylingKey;
  if (Array.isArray(tStylingKeyWithStatic)) {
    const staticKeyValueArray = tStylingKeyWithStatic;
    tStylingKey = staticKeyValueArray[1];
    if (tStylingKey === null || keyValueArrayIndexOf(staticKeyValueArray, tStylingKey) > 0) {
      isKeyDuplicateOfStatic = true;
    }
  } else {
    tStylingKey = tStylingKeyWithStatic;
  }
  if (isHostBinding) {
    const hasTemplateBindings = tmplTail !== 0;
    if (hasTemplateBindings) {
      const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);
      tData[index + 1] = toTStylingRange(previousNode, tmplHead);
      if (previousNode !== 0) {
        tData[previousNode + 1] = setTStylingRangeNext(tData[previousNode + 1], index);
      }
      tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);
    } else {
      tData[index + 1] = toTStylingRange(tmplHead, 0);
      if (tmplHead !== 0) {
        tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);
      }
      tmplHead = index;
    }
  } else {
    tData[index + 1] = toTStylingRange(tmplTail, 0);
    ngDevMode && assertEqual(tmplHead !== 0 && tmplTail === 0, false, "Adding template bindings after hostBindings is not allowed.");
    if (tmplHead === 0) {
      tmplHead = index;
    } else {
      tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);
    }
    tmplTail = index;
  }
  if (isKeyDuplicateOfStatic) {
    tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);
  }
  markDuplicates(tData, tStylingKey, index, true);
  markDuplicates(tData, tStylingKey, index, false);
  markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);
  tBindings = toTStylingRange(tmplHead, tmplTail);
  if (isClassBinding) {
    tNode.classBindings = tBindings;
  } else {
    tNode.styleBindings = tBindings;
  }
}
function markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {
  const residual2 = isClassBinding ? tNode.residualClasses : tNode.residualStyles;
  if (residual2 != null && typeof tStylingKey == "string" && keyValueArrayIndexOf(residual2, tStylingKey) >= 0) {
    tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);
  }
}
function markDuplicates(tData, tStylingKey, index, isPrevDir) {
  const tStylingAtIndex = tData[index + 1];
  const isMap = tStylingKey === null;
  let cursor = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);
  let foundDuplicate = false;
  while (cursor !== 0 && (foundDuplicate === false || isMap)) {
    ngDevMode && assertIndexInRange(tData, cursor);
    const tStylingValueAtCursor = tData[cursor];
    const tStyleRangeAtCursor = tData[cursor + 1];
    if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {
      foundDuplicate = true;
      tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) : setTStylingRangePrevDuplicate(tStyleRangeAtCursor);
    }
    cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) : getTStylingRangeNext(tStyleRangeAtCursor);
  }
  if (foundDuplicate) {
    tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) : setTStylingRangeNextDuplicate(tStylingAtIndex);
  }
}
function isStylingMatch(tStylingKeyCursor, tStylingKey) {
  ngDevMode && assertNotEqual(Array.isArray(tStylingKey), true, "Expected that 'tStylingKey' has been unwrapped");
  if (tStylingKeyCursor === null || // If the cursor is `null` it means that we have map at that
  // location so we must assume that we have a match.
  tStylingKey == null || // If `tStylingKey` is `null` then it is a map therefor assume that it
  // contains a match.
  (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) === tStylingKey) {
    return true;
  } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === "string") {
    return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >= 0;
  }
  return false;
}
function getLastParsedKey(text) {
  return text.substring(parserState.key, parserState.keyEnd);
}
function getLastParsedValue(text) {
  return text.substring(parserState.value, parserState.valueEnd);
}
function parseClassName(text) {
  resetParserState(text);
  return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));
}
function parseClassNameNext(text, index) {
  const end = parserState.textEnd;
  if (end === index) {
    return -1;
  }
  index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);
  return consumeWhitespace(text, index, end);
}
function parseStyle(text) {
  resetParserState(text);
  return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));
}
function parseStyleNext(text, startIndex) {
  const end = parserState.textEnd;
  let index = parserState.key = consumeWhitespace(text, startIndex, end);
  if (end === index) {
    return -1;
  }
  index = parserState.keyEnd = consumeStyleKey(text, index, end);
  index = consumeSeparator(
    text,
    index,
    end,
    58
    /* CharCode.COLON */
  );
  index = parserState.value = consumeWhitespace(text, index, end);
  index = parserState.valueEnd = consumeStyleValue(text, index, end);
  return consumeSeparator(
    text,
    index,
    end,
    59
    /* CharCode.SEMI_COLON */
  );
}
function resetParserState(text) {
  parserState.key = 0;
  parserState.keyEnd = 0;
  parserState.value = 0;
  parserState.valueEnd = 0;
  parserState.textEnd = text.length;
}
function consumeWhitespace(text, startIndex, endIndex) {
  while (startIndex < endIndex && text.charCodeAt(startIndex) <= 32) {
    startIndex++;
  }
  return startIndex;
}
function consumeClassToken(text, startIndex, endIndex) {
  while (startIndex < endIndex && text.charCodeAt(startIndex) > 32) {
    startIndex++;
  }
  return startIndex;
}
function consumeStyleKey(text, startIndex, endIndex) {
  let ch2;
  while (startIndex < endIndex && ((ch2 = text.charCodeAt(startIndex)) === 45 || ch2 === 95 || (ch2 & -33) >= 65 && (ch2 & -33) <= 90 || ch2 >= 48 && ch2 <= 57)) {
    startIndex++;
  }
  return startIndex;
}
function consumeSeparator(text, startIndex, endIndex, separator) {
  startIndex = consumeWhitespace(text, startIndex, endIndex);
  if (startIndex < endIndex) {
    if (ngDevMode && text.charCodeAt(startIndex) !== separator) {
      malformedStyleError(text, String.fromCharCode(separator), startIndex);
    }
    startIndex++;
  }
  return startIndex;
}
function consumeStyleValue(text, startIndex, endIndex) {
  let ch1 = -1;
  let ch2 = -1;
  let ch3 = -1;
  let i2 = startIndex;
  let lastChIndex = i2;
  while (i2 < endIndex) {
    const ch4 = text.charCodeAt(i2++);
    if (ch4 === 59) {
      return lastChIndex;
    } else if (ch4 === 34 || ch4 === 39) {
      lastChIndex = i2 = consumeQuotedText(text, ch4, i2, endIndex);
    } else if (startIndex === i2 - 4 && // We have seen only 4 characters so far "URL(" (Ignore "foo_URL()")
    ch3 === 85 && ch2 === 82 && ch1 === 76 && ch4 === 40) {
      lastChIndex = i2 = consumeQuotedText(text, 41, i2, endIndex);
    } else if (ch4 > 32) {
      lastChIndex = i2;
    }
    ch3 = ch2;
    ch2 = ch1;
    ch1 = ch4 & -33;
  }
  return lastChIndex;
}
function consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {
  let ch1 = -1;
  let index = startIndex;
  while (index < endIndex) {
    const ch2 = text.charCodeAt(index++);
    if (ch2 == quoteCharCode && ch1 !== 92) {
      return index;
    }
    if (ch2 == 92 && ch1 === 92) {
      ch1 = 0;
    } else {
      ch1 = ch2;
    }
  }
  throw ngDevMode ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) : new Error();
}
function malformedStyleError(text, expecting, index) {
  ngDevMode && assertEqual(typeof text === "string", true, "String expected here");
  throw throwError2(`Malformed style at location ${index} in string '` + text.substring(0, index) + "[>>" + text.substring(index, index + 1) + "<<]" + text.slice(index + 1) + `'. Expecting '${expecting}'.`);
}
function \u0275\u0275styleProp(prop, value, suffix) {
  checkStylingProperty(prop, value, suffix, false);
  return \u0275\u0275styleProp;
}
function \u0275\u0275classProp(className, value) {
  checkStylingProperty(className, value, null, true);
  return \u0275\u0275classProp;
}
function \u0275\u0275styleMap(styles) {
  checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);
}
function styleStringParser(keyValueArray, text) {
  for (let i2 = parseStyle(text); i2 >= 0; i2 = parseStyleNext(text, i2)) {
    styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));
  }
}
function \u0275\u0275classMap(classes) {
  checkStylingMap(classKeyValueArraySet, classStringParser, classes, true);
}
function classStringParser(keyValueArray, text) {
  for (let i2 = parseClassName(text); i2 >= 0; i2 = parseClassNameNext(text, i2)) {
    keyValueArraySet(keyValueArray, getLastParsedKey(text), true);
  }
}
function checkStylingProperty(prop, value, suffix, isClassBased) {
  const lView = getLView();
  const tView = getTView();
  const bindingIndex = incrementBindingIndex(2);
  if (tView.firstUpdatePass) {
    stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);
  }
  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
    const tNode = tView.data[getSelectedIndex()];
    updateStyling(tView, tNode, lView, lView[RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);
  }
}
function checkStylingMap(keyValueArraySet2, stringParser, value, isClassBased) {
  const tView = getTView();
  const bindingIndex = incrementBindingIndex(2);
  if (tView.firstUpdatePass) {
    stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);
  }
  const lView = getLView();
  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
    const tNode = tView.data[getSelectedIndex()];
    if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {
      if (ngDevMode) {
        const tStylingKey = tView.data[bindingIndex];
        assertEqual(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, "Styling linked list shadow input should be marked as 'false'");
      }
      let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;
      ngDevMode && isClassBased === false && staticPrefix !== null && assertEqual(staticPrefix.endsWith(";"), true, "Expecting static portion to end with ';'");
      if (staticPrefix !== null) {
        value = concatStringsWithSpace(staticPrefix, value ? value : "");
      }
      setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);
    } else {
      updateStylingMap(tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet2, stringParser, value), isClassBased, bindingIndex);
    }
  }
}
function isInHostBindings(tView, bindingIndex) {
  return bindingIndex >= tView.expandoStartIndex;
}
function stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {
  ngDevMode && assertFirstUpdatePass(tView);
  const tData = tView.data;
  if (tData[bindingIndex + 1] === null) {
    const tNode = tData[getSelectedIndex()];
    ngDevMode && assertDefined(tNode, "TNode expected");
    const isHostBindings = isInHostBindings(tView, bindingIndex);
    if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {
      tStylingKey = false;
    }
    tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);
    insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);
  }
}
function wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {
  const hostDirectiveDef = getCurrentDirectiveDef(tData);
  let residual2 = isClassBased ? tNode.residualClasses : tNode.residualStyles;
  if (hostDirectiveDef === null) {
    const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;
    if (isFirstStylingInstructionInTemplate) {
      stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);
      stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);
      residual2 = null;
    }
  } else {
    const directiveStylingLast = tNode.directiveStylingLast;
    const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;
    if (isFirstStylingInstructionInHostBinding) {
      stylingKey = collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);
      if (residual2 === null) {
        let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);
        if (templateStylingKey !== void 0 && Array.isArray(templateStylingKey)) {
          templateStylingKey = collectStylingFromDirectives(null, tData, tNode, templateStylingKey[1], isClassBased);
          templateStylingKey = collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);
          setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);
        }
      } else {
        residual2 = collectResidual(tData, tNode, isClassBased);
      }
    }
  }
  if (residual2 !== void 0) {
    isClassBased ? tNode.residualClasses = residual2 : tNode.residualStyles = residual2;
  }
  return stylingKey;
}
function getTemplateHeadTStylingKey(tData, tNode, isClassBased) {
  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
  if (getTStylingRangeNext(bindings) === 0) {
    return void 0;
  }
  return tData[getTStylingRangePrev(bindings)];
}
function setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {
  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
  ngDevMode && assertNotEqual(getTStylingRangeNext(bindings), 0, "Expecting to have at least one template styling binding.");
  tData[getTStylingRangePrev(bindings)] = tStylingKey;
}
function collectResidual(tData, tNode, isClassBased) {
  let residual2 = void 0;
  const directiveEnd = tNode.directiveEnd;
  ngDevMode && assertNotEqual(tNode.directiveStylingLast, -1, "By the time this function gets called at least one hostBindings-node styling instruction must have executed.");
  for (let i2 = 1 + tNode.directiveStylingLast; i2 < directiveEnd; i2++) {
    const attrs = tData[i2].hostAttrs;
    residual2 = collectStylingFromTAttrs(residual2, attrs, isClassBased);
  }
  return collectStylingFromTAttrs(residual2, tNode.attrs, isClassBased);
}
function collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {
  let currentDirective = null;
  const directiveEnd = tNode.directiveEnd;
  let directiveStylingLast = tNode.directiveStylingLast;
  if (directiveStylingLast === -1) {
    directiveStylingLast = tNode.directiveStart;
  } else {
    directiveStylingLast++;
  }
  while (directiveStylingLast < directiveEnd) {
    currentDirective = tData[directiveStylingLast];
    ngDevMode && assertDefined(currentDirective, "expected to be defined");
    stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);
    if (currentDirective === hostDirectiveDef)
      break;
    directiveStylingLast++;
  }
  if (hostDirectiveDef !== null) {
    tNode.directiveStylingLast = directiveStylingLast;
  }
  return stylingKey;
}
function collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {
  const desiredMarker = isClassBased ? 1 : 2;
  let currentMarker = -1;
  if (attrs !== null) {
    for (let i2 = 0; i2 < attrs.length; i2++) {
      const item = attrs[i2];
      if (typeof item === "number") {
        currentMarker = item;
      } else {
        if (currentMarker === desiredMarker) {
          if (!Array.isArray(stylingKey)) {
            stylingKey = stylingKey === void 0 ? [] : ["", stylingKey];
          }
          keyValueArraySet(stylingKey, item, isClassBased ? true : attrs[++i2]);
        }
      }
    }
  }
  return stylingKey === void 0 ? null : stylingKey;
}
function toStylingKeyValueArray(keyValueArraySet2, stringParser, value) {
  if (value == null || value === "")
    return EMPTY_ARRAY;
  const styleKeyValueArray = [];
  const unwrappedValue = unwrapSafeValue(value);
  if (Array.isArray(unwrappedValue)) {
    for (let i2 = 0; i2 < unwrappedValue.length; i2++) {
      keyValueArraySet2(styleKeyValueArray, unwrappedValue[i2], true);
    }
  } else if (typeof unwrappedValue === "object") {
    for (const key in unwrappedValue) {
      if (unwrappedValue.hasOwnProperty(key)) {
        keyValueArraySet2(styleKeyValueArray, key, unwrappedValue[key]);
      }
    }
  } else if (typeof unwrappedValue === "string") {
    stringParser(styleKeyValueArray, unwrappedValue);
  } else {
    ngDevMode && throwError2("Unsupported styling type: " + typeof unwrappedValue + " (" + unwrappedValue + ")");
  }
  return styleKeyValueArray;
}
function styleKeyValueArraySet(keyValueArray, key, value) {
  keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));
}
function classKeyValueArraySet(keyValueArray, key, value) {
  const stringKey = String(key);
  if (stringKey !== "" && !stringKey.includes(" ")) {
    keyValueArraySet(keyValueArray, stringKey, value);
  }
}
function updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {
  if (oldKeyValueArray === NO_CHANGE) {
    oldKeyValueArray = EMPTY_ARRAY;
  }
  let oldIndex = 0;
  let newIndex = 0;
  let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;
  let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;
  while (oldKey !== null || newKey !== null) {
    ngDevMode && assertLessThan(oldIndex, 999, "Are we stuck in infinite loop?");
    ngDevMode && assertLessThan(newIndex, 999, "Are we stuck in infinite loop?");
    const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : void 0;
    const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : void 0;
    let setKey = null;
    let setValue = void 0;
    if (oldKey === newKey) {
      oldIndex += 2;
      newIndex += 2;
      if (oldValue !== newValue) {
        setKey = newKey;
        setValue = newValue;
      }
    } else if (newKey === null || oldKey !== null && oldKey < newKey) {
      oldIndex += 2;
      setKey = oldKey;
    } else {
      ngDevMode && assertDefined(newKey, "Expecting to have a valid key");
      newIndex += 2;
      setKey = newKey;
      setValue = newValue;
    }
    if (setKey !== null) {
      updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);
    }
    oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;
    newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;
  }
}
function updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {
  if (!(tNode.type & 3)) {
    return;
  }
  const tData = tView.data;
  const tRange = tData[bindingIndex + 1];
  const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ? findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) : void 0;
  if (!isStylingValuePresent(higherPriorityValue)) {
    if (!isStylingValuePresent(value)) {
      if (getTStylingRangePrevDuplicate(tRange)) {
        value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);
      }
    }
    const rNode = getNativeByIndex(getSelectedIndex(), lView);
    applyStyling(renderer, isClassBased, rNode, prop, value);
  }
}
function findStylingValue(tData, tNode, lView, prop, index, isClassBased) {
  const isPrevDirection = tNode === null;
  let value = void 0;
  while (index > 0) {
    const rawKey = tData[index];
    const containsStatics = Array.isArray(rawKey);
    const key = containsStatics ? rawKey[1] : rawKey;
    const isStylingMap = key === null;
    let valueAtLViewIndex = lView[index + 1];
    if (valueAtLViewIndex === NO_CHANGE) {
      valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : void 0;
    }
    let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) : key === prop ? valueAtLViewIndex : void 0;
    if (containsStatics && !isStylingValuePresent(currentValue)) {
      currentValue = keyValueArrayGet(rawKey, prop);
    }
    if (isStylingValuePresent(currentValue)) {
      value = currentValue;
      if (isPrevDirection) {
        return value;
      }
    }
    const tRange = tData[index + 1];
    index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);
  }
  if (tNode !== null) {
    let residual2 = isClassBased ? tNode.residualClasses : tNode.residualStyles;
    if (residual2 != null) {
      value = keyValueArrayGet(residual2, prop);
    }
  }
  return value;
}
function isStylingValuePresent(value) {
  return value !== void 0;
}
function normalizeSuffix(value, suffix) {
  if (value == null || value === "") ;
  else if (typeof suffix === "string") {
    value = value + suffix;
  } else if (typeof value === "object") {
    value = stringify(unwrapSafeValue(value));
  }
  return value;
}
function hasStylingInputShadow(tNode, isClassBased) {
  return (tNode.flags & (isClassBased ? 8 : 16)) !== 0;
}
function \u0275\u0275text(index, value = "") {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = index + HEADER_OFFSET;
  ngDevMode && assertTNodeCreationIndex(lView, index);
  const tNode = tView.firstCreatePass ? getOrCreateTNode(tView, adjustedIndex, 1, value, null) : tView.data[adjustedIndex];
  const textNative = _locateOrCreateTextNode(tView, lView, tNode, value, index);
  lView[adjustedIndex] = textNative;
  if (wasLastNodeCreated()) {
    appendChild(tView, lView, textNative, tNode);
  }
  setCurrentTNode(tNode, false);
}
function interpolationV(lView, values) {
  ngDevMode && assertLessThan(2, values.length, "should have at least 3 values");
  let isBindingUpdated = false;
  let bindingIndex = getBindingIndex();
  for (let i2 = 1; i2 < values.length; i2 += 2) {
    isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i2]) || isBindingUpdated;
  }
  setBindingIndex(bindingIndex);
  if (!isBindingUpdated) {
    return NO_CHANGE;
  }
  let content = values[0];
  for (let i2 = 1; i2 < values.length; i2 += 2) {
    content += renderStringify(values[i2]) + (i2 + 1 !== values.length ? values[i2 + 1] : "");
  }
  return content;
}
function interpolation1(lView, prefix, v0, suffix = "") {
  const different = bindingUpdated(lView, nextBindingIndex(), v0);
  return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;
}
function interpolation2(lView, prefix, v0, i0, v1, suffix = "") {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated2(lView, bindingIndex, v0, v1);
  incrementBindingIndex(2);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;
}
function interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix = "") {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);
  incrementBindingIndex(3);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix : NO_CHANGE;
}
function interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix = "") {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  incrementBindingIndex(4);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + suffix : NO_CHANGE;
}
function interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix = "") {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated(lView, bindingIndex + 4, v4) || different;
  incrementBindingIndex(5);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + suffix : NO_CHANGE;
}
function interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix = "") {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;
  incrementBindingIndex(6);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix : NO_CHANGE;
}
function interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix = "") {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;
  incrementBindingIndex(7);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + suffix : NO_CHANGE;
}
function interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix = "") {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;
  incrementBindingIndex(8);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix : NO_CHANGE;
}
function \u0275\u0275textInterpolate(v0) {
  \u0275\u0275textInterpolate1("", v0);
  return \u0275\u0275textInterpolate;
}
function \u0275\u0275textInterpolate1(prefix, v0, suffix) {
  const lView = getLView();
  const interpolated = interpolation1(lView, prefix, v0, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate1;
}
function \u0275\u0275textInterpolate2(prefix, v0, i0, v1, suffix) {
  const lView = getLView();
  const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate2;
}
function \u0275\u0275textInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
  const lView = getLView();
  const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate3;
}
function \u0275\u0275textInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const lView = getLView();
  const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate4;
}
function \u0275\u0275textInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const lView = getLView();
  const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate5;
}
function \u0275\u0275textInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const lView = getLView();
  const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate6;
}
function \u0275\u0275textInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const lView = getLView();
  const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate7;
}
function \u0275\u0275textInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const lView = getLView();
  const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate8;
}
function \u0275\u0275textInterpolateV(values) {
  const lView = getLView();
  const interpolated = interpolationV(lView, values);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolateV;
}
function textBindingInternal(lView, index, value) {
  ngDevMode && assertString(value, "Value should be a string");
  ngDevMode && assertNotSame(value, NO_CHANGE, "value should not be NO_CHANGE");
  ngDevMode && assertIndexInRange(lView, index);
  const element = getNativeByIndex(index, lView);
  ngDevMode && assertDefined(element, "native element should exist");
  updateTextNode(lView[RENDERER], element, value);
}
function \u0275\u0275twoWayProperty(propName, value, sanitizer) {
  if (isWritableSignal(value)) {
    value = value();
  }
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    setPropertyAndInputs(tNode, lView, propName, value, lView[RENDERER], sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275twoWayProperty;
}
function \u0275\u0275twoWayBindingSet(target, value) {
  const canWrite = isWritableSignal(target);
  canWrite && target.set(value);
  return canWrite;
}
function \u0275\u0275twoWayListener(eventName, listenerFn) {
  const lView = getLView();
  const tView = getTView();
  const tNode = getCurrentTNode();
  listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn);
  return \u0275\u0275twoWayListener;
}
function \u0275\u0275declareLet(index) {
  const tView = getTView();
  const lView = getLView();
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = getOrCreateTNode(tView, adjustedIndex, 128, null, null);
  setCurrentTNode(tNode, false);
  store(tView, lView, adjustedIndex, UNINITIALIZED_LET);
  return \u0275\u0275declareLet;
}
function \u0275\u0275storeLet(value) {
  performanceMarkFeature("NgLet");
  const tView = getTView();
  const lView = getLView();
  const index = getSelectedIndex();
  store(tView, lView, index, value);
  return value;
}
function \u0275\u0275readContextLet(index) {
  const contextLView = getContextLView();
  const value = load(contextLView, HEADER_OFFSET + index);
  if (value === UNINITIALIZED_LET) {
    throw new RuntimeError(314, ngDevMode && "Attempting to access a @let declaration whose value is not available yet");
  }
  return value;
}
function \u0275\u0275attachSourceLocations(templatePath, locations) {
  const tView = getTView();
  const lView = getLView();
  const renderer = lView[RENDERER];
  const attributeName = "data-ng-source-location";
  for (const [index, offset, line, column] of locations) {
    const tNode = getTNode(tView, index + HEADER_OFFSET);
    ngDevMode && assertTNodeType(
      tNode,
      2
      /* TNodeType.Element */
    );
    const node = getNativeByIndex(index + HEADER_OFFSET, lView);
    if (!node.hasAttribute(attributeName)) {
      const attributeValue = `${templatePath}@o:${offset},l:${line},c:${column}`;
      renderer.setAttribute(node, attributeName, attributeValue);
    }
  }
}
function \u0275\u0275interpolate(v0) {
  return bindingUpdated(getLView(), nextBindingIndex(), v0) ? renderStringify(v0) : NO_CHANGE;
}
function \u0275\u0275interpolate1(prefix, v0, suffix = "") {
  return interpolation1(getLView(), prefix, v0, suffix);
}
function \u0275\u0275interpolate2(prefix, v0, i0, v1, suffix = "") {
  return interpolation2(getLView(), prefix, v0, i0, v1, suffix);
}
function \u0275\u0275interpolate3(prefix, v0, i0, v1, i1, v2, suffix = "") {
  return interpolation3(getLView(), prefix, v0, i0, v1, i1, v2, suffix);
}
function \u0275\u0275interpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix = "") {
  return interpolation4(getLView(), prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
}
function \u0275\u0275interpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix = "") {
  return interpolation5(getLView(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
}
function \u0275\u0275interpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix = "") {
  return interpolation6(getLView(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
}
function \u0275\u0275interpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix = "") {
  return interpolation7(getLView(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
}
function \u0275\u0275interpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix = "") {
  return interpolation8(getLView(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
}
function \u0275\u0275interpolateV(values) {
  return interpolationV(getLView(), values);
}
function providersResolver(def, providers, viewProviders) {
  const tView = getTView();
  if (tView.firstCreatePass) {
    const isComponent2 = isComponentDef(def);
    resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent2, true);
    resolveProvider(providers, tView.data, tView.blueprint, isComponent2, false);
  }
}
function resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent2, isViewProvider) {
  provider = resolveForwardRef(provider);
  if (Array.isArray(provider)) {
    for (let i2 = 0; i2 < provider.length; i2++) {
      resolveProvider(provider[i2], tInjectables, lInjectablesBlueprint, isComponent2, isViewProvider);
    }
  } else {
    const tView = getTView();
    const lView = getLView();
    const tNode = getCurrentTNode();
    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);
    const providerFactory = providerToFactory(provider);
    if (ngDevMode) {
      const injector = new NodeInjector(tNode, lView);
      runInInjectorProfilerContext(injector, token, () => {
        emitProviderConfiguredEvent(provider, isViewProvider);
      });
    }
    const beginIndex = tNode.providerIndexes & 1048575;
    const endIndex = tNode.directiveStart;
    const cptViewProvidersCount = tNode.providerIndexes >> 20;
    if (isTypeProvider(provider) || !provider.multi) {
      const factory = new NodeInjectorFactory(providerFactory, isViewProvider, \u0275\u0275directiveInject, ngDevMode ? providerName(provider) : null);
      const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);
      if (existingFactoryIndex === -1) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
        registerDestroyHooksIfSupported(tView, provider, tInjectables.length);
        tInjectables.push(token);
        tNode.directiveStart++;
        tNode.directiveEnd++;
        if (isViewProvider) {
          tNode.providerIndexes += 1048576;
        }
        lInjectablesBlueprint.push(factory);
        lView.push(factory);
      } else {
        lInjectablesBlueprint[existingFactoryIndex] = factory;
        lView[existingFactoryIndex] = factory;
      }
    } else {
      const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);
      const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);
      const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex];
      const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];
      if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
        const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent2, providerFactory, provider);
        if (!isViewProvider && doesViewProvidersFactoryExist) {
          lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;
        }
        registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);
        tInjectables.push(token);
        tNode.directiveStart++;
        tNode.directiveEnd++;
        if (isViewProvider) {
          tNode.providerIndexes += 1048576;
        }
        lInjectablesBlueprint.push(factory);
        lView.push(factory);
      } else {
        const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent2);
        registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex : existingViewProvidersFactoryIndex, indexInFactory);
      }
      if (!isViewProvider && isComponent2 && doesViewProvidersFactoryExist) {
        lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;
      }
    }
  }
}
function registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {
  const providerIsTypeProvider = isTypeProvider(provider);
  const providerIsClassProvider = isClassProvider(provider);
  if (providerIsTypeProvider || providerIsClassProvider) {
    const classToken = providerIsClassProvider ? resolveForwardRef(provider.useClass) : provider;
    const prototype = classToken.prototype;
    const ngOnDestroy = prototype.ngOnDestroy;
    if (ngOnDestroy) {
      const hooks = tView.destroyHooks || (tView.destroyHooks = []);
      if (!providerIsTypeProvider && provider.multi) {
        ngDevMode && assertDefined(indexInFactory, "indexInFactory when registering multi factory destroy hook");
        const existingCallbacksIndex = hooks.indexOf(contextIndex);
        if (existingCallbacksIndex === -1) {
          hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);
        } else {
          hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);
        }
      } else {
        hooks.push(contextIndex, ngOnDestroy);
      }
    }
  }
}
function multiFactoryAdd(multiFactory2, factory, isComponentProvider) {
  if (isComponentProvider) {
    multiFactory2.componentProviders++;
  }
  return multiFactory2.multi.push(factory) - 1;
}
function indexOf(item, arr, begin, end) {
  for (let i2 = begin; i2 < end; i2++) {
    if (arr[i2] === item)
      return i2;
  }
  return -1;
}
function multiProvidersFactoryResolver(_2, flags, tData, lData, tNode) {
  return multiResolve(this.multi, []);
}
function multiViewProvidersFactoryResolver(_2, _flags, _tData, lView, tNode) {
  const factories = this.multi;
  let result;
  if (this.providerFactory) {
    const componentCount = this.providerFactory.componentProviders;
    const multiProviders = getNodeInjectable(lView, lView[TVIEW], this.providerFactory.index, tNode);
    result = multiProviders.slice(0, componentCount);
    multiResolve(factories, result);
    for (let i2 = componentCount; i2 < multiProviders.length; i2++) {
      result.push(multiProviders[i2]);
    }
  } else {
    result = [];
    multiResolve(factories, result);
  }
  return result;
}
function multiResolve(factories, result) {
  for (let i2 = 0; i2 < factories.length; i2++) {
    const factory = factories[i2];
    result.push(factory());
  }
  return result;
}
function multiFactory(factoryFn, index, isViewProvider, isComponent2, f2, provider) {
  const factory = new NodeInjectorFactory(factoryFn, isViewProvider, \u0275\u0275directiveInject, ngDevMode ? providerName(provider) : null);
  factory.multi = [];
  factory.index = index;
  factory.componentProviders = 0;
  multiFactoryAdd(factory, f2, isComponent2 && !isViewProvider);
  return factory;
}
function providerName(provider) {
  if (Array.isArray(provider)) {
    return null;
  }
  if (isTypeProvider(provider)) {
    return provider.name;
  } else if (isClassProvider(provider)) {
    if (provider.provide instanceof InjectionToken) {
      return `('${provider.provide.toString()}':${provider.useClass.name})`;
    }
    return provider.useClass.name;
  } else if (provider.provide instanceof InjectionToken) {
    return provider.provide.toString();
  } else if (typeof provider.provide === "string") {
    return provider.provide;
  } else {
    return null;
  }
}
function \u0275\u0275ProvidersFeature(providers, viewProviders = []) {
  return (definition) => {
    definition.providersResolver = (def, processProvidersFn) => {
      return providersResolver(
        def,
        //
        processProvidersFn ? processProvidersFn(providers) : providers,
        //
        viewProviders
      );
    };
  };
}
function \u0275\u0275ExternalStylesFeature(styleUrls) {
  return (definition) => {
    if (styleUrls.length < 1) {
      return;
    }
    definition.getExternalStyles = (encapsulationId) => {
      const urls = styleUrls.map((value) => value + "?ngcomp" + (encapsulationId ? "=" + encodeURIComponent(encapsulationId) : "") + "&e=" + definition.encapsulation);
      return urls;
    };
  };
}
function \u0275\u0275setComponentScope(type, directives, pipes) {
  const def = type.\u0275cmp;
  def.directiveDefs = extractDefListOrFactory(directives, extractDirectiveDef);
  def.pipeDefs = extractDefListOrFactory(pipes, getPipeDef);
}
function \u0275\u0275setNgModuleScope(type, scope) {
  return noSideEffects(() => {
    const ngModuleDef = getNgModuleDefOrThrow(type);
    ngModuleDef.declarations = convertToTypeArray(scope.declarations || EMPTY_ARRAY);
    ngModuleDef.imports = convertToTypeArray(scope.imports || EMPTY_ARRAY);
    ngModuleDef.exports = convertToTypeArray(scope.exports || EMPTY_ARRAY);
    if (scope.bootstrap) {
      ngModuleDef.bootstrap = convertToTypeArray(scope.bootstrap);
    }
    depsTracker.registerNgModule(type, scope);
  });
}
function convertToTypeArray(values) {
  if (typeof values === "function") {
    return values;
  }
  const flattenValues = flatten(values);
  if (flattenValues.some(isForwardRef)) {
    return () => flattenValues.map(resolveForwardRef).map(maybeUnwrapModuleWithProviders);
  } else {
    return flattenValues.map(maybeUnwrapModuleWithProviders);
  }
}
function maybeUnwrapModuleWithProviders(value) {
  return isModuleWithProviders(value) ? value.ngModule : value;
}
function \u0275\u0275pureFunction0(slotOffset, pureFn, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  return lView[bindingIndex] === NO_CHANGE ? updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) : getBinding(lView, bindingIndex);
}
function \u0275\u0275pureFunction1(slotOffset, pureFn, exp, thisArg) {
  return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);
}
function \u0275\u0275pureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {
  return pureFunction2Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, thisArg);
}
function \u0275\u0275pureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
  return pureFunction3Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);
}
function \u0275\u0275pureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
  return pureFunction4Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);
}
function \u0275\u0275pureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated(lView, bindingIndex + 4, exp5) || different ? updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) : pureFn(exp1, exp2, exp3, exp4, exp5)) : getBinding(lView, bindingIndex + 5);
}
function \u0275\u0275pureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ? updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) : getBinding(lView, bindingIndex + 6);
}
function \u0275\u0275pureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ? updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) : getBinding(lView, bindingIndex + 7);
}
function \u0275\u0275pureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ? updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) : getBinding(lView, bindingIndex + 8);
}
function \u0275\u0275pureFunctionV(slotOffset, pureFn, exps, thisArg) {
  return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);
}
function getPureFunctionReturnValue(lView, returnValueIndex) {
  ngDevMode && assertIndexInRange(lView, returnValueIndex);
  const lastReturnValue = lView[returnValueIndex];
  return lastReturnValue === NO_CHANGE ? void 0 : lastReturnValue;
}
function pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getPureFunctionReturnValue(lView, bindingIndex + 1);
}
function pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getPureFunctionReturnValue(lView, bindingIndex + 2);
}
function pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ? updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) : getPureFunctionReturnValue(lView, bindingIndex + 3);
}
function pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ? updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) : getPureFunctionReturnValue(lView, bindingIndex + 4);
}
function pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {
  let bindingIndex = bindingRoot + slotOffset;
  let different = false;
  for (let i2 = 0; i2 < exps.length; i2++) {
    bindingUpdated(lView, bindingIndex++, exps[i2]) && (different = true);
  }
  return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) : getPureFunctionReturnValue(lView, bindingIndex);
}
function \u0275\u0275pipe(index, pipeName) {
  const tView = getTView();
  let pipeDef;
  const adjustedIndex = index + HEADER_OFFSET;
  if (tView.firstCreatePass) {
    pipeDef = getPipeDef2(pipeName, tView.pipeRegistry);
    tView.data[adjustedIndex] = pipeDef;
    if (pipeDef.onDestroy) {
      (tView.destroyHooks ??= []).push(adjustedIndex, pipeDef.onDestroy);
    }
  } else {
    pipeDef = tView.data[adjustedIndex];
  }
  const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));
  let previousInjectorProfilerContext;
  if (ngDevMode) {
    previousInjectorProfilerContext = setInjectorProfilerContext({
      injector: new NodeInjector(getCurrentTNode(), getLView()),
      token: pipeDef.type
    });
  }
  const previousInjectImplementation = setInjectImplementation(\u0275\u0275directiveInject);
  try {
    const previousIncludeViewProviders = setIncludeViewProviders(false);
    const pipeInstance = pipeFactory();
    setIncludeViewProviders(previousIncludeViewProviders);
    store(tView, getLView(), adjustedIndex, pipeInstance);
    return pipeInstance;
  } finally {
    setInjectImplementation(previousInjectImplementation);
    ngDevMode && setInjectorProfilerContext(previousInjectorProfilerContext);
  }
}
function getPipeDef2(name, registry) {
  if (registry) {
    if (ngDevMode) {
      const pipes = registry.filter((pipe2) => pipe2.name === name);
      if (pipes.length > 1) {
        console.warn(formatRuntimeError(313, getMultipleMatchingPipesMessage(name)));
      }
    }
    for (let i2 = registry.length - 1; i2 >= 0; i2--) {
      const pipeDef = registry[i2];
      if (name === pipeDef.name) {
        return pipeDef;
      }
    }
  }
  if (ngDevMode) {
    throw new RuntimeError(-302, getPipeNotFoundErrorMessage(name));
  }
  return;
}
function getMultipleMatchingPipesMessage(name) {
  const lView = getLView();
  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
  const context2 = declarationLView[CONTEXT];
  const hostIsStandalone = isHostComponentStandalone(lView);
  const componentInfoMessage = context2 ? ` in the '${context2.constructor.name}' component` : "";
  const verifyMessage = `check ${hostIsStandalone ? "'@Component.imports' of this component" : "the imports of this module"}`;
  const errorMessage = `Multiple pipes match the name \`${name}\`${componentInfoMessage}. ${verifyMessage}`;
  return errorMessage;
}
function getPipeNotFoundErrorMessage(name) {
  const lView = getLView();
  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
  const context2 = declarationLView[CONTEXT];
  const hostIsStandalone = isHostComponentStandalone(lView);
  const componentInfoMessage = context2 ? ` in the '${context2.constructor.name}' component` : "";
  const verifyMessage = `Verify that it is ${hostIsStandalone ? "included in the '@Component.imports' of this component" : "declared or imported in this module"}`;
  const errorMessage = `The pipe '${name}' could not be found${componentInfoMessage}. ${verifyMessage}`;
  return errorMessage;
}
function \u0275\u0275pipeBind1(index, offset, v1) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction1Internal(lView, getBindingRoot(), offset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1);
}
function \u0275\u0275pipeBind2(index, slotOffset, v1, v2) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction2Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) : pipeInstance.transform(v1, v2);
}
function \u0275\u0275pipeBind3(index, slotOffset, v1, v2, v3) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction3Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) : pipeInstance.transform(v1, v2, v3);
}
function \u0275\u0275pipeBind4(index, slotOffset, v1, v2, v3, v4) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) : pipeInstance.transform(v1, v2, v3, v4);
}
function \u0275\u0275pipeBindV(index, slotOffset, values) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunctionVInternal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, values, pipeInstance) : pipeInstance.transform.apply(pipeInstance, values);
}
function isPure(lView, index) {
  return lView[TVIEW].data[index].pure;
}
function \u0275\u0275templateRefExtractor(tNode, lView) {
  return createTemplateRef(tNode, lView);
}
function \u0275\u0275getComponentDepsFactory(type, rawImports) {
  return () => {
    try {
      return depsTracker.getComponentDependencies(type, rawImports).dependencies;
    } catch (e2) {
      console.error(`Computing dependencies in local compilation mode for the component "${type.name}" failed with the exception:`, e2);
      throw e2;
    }
  };
}
function \u0275setClassDebugInfo(type, debugInfo) {
  const def = getComponentDef(type);
  if (def !== null) {
    def.debugInfo = debugInfo;
  }
}
function \u0275\u0275getReplaceMetadataURL(id2, timestamp, base) {
  const url = `./@ng/component?c=${id2}&t=${encodeURIComponent(timestamp)}`;
  return new URL(url, base).href;
}
function \u0275\u0275replaceMetadata(type, applyMetadata, namespaces, locals, importMeta = null, id2 = null) {
  ngDevMode && assertComponentDef(type);
  const currentDef = getComponentDef(type);
  applyMetadata.apply(null, [type, namespaces, ...locals]);
  const { newDef, oldDef } = mergeWithExistingDefinition(currentDef, getComponentDef(type));
  type[NG_COMP_DEF] = newDef;
  if (oldDef.tView) {
    const trackedViews = getTrackedLViews().values();
    for (const root of trackedViews) {
      if (isRootView(root) && root[PARENT] === null) {
        recreateMatchingLViews(importMeta, id2, newDef, oldDef, root);
      }
    }
  }
}
function mergeWithExistingDefinition(currentDef, newDef) {
  const clone = __spreadValues({}, currentDef);
  const replacement = Object.assign(currentDef, newDef, {
    // We need to keep the existing directive and pipe defs, because they can get patched on
    // by a call to `setComponentScope` from a module file. That call won't make it into the
    // HMR replacement function, because it lives in an entirely different file.
    directiveDefs: clone.directiveDefs,
    pipeDefs: clone.pipeDefs,
    // Preserve the old `setInput` function, because it has some state.
    // This is fine, because the component instance is preserved as well.
    setInput: clone.setInput,
    // Externally this is redundant since we redeclare the definition using the original type.
    // Internally we may receive a definition with an alternate, but identical, type so we have
    // to ensure that the original one is preserved.
    type: clone.type
  });
  ngDevMode && assertEqual(replacement, currentDef, "Expected definition to be merged in place");
  return { newDef: replacement, oldDef: clone };
}
function recreateMatchingLViews(importMeta, id2, newDef, oldDef, rootLView) {
  ngDevMode && assertDefined(oldDef.tView, "Expected a component definition that has been instantiated at least once");
  const tView = rootLView[TVIEW];
  if (tView === oldDef.tView) {
    ngDevMode && assertComponentDef(oldDef.type);
    recreateLView(importMeta, id2, newDef, oldDef, rootLView);
    return;
  }
  for (let i2 = HEADER_OFFSET; i2 < tView.bindingStartIndex; i2++) {
    const current = rootLView[i2];
    if (isLContainer(current)) {
      if (isLView(current[HOST])) {
        recreateMatchingLViews(importMeta, id2, newDef, oldDef, current[HOST]);
      }
      for (let j2 = CONTAINER_HEADER_OFFSET; j2 < current.length; j2++) {
        recreateMatchingLViews(importMeta, id2, newDef, oldDef, current[j2]);
      }
    } else if (isLView(current)) {
      recreateMatchingLViews(importMeta, id2, newDef, oldDef, current);
    }
  }
}
function clearRendererCache(factory, def) {
  factory.componentReplaced?.(def.id);
}
function recreateLView(importMeta, id2, newDef, oldDef, lView) {
  const instance = lView[CONTEXT];
  let host = lView[HOST];
  const parentLView = lView[PARENT];
  ngDevMode && assertLView(parentLView);
  const tNode = lView[T_HOST];
  ngDevMode && assertTNodeType(
    tNode,
    2
    /* TNodeType.Element */
  );
  ngDevMode && assertNotEqual(newDef, oldDef, "Expected different component definition");
  const zone = lView[INJECTOR].get(NgZone, null);
  const recreate = () => {
    if (oldDef.encapsulation === ViewEncapsulation.ShadowDom) {
      const newHost = host.cloneNode(false);
      host.replaceWith(newHost);
      host = newHost;
    }
    const newTView = getOrCreateComponentTView(newDef);
    const newLView = createLView(
      parentLView,
      newTView,
      instance,
      getInitialLViewFlagsFromDef(newDef),
      host,
      tNode,
      null,
      null,
      // The renderer will be created a bit further down once the old one is destroyed.
      null,
      null,
      null
    );
    replaceLViewInTree(parentLView, lView, newLView, tNode.index);
    destroyLView(lView[TVIEW], lView);
    const rendererFactory = lView[ENVIRONMENT].rendererFactory;
    clearRendererCache(rendererFactory, oldDef);
    newLView[RENDERER] = rendererFactory.createRenderer(host, newDef);
    removeViewFromDOM(lView[TVIEW], lView);
    resetProjectionState(tNode);
    renderView(newTView, newLView, instance);
    refreshView(newTView, newLView, newTView.template, instance);
  };
  if (zone === null) {
    executeWithInvalidateFallback(importMeta, id2, recreate);
  } else {
    zone.run(() => executeWithInvalidateFallback(importMeta, id2, recreate));
  }
}
function executeWithInvalidateFallback(importMeta, id2, callback) {
  try {
    callback();
  } catch (e2) {
    const error = e2;
    if (id2 !== null && error.message) {
      const toLog = error.message + (error.stack ? "\n" + error.stack : "");
      importMeta?.hot?.send?.("angular:invalidate", { id: id2, message: toLog, error: true });
    }
    throw e2;
  }
}
function replaceLViewInTree(parentLView, oldLView, newLView, index) {
  for (let i2 = HEADER_OFFSET; i2 < parentLView[TVIEW].bindingStartIndex; i2++) {
    const current = parentLView[i2];
    if ((isLView(current) || isLContainer(current)) && current[NEXT] === oldLView) {
      current[NEXT] = newLView;
      break;
    }
  }
  if (parentLView[CHILD_HEAD] === oldLView) {
    parentLView[CHILD_HEAD] = newLView;
  }
  if (parentLView[CHILD_TAIL] === oldLView) {
    parentLView[CHILD_TAIL] = newLView;
  }
  newLView[NEXT] = oldLView[NEXT];
  oldLView[NEXT] = null;
  parentLView[index] = newLView;
}
function resetProjectionState(tNode) {
  if (tNode.projection !== null) {
    for (const current of tNode.projection) {
      if (isTNodeShape(current)) {
        current.projectionNext = null;
        current.flags &= ~2;
      }
    }
    tNode.projection = null;
  }
}
function setJitOptions(options) {
  if (jitOptions !== null) {
    if (options.defaultEncapsulation !== jitOptions.defaultEncapsulation) {
      ngDevMode && console.error("Provided value for `defaultEncapsulation` can not be changed once it has been set.");
      return;
    }
    if (options.preserveWhitespaces !== jitOptions.preserveWhitespaces) {
      ngDevMode && console.error("Provided value for `preserveWhitespaces` can not be changed once it has been set.");
      return;
    }
  }
  jitOptions = options;
}
function getJitOptions() {
  return jitOptions;
}
function enqueueModuleForDelayedScoping(moduleType, ngModule) {
  moduleQueue.push({ moduleType, ngModule });
}
function flushModuleScopingQueueAsMuchAsPossible() {
  if (!flushingModuleQueue) {
    flushingModuleQueue = true;
    try {
      for (let i2 = moduleQueue.length - 1; i2 >= 0; i2--) {
        const { moduleType, ngModule } = moduleQueue[i2];
        if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {
          moduleQueue.splice(i2, 1);
          setScopeOnDeclaredComponents(moduleType, ngModule);
        }
      }
    } finally {
      flushingModuleQueue = false;
    }
  }
}
function isResolvedDeclaration(declaration) {
  if (Array.isArray(declaration)) {
    return declaration.every(isResolvedDeclaration);
  }
  return !!resolveForwardRef(declaration);
}
function compileNgModule(moduleType, ngModule = {}) {
  compileNgModuleDefs(moduleType, ngModule);
  if (ngModule.id !== void 0) {
    registerNgModuleType(moduleType, ngModule.id);
  }
  enqueueModuleForDelayedScoping(moduleType, ngModule);
}
function compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {
  ngDevMode && assertDefined(moduleType, "Required value moduleType");
  ngDevMode && assertDefined(ngModule, "Required value ngModule");
  const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
  let ngModuleDef = null;
  Object.defineProperty(moduleType, NG_MOD_DEF, {
    configurable: true,
    get: () => {
      if (ngModuleDef === null) {
        if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {
          throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);
        }
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/\u0275mod.js`, {
          type: moduleType,
          bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),
          declarations: declarations.map(resolveForwardRef),
          imports: flatten(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
          exports: flatten(ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
          schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,
          id: ngModule.id || null
        });
        if (!ngModuleDef.schemas) {
          ngModuleDef.schemas = [];
        }
      }
      return ngModuleDef;
    }
  });
  let ngFactoryDef = null;
  Object.defineProperty(moduleType, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/\u0275fac.js`, {
          name: moduleType.name,
          type: moduleType,
          deps: reflectDependencies(moduleType),
          target: compiler.FactoryTarget.NgModule,
          typeArgumentCount: 0
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
  let ngInjectorDef = null;
  Object.defineProperty(moduleType, NG_INJ_DEF, {
    get: () => {
      if (ngInjectorDef === null) {
        ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);
        const meta = {
          name: moduleType.name,
          type: moduleType,
          providers: ngModule.providers || EMPTY_ARRAY,
          imports: [
            (ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef),
            (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef)
          ]
        };
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngInjectorDef = compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/\u0275inj.js`, meta);
      }
      return ngInjectorDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function generateStandaloneInDeclarationsError(type, location2) {
  const prefix = `Unexpected "${stringifyForError(type)}" found in the "declarations" array of the`;
  const suffix = `"${stringifyForError(type)}" is marked as standalone and can't be declared in any NgModule - did you intend to import it instead (by adding it to the "imports" array)?`;
  return `${prefix} ${location2}, ${suffix}`;
}
function verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {
  if (verifiedNgModule.get(moduleType))
    return;
  if (isStandalone(moduleType))
    return;
  verifiedNgModule.set(moduleType, true);
  moduleType = resolveForwardRef(moduleType);
  let ngModuleDef;
  if (importingModule) {
    ngModuleDef = getNgModuleDef(moduleType);
    if (!ngModuleDef) {
      throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
    }
  } else {
    ngModuleDef = getNgModuleDefOrThrow(moduleType);
  }
  const errors = [];
  const declarations = maybeUnwrapFn(ngModuleDef.declarations);
  const imports = maybeUnwrapFn(ngModuleDef.imports);
  flatten(imports).map(unwrapModuleWithProvidersImports).forEach((modOrStandaloneCmpt) => {
    verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);
    verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);
  });
  const exports = maybeUnwrapFn(ngModuleDef.exports);
  declarations.forEach(verifyDeclarationsHaveDefinitions);
  declarations.forEach(verifyDirectivesHaveSelector);
  declarations.forEach((declarationType) => verifyNotStandalone(declarationType, moduleType));
  const combinedDeclarations = [
    ...declarations.map(resolveForwardRef),
    ...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef)
  ];
  exports.forEach(verifyExportsAreDeclaredOrReExported);
  declarations.forEach((decl) => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));
  const ngModule = getAnnotation(moduleType, "NgModule");
  if (ngModule) {
    ngModule.imports && flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach((mod) => {
      verifySemanticsOfNgModuleImport(mod, moduleType);
      verifySemanticsOfNgModuleDef(mod, false, moduleType);
    });
    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);
    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);
  }
  if (errors.length) {
    throw new Error(errors.join("\n"));
  }
  function verifyDeclarationsHaveDefinitions(type) {
    type = resolveForwardRef(type);
    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);
    if (!def) {
      errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);
    }
  }
  function verifyDirectivesHaveSelector(type) {
    type = resolveForwardRef(type);
    const def = getDirectiveDef(type);
    if (!getComponentDef(type) && def && def.selectors.length == 0) {
      errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);
    }
  }
  function verifyNotStandalone(type, moduleType2) {
    type = resolveForwardRef(type);
    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);
    if (def?.standalone) {
      const location2 = `"${stringifyForError(moduleType2)}" NgModule`;
      errors.push(generateStandaloneInDeclarationsError(type, location2));
    }
  }
  function verifyExportsAreDeclaredOrReExported(type) {
    type = resolveForwardRef(type);
    const kind = getComponentDef(type) && "component" || getDirectiveDef(type) && "directive" || getPipeDef(type) && "pipe";
    if (kind) {
      if (combinedDeclarations.lastIndexOf(type) === -1) {
        errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${stringifyForError(moduleType)} as it was neither declared nor imported!`);
      }
    }
  }
  function verifyDeclarationIsUnique(type, suppressErrors) {
    type = resolveForwardRef(type);
    const existingModule = ownerNgModule.get(type);
    if (existingModule && existingModule !== moduleType) {
      if (!suppressErrors) {
        const modules2 = [existingModule, moduleType].map(stringifyForError).sort();
        errors.push(`Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${modules2[0]} and ${modules2[1]}! Please consider moving ${stringifyForError(type)} to a higher module that imports ${modules2[0]} and ${modules2[1]}. You can also create a new NgModule that exports and includes ${stringifyForError(type)} then import that NgModule in ${modules2[0]} and ${modules2[1]}.`);
      }
    } else {
      ownerNgModule.set(type, moduleType);
    }
  }
  function verifyComponentIsPartOfNgModule(type) {
    type = resolveForwardRef(type);
    const existingModule = ownerNgModule.get(type);
    if (!existingModule && !isStandalone(type)) {
      errors.push(`Component ${stringifyForError(type)} is not part of any NgModule or the module has not been imported into your module.`);
    }
  }
  function verifyCorrectBootstrapType(type) {
    type = resolveForwardRef(type);
    if (!getComponentDef(type)) {
      errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);
    }
    if (isStandalone(type)) {
      errors.push(`The \`${stringifyForError(type)}\` class is a standalone component, which can not be used in the \`@NgModule.bootstrap\` array. Use the \`bootstrapApplication\` function for bootstrap instead.`);
    }
  }
  function verifySemanticsOfNgModuleImport(type, importingModule2) {
    type = resolveForwardRef(type);
    const directiveDef = getComponentDef(type) || getDirectiveDef(type);
    if (directiveDef !== null && !directiveDef.standalone) {
      throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
    }
    const pipeDef = getPipeDef(type);
    if (pipeDef !== null && !pipeDef.standalone) {
      throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
    }
  }
}
function unwrapModuleWithProvidersImports(typeOrWithProviders) {
  typeOrWithProviders = resolveForwardRef(typeOrWithProviders);
  return typeOrWithProviders.ngModule || typeOrWithProviders;
}
function getAnnotation(type, name) {
  let annotation = null;
  collect(type.__annotations__);
  collect(type.decorators);
  return annotation;
  function collect(annotations) {
    if (annotations) {
      annotations.forEach(readAnnotation);
    }
  }
  function readAnnotation(decorator) {
    if (!annotation) {
      const proto = Object.getPrototypeOf(decorator);
      if (proto.ngMetadataName == name) {
        annotation = decorator;
      } else if (decorator.type) {
        const proto2 = Object.getPrototypeOf(decorator.type);
        if (proto2.ngMetadataName == name) {
          annotation = decorator.args[0];
        }
      }
    }
  }
}
function computeCombinedExports(type) {
  type = resolveForwardRef(type);
  const ngModuleDef = getNgModuleDef(type);
  if (ngModuleDef === null) {
    return [type];
  }
  return flatten(maybeUnwrapFn(ngModuleDef.exports).map((type2) => {
    const ngModuleDef2 = getNgModuleDef(type2);
    if (ngModuleDef2) {
      verifySemanticsOfNgModuleDef(type2, false);
      return computeCombinedExports(type2);
    } else {
      return type2;
    }
  }));
}
function setScopeOnDeclaredComponents(moduleType, ngModule) {
  const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
  const transitiveScopes = transitiveScopesFor(moduleType);
  declarations.forEach((declaration) => {
    declaration = resolveForwardRef(declaration);
    if (declaration.hasOwnProperty(NG_COMP_DEF)) {
      const component = declaration;
      const componentDef = getComponentDef(component);
      patchComponentDefWithScope(componentDef, transitiveScopes);
    } else if (!declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {
      declaration.ngSelectorScope = moduleType;
    }
  });
}
function patchComponentDefWithScope(componentDef, transitiveScopes) {
  componentDef.directiveDefs = () => Array.from(transitiveScopes.compilation.directives).map((dir) => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef(dir) : getDirectiveDef(dir)).filter((def) => !!def);
  componentDef.pipeDefs = () => Array.from(transitiveScopes.compilation.pipes).map((pipe2) => getPipeDef(pipe2));
  componentDef.schemas = transitiveScopes.schemas;
  componentDef.tView = null;
}
function transitiveScopesFor(type) {
  if (isNgModule(type)) {
    const scope = depsTracker.getNgModuleScope(type);
    const def = getNgModuleDefOrThrow(type);
    return __spreadValues({
      schemas: def.schemas || null
    }, scope);
  } else if (isStandalone(type)) {
    const directiveDef = getComponentDef(type) || getDirectiveDef(type);
    if (directiveDef !== null) {
      return {
        schemas: null,
        compilation: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set()
        },
        exported: {
          directives: /* @__PURE__ */ new Set([type]),
          pipes: /* @__PURE__ */ new Set()
        }
      };
    }
    const pipeDef = getPipeDef(type);
    if (pipeDef !== null) {
      return {
        schemas: null,
        compilation: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set()
        },
        exported: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set([type])
        }
      };
    }
  }
  throw new Error(`${type.name} does not have a module def (\u0275mod property)`);
}
function expandModuleWithProviders(value) {
  if (isModuleWithProviders(value)) {
    return value.ngModule;
  }
  return value;
}
function compileComponent(type, metadata) {
  (typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode();
  let ngComponentDef = null;
  maybeQueueResolutionOfComponentResources(type, metadata);
  addDirectiveFactoryDef(type, metadata);
  Object.defineProperty(type, NG_COMP_DEF, {
    get: () => {
      if (ngComponentDef === null) {
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "component",
          type
        });
        if (componentNeedsResolution(metadata)) {
          const error = [`Component '${type.name}' is not resolved:`];
          if (metadata.templateUrl) {
            error.push(` - templateUrl: ${metadata.templateUrl}`);
          }
          if (metadata.styleUrls && metadata.styleUrls.length) {
            error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);
          }
          if (metadata.styleUrl) {
            error.push(` - styleUrl: ${metadata.styleUrl}`);
          }
          error.push(`Did you run and wait for 'resolveComponentResources()'?`);
          throw new Error(error.join("\n"));
        }
        const options = getJitOptions();
        let preserveWhitespaces = metadata.preserveWhitespaces;
        if (preserveWhitespaces === void 0) {
          if (options !== null && options.preserveWhitespaces !== void 0) {
            preserveWhitespaces = options.preserveWhitespaces;
          } else {
            preserveWhitespaces = false;
          }
        }
        let encapsulation = metadata.encapsulation;
        if (encapsulation === void 0) {
          if (options !== null && options.defaultEncapsulation !== void 0) {
            encapsulation = options.defaultEncapsulation;
          } else {
            encapsulation = ViewEncapsulation.Emulated;
          }
        }
        const templateUrl = metadata.templateUrl || `ng:///${type.name}/template.html`;
        const baseMeta = directiveMetadata(type, metadata);
        const meta = __spreadProps(__spreadValues({}, baseMeta), {
          typeSourceSpan: compiler.createParseSourceSpan("Component", type.name, templateUrl),
          template: metadata.template || "",
          preserveWhitespaces,
          styles: typeof metadata.styles === "string" ? [metadata.styles] : metadata.styles || EMPTY_ARRAY,
          animations: metadata.animations,
          // JIT components are always compiled against an empty set of `declarations`. Instead, the
          // `directiveDefs` and `pipeDefs` are updated at a later point:
          //  * for NgModule-based components, they're set when the NgModule which declares the
          //    component resolves in the module scoping queue
          //  * for standalone components, they're set just below, after `compileComponent`.
          declarations: [],
          changeDetection: metadata.changeDetection,
          encapsulation,
          interpolation: metadata.interpolation,
          viewProviders: metadata.viewProviders || null,
          // We can't inspect whether any of the dependencies are actually directives, because they
          // get patched on after compilation. That's why in JIT mode we consider that any
          // dependency might be a directive dependency.
          hasDirectiveDependencies: !baseMeta.isStandalone || metadata.imports != null && metadata.imports.length > 0
        });
        compilationDepth++;
        try {
          if (meta.usesInheritance) {
            addDirectiveDefToUndecoratedParents(type);
          }
          ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta);
          if (meta.isStandalone) {
            const imports = flatten(metadata.imports || EMPTY_ARRAY);
            const { directiveDefs, pipeDefs } = getStandaloneDefFunctions(type, imports);
            ngComponentDef.directiveDefs = directiveDefs;
            ngComponentDef.pipeDefs = pipeDefs;
            ngComponentDef.dependencies = () => imports.map(resolveForwardRef);
          }
        } finally {
          compilationDepth--;
        }
        if (compilationDepth === 0) {
          flushModuleScopingQueueAsMuchAsPossible();
        }
        if (hasSelectorScope(type)) {
          const scopes = transitiveScopesFor(type.ngSelectorScope);
          patchComponentDefWithScope(ngComponentDef, scopes);
        }
        if (metadata.schemas) {
          if (meta.isStandalone) {
            ngComponentDef.schemas = metadata.schemas;
          } else {
            throw new Error(`The 'schemas' was specified for the ${stringifyForError(type)} but is only valid on a component that is standalone.`);
          }
        } else if (meta.isStandalone) {
          ngComponentDef.schemas = [];
        }
      }
      return ngComponentDef;
    },
    set: (def) => {
      ngComponentDef = def;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getStandaloneDefFunctions(type, imports) {
  const directiveDefs = () => {
    if (ngDevMode) {
      for (const rawDep of imports) {
        verifyStandaloneImport(rawDep, type);
      }
    }
    if (!isComponent(type)) {
      return [];
    }
    const scope = depsTracker.getStandaloneComponentScope(type, imports);
    return [...scope.compilation.directives].map((p2) => getComponentDef(p2) || getDirectiveDef(p2)).filter((d2) => d2 !== null);
  };
  const pipeDefs = () => {
    if (ngDevMode) {
      for (const rawDep of imports) {
        verifyStandaloneImport(rawDep, type);
      }
    }
    if (!isComponent(type)) {
      return [];
    }
    const scope = depsTracker.getStandaloneComponentScope(type, imports);
    return [...scope.compilation.pipes].map((p2) => getPipeDef(p2)).filter((d2) => d2 !== null);
  };
  return {
    directiveDefs,
    pipeDefs
  };
}
function hasSelectorScope(component) {
  return component.ngSelectorScope !== void 0;
}
function compileDirective(type, directive) {
  let ngDirectiveDef = null;
  addDirectiveFactoryDef(type, directive || {});
  Object.defineProperty(type, NG_DIR_DEF, {
    get: () => {
      if (ngDirectiveDef === null) {
        const meta = getDirectiveMetadata(type, directive || {});
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "directive",
          type
        });
        ngDirectiveDef = compiler.compileDirective(angularCoreEnv, meta.sourceMapUrl, meta.metadata);
      }
      return ngDirectiveDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getDirectiveMetadata(type, metadata) {
  const name = type && type.name;
  const sourceMapUrl = `ng:///${name}/\u0275dir.js`;
  const compiler = getCompilerFacade({ usage: 0, kind: "directive", type });
  const facade = directiveMetadata(type, metadata);
  facade.typeSourceSpan = compiler.createParseSourceSpan("Directive", name, sourceMapUrl);
  if (facade.usesInheritance) {
    addDirectiveDefToUndecoratedParents(type);
  }
  return { metadata: facade, sourceMapUrl };
}
function addDirectiveFactoryDef(type, metadata) {
  let ngFactoryDef = null;
  Object.defineProperty(type, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const meta = getDirectiveMetadata(type, metadata);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "directive",
          type
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${type.name}/\u0275fac.js`, {
          name: meta.metadata.name,
          type: meta.metadata.type,
          typeArgumentCount: 0,
          deps: reflectDependencies(type),
          target: compiler.FactoryTarget.Directive
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function extendsDirectlyFromObject(type) {
  return Object.getPrototypeOf(type.prototype) === Object.prototype;
}
function directiveMetadata(type, metadata) {
  const reflect = getReflect();
  const propMetadata = reflect.ownPropMetadata(type);
  return {
    name: type.name,
    type,
    selector: metadata.selector !== void 0 ? metadata.selector : null,
    host: metadata.host || EMPTY_OBJ,
    propMetadata,
    inputs: metadata.inputs || EMPTY_ARRAY,
    outputs: metadata.outputs || EMPTY_ARRAY,
    queries: extractQueriesMetadata(type, propMetadata, isContentQuery),
    lifecycle: { usesOnChanges: reflect.hasLifecycleHook(type, "ngOnChanges") },
    typeSourceSpan: null,
    usesInheritance: !extendsDirectlyFromObject(type),
    exportAs: extractExportAs(metadata.exportAs),
    providers: metadata.providers || null,
    viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery),
    isStandalone: metadata.standalone === void 0 ? true : !!metadata.standalone,
    isSignal: !!metadata.signals,
    hostDirectives: metadata.hostDirectives?.map((directive) => typeof directive === "function" ? { directive } : directive) || null
  };
}
function addDirectiveDefToUndecoratedParents(type) {
  const objPrototype = Object.prototype;
  let parent = Object.getPrototypeOf(type.prototype).constructor;
  while (parent && parent !== objPrototype) {
    if (!getDirectiveDef(parent) && !getComponentDef(parent) && shouldAddAbstractDirective(parent)) {
      compileDirective(parent, null);
    }
    parent = Object.getPrototypeOf(parent);
  }
}
function convertToR3QueryPredicate(selector) {
  return typeof selector === "string" ? splitByComma(selector) : resolveForwardRef(selector);
}
function convertToR3QueryMetadata(propertyName, ann) {
  return {
    propertyName,
    predicate: convertToR3QueryPredicate(ann.selector),
    descendants: ann.descendants,
    first: ann.first,
    read: ann.read ? ann.read : null,
    static: !!ann.static,
    emitDistinctChangesOnly: !!ann.emitDistinctChangesOnly,
    isSignal: !!ann.isSignal
  };
}
function extractQueriesMetadata(type, propMetadata, isQueryAnn) {
  const queriesMeta = [];
  for (const field in propMetadata) {
    if (propMetadata.hasOwnProperty(field)) {
      const annotations = propMetadata[field];
      annotations.forEach((ann) => {
        if (isQueryAnn(ann)) {
          if (!ann.selector) {
            throw new Error(`Can't construct a query for the property "${field}" of "${stringifyForError(type)}" since the query selector wasn't defined.`);
          }
          if (annotations.some(isInputAnnotation)) {
            throw new Error(`Cannot combine @Input decorators with query decorators`);
          }
          queriesMeta.push(convertToR3QueryMetadata(field, ann));
        }
      });
    }
  }
  return queriesMeta;
}
function extractExportAs(exportAs) {
  return exportAs === void 0 ? null : splitByComma(exportAs);
}
function isContentQuery(value) {
  const name = value.ngMetadataName;
  return name === "ContentChild" || name === "ContentChildren";
}
function isViewQuery(value) {
  const name = value.ngMetadataName;
  return name === "ViewChild" || name === "ViewChildren";
}
function isInputAnnotation(value) {
  return value.ngMetadataName === "Input";
}
function splitByComma(value) {
  return value.split(",").map((piece) => piece.trim());
}
function shouldAddAbstractDirective(type) {
  const reflect = getReflect();
  if (LIFECYCLE_HOOKS.some((hookName) => reflect.hasLifecycleHook(type, hookName))) {
    return true;
  }
  const propMetadata = reflect.propMetadata(type);
  for (const field in propMetadata) {
    const annotations = propMetadata[field];
    for (let i2 = 0; i2 < annotations.length; i2++) {
      const current = annotations[i2];
      const metadataName = current.ngMetadataName;
      if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) || metadataName === "Output" || metadataName === "HostBinding" || metadataName === "HostListener") {
        return true;
      }
    }
  }
  return false;
}
function compilePipe(type, meta) {
  let ngPipeDef = null;
  let ngFactoryDef = null;
  Object.defineProperty(type, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const metadata = getPipeMetadata(type, meta);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "pipe",
          type: metadata.type
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${metadata.name}/\u0275fac.js`, {
          name: metadata.name,
          type: metadata.type,
          typeArgumentCount: 0,
          deps: reflectDependencies(type),
          target: compiler.FactoryTarget.Pipe
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
  Object.defineProperty(type, NG_PIPE_DEF, {
    get: () => {
      if (ngPipeDef === null) {
        const metadata = getPipeMetadata(type, meta);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "pipe",
          type: metadata.type
        });
        ngPipeDef = compiler.compilePipe(angularCoreEnv, `ng:///${metadata.name}/\u0275pipe.js`, metadata);
      }
      return ngPipeDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getPipeMetadata(type, meta) {
  return {
    type,
    name: type.name,
    pipeName: meta.name,
    pure: meta.pure !== void 0 ? meta.pure : true,
    isStandalone: meta.standalone === void 0 ? true : !!meta.standalone
  };
}
function internalProvideZoneChangeDetection({ ngZoneFactory, ignoreChangesOutsideZone, scheduleInRootZone }) {
  ngZoneFactory ??= () => new NgZone(__spreadProps(__spreadValues({}, getNgZoneOptions()), { scheduleInRootZone }));
  return [
    { provide: NgZone, useFactory: ngZoneFactory },
    {
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const ngZoneChangeDetectionScheduler = inject2(NgZoneChangeDetectionScheduler, {
          optional: true
        });
        if ((typeof ngDevMode === "undefined" || ngDevMode) && ngZoneChangeDetectionScheduler === null) {
          throw new RuntimeError(402, `A required Injectable was not found in the dependency injection tree. If you are bootstrapping an NgModule, make sure that the \`BrowserModule\` is imported.`);
        }
        return () => ngZoneChangeDetectionScheduler.initialize();
      }
    },
    {
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const service = inject2(ZoneStablePendingTask);
        return () => {
          service.initialize();
        };
      }
    },
    // Always disable scheduler whenever explicitly disabled, even if another place called
    // `provideZoneChangeDetection` without the 'ignore' option.
    ignoreChangesOutsideZone === true ? { provide: ZONELESS_SCHEDULER_DISABLED, useValue: true } : [],
    {
      provide: SCHEDULE_IN_ROOT_ZONE,
      useValue: scheduleInRootZone ?? SCHEDULE_IN_ROOT_ZONE_DEFAULT
    },
    {
      provide: INTERNAL_APPLICATION_ERROR_HANDLER,
      useFactory: () => {
        const zone = inject2(NgZone);
        const injector = inject2(EnvironmentInjector);
        let userErrorHandler;
        return (e2) => {
          zone.runOutsideAngular(() => {
            if (injector.destroyed && !userErrorHandler) {
              setTimeout(() => {
                throw e2;
              });
            } else {
              userErrorHandler ??= injector.get(ErrorHandler);
              userErrorHandler.handleError(e2);
            }
          });
        };
      }
    }
  ];
}
function provideZoneChangeDetection(options) {
  const ignoreChangesOutsideZone = options?.ignoreChangesOutsideZone;
  const scheduleInRootZone = options?.scheduleInRootZone;
  const zoneProviders = internalProvideZoneChangeDetection({
    ngZoneFactory: () => {
      const ngZoneOptions = getNgZoneOptions(options);
      ngZoneOptions.scheduleInRootZone = scheduleInRootZone;
      if (ngZoneOptions.shouldCoalesceEventChangeDetection) {
        performanceMarkFeature("NgZone_CoalesceEvent");
      }
      return new NgZone(ngZoneOptions);
    },
    ignoreChangesOutsideZone,
    scheduleInRootZone
  });
  return makeEnvironmentProviders([
    { provide: PROVIDED_NG_ZONE, useValue: true },
    { provide: ZONELESS_ENABLED, useValue: false },
    zoneProviders
  ]);
}
function getNgZoneOptions(options) {
  return {
    enableLongStackTrace: typeof ngDevMode === "undefined" ? false : !!ngDevMode,
    shouldCoalesceEventChangeDetection: options?.eventCoalescing ?? false,
    shouldCoalesceRunChangeDetection: options?.runCoalescing ?? false
  };
}
function trackMicrotaskNotificationForDebugging() {
  consecutiveMicrotaskNotifications++;
  if (CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT - consecutiveMicrotaskNotifications < 5) {
    const stack = new Error().stack;
    if (stack) {
      stackFromLastFewNotifications.push(stack);
    }
  }
  if (consecutiveMicrotaskNotifications === CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT) {
    throw new RuntimeError(103, "Angular could not stabilize because there were endless change notifications within the browser event loop. The stack from the last several notifications: \n" + stackFromLastFewNotifications.join("\n"));
  }
}
function getGlobalLocale() {
  if (false) {
    return goog.LOCALE;
  } else {
    return typeof $localize !== "undefined" && $localize.locale || DEFAULT_LOCALE_ID;
  }
}
var ANNOTATIONS, PARAMETERS, PROP_METADATA, Inject, Optional, Self, SkipSelf, Host, angularCoreDiEnv, Type, ES5_DELEGATE_CTOR, ES2015_INHERITED_CLASS, ES2015_INHERITED_CLASS_WITH_CTOR, ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR, ReflectionCapabilities, SimpleChange, \u0275\u0275NgOnChangesFeature, SIMPLE_CHANGES_STORE, profilerCallbacks, NOOP_PROFILER_REMOVAL2, profiler, NO_PARENT_INJECTOR, NodeInjectorFactory, includeViewProviders, BLOOM_SIZE, BLOOM_MASK, BLOOM_BUCKET_BITS, nextNgElementId, NOT_FOUND2, injectionPath, NodeInjector, Attribute, _reflect, USE_VALUE2, Injectable, ElementRef, QueryList, ChangeDetectionStrategy, TRACKED_LVIEWS, uniqueIdCounter, LContext, MONKEY_PATCH_KEY_NAME, Framework, AcxChangeDetectionStrategy, AcxViewEncapsulation, DOCUMENT2, APP_ID, DEFAULT_APP_ID, PLATFORM_INITIALIZER, PLATFORM_ID, PACKAGE_ROOT_URL, ANIMATION_MODULE_TYPE, CSP_NONCE, IMAGE_CONFIG_DEFAULTS, IMAGE_CONFIG, TransferState, REFERENCE_NODE_HOST, REFERENCE_NODE_BODY, NUM_ROOT_NODES, DEFER_BLOCK_ID, DEFER_BLOCK_STATE$1, DEFER_PARENT_BLOCK_ID, IS_HYDRATION_DOM_REUSE_ENABLED, PRESERVE_HOST_CONTENT_DEFAULT, PRESERVE_HOST_CONTENT, IS_I18N_HYDRATION_ENABLED, IS_EVENT_REPLAY_ENABLED, IS_INCREMENTAL_HYDRATION_ENABLED, JSACTION_BLOCK_ELEMENT_MAP, eventListenerOptions, hoverTriggers, interactionTriggers, viewportTriggers, interactionEventNames, hoverEventNames, intersectionObserver, observedViewportElements, DeferEventEntry, JSACTION_EVENT_CONTRACT, _stashEventListenerImpl, DEHYDRATED_BLOCK_REGISTRY, TRANSFER_STATE_TOKEN_ID, NGH_DATA_KEY, TRANSFER_STATE_DEFER_BLOCKS_INFO, NGH_DEFER_BLOCKS_KEY, _retrieveHydrationInfoImpl, HydrationStatus, HYDRATION_INFO_KEY, ViewEncapsulation, policy$1, policy, SafeValueImpl, SafeHtmlImpl, SafeStyleImpl, SafeScriptImpl, SafeUrlImpl, SafeResourceUrlImpl, DOMParserHelper, InertDocumentHelper, SAFE_URL_PATTERN, VOID_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS, OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, VALID_ELEMENTS, URI_ATTRS, HTML_ATTRS, ARIA_ATTRS, VALID_ATTRS, SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS, SanitizingHtmlSerializer, SURROGATE_PAIR_REGEXP, NON_ALPHANUMERIC_REGEXP, inertBodyHelper, SecurityContext, COMMENT_DISALLOWED, COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED, NG_REFLECT_ATTRS_FLAG_DEFAULT, NG_REFLECT_ATTRS_FLAG, CAMEL_CASE_REGEXP, CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, shouldThrowErrorOnUnknownElement, shouldThrowErrorOnUnknownProperty, KNOWN_CONTROL_FLOW_DIRECTIVES, INTERPOLATION_DELIMITER, VALUE_STRING_LENGTH_LIMIT, NG_TEMPLATE_SELECTOR, NO_CHANGE, InputFlags, RendererStyleFlags2, _icuContainerIterate, _getInsertInFrontOfRNodeWithI18n, _processI18nInsertBefore, _applyRootElementTransformImpl, USE_EXHAUSTIVE_CHECK_NO_CHANGES_DEFAULT, UseExhaustiveCheckNoChanges, freeConsumers, REACTIVE_LVIEW_CONSUMER_NODE, TEMPORARY_CONSUMER_NODE, MAXIMUM_REFRESH_RERUNS$1, ViewRef, TemplateRef, AT_THIS_LOCATION, internalAttrs, REF_EXTRACTOR_REGEXP, _prepareI18nBlockForHydrationImpl, _claimDehydratedIcuCaseImpl, _findMatchingDehydratedViewImpl, _findAndReconcileMatchingDehydratedViewsImpl, ComponentRef$1, ComponentFactory$1, _NullComponentFactoryResolver, ComponentFactoryResolver$1, RendererFactory2, Renderer2, Sanitizer, DepsTracker, depsTracker, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, ChainedInjector, BINDING, ComponentFactoryResolver2, ComponentFactory2, ComponentRef2, ViewContainerRef, VE_ViewContainerRef, R3ViewContainerRef, _locateOrCreateAnchorNode, _populateDehydratedViewsInLContainer, LQuery_, LQueries_, TQueryMetadata_, TQueries_, TQuery_, componentResourceResolutionQueue, componentDefPendingResolution, modules, checkForDuplicateNgModules, markedFeatures, NgModuleRef$1, NgModuleFactory$1, NgModuleRef2, NgModuleFactory2, EnvironmentNgModuleRefAdapter, StandaloneService, GENERATED_COMP_IDS, COPY_DIRECTIVE_FIELDS, COPY_COMPONENT_FIELDS, _locateOrCreateContainerAnchor, DeferDependenciesLoadingState, MINIMUM_SLOT, LOADING_AFTER_SLOT, DeferBlockState, DeferBlockInternalState, NEXT_DEFER_BLOCK_STATE, DEFER_BLOCK_STATE, STATE_IS_FROZEN_UNTIL, LOADING_AFTER_CLEANUP_FN, TRIGGER_CLEANUP_FNS, PREFETCH_TRIGGER_CLEANUP_FNS, SSR_UNIQUE_ID, SSR_BLOCK_STATE, ON_COMPLETE_FNS, HYDRATE_TRIGGER_CLEANUP_FNS, DeferBlockBehavior, TracingAction, TracingService, SCHEDULE_IN_ROOT_ZONE_DEFAULT, EventEmitter_, EventEmitter, AsyncStackTaggingZoneSpec, isAngularZoneProperty, angularZoneInstanceIdProperty, ngZoneInstanceId, NgZone, EMPTY_PAYLOAD, NoopNgZone, AfterRenderManager, AFTER_RENDER_PHASES, AfterRenderImpl, AfterRenderSequence, _requestIdleCallback, _cancelIdleCallback, IdleScheduler, TimerScheduler, CachedInjectorService, DEFER_BLOCK_DEPENDENCY_INTERCEPTOR, DEFER_BLOCK_CONFIG, applyDeferBlockStateWithSchedulingImpl, Console, DIDebugData, frameworkDIDebugData, signalDebugMap, counter$1, changeDetectionRuns, changeDetectionSyncRuns, counter, eventsStack, chromeDevToolsInjectorProfiler, devToolsProfiler, GLOBAL_PUBLISH_EXPANDO_KEY, globalUtilsFunctions, _published, TESTABILITY, TESTABILITY_GETTER, Testability, TestabilityRegistry, _testabilityGetter, APP_INITIALIZER, ApplicationInitStatus, APP_BOOTSTRAP_LISTENER, MAXIMUM_REFRESH_RERUNS, ApplicationRef, LiveCollection, UniqueValueMultiKeyMap, RepeaterContext, RepeaterMetadata, OperationsCounter, LiveCollectionLContainerImpl, _locateOrCreateElementNode, _locateOrCreateElementContainerNode, u, localeEn, LOCALE_DATA, LocaleDataIndex, pluralMapping, DEFAULT_LOCALE_ID, USD_CURRENCY_CODE, ELEMENT_MARKER, ICU_MARKER, I18nCreateOpCode, LOCALE_ID$1, changeMask, changeMaskCounter, _locateOrCreateNode, OpCodeParser, BINDING_REGEXP, ICU_REGEXP, NESTED_ICU, ICU_BLOCK_REGEXP, MARKER, SUBTEMPLATE_REGEXP, PH_REGEXP, NGSP_UNICODE_REGEXP, ROOT_TEMPLATE_ID, PP_MULTI_VALUE_PLACEHOLDERS_REGEXP, PP_PLACEHOLDERS_REGEXP, PP_ICU_VARS_REGEXP, PP_ICU_PLACEHOLDERS_REGEXP, PP_ICUS_REGEXP, PP_CLOSE_TEMPLATE_REGEXP, PP_TEMPLATE_ID_REGEXP, parserState, _locateOrCreateTextNode, UNINITIALIZED_LET, angularCoreEnv, jitOptions, moduleQueue, flushingModuleQueue, ownerNgModule, verifiedNgModule, compilationDepth, LIFECYCLE_HOOKS, Directive, Component, Pipe, Input, Output, HostBinding, HostListener, NgModule, ModuleWithComponentFactories, Compiler, COMPILER_OPTIONS, NgZoneChangeDetectionScheduler, PROVIDED_NG_ZONE, ZoneStablePendingTask, CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT, consecutiveMicrotaskNotifications, stackFromLastFewNotifications, ChangeDetectionSchedulerImpl, LOCALE_ID, DEFAULT_CURRENCY_CODE, TRANSLATIONS, TRANSLATIONS_FORMAT, MissingTranslationStrategy;
var init_debug_node = __esm({
  "node_modules/@angular/core/fesm2022/debug_node.mjs"() {
    "use strict";
    init_root_effect_scheduler();
    init_signal();
    init_esm();
    init_signals();
    init_operators();
    ANNOTATIONS = "__annotations__";
    PARAMETERS = "__parameters__";
    PROP_METADATA = "__prop__metadata__";
    Inject = attachInjectFlag(
      // Disable tslint because `DecoratorFlags` is a const enum which gets inlined.
      makeParamDecorator("Inject", (token) => ({ token })),
      -1
      /* DecoratorFlags.Inject */
    );
    Optional = // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
    // tslint:disable-next-line: no-toplevel-property-access
    attachInjectFlag(
      makeParamDecorator("Optional"),
      8
      /* InternalInjectFlags.Optional */
    );
    Self = // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
    // tslint:disable-next-line: no-toplevel-property-access
    attachInjectFlag(
      makeParamDecorator("Self"),
      2
      /* InternalInjectFlags.Self */
    );
    SkipSelf = // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
    // tslint:disable-next-line: no-toplevel-property-access
    attachInjectFlag(
      makeParamDecorator("SkipSelf"),
      4
      /* InternalInjectFlags.SkipSelf */
    );
    Host = // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
    // tslint:disable-next-line: no-toplevel-property-access
    attachInjectFlag(
      makeParamDecorator("Host"),
      1
      /* InternalInjectFlags.Host */
    );
    angularCoreDiEnv = {
      "\u0275\u0275defineInjectable": \u0275\u0275defineInjectable,
      "\u0275\u0275defineInjector": \u0275\u0275defineInjector,
      "\u0275\u0275inject": \u0275\u0275inject,
      "\u0275\u0275invalidFactoryDep": \u0275\u0275invalidFactoryDep,
      "resolveForwardRef": resolveForwardRef
    };
    Type = Function;
    ES5_DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/;
    ES2015_INHERITED_CLASS = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/;
    ES2015_INHERITED_CLASS_WITH_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/;
    ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{[^}]*super\(\.\.\.arguments\)/;
    ReflectionCapabilities = class {
      _reflect;
      constructor(reflect) {
        this._reflect = reflect || _global["Reflect"];
      }
      factory(t2) {
        return (...args) => new t2(...args);
      }
      /** @internal */
      _zipTypesAndAnnotations(paramTypes, paramAnnotations) {
        let result;
        if (typeof paramTypes === "undefined") {
          result = newArray(paramAnnotations.length);
        } else {
          result = newArray(paramTypes.length);
        }
        for (let i2 = 0; i2 < result.length; i2++) {
          if (typeof paramTypes === "undefined") {
            result[i2] = [];
          } else if (paramTypes[i2] && paramTypes[i2] != Object) {
            result[i2] = [paramTypes[i2]];
          } else {
            result[i2] = [];
          }
          if (paramAnnotations && paramAnnotations[i2] != null) {
            result[i2] = result[i2].concat(paramAnnotations[i2]);
          }
        }
        return result;
      }
      _ownParameters(type, parentCtor) {
        const typeStr = type.toString();
        if (isDelegateCtor(typeStr)) {
          return null;
        }
        if (type.parameters && type.parameters !== parentCtor.parameters) {
          return type.parameters;
        }
        const tsickleCtorParams = type.ctorParameters;
        if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
          const ctorParameters = typeof tsickleCtorParams === "function" ? tsickleCtorParams() : tsickleCtorParams;
          const paramTypes2 = ctorParameters.map((ctorParam) => ctorParam && ctorParam.type);
          const paramAnnotations2 = ctorParameters.map((ctorParam) => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));
          return this._zipTypesAndAnnotations(paramTypes2, paramAnnotations2);
        }
        const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];
        const paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata("design:paramtypes", type);
        if (paramTypes || paramAnnotations) {
          return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
        }
        return newArray(type.length);
      }
      parameters(type) {
        if (!isType(type)) {
          return [];
        }
        const parentCtor = getParentCtor(type);
        let parameters = this._ownParameters(type, parentCtor);
        if (!parameters && parentCtor !== Object) {
          parameters = this.parameters(parentCtor);
        }
        return parameters || [];
      }
      _ownAnnotations(typeOrFunc, parentCtor) {
        if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {
          let annotations = typeOrFunc.annotations;
          if (typeof annotations === "function" && annotations.annotations) {
            annotations = annotations.annotations;
          }
          return annotations;
        }
        if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {
          return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
        }
        if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {
          return typeOrFunc[ANNOTATIONS];
        }
        return null;
      }
      annotations(typeOrFunc) {
        if (!isType(typeOrFunc)) {
          return [];
        }
        const parentCtor = getParentCtor(typeOrFunc);
        const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
        const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
        return parentAnnotations.concat(ownAnnotations);
      }
      _ownPropMetadata(typeOrFunc, parentCtor) {
        if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {
          let propMetadata = typeOrFunc.propMetadata;
          if (typeof propMetadata === "function" && propMetadata.propMetadata) {
            propMetadata = propMetadata.propMetadata;
          }
          return propMetadata;
        }
        if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {
          const propDecorators = typeOrFunc.propDecorators;
          const propMetadata = {};
          Object.keys(propDecorators).forEach((prop) => {
            propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);
          });
          return propMetadata;
        }
        if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {
          return typeOrFunc[PROP_METADATA];
        }
        return null;
      }
      propMetadata(typeOrFunc) {
        if (!isType(typeOrFunc)) {
          return {};
        }
        const parentCtor = getParentCtor(typeOrFunc);
        const propMetadata = {};
        if (parentCtor !== Object) {
          const parentPropMetadata = this.propMetadata(parentCtor);
          Object.keys(parentPropMetadata).forEach((propName) => {
            propMetadata[propName] = parentPropMetadata[propName];
          });
        }
        const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
        if (ownPropMetadata) {
          Object.keys(ownPropMetadata).forEach((propName) => {
            const decorators = [];
            if (propMetadata.hasOwnProperty(propName)) {
              decorators.push(...propMetadata[propName]);
            }
            decorators.push(...ownPropMetadata[propName]);
            propMetadata[propName] = decorators;
          });
        }
        return propMetadata;
      }
      ownPropMetadata(typeOrFunc) {
        if (!isType(typeOrFunc)) {
          return {};
        }
        return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};
      }
      hasLifecycleHook(type, lcProperty) {
        return type instanceof Type && lcProperty in type.prototype;
      }
    };
    SimpleChange = class {
      previousValue;
      currentValue;
      firstChange;
      constructor(previousValue, currentValue, firstChange) {
        this.previousValue = previousValue;
        this.currentValue = currentValue;
        this.firstChange = firstChange;
      }
      /**
       * Check whether the new value is the first value assigned.
       */
      isFirstChange() {
        return this.firstChange;
      }
    };
    \u0275\u0275NgOnChangesFeature = /* @__PURE__ */ (() => {
      const \u0275\u0275NgOnChangesFeatureImpl = () => NgOnChangesFeatureImpl;
      \u0275\u0275NgOnChangesFeatureImpl.ngInherit = true;
      return \u0275\u0275NgOnChangesFeatureImpl;
    })();
    SIMPLE_CHANGES_STORE = "__ngSimpleChanges__";
    profilerCallbacks = [];
    NOOP_PROFILER_REMOVAL2 = () => {
    };
    profiler = function(event, instance = null, eventFn) {
      for (let i2 = 0; i2 < profilerCallbacks.length; i2++) {
        const profilerCallback = profilerCallbacks[i2];
        profilerCallback(event, instance, eventFn);
      }
    };
    NO_PARENT_INJECTOR = -1;
    NodeInjectorFactory = class {
      factory;
      name;
      /**
       * The inject implementation to be activated when using the factory.
       */
      injectImpl;
      /**
       * Marker set to true during factory invocation to see if we get into recursive loop.
       * Recursive loop causes an error to be displayed.
       */
      resolving = false;
      /**
       * Marks that the token can see other Tokens declared in `viewProviders` on the same node.
       */
      canSeeViewProviders;
      /**
       * An array of factories to use in case of `multi` provider.
       */
      multi;
      /**
       * Number of `multi`-providers which belong to the component.
       *
       * This is needed because when multiple components and directives declare the `multi` provider
       * they have to be concatenated in the correct order.
       *
       * Example:
       *
       * If we have a component and directive active an a single element as declared here
       * ```ts
       * component:
       *   providers: [ {provide: String, useValue: 'component', multi: true} ],
       *   viewProviders: [ {provide: String, useValue: 'componentView', multi: true} ],
       *
       * directive:
       *   providers: [ {provide: String, useValue: 'directive', multi: true} ],
       * ```
       *
       * Then the expected results are:
       *
       * ```ts
       * providers: ['component', 'directive']
       * viewProviders: ['component', 'componentView', 'directive']
       * ```
       *
       * The way to think about it is that the `viewProviders` have been inserted after the component
       * but before the directives, which is why we need to know how many `multi`s have been declared by
       * the component.
       */
      componentProviders;
      /**
       * Current index of the Factory in the `data`. Needed for `viewProviders` and `providers` merging.
       * See `providerFactory`.
       */
      index;
      /**
       * Because the same `multi` provider can be declared in `providers` and `viewProviders` it is
       * possible for `viewProviders` to shadow the `providers`. For this reason we store the
       * `provideFactory` of the `providers` so that `providers` can be extended with `viewProviders`.
       *
       * Example:
       *
       * Given:
       * ```ts
       * providers: [ {provide: String, useValue: 'all', multi: true} ],
       * viewProviders: [ {provide: String, useValue: 'viewOnly', multi: true} ],
       * ```
       *
       * We have to return `['all']` in case of content injection, but `['all', 'viewOnly']` in case
       * of view injection. We further have to make sure that the shared instances (in our case
       * `all`) are the exact same instance in both the content as well as the view injection. (We
       * have to make sure that we don't double instantiate.) For this reason the `viewProviders`
       * `Factory` has a pointer to the shadowed `providers` factory so that it can instantiate the
       * `providers` (`['all']`) and then extend it with `viewProviders` (`['all'] + ['viewOnly'] =
       * ['all', 'viewOnly']`).
       */
      providerFactory;
      constructor(factory, isViewProvider, injectImplementation, name) {
        this.factory = factory;
        this.name = name;
        ngDevMode && assertDefined(factory, "Factory not specified");
        ngDevMode && assertEqual(typeof factory, "function", "Expected factory function.");
        this.canSeeViewProviders = isViewProvider;
        this.injectImpl = injectImplementation;
      }
    };
    includeViewProviders = true;
    BLOOM_SIZE = 256;
    BLOOM_MASK = BLOOM_SIZE - 1;
    BLOOM_BUCKET_BITS = 5;
    nextNgElementId = 0;
    NOT_FOUND2 = {};
    injectionPath = [];
    NodeInjector = class {
      _tNode;
      _lView;
      constructor(_tNode, _lView) {
        this._tNode = _tNode;
        this._lView = _lView;
      }
      get(token, notFoundValue, flags) {
        return getOrCreateInjectable(this._tNode, this._lView, token, convertToBitFlags(flags), notFoundValue);
      }
    };
    Attribute = makeParamDecorator("Attribute", (attributeName) => ({
      attributeName,
      __NG_ELEMENT_ID__: () => \u0275\u0275injectAttribute(attributeName)
    }));
    _reflect = null;
    USE_VALUE2 = getClosureSafeProperty({
      provide: String,
      useValue: getClosureSafeProperty
    });
    Injectable = makeDecorator("Injectable", void 0, void 0, void 0, (type, meta) => compileInjectable(type, meta));
    ElementRef = class {
      /**
       * <div class="docs-alert docs-alert-important">
       *   <header>Use with caution</header>
       *   <p>
       *    Use this API as the last resort when direct access to DOM is needed. Use templating and
       *    data-binding provided by Angular instead. If used, it is recommended in combination with
       *    {@link /best-practices/security#direct-use-of-the-dom-apis-and-explicit-sanitization-calls DomSanitizer}
       *    for maxiumum security;
       *   </p>
       * </div>
       */
      nativeElement;
      constructor(nativeElement) {
        this.nativeElement = nativeElement;
      }
      /**
       * @internal
       * @nocollapse
       */
      static __NG_ELEMENT_ID__ = injectElementRef;
    };
    QueryList = class {
      _emitDistinctChangesOnly;
      dirty = true;
      _onDirty = void 0;
      _results = [];
      _changesDetected = false;
      _changes = void 0;
      length = 0;
      first = void 0;
      last = void 0;
      /**
       * Returns `Observable` of `QueryList` notifying the subscriber of changes.
       */
      get changes() {
        return this._changes ??= new Subject();
      }
      /**
       * @param emitDistinctChangesOnly Whether `QueryList.changes` should fire only when actual change
       *     has occurred. Or if it should fire when query is recomputed. (recomputing could resolve in
       *     the same result)
       */
      constructor(_emitDistinctChangesOnly = false) {
        this._emitDistinctChangesOnly = _emitDistinctChangesOnly;
      }
      /**
       * Returns the QueryList entry at `index`.
       */
      get(index) {
        return this._results[index];
      }
      /**
       * See
       * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
       */
      map(fn) {
        return this._results.map(fn);
      }
      filter(fn) {
        return this._results.filter(fn);
      }
      /**
       * See
       * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
       */
      find(fn) {
        return this._results.find(fn);
      }
      /**
       * See
       * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
       */
      reduce(fn, init) {
        return this._results.reduce(fn, init);
      }
      /**
       * See
       * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
       */
      forEach(fn) {
        this._results.forEach(fn);
      }
      /**
       * See
       * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
       */
      some(fn) {
        return this._results.some(fn);
      }
      /**
       * Returns a copy of the internal results list as an Array.
       */
      toArray() {
        return this._results.slice();
      }
      toString() {
        return this._results.toString();
      }
      /**
       * Updates the stored data of the query list, and resets the `dirty` flag to `false`, so that
       * on change detection, it will not notify of changes to the queries, unless a new change
       * occurs.
       *
       * @param resultsTree The query results to store
       * @param identityAccessor Optional function for extracting stable object identity from a value
       *    in the array. This function is executed for each element of the query result list while
       *    comparing current query list with the new one (provided as a first argument of the `reset`
       *    function) to detect if the lists are different. If the function is not provided, elements
       *    are compared as is (without any pre-processing).
       */
      reset(resultsTree, identityAccessor) {
        this.dirty = false;
        const newResultFlat = flatten(resultsTree);
        if (this._changesDetected = !arrayEquals(this._results, newResultFlat, identityAccessor)) {
          this._results = newResultFlat;
          this.length = newResultFlat.length;
          this.last = newResultFlat[this.length - 1];
          this.first = newResultFlat[0];
        }
      }
      /**
       * Triggers a change event by emitting on the `changes` {@link EventEmitter}.
       */
      notifyOnChanges() {
        if (this._changes !== void 0 && (this._changesDetected || !this._emitDistinctChangesOnly))
          this._changes.next(this);
      }
      /** @internal */
      onDirty(cb) {
        this._onDirty = cb;
      }
      /** internal */
      setDirty() {
        this.dirty = true;
        this._onDirty?.();
      }
      /** internal */
      destroy() {
        if (this._changes !== void 0) {
          this._changes.complete();
          this._changes.unsubscribe();
        }
      }
      [Symbol.iterator] = /* @__PURE__ */ (() => symbolIterator)();
    };
    (function(ChangeDetectionStrategy2) {
      ChangeDetectionStrategy2[ChangeDetectionStrategy2["OnPush"] = 0] = "OnPush";
      ChangeDetectionStrategy2[ChangeDetectionStrategy2["Default"] = 1] = "Default";
    })(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));
    TRACKED_LVIEWS = /* @__PURE__ */ new Map();
    uniqueIdCounter = 0;
    LContext = class {
      lViewId;
      nodeIndex;
      native;
      /**
       * The instance of the Component node.
       */
      component;
      /**
       * The list of active directives that exist on this element.
       */
      directives;
      /**
       * The map of local references (local reference name => element or directive instance) that
       * exist on this element.
       */
      localRefs;
      /** Component's parent view data. */
      get lView() {
        return getLViewById(this.lViewId);
      }
      constructor(lViewId, nodeIndex, native) {
        this.lViewId = lViewId;
        this.nodeIndex = nodeIndex;
        this.native = native;
      }
    };
    MONKEY_PATCH_KEY_NAME = "__ngContext__";
    (function(Framework2) {
      Framework2["Angular"] = "angular";
      Framework2["ACX"] = "acx";
      Framework2["Wiz"] = "wiz";
    })(Framework || (Framework = {}));
    (function(AcxChangeDetectionStrategy2) {
      AcxChangeDetectionStrategy2[AcxChangeDetectionStrategy2["Default"] = 0] = "Default";
      AcxChangeDetectionStrategy2[AcxChangeDetectionStrategy2["OnPush"] = 1] = "OnPush";
    })(AcxChangeDetectionStrategy || (AcxChangeDetectionStrategy = {}));
    (function(AcxViewEncapsulation2) {
      AcxViewEncapsulation2[AcxViewEncapsulation2["Emulated"] = 0] = "Emulated";
      AcxViewEncapsulation2[AcxViewEncapsulation2["None"] = 1] = "None";
    })(AcxViewEncapsulation || (AcxViewEncapsulation = {}));
    DOCUMENT2 = void 0;
    APP_ID = new InjectionToken(ngDevMode ? "AppId" : "", {
      providedIn: "root",
      factory: () => DEFAULT_APP_ID
    });
    DEFAULT_APP_ID = "ng";
    PLATFORM_INITIALIZER = new InjectionToken(ngDevMode ? "Platform Initializer" : "");
    PLATFORM_ID = new InjectionToken(ngDevMode ? "Platform ID" : "", {
      providedIn: "platform",
      factory: () => "unknown"
      // set a default platform name, when none set explicitly
    });
    PACKAGE_ROOT_URL = new InjectionToken(ngDevMode ? "Application Packages Root URL" : "");
    ANIMATION_MODULE_TYPE = new InjectionToken(ngDevMode ? "AnimationModuleType" : "");
    CSP_NONCE = new InjectionToken(ngDevMode ? "CSP nonce" : "", {
      providedIn: "root",
      factory: () => {
        return getDocument().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null;
      }
    });
    IMAGE_CONFIG_DEFAULTS = {
      breakpoints: [16, 32, 48, 64, 96, 128, 256, 384, 640, 750, 828, 1080, 1200, 1920, 2048, 3840],
      placeholderResolution: 30,
      disableImageSizeWarning: false,
      disableImageLazyLoadWarning: false
    };
    IMAGE_CONFIG = new InjectionToken(ngDevMode ? "ImageConfig" : "", {
      providedIn: "root",
      factory: () => IMAGE_CONFIG_DEFAULTS
    });
    TransferState = class _TransferState {
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _TransferState,
          providedIn: "root",
          factory: initTransferState
        })
      );
      /** @internal */
      store = {};
      onSerializeCallbacks = {};
      /**
       * Get the value corresponding to a key. Return `defaultValue` if key is not found.
       */
      get(key, defaultValue) {
        return this.store[key] !== void 0 ? this.store[key] : defaultValue;
      }
      /**
       * Set the value corresponding to a key.
       */
      set(key, value) {
        this.store[key] = value;
      }
      /**
       * Remove a key from the store.
       */
      remove(key) {
        delete this.store[key];
      }
      /**
       * Test whether a key exists in the store.
       */
      hasKey(key) {
        return this.store.hasOwnProperty(key);
      }
      /**
       * Indicates whether the state is empty.
       */
      get isEmpty() {
        return Object.keys(this.store).length === 0;
      }
      /**
       * Register a callback to provide the value for a key when `toJson` is called.
       */
      onSerialize(key, callback) {
        this.onSerializeCallbacks[key] = callback;
      }
      /**
       * Serialize the current state of the store to JSON.
       */
      toJson() {
        for (const key in this.onSerializeCallbacks) {
          if (this.onSerializeCallbacks.hasOwnProperty(key)) {
            try {
              this.store[key] = this.onSerializeCallbacks[key]();
            } catch (e2) {
              console.warn("Exception in onSerialize callback: ", e2);
            }
          }
        }
        return JSON.stringify(this.store).replace(/</g, "\\u003C");
      }
    };
    REFERENCE_NODE_HOST = "h";
    REFERENCE_NODE_BODY = "b";
    NUM_ROOT_NODES = "r";
    DEFER_BLOCK_ID = "di";
    DEFER_BLOCK_STATE$1 = "s";
    DEFER_PARENT_BLOCK_ID = "p";
    IS_HYDRATION_DOM_REUSE_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_HYDRATION_DOM_REUSE_ENABLED" : "");
    PRESERVE_HOST_CONTENT_DEFAULT = false;
    PRESERVE_HOST_CONTENT = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "PRESERVE_HOST_CONTENT" : "", {
      providedIn: "root",
      factory: () => PRESERVE_HOST_CONTENT_DEFAULT
    });
    IS_I18N_HYDRATION_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_I18N_HYDRATION_ENABLED" : "");
    IS_EVENT_REPLAY_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_EVENT_REPLAY_ENABLED" : "");
    IS_INCREMENTAL_HYDRATION_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_INCREMENTAL_HYDRATION_ENABLED" : "");
    JSACTION_BLOCK_ELEMENT_MAP = new InjectionToken(ngDevMode ? "JSACTION_BLOCK_ELEMENT_MAP" : "", {
      providedIn: "root",
      factory: () => /* @__PURE__ */ new Map()
    });
    eventListenerOptions = {
      passive: true,
      capture: true
    };
    hoverTriggers = /* @__PURE__ */ new WeakMap();
    interactionTriggers = /* @__PURE__ */ new WeakMap();
    viewportTriggers = /* @__PURE__ */ new WeakMap();
    interactionEventNames = ["click", "keydown"];
    hoverEventNames = ["mouseenter", "mouseover", "focusin"];
    intersectionObserver = null;
    observedViewportElements = 0;
    DeferEventEntry = class {
      callbacks = /* @__PURE__ */ new Set();
      listener = () => {
        for (const callback of this.callbacks) {
          callback();
        }
      };
    };
    JSACTION_EVENT_CONTRACT = new InjectionToken(ngDevMode ? "EVENT_CONTRACT_DETAILS" : "", {
      providedIn: "root",
      factory: () => ({})
    });
    _stashEventListenerImpl = (lView, target, eventName, wrappedListener) => {
    };
    DEHYDRATED_BLOCK_REGISTRY = new InjectionToken(ngDevMode ? "DEHYDRATED_BLOCK_REGISTRY" : "");
    TRANSFER_STATE_TOKEN_ID = "__nghData__";
    NGH_DATA_KEY = makeStateKey(TRANSFER_STATE_TOKEN_ID);
    TRANSFER_STATE_DEFER_BLOCKS_INFO = "__nghDeferData__";
    NGH_DEFER_BLOCKS_KEY = makeStateKey(TRANSFER_STATE_DEFER_BLOCKS_INFO);
    _retrieveHydrationInfoImpl = () => null;
    (function(HydrationStatus2) {
      HydrationStatus2["Hydrated"] = "hydrated";
      HydrationStatus2["Skipped"] = "skipped";
      HydrationStatus2["Mismatched"] = "mismatched";
    })(HydrationStatus || (HydrationStatus = {}));
    HYDRATION_INFO_KEY = "__ngDebugHydrationInfo__";
    (function(ViewEncapsulation3) {
      ViewEncapsulation3[ViewEncapsulation3["Emulated"] = 0] = "Emulated";
      ViewEncapsulation3[ViewEncapsulation3["None"] = 2] = "None";
      ViewEncapsulation3[ViewEncapsulation3["ShadowDom"] = 3] = "ShadowDom";
    })(ViewEncapsulation || (ViewEncapsulation = {}));
    SafeValueImpl = class {
      changingThisBreaksApplicationSecurity;
      constructor(changingThisBreaksApplicationSecurity) {
        this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
      }
      toString() {
        return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${XSS_SECURITY_URL})`;
      }
    };
    SafeHtmlImpl = class extends SafeValueImpl {
      getTypeName() {
        return "HTML";
      }
    };
    SafeStyleImpl = class extends SafeValueImpl {
      getTypeName() {
        return "Style";
      }
    };
    SafeScriptImpl = class extends SafeValueImpl {
      getTypeName() {
        return "Script";
      }
    };
    SafeUrlImpl = class extends SafeValueImpl {
      getTypeName() {
        return "URL";
      }
    };
    SafeResourceUrlImpl = class extends SafeValueImpl {
      getTypeName() {
        return "ResourceURL";
      }
    };
    DOMParserHelper = class {
      inertDocumentHelper;
      constructor(inertDocumentHelper) {
        this.inertDocumentHelper = inertDocumentHelper;
      }
      getInertBodyElement(html) {
        html = "<body><remove></remove>" + html;
        try {
          const body = new window.DOMParser().parseFromString(trustedHTMLFromString(html), "text/html").body;
          if (body === null) {
            return this.inertDocumentHelper.getInertBodyElement(html);
          }
          body.firstChild?.remove();
          return body;
        } catch {
          return null;
        }
      }
    };
    InertDocumentHelper = class {
      defaultDoc;
      inertDocument;
      constructor(defaultDoc) {
        this.defaultDoc = defaultDoc;
        this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert");
      }
      getInertBodyElement(html) {
        const templateEl = this.inertDocument.createElement("template");
        templateEl.innerHTML = trustedHTMLFromString(html);
        return templateEl;
      }
    };
    SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;
    VOID_ELEMENTS = tagSet("area,br,col,hr,img,wbr");
    OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr");
    OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet("rp,rt");
    OPTIONAL_END_TAG_ELEMENTS = merge2(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
    BLOCK_ELEMENTS = merge2(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul"));
    INLINE_ELEMENTS = merge2(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video"));
    VALID_ELEMENTS = merge2(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
    URI_ATTRS = tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href");
    HTML_ATTRS = tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width");
    ARIA_ATTRS = tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext");
    VALID_ATTRS = merge2(URI_ATTRS, HTML_ATTRS, ARIA_ATTRS);
    SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet("script,style,template");
    SanitizingHtmlSerializer = class {
      // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just
      // because characters were re-encoded.
      sanitizedSomething = false;
      buf = [];
      sanitizeChildren(el2) {
        let current = el2.firstChild;
        let traverseContent = true;
        let parentNodes = [];
        while (current) {
          if (current.nodeType === Node.ELEMENT_NODE) {
            traverseContent = this.startElement(current);
          } else if (current.nodeType === Node.TEXT_NODE) {
            this.chars(current.nodeValue);
          } else {
            this.sanitizedSomething = true;
          }
          if (traverseContent && current.firstChild) {
            parentNodes.push(current);
            current = getFirstChild(current);
            continue;
          }
          while (current) {
            if (current.nodeType === Node.ELEMENT_NODE) {
              this.endElement(current);
            }
            let next = getNextSibling(current);
            if (next) {
              current = next;
              break;
            }
            current = parentNodes.pop();
          }
        }
        return this.buf.join("");
      }
      /**
       * Sanitizes an opening element tag (if valid) and returns whether the element's contents should
       * be traversed. Element content must always be traversed (even if the element itself is not
       * valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.
       *
       * @param element The element to sanitize.
       * @return True if the element's contents should be traversed.
       */
      startElement(element) {
        const tagName = getNodeName(element).toLowerCase();
        if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
          this.sanitizedSomething = true;
          return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
        }
        this.buf.push("<");
        this.buf.push(tagName);
        const elAttrs = element.attributes;
        for (let i2 = 0; i2 < elAttrs.length; i2++) {
          const elAttr = elAttrs.item(i2);
          const attrName = elAttr.name;
          const lower = attrName.toLowerCase();
          if (!VALID_ATTRS.hasOwnProperty(lower)) {
            this.sanitizedSomething = true;
            continue;
          }
          let value = elAttr.value;
          if (URI_ATTRS[lower])
            value = _sanitizeUrl(value);
          this.buf.push(" ", attrName, '="', encodeEntities(value), '"');
        }
        this.buf.push(">");
        return true;
      }
      endElement(current) {
        const tagName = getNodeName(current).toLowerCase();
        if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
          this.buf.push("</");
          this.buf.push(tagName);
          this.buf.push(">");
        }
      }
      chars(chars) {
        this.buf.push(encodeEntities(chars));
      }
    };
    SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
    (function(SecurityContext2) {
      SecurityContext2[SecurityContext2["NONE"] = 0] = "NONE";
      SecurityContext2[SecurityContext2["HTML"] = 1] = "HTML";
      SecurityContext2[SecurityContext2["STYLE"] = 2] = "STYLE";
      SecurityContext2[SecurityContext2["SCRIPT"] = 3] = "SCRIPT";
      SecurityContext2[SecurityContext2["URL"] = 4] = "URL";
      SecurityContext2[SecurityContext2["RESOURCE_URL"] = 5] = "RESOURCE_URL";
    })(SecurityContext || (SecurityContext = {}));
    COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;
    COMMENT_DELIMITER = /(<|>)/g;
    COMMENT_DELIMITER_ESCAPED = "\u200B$1\u200B";
    NG_REFLECT_ATTRS_FLAG_DEFAULT = false;
    NG_REFLECT_ATTRS_FLAG = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "NG_REFLECT_FLAG" : "", {
      providedIn: "root",
      factory: () => NG_REFLECT_ATTRS_FLAG_DEFAULT
    });
    CAMEL_CASE_REGEXP = /([A-Z])/g;
    CUSTOM_ELEMENTS_SCHEMA = {
      name: "custom-elements"
    };
    NO_ERRORS_SCHEMA = {
      name: "no-errors-schema"
    };
    shouldThrowErrorOnUnknownElement = false;
    shouldThrowErrorOnUnknownProperty = false;
    KNOWN_CONTROL_FLOW_DIRECTIVES = /* @__PURE__ */ new Map([
      ["ngIf", "NgIf"],
      ["ngFor", "NgFor"],
      ["ngSwitchCase", "NgSwitchCase"],
      ["ngSwitchDefault", "NgSwitchDefault"]
    ]);
    INTERPOLATION_DELIMITER = `\uFFFD`;
    VALUE_STRING_LENGTH_LIMIT = 200;
    NG_TEMPLATE_SELECTOR = "ng-template";
    NO_CHANGE = typeof ngDevMode === "undefined" || ngDevMode ? { __brand__: "NO_CHANGE" } : {};
    (function(InputFlags2) {
      InputFlags2[InputFlags2["None"] = 0] = "None";
      InputFlags2[InputFlags2["SignalBased"] = 1] = "SignalBased";
      InputFlags2[InputFlags2["HasDecoratorInputTransform"] = 2] = "HasDecoratorInputTransform";
    })(InputFlags || (InputFlags = {}));
    (function(RendererStyleFlags22) {
      RendererStyleFlags22[RendererStyleFlags22["Important"] = 1] = "Important";
      RendererStyleFlags22[RendererStyleFlags22["DashCase"] = 2] = "DashCase";
    })(RendererStyleFlags2 || (RendererStyleFlags2 = {}));
    _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;
    _applyRootElementTransformImpl = () => null;
    USE_EXHAUSTIVE_CHECK_NO_CHANGES_DEFAULT = false;
    UseExhaustiveCheckNoChanges = new InjectionToken(ngDevMode ? "exhaustive checkNoChanges" : "");
    freeConsumers = [];
    REACTIVE_LVIEW_CONSUMER_NODE = __spreadProps(__spreadValues({}, REACTIVE_NODE), {
      consumerIsAlwaysLive: true,
      kind: "template",
      consumerMarkedDirty: (node) => {
        markAncestorsForTraversal(node.lView);
      },
      consumerOnSignalRead() {
        this.lView[REACTIVE_TEMPLATE_CONSUMER] = this;
      }
    });
    TEMPORARY_CONSUMER_NODE = __spreadProps(__spreadValues({}, REACTIVE_NODE), {
      consumerIsAlwaysLive: true,
      kind: "template",
      consumerMarkedDirty: (node) => {
        let parent = getLViewParent(node.lView);
        while (parent && !viewShouldHaveReactiveConsumer(parent[TVIEW])) {
          parent = getLViewParent(parent);
        }
        if (!parent) {
          return;
        }
        markViewForRefresh(parent);
      },
      consumerOnSignalRead() {
        this.lView[REACTIVE_TEMPLATE_CONSUMER] = this;
      }
    });
    MAXIMUM_REFRESH_RERUNS$1 = 100;
    ViewRef = class {
      _lView;
      _cdRefInjectingView;
      _appRef = null;
      _attachedToViewContainer = false;
      exhaustive;
      get rootNodes() {
        const lView = this._lView;
        const tView = lView[TVIEW];
        return collectNativeNodes(tView, lView, tView.firstChild, []);
      }
      constructor(_lView, _cdRefInjectingView) {
        this._lView = _lView;
        this._cdRefInjectingView = _cdRefInjectingView;
      }
      get context() {
        return this._lView[CONTEXT];
      }
      /**
       * @deprecated Replacing the full context object is not supported. Modify the context
       *   directly, or consider using a `Proxy` if you need to replace the full object.
       * // TODO(devversion): Remove this.
       */
      set context(value) {
        if (ngDevMode) {
          console.warn("Angular: Replacing the `context` object of an `EmbeddedViewRef` is deprecated.");
        }
        this._lView[CONTEXT] = value;
      }
      get destroyed() {
        return isDestroyed(this._lView);
      }
      destroy() {
        if (this._appRef) {
          this._appRef.detachView(this);
        } else if (this._attachedToViewContainer) {
          const parent = this._lView[PARENT];
          if (isLContainer(parent)) {
            const viewRefs = parent[VIEW_REFS];
            const index = viewRefs ? viewRefs.indexOf(this) : -1;
            if (index > -1) {
              ngDevMode && assertEqual(index, parent.indexOf(this._lView) - CONTAINER_HEADER_OFFSET, "An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.");
              detachView(parent, index);
              removeFromArray(viewRefs, index);
            }
          }
          this._attachedToViewContainer = false;
        }
        destroyLView(this._lView[TVIEW], this._lView);
      }
      onDestroy(callback) {
        storeLViewOnDestroy(this._lView, callback);
      }
      /**
       * Marks a view and all of its ancestors dirty.
       *
       * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush} component is
       * checked when it needs to be re-rendered but the two normal triggers haven't marked it
       * dirty (i.e. inputs haven't changed and events haven't fired in the view).
       *
       * <!-- TODO: Add a link to a chapter on OnPush components -->
       *
       * @usageNotes
       * ### Example
       *
       * ```ts
       * @Component({
       *   selector: 'app-root',
       *   template: `Number of ticks: {{numberOfTicks}}`
       *   changeDetection: ChangeDetectionStrategy.OnPush,
       * })
       * class AppComponent {
       *   numberOfTicks = 0;
       *
       *   constructor(private ref: ChangeDetectorRef) {
       *     setInterval(() => {
       *       this.numberOfTicks++;
       *       // the following is required, otherwise the view will not be updated
       *       this.ref.markForCheck();
       *     }, 1000);
       *   }
       * }
       * ```
       */
      markForCheck() {
        markViewDirty(
          this._cdRefInjectingView || this._lView,
          4
          /* NotificationSource.MarkForCheck */
        );
      }
      /**
       * Detaches the view from the change detection tree.
       *
       * Detached views will not be checked during change detection runs until they are
       * re-attached, even if they are dirty. `detach` can be used in combination with
       * {@link ChangeDetectorRef#detectChanges} to implement local change
       * detection checks.
       *
       * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
       * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
       *
       * @usageNotes
       * ### Example
       *
       * The following example defines a component with a large list of readonly data.
       * Imagine the data changes constantly, many times per second. For performance reasons,
       * we want to check and update the list every five seconds. We can do that by detaching
       * the component's change detector and doing a local check every five seconds.
       *
       * ```ts
       * class DataProvider {
       *   // in a real application the returned data will be different every time
       *   get data() {
       *     return [1,2,3,4,5];
       *   }
       * }
       *
       * @Component({
       *   selector: 'giant-list',
       *   template: `
       *     @for(d of dataProvider.data; track $index) {
       *        <li>Data {{d}}</li>
       *     }
       *   `,
       * })
       * class GiantList {
       *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {
       *     ref.detach();
       *     setInterval(() => {
       *       this.ref.detectChanges();
       *     }, 5000);
       *   }
       * }
       *
       * @Component({
       *   selector: 'app',
       *   providers: [DataProvider],
       *   template: `
       *     <giant-list><giant-list>
       *   `,
       * })
       * class App {
       * }
       * ```
       */
      detach() {
        this._lView[FLAGS] &= ~128;
      }
      /**
       * Re-attaches a view to the change detection tree.
       *
       * This can be used to re-attach views that were previously detached from the tree
       * using {@link ChangeDetectorRef#detach}. Views are attached to the tree by default.
       *
       * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
       *
       * @usageNotes
       * ### Example
       *
       * The following example creates a component displaying `live` data. The component will detach
       * its change detector from the main change detector tree when the component's live property
       * is set to false.
       *
       * ```ts
       * class DataProvider {
       *   data = 1;
       *
       *   constructor() {
       *     setInterval(() => {
       *       this.data = this.data * 2;
       *     }, 500);
       *   }
       * }
       *
       * @Component({
       *   selector: 'live-data',
       *   inputs: ['live'],
       *   template: 'Data: {{dataProvider.data}}'
       * })
       * class LiveData {
       *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}
       *
       *   set live(value) {
       *     if (value) {
       *       this.ref.reattach();
       *     } else {
       *       this.ref.detach();
       *     }
       *   }
       * }
       *
       * @Component({
       *   selector: 'app-root',
       *   providers: [DataProvider],
       *   template: `
       *     Live Update: <input type="checkbox" [(ngModel)]="live">
       *     <live-data [live]="live"><live-data>
       *   `,
       * })
       * class AppComponent {
       *   live = true;
       * }
       * ```
       */
      reattach() {
        updateAncestorTraversalFlagsOnAttach(this._lView);
        this._lView[FLAGS] |= 128;
      }
      /**
       * Checks the view and its children.
       *
       * This can also be used in combination with {@link ChangeDetectorRef#detach} to implement
       * local change detection checks.
       *
       * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
       * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
       *
       * @usageNotes
       * ### Example
       *
       * The following example defines a component with a large list of readonly data.
       * Imagine, the data changes constantly, many times per second. For performance reasons,
       * we want to check and update the list every five seconds.
       *
       * We can do that by detaching the component's change detector and doing a local change detection
       * check every five seconds.
       *
       * See {@link ChangeDetectorRef#detach} for more information.
       */
      detectChanges() {
        this._lView[FLAGS] |= 1024;
        detectChangesInternal(this._lView);
      }
      /**
       * Checks the change detector and its children, and throws if any changes are detected.
       *
       * This is used in development mode to verify that running change detection doesn't
       * introduce other changes.
       */
      checkNoChanges() {
        if (!ngDevMode)
          return;
        try {
          this.exhaustive ??= this._lView[INJECTOR].get(UseExhaustiveCheckNoChanges, USE_EXHAUSTIVE_CHECK_NO_CHANGES_DEFAULT);
        } catch {
          this.exhaustive = USE_EXHAUSTIVE_CHECK_NO_CHANGES_DEFAULT;
        }
        checkNoChangesInternal(this._lView, this.exhaustive);
      }
      attachToViewContainerRef() {
        if (this._appRef) {
          throw new RuntimeError(902, ngDevMode && "This view is already attached directly to the ApplicationRef!");
        }
        this._attachedToViewContainer = true;
      }
      detachFromAppRef() {
        this._appRef = null;
        const isRoot = isRootView(this._lView);
        const declarationContainer = this._lView[DECLARATION_LCONTAINER];
        if (declarationContainer !== null && !isRoot) {
          detachMovedView(declarationContainer, this._lView);
        }
        detachViewFromDOM(this._lView[TVIEW], this._lView);
      }
      attachToAppRef(appRef) {
        if (this._attachedToViewContainer) {
          throw new RuntimeError(902, ngDevMode && "This view is already attached to a ViewContainer!");
        }
        this._appRef = appRef;
        const isRoot = isRootView(this._lView);
        const declarationContainer = this._lView[DECLARATION_LCONTAINER];
        if (declarationContainer !== null && !isRoot) {
          trackMovedView(declarationContainer, this._lView);
        }
        updateAncestorTraversalFlagsOnAttach(this._lView);
      }
    };
    TemplateRef = class {
      _declarationLView;
      _declarationTContainer;
      /**
       * The anchor element in the parent view for this embedded view.
       *
       * The data-binding and [injection contexts](guide/di/dependency-injection-context) of embedded
       * views created from this `TemplateRef` inherit from the contexts of this location.
       *
       * Typically new embedded views are attached to the view container of this location, but in
       * advanced use-cases, the view can be attached to a different container while keeping the
       * data-binding and injection context from the original location.
       *
       */
      elementRef;
      /**
       * @internal
       * @nocollapse
       */
      static __NG_ELEMENT_ID__ = injectTemplateRef;
      /** @internal */
      constructor(_declarationLView, _declarationTContainer, elementRef) {
        this._declarationLView = _declarationLView;
        this._declarationTContainer = _declarationTContainer;
        this.elementRef = elementRef;
      }
      /**
       * Returns an `ssrId` associated with a TView, which was used to
       * create this instance of the `TemplateRef`.
       *
       * @internal
       */
      get ssrId() {
        return this._declarationTContainer.tView?.ssrId || null;
      }
      /**
       * Instantiates an unattached embedded view based on this template.
       * @param context The data-binding context of the embedded view, as declared
       * in the `<ng-template>` usage.
       * @param injector Injector to be used within the embedded view.
       * @returns The new embedded view object.
       */
      createEmbeddedView(context2, injector) {
        return this.createEmbeddedViewImpl(context2, injector);
      }
      /**
       * Implementation of the `createEmbeddedView` function.
       *
       * This implementation is internal and allows framework code
       * to invoke it with extra parameters (e.g. for hydration) without
       * affecting public API.
       *
       * @internal
       */
      createEmbeddedViewImpl(context2, injector, dehydratedView) {
        const embeddedLView = createAndRenderEmbeddedLView(this._declarationLView, this._declarationTContainer, context2, { embeddedViewInjector: injector, dehydratedView });
        return new ViewRef(embeddedLView);
      }
    };
    AT_THIS_LOCATION = "<-- AT THIS LOCATION";
    internalAttrs = /* @__PURE__ */ new Set(["ngh", "ng-version", "ng-server-context"]);
    REF_EXTRACTOR_REGEXP = /* @__PURE__ */ new RegExp(`^(\\d+)*(${REFERENCE_NODE_BODY}|${REFERENCE_NODE_HOST})*(.*)`);
    _prepareI18nBlockForHydrationImpl = () => {
    };
    _claimDehydratedIcuCaseImpl = () => {
    };
    _findMatchingDehydratedViewImpl = () => null;
    _findAndReconcileMatchingDehydratedViewsImpl = () => null;
    ComponentRef$1 = class ComponentRef {
    };
    ComponentFactory$1 = class ComponentFactory {
    };
    _NullComponentFactoryResolver = class {
      resolveComponentFactory(component) {
        throw new RuntimeError(917, typeof ngDevMode !== "undefined" && ngDevMode && `No component factory found for ${stringify(component)}.`);
      }
    };
    ComponentFactoryResolver$1 = class ComponentFactoryResolver {
      static NULL = new _NullComponentFactoryResolver();
    };
    RendererFactory2 = class {
    };
    Renderer2 = class {
      /**
       * If null or undefined, the view engine won't call it.
       * This is used as a performance optimization for production mode.
       */
      destroyNode = null;
      /**
       * @internal
       * @nocollapse
       */
      static __NG_ELEMENT_ID__ = () => injectRenderer2();
    };
    Sanitizer = class _Sanitizer {
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _Sanitizer,
          providedIn: "root",
          factory: () => null
        })
      );
    };
    DepsTracker = class {
      ownerNgModule = /* @__PURE__ */ new Map();
      ngModulesWithSomeUnresolvedDecls = /* @__PURE__ */ new Set();
      ngModulesScopeCache = /* @__PURE__ */ new Map();
      standaloneComponentsScopeCache = /* @__PURE__ */ new Map();
      /**
       * Attempts to resolve ng module's forward ref declarations as much as possible and add them to
       * the `ownerNgModule` map. This method normally should be called after the initial parsing when
       * all the forward refs are resolved (e.g., when trying to render a component)
       */
      resolveNgModulesDecls() {
        if (this.ngModulesWithSomeUnresolvedDecls.size === 0) {
          return;
        }
        for (const moduleType of this.ngModulesWithSomeUnresolvedDecls) {
          const def = getNgModuleDef(moduleType);
          if (def?.declarations) {
            for (const decl of maybeUnwrapFn(def.declarations)) {
              if (isComponent(decl)) {
                this.ownerNgModule.set(decl, moduleType);
              }
            }
          }
        }
        this.ngModulesWithSomeUnresolvedDecls.clear();
      }
      /** @override */
      getComponentDependencies(type, rawImports) {
        this.resolveNgModulesDecls();
        const def = getComponentDef(type);
        if (def === null) {
          throw new Error(`Attempting to get component dependencies for a type that is not a component: ${type}`);
        }
        if (def.standalone) {
          const scope = this.getStandaloneComponentScope(type, rawImports);
          if (scope.compilation.isPoisoned) {
            return { dependencies: [] };
          }
          return {
            dependencies: [
              ...scope.compilation.directives,
              ...scope.compilation.pipes,
              ...scope.compilation.ngModules
            ]
          };
        } else {
          if (!this.ownerNgModule.has(type)) {
            return { dependencies: [] };
          }
          const scope = this.getNgModuleScope(this.ownerNgModule.get(type));
          if (scope.compilation.isPoisoned) {
            return { dependencies: [] };
          }
          return {
            dependencies: [...scope.compilation.directives, ...scope.compilation.pipes]
          };
        }
      }
      /**
       * @override
       * This implementation does not make use of param scopeInfo since it assumes the scope info is
       * already added to the type itself through methods like {@link ɵɵsetNgModuleScope}
       */
      registerNgModule(type, scopeInfo) {
        if (!isNgModule(type)) {
          throw new Error(`Attempting to register a Type which is not NgModule as NgModule: ${type}`);
        }
        this.ngModulesWithSomeUnresolvedDecls.add(type);
      }
      /** @override */
      clearScopeCacheFor(type) {
        this.ngModulesScopeCache.delete(type);
        this.standaloneComponentsScopeCache.delete(type);
      }
      /** @override */
      getNgModuleScope(type) {
        if (this.ngModulesScopeCache.has(type)) {
          return this.ngModulesScopeCache.get(type);
        }
        const scope = this.computeNgModuleScope(type);
        this.ngModulesScopeCache.set(type, scope);
        return scope;
      }
      /** Compute NgModule scope afresh. */
      computeNgModuleScope(type) {
        const def = getNgModuleDefOrThrow(type);
        const scope = {
          exported: { directives: /* @__PURE__ */ new Set(), pipes: /* @__PURE__ */ new Set() },
          compilation: { directives: /* @__PURE__ */ new Set(), pipes: /* @__PURE__ */ new Set() }
        };
        for (const imported of maybeUnwrapFn(def.imports)) {
          if (isNgModule(imported)) {
            const importedScope = this.getNgModuleScope(imported);
            addSet(importedScope.exported.directives, scope.compilation.directives);
            addSet(importedScope.exported.pipes, scope.compilation.pipes);
          } else if (isStandalone(imported)) {
            if (isDirective(imported) || isComponent(imported)) {
              scope.compilation.directives.add(imported);
            } else if (isPipe(imported)) {
              scope.compilation.pipes.add(imported);
            } else {
              throw new RuntimeError(980, "The standalone imported type is neither a component nor a directive nor a pipe");
            }
          } else {
            scope.compilation.isPoisoned = true;
            break;
          }
        }
        if (!scope.compilation.isPoisoned) {
          for (const decl of maybeUnwrapFn(def.declarations)) {
            if (isNgModule(decl) || isStandalone(decl)) {
              scope.compilation.isPoisoned = true;
              break;
            }
            if (isPipe(decl)) {
              scope.compilation.pipes.add(decl);
            } else {
              scope.compilation.directives.add(decl);
            }
          }
        }
        for (const exported of maybeUnwrapFn(def.exports)) {
          if (isNgModule(exported)) {
            const exportedScope = this.getNgModuleScope(exported);
            addSet(exportedScope.exported.directives, scope.exported.directives);
            addSet(exportedScope.exported.pipes, scope.exported.pipes);
            addSet(exportedScope.exported.directives, scope.compilation.directives);
            addSet(exportedScope.exported.pipes, scope.compilation.pipes);
          } else if (isPipe(exported)) {
            scope.exported.pipes.add(exported);
          } else {
            scope.exported.directives.add(exported);
          }
        }
        return scope;
      }
      /** @override */
      getStandaloneComponentScope(type, rawImports) {
        if (this.standaloneComponentsScopeCache.has(type)) {
          return this.standaloneComponentsScopeCache.get(type);
        }
        const ans = this.computeStandaloneComponentScope(type, rawImports);
        this.standaloneComponentsScopeCache.set(type, ans);
        return ans;
      }
      computeStandaloneComponentScope(type, rawImports) {
        const ans = {
          compilation: {
            // Standalone components are always able to self-reference.
            directives: /* @__PURE__ */ new Set([type]),
            pipes: /* @__PURE__ */ new Set(),
            ngModules: /* @__PURE__ */ new Set()
          }
        };
        for (const rawImport of flatten(rawImports ?? [])) {
          const imported = resolveForwardRef(rawImport);
          try {
            verifyStandaloneImport(imported, type);
          } catch (e2) {
            ans.compilation.isPoisoned = true;
            return ans;
          }
          if (isNgModule(imported)) {
            ans.compilation.ngModules.add(imported);
            const importedScope = this.getNgModuleScope(imported);
            if (importedScope.exported.isPoisoned) {
              ans.compilation.isPoisoned = true;
              return ans;
            }
            addSet(importedScope.exported.directives, ans.compilation.directives);
            addSet(importedScope.exported.pipes, ans.compilation.pipes);
          } else if (isPipe(imported)) {
            ans.compilation.pipes.add(imported);
          } else if (isDirective(imported) || isComponent(imported)) {
            ans.compilation.directives.add(imported);
          } else {
            ans.compilation.isPoisoned = true;
            return ans;
          }
        }
        return ans;
      }
      /** @override */
      isOrphanComponent(cmp) {
        const def = getComponentDef(cmp);
        if (!def || def.standalone) {
          return false;
        }
        this.resolveNgModulesDecls();
        return !this.ownerNgModule.has(cmp);
      }
    };
    depsTracker = new DepsTracker();
    NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
    ChainedInjector = class {
      injector;
      parentInjector;
      constructor(injector, parentInjector) {
        this.injector = injector;
        this.parentInjector = parentInjector;
      }
      get(token, notFoundValue, options) {
        const value = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, options);
        if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
          return value;
        }
        return this.parentInjector.get(token, notFoundValue, options);
      }
    };
    BINDING = /* @__PURE__ */ Symbol("BINDING");
    ComponentFactoryResolver2 = class extends ComponentFactoryResolver$1 {
      ngModule;
      /**
       * @param ngModule The NgModuleRef to which all resolved factories are bound.
       */
      constructor(ngModule) {
        super();
        this.ngModule = ngModule;
      }
      resolveComponentFactory(component) {
        ngDevMode && assertComponentType(component);
        const componentDef = getComponentDef(component);
        return new ComponentFactory2(componentDef, this.ngModule);
      }
    };
    ComponentFactory2 = class extends ComponentFactory$1 {
      componentDef;
      ngModule;
      selector;
      componentType;
      ngContentSelectors;
      isBoundToModule;
      cachedInputs = null;
      cachedOutputs = null;
      get inputs() {
        this.cachedInputs ??= toInputRefArray(this.componentDef.inputs);
        return this.cachedInputs;
      }
      get outputs() {
        this.cachedOutputs ??= toOutputRefArray(this.componentDef.outputs);
        return this.cachedOutputs;
      }
      /**
       * @param componentDef The component definition.
       * @param ngModule The NgModuleRef to which the factory is bound.
       */
      constructor(componentDef, ngModule) {
        super();
        this.componentDef = componentDef;
        this.ngModule = ngModule;
        this.componentType = componentDef.type;
        this.selector = stringifyCSSSelectorList(componentDef.selectors);
        this.ngContentSelectors = componentDef.ngContentSelectors ?? [];
        this.isBoundToModule = !!ngModule;
      }
      create(injector, projectableNodes, rootSelectorOrNode, environmentInjector, directives, componentBindings) {
        profiler(
          22
          /* ProfilerEvent.DynamicComponentStart */
        );
        const prevConsumer = setActiveConsumer(null);
        try {
          const cmpDef = this.componentDef;
          ngDevMode && verifyNotAnOrphanComponent(cmpDef);
          const rootTView = createRootTView(rootSelectorOrNode, cmpDef, componentBindings, directives);
          const rootViewInjector = createRootViewInjector(cmpDef, environmentInjector || this.ngModule, injector);
          const environment2 = createRootLViewEnvironment(rootViewInjector);
          const hostRenderer = environment2.rendererFactory.createRenderer(null, cmpDef);
          const hostElement = rootSelectorOrNode ? locateHostElement(hostRenderer, rootSelectorOrNode, cmpDef.encapsulation, rootViewInjector) : createHostElement(cmpDef, hostRenderer);
          const hasInputBindings = componentBindings?.some(isInputBinding) || directives?.some((d2) => typeof d2 !== "function" && d2.bindings.some(isInputBinding));
          const rootLView = createLView(null, rootTView, null, 512 | getInitialLViewFlagsFromDef(cmpDef), null, null, environment2, hostRenderer, rootViewInjector, null, retrieveHydrationInfo(
            hostElement,
            rootViewInjector,
            true
            /* isRootView */
          ));
          rootLView[HEADER_OFFSET] = hostElement;
          enterView(rootLView);
          let componentView = null;
          try {
            const hostTNode = directiveHostFirstCreatePass(HEADER_OFFSET, rootLView, 2, "#host", () => rootTView.directiveRegistry, true, 0);
            if (hostElement) {
              setupStaticAttributes(hostRenderer, hostElement, hostTNode);
              attachPatchData(hostElement, rootLView);
            }
            createDirectivesInstances(rootTView, rootLView, hostTNode);
            executeContentQueries(rootTView, hostTNode, rootLView);
            directiveHostEndFirstCreatePass(rootTView, hostTNode);
            if (projectableNodes !== void 0) {
              projectNodes(hostTNode, this.ngContentSelectors, projectableNodes);
            }
            componentView = getComponentLViewByIndex(hostTNode.index, rootLView);
            rootLView[CONTEXT] = componentView[CONTEXT];
            renderView(rootTView, rootLView, null);
          } catch (e2) {
            if (componentView !== null) {
              unregisterLView(componentView);
            }
            unregisterLView(rootLView);
            throw e2;
          } finally {
            profiler(
              23
              /* ProfilerEvent.DynamicComponentEnd */
            );
            leaveView();
          }
          return new ComponentRef2(this.componentType, rootLView, !!hasInputBindings);
        } finally {
          setActiveConsumer(prevConsumer);
        }
      }
    };
    ComponentRef2 = class extends ComponentRef$1 {
      _rootLView;
      _hasInputBindings;
      instance;
      hostView;
      changeDetectorRef;
      componentType;
      location;
      previousInputValues = null;
      _tNode;
      constructor(componentType, _rootLView, _hasInputBindings) {
        super();
        this._rootLView = _rootLView;
        this._hasInputBindings = _hasInputBindings;
        this._tNode = getTNode(_rootLView[TVIEW], HEADER_OFFSET);
        this.location = createElementRef(this._tNode, _rootLView);
        this.instance = getComponentLViewByIndex(this._tNode.index, _rootLView)[CONTEXT];
        this.hostView = this.changeDetectorRef = new ViewRef(
          _rootLView,
          void 0
          /* _cdRefInjectingView */
        );
        this.componentType = componentType;
      }
      setInput(name, value) {
        if (this._hasInputBindings && ngDevMode) {
          throw new RuntimeError(317, "Cannot call `setInput` on a component that is using the `inputBinding` or `twoWayBinding` functions.");
        }
        const tNode = this._tNode;
        this.previousInputValues ??= /* @__PURE__ */ new Map();
        if (this.previousInputValues.has(name) && Object.is(this.previousInputValues.get(name), value)) {
          return;
        }
        const lView = this._rootLView;
        const hasSetInput = setAllInputsForProperty(tNode, lView[TVIEW], lView, name, value);
        this.previousInputValues.set(name, value);
        const childComponentLView = getComponentLViewByIndex(tNode.index, lView);
        markViewDirty(
          childComponentLView,
          1
          /* NotificationSource.SetInput */
        );
        if (ngDevMode && !hasSetInput) {
          const cmpNameForError = stringifyForError(this.componentType);
          let message = `Can't set value of the '${name}' input on the '${cmpNameForError}' component. `;
          message += `Make sure that the '${name}' property is declared as an input using the @Input() decorator or the input() function.`;
          reportUnknownPropertyError(message);
        }
      }
      get injector() {
        return new NodeInjector(this._tNode, this._rootLView);
      }
      destroy() {
        this.hostView.destroy();
      }
      onDestroy(callback) {
        this.hostView.onDestroy(callback);
      }
    };
    ViewContainerRef = class {
      /**
       * @internal
       * @nocollapse
       */
      static __NG_ELEMENT_ID__ = injectViewContainerRef;
    };
    VE_ViewContainerRef = ViewContainerRef;
    R3ViewContainerRef = class ViewContainerRef2 extends VE_ViewContainerRef {
      _lContainer;
      _hostTNode;
      _hostLView;
      constructor(_lContainer, _hostTNode, _hostLView) {
        super();
        this._lContainer = _lContainer;
        this._hostTNode = _hostTNode;
        this._hostLView = _hostLView;
      }
      get element() {
        return createElementRef(this._hostTNode, this._hostLView);
      }
      get injector() {
        return new NodeInjector(this._hostTNode, this._hostLView);
      }
      /** @deprecated No replacement */
      get parentInjector() {
        const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);
        if (hasParentInjector(parentLocation)) {
          const parentView = getParentInjectorView(parentLocation, this._hostLView);
          const injectorIndex = getParentInjectorIndex(parentLocation);
          ngDevMode && assertNodeInjector(parentView, injectorIndex);
          const parentTNode = parentView[TVIEW].data[
            injectorIndex + 8
            /* NodeInjectorOffset.TNODE */
          ];
          return new NodeInjector(parentTNode, parentView);
        } else {
          return new NodeInjector(null, this._hostLView);
        }
      }
      clear() {
        while (this.length > 0) {
          this.remove(this.length - 1);
        }
      }
      get(index) {
        const viewRefs = getViewRefs(this._lContainer);
        return viewRefs !== null && viewRefs[index] || null;
      }
      get length() {
        return this._lContainer.length - CONTAINER_HEADER_OFFSET;
      }
      createEmbeddedView(templateRef, context2, indexOrOptions) {
        let index;
        let injector;
        if (typeof indexOrOptions === "number") {
          index = indexOrOptions;
        } else if (indexOrOptions != null) {
          index = indexOrOptions.index;
          injector = indexOrOptions.injector;
        }
        const dehydratedView = findMatchingDehydratedView(this._lContainer, templateRef.ssrId);
        const viewRef = templateRef.createEmbeddedViewImpl(context2 || {}, injector, dehydratedView);
        this.insertImpl(viewRef, index, shouldAddViewToDom(this._hostTNode, dehydratedView));
        return viewRef;
      }
      createComponent(componentFactoryOrType, indexOrOptions, injector, projectableNodes, environmentInjector, directives, bindings) {
        const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);
        let index;
        if (isComponentFactory) {
          if (ngDevMode) {
            assertEqual(typeof indexOrOptions !== "object", true, "It looks like Component factory was provided as the first argument and an options object as the second argument. This combination of arguments is incompatible. You can either change the first argument to provide Component type or change the second argument to be a number (representing an index at which to insert the new component's host view into this container)");
          }
          index = indexOrOptions;
        } else {
          if (ngDevMode) {
            assertDefined(getComponentDef(componentFactoryOrType), `Provided Component class doesn't contain Component definition. Please check whether provided class has @Component decorator.`);
            assertEqual(typeof indexOrOptions !== "number", true, "It looks like Component type was provided as the first argument and a number (representing an index at which to insert the new component's host view into this container as the second argument. This combination of arguments is incompatible. Please use an object as the second argument instead.");
          }
          const options = indexOrOptions || {};
          if (ngDevMode && options.environmentInjector && options.ngModuleRef) {
            throwError2(`Cannot pass both environmentInjector and ngModuleRef options to createComponent().`);
          }
          index = options.index;
          injector = options.injector;
          projectableNodes = options.projectableNodes;
          environmentInjector = options.environmentInjector || options.ngModuleRef;
          directives = options.directives;
          bindings = options.bindings;
        }
        const componentFactory = isComponentFactory ? componentFactoryOrType : new ComponentFactory2(getComponentDef(componentFactoryOrType));
        const contextInjector = injector || this.parentInjector;
        if (!environmentInjector && componentFactory.ngModule == null) {
          const _injector = isComponentFactory ? contextInjector : this.parentInjector;
          const result = _injector.get(EnvironmentInjector, null);
          if (result) {
            environmentInjector = result;
          }
        }
        const componentDef = getComponentDef(componentFactory.componentType ?? {});
        const dehydratedView = findMatchingDehydratedView(this._lContainer, componentDef?.id ?? null);
        const rNode = dehydratedView?.firstChild ?? null;
        const componentRef = componentFactory.create(contextInjector, projectableNodes, rNode, environmentInjector, directives, bindings);
        this.insertImpl(componentRef.hostView, index, shouldAddViewToDom(this._hostTNode, dehydratedView));
        return componentRef;
      }
      insert(viewRef, index) {
        return this.insertImpl(viewRef, index, true);
      }
      insertImpl(viewRef, index, addToDOM) {
        const lView = viewRef._lView;
        if (ngDevMode && viewRef.destroyed) {
          throw new Error("Cannot insert a destroyed View in a ViewContainer!");
        }
        if (viewAttachedToContainer(lView)) {
          const prevIdx = this.indexOf(viewRef);
          if (prevIdx !== -1) {
            this.detach(prevIdx);
          } else {
            const prevLContainer = lView[PARENT];
            ngDevMode && assertEqual(isLContainer(prevLContainer), true, "An attached view should have its PARENT point to a container.");
            const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[T_HOST], prevLContainer[PARENT]);
            prevVCRef.detach(prevVCRef.indexOf(viewRef));
          }
        }
        const adjustedIdx = this._adjustIndex(index);
        const lContainer = this._lContainer;
        addLViewToLContainer(lContainer, lView, adjustedIdx, addToDOM);
        viewRef.attachToViewContainerRef();
        addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);
        return viewRef;
      }
      move(viewRef, newIndex) {
        if (ngDevMode && viewRef.destroyed) {
          throw new Error("Cannot move a destroyed View in a ViewContainer!");
        }
        return this.insert(viewRef, newIndex);
      }
      indexOf(viewRef) {
        const viewRefsArr = getViewRefs(this._lContainer);
        return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;
      }
      remove(index) {
        const adjustedIdx = this._adjustIndex(index, -1);
        const detachedView = detachView(this._lContainer, adjustedIdx);
        if (detachedView) {
          removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);
          destroyLView(detachedView[TVIEW], detachedView);
        }
      }
      detach(index) {
        const adjustedIdx = this._adjustIndex(index, -1);
        const view = detachView(this._lContainer, adjustedIdx);
        const wasDetached = view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;
        return wasDetached ? new ViewRef(view) : null;
      }
      _adjustIndex(index, shift = 0) {
        if (index == null) {
          return this.length + shift;
        }
        if (ngDevMode) {
          assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`);
          assertLessThan(index, this.length + 1 + shift, "index");
        }
        return index;
      }
    };
    _locateOrCreateAnchorNode = createAnchorNode;
    _populateDehydratedViewsInLContainer = () => false;
    LQuery_ = class _LQuery_ {
      queryList;
      matches = null;
      constructor(queryList) {
        this.queryList = queryList;
      }
      clone() {
        return new _LQuery_(this.queryList);
      }
      setDirty() {
        this.queryList.setDirty();
      }
    };
    LQueries_ = class _LQueries_ {
      queries;
      constructor(queries = []) {
        this.queries = queries;
      }
      createEmbeddedView(tView) {
        const tQueries = tView.queries;
        if (tQueries !== null) {
          const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;
          const viewLQueries = [];
          for (let i2 = 0; i2 < noOfInheritedQueries; i2++) {
            const tQuery = tQueries.getByIndex(i2);
            const parentLQuery = this.queries[tQuery.indexInDeclarationView];
            viewLQueries.push(parentLQuery.clone());
          }
          return new _LQueries_(viewLQueries);
        }
        return null;
      }
      insertView(tView) {
        this.dirtyQueriesWithMatches(tView);
      }
      detachView(tView) {
        this.dirtyQueriesWithMatches(tView);
      }
      finishViewCreation(tView) {
        this.dirtyQueriesWithMatches(tView);
      }
      dirtyQueriesWithMatches(tView) {
        for (let i2 = 0; i2 < this.queries.length; i2++) {
          if (getTQuery(tView, i2).matches !== null) {
            this.queries[i2].setDirty();
          }
        }
      }
    };
    TQueryMetadata_ = class {
      flags;
      read;
      predicate;
      constructor(predicate, flags, read = null) {
        this.flags = flags;
        this.read = read;
        if (typeof predicate === "string") {
          this.predicate = splitQueryMultiSelectors(predicate);
        } else {
          this.predicate = predicate;
        }
      }
    };
    TQueries_ = class _TQueries_ {
      queries;
      constructor(queries = []) {
        this.queries = queries;
      }
      elementStart(tView, tNode) {
        ngDevMode && assertFirstCreatePass(tView, "Queries should collect results on the first template pass only");
        for (let i2 = 0; i2 < this.queries.length; i2++) {
          this.queries[i2].elementStart(tView, tNode);
        }
      }
      elementEnd(tNode) {
        for (let i2 = 0; i2 < this.queries.length; i2++) {
          this.queries[i2].elementEnd(tNode);
        }
      }
      embeddedTView(tNode) {
        let queriesForTemplateRef = null;
        for (let i2 = 0; i2 < this.length; i2++) {
          const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;
          const tqueryClone = this.getByIndex(i2).embeddedTView(tNode, childQueryIndex);
          if (tqueryClone) {
            tqueryClone.indexInDeclarationView = i2;
            if (queriesForTemplateRef !== null) {
              queriesForTemplateRef.push(tqueryClone);
            } else {
              queriesForTemplateRef = [tqueryClone];
            }
          }
        }
        return queriesForTemplateRef !== null ? new _TQueries_(queriesForTemplateRef) : null;
      }
      template(tView, tNode) {
        ngDevMode && assertFirstCreatePass(tView, "Queries should collect results on the first template pass only");
        for (let i2 = 0; i2 < this.queries.length; i2++) {
          this.queries[i2].template(tView, tNode);
        }
      }
      getByIndex(index) {
        ngDevMode && assertIndexInRange(this.queries, index);
        return this.queries[index];
      }
      get length() {
        return this.queries.length;
      }
      track(tquery) {
        this.queries.push(tquery);
      }
    };
    TQuery_ = class _TQuery_ {
      metadata;
      matches = null;
      indexInDeclarationView = -1;
      crossesNgTemplate = false;
      /**
       * A node index on which a query was declared (-1 for view queries and ones inherited from the
       * declaration template). We use this index (alongside with _appliesToNextNode flag) to know
       * when to apply content queries to elements in a template.
       */
      _declarationNodeIndex;
      /**
       * A flag indicating if a given query still applies to nodes it is crossing. We use this flag
       * (alongside with _declarationNodeIndex) to know when to stop applying content queries to
       * elements in a template.
       */
      _appliesToNextNode = true;
      constructor(metadata, nodeIndex = -1) {
        this.metadata = metadata;
        this._declarationNodeIndex = nodeIndex;
      }
      elementStart(tView, tNode) {
        if (this.isApplyingToNode(tNode)) {
          this.matchTNode(tView, tNode);
        }
      }
      elementEnd(tNode) {
        if (this._declarationNodeIndex === tNode.index) {
          this._appliesToNextNode = false;
        }
      }
      template(tView, tNode) {
        this.elementStart(tView, tNode);
      }
      embeddedTView(tNode, childQueryIndex) {
        if (this.isApplyingToNode(tNode)) {
          this.crossesNgTemplate = true;
          this.addMatch(-tNode.index, childQueryIndex);
          return new _TQuery_(this.metadata);
        }
        return null;
      }
      isApplyingToNode(tNode) {
        if (this._appliesToNextNode && (this.metadata.flags & 1) !== 1) {
          const declarationNodeIdx = this._declarationNodeIndex;
          let parent = tNode.parent;
          while (parent !== null && parent.type & 8 && parent.index !== declarationNodeIdx) {
            parent = parent.parent;
          }
          return declarationNodeIdx === (parent !== null ? parent.index : -1);
        }
        return this._appliesToNextNode;
      }
      matchTNode(tView, tNode) {
        const predicate = this.metadata.predicate;
        if (Array.isArray(predicate)) {
          for (let i2 = 0; i2 < predicate.length; i2++) {
            const name = predicate[i2];
            this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name));
            this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));
          }
        } else {
          if (predicate === TemplateRef) {
            if (tNode.type & 4) {
              this.matchTNodeWithReadOption(tView, tNode, -1);
            }
          } else {
            this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));
          }
        }
      }
      matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {
        if (nodeMatchIdx !== null) {
          const read = this.metadata.read;
          if (read !== null) {
            if (read === ElementRef || read === ViewContainerRef || read === TemplateRef && tNode.type & 4) {
              this.addMatch(tNode.index, -2);
            } else {
              const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);
              if (directiveOrProviderIdx !== null) {
                this.addMatch(tNode.index, directiveOrProviderIdx);
              }
            }
          } else {
            this.addMatch(tNode.index, nodeMatchIdx);
          }
        }
      }
      addMatch(tNodeIdx, matchIdx) {
        if (this.matches === null) {
          this.matches = [tNodeIdx, matchIdx];
        } else {
          this.matches.push(tNodeIdx, matchIdx);
        }
      }
    };
    componentResourceResolutionQueue = /* @__PURE__ */ new Map();
    componentDefPendingResolution = /* @__PURE__ */ new Set();
    modules = /* @__PURE__ */ new Map();
    checkForDuplicateNgModules = true;
    markedFeatures = /* @__PURE__ */ new Set();
    NgModuleRef$1 = class NgModuleRef {
    };
    NgModuleFactory$1 = class NgModuleFactory {
    };
    NgModuleRef2 = class extends NgModuleRef$1 {
      ngModuleType;
      _parent;
      // tslint:disable-next-line:require-internal-with-underscore
      _bootstrapComponents = [];
      _r3Injector;
      instance;
      destroyCbs = [];
      // When bootstrapping a module we have a dependency graph that looks like this:
      // ApplicationRef -> ComponentFactoryResolver -> NgModuleRef. The problem is that if the
      // module being resolved tries to inject the ComponentFactoryResolver, it'll create a
      // circular dependency which will result in a runtime error, because the injector doesn't
      // exist yet. We work around the issue by creating the ComponentFactoryResolver ourselves
      // and providing it, rather than letting the injector resolve it.
      componentFactoryResolver = new ComponentFactoryResolver2(this);
      constructor(ngModuleType, _parent, additionalProviders, runInjectorInitializers = true) {
        super();
        this.ngModuleType = ngModuleType;
        this._parent = _parent;
        const ngModuleDef = getNgModuleDef(ngModuleType);
        ngDevMode && assertDefined(ngModuleDef, `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`);
        this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap);
        this._r3Injector = createInjectorWithoutInjectorInstances(ngModuleType, _parent, [
          { provide: NgModuleRef$1, useValue: this },
          {
            provide: ComponentFactoryResolver$1,
            useValue: this.componentFactoryResolver
          },
          ...additionalProviders
        ], stringify(ngModuleType), /* @__PURE__ */ new Set(["environment"]));
        if (runInjectorInitializers) {
          this.resolveInjectorInitializers();
        }
      }
      resolveInjectorInitializers() {
        this._r3Injector.resolveInjectorInitializers();
        this.instance = this._r3Injector.get(this.ngModuleType);
      }
      get injector() {
        return this._r3Injector;
      }
      destroy() {
        ngDevMode && assertDefined(this.destroyCbs, "NgModule already destroyed");
        const injector = this._r3Injector;
        !injector.destroyed && injector.destroy();
        this.destroyCbs.forEach((fn) => fn());
        this.destroyCbs = null;
      }
      onDestroy(callback) {
        ngDevMode && assertDefined(this.destroyCbs, "NgModule already destroyed");
        this.destroyCbs.push(callback);
      }
    };
    NgModuleFactory2 = class extends NgModuleFactory$1 {
      moduleType;
      constructor(moduleType) {
        super();
        this.moduleType = moduleType;
      }
      create(parentInjector) {
        return new NgModuleRef2(this.moduleType, parentInjector, []);
      }
    };
    EnvironmentNgModuleRefAdapter = class extends NgModuleRef$1 {
      injector;
      componentFactoryResolver = new ComponentFactoryResolver2(this);
      instance = null;
      constructor(config2) {
        super();
        const injector = new R3Injector([
          ...config2.providers,
          { provide: NgModuleRef$1, useValue: this },
          { provide: ComponentFactoryResolver$1, useValue: this.componentFactoryResolver }
        ], config2.parent || getNullInjector(), config2.debugName, /* @__PURE__ */ new Set(["environment"]));
        this.injector = injector;
        if (config2.runEnvironmentInitializers) {
          injector.resolveInjectorInitializers();
        }
      }
      destroy() {
        this.injector.destroy();
      }
      onDestroy(callback) {
        this.injector.onDestroy(callback);
      }
    };
    StandaloneService = class _StandaloneService {
      _injector;
      cachedInjectors = /* @__PURE__ */ new Map();
      constructor(_injector) {
        this._injector = _injector;
      }
      getOrCreateStandaloneInjector(componentDef) {
        if (!componentDef.standalone) {
          return null;
        }
        if (!this.cachedInjectors.has(componentDef)) {
          const providers = internalImportProvidersFrom(false, componentDef.type);
          const standaloneInjector = providers.length > 0 ? createEnvironmentInjector([providers], this._injector, `Standalone[${componentDef.type.name}]`) : null;
          this.cachedInjectors.set(componentDef, standaloneInjector);
        }
        return this.cachedInjectors.get(componentDef);
      }
      ngOnDestroy() {
        try {
          for (const injector of this.cachedInjectors.values()) {
            if (injector !== null) {
              injector.destroy();
            }
          }
        } finally {
          this.cachedInjectors.clear();
        }
      }
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _StandaloneService,
          providedIn: "environment",
          factory: () => new _StandaloneService(\u0275\u0275inject(EnvironmentInjector))
        })
      );
    };
    GENERATED_COMP_IDS = /* @__PURE__ */ new Map();
    COPY_DIRECTIVE_FIELDS = [
      // The child class should use the providers of its parent.
      "providersResolver"
      // Not listed here are any fields which are handled by the `ɵɵInheritDefinitionFeature`, such
      // as inputs, outputs, and host binding functions.
    ];
    COPY_COMPONENT_FIELDS = [
      // The child class should use the template function of its parent, including all template
      // semantics.
      "template",
      "decls",
      "consts",
      "vars",
      "onPush",
      "ngContentSelectors",
      // The child class should use the CSS styles of its parent, including all styling semantics.
      "styles",
      "encapsulation",
      // The child class should be checked by the runtime in the same way as its parent.
      "schemas"
    ];
    _locateOrCreateContainerAnchor = createContainerAnchorImpl;
    (function(DeferDependenciesLoadingState2) {
      DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["NOT_STARTED"] = 0] = "NOT_STARTED";
      DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["IN_PROGRESS"] = 1] = "IN_PROGRESS";
      DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["COMPLETE"] = 2] = "COMPLETE";
      DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["FAILED"] = 3] = "FAILED";
    })(DeferDependenciesLoadingState || (DeferDependenciesLoadingState = {}));
    MINIMUM_SLOT = 0;
    LOADING_AFTER_SLOT = 1;
    (function(DeferBlockState2) {
      DeferBlockState2[DeferBlockState2["Placeholder"] = 0] = "Placeholder";
      DeferBlockState2[DeferBlockState2["Loading"] = 1] = "Loading";
      DeferBlockState2[DeferBlockState2["Complete"] = 2] = "Complete";
      DeferBlockState2[DeferBlockState2["Error"] = 3] = "Error";
    })(DeferBlockState || (DeferBlockState = {}));
    (function(DeferBlockInternalState2) {
      DeferBlockInternalState2[DeferBlockInternalState2["Initial"] = -1] = "Initial";
    })(DeferBlockInternalState || (DeferBlockInternalState = {}));
    NEXT_DEFER_BLOCK_STATE = 0;
    DEFER_BLOCK_STATE = 1;
    STATE_IS_FROZEN_UNTIL = 2;
    LOADING_AFTER_CLEANUP_FN = 3;
    TRIGGER_CLEANUP_FNS = 4;
    PREFETCH_TRIGGER_CLEANUP_FNS = 5;
    SSR_UNIQUE_ID = 6;
    SSR_BLOCK_STATE = 7;
    ON_COMPLETE_FNS = 8;
    HYDRATE_TRIGGER_CLEANUP_FNS = 9;
    (function(DeferBlockBehavior2) {
      DeferBlockBehavior2[DeferBlockBehavior2["Manual"] = 0] = "Manual";
      DeferBlockBehavior2[DeferBlockBehavior2["Playthrough"] = 1] = "Playthrough";
    })(DeferBlockBehavior || (DeferBlockBehavior = {}));
    (function(TracingAction2) {
      TracingAction2[TracingAction2["CHANGE_DETECTION"] = 0] = "CHANGE_DETECTION";
      TracingAction2[TracingAction2["AFTER_NEXT_RENDER"] = 1] = "AFTER_NEXT_RENDER";
    })(TracingAction || (TracingAction = {}));
    TracingService = new InjectionToken(ngDevMode ? "TracingService" : "");
    SCHEDULE_IN_ROOT_ZONE_DEFAULT = false;
    EventEmitter_ = class extends Subject {
      // tslint:disable-next-line:require-internal-with-underscore
      __isAsync;
      destroyRef = void 0;
      pendingTasks = void 0;
      constructor(isAsync = false) {
        super();
        this.__isAsync = isAsync;
        if (isInInjectionContext()) {
          this.destroyRef = inject2(DestroyRef, { optional: true }) ?? void 0;
          this.pendingTasks = inject2(PendingTasksInternal, { optional: true }) ?? void 0;
        }
      }
      emit(value) {
        const prevConsumer = setActiveConsumer(null);
        try {
          super.next(value);
        } finally {
          setActiveConsumer(prevConsumer);
        }
      }
      subscribe(observerOrNext, error, complete) {
        let nextFn = observerOrNext;
        let errorFn = error || (() => null);
        let completeFn = complete;
        if (observerOrNext && typeof observerOrNext === "object") {
          const observer = observerOrNext;
          nextFn = observer.next?.bind(observer);
          errorFn = observer.error?.bind(observer);
          completeFn = observer.complete?.bind(observer);
        }
        if (this.__isAsync) {
          errorFn = this.wrapInTimeout(errorFn);
          if (nextFn) {
            nextFn = this.wrapInTimeout(nextFn);
          }
          if (completeFn) {
            completeFn = this.wrapInTimeout(completeFn);
          }
        }
        const sink = super.subscribe({ next: nextFn, error: errorFn, complete: completeFn });
        if (observerOrNext instanceof Subscription) {
          observerOrNext.add(sink);
        }
        return sink;
      }
      wrapInTimeout(fn) {
        return (value) => {
          const taskId = this.pendingTasks?.add();
          setTimeout(() => {
            try {
              fn(value);
            } finally {
              if (taskId !== void 0) {
                this.pendingTasks?.remove(taskId);
              }
            }
          });
        };
      }
    };
    EventEmitter = EventEmitter_;
    AsyncStackTaggingZoneSpec = class {
      createTask;
      constructor(namePrefix, consoleAsyncStackTaggingImpl = console) {
        this.name = "asyncStackTagging for " + namePrefix;
        this.createTask = consoleAsyncStackTaggingImpl?.createTask ?? (() => null);
      }
      // ZoneSpec implementation below.
      name;
      onScheduleTask(delegate, _current, target, task) {
        task.consoleTask = this.createTask(`Zone - ${task.source || task.type}`);
        return delegate.scheduleTask(target, task);
      }
      onInvokeTask(delegate, _currentZone, targetZone, task, applyThis, applyArgs) {
        let ret;
        if (task.consoleTask) {
          ret = task.consoleTask.run(() => delegate.invokeTask(targetZone, task, applyThis, applyArgs));
        } else {
          ret = delegate.invokeTask(targetZone, task, applyThis, applyArgs);
        }
        return ret;
      }
    };
    isAngularZoneProperty = "isAngularZone";
    angularZoneInstanceIdProperty = isAngularZoneProperty + "_ID";
    ngZoneInstanceId = 0;
    NgZone = class _NgZone {
      hasPendingMacrotasks = false;
      hasPendingMicrotasks = false;
      /**
       * Whether there are no outstanding microtasks or macrotasks.
       */
      isStable = true;
      /**
       * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
       */
      onUnstable = new EventEmitter(false);
      /**
       * Notifies when there is no more microtasks enqueued in the current VM Turn.
       * This is a hint for Angular to do change detection, which may enqueue more microtasks.
       * For this reason this event can fire multiple times per VM Turn.
       */
      onMicrotaskEmpty = new EventEmitter(false);
      /**
       * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
       * implies we are about to relinquish VM turn.
       * This event gets called just once.
       */
      onStable = new EventEmitter(false);
      /**
       * Notifies that an error has been delivered.
       */
      onError = new EventEmitter(false);
      constructor(options) {
        const { enableLongStackTrace = false, shouldCoalesceEventChangeDetection = false, shouldCoalesceRunChangeDetection = false, scheduleInRootZone = SCHEDULE_IN_ROOT_ZONE_DEFAULT } = options;
        if (typeof Zone == "undefined") {
          throw new RuntimeError(908, ngDevMode && `In this configuration Angular requires Zone.js`);
        }
        Zone.assertZonePatched();
        const self2 = this;
        self2._nesting = 0;
        self2._outer = self2._inner = Zone.current;
        if (ngDevMode) {
          self2._inner = self2._inner.fork(new AsyncStackTaggingZoneSpec("Angular"));
        }
        if (Zone["TaskTrackingZoneSpec"]) {
          self2._inner = self2._inner.fork(new Zone["TaskTrackingZoneSpec"]());
        }
        if (enableLongStackTrace && Zone["longStackTraceZoneSpec"]) {
          self2._inner = self2._inner.fork(Zone["longStackTraceZoneSpec"]);
        }
        self2.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;
        self2.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;
        self2.callbackScheduled = false;
        self2.scheduleInRootZone = scheduleInRootZone;
        forkInnerZoneWithAngularBehavior(self2);
      }
      /**
        This method checks whether the method call happens within an Angular Zone instance.
      */
      static isInAngularZone() {
        return typeof Zone !== "undefined" && Zone.current.get(isAngularZoneProperty) === true;
      }
      /**
        Assures that the method is called within the Angular Zone, otherwise throws an error.
      */
      static assertInAngularZone() {
        if (!_NgZone.isInAngularZone()) {
          throw new RuntimeError(909, ngDevMode && "Expected to be in Angular Zone, but it is not!");
        }
      }
      /**
        Assures that the method is called outside of the Angular Zone, otherwise throws an error.
      */
      static assertNotInAngularZone() {
        if (_NgZone.isInAngularZone()) {
          throw new RuntimeError(909, ngDevMode && "Expected to not be in Angular Zone, but it is!");
        }
      }
      /**
       * Executes the `fn` function synchronously within the Angular zone and returns value returned by
       * the function.
       *
       * Running functions via `run` allows you to reenter Angular zone from a task that was executed
       * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
       *
       * Any future tasks or microtasks scheduled from within this function will continue executing from
       * within the Angular zone.
       *
       * If a synchronous error happens it will be rethrown and not reported via `onError`.
       */
      run(fn, applyThis, applyArgs) {
        return this._inner.run(fn, applyThis, applyArgs);
      }
      /**
       * Executes the `fn` function synchronously within the Angular zone as a task and returns value
       * returned by the function.
       *
       * Running functions via `runTask` allows you to reenter Angular zone from a task that was executed
       * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
       *
       * Any future tasks or microtasks scheduled from within this function will continue executing from
       * within the Angular zone.
       *
       * If a synchronous error happens it will be rethrown and not reported via `onError`.
       */
      runTask(fn, applyThis, applyArgs, name) {
        const zone = this._inner;
        const task = zone.scheduleEventTask("NgZoneEvent: " + name, fn, EMPTY_PAYLOAD, noop2, noop2);
        try {
          return zone.runTask(task, applyThis, applyArgs);
        } finally {
          zone.cancelTask(task);
        }
      }
      /**
       * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
       * rethrown.
       */
      runGuarded(fn, applyThis, applyArgs) {
        return this._inner.runGuarded(fn, applyThis, applyArgs);
      }
      /**
       * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
       * the function.
       *
       * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do
       * work that
       * doesn't trigger Angular change-detection or is subject to Angular's error handling.
       *
       * Any future tasks or microtasks scheduled from within this function will continue executing from
       * outside of the Angular zone.
       *
       * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
       */
      runOutsideAngular(fn) {
        return this._outer.run(fn);
      }
    };
    EMPTY_PAYLOAD = {};
    NoopNgZone = class {
      hasPendingMicrotasks = false;
      hasPendingMacrotasks = false;
      isStable = true;
      onUnstable = new EventEmitter();
      onMicrotaskEmpty = new EventEmitter();
      onStable = new EventEmitter();
      onError = new EventEmitter();
      run(fn, applyThis, applyArgs) {
        return fn.apply(applyThis, applyArgs);
      }
      runGuarded(fn, applyThis, applyArgs) {
        return fn.apply(applyThis, applyArgs);
      }
      runOutsideAngular(fn) {
        return fn();
      }
      runTask(fn, applyThis, applyArgs, name) {
        return fn.apply(applyThis, applyArgs);
      }
    };
    AfterRenderManager = class _AfterRenderManager {
      impl = null;
      execute() {
        this.impl?.execute();
      }
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _AfterRenderManager,
          providedIn: "root",
          factory: () => new _AfterRenderManager()
        })
      );
    };
    AFTER_RENDER_PHASES = /* @__PURE__ */ (() => [
      0,
      1,
      2,
      3
    ])();
    AfterRenderImpl = class _AfterRenderImpl {
      ngZone = inject2(NgZone);
      scheduler = inject2(ChangeDetectionScheduler);
      errorHandler = inject2(ErrorHandler, { optional: true });
      /** Current set of active sequences. */
      sequences = /* @__PURE__ */ new Set();
      /** Tracks registrations made during the current set of executions. */
      deferredRegistrations = /* @__PURE__ */ new Set();
      /** Whether the `AfterRenderManager` is currently executing hooks. */
      executing = false;
      constructor() {
        inject2(TracingService, { optional: true });
      }
      /**
       * Run the sequence of phases of hooks, once through. As a result of executing some hooks, more
       * might be scheduled.
       */
      execute() {
        const hasSequencesToExecute = this.sequences.size > 0;
        if (hasSequencesToExecute) {
          profiler(
            16
            /* ProfilerEvent.AfterRenderHooksStart */
          );
        }
        this.executing = true;
        for (const phase of AFTER_RENDER_PHASES) {
          for (const sequence of this.sequences) {
            if (sequence.erroredOrDestroyed || !sequence.hooks[phase]) {
              continue;
            }
            try {
              sequence.pipelinedValue = this.ngZone.runOutsideAngular(() => this.maybeTrace(() => {
                const hookFn = sequence.hooks[phase];
                const value = hookFn(sequence.pipelinedValue);
                return value;
              }, sequence.snapshot));
            } catch (err) {
              sequence.erroredOrDestroyed = true;
              this.errorHandler?.handleError(err);
            }
          }
        }
        this.executing = false;
        for (const sequence of this.sequences) {
          sequence.afterRun();
          if (sequence.once) {
            this.sequences.delete(sequence);
            sequence.destroy();
          }
        }
        for (const sequence of this.deferredRegistrations) {
          this.sequences.add(sequence);
        }
        if (this.deferredRegistrations.size > 0) {
          this.scheduler.notify(
            7
            /* NotificationSource.RenderHook */
          );
        }
        this.deferredRegistrations.clear();
        if (hasSequencesToExecute) {
          profiler(
            17
            /* ProfilerEvent.AfterRenderHooksEnd */
          );
        }
      }
      register(sequence) {
        const { view } = sequence;
        if (view !== void 0) {
          (view[AFTER_RENDER_SEQUENCES_TO_ADD] ??= []).push(sequence);
          markAncestorsForTraversal(view);
          view[FLAGS] |= 8192;
        } else if (!this.executing) {
          this.addSequence(sequence);
        } else {
          this.deferredRegistrations.add(sequence);
        }
      }
      addSequence(sequence) {
        this.sequences.add(sequence);
        this.scheduler.notify(
          7
          /* NotificationSource.RenderHook */
        );
      }
      unregister(sequence) {
        if (this.executing && this.sequences.has(sequence)) {
          sequence.erroredOrDestroyed = true;
          sequence.pipelinedValue = void 0;
          sequence.once = true;
        } else {
          this.sequences.delete(sequence);
          this.deferredRegistrations.delete(sequence);
        }
      }
      maybeTrace(fn, snapshot) {
        return snapshot ? snapshot.run(TracingAction.AFTER_NEXT_RENDER, fn) : fn();
      }
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _AfterRenderImpl,
          providedIn: "root",
          factory: () => new _AfterRenderImpl()
        })
      );
    };
    AfterRenderSequence = class {
      impl;
      hooks;
      view;
      once;
      snapshot;
      /**
       * Whether this sequence errored or was destroyed during this execution, and hooks should no
       * longer run for it.
       */
      erroredOrDestroyed = false;
      /**
       * The value returned by the last hook execution (if any), ready to be pipelined into the next
       * one.
       */
      pipelinedValue = void 0;
      unregisterOnDestroy;
      constructor(impl, hooks, view, once, destroyRef, snapshot = null) {
        this.impl = impl;
        this.hooks = hooks;
        this.view = view;
        this.once = once;
        this.snapshot = snapshot;
        this.unregisterOnDestroy = destroyRef?.onDestroy(() => this.destroy());
      }
      afterRun() {
        this.erroredOrDestroyed = false;
        this.pipelinedValue = void 0;
        this.snapshot?.dispose();
        this.snapshot = null;
      }
      destroy() {
        this.impl.unregister(this);
        this.unregisterOnDestroy?.();
        const scheduled2 = this.view?.[AFTER_RENDER_SEQUENCES_TO_ADD];
        if (scheduled2) {
          this.view[AFTER_RENDER_SEQUENCES_TO_ADD] = scheduled2.filter((s2) => s2 !== this);
        }
      }
    };
    _requestIdleCallback = () => typeof requestIdleCallback !== "undefined" ? requestIdleCallback : setTimeout;
    _cancelIdleCallback = () => typeof requestIdleCallback !== "undefined" ? cancelIdleCallback : clearTimeout;
    IdleScheduler = class _IdleScheduler {
      // Indicates whether current callbacks are being invoked.
      executingCallbacks = false;
      // Currently scheduled idle callback id.
      idleId = null;
      // Set of callbacks to be invoked next.
      current = /* @__PURE__ */ new Set();
      // Set of callbacks collected while invoking current set of callbacks.
      // Those callbacks are scheduled for the next idle period.
      deferred = /* @__PURE__ */ new Set();
      ngZone = inject2(NgZone);
      requestIdleCallbackFn = _requestIdleCallback().bind(globalThis);
      cancelIdleCallbackFn = _cancelIdleCallback().bind(globalThis);
      add(callback) {
        const target = this.executingCallbacks ? this.deferred : this.current;
        target.add(callback);
        if (this.idleId === null) {
          this.scheduleIdleCallback();
        }
      }
      remove(callback) {
        const { current, deferred } = this;
        current.delete(callback);
        deferred.delete(callback);
        if (current.size === 0 && deferred.size === 0) {
          this.cancelIdleCallback();
        }
      }
      scheduleIdleCallback() {
        const callback = () => {
          this.cancelIdleCallback();
          this.executingCallbacks = true;
          for (const callback2 of this.current) {
            callback2();
          }
          this.current.clear();
          this.executingCallbacks = false;
          if (this.deferred.size > 0) {
            for (const callback2 of this.deferred) {
              this.current.add(callback2);
            }
            this.deferred.clear();
            this.scheduleIdleCallback();
          }
        };
        this.idleId = this.requestIdleCallbackFn(() => this.ngZone.run(callback));
      }
      cancelIdleCallback() {
        if (this.idleId !== null) {
          this.cancelIdleCallbackFn(this.idleId);
          this.idleId = null;
        }
      }
      ngOnDestroy() {
        this.cancelIdleCallback();
        this.current.clear();
        this.deferred.clear();
      }
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _IdleScheduler,
          providedIn: "root",
          factory: () => new _IdleScheduler()
        })
      );
    };
    TimerScheduler = class _TimerScheduler {
      // Indicates whether current callbacks are being invoked.
      executingCallbacks = false;
      // Currently scheduled `setTimeout` id.
      timeoutId = null;
      // When currently scheduled timer would fire.
      invokeTimerAt = null;
      // List of callbacks to be invoked.
      // For each callback we also store a timestamp on when the callback
      // should be invoked. We store timestamps and callback functions
      // in a flat array to avoid creating new objects for each entry.
      // [timestamp1, callback1, timestamp2, callback2, ...]
      current = [];
      // List of callbacks collected while invoking current set of callbacks.
      // Those callbacks are added to the "current" queue at the end of
      // the current callback invocation. The shape of this list is the same
      // as the shape of the `current` list.
      deferred = [];
      add(delay, callback, ngZone) {
        const target = this.executingCallbacks ? this.deferred : this.current;
        this.addToQueue(target, Date.now() + delay, callback);
        this.scheduleTimer(ngZone);
      }
      remove(callback) {
        const { current, deferred } = this;
        const callbackIndex = this.removeFromQueue(current, callback);
        if (callbackIndex === -1) {
          this.removeFromQueue(deferred, callback);
        }
        if (current.length === 0 && deferred.length === 0) {
          this.clearTimeout();
        }
      }
      addToQueue(target, invokeAt, callback) {
        let insertAtIndex = target.length;
        for (let i2 = 0; i2 < target.length; i2 += 2) {
          const invokeQueuedCallbackAt = target[i2];
          if (invokeQueuedCallbackAt > invokeAt) {
            insertAtIndex = i2;
            break;
          }
        }
        arrayInsert2(target, insertAtIndex, invokeAt, callback);
      }
      removeFromQueue(target, callback) {
        let index = -1;
        for (let i2 = 0; i2 < target.length; i2 += 2) {
          const queuedCallback = target[i2 + 1];
          if (queuedCallback === callback) {
            index = i2;
            break;
          }
        }
        if (index > -1) {
          arraySplice(target, index, 2);
        }
        return index;
      }
      scheduleTimer(ngZone) {
        const callback = () => {
          this.clearTimeout();
          this.executingCallbacks = true;
          const current = [...this.current];
          const now = Date.now();
          for (let i2 = 0; i2 < current.length; i2 += 2) {
            const invokeAt = current[i2];
            const callback2 = current[i2 + 1];
            if (invokeAt <= now) {
              callback2();
            } else {
              break;
            }
          }
          let lastCallbackIndex = -1;
          for (let i2 = 0; i2 < this.current.length; i2 += 2) {
            const invokeAt = this.current[i2];
            if (invokeAt <= now) {
              lastCallbackIndex = i2 + 1;
            } else {
              break;
            }
          }
          if (lastCallbackIndex >= 0) {
            arraySplice(this.current, 0, lastCallbackIndex + 1);
          }
          this.executingCallbacks = false;
          if (this.deferred.length > 0) {
            for (let i2 = 0; i2 < this.deferred.length; i2 += 2) {
              const invokeAt = this.deferred[i2];
              const callback2 = this.deferred[i2 + 1];
              this.addToQueue(this.current, invokeAt, callback2);
            }
            this.deferred.length = 0;
          }
          this.scheduleTimer(ngZone);
        };
        const FRAME_DURATION_MS = 16;
        if (this.current.length > 0) {
          const now = Date.now();
          const invokeAt = this.current[0];
          if (this.timeoutId === null || // Reschedule a timer in case a queue contains an item with
          // an earlier timestamp and the delta is more than an average
          // frame duration.
          this.invokeTimerAt && this.invokeTimerAt - invokeAt > FRAME_DURATION_MS) {
            this.clearTimeout();
            const timeout = Math.max(invokeAt - now, FRAME_DURATION_MS);
            this.invokeTimerAt = invokeAt;
            this.timeoutId = ngZone.runOutsideAngular(() => {
              return setTimeout(() => ngZone.run(callback), timeout);
            });
          }
        }
      }
      clearTimeout() {
        if (this.timeoutId !== null) {
          clearTimeout(this.timeoutId);
          this.timeoutId = null;
        }
      }
      ngOnDestroy() {
        this.clearTimeout();
        this.current.length = 0;
        this.deferred.length = 0;
      }
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _TimerScheduler,
          providedIn: "root",
          factory: () => new _TimerScheduler()
        })
      );
    };
    CachedInjectorService = class _CachedInjectorService {
      cachedInjectors = /* @__PURE__ */ new Map();
      getOrCreateInjector(key, parentInjector, providers, debugName) {
        if (!this.cachedInjectors.has(key)) {
          const injector = providers.length > 0 ? createEnvironmentInjector(providers, parentInjector, debugName) : null;
          this.cachedInjectors.set(key, injector);
        }
        return this.cachedInjectors.get(key);
      }
      ngOnDestroy() {
        try {
          for (const injector of this.cachedInjectors.values()) {
            if (injector !== null) {
              injector.destroy();
            }
          }
        } finally {
          this.cachedInjectors.clear();
        }
      }
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _CachedInjectorService,
          providedIn: "environment",
          factory: () => new _CachedInjectorService()
        })
      );
    };
    DEFER_BLOCK_DEPENDENCY_INTERCEPTOR = /* @__PURE__ */ new InjectionToken("DEFER_BLOCK_DEPENDENCY_INTERCEPTOR");
    DEFER_BLOCK_CONFIG = new InjectionToken(ngDevMode ? "DEFER_BLOCK_CONFIG" : "");
    applyDeferBlockStateWithSchedulingImpl = null;
    Console = class _Console {
      log(message) {
        console.log(message);
      }
      // Note: for reporting errors use `DOM.logError()` as it is platform specific
      warn(message) {
        console.warn(message);
      }
      static \u0275fac = function Console_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Console)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _Console, factory: _Console.\u0275fac, providedIn: "platform" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Console, [{
        type: Injectable,
        args: [{ providedIn: "platform" }]
      }], null, null);
    })();
    DIDebugData = class {
      resolverToTokenToDependencies = /* @__PURE__ */ new WeakMap();
      resolverToProviders = /* @__PURE__ */ new WeakMap();
      resolverToEffects = /* @__PURE__ */ new WeakMap();
      standaloneInjectorToComponent = /* @__PURE__ */ new WeakMap();
      reset() {
        this.resolverToTokenToDependencies = /* @__PURE__ */ new WeakMap();
        this.resolverToProviders = /* @__PURE__ */ new WeakMap();
        this.standaloneInjectorToComponent = /* @__PURE__ */ new WeakMap();
      }
    };
    frameworkDIDebugData = new DIDebugData();
    signalDebugMap = /* @__PURE__ */ new WeakMap();
    counter$1 = 0;
    changeDetectionRuns = 0;
    changeDetectionSyncRuns = 0;
    counter = 0;
    eventsStack = [];
    chromeDevToolsInjectorProfiler = (event) => {
      const eventType = event.type;
      if (eventType === 4) {
        measureStart(
          100
          /* ProfilerDIEvent.InjectorToCreateInstanceEvent */
        );
      } else if (eventType === 1) {
        const token = event.context.token;
        measureEnd(100, getProviderTokenMeasureName(token), "tertiary-dark");
      }
    };
    devToolsProfiler = (event, instance, eventFn) => {
      switch (event) {
        case 8:
        case 10:
        case 12:
        case 14:
        case 16:
        case 18:
        case 20:
        case 22:
        case 0:
        case 4:
        case 2:
        case 24:
        case 6: {
          measureStart(event);
          break;
        }
        case 9: {
          measureEnd(8, "Bootstrap application", "primary-dark");
          break;
        }
        case 11: {
          measureEnd(10, "Bootstrap component", "primary-dark");
          break;
        }
        case 13: {
          changeDetectionSyncRuns = 0;
          measureEnd(12, "Change detection " + changeDetectionRuns++, "primary-dark");
          break;
        }
        case 15: {
          measureEnd(14, "Synchronization " + changeDetectionSyncRuns++, "primary");
          break;
        }
        case 17: {
          measureEnd(16, "After render hooks", "primary");
          break;
        }
        case 19: {
          const typeName = getComponentMeasureName(instance);
          measureEnd(18, typeName, "primary-light");
          break;
        }
        case 21: {
          measureEnd(20, "Defer block", "primary-dark");
          break;
        }
        case 23: {
          measureEnd(22, "Dynamic component creation", "primary-dark");
          break;
        }
        case 3: {
          measureEnd(2, stringifyForError(eventFn) + " (update)", "secondary-dark");
          break;
        }
        case 1: {
          measureEnd(0, stringifyForError(eventFn) + " (create)", "secondary");
          break;
        }
        case 25: {
          measureEnd(24, "HostBindings", "secondary-dark");
          break;
        }
        case 5: {
          const typeName = getComponentMeasureName(instance);
          measureEnd(4, `${typeName}:${stringifyForError(eventFn)}`, "tertiary");
          break;
        }
        case 7: {
          measureEnd(6, stringifyForError(eventFn), "tertiary-light");
          break;
        }
        default: {
          throw new Error("Unexpected profiling event type: " + event);
        }
      }
    };
    GLOBAL_PUBLISH_EXPANDO_KEY = "ng";
    globalUtilsFunctions = {
      /**
       * Warning: functions that start with `ɵ` are considered *INTERNAL* and should not be relied upon
       * in application's code. The contract of those functions might be changed in any release and/or a
       * function can be removed completely.
       */
      "\u0275getDependenciesFromInjectable": getDependenciesFromInjectable,
      "\u0275getInjectorProviders": getInjectorProviders,
      "\u0275getInjectorResolutionPath": getInjectorResolutionPath,
      "\u0275getInjectorMetadata": getInjectorMetadata,
      "\u0275setProfiler": setProfiler,
      "\u0275getSignalGraph": getSignalGraph,
      "\u0275getDeferBlocks": getDeferBlocks,
      "getDirectiveMetadata": getDirectiveMetadata$1,
      "getComponent": getComponent,
      "getContext": getContext,
      "getListeners": getListeners,
      "getOwningComponent": getOwningComponent,
      "getHostElement": getHostElement,
      "getInjector": getInjector,
      "getRootComponents": getRootComponents,
      "getDirectives": getDirectives,
      "applyChanges": applyChanges,
      "isSignal": isSignal,
      "enableProfiling": enableProfiling
    };
    _published = false;
    TESTABILITY = new InjectionToken("");
    TESTABILITY_GETTER = new InjectionToken("");
    Testability = class _Testability {
      _ngZone;
      registry;
      _isZoneStable = true;
      _callbacks = [];
      _taskTrackingZone = null;
      _destroyRef;
      constructor(_ngZone, registry, testabilityGetter) {
        this._ngZone = _ngZone;
        this.registry = registry;
        if (isInInjectionContext()) {
          this._destroyRef = inject2(DestroyRef, { optional: true }) ?? void 0;
        }
        if (!_testabilityGetter) {
          setTestabilityGetter(testabilityGetter);
          testabilityGetter.addToWindow(registry);
        }
        this._watchAngularEvents();
        _ngZone.run(() => {
          this._taskTrackingZone = typeof Zone == "undefined" ? null : Zone.current.get("TaskTrackingZone");
        });
      }
      _watchAngularEvents() {
        const onUnstableSubscription = this._ngZone.onUnstable.subscribe({
          next: () => {
            this._isZoneStable = false;
          }
        });
        const onStableSubscription = this._ngZone.runOutsideAngular(() => this._ngZone.onStable.subscribe({
          next: () => {
            NgZone.assertNotInAngularZone();
            queueMicrotask(() => {
              this._isZoneStable = true;
              this._runCallbacksIfReady();
            });
          }
        }));
        this._destroyRef?.onDestroy(() => {
          onUnstableSubscription.unsubscribe();
          onStableSubscription.unsubscribe();
        });
      }
      /**
       * Whether an associated application is stable
       */
      isStable() {
        return this._isZoneStable && !this._ngZone.hasPendingMacrotasks;
      }
      _runCallbacksIfReady() {
        if (this.isStable()) {
          queueMicrotask(() => {
            while (this._callbacks.length !== 0) {
              let cb = this._callbacks.pop();
              clearTimeout(cb.timeoutId);
              cb.doneCb();
            }
          });
        } else {
          let pending = this.getPendingTasks();
          this._callbacks = this._callbacks.filter((cb) => {
            if (cb.updateCb && cb.updateCb(pending)) {
              clearTimeout(cb.timeoutId);
              return false;
            }
            return true;
          });
        }
      }
      getPendingTasks() {
        if (!this._taskTrackingZone) {
          return [];
        }
        return this._taskTrackingZone.macroTasks.map((t2) => {
          return {
            source: t2.source,
            // From TaskTrackingZone:
            // https://github.com/angular/zone.js/blob/master/lib/zone-spec/task-tracking.ts#L40
            creationLocation: t2.creationLocation,
            data: t2.data
          };
        });
      }
      addCallback(cb, timeout, updateCb) {
        let timeoutId = -1;
        if (timeout && timeout > 0) {
          timeoutId = setTimeout(() => {
            this._callbacks = this._callbacks.filter((cb2) => cb2.timeoutId !== timeoutId);
            cb();
          }, timeout);
        }
        this._callbacks.push({ doneCb: cb, timeoutId, updateCb });
      }
      /**
       * Wait for the application to be stable with a timeout. If the timeout is reached before that
       * happens, the callback receives a list of the macro tasks that were pending, otherwise null.
       *
       * @param doneCb The callback to invoke when Angular is stable or the timeout expires
       *    whichever comes first.
       * @param timeout Optional. The maximum time to wait for Angular to become stable. If not
       *    specified, whenStable() will wait forever.
       * @param updateCb Optional. If specified, this callback will be invoked whenever the set of
       *    pending macrotasks changes. If this callback returns true doneCb will not be invoked
       *    and no further updates will be issued.
       */
      whenStable(doneCb, timeout, updateCb) {
        if (updateCb && !this._taskTrackingZone) {
          throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
        }
        this.addCallback(doneCb, timeout, updateCb);
        this._runCallbacksIfReady();
      }
      /**
       * Registers an application with a testability hook so that it can be tracked.
       * @param token token of application, root element
       *
       * @internal
       */
      registerApplication(token) {
        this.registry.registerApplication(token, this);
      }
      /**
       * Unregisters an application.
       * @param token token of application, root element
       *
       * @internal
       */
      unregisterApplication(token) {
        this.registry.unregisterApplication(token);
      }
      /**
       * Find providers by name
       * @param using The root element to search from
       * @param provider The name of binding variable
       * @param exactMatch Whether using exactMatch
       */
      findProviders(using, provider, exactMatch) {
        return [];
      }
      static \u0275fac = function Testability_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Testability)(\u0275\u0275inject(NgZone), \u0275\u0275inject(TestabilityRegistry), \u0275\u0275inject(TESTABILITY_GETTER));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _Testability, factory: _Testability.\u0275fac });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Testability, [{
        type: Injectable
      }], () => [{ type: NgZone }, { type: TestabilityRegistry }, { type: void 0, decorators: [{
        type: Inject,
        args: [TESTABILITY_GETTER]
      }] }], null);
    })();
    TestabilityRegistry = class _TestabilityRegistry {
      /** @internal */
      _applications = /* @__PURE__ */ new Map();
      /**
       * Registers an application with a testability hook so that it can be tracked
       * @param token token of application, root element
       * @param testability Testability hook
       */
      registerApplication(token, testability) {
        this._applications.set(token, testability);
      }
      /**
       * Unregisters an application.
       * @param token token of application, root element
       */
      unregisterApplication(token) {
        this._applications.delete(token);
      }
      /**
       * Unregisters all applications
       */
      unregisterAllApplications() {
        this._applications.clear();
      }
      /**
       * Get a testability hook associated with the application
       * @param elem root element
       */
      getTestability(elem) {
        return this._applications.get(elem) || null;
      }
      /**
       * Get all registered testabilities
       */
      getAllTestabilities() {
        return Array.from(this._applications.values());
      }
      /**
       * Get all registered applications(root elements)
       */
      getAllRootElements() {
        return Array.from(this._applications.keys());
      }
      /**
       * Find testability of a node in the Tree
       * @param elem node
       * @param findInAncestors whether finding testability in ancestors if testability was not found in
       * current node
       */
      findTestabilityInTree(elem, findInAncestors = true) {
        return _testabilityGetter?.findTestabilityInTree(this, elem, findInAncestors) ?? null;
      }
      static \u0275fac = function TestabilityRegistry_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _TestabilityRegistry)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _TestabilityRegistry, factory: _TestabilityRegistry.\u0275fac, providedIn: "platform" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TestabilityRegistry, [{
        type: Injectable,
        args: [{ providedIn: "platform" }]
      }], null, null);
    })();
    APP_INITIALIZER = new InjectionToken(ngDevMode ? "Application Initializer" : "");
    ApplicationInitStatus = class _ApplicationInitStatus {
      // Using non null assertion, these fields are defined below
      // within the `new Promise` callback (synchronously).
      resolve;
      reject;
      initialized = false;
      done = false;
      donePromise = new Promise((res, rej) => {
        this.resolve = res;
        this.reject = rej;
      });
      appInits = inject2(APP_INITIALIZER, { optional: true }) ?? [];
      injector = inject2(Injector);
      constructor() {
        if ((typeof ngDevMode === "undefined" || ngDevMode) && !Array.isArray(this.appInits)) {
          throw new RuntimeError(-209, `Unexpected type of the \`APP_INITIALIZER\` token value (expected an array, but got ${typeof this.appInits}). Please check that the \`APP_INITIALIZER\` token is configured as a \`multi: true\` provider.`);
        }
      }
      /** @internal */
      runInitializers() {
        if (this.initialized) {
          return;
        }
        const asyncInitPromises = [];
        for (const appInits of this.appInits) {
          const initResult = runInInjectionContext(this.injector, appInits);
          if (isPromise2(initResult)) {
            asyncInitPromises.push(initResult);
          } else if (isSubscribable(initResult)) {
            const observableAsPromise = new Promise((resolve, reject) => {
              initResult.subscribe({ complete: resolve, error: reject });
            });
            asyncInitPromises.push(observableAsPromise);
          }
        }
        const complete = () => {
          this.done = true;
          this.resolve();
        };
        Promise.all(asyncInitPromises).then(() => {
          complete();
        }).catch((e2) => {
          this.reject(e2);
        });
        if (asyncInitPromises.length === 0) {
          complete();
        }
        this.initialized = true;
      }
      static \u0275fac = function ApplicationInitStatus_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ApplicationInitStatus)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ApplicationInitStatus, factory: _ApplicationInitStatus.\u0275fac, providedIn: "root" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationInitStatus, [{
        type: Injectable,
        args: [{ providedIn: "root" }]
      }], () => [], null);
    })();
    APP_BOOTSTRAP_LISTENER = new InjectionToken(ngDevMode ? "appBootstrapListener" : "");
    MAXIMUM_REFRESH_RERUNS = 10;
    ApplicationRef = class _ApplicationRef {
      /** @internal */
      _runningTick = false;
      _destroyed = false;
      _destroyListeners = [];
      /** @internal */
      _views = [];
      internalErrorHandler = inject2(INTERNAL_APPLICATION_ERROR_HANDLER);
      afterRenderManager = inject2(AfterRenderManager);
      zonelessEnabled = inject2(ZONELESS_ENABLED);
      rootEffectScheduler = inject2(EffectScheduler);
      /**
       * Current dirty state of the application across a number of dimensions (views, afterRender hooks,
       * etc).
       *
       * A flag set here means that `tick()` will attempt to resolve the dirtiness when executed.
       *
       * @internal
       */
      dirtyFlags = 0;
      /**
       * Most recent snapshot from the `TracingService`, if any.
       *
       * This snapshot attempts to capture the context when `tick()` was first
       * scheduled. It then runs wrapped in this context.
       *
       * @internal
       */
      tracingSnapshot = null;
      // Needed for ComponentFixture temporarily during migration of autoDetect behavior
      // Eventually the hostView of the fixture should just attach to ApplicationRef.
      allTestViews = /* @__PURE__ */ new Set();
      autoDetectTestViews = /* @__PURE__ */ new Set();
      includeAllTestViews = false;
      /** @internal */
      afterTick = new Subject();
      /** @internal */
      get allViews() {
        return [
          ...(this.includeAllTestViews ? this.allTestViews : this.autoDetectTestViews).keys(),
          ...this._views
        ];
      }
      /**
       * Indicates whether this instance was destroyed.
       */
      get destroyed() {
        return this._destroyed;
      }
      /**
       * Get a list of component types registered to this application.
       * This list is populated even before the component is created.
       */
      componentTypes = [];
      /**
       * Get a list of components registered to this application.
       */
      components = [];
      internalPendingTask = inject2(PendingTasksInternal);
      /**
       * Returns an Observable that indicates when the application is stable or unstable.
       */
      get isStable() {
        return this.internalPendingTask.hasPendingTasksObservable.pipe(map((pending) => !pending));
      }
      constructor() {
        inject2(TracingService, { optional: true });
      }
      /**
       * @returns A promise that resolves when the application becomes stable
       */
      whenStable() {
        let subscription;
        return new Promise((resolve) => {
          subscription = this.isStable.subscribe({
            next: (stable) => {
              if (stable) {
                resolve();
              }
            }
          });
        }).finally(() => {
          subscription.unsubscribe();
        });
      }
      _injector = inject2(EnvironmentInjector);
      _rendererFactory = null;
      /**
       * The `EnvironmentInjector` used to create this application.
       */
      get injector() {
        return this._injector;
      }
      /**
       * Bootstrap a component onto the element identified by its selector or, optionally, to a
       * specified element.
       *
       * @usageNotes
       * ### Bootstrap process
       *
       * When bootstrapping a component, Angular mounts it onto a target DOM element
       * and kicks off automatic change detection. The target DOM element can be
       * provided using the `rootSelectorOrNode` argument.
       *
       * If the target DOM element is not provided, Angular tries to find one on a page
       * using the `selector` of the component that is being bootstrapped
       * (first matched element is used).
       *
       * ### Example
       *
       * Generally, we define the component to bootstrap in the `bootstrap` array of `NgModule`,
       * but it requires us to know the component while writing the application code.
       *
       * Imagine a situation where we have to wait for an API call to decide about the component to
       * bootstrap. We can use the `ngDoBootstrap` hook of the `NgModule` and call this method to
       * dynamically bootstrap a component.
       *
       * {@example core/ts/platform/platform.ts region='componentSelector'}
       *
       * Optionally, a component can be mounted onto a DOM element that does not match the
       * selector of the bootstrapped component.
       *
       * In the following example, we are providing a CSS selector to match the target element.
       *
       * {@example core/ts/platform/platform.ts region='cssSelector'}
       *
       * While in this example, we are providing reference to a DOM node.
       *
       * {@example core/ts/platform/platform.ts region='domNode'}
       */
      bootstrap(componentOrFactory, rootSelectorOrNode) {
        return this.bootstrapImpl(componentOrFactory, rootSelectorOrNode);
      }
      bootstrapImpl(componentOrFactory, rootSelectorOrNode, injector = Injector.NULL) {
        const ngZone = this._injector.get(NgZone);
        return ngZone.run(() => {
          profiler(
            10
            /* ProfilerEvent.BootstrapComponentStart */
          );
          (typeof ngDevMode === "undefined" || ngDevMode) && warnIfDestroyed(this._destroyed);
          const isComponentFactory = componentOrFactory instanceof ComponentFactory$1;
          const initStatus = this._injector.get(ApplicationInitStatus);
          if (!initStatus.done) {
            let errorMessage = "";
            if (typeof ngDevMode === "undefined" || ngDevMode) {
              const standalone = !isComponentFactory && isStandalone(componentOrFactory);
              errorMessage = "Cannot bootstrap as there are still asynchronous initializers running." + (standalone ? "" : " Bootstrap components in the `ngDoBootstrap` method of the root module.");
            }
            throw new RuntimeError(405, errorMessage);
          }
          let componentFactory;
          if (isComponentFactory) {
            componentFactory = componentOrFactory;
          } else {
            const resolver = this._injector.get(ComponentFactoryResolver$1);
            componentFactory = resolver.resolveComponentFactory(componentOrFactory);
          }
          this.componentTypes.push(componentFactory.componentType);
          const ngModule = isBoundToModule(componentFactory) ? void 0 : this._injector.get(NgModuleRef$1);
          const selectorOrNode = rootSelectorOrNode || componentFactory.selector;
          const compRef = componentFactory.create(injector, [], selectorOrNode, ngModule);
          const nativeElement = compRef.location.nativeElement;
          const testability = compRef.injector.get(TESTABILITY, null);
          testability?.registerApplication(nativeElement);
          compRef.onDestroy(() => {
            this.detachView(compRef.hostView);
            remove(this.components, compRef);
            testability?.unregisterApplication(nativeElement);
          });
          this._loadComponent(compRef);
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            const _console = this._injector.get(Console);
            _console.log(`Angular is running in development mode.`);
          }
          profiler(11, compRef);
          return compRef;
        });
      }
      /**
       * Invoke this method to explicitly process change detection and its side-effects.
       *
       * In development mode, `tick()` also performs a second change detection cycle to ensure that no
       * further changes are detected. If additional changes are picked up during this second cycle,
       * bindings in the app have side-effects that cannot be resolved in a single change detection
       * pass.
       * In this case, Angular throws an error, since an Angular application can only have one change
       * detection pass during which all change detection must complete.
       */
      tick() {
        if (!this.zonelessEnabled) {
          this.dirtyFlags |= 1;
        }
        this._tick();
      }
      /** @internal */
      _tick() {
        profiler(
          12
          /* ProfilerEvent.ChangeDetectionStart */
        );
        if (this.tracingSnapshot !== null) {
          this.tracingSnapshot.run(TracingAction.CHANGE_DETECTION, this.tickImpl);
        } else {
          this.tickImpl();
        }
      }
      tickImpl = () => {
        (typeof ngDevMode === "undefined" || ngDevMode) && warnIfDestroyed(this._destroyed);
        if (this._runningTick) {
          throw new RuntimeError(101, ngDevMode && "ApplicationRef.tick is called recursively");
        }
        const prevConsumer = setActiveConsumer(null);
        try {
          this._runningTick = true;
          this.synchronize();
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            for (let view of this.allViews) {
              view.checkNoChanges();
            }
          }
        } finally {
          this._runningTick = false;
          this.tracingSnapshot?.dispose();
          this.tracingSnapshot = null;
          setActiveConsumer(prevConsumer);
          this.afterTick.next();
          profiler(
            13
            /* ProfilerEvent.ChangeDetectionEnd */
          );
        }
      };
      /**
       * Performs the core work of synchronizing the application state with the UI, resolving any
       * pending dirtiness (potentially in a loop).
       */
      synchronize() {
        if (this._rendererFactory === null && !this._injector.destroyed) {
          this._rendererFactory = this._injector.get(RendererFactory2, null, { optional: true });
        }
        let runs = 0;
        while (this.dirtyFlags !== 0 && runs++ < MAXIMUM_REFRESH_RERUNS) {
          profiler(
            14
            /* ProfilerEvent.ChangeDetectionSyncStart */
          );
          this.synchronizeOnce();
          profiler(
            15
            /* ProfilerEvent.ChangeDetectionSyncEnd */
          );
        }
        if ((typeof ngDevMode === "undefined" || ngDevMode) && runs >= MAXIMUM_REFRESH_RERUNS) {
          throw new RuntimeError(103, ngDevMode && "Infinite change detection while refreshing application views. Ensure views are not calling `markForCheck` on every template execution or that afterRender hooks always mark views for check.");
        }
      }
      /**
       * Perform a single synchronization pass.
       */
      synchronizeOnce() {
        if (this.dirtyFlags & 16) {
          this.dirtyFlags &= ~16;
          this.rootEffectScheduler.flush();
        }
        let ranDetectChanges = false;
        if (this.dirtyFlags & 7) {
          const useGlobalCheck = Boolean(
            this.dirtyFlags & 1
            /* ApplicationRefDirtyFlags.ViewTreeGlobal */
          );
          this.dirtyFlags &= ~7;
          this.dirtyFlags |= 8;
          for (let { _lView } of this.allViews) {
            if (!useGlobalCheck && !requiresRefreshOrTraversal(_lView)) {
              continue;
            }
            const mode = useGlobalCheck && !this.zonelessEnabled ? (
              // Global mode includes `CheckAlways` views.
              0
            ) : (
              // Only refresh views with the `RefreshView` flag or views is a changed signal
              1
            );
            detectChangesInternal(_lView, mode);
            ranDetectChanges = true;
          }
          this.dirtyFlags &= ~4;
          this.syncDirtyFlagsWithViews();
          if (this.dirtyFlags & (7 | 16)) {
            return;
          }
        }
        if (!ranDetectChanges) {
          this._rendererFactory?.begin?.();
          this._rendererFactory?.end?.();
        }
        if (this.dirtyFlags & 8) {
          this.dirtyFlags &= ~8;
          this.afterRenderManager.execute();
        }
        this.syncDirtyFlagsWithViews();
      }
      /**
       * Checks `allViews` for views which require refresh/traversal, and updates `dirtyFlags`
       * accordingly, with two potential behaviors:
       *
       * 1. If any of our views require updating, then this adds the `ViewTreeTraversal` dirty flag.
       *    This _should_ be a no-op, since the scheduler should've added the flag at the same time the
       *    view was marked as needing updating.
       *
       *    TODO(alxhub): figure out if this behavior is still needed for edge cases.
       *
       * 2. If none of our views require updating, then clear the view-related `dirtyFlag`s. This
       *    happens when the scheduler is notified of a view becoming dirty, but the view itself isn't
       *    reachable through traversal from our roots (e.g. it's detached from the CD tree).
       */
      syncDirtyFlagsWithViews() {
        if (this.allViews.some(({ _lView }) => requiresRefreshOrTraversal(_lView))) {
          this.dirtyFlags |= 2;
          return;
        } else {
          this.dirtyFlags &= ~7;
        }
      }
      /**
       * Attaches a view so that it will be dirty checked.
       * The view will be automatically detached when it is destroyed.
       * This will throw if the view is already attached to a ViewContainer.
       */
      attachView(viewRef) {
        (typeof ngDevMode === "undefined" || ngDevMode) && warnIfDestroyed(this._destroyed);
        const view = viewRef;
        this._views.push(view);
        view.attachToAppRef(this);
      }
      /**
       * Detaches a view from dirty checking again.
       */
      detachView(viewRef) {
        (typeof ngDevMode === "undefined" || ngDevMode) && warnIfDestroyed(this._destroyed);
        const view = viewRef;
        remove(this._views, view);
        view.detachFromAppRef();
      }
      _loadComponent(componentRef) {
        this.attachView(componentRef.hostView);
        try {
          this.tick();
        } catch (e2) {
          this.internalErrorHandler(e2);
        }
        this.components.push(componentRef);
        const listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []);
        if (ngDevMode && !Array.isArray(listeners)) {
          throw new RuntimeError(-209, `Unexpected type of the \`APP_BOOTSTRAP_LISTENER\` token value (expected an array, but got ${typeof listeners}). Please check that the \`APP_BOOTSTRAP_LISTENER\` token is configured as a \`multi: true\` provider.`);
        }
        listeners.forEach((listener) => listener(componentRef));
      }
      /** @internal */
      ngOnDestroy() {
        if (this._destroyed)
          return;
        try {
          this._destroyListeners.forEach((listener) => listener());
          this._views.slice().forEach((view) => view.destroy());
        } finally {
          this._destroyed = true;
          this._views = [];
          this._destroyListeners = [];
        }
      }
      /**
       * Registers a listener to be called when an instance is destroyed.
       *
       * @param callback A callback function to add as a listener.
       * @returns A function which unregisters a listener.
       */
      onDestroy(callback) {
        (typeof ngDevMode === "undefined" || ngDevMode) && warnIfDestroyed(this._destroyed);
        this._destroyListeners.push(callback);
        return () => remove(this._destroyListeners, callback);
      }
      /**
       * Destroys an Angular application represented by this `ApplicationRef`. Calling this function
       * will destroy the associated environment injectors as well as all the bootstrapped components
       * with their views.
       */
      destroy() {
        if (this._destroyed) {
          throw new RuntimeError(406, ngDevMode && "This instance of the `ApplicationRef` has already been destroyed.");
        }
        const injector = this._injector;
        if (injector.destroy && !injector.destroyed) {
          injector.destroy();
        }
      }
      /**
       * Returns the number of attached views.
       */
      get viewCount() {
        return this._views.length;
      }
      static \u0275fac = function ApplicationRef_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ApplicationRef)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ApplicationRef, factory: _ApplicationRef.\u0275fac, providedIn: "root" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationRef, [{
        type: Injectable,
        args: [{ providedIn: "root" }]
      }], () => [], null);
    })();
    LiveCollection = class {
      destroy(item) {
      }
      updateValue(index, value) {
      }
      // operations below could be implemented on top of the operations defined so far, but having
      // them explicitly allow clear expression of intent and potentially more performant
      // implementations
      swap(index1, index2) {
        const startIdx = Math.min(index1, index2);
        const endIdx = Math.max(index1, index2);
        const endItem = this.detach(endIdx);
        if (endIdx - startIdx > 1) {
          const startItem = this.detach(startIdx);
          this.attach(startIdx, endItem);
          this.attach(endIdx, startItem);
        } else {
          this.attach(startIdx, endItem);
        }
      }
      move(prevIndex, newIdx) {
        this.attach(newIdx, this.detach(prevIndex));
      }
    };
    UniqueValueMultiKeyMap = class {
      // A map from a key to the first value corresponding to this key.
      kvMap = /* @__PURE__ */ new Map();
      // A map that acts as a linked list of values - each value maps to the next value in this "linked
      // list" (this only works if values are unique). Allocated lazily to avoid memory consumption when
      // there are no duplicated values.
      _vMap = void 0;
      has(key) {
        return this.kvMap.has(key);
      }
      delete(key) {
        if (!this.has(key))
          return false;
        const value = this.kvMap.get(key);
        if (this._vMap !== void 0 && this._vMap.has(value)) {
          this.kvMap.set(key, this._vMap.get(value));
          this._vMap.delete(value);
        } else {
          this.kvMap.delete(key);
        }
        return true;
      }
      get(key) {
        return this.kvMap.get(key);
      }
      set(key, value) {
        if (this.kvMap.has(key)) {
          let prevValue = this.kvMap.get(key);
          if (ngDevMode && prevValue === value) {
            throw new Error(`Detected a duplicated value ${value} for the key ${key}`);
          }
          if (this._vMap === void 0) {
            this._vMap = /* @__PURE__ */ new Map();
          }
          const vMap = this._vMap;
          while (vMap.has(prevValue)) {
            prevValue = vMap.get(prevValue);
          }
          vMap.set(prevValue, value);
        } else {
          this.kvMap.set(key, value);
        }
      }
      forEach(cb) {
        for (let [key, value] of this.kvMap) {
          cb(value, key);
          if (this._vMap !== void 0) {
            const vMap = this._vMap;
            while (vMap.has(value)) {
              value = vMap.get(value);
              cb(value, key);
            }
          }
        }
      }
    };
    RepeaterContext = class {
      lContainer;
      $implicit;
      $index;
      constructor(lContainer, $implicit, $index) {
        this.lContainer = lContainer;
        this.$implicit = $implicit;
        this.$index = $index;
      }
      get $count() {
        return this.lContainer.length - CONTAINER_HEADER_OFFSET;
      }
    };
    RepeaterMetadata = class {
      hasEmptyBlock;
      trackByFn;
      liveCollection;
      constructor(hasEmptyBlock, trackByFn, liveCollection) {
        this.hasEmptyBlock = hasEmptyBlock;
        this.trackByFn = trackByFn;
        this.liveCollection = liveCollection;
      }
    };
    OperationsCounter = class {
      created = 0;
      destroyed = 0;
      reset() {
        this.created = 0;
        this.destroyed = 0;
      }
      recordCreate() {
        this.created++;
      }
      recordDestroy() {
        this.destroyed++;
      }
      /**
       * A method indicating if the entire collection was re-created as part of the reconciliation pass.
       * Used to warn developers about the usage of a tracking function that might result in excessive
       * amount of view creation / destroy operations.
       *
       * @returns boolean value indicating if a live collection was re-created
       */
      wasReCreated(collectionLen) {
        return collectionLen > 0 && this.created === this.destroyed && this.created === collectionLen;
      }
    };
    LiveCollectionLContainerImpl = class extends LiveCollection {
      lContainer;
      hostLView;
      templateTNode;
      operationsCounter = ngDevMode ? new OperationsCounter() : void 0;
      /**
        Property indicating if indexes in the repeater context need to be updated following the live
        collection changes. Index updates are necessary if and only if views are inserted / removed in
        the middle of LContainer. Adds and removals at the end don't require index updates.
      */
      needsIndexUpdate = false;
      constructor(lContainer, hostLView, templateTNode) {
        super();
        this.lContainer = lContainer;
        this.hostLView = hostLView;
        this.templateTNode = templateTNode;
      }
      get length() {
        return this.lContainer.length - CONTAINER_HEADER_OFFSET;
      }
      at(index) {
        return this.getLView(index)[CONTEXT].$implicit;
      }
      attach(index, lView) {
        const dehydratedView = lView[HYDRATION];
        this.needsIndexUpdate ||= index !== this.length;
        addLViewToLContainer(this.lContainer, lView, index, shouldAddViewToDom(this.templateTNode, dehydratedView));
      }
      detach(index) {
        this.needsIndexUpdate ||= index !== this.length - 1;
        return detachExistingView(this.lContainer, index);
      }
      create(index, value) {
        const dehydratedView = findMatchingDehydratedView(this.lContainer, this.templateTNode.tView.ssrId);
        const embeddedLView = createAndRenderEmbeddedLView(this.hostLView, this.templateTNode, new RepeaterContext(this.lContainer, value, index), { dehydratedView });
        this.operationsCounter?.recordCreate();
        return embeddedLView;
      }
      destroy(lView) {
        destroyLView(lView[TVIEW], lView);
        this.operationsCounter?.recordDestroy();
      }
      updateValue(index, value) {
        this.getLView(index)[CONTEXT].$implicit = value;
      }
      reset() {
        this.needsIndexUpdate = false;
        this.operationsCounter?.reset();
      }
      updateIndexes() {
        if (this.needsIndexUpdate) {
          for (let i2 = 0; i2 < this.length; i2++) {
            this.getLView(i2)[CONTEXT].$index = i2;
          }
        }
      }
      getLView(index) {
        return getExistingLViewFromLContainer(this.lContainer, index);
      }
    };
    _locateOrCreateElementNode = (tView, lView, tNode, name, index) => {
      lastNodeWasCreated(true);
      return createElementNode(lView[RENDERER], name, getNamespace());
    };
    _locateOrCreateElementContainerNode = (tView, lView, tNode, commentText, index) => {
      lastNodeWasCreated(true);
      return createCommentNode(lView[RENDERER], ngDevMode ? commentText : "");
    };
    u = void 0;
    localeEn = ["en", [["a", "p"], ["AM", "PM"], u], [["AM", "PM"], u, u], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], u, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], u, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", u, "{1} 'at' {0}", u], [".", ",", ";", "%", "+", "-", "E", "\xD7", "\u2030", "\u221E", "NaN", ":"], ["#,##0.###", "#,##0%", "\xA4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", plural];
    LOCALE_DATA = {};
    (function(LocaleDataIndex2) {
      LocaleDataIndex2[LocaleDataIndex2["LocaleId"] = 0] = "LocaleId";
      LocaleDataIndex2[LocaleDataIndex2["DayPeriodsFormat"] = 1] = "DayPeriodsFormat";
      LocaleDataIndex2[LocaleDataIndex2["DayPeriodsStandalone"] = 2] = "DayPeriodsStandalone";
      LocaleDataIndex2[LocaleDataIndex2["DaysFormat"] = 3] = "DaysFormat";
      LocaleDataIndex2[LocaleDataIndex2["DaysStandalone"] = 4] = "DaysStandalone";
      LocaleDataIndex2[LocaleDataIndex2["MonthsFormat"] = 5] = "MonthsFormat";
      LocaleDataIndex2[LocaleDataIndex2["MonthsStandalone"] = 6] = "MonthsStandalone";
      LocaleDataIndex2[LocaleDataIndex2["Eras"] = 7] = "Eras";
      LocaleDataIndex2[LocaleDataIndex2["FirstDayOfWeek"] = 8] = "FirstDayOfWeek";
      LocaleDataIndex2[LocaleDataIndex2["WeekendRange"] = 9] = "WeekendRange";
      LocaleDataIndex2[LocaleDataIndex2["DateFormat"] = 10] = "DateFormat";
      LocaleDataIndex2[LocaleDataIndex2["TimeFormat"] = 11] = "TimeFormat";
      LocaleDataIndex2[LocaleDataIndex2["DateTimeFormat"] = 12] = "DateTimeFormat";
      LocaleDataIndex2[LocaleDataIndex2["NumberSymbols"] = 13] = "NumberSymbols";
      LocaleDataIndex2[LocaleDataIndex2["NumberFormats"] = 14] = "NumberFormats";
      LocaleDataIndex2[LocaleDataIndex2["CurrencyCode"] = 15] = "CurrencyCode";
      LocaleDataIndex2[LocaleDataIndex2["CurrencySymbol"] = 16] = "CurrencySymbol";
      LocaleDataIndex2[LocaleDataIndex2["CurrencyName"] = 17] = "CurrencyName";
      LocaleDataIndex2[LocaleDataIndex2["Currencies"] = 18] = "Currencies";
      LocaleDataIndex2[LocaleDataIndex2["Directionality"] = 19] = "Directionality";
      LocaleDataIndex2[LocaleDataIndex2["PluralCase"] = 20] = "PluralCase";
      LocaleDataIndex2[LocaleDataIndex2["ExtraData"] = 21] = "ExtraData";
    })(LocaleDataIndex || (LocaleDataIndex = {}));
    pluralMapping = ["zero", "one", "two", "few", "many"];
    DEFAULT_LOCALE_ID = "en-US";
    USD_CURRENCY_CODE = "USD";
    ELEMENT_MARKER = {
      marker: "element"
    };
    ICU_MARKER = {
      marker: "ICU"
    };
    (function(I18nCreateOpCode2) {
      I18nCreateOpCode2[I18nCreateOpCode2["SHIFT"] = 2] = "SHIFT";
      I18nCreateOpCode2[I18nCreateOpCode2["APPEND_EAGERLY"] = 1] = "APPEND_EAGERLY";
      I18nCreateOpCode2[I18nCreateOpCode2["COMMENT"] = 2] = "COMMENT";
    })(I18nCreateOpCode || (I18nCreateOpCode = {}));
    LOCALE_ID$1 = DEFAULT_LOCALE_ID;
    changeMask = 0;
    changeMaskCounter = 0;
    _locateOrCreateNode = (lView, index, textOrName, nodeType) => {
      lastNodeWasCreated(true);
      return createNodeWithoutHydration(lView, textOrName, nodeType);
    };
    OpCodeParser = class {
      i = 0;
      codes;
      constructor(codes) {
        this.codes = codes;
      }
      hasMore() {
        return this.i < this.codes.length;
      }
      consumeNumber() {
        let value = this.codes[this.i++];
        assertNumber(value, "expecting number in OpCode");
        return value;
      }
      consumeString() {
        let value = this.codes[this.i++];
        assertString(value, "expecting string in OpCode");
        return value;
      }
      consumeFunction() {
        let value = this.codes[this.i++];
        if (value === null || typeof value === "function") {
          return value;
        }
        throw new Error("expecting function in OpCode");
      }
      consumeNumberOrString() {
        let value = this.codes[this.i++];
        if (typeof value === "string") {
          return value;
        }
        assertNumber(value, "expecting number or string in OpCode");
        return value;
      }
      consumeNumberStringOrMarker() {
        let value = this.codes[this.i++];
        if (typeof value === "string" || typeof value === "number" || value == ICU_MARKER || value == ELEMENT_MARKER) {
          return value;
        }
        assertNumber(value, "expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode");
        return value;
      }
    };
    BINDING_REGEXP = /�(\d+):?\d*�/gi;
    ICU_REGEXP = /({\s*�\d+:?\d*�\s*,\s*\S{6}\s*,[\s\S]*})/gi;
    NESTED_ICU = /�(\d+)�/;
    ICU_BLOCK_REGEXP = /^\s*(�\d+:?\d*�)\s*,\s*(select|plural)\s*,/;
    MARKER = `\uFFFD`;
    SUBTEMPLATE_REGEXP = /�\/?\*(\d+:\d+)�/gi;
    PH_REGEXP = /�(\/?[#*]\d+):?\d*�/gi;
    NGSP_UNICODE_REGEXP = /\uE500/g;
    ROOT_TEMPLATE_ID = 0;
    PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]/;
    PP_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]|(�\/?\*\d+:\d+�)/g;
    PP_ICU_VARS_REGEXP = /({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g;
    PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;
    PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\d+)?)�/g;
    PP_CLOSE_TEMPLATE_REGEXP = /\/\*/;
    PP_TEMPLATE_ID_REGEXP = /\d+\:(\d+)/;
    parserState = {
      textEnd: 0,
      key: 0,
      keyEnd: 0,
      value: 0,
      valueEnd: 0
    };
    _locateOrCreateTextNode = (tView, lView, tNode, value, index) => {
      lastNodeWasCreated(true);
      return createTextNode(lView[RENDERER], value);
    };
    UNINITIALIZED_LET = {};
    angularCoreEnv = /* @__PURE__ */ (() => ({
      "\u0275\u0275attribute": \u0275\u0275attribute,
      "\u0275\u0275defineComponent": \u0275\u0275defineComponent,
      "\u0275\u0275defineDirective": \u0275\u0275defineDirective,
      "\u0275\u0275defineInjectable": \u0275\u0275defineInjectable,
      "\u0275\u0275defineInjector": \u0275\u0275defineInjector,
      "\u0275\u0275defineNgModule": \u0275\u0275defineNgModule,
      "\u0275\u0275definePipe": \u0275\u0275definePipe,
      "\u0275\u0275directiveInject": \u0275\u0275directiveInject,
      "\u0275\u0275getInheritedFactory": \u0275\u0275getInheritedFactory,
      "\u0275\u0275inject": \u0275\u0275inject,
      "\u0275\u0275injectAttribute": \u0275\u0275injectAttribute,
      "\u0275\u0275invalidFactory": \u0275\u0275invalidFactory,
      "\u0275\u0275invalidFactoryDep": \u0275\u0275invalidFactoryDep,
      "\u0275\u0275templateRefExtractor": \u0275\u0275templateRefExtractor,
      "\u0275\u0275resetView": \u0275\u0275resetView,
      "\u0275\u0275HostDirectivesFeature": \u0275\u0275HostDirectivesFeature,
      "\u0275\u0275NgOnChangesFeature": \u0275\u0275NgOnChangesFeature,
      "\u0275\u0275ProvidersFeature": \u0275\u0275ProvidersFeature,
      "\u0275\u0275CopyDefinitionFeature": \u0275\u0275CopyDefinitionFeature,
      "\u0275\u0275InheritDefinitionFeature": \u0275\u0275InheritDefinitionFeature,
      "\u0275\u0275ExternalStylesFeature": \u0275\u0275ExternalStylesFeature,
      "\u0275\u0275nextContext": \u0275\u0275nextContext,
      "\u0275\u0275namespaceHTML": \u0275\u0275namespaceHTML,
      "\u0275\u0275namespaceMathML": \u0275\u0275namespaceMathML,
      "\u0275\u0275namespaceSVG": \u0275\u0275namespaceSVG,
      "\u0275\u0275enableBindings": \u0275\u0275enableBindings,
      "\u0275\u0275disableBindings": \u0275\u0275disableBindings,
      "\u0275\u0275elementStart": \u0275\u0275elementStart,
      "\u0275\u0275elementEnd": \u0275\u0275elementEnd,
      "\u0275\u0275element": \u0275\u0275element,
      "\u0275\u0275elementContainerStart": \u0275\u0275elementContainerStart,
      "\u0275\u0275elementContainerEnd": \u0275\u0275elementContainerEnd,
      "\u0275\u0275domElement": \u0275\u0275domElement,
      "\u0275\u0275domElementStart": \u0275\u0275domElementStart,
      "\u0275\u0275domElementEnd": \u0275\u0275domElementEnd,
      "\u0275\u0275domElementContainer": \u0275\u0275domElementContainer,
      "\u0275\u0275domElementContainerStart": \u0275\u0275domElementContainerStart,
      "\u0275\u0275domElementContainerEnd": \u0275\u0275domElementContainerEnd,
      "\u0275\u0275domTemplate": \u0275\u0275domTemplate,
      "\u0275\u0275domListener": \u0275\u0275domListener,
      "\u0275\u0275elementContainer": \u0275\u0275elementContainer,
      "\u0275\u0275pureFunction0": \u0275\u0275pureFunction0,
      "\u0275\u0275pureFunction1": \u0275\u0275pureFunction1,
      "\u0275\u0275pureFunction2": \u0275\u0275pureFunction2,
      "\u0275\u0275pureFunction3": \u0275\u0275pureFunction3,
      "\u0275\u0275pureFunction4": \u0275\u0275pureFunction4,
      "\u0275\u0275pureFunction5": \u0275\u0275pureFunction5,
      "\u0275\u0275pureFunction6": \u0275\u0275pureFunction6,
      "\u0275\u0275pureFunction7": \u0275\u0275pureFunction7,
      "\u0275\u0275pureFunction8": \u0275\u0275pureFunction8,
      "\u0275\u0275pureFunctionV": \u0275\u0275pureFunctionV,
      "\u0275\u0275getCurrentView": \u0275\u0275getCurrentView,
      "\u0275\u0275restoreView": \u0275\u0275restoreView,
      "\u0275\u0275listener": \u0275\u0275listener,
      "\u0275\u0275projection": \u0275\u0275projection,
      "\u0275\u0275syntheticHostProperty": \u0275\u0275syntheticHostProperty,
      "\u0275\u0275syntheticHostListener": \u0275\u0275syntheticHostListener,
      "\u0275\u0275pipeBind1": \u0275\u0275pipeBind1,
      "\u0275\u0275pipeBind2": \u0275\u0275pipeBind2,
      "\u0275\u0275pipeBind3": \u0275\u0275pipeBind3,
      "\u0275\u0275pipeBind4": \u0275\u0275pipeBind4,
      "\u0275\u0275pipeBindV": \u0275\u0275pipeBindV,
      "\u0275\u0275projectionDef": \u0275\u0275projectionDef,
      "\u0275\u0275domProperty": \u0275\u0275domProperty,
      "\u0275\u0275property": \u0275\u0275property,
      "\u0275\u0275pipe": \u0275\u0275pipe,
      "\u0275\u0275queryRefresh": \u0275\u0275queryRefresh,
      "\u0275\u0275queryAdvance": \u0275\u0275queryAdvance,
      "\u0275\u0275viewQuery": \u0275\u0275viewQuery,
      "\u0275\u0275viewQuerySignal": \u0275\u0275viewQuerySignal,
      "\u0275\u0275loadQuery": \u0275\u0275loadQuery,
      "\u0275\u0275contentQuery": \u0275\u0275contentQuery,
      "\u0275\u0275contentQuerySignal": \u0275\u0275contentQuerySignal,
      "\u0275\u0275reference": \u0275\u0275reference,
      "\u0275\u0275classMap": \u0275\u0275classMap,
      "\u0275\u0275styleMap": \u0275\u0275styleMap,
      "\u0275\u0275styleProp": \u0275\u0275styleProp,
      "\u0275\u0275classProp": \u0275\u0275classProp,
      "\u0275\u0275advance": \u0275\u0275advance,
      "\u0275\u0275template": \u0275\u0275template,
      "\u0275\u0275conditional": \u0275\u0275conditional,
      "\u0275\u0275conditionalCreate": \u0275\u0275conditionalCreate,
      "\u0275\u0275conditionalBranchCreate": \u0275\u0275conditionalBranchCreate,
      "\u0275\u0275defer": \u0275\u0275defer,
      "\u0275\u0275deferWhen": \u0275\u0275deferWhen,
      "\u0275\u0275deferOnIdle": \u0275\u0275deferOnIdle,
      "\u0275\u0275deferOnImmediate": \u0275\u0275deferOnImmediate,
      "\u0275\u0275deferOnTimer": \u0275\u0275deferOnTimer,
      "\u0275\u0275deferOnHover": \u0275\u0275deferOnHover,
      "\u0275\u0275deferOnInteraction": \u0275\u0275deferOnInteraction,
      "\u0275\u0275deferOnViewport": \u0275\u0275deferOnViewport,
      "\u0275\u0275deferPrefetchWhen": \u0275\u0275deferPrefetchWhen,
      "\u0275\u0275deferPrefetchOnIdle": \u0275\u0275deferPrefetchOnIdle,
      "\u0275\u0275deferPrefetchOnImmediate": \u0275\u0275deferPrefetchOnImmediate,
      "\u0275\u0275deferPrefetchOnTimer": \u0275\u0275deferPrefetchOnTimer,
      "\u0275\u0275deferPrefetchOnHover": \u0275\u0275deferPrefetchOnHover,
      "\u0275\u0275deferPrefetchOnInteraction": \u0275\u0275deferPrefetchOnInteraction,
      "\u0275\u0275deferPrefetchOnViewport": \u0275\u0275deferPrefetchOnViewport,
      "\u0275\u0275deferHydrateWhen": \u0275\u0275deferHydrateWhen,
      "\u0275\u0275deferHydrateNever": \u0275\u0275deferHydrateNever,
      "\u0275\u0275deferHydrateOnIdle": \u0275\u0275deferHydrateOnIdle,
      "\u0275\u0275deferHydrateOnImmediate": \u0275\u0275deferHydrateOnImmediate,
      "\u0275\u0275deferHydrateOnTimer": \u0275\u0275deferHydrateOnTimer,
      "\u0275\u0275deferHydrateOnHover": \u0275\u0275deferHydrateOnHover,
      "\u0275\u0275deferHydrateOnInteraction": \u0275\u0275deferHydrateOnInteraction,
      "\u0275\u0275deferHydrateOnViewport": \u0275\u0275deferHydrateOnViewport,
      "\u0275\u0275deferEnableTimerScheduling": \u0275\u0275deferEnableTimerScheduling,
      "\u0275\u0275repeater": \u0275\u0275repeater,
      "\u0275\u0275repeaterCreate": \u0275\u0275repeaterCreate,
      "\u0275\u0275repeaterTrackByIndex": \u0275\u0275repeaterTrackByIndex,
      "\u0275\u0275repeaterTrackByIdentity": \u0275\u0275repeaterTrackByIdentity,
      "\u0275\u0275componentInstance": \u0275\u0275componentInstance,
      "\u0275\u0275text": \u0275\u0275text,
      "\u0275\u0275textInterpolate": \u0275\u0275textInterpolate,
      "\u0275\u0275textInterpolate1": \u0275\u0275textInterpolate1,
      "\u0275\u0275textInterpolate2": \u0275\u0275textInterpolate2,
      "\u0275\u0275textInterpolate3": \u0275\u0275textInterpolate3,
      "\u0275\u0275textInterpolate4": \u0275\u0275textInterpolate4,
      "\u0275\u0275textInterpolate5": \u0275\u0275textInterpolate5,
      "\u0275\u0275textInterpolate6": \u0275\u0275textInterpolate6,
      "\u0275\u0275textInterpolate7": \u0275\u0275textInterpolate7,
      "\u0275\u0275textInterpolate8": \u0275\u0275textInterpolate8,
      "\u0275\u0275textInterpolateV": \u0275\u0275textInterpolateV,
      "\u0275\u0275i18n": \u0275\u0275i18n,
      "\u0275\u0275i18nAttributes": \u0275\u0275i18nAttributes,
      "\u0275\u0275i18nExp": \u0275\u0275i18nExp,
      "\u0275\u0275i18nStart": \u0275\u0275i18nStart,
      "\u0275\u0275i18nEnd": \u0275\u0275i18nEnd,
      "\u0275\u0275i18nApply": \u0275\u0275i18nApply,
      "\u0275\u0275i18nPostprocess": \u0275\u0275i18nPostprocess,
      "\u0275\u0275resolveWindow": \u0275\u0275resolveWindow,
      "\u0275\u0275resolveDocument": \u0275\u0275resolveDocument,
      "\u0275\u0275resolveBody": \u0275\u0275resolveBody,
      "\u0275\u0275setComponentScope": \u0275\u0275setComponentScope,
      "\u0275\u0275setNgModuleScope": \u0275\u0275setNgModuleScope,
      "\u0275\u0275registerNgModuleType": registerNgModuleType,
      "\u0275\u0275getComponentDepsFactory": \u0275\u0275getComponentDepsFactory,
      "\u0275setClassDebugInfo": \u0275setClassDebugInfo,
      "\u0275\u0275declareLet": \u0275\u0275declareLet,
      "\u0275\u0275storeLet": \u0275\u0275storeLet,
      "\u0275\u0275readContextLet": \u0275\u0275readContextLet,
      "\u0275\u0275attachSourceLocations": \u0275\u0275attachSourceLocations,
      "\u0275\u0275interpolate": \u0275\u0275interpolate,
      "\u0275\u0275interpolate1": \u0275\u0275interpolate1,
      "\u0275\u0275interpolate2": \u0275\u0275interpolate2,
      "\u0275\u0275interpolate3": \u0275\u0275interpolate3,
      "\u0275\u0275interpolate4": \u0275\u0275interpolate4,
      "\u0275\u0275interpolate5": \u0275\u0275interpolate5,
      "\u0275\u0275interpolate6": \u0275\u0275interpolate6,
      "\u0275\u0275interpolate7": \u0275\u0275interpolate7,
      "\u0275\u0275interpolate8": \u0275\u0275interpolate8,
      "\u0275\u0275interpolateV": \u0275\u0275interpolateV,
      "\u0275\u0275sanitizeHtml": \u0275\u0275sanitizeHtml,
      "\u0275\u0275sanitizeStyle": \u0275\u0275sanitizeStyle,
      "\u0275\u0275sanitizeResourceUrl": \u0275\u0275sanitizeResourceUrl,
      "\u0275\u0275sanitizeScript": \u0275\u0275sanitizeScript,
      "\u0275\u0275sanitizeUrl": \u0275\u0275sanitizeUrl,
      "\u0275\u0275sanitizeUrlOrResourceUrl": \u0275\u0275sanitizeUrlOrResourceUrl,
      "\u0275\u0275trustConstantHtml": \u0275\u0275trustConstantHtml,
      "\u0275\u0275trustConstantResourceUrl": \u0275\u0275trustConstantResourceUrl,
      "\u0275\u0275validateIframeAttribute": \u0275\u0275validateIframeAttribute,
      "forwardRef": forwardRef,
      "resolveForwardRef": resolveForwardRef,
      "\u0275\u0275twoWayProperty": \u0275\u0275twoWayProperty,
      "\u0275\u0275twoWayBindingSet": \u0275\u0275twoWayBindingSet,
      "\u0275\u0275twoWayListener": \u0275\u0275twoWayListener,
      "\u0275\u0275replaceMetadata": \u0275\u0275replaceMetadata,
      "\u0275\u0275getReplaceMetadataURL": \u0275\u0275getReplaceMetadataURL
    }))();
    jitOptions = null;
    moduleQueue = [];
    flushingModuleQueue = false;
    ownerNgModule = /* @__PURE__ */ new WeakMap();
    verifiedNgModule = /* @__PURE__ */ new WeakMap();
    compilationDepth = 0;
    LIFECYCLE_HOOKS = [
      "ngOnChanges",
      "ngOnInit",
      "ngOnDestroy",
      "ngDoCheck",
      "ngAfterViewInit",
      "ngAfterViewChecked",
      "ngAfterContentInit",
      "ngAfterContentChecked"
    ];
    Directive = makeDecorator("Directive", (dir = {}) => dir, void 0, void 0, (type, meta) => compileDirective(type, meta));
    Component = makeDecorator("Component", (c2 = {}) => __spreadValues({ changeDetection: ChangeDetectionStrategy.Default }, c2), Directive, void 0, (type, meta) => compileComponent(type, meta));
    Pipe = makeDecorator("Pipe", (p2) => __spreadValues({ pure: true }, p2), void 0, void 0, (type, meta) => compilePipe(type, meta));
    Input = makePropDecorator("Input", (arg) => {
      if (!arg) {
        return {};
      }
      return typeof arg === "string" ? { alias: arg } : arg;
    });
    Output = makePropDecorator("Output", (alias) => ({ alias }));
    HostBinding = makePropDecorator("HostBinding", (hostPropertyName) => ({ hostPropertyName }));
    HostListener = makePropDecorator("HostListener", (eventName, args) => ({ eventName, args }));
    NgModule = makeDecorator(
      "NgModule",
      (ngModule) => ngModule,
      void 0,
      void 0,
      /**
       * Decorator that marks the following class as an NgModule, and supplies
       * configuration metadata for it.
       *
       * * The `declarations` option configures the compiler
       * with information about what belongs to the NgModule.
       * * The `providers` options configures the NgModule's injector to provide
       * dependencies the NgModule members.
       * * The `imports` and `exports` options bring in members from other modules, and make
       * this module's members available to others.
       */
      (type, meta) => compileNgModule(type, meta)
    );
    ModuleWithComponentFactories = class {
      ngModuleFactory;
      componentFactories;
      constructor(ngModuleFactory, componentFactories) {
        this.ngModuleFactory = ngModuleFactory;
        this.componentFactories = componentFactories;
      }
    };
    Compiler = class _Compiler {
      /**
       * Compiles the given NgModule and all of its components. All templates of the components
       * have to be inlined.
       */
      compileModuleSync(moduleType) {
        return new NgModuleFactory2(moduleType);
      }
      /**
       * Compiles the given NgModule and all of its components
       */
      compileModuleAsync(moduleType) {
        return Promise.resolve(this.compileModuleSync(moduleType));
      }
      /**
       * Same as {@link Compiler#compileModuleSync compileModuleSync} but also creates ComponentFactories for all components.
       */
      compileModuleAndAllComponentsSync(moduleType) {
        const ngModuleFactory = this.compileModuleSync(moduleType);
        const moduleDef = getNgModuleDef(moduleType);
        const componentFactories = maybeUnwrapFn(moduleDef.declarations).reduce((factories, declaration) => {
          const componentDef = getComponentDef(declaration);
          componentDef && factories.push(new ComponentFactory2(componentDef));
          return factories;
        }, []);
        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
      }
      /**
       * Same as {@link Compiler#compileModuleAsync compileModuleAsync} but also creates ComponentFactories for all components.
       */
      compileModuleAndAllComponentsAsync(moduleType) {
        return Promise.resolve(this.compileModuleAndAllComponentsSync(moduleType));
      }
      /**
       * Clears all caches.
       */
      clearCache() {
      }
      /**
       * Clears the cache for the given component/ngModule.
       */
      clearCacheFor(type) {
      }
      /**
       * Returns the id for a given NgModule, if one is defined and known to the compiler.
       */
      getModuleId(moduleType) {
        return void 0;
      }
      static \u0275fac = function Compiler_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Compiler)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _Compiler, factory: _Compiler.\u0275fac, providedIn: "root" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Compiler, [{
        type: Injectable,
        args: [{ providedIn: "root" }]
      }], null, null);
    })();
    COMPILER_OPTIONS = new InjectionToken(ngDevMode ? "compilerOptions" : "");
    NgZoneChangeDetectionScheduler = class _NgZoneChangeDetectionScheduler {
      zone = inject2(NgZone);
      changeDetectionScheduler = inject2(ChangeDetectionScheduler);
      applicationRef = inject2(ApplicationRef);
      applicationErrorHandler = inject2(INTERNAL_APPLICATION_ERROR_HANDLER);
      _onMicrotaskEmptySubscription;
      initialize() {
        if (this._onMicrotaskEmptySubscription) {
          return;
        }
        this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({
          next: () => {
            if (this.changeDetectionScheduler.runningTick) {
              return;
            }
            this.zone.run(() => {
              try {
                this.applicationRef.dirtyFlags |= 1;
                this.applicationRef._tick();
              } catch (e2) {
                this.applicationErrorHandler(e2);
              }
            });
          }
        });
      }
      ngOnDestroy() {
        this._onMicrotaskEmptySubscription?.unsubscribe();
      }
      static \u0275fac = function NgZoneChangeDetectionScheduler_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgZoneChangeDetectionScheduler)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _NgZoneChangeDetectionScheduler, factory: _NgZoneChangeDetectionScheduler.\u0275fac, providedIn: "root" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgZoneChangeDetectionScheduler, [{
        type: Injectable,
        args: [{ providedIn: "root" }]
      }], null, null);
    })();
    PROVIDED_NG_ZONE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "provideZoneChangeDetection token" : "", { factory: () => false });
    ZoneStablePendingTask = class _ZoneStablePendingTask {
      subscription = new Subscription();
      initialized = false;
      zone = inject2(NgZone);
      pendingTasks = inject2(PendingTasksInternal);
      initialize() {
        if (this.initialized) {
          return;
        }
        this.initialized = true;
        let task = null;
        if (!this.zone.isStable && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {
          task = this.pendingTasks.add();
        }
        this.zone.runOutsideAngular(() => {
          this.subscription.add(this.zone.onStable.subscribe(() => {
            NgZone.assertNotInAngularZone();
            queueMicrotask(() => {
              if (task !== null && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {
                this.pendingTasks.remove(task);
                task = null;
              }
            });
          }));
        });
        this.subscription.add(this.zone.onUnstable.subscribe(() => {
          NgZone.assertInAngularZone();
          task ??= this.pendingTasks.add();
        }));
      }
      ngOnDestroy() {
        this.subscription.unsubscribe();
      }
      static \u0275fac = function ZoneStablePendingTask_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ZoneStablePendingTask)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ZoneStablePendingTask, factory: _ZoneStablePendingTask.\u0275fac, providedIn: "root" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ZoneStablePendingTask, [{
        type: Injectable,
        args: [{ providedIn: "root" }]
      }], null, null);
    })();
    CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT = 100;
    consecutiveMicrotaskNotifications = 0;
    stackFromLastFewNotifications = [];
    ChangeDetectionSchedulerImpl = class _ChangeDetectionSchedulerImpl {
      applicationErrorHandler = inject2(INTERNAL_APPLICATION_ERROR_HANDLER);
      appRef = inject2(ApplicationRef);
      taskService = inject2(PendingTasksInternal);
      ngZone = inject2(NgZone);
      zonelessEnabled = inject2(ZONELESS_ENABLED);
      tracing = inject2(TracingService, { optional: true });
      disableScheduling = inject2(ZONELESS_SCHEDULER_DISABLED, { optional: true }) ?? false;
      zoneIsDefined = typeof Zone !== "undefined" && !!Zone.root.run;
      schedulerTickApplyArgs = [{ data: { "__scheduler_tick__": true } }];
      subscriptions = new Subscription();
      angularZoneId = this.zoneIsDefined ? this.ngZone._inner?.get(angularZoneInstanceIdProperty) : null;
      scheduleInRootZone = !this.zonelessEnabled && this.zoneIsDefined && (inject2(SCHEDULE_IN_ROOT_ZONE, { optional: true }) ?? false);
      cancelScheduledCallback = null;
      useMicrotaskScheduler = false;
      runningTick = false;
      pendingRenderTaskId = null;
      constructor() {
        this.subscriptions.add(this.appRef.afterTick.subscribe(() => {
          if (!this.runningTick) {
            this.cleanup();
          }
        }));
        this.subscriptions.add(this.ngZone.onUnstable.subscribe(() => {
          if (!this.runningTick) {
            this.cleanup();
          }
        }));
        this.disableScheduling ||= !this.zonelessEnabled && // NoopNgZone without enabling zoneless means no scheduling whatsoever
        (this.ngZone instanceof NoopNgZone || // The same goes for the lack of Zone without enabling zoneless scheduling
        !this.zoneIsDefined);
      }
      notify(source) {
        if (!this.zonelessEnabled && source === 5) {
          return;
        }
        let force = false;
        switch (source) {
          case 0: {
            this.appRef.dirtyFlags |= 2;
            break;
          }
          case 3:
          case 2:
          case 4:
          case 5:
          case 1: {
            this.appRef.dirtyFlags |= 4;
            break;
          }
          case 6: {
            this.appRef.dirtyFlags |= 2;
            force = true;
            break;
          }
          case 12: {
            this.appRef.dirtyFlags |= 16;
            force = true;
            break;
          }
          case 13: {
            this.appRef.dirtyFlags |= 2;
            force = true;
            break;
          }
          case 11: {
            force = true;
            break;
          }
          case 9:
          case 8:
          case 7:
          case 10:
          default: {
            this.appRef.dirtyFlags |= 8;
          }
        }
        this.appRef.tracingSnapshot = this.tracing?.snapshot(this.appRef.tracingSnapshot) ?? null;
        if (!this.shouldScheduleTick(force)) {
          return;
        }
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          if (this.useMicrotaskScheduler) {
            trackMicrotaskNotificationForDebugging();
          } else {
            consecutiveMicrotaskNotifications = 0;
            stackFromLastFewNotifications.length = 0;
          }
        }
        const scheduleCallback = this.useMicrotaskScheduler ? scheduleCallbackWithMicrotask : scheduleCallbackWithRafRace;
        this.pendingRenderTaskId = this.taskService.add();
        if (this.scheduleInRootZone) {
          this.cancelScheduledCallback = Zone.root.run(() => scheduleCallback(() => this.tick()));
        } else {
          this.cancelScheduledCallback = this.ngZone.runOutsideAngular(() => scheduleCallback(() => this.tick()));
        }
      }
      shouldScheduleTick(force) {
        if (this.disableScheduling && !force || this.appRef.destroyed) {
          return false;
        }
        if (this.pendingRenderTaskId !== null || this.runningTick || this.appRef._runningTick) {
          return false;
        }
        if (!this.zonelessEnabled && this.zoneIsDefined && Zone.current.get(angularZoneInstanceIdProperty + this.angularZoneId)) {
          return false;
        }
        return true;
      }
      /**
       * Calls ApplicationRef._tick inside the `NgZone`.
       *
       * Calling `tick` directly runs change detection and cancels any change detection that had been
       * scheduled previously.
       *
       * @param shouldRefreshViews Passed directly to `ApplicationRef._tick` and skips straight to
       *     render hooks when `false`.
       */
      tick() {
        if (this.runningTick || this.appRef.destroyed) {
          return;
        }
        if (this.appRef.dirtyFlags === 0) {
          this.cleanup();
          return;
        }
        if (!this.zonelessEnabled && this.appRef.dirtyFlags & 7) {
          this.appRef.dirtyFlags |= 1;
        }
        const task = this.taskService.add();
        try {
          this.ngZone.run(() => {
            this.runningTick = true;
            this.appRef._tick();
          }, void 0, this.schedulerTickApplyArgs);
        } catch (e2) {
          this.taskService.remove(task);
          this.applicationErrorHandler(e2);
        } finally {
          this.cleanup();
        }
        this.useMicrotaskScheduler = true;
        scheduleCallbackWithMicrotask(() => {
          this.useMicrotaskScheduler = false;
          this.taskService.remove(task);
        });
      }
      ngOnDestroy() {
        this.subscriptions.unsubscribe();
        this.cleanup();
      }
      cleanup() {
        this.runningTick = false;
        this.cancelScheduledCallback?.();
        this.cancelScheduledCallback = null;
        if (this.pendingRenderTaskId !== null) {
          const taskId = this.pendingRenderTaskId;
          this.pendingRenderTaskId = null;
          this.taskService.remove(taskId);
        }
      }
      static \u0275fac = function ChangeDetectionSchedulerImpl_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ChangeDetectionSchedulerImpl)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ChangeDetectionSchedulerImpl, factory: _ChangeDetectionSchedulerImpl.\u0275fac, providedIn: "root" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChangeDetectionSchedulerImpl, [{
        type: Injectable,
        args: [{ providedIn: "root" }]
      }], () => [], null);
    })();
    LOCALE_ID = new InjectionToken(ngDevMode ? "LocaleId" : "", {
      providedIn: "root",
      factory: () => inject2(LOCALE_ID, { optional: true, skipSelf: true }) || getGlobalLocale()
    });
    DEFAULT_CURRENCY_CODE = new InjectionToken(ngDevMode ? "DefaultCurrencyCode" : "", {
      providedIn: "root",
      factory: () => USD_CURRENCY_CODE
    });
    TRANSLATIONS = new InjectionToken(ngDevMode ? "Translations" : "");
    TRANSLATIONS_FORMAT = new InjectionToken(ngDevMode ? "TranslationsFormat" : "");
    (function(MissingTranslationStrategy2) {
      MissingTranslationStrategy2[MissingTranslationStrategy2["Error"] = 0] = "Error";
      MissingTranslationStrategy2[MissingTranslationStrategy2["Warning"] = 1] = "Warning";
      MissingTranslationStrategy2[MissingTranslationStrategy2["Ignore"] = 2] = "Ignore";
    })(MissingTranslationStrategy || (MissingTranslationStrategy = {}));
  }
});

// node_modules/@angular/core/fesm2022/resource.mjs
function untracked2(nonReactiveReadsFn) {
  return untracked(nonReactiveReadsFn);
}
function computed(computation, options) {
  const getter = createComputed(computation, options?.equal);
  if (ngDevMode) {
    getter.toString = () => `[Computed: ${getter()}]`;
    getter[SIGNAL].debugName = options?.debugName;
  }
  return getter;
}
function effect(effectFn, options) {
  ngDevMode && assertNotInReactiveContext(effect, "Call `effect` outside of a reactive context. For example, schedule the effect inside the component constructor.");
  if (ngDevMode && !options?.injector) {
    assertInInjectionContext(effect);
  }
  if (ngDevMode && options?.allowSignalWrites !== void 0) {
    console.warn(`The 'allowSignalWrites' flag is deprecated and no longer impacts effect() (writes are always allowed)`);
  }
  const injector = options?.injector ?? inject2(Injector);
  let destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;
  let node;
  const viewContext = injector.get(ViewContext, null, { optional: true });
  const notifier = injector.get(ChangeDetectionScheduler);
  if (viewContext !== null) {
    node = createViewEffect(viewContext.view, notifier, effectFn);
    if (destroyRef instanceof NodeInjectorDestroyRef && destroyRef._lView === viewContext.view) {
      destroyRef = null;
    }
  } else {
    node = createRootEffect(effectFn, injector.get(EffectScheduler), notifier);
  }
  node.injector = injector;
  if (destroyRef !== null) {
    node.onDestroyFn = destroyRef.onDestroy(() => node.destroy());
  }
  const effectRef = new EffectRefImpl(node);
  if (ngDevMode) {
    node.debugName = options?.debugName ?? "";
    const prevInjectorProfilerContext = setInjectorProfilerContext({ injector, token: null });
    try {
      emitEffectCreatedEvent(effectRef);
    } finally {
      setInjectorProfilerContext(prevInjectorProfilerContext);
    }
  }
  return effectRef;
}
function createViewEffect(view, notifier, fn) {
  const node = Object.create(VIEW_EFFECT_NODE);
  node.view = view;
  node.zone = typeof Zone !== "undefined" ? Zone.current : null;
  node.notifier = notifier;
  node.fn = fn;
  view[EFFECTS] ??= /* @__PURE__ */ new Set();
  view[EFFECTS].add(node);
  node.consumerMarkedDirty(node);
  return node;
}
function createRootEffect(fn, scheduler, notifier) {
  const node = Object.create(ROOT_EFFECT_NODE);
  node.fn = fn;
  node.scheduler = scheduler;
  node.notifier = notifier;
  node.zone = typeof Zone !== "undefined" ? Zone.current : null;
  node.scheduler.add(node);
  node.notifier.notify(
    12
    /* NotificationSource.RootEffect */
  );
  return node;
}
function linkedSignal(optionsOrComputation, options) {
  if (typeof optionsOrComputation === "function") {
    const getter = createLinkedSignal(optionsOrComputation, identityFn, options?.equal);
    return upgradeLinkedSignalGetter(getter);
  } else {
    const getter = createLinkedSignal(optionsOrComputation.source, optionsOrComputation.computation, optionsOrComputation.equal);
    return upgradeLinkedSignalGetter(getter);
  }
}
function upgradeLinkedSignalGetter(getter) {
  if (ngDevMode) {
    getter.toString = () => `[LinkedSignal: ${getter()}]`;
  }
  const node = getter[SIGNAL];
  const upgradedGetter = getter;
  upgradedGetter.set = (newValue) => linkedSignalSetFn(node, newValue);
  upgradedGetter.update = (updateFn) => linkedSignalUpdateFn(node, updateFn);
  upgradedGetter.asReadonly = signalAsReadonlyFn.bind(getter);
  return upgradedGetter;
}
function projectStatusOfState(state) {
  switch (state.status) {
    case "loading":
      return state.extRequest.reload === 0 ? "loading" : "reloading";
    case "resolved":
      return isResolved(state.stream()) ? "resolved" : "error";
    default:
      return state.status;
  }
}
function isResolved(state) {
  return state.error === void 0;
}
function encapsulateResourceError(error) {
  if (error instanceof Error) {
    return error;
  }
  return new ResourceWrappedError(error);
}
var OutputEmitterRef, EffectRefImpl, BASE_EFFECT_NODE, ROOT_EFFECT_NODE, VIEW_EFFECT_NODE, identityFn, RESOURCE_VALUE_THROWS_ERRORS_DEFAULT, BaseWritableResource, ResourceImpl, ResourceValueError, ResourceWrappedError;
var init_resource = __esm({
  "node_modules/@angular/core/fesm2022/resource.mjs"() {
    "use strict";
    init_root_effect_scheduler();
    init_signal();
    init_untracked();
    OutputEmitterRef = class {
      destroyed = false;
      listeners = null;
      errorHandler = inject2(ErrorHandler, { optional: true });
      /** @internal */
      destroyRef = inject2(DestroyRef);
      constructor() {
        this.destroyRef.onDestroy(() => {
          this.destroyed = true;
          this.listeners = null;
        });
      }
      subscribe(callback) {
        if (this.destroyed) {
          throw new RuntimeError(953, ngDevMode && "Unexpected subscription to destroyed `OutputRef`. The owning directive/component is destroyed.");
        }
        (this.listeners ??= []).push(callback);
        return {
          unsubscribe: () => {
            const idx = this.listeners?.indexOf(callback);
            if (idx !== void 0 && idx !== -1) {
              this.listeners?.splice(idx, 1);
            }
          }
        };
      }
      /** Emits a new value to the output. */
      emit(value) {
        if (this.destroyed) {
          console.warn(formatRuntimeError(953, ngDevMode && "Unexpected emit for destroyed `OutputRef`. The owning directive/component is destroyed."));
          return;
        }
        if (this.listeners === null) {
          return;
        }
        const previousConsumer = setActiveConsumer(null);
        try {
          for (const listenerFn of this.listeners) {
            try {
              listenerFn(value);
            } catch (err) {
              this.errorHandler?.handleError(err);
            }
          }
        } finally {
          setActiveConsumer(previousConsumer);
        }
      }
    };
    EffectRefImpl = class {
      [SIGNAL];
      constructor(node) {
        this[SIGNAL] = node;
      }
      destroy() {
        this[SIGNAL].destroy();
      }
    };
    BASE_EFFECT_NODE = /* @__PURE__ */ (() => __spreadProps(__spreadValues({}, REACTIVE_NODE), {
      consumerIsAlwaysLive: true,
      consumerAllowSignalWrites: true,
      dirty: true,
      hasRun: false,
      cleanupFns: void 0,
      zone: null,
      kind: "effect",
      onDestroyFn: noop2,
      run() {
        this.dirty = false;
        if (ngDevMode && isInNotificationPhase()) {
          throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);
        }
        if (this.hasRun && !consumerPollProducersForChange(this)) {
          return;
        }
        this.hasRun = true;
        const registerCleanupFn = (cleanupFn) => (this.cleanupFns ??= []).push(cleanupFn);
        const prevNode = consumerBeforeComputation(this);
        const prevRefreshingViews = setIsRefreshingViews(false);
        try {
          this.maybeCleanup();
          this.fn(registerCleanupFn);
        } finally {
          setIsRefreshingViews(prevRefreshingViews);
          consumerAfterComputation(this, prevNode);
        }
      },
      maybeCleanup() {
        if (!this.cleanupFns?.length) {
          return;
        }
        const prevConsumer = setActiveConsumer(null);
        try {
          while (this.cleanupFns.length) {
            this.cleanupFns.pop()();
          }
        } finally {
          this.cleanupFns = [];
          setActiveConsumer(prevConsumer);
        }
      }
    }))();
    ROOT_EFFECT_NODE = /* @__PURE__ */ (() => __spreadProps(__spreadValues({}, BASE_EFFECT_NODE), {
      consumerMarkedDirty() {
        this.scheduler.schedule(this);
        this.notifier.notify(
          12
          /* NotificationSource.RootEffect */
        );
      },
      destroy() {
        consumerDestroy(this);
        this.onDestroyFn();
        this.maybeCleanup();
        this.scheduler.remove(this);
      }
    }))();
    VIEW_EFFECT_NODE = /* @__PURE__ */ (() => __spreadProps(__spreadValues({}, BASE_EFFECT_NODE), {
      consumerMarkedDirty() {
        this.view[FLAGS] |= 8192;
        markAncestorsForTraversal(this.view);
        this.notifier.notify(
          13
          /* NotificationSource.ViewEffect */
        );
      },
      destroy() {
        consumerDestroy(this);
        this.onDestroyFn();
        this.maybeCleanup();
        this.view[EFFECTS]?.delete(this);
      }
    }))();
    identityFn = (v) => v;
    RESOURCE_VALUE_THROWS_ERRORS_DEFAULT = true;
    BaseWritableResource = class {
      value;
      constructor(value) {
        this.value = value;
        this.value.set = this.set.bind(this);
        this.value.update = this.update.bind(this);
        this.value.asReadonly = signalAsReadonlyFn;
      }
      isError = computed(() => this.status() === "error");
      update(updateFn) {
        this.set(updateFn(untracked2(this.value)));
      }
      isLoading = computed(() => this.status() === "loading" || this.status() === "reloading");
      // Use a computed here to avoid triggering reactive consumers if the value changes while staying
      // either defined or undefined.
      isValueDefined = computed(() => {
        if (this.isError()) {
          return false;
        }
        return this.value() !== void 0;
      });
      hasValue() {
        return this.isValueDefined();
      }
      asReadonly() {
        return this;
      }
    };
    ResourceImpl = class extends BaseWritableResource {
      loaderFn;
      equal;
      pendingTasks;
      /**
       * The current state of the resource. Status, value, and error are derived from this.
       */
      state;
      /**
       * Combines the current request with a reload counter which allows the resource to be reloaded on
       * imperative command.
       */
      extRequest;
      effectRef;
      pendingController;
      resolvePendingTask = void 0;
      destroyed = false;
      unregisterOnDestroy;
      constructor(request, loaderFn, defaultValue, equal, injector, throwErrorsFromValue = RESOURCE_VALUE_THROWS_ERRORS_DEFAULT) {
        super(
          // Feed a computed signal for the value to `BaseWritableResource`, which will upgrade it to a
          // `WritableSignal` that delegates to `ResourceImpl.set`.
          computed(() => {
            const streamValue = this.state().stream?.();
            if (!streamValue) {
              return defaultValue;
            }
            if (this.state().status === "loading" && this.error()) {
              return defaultValue;
            }
            if (!isResolved(streamValue)) {
              if (throwErrorsFromValue) {
                throw new ResourceValueError(this.error());
              } else {
                return defaultValue;
              }
            }
            return streamValue.value;
          }, { equal })
        );
        this.loaderFn = loaderFn;
        this.equal = equal;
        this.extRequest = linkedSignal({
          source: request,
          computation: (request2) => ({ request: request2, reload: 0 })
        });
        this.state = linkedSignal({
          // Whenever the request changes,
          source: this.extRequest,
          // Compute the state of the resource given a change in status.
          computation: (extRequest, previous) => {
            const status = extRequest.request === void 0 ? "idle" : "loading";
            if (!previous) {
              return {
                extRequest,
                status,
                previousStatus: "idle",
                stream: void 0
              };
            } else {
              return {
                extRequest,
                status,
                previousStatus: projectStatusOfState(previous.value),
                // If the request hasn't changed, keep the previous stream.
                stream: previous.value.extRequest.request === extRequest.request ? previous.value.stream : void 0
              };
            }
          }
        });
        this.effectRef = effect(this.loadEffect.bind(this), {
          injector,
          manualCleanup: true
        });
        this.pendingTasks = injector.get(PendingTasks);
        this.unregisterOnDestroy = injector.get(DestroyRef).onDestroy(() => this.destroy());
      }
      status = computed(() => projectStatusOfState(this.state()));
      error = computed(() => {
        const stream = this.state().stream?.();
        return stream && !isResolved(stream) ? stream.error : void 0;
      });
      /**
       * Called either directly via `WritableResource.set` or via `.value.set()`.
       */
      set(value) {
        if (this.destroyed) {
          return;
        }
        const error = untracked2(this.error);
        const state = untracked2(this.state);
        if (!error) {
          const current = untracked2(this.value);
          if (state.status === "local" && (this.equal ? this.equal(current, value) : current === value)) {
            return;
          }
        }
        this.state.set({
          extRequest: state.extRequest,
          status: "local",
          previousStatus: "local",
          stream: signal({ value })
        });
        this.abortInProgressLoad();
      }
      reload() {
        const { status } = untracked2(this.state);
        if (status === "idle" || status === "loading") {
          return false;
        }
        this.extRequest.update(({ request, reload }) => ({ request, reload: reload + 1 }));
        return true;
      }
      destroy() {
        this.destroyed = true;
        this.unregisterOnDestroy();
        this.effectRef.destroy();
        this.abortInProgressLoad();
        this.state.set({
          extRequest: { request: void 0, reload: 0 },
          status: "idle",
          previousStatus: "idle",
          stream: void 0
        });
      }
      loadEffect() {
        return __async(this, null, function* () {
          const extRequest = this.extRequest();
          const { status: currentStatus, previousStatus } = untracked2(this.state);
          if (extRequest.request === void 0) {
            return;
          } else if (currentStatus !== "loading") {
            return;
          }
          this.abortInProgressLoad();
          let resolvePendingTask = this.resolvePendingTask = this.pendingTasks.add();
          const { signal: abortSignal } = this.pendingController = new AbortController();
          try {
            const stream = yield untracked2(() => {
              return this.loaderFn({
                params: extRequest.request,
                // TODO(alxhub): cleanup after g3 removal of `request` alias.
                request: extRequest.request,
                abortSignal,
                previous: {
                  status: previousStatus
                }
              });
            });
            if (abortSignal.aborted || untracked2(this.extRequest) !== extRequest) {
              return;
            }
            this.state.set({
              extRequest,
              status: "resolved",
              previousStatus: "resolved",
              stream
            });
          } catch (err) {
            if (abortSignal.aborted || untracked2(this.extRequest) !== extRequest) {
              return;
            }
            this.state.set({
              extRequest,
              status: "resolved",
              previousStatus: "error",
              stream: signal({ error: encapsulateResourceError(err) })
            });
          } finally {
            resolvePendingTask?.();
            resolvePendingTask = void 0;
          }
        });
      }
      abortInProgressLoad() {
        untracked2(() => this.pendingController?.abort());
        this.pendingController = void 0;
        this.resolvePendingTask?.();
        this.resolvePendingTask = void 0;
      }
    };
    ResourceValueError = class extends Error {
      constructor(error) {
        super(ngDevMode ? `Resource is currently in an error state (see Error.cause for details): ${error.message}` : error.message, { cause: error });
      }
    };
    ResourceWrappedError = class extends Error {
      constructor(error) {
        super(ngDevMode ? `Resource returned an error that's not an Error instance: ${String(error)}. Check this error's .cause for the actual error.` : String(error), { cause: error });
      }
    };
  }
});

// node_modules/@angular/core/fesm2022/core.mjs
function createInputSignal(initialValue, options) {
  const node = Object.create(INPUT_SIGNAL_NODE);
  node.value = initialValue;
  node.transformFn = options?.transform;
  function inputValueFn() {
    producerAccessed(node);
    if (node.value === REQUIRED_UNSET_VALUE) {
      let message = null;
      if (ngDevMode) {
        const name = options?.debugName ?? options?.alias;
        message = `Input${name ? ` "${name}"` : ""} is required but no value is available yet.`;
      }
      throw new RuntimeError(-950, message);
    }
    return node.value;
  }
  inputValueFn[SIGNAL] = node;
  if (ngDevMode) {
    inputValueFn.toString = () => `[Input Signal: ${inputValueFn()}]`;
    node.debugName = options?.debugName;
  }
  return inputValueFn;
}
function getDevModeNodeName(tNode) {
  if (tNode.type & 8) {
    return "an <ng-container>";
  } else if (tNode.type & 4) {
    return "an <ng-template>";
  } else if (tNode.type & 128) {
    return "an @let declaration";
  } else {
    return "a node";
  }
}
function inputFunction(initialValue, opts) {
  ngDevMode && assertInInjectionContext(input);
  return createInputSignal(initialValue, opts);
}
function inputRequiredFunction(opts) {
  ngDevMode && assertInInjectionContext(input);
  return createInputSignal(REQUIRED_UNSET_VALUE, opts);
}
function viewChildFn(locator, opts) {
  ngDevMode && assertInInjectionContext(viewChild);
  return createSingleResultOptionalQuerySignalFn(opts);
}
function viewChildRequiredFn(locator, opts) {
  ngDevMode && assertInInjectionContext(viewChild);
  return createSingleResultRequiredQuerySignalFn(opts);
}
function contentChildFn(locator, opts) {
  ngDevMode && assertInInjectionContext(contentChild);
  return createSingleResultOptionalQuerySignalFn(opts);
}
function contentChildRequiredFn(locator, opts) {
  ngDevMode && assertInInjectionContext(contentChildren);
  return createSingleResultRequiredQuerySignalFn(opts);
}
function contentChildren(locator, opts) {
  return createMultiResultQuerySignalFn(opts);
}
function createModelSignal(initialValue, opts) {
  const node = Object.create(INPUT_SIGNAL_NODE);
  const emitterRef = new OutputEmitterRef();
  node.value = initialValue;
  function getter() {
    producerAccessed(node);
    assertModelSet(node.value);
    return node.value;
  }
  getter[SIGNAL] = node;
  getter.asReadonly = signalAsReadonlyFn.bind(getter);
  getter.set = (newValue) => {
    if (!node.equal(node.value, newValue)) {
      signalSetFn(node, newValue);
      emitterRef.emit(newValue);
    }
  };
  getter.update = (updateFn) => {
    assertModelSet(node.value);
    getter.set(updateFn(node.value));
  };
  getter.subscribe = emitterRef.subscribe.bind(emitterRef);
  getter.destroyRef = emitterRef.destroyRef;
  if (ngDevMode) {
    getter.toString = () => `[Model Signal: ${getter()}]`;
    node.debugName = opts?.debugName;
  }
  return getter;
}
function assertModelSet(value) {
  if (value === REQUIRED_UNSET_VALUE) {
    throw new RuntimeError(952, ngDevMode && "Model is required but no value is available yet.");
  }
}
function modelFunction(initialValue, opts) {
  ngDevMode && assertInInjectionContext(model);
  return createModelSignal(initialValue, opts);
}
function modelRequiredFunction(opts) {
  ngDevMode && assertInInjectionContext(model);
  return createModelSignal(REQUIRED_UNSET_VALUE, opts);
}
function compileNgModuleFactory(injector, options, moduleType) {
  ngDevMode && assertNgModuleType(moduleType);
  const moduleFactory = new NgModuleFactory2(moduleType);
  if (true) {
    return Promise.resolve(moduleFactory);
  }
  const compilerOptions = injector.get(COMPILER_OPTIONS, []).concat(options);
  setJitOptions({
    defaultEncapsulation: _lastDefined(compilerOptions.map((opts) => opts.defaultEncapsulation)),
    preserveWhitespaces: _lastDefined(compilerOptions.map((opts) => opts.preserveWhitespaces))
  });
  if (isComponentResourceResolutionQueueEmpty()) {
    return Promise.resolve(moduleFactory);
  }
  const compilerProviders = compilerOptions.flatMap((option) => option.providers ?? []);
  if (compilerProviders.length === 0) {
    return Promise.resolve(moduleFactory);
  }
  const compiler = getCompilerFacade({
    usage: 0,
    kind: "NgModule",
    type: moduleType
  });
  const compilerInjector = Injector.create({ providers: compilerProviders });
  const resourceLoader = compilerInjector.get(compiler.ResourceLoader);
  return resolveComponentResources((url) => Promise.resolve(resourceLoader.get(url))).then(() => moduleFactory);
}
function _lastDefined(args) {
  for (let i2 = args.length - 1; i2 >= 0; i2--) {
    if (args[i2] !== void 0) {
      return args[i2];
    }
  }
  return void 0;
}
function logLazyLCPWarning(src) {
  console.warn(formatRuntimeError(-913, `An image with src ${src} is the Largest Contentful Paint (LCP) element but was given a "loading" value of "lazy", which can negatively impact application loading performance. This warning can be addressed by changing the loading value of the LCP image to "eager", or by using the NgOptimizedImage directive's prioritization utilities. For more information about addressing or disabling this warning, see https://angular.dev/errors/NG0913`));
}
function logOversizedImageWarning(src) {
  console.warn(formatRuntimeError(-913, `An image with src ${src} has intrinsic file dimensions much larger than its rendered size. This can negatively impact application loading performance. For more information about addressing or disabling this warning, see https://angular.dev/errors/NG0913`));
}
function isApplicationBootstrapConfig(config2) {
  return !config2.moduleRef;
}
function bootstrap(config2) {
  const envInjector = isApplicationBootstrapConfig(config2) ? config2.r3Injector : config2.moduleRef.injector;
  const ngZone = envInjector.get(NgZone);
  return ngZone.run(() => {
    if (isApplicationBootstrapConfig(config2)) {
      config2.r3Injector.resolveInjectorInitializers();
    } else {
      config2.moduleRef.resolveInjectorInitializers();
    }
    const exceptionHandler = envInjector.get(INTERNAL_APPLICATION_ERROR_HANDLER);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (envInjector.get(PROVIDED_ZONELESS) && envInjector.get(PROVIDED_NG_ZONE)) {
        throw new RuntimeError(408, "Invalid change detection configuration: provideZoneChangeDetection and provideZonelessChangeDetection cannot be used together.");
      }
    }
    let onErrorSubscription;
    ngZone.runOutsideAngular(() => {
      onErrorSubscription = ngZone.onError.subscribe({
        next: exceptionHandler
      });
    });
    if (isApplicationBootstrapConfig(config2)) {
      const destroyListener = () => envInjector.destroy();
      const onPlatformDestroyListeners = config2.platformInjector.get(PLATFORM_DESTROY_LISTENERS);
      onPlatformDestroyListeners.add(destroyListener);
      envInjector.onDestroy(() => {
        onErrorSubscription.unsubscribe();
        onPlatformDestroyListeners.delete(destroyListener);
      });
    } else {
      const destroyListener = () => config2.moduleRef.destroy();
      const onPlatformDestroyListeners = config2.platformInjector.get(PLATFORM_DESTROY_LISTENERS);
      onPlatformDestroyListeners.add(destroyListener);
      config2.moduleRef.onDestroy(() => {
        remove(config2.allPlatformModules, config2.moduleRef);
        onErrorSubscription.unsubscribe();
        onPlatformDestroyListeners.delete(destroyListener);
      });
    }
    return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {
      const pendingTasks = envInjector.get(PendingTasksInternal);
      const taskId = pendingTasks.add();
      const initStatus = envInjector.get(ApplicationInitStatus);
      initStatus.runInitializers();
      return initStatus.donePromise.then(() => {
        const localeId = envInjector.get(LOCALE_ID, DEFAULT_LOCALE_ID);
        setLocaleId(localeId || DEFAULT_LOCALE_ID);
        const enableRootComponentBoostrap = envInjector.get(ENABLE_ROOT_COMPONENT_BOOTSTRAP, true);
        if (!enableRootComponentBoostrap) {
          if (isApplicationBootstrapConfig(config2)) {
            return envInjector.get(ApplicationRef);
          }
          config2.allPlatformModules.push(config2.moduleRef);
          return config2.moduleRef;
        }
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          const imagePerformanceService = envInjector.get(ImagePerformanceWarning);
          imagePerformanceService.start();
        }
        if (isApplicationBootstrapConfig(config2)) {
          const appRef = envInjector.get(ApplicationRef);
          if (config2.rootComponent !== void 0) {
            appRef.bootstrap(config2.rootComponent);
          }
          return appRef;
        } else {
          moduleBootstrapImpl?.(config2.moduleRef, config2.allPlatformModules);
          return config2.moduleRef;
        }
      }).finally(() => void pendingTasks.remove(taskId));
    });
  });
}
function setModuleBootstrapImpl() {
  moduleBootstrapImpl = _moduleDoBootstrap;
}
function _moduleDoBootstrap(moduleRef, allPlatformModules) {
  const appRef = moduleRef.injector.get(ApplicationRef);
  if (moduleRef._bootstrapComponents.length > 0) {
    moduleRef._bootstrapComponents.forEach((f2) => appRef.bootstrap(f2));
  } else if (moduleRef.instance.ngDoBootstrap) {
    moduleRef.instance.ngDoBootstrap(appRef);
  } else {
    throw new RuntimeError(-403, ngDevMode && `The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);
  }
  allPlatformModules.push(moduleRef);
}
function _callAndReportToErrorHandler(errorHandler2, ngZone, callback) {
  try {
    const result = callback();
    if (isPromise2(result)) {
      return result.catch((e2) => {
        ngZone.runOutsideAngular(() => errorHandler2(e2));
        throw e2;
      });
    }
    return result;
  } catch (e2) {
    ngZone.runOutsideAngular(() => errorHandler2(e2));
    throw e2;
  }
}
function createPlatform(injector) {
  if (_platformInjector && !_platformInjector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
    throw new RuntimeError(400, ngDevMode && "There can be only one platform. Destroy the previous one to create a new one.");
  }
  publishDefaultGlobalUtils();
  publishSignalConfiguration();
  _platformInjector = injector;
  const platform = injector.get(PlatformRef);
  runPlatformInitializers(injector);
  return platform;
}
function createPlatformFactory(parentPlatformFactory, name, providers = []) {
  const desc = `Platform: ${name}`;
  const marker = new InjectionToken(desc);
  return (extraProviders = []) => {
    let platform = getPlatform();
    if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
      const platformProviders = [
        ...providers,
        ...extraProviders,
        { provide: marker, useValue: true }
      ];
      if (parentPlatformFactory) {
        parentPlatformFactory(platformProviders);
      } else {
        createPlatform(createPlatformInjector(platformProviders, desc));
      }
    }
    return assertPlatform(marker);
  };
}
function createPlatformInjector(providers = [], name) {
  return Injector.create({
    name,
    providers: [
      { provide: INJECTOR_SCOPE, useValue: "platform" },
      { provide: PLATFORM_DESTROY_LISTENERS, useValue: /* @__PURE__ */ new Set([() => _platformInjector = null]) },
      ...providers
    ]
  });
}
function assertPlatform(requiredToken) {
  const platform = getPlatform();
  if (!platform) {
    throw new RuntimeError(401, ngDevMode && "No platform exists!");
  }
  if ((typeof ngDevMode === "undefined" || ngDevMode) && !platform.injector.get(requiredToken, null)) {
    throw new RuntimeError(400, "A platform with a different configuration has been created. Please destroy it first.");
  }
  return platform;
}
function getPlatform() {
  return _platformInjector?.get(PlatformRef) ?? null;
}
function createOrReusePlatformInjector(providers = []) {
  if (_platformInjector)
    return _platformInjector;
  publishDefaultGlobalUtils();
  const injector = createPlatformInjector(providers);
  _platformInjector = injector;
  publishSignalConfiguration();
  runPlatformInitializers(injector);
  return injector;
}
function runPlatformInitializers(injector) {
  const inits = injector.get(PLATFORM_INITIALIZER, null);
  runInInjectionContext(injector, () => {
    inits?.forEach((init) => init());
  });
}
function injectChangeDetectorRef(flags) {
  return createViewRef(
    getCurrentTNode(),
    getLView(),
    (flags & 16) === 16
    /* InternalInjectFlags.ForPipe */
  );
}
function createViewRef(tNode, lView, isPipe2) {
  if (isComponentHost(tNode) && !isPipe2) {
    const componentView = getComponentLViewByIndex(tNode.index, lView);
    return new ViewRef(componentView, componentView);
  } else if (tNode.type & (3 | 12 | 32 | 128)) {
    const hostComponentView = lView[DECLARATION_COMPONENT_VIEW];
    return new ViewRef(hostComponentView, lView);
  }
  return null;
}
function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
  const previousIndex = item.previousIndex;
  if (previousIndex === null)
    return previousIndex;
  let moveOffset = 0;
  if (moveOffsets && previousIndex < moveOffsets.length) {
    moveOffset = moveOffsets[previousIndex];
  }
  return previousIndex + addRemoveOffset + moveOffset;
}
function defaultIterableDiffersFactory() {
  return new IterableDiffers([new DefaultIterableDifferFactory()]);
}
function getTypeNameForDebugging(type) {
  return type["name"] || typeof type;
}
function defaultKeyValueDiffersFactory() {
  return new KeyValueDiffers([new DefaultKeyValueDifferFactory()]);
}
function internalCreateApplication(config2) {
  profiler(
    8
    /* ProfilerEvent.BootstrapApplicationStart */
  );
  try {
    const { rootComponent, appProviders, platformProviders } = config2;
    if ((typeof ngDevMode === "undefined" || ngDevMode) && rootComponent !== void 0) {
      assertStandaloneComponentType(rootComponent);
    }
    const platformInjector = createOrReusePlatformInjector(platformProviders);
    const allAppProviders = [
      internalProvideZoneChangeDetection({}),
      { provide: ChangeDetectionScheduler, useExisting: ChangeDetectionSchedulerImpl },
      errorHandlerEnvironmentInitializer,
      ...appProviders || []
    ];
    const adapter = new EnvironmentNgModuleRefAdapter({
      providers: allAppProviders,
      parent: platformInjector,
      debugName: typeof ngDevMode === "undefined" || ngDevMode ? "Environment Injector" : "",
      // We skip environment initializers because we need to run them inside the NgZone, which
      // happens after we get the NgZone instance from the Injector.
      runEnvironmentInitializers: false
    });
    return bootstrap({
      r3Injector: adapter.injector,
      platformInjector,
      rootComponent
    });
  } catch (e2) {
    return Promise.reject(e2);
  } finally {
    profiler(
      9
      /* ProfilerEvent.BootstrapApplicationEnd */
    );
  }
}
function booleanAttribute(value) {
  return typeof value === "boolean" ? value : value != null && value !== "false";
}
function numberAttribute(value, fallbackValue = NaN) {
  const isNumberValue = !isNaN(parseFloat(value)) && !isNaN(Number(value));
  return isNumberValue ? Number(value) : fallbackValue;
}
function createComponent(component, options) {
  ngDevMode && assertComponentDef(component);
  const componentDef = getComponentDef(component);
  const elementInjector = options.elementInjector || getNullInjector();
  const factory = new ComponentFactory2(componentDef);
  return factory.create(elementInjector, options.projectableNodes, options.hostElement, options.environmentInjector, options.directives, options.bindings);
}
function reflectComponentType(component) {
  const componentDef = getComponentDef(component);
  if (!componentDef)
    return null;
  const factory = new ComponentFactory2(componentDef);
  return {
    get selector() {
      return factory.selector;
    },
    get type() {
      return factory.componentType;
    },
    get inputs() {
      return factory.inputs;
    },
    get outputs() {
      return factory.outputs;
    },
    get ngContentSelectors() {
      return factory.ngContentSelectors;
    },
    get isStandalone() {
      return componentDef.standalone;
    },
    get isSignal() {
      return componentDef.signals;
    }
  };
}
var REQUIRED_UNSET_VALUE, INPUT_SIGNAL_NODE, FactoryTarget, R3TemplateDependencyKind, ViewEncapsulation2, HostAttributeToken, HOST_TAG_NAME, input, viewChild, contentChild, model, emitDistinctChangesOnlyDefaultValue, Query, ContentChildren, ContentChild, ViewChildren, ViewChild, Version, VERSION, SCAN_DELAY, OVERSIZED_IMAGE_TOLERANCE, ImagePerformanceWarning, PLATFORM_DESTROY_LISTENERS, ENABLE_ROOT_COMPONENT_BOOTSTRAP, moduleBootstrapImpl, PlatformRef, _platformInjector, ALLOW_MULTIPLE_PLATFORMS, ChangeDetectorRef, DefaultIterableDifferFactory, trackByIdentity, DefaultIterableDiffer, IterableChangeRecord_, _DuplicateItemRecordList, _DuplicateMap, DefaultKeyValueDifferFactory, DefaultKeyValueDiffer, KeyValueChangeRecord_, IterableDiffers, KeyValueDiffers, keyValDiff, iterableDiff, defaultIterableDiffers, defaultKeyValueDiffers, platformCore, ApplicationModule, REQUEST, RESPONSE_INIT, REQUEST_CONTEXT;
var init_core = __esm({
  "node_modules/@angular/core/fesm2022/core.mjs"() {
    "use strict";
    init_root_effect_scheduler();
    init_root_effect_scheduler();
    init_signal();
    init_debug_node();
    init_debug_node();
    init_resource();
    init_resource();
    REQUIRED_UNSET_VALUE = /* @__PURE__ */ Symbol("InputSignalNode#UNSET");
    INPUT_SIGNAL_NODE = /* @__PURE__ */ (() => {
      return __spreadProps(__spreadValues({}, SIGNAL_NODE), {
        transformFn: void 0,
        applyValueToInputSignal(node, value) {
          signalSetFn(node, value);
        }
      });
    })();
    (function(FactoryTarget2) {
      FactoryTarget2[FactoryTarget2["Directive"] = 0] = "Directive";
      FactoryTarget2[FactoryTarget2["Component"] = 1] = "Component";
      FactoryTarget2[FactoryTarget2["Injectable"] = 2] = "Injectable";
      FactoryTarget2[FactoryTarget2["Pipe"] = 3] = "Pipe";
      FactoryTarget2[FactoryTarget2["NgModule"] = 4] = "NgModule";
    })(FactoryTarget || (FactoryTarget = {}));
    (function(R3TemplateDependencyKind2) {
      R3TemplateDependencyKind2[R3TemplateDependencyKind2["Directive"] = 0] = "Directive";
      R3TemplateDependencyKind2[R3TemplateDependencyKind2["Pipe"] = 1] = "Pipe";
      R3TemplateDependencyKind2[R3TemplateDependencyKind2["NgModule"] = 2] = "NgModule";
    })(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));
    (function(ViewEncapsulation3) {
      ViewEncapsulation3[ViewEncapsulation3["Emulated"] = 0] = "Emulated";
      ViewEncapsulation3[ViewEncapsulation3["None"] = 2] = "None";
      ViewEncapsulation3[ViewEncapsulation3["ShadowDom"] = 3] = "ShadowDom";
    })(ViewEncapsulation2 || (ViewEncapsulation2 = {}));
    HostAttributeToken = class {
      attributeName;
      constructor(attributeName) {
        this.attributeName = attributeName;
      }
      /** @internal */
      __NG_ELEMENT_ID__ = () => \u0275\u0275injectAttribute(this.attributeName);
      toString() {
        return `HostAttributeToken ${this.attributeName}`;
      }
    };
    HOST_TAG_NAME = new InjectionToken(ngDevMode ? "HOST_TAG_NAME" : "");
    HOST_TAG_NAME.__NG_ELEMENT_ID__ = (flags) => {
      const tNode = getCurrentTNode();
      if (tNode === null) {
        throw new RuntimeError(204, ngDevMode && "HOST_TAG_NAME can only be injected in directives and components during construction time (in a class constructor or as a class field initializer)");
      }
      if (tNode.type & 2) {
        return tNode.value;
      }
      if (flags & 8) {
        return null;
      }
      throw new RuntimeError(204, ngDevMode && `HOST_TAG_NAME was used on ${getDevModeNodeName(tNode)} which doesn't have an underlying element in the DOM. This is invalid, and so the dependency should be marked as optional.`);
    };
    input = (() => {
      inputFunction.required = inputRequiredFunction;
      return inputFunction;
    })();
    viewChild = (() => {
      viewChildFn.required = viewChildRequiredFn;
      return viewChildFn;
    })();
    contentChild = (() => {
      contentChildFn.required = contentChildRequiredFn;
      return contentChildFn;
    })();
    model = (() => {
      modelFunction.required = modelRequiredFunction;
      return modelFunction;
    })();
    emitDistinctChangesOnlyDefaultValue = true;
    Query = class {
    };
    ContentChildren = makePropDecorator("ContentChildren", (selector, opts = {}) => __spreadValues({
      selector,
      first: false,
      isViewQuery: false,
      descendants: false,
      emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue
    }, opts), Query);
    ContentChild = makePropDecorator("ContentChild", (selector, opts = {}) => __spreadValues({
      selector,
      first: true,
      isViewQuery: false,
      descendants: true
    }, opts), Query);
    ViewChildren = makePropDecorator("ViewChildren", (selector, opts = {}) => __spreadValues({
      selector,
      first: false,
      isViewQuery: true,
      descendants: true,
      emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue
    }, opts), Query);
    ViewChild = makePropDecorator("ViewChild", (selector, opts) => __spreadValues({
      selector,
      first: true,
      isViewQuery: true,
      descendants: true
    }, opts), Query);
    Version = class {
      full;
      major;
      minor;
      patch;
      constructor(full) {
        this.full = full;
        const parts = full.split(".");
        this.major = parts[0];
        this.minor = parts[1];
        this.patch = parts.slice(2).join(".");
      }
    };
    VERSION = new Version("20.1.7");
    SCAN_DELAY = 200;
    OVERSIZED_IMAGE_TOLERANCE = 1200;
    ImagePerformanceWarning = class _ImagePerformanceWarning {
      // Map of full image URLs -> original `ngSrc` values.
      window = null;
      observer = null;
      options = inject2(IMAGE_CONFIG);
      lcpImageUrl;
      start() {
        if (typeof PerformanceObserver === "undefined" || this.options?.disableImageSizeWarning && this.options?.disableImageLazyLoadWarning) {
          return;
        }
        this.observer = this.initPerformanceObserver();
        const doc = getDocument();
        const win = doc.defaultView;
        if (win) {
          this.window = win;
          const waitToScan = () => {
            setTimeout(this.scanImages.bind(this), SCAN_DELAY);
          };
          const setup = () => {
            if (doc.readyState === "complete") {
              waitToScan();
            } else {
              this.window?.addEventListener("load", waitToScan, { once: true });
            }
          };
          if (typeof Zone !== "undefined") {
            Zone.root.run(() => setup());
          } else {
            setup();
          }
        }
      }
      ngOnDestroy() {
        this.observer?.disconnect();
      }
      initPerformanceObserver() {
        if (typeof PerformanceObserver === "undefined") {
          return null;
        }
        const observer = new PerformanceObserver((entryList) => {
          const entries = entryList.getEntries();
          if (entries.length === 0)
            return;
          const lcpElement = entries[entries.length - 1];
          const imgSrc = lcpElement.element?.src ?? "";
          if (imgSrc.startsWith("data:") || imgSrc.startsWith("blob:"))
            return;
          this.lcpImageUrl = imgSrc;
        });
        observer.observe({ type: "largest-contentful-paint", buffered: true });
        return observer;
      }
      scanImages() {
        const images = getDocument().querySelectorAll("img");
        let lcpElementFound, lcpElementLoadedCorrectly = false;
        for (let index = 0; index < images.length; index++) {
          const image = images[index];
          if (!image) {
            continue;
          }
          if (!this.options?.disableImageSizeWarning) {
            if (!image.getAttribute("ng-img") && this.isOversized(image)) {
              logOversizedImageWarning(image.src);
            }
          }
          if (!this.options?.disableImageLazyLoadWarning && this.lcpImageUrl) {
            if (image.src === this.lcpImageUrl) {
              lcpElementFound = true;
              if (image.loading !== "lazy" || image.getAttribute("ng-img")) {
                lcpElementLoadedCorrectly = true;
              }
            }
          }
        }
        if (lcpElementFound && !lcpElementLoadedCorrectly && this.lcpImageUrl && !this.options?.disableImageLazyLoadWarning) {
          logLazyLCPWarning(this.lcpImageUrl);
        }
      }
      isOversized(image) {
        if (!this.window) {
          return false;
        }
        const nonOversizedImageExtentions = [
          // SVG images are vector-based, which means they can scale
          // to any size without losing quality.
          ".svg"
        ];
        const imageSource = (image.src || "").toLowerCase();
        if (nonOversizedImageExtentions.some((extension) => imageSource.endsWith(extension))) {
          return false;
        }
        const computedStyle = this.window.getComputedStyle(image);
        let renderedWidth = parseFloat(computedStyle.getPropertyValue("width"));
        let renderedHeight = parseFloat(computedStyle.getPropertyValue("height"));
        const boxSizing = computedStyle.getPropertyValue("box-sizing");
        const objectFit = computedStyle.getPropertyValue("object-fit");
        if (objectFit === `cover`) {
          return false;
        }
        if (boxSizing === "border-box") {
          const paddingTop = computedStyle.getPropertyValue("padding-top");
          const paddingRight = computedStyle.getPropertyValue("padding-right");
          const paddingBottom = computedStyle.getPropertyValue("padding-bottom");
          const paddingLeft = computedStyle.getPropertyValue("padding-left");
          renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);
          renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);
        }
        const intrinsicWidth = image.naturalWidth;
        const intrinsicHeight = image.naturalHeight;
        const recommendedWidth = this.window.devicePixelRatio * renderedWidth;
        const recommendedHeight = this.window.devicePixelRatio * renderedHeight;
        const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE;
        const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE;
        return oversizedWidth || oversizedHeight;
      }
      static \u0275fac = function ImagePerformanceWarning_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ImagePerformanceWarning)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ImagePerformanceWarning, factory: _ImagePerformanceWarning.\u0275fac, providedIn: "root" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ImagePerformanceWarning, [{
        type: Injectable,
        args: [{ providedIn: "root" }]
      }], null, null);
    })();
    PLATFORM_DESTROY_LISTENERS = new InjectionToken(ngDevMode ? "PlatformDestroyListeners" : "");
    ENABLE_ROOT_COMPONENT_BOOTSTRAP = new InjectionToken(ngDevMode ? "ENABLE_ROOT_COMPONENT_BOOTSTRAP" : "");
    PlatformRef = class _PlatformRef {
      _injector;
      _modules = [];
      _destroyListeners = [];
      _destroyed = false;
      /** @internal */
      constructor(_injector) {
        this._injector = _injector;
      }
      /**
       * Creates an instance of an `@NgModule` for the given platform.
       *
       * @deprecated Passing NgModule factories as the `PlatformRef.bootstrapModuleFactory` function
       *     argument is deprecated. Use the `PlatformRef.bootstrapModule` API instead.
       */
      bootstrapModuleFactory(moduleFactory, options) {
        const scheduleInRootZone = options?.scheduleInRootZone;
        const ngZoneFactory = () => getNgZone(options?.ngZone, __spreadProps(__spreadValues({}, getNgZoneOptions({
          eventCoalescing: options?.ngZoneEventCoalescing,
          runCoalescing: options?.ngZoneRunCoalescing
        })), {
          scheduleInRootZone
        }));
        const ignoreChangesOutsideZone = options?.ignoreChangesOutsideZone;
        const allAppProviders = [
          internalProvideZoneChangeDetection({
            ngZoneFactory,
            ignoreChangesOutsideZone
          }),
          { provide: ChangeDetectionScheduler, useExisting: ChangeDetectionSchedulerImpl },
          errorHandlerEnvironmentInitializer
        ];
        const moduleRef = createNgModuleRefWithProviders(moduleFactory.moduleType, this.injector, allAppProviders);
        setModuleBootstrapImpl();
        return bootstrap({
          moduleRef,
          allPlatformModules: this._modules,
          platformInjector: this.injector
        });
      }
      /**
       * Creates an instance of an `@NgModule` for a given platform.
       *
       * @usageNotes
       * ### Simple Example
       *
       * ```ts
       * @NgModule({
       *   imports: [BrowserModule]
       * })
       * class MyModule {}
       *
       * let moduleRef = platformBrowser().bootstrapModule(MyModule);
       * ```
       *
       */
      bootstrapModule(moduleType, compilerOptions = []) {
        const options = optionsReducer({}, compilerOptions);
        setModuleBootstrapImpl();
        return compileNgModuleFactory(this.injector, options, moduleType).then((moduleFactory) => this.bootstrapModuleFactory(moduleFactory, options));
      }
      /**
       * Registers a listener to be called when the platform is destroyed.
       */
      onDestroy(callback) {
        this._destroyListeners.push(callback);
      }
      /**
       * Retrieves the platform {@link Injector}, which is the parent injector for
       * every Angular application on the page and provides singleton providers.
       */
      get injector() {
        return this._injector;
      }
      /**
       * Destroys the current Angular platform and all Angular applications on the page.
       * Destroys all modules and listeners registered with the platform.
       */
      destroy() {
        if (this._destroyed) {
          throw new RuntimeError(404, ngDevMode && "The platform has already been destroyed!");
        }
        this._modules.slice().forEach((module2) => module2.destroy());
        this._destroyListeners.forEach((listener) => listener());
        const destroyListeners = this._injector.get(PLATFORM_DESTROY_LISTENERS, null);
        if (destroyListeners) {
          destroyListeners.forEach((listener) => listener());
          destroyListeners.clear();
        }
        this._destroyed = true;
      }
      /**
       * Indicates whether this instance was destroyed.
       */
      get destroyed() {
        return this._destroyed;
      }
      static \u0275fac = function PlatformRef_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _PlatformRef)(\u0275\u0275inject(Injector));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _PlatformRef, factory: _PlatformRef.\u0275fac, providedIn: "platform" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformRef, [{
        type: Injectable,
        args: [{ providedIn: "platform" }]
      }], () => [{ type: Injector }], null);
    })();
    _platformInjector = null;
    ALLOW_MULTIPLE_PLATFORMS = new InjectionToken(ngDevMode ? "AllowMultipleToken" : "");
    ChangeDetectorRef = class {
      /**
       * @internal
       * @nocollapse
       */
      static __NG_ELEMENT_ID__ = injectChangeDetectorRef;
    };
    DefaultIterableDifferFactory = class {
      constructor() {
      }
      supports(obj) {
        return isListLikeIterable(obj);
      }
      create(trackByFn) {
        return new DefaultIterableDiffer(trackByFn);
      }
    };
    trackByIdentity = (index, item) => item;
    DefaultIterableDiffer = class {
      length = 0;
      // TODO: confirm the usage of `collection` as it's unused, readonly and on a non public API.
      collection;
      // Keeps track of the used records at any point in time (during & across `_check()` calls)
      _linkedRecords = null;
      // Keeps track of the removed records at any point in time during `_check()` calls.
      _unlinkedRecords = null;
      _previousItHead = null;
      _itHead = null;
      _itTail = null;
      _additionsHead = null;
      _additionsTail = null;
      _movesHead = null;
      _movesTail = null;
      _removalsHead = null;
      _removalsTail = null;
      // Keeps track of records where custom track by is the same, but item identity has changed
      _identityChangesHead = null;
      _identityChangesTail = null;
      _trackByFn;
      constructor(trackByFn) {
        this._trackByFn = trackByFn || trackByIdentity;
      }
      forEachItem(fn) {
        let record;
        for (record = this._itHead; record !== null; record = record._next) {
          fn(record);
        }
      }
      forEachOperation(fn) {
        let nextIt = this._itHead;
        let nextRemove = this._removalsHead;
        let addRemoveOffset = 0;
        let moveOffsets = null;
        while (nextIt || nextRemove) {
          const record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove;
          const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
          const currentIndex = record.currentIndex;
          if (record === nextRemove) {
            addRemoveOffset--;
            nextRemove = nextRemove._nextRemoved;
          } else {
            nextIt = nextIt._next;
            if (record.previousIndex == null) {
              addRemoveOffset++;
            } else {
              if (!moveOffsets)
                moveOffsets = [];
              const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
              const localCurrentIndex = currentIndex - addRemoveOffset;
              if (localMovePreviousIndex != localCurrentIndex) {
                for (let i2 = 0; i2 < localMovePreviousIndex; i2++) {
                  const offset = i2 < moveOffsets.length ? moveOffsets[i2] : moveOffsets[i2] = 0;
                  const index = offset + i2;
                  if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                    moveOffsets[i2] = offset + 1;
                  }
                }
                const previousIndex = record.previousIndex;
                moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
              }
            }
          }
          if (adjPreviousIndex !== currentIndex) {
            fn(record, adjPreviousIndex, currentIndex);
          }
        }
      }
      forEachPreviousItem(fn) {
        let record;
        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
          fn(record);
        }
      }
      forEachAddedItem(fn) {
        let record;
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
          fn(record);
        }
      }
      forEachMovedItem(fn) {
        let record;
        for (record = this._movesHead; record !== null; record = record._nextMoved) {
          fn(record);
        }
      }
      forEachRemovedItem(fn) {
        let record;
        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
          fn(record);
        }
      }
      forEachIdentityChange(fn) {
        let record;
        for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
          fn(record);
        }
      }
      diff(collection) {
        if (collection == null)
          collection = [];
        if (!isListLikeIterable(collection)) {
          throw new RuntimeError(900, ngDevMode && `Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`);
        }
        if (this.check(collection)) {
          return this;
        } else {
          return null;
        }
      }
      onDestroy() {
      }
      check(collection) {
        this._reset();
        let record = this._itHead;
        let mayBeDirty = false;
        let index;
        let item;
        let itemTrackBy;
        if (Array.isArray(collection)) {
          this.length = collection.length;
          for (let index2 = 0; index2 < this.length; index2++) {
            item = collection[index2];
            itemTrackBy = this._trackByFn(index2, item);
            if (record === null || !Object.is(record.trackById, itemTrackBy)) {
              record = this._mismatch(record, item, itemTrackBy, index2);
              mayBeDirty = true;
            } else {
              if (mayBeDirty) {
                record = this._verifyReinsertion(record, item, itemTrackBy, index2);
              }
              if (!Object.is(record.item, item))
                this._addIdentityChange(record, item);
            }
            record = record._next;
          }
        } else {
          index = 0;
          iterateListLike(collection, (item2) => {
            itemTrackBy = this._trackByFn(index, item2);
            if (record === null || !Object.is(record.trackById, itemTrackBy)) {
              record = this._mismatch(record, item2, itemTrackBy, index);
              mayBeDirty = true;
            } else {
              if (mayBeDirty) {
                record = this._verifyReinsertion(record, item2, itemTrackBy, index);
              }
              if (!Object.is(record.item, item2))
                this._addIdentityChange(record, item2);
            }
            record = record._next;
            index++;
          });
          this.length = index;
        }
        this._truncate(record);
        this.collection = collection;
        return this.isDirty;
      }
      /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity
       * changes.
       */
      get isDirty() {
        return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
      }
      /**
       * Reset the state of the change objects to show no changes. This means set previousKey to
       * currentKey, and clear all of the queues (additions, moves, removals).
       * Set the previousIndexes of moved and added items to their currentIndexes
       * Reset the list of additions, moves and removals
       *
       * @internal
       */
      _reset() {
        if (this.isDirty) {
          let record;
          for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
            record._nextPrevious = record._next;
          }
          for (record = this._additionsHead; record !== null; record = record._nextAdded) {
            record.previousIndex = record.currentIndex;
          }
          this._additionsHead = this._additionsTail = null;
          for (record = this._movesHead; record !== null; record = record._nextMoved) {
            record.previousIndex = record.currentIndex;
          }
          this._movesHead = this._movesTail = null;
          this._removalsHead = this._removalsTail = null;
          this._identityChangesHead = this._identityChangesTail = null;
        }
      }
      /**
       * This is the core function which handles differences between collections.
       *
       * - `record` is the record which we saw at this position last time. If null then it is a new
       *   item.
       * - `item` is the current item in the collection
       * - `index` is the position of the item in the collection
       *
       * @internal
       */
      _mismatch(record, item, itemTrackBy, index) {
        let previousRecord;
        if (record === null) {
          previousRecord = this._itTail;
        } else {
          previousRecord = record._prev;
          this._remove(record);
        }
        record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
        if (record !== null) {
          if (!Object.is(record.item, item))
            this._addIdentityChange(record, item);
          this._reinsertAfter(record, previousRecord, index);
        } else {
          record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
          if (record !== null) {
            if (!Object.is(record.item, item))
              this._addIdentityChange(record, item);
            this._moveAfter(record, previousRecord, index);
          } else {
            record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
          }
        }
        return record;
      }
      /**
       * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
       *
       * Use case: `[a, a]` => `[b, a, a]`
       *
       * If we did not have this check then the insertion of `b` would:
       *   1) evict first `a`
       *   2) insert `b` at `0` index.
       *   3) leave `a` at index `1` as is. <-- this is wrong!
       *   3) reinsert `a` at index 2. <-- this is wrong!
       *
       * The correct behavior is:
       *   1) evict first `a`
       *   2) insert `b` at `0` index.
       *   3) reinsert `a` at index 1.
       *   3) move `a` at from `1` to `2`.
       *
       *
       * Double check that we have not evicted a duplicate item. We need to check if the item type may
       * have already been removed:
       * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
       * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
       * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
       * at the end.
       *
       * @internal
       */
      _verifyReinsertion(record, item, itemTrackBy, index) {
        let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
        if (reinsertRecord !== null) {
          record = this._reinsertAfter(reinsertRecord, record._prev, index);
        } else if (record.currentIndex != index) {
          record.currentIndex = index;
          this._addToMoves(record, index);
        }
        return record;
      }
      /**
       * Get rid of any excess {@link IterableChangeRecord_}s from the previous collection
       *
       * - `record` The first excess {@link IterableChangeRecord_}.
       *
       * @internal
       */
      _truncate(record) {
        while (record !== null) {
          const nextRecord = record._next;
          this._addToRemovals(this._unlink(record));
          record = nextRecord;
        }
        if (this._unlinkedRecords !== null) {
          this._unlinkedRecords.clear();
        }
        if (this._additionsTail !== null) {
          this._additionsTail._nextAdded = null;
        }
        if (this._movesTail !== null) {
          this._movesTail._nextMoved = null;
        }
        if (this._itTail !== null) {
          this._itTail._next = null;
        }
        if (this._removalsTail !== null) {
          this._removalsTail._nextRemoved = null;
        }
        if (this._identityChangesTail !== null) {
          this._identityChangesTail._nextIdentityChange = null;
        }
      }
      /** @internal */
      _reinsertAfter(record, prevRecord, index) {
        if (this._unlinkedRecords !== null) {
          this._unlinkedRecords.remove(record);
        }
        const prev = record._prevRemoved;
        const next = record._nextRemoved;
        if (prev === null) {
          this._removalsHead = next;
        } else {
          prev._nextRemoved = next;
        }
        if (next === null) {
          this._removalsTail = prev;
        } else {
          next._prevRemoved = prev;
        }
        this._insertAfter(record, prevRecord, index);
        this._addToMoves(record, index);
        return record;
      }
      /** @internal */
      _moveAfter(record, prevRecord, index) {
        this._unlink(record);
        this._insertAfter(record, prevRecord, index);
        this._addToMoves(record, index);
        return record;
      }
      /** @internal */
      _addAfter(record, prevRecord, index) {
        this._insertAfter(record, prevRecord, index);
        if (this._additionsTail === null) {
          this._additionsTail = this._additionsHead = record;
        } else {
          this._additionsTail = this._additionsTail._nextAdded = record;
        }
        return record;
      }
      /** @internal */
      _insertAfter(record, prevRecord, index) {
        const next = prevRecord === null ? this._itHead : prevRecord._next;
        record._next = next;
        record._prev = prevRecord;
        if (next === null) {
          this._itTail = record;
        } else {
          next._prev = record;
        }
        if (prevRecord === null) {
          this._itHead = record;
        } else {
          prevRecord._next = record;
        }
        if (this._linkedRecords === null) {
          this._linkedRecords = new _DuplicateMap();
        }
        this._linkedRecords.put(record);
        record.currentIndex = index;
        return record;
      }
      /** @internal */
      _remove(record) {
        return this._addToRemovals(this._unlink(record));
      }
      /** @internal */
      _unlink(record) {
        if (this._linkedRecords !== null) {
          this._linkedRecords.remove(record);
        }
        const prev = record._prev;
        const next = record._next;
        if (prev === null) {
          this._itHead = next;
        } else {
          prev._next = next;
        }
        if (next === null) {
          this._itTail = prev;
        } else {
          next._prev = prev;
        }
        return record;
      }
      /** @internal */
      _addToMoves(record, toIndex) {
        if (record.previousIndex === toIndex) {
          return record;
        }
        if (this._movesTail === null) {
          this._movesTail = this._movesHead = record;
        } else {
          this._movesTail = this._movesTail._nextMoved = record;
        }
        return record;
      }
      _addToRemovals(record) {
        if (this._unlinkedRecords === null) {
          this._unlinkedRecords = new _DuplicateMap();
        }
        this._unlinkedRecords.put(record);
        record.currentIndex = null;
        record._nextRemoved = null;
        if (this._removalsTail === null) {
          this._removalsTail = this._removalsHead = record;
          record._prevRemoved = null;
        } else {
          record._prevRemoved = this._removalsTail;
          this._removalsTail = this._removalsTail._nextRemoved = record;
        }
        return record;
      }
      /** @internal */
      _addIdentityChange(record, item) {
        record.item = item;
        if (this._identityChangesTail === null) {
          this._identityChangesTail = this._identityChangesHead = record;
        } else {
          this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
        }
        return record;
      }
    };
    IterableChangeRecord_ = class {
      item;
      trackById;
      currentIndex = null;
      previousIndex = null;
      /** @internal */
      _nextPrevious = null;
      /** @internal */
      _prev = null;
      /** @internal */
      _next = null;
      /** @internal */
      _prevDup = null;
      /** @internal */
      _nextDup = null;
      /** @internal */
      _prevRemoved = null;
      /** @internal */
      _nextRemoved = null;
      /** @internal */
      _nextAdded = null;
      /** @internal */
      _nextMoved = null;
      /** @internal */
      _nextIdentityChange = null;
      constructor(item, trackById) {
        this.item = item;
        this.trackById = trackById;
      }
    };
    _DuplicateItemRecordList = class {
      /** @internal */
      _head = null;
      /** @internal */
      _tail = null;
      /**
       * Append the record to the list of duplicates.
       *
       * Note: by design all records in the list of duplicates hold the same value in record.item.
       */
      add(record) {
        if (this._head === null) {
          this._head = this._tail = record;
          record._nextDup = null;
          record._prevDup = null;
        } else {
          this._tail._nextDup = record;
          record._prevDup = this._tail;
          record._nextDup = null;
          this._tail = record;
        }
      }
      // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and
      // IterableChangeRecord_.currentIndex >= atOrAfterIndex
      get(trackById, atOrAfterIndex) {
        let record;
        for (record = this._head; record !== null; record = record._nextDup) {
          if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) && Object.is(record.trackById, trackById)) {
            return record;
          }
        }
        return null;
      }
      /**
       * Remove one {@link IterableChangeRecord_} from the list of duplicates.
       *
       * Returns whether the list of duplicates is empty.
       */
      remove(record) {
        const prev = record._prevDup;
        const next = record._nextDup;
        if (prev === null) {
          this._head = next;
        } else {
          prev._nextDup = next;
        }
        if (next === null) {
          this._tail = prev;
        } else {
          next._prevDup = prev;
        }
        return this._head === null;
      }
    };
    _DuplicateMap = class {
      map = /* @__PURE__ */ new Map();
      put(record) {
        const key = record.trackById;
        let duplicates = this.map.get(key);
        if (!duplicates) {
          duplicates = new _DuplicateItemRecordList();
          this.map.set(key, duplicates);
        }
        duplicates.add(record);
      }
      /**
       * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we
       * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.
       *
       * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
       * have any more `a`s needs to return the second `a`.
       */
      get(trackById, atOrAfterIndex) {
        const key = trackById;
        const recordList = this.map.get(key);
        return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
      }
      /**
       * Removes a {@link IterableChangeRecord_} from the list of duplicates.
       *
       * The list of duplicates also is removed from the map if it gets empty.
       */
      remove(record) {
        const key = record.trackById;
        const recordList = this.map.get(key);
        if (recordList.remove(record)) {
          this.map.delete(key);
        }
        return record;
      }
      get isEmpty() {
        return this.map.size === 0;
      }
      clear() {
        this.map.clear();
      }
    };
    DefaultKeyValueDifferFactory = class {
      constructor() {
      }
      supports(obj) {
        return obj instanceof Map || isJsObject(obj);
      }
      create() {
        return new DefaultKeyValueDiffer();
      }
    };
    DefaultKeyValueDiffer = class {
      _records = /* @__PURE__ */ new Map();
      _mapHead = null;
      // _appendAfter is used in the check loop
      _appendAfter = null;
      _previousMapHead = null;
      _changesHead = null;
      _changesTail = null;
      _additionsHead = null;
      _additionsTail = null;
      _removalsHead = null;
      _removalsTail = null;
      get isDirty() {
        return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
      }
      forEachItem(fn) {
        let record;
        for (record = this._mapHead; record !== null; record = record._next) {
          fn(record);
        }
      }
      forEachPreviousItem(fn) {
        let record;
        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
          fn(record);
        }
      }
      forEachChangedItem(fn) {
        let record;
        for (record = this._changesHead; record !== null; record = record._nextChanged) {
          fn(record);
        }
      }
      forEachAddedItem(fn) {
        let record;
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
          fn(record);
        }
      }
      forEachRemovedItem(fn) {
        let record;
        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
          fn(record);
        }
      }
      diff(map2) {
        if (!map2) {
          map2 = /* @__PURE__ */ new Map();
        } else if (!(map2 instanceof Map || isJsObject(map2))) {
          throw new RuntimeError(900, ngDevMode && `Error trying to diff '${stringify(map2)}'. Only maps and objects are allowed`);
        }
        return this.check(map2) ? this : null;
      }
      onDestroy() {
      }
      /**
       * Check the current state of the map vs the previous.
       * The algorithm is optimised for when the keys do no change.
       */
      check(map2) {
        this._reset();
        let insertBefore = this._mapHead;
        this._appendAfter = null;
        this._forEach(map2, (value, key) => {
          if (insertBefore && insertBefore.key === key) {
            this._maybeAddToChanges(insertBefore, value);
            this._appendAfter = insertBefore;
            insertBefore = insertBefore._next;
          } else {
            const record = this._getOrCreateRecordForKey(key, value);
            insertBefore = this._insertBeforeOrAppend(insertBefore, record);
          }
        });
        if (insertBefore) {
          if (insertBefore._prev) {
            insertBefore._prev._next = null;
          }
          this._removalsHead = insertBefore;
          for (let record = insertBefore; record !== null; record = record._nextRemoved) {
            if (record === this._mapHead) {
              this._mapHead = null;
            }
            this._records.delete(record.key);
            record._nextRemoved = record._next;
            record.previousValue = record.currentValue;
            record.currentValue = null;
            record._prev = null;
            record._next = null;
          }
        }
        if (this._changesTail)
          this._changesTail._nextChanged = null;
        if (this._additionsTail)
          this._additionsTail._nextAdded = null;
        return this.isDirty;
      }
      /**
       * Inserts a record before `before` or append at the end of the list when `before` is null.
       *
       * Notes:
       * - This method appends at `this._appendAfter`,
       * - This method updates `this._appendAfter`,
       * - The return value is the new value for the insertion pointer.
       */
      _insertBeforeOrAppend(before, record) {
        if (before) {
          const prev = before._prev;
          record._next = before;
          record._prev = prev;
          before._prev = record;
          if (prev) {
            prev._next = record;
          }
          if (before === this._mapHead) {
            this._mapHead = record;
          }
          this._appendAfter = before;
          return before;
        }
        if (this._appendAfter) {
          this._appendAfter._next = record;
          record._prev = this._appendAfter;
        } else {
          this._mapHead = record;
        }
        this._appendAfter = record;
        return null;
      }
      _getOrCreateRecordForKey(key, value) {
        if (this._records.has(key)) {
          const record2 = this._records.get(key);
          this._maybeAddToChanges(record2, value);
          const prev = record2._prev;
          const next = record2._next;
          if (prev) {
            prev._next = next;
          }
          if (next) {
            next._prev = prev;
          }
          record2._next = null;
          record2._prev = null;
          return record2;
        }
        const record = new KeyValueChangeRecord_(key);
        this._records.set(key, record);
        record.currentValue = value;
        this._addToAdditions(record);
        return record;
      }
      /** @internal */
      _reset() {
        if (this.isDirty) {
          let record;
          this._previousMapHead = this._mapHead;
          for (record = this._previousMapHead; record !== null; record = record._next) {
            record._nextPrevious = record._next;
          }
          for (record = this._changesHead; record !== null; record = record._nextChanged) {
            record.previousValue = record.currentValue;
          }
          for (record = this._additionsHead; record != null; record = record._nextAdded) {
            record.previousValue = record.currentValue;
          }
          this._changesHead = this._changesTail = null;
          this._additionsHead = this._additionsTail = null;
          this._removalsHead = null;
        }
      }
      // Add the record or a given key to the list of changes only when the value has actually changed
      _maybeAddToChanges(record, newValue) {
        if (!Object.is(newValue, record.currentValue)) {
          record.previousValue = record.currentValue;
          record.currentValue = newValue;
          this._addToChanges(record);
        }
      }
      _addToAdditions(record) {
        if (this._additionsHead === null) {
          this._additionsHead = this._additionsTail = record;
        } else {
          this._additionsTail._nextAdded = record;
          this._additionsTail = record;
        }
      }
      _addToChanges(record) {
        if (this._changesHead === null) {
          this._changesHead = this._changesTail = record;
        } else {
          this._changesTail._nextChanged = record;
          this._changesTail = record;
        }
      }
      /** @internal */
      _forEach(obj, fn) {
        if (obj instanceof Map) {
          obj.forEach(fn);
        } else {
          Object.keys(obj).forEach((k2) => fn(obj[k2], k2));
        }
      }
    };
    KeyValueChangeRecord_ = class {
      key;
      previousValue = null;
      currentValue = null;
      /** @internal */
      _nextPrevious = null;
      /** @internal */
      _next = null;
      /** @internal */
      _prev = null;
      /** @internal */
      _nextAdded = null;
      /** @internal */
      _nextRemoved = null;
      /** @internal */
      _nextChanged = null;
      constructor(key) {
        this.key = key;
      }
    };
    IterableDiffers = class _IterableDiffers {
      factories;
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _IterableDiffers,
          providedIn: "root",
          factory: defaultIterableDiffersFactory
        })
      );
      constructor(factories) {
        this.factories = factories;
      }
      static create(factories, parent) {
        if (parent != null) {
          const copied = parent.factories.slice();
          factories = factories.concat(copied);
        }
        return new _IterableDiffers(factories);
      }
      /**
       * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
       * inherited {@link IterableDiffers} instance with the provided factories and return a new
       * {@link IterableDiffers} instance.
       *
       * @usageNotes
       * ### Example
       *
       * The following example shows how to extend an existing list of factories,
       * which will only be applied to the injector for this component and its children.
       * This step is all that's required to make a new {@link IterableDiffer} available.
       *
       * ```ts
       * @Component({
       *   viewProviders: [
       *     IterableDiffers.extend([new ImmutableListDiffer()])
       *   ]
       * })
       * ```
       */
      static extend(factories) {
        return {
          provide: _IterableDiffers,
          useFactory: (parent) => {
            return _IterableDiffers.create(factories, parent || defaultIterableDiffersFactory());
          },
          // Dependency technically isn't optional, but we can provide a better error message this way.
          deps: [[_IterableDiffers, new SkipSelf(), new Optional()]]
        };
      }
      find(iterable) {
        const factory = this.factories.find((f2) => f2.supports(iterable));
        if (factory != null) {
          return factory;
        } else {
          throw new RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${iterable}' of type '${getTypeNameForDebugging(iterable)}'`);
        }
      }
    };
    KeyValueDiffers = class _KeyValueDiffers {
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _KeyValueDiffers,
          providedIn: "root",
          factory: defaultKeyValueDiffersFactory
        })
      );
      factories;
      constructor(factories) {
        this.factories = factories;
      }
      static create(factories, parent) {
        if (parent) {
          const copied = parent.factories.slice();
          factories = factories.concat(copied);
        }
        return new _KeyValueDiffers(factories);
      }
      /**
       * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
       * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
       * {@link KeyValueDiffers} instance.
       *
       * @usageNotes
       * ### Example
       *
       * The following example shows how to extend an existing list of factories,
       * which will only be applied to the injector for this component and its children.
       * This step is all that's required to make a new {@link KeyValueDiffer} available.
       *
       * ```ts
       * @Component({
       *   viewProviders: [
       *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
       *   ]
       * })
       * ```
       */
      static extend(factories) {
        return {
          provide: _KeyValueDiffers,
          useFactory: (parent) => {
            return _KeyValueDiffers.create(factories, parent || defaultKeyValueDiffersFactory());
          },
          // Dependency technically isn't optional, but we can provide a better error message this way.
          deps: [[_KeyValueDiffers, new SkipSelf(), new Optional()]]
        };
      }
      find(kv) {
        const factory = this.factories.find((f2) => f2.supports(kv));
        if (factory) {
          return factory;
        }
        throw new RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${kv}'`);
      }
    };
    keyValDiff = [new DefaultKeyValueDifferFactory()];
    iterableDiff = [new DefaultIterableDifferFactory()];
    defaultIterableDiffers = new IterableDiffers(iterableDiff);
    defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
    platformCore = createPlatformFactory(null, "core", []);
    ApplicationModule = class _ApplicationModule {
      // Inject ApplicationRef to make it eager...
      constructor(appRef) {
      }
      static \u0275fac = function ApplicationModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ApplicationModule)(\u0275\u0275inject(ApplicationRef));
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _ApplicationModule });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationModule, [{
        type: NgModule
      }], () => [{ type: ApplicationRef }], null);
    })();
    REQUEST = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "REQUEST" : "", {
      providedIn: "platform",
      factory: () => null
    });
    RESPONSE_INIT = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "RESPONSE_INIT" : "", {
      providedIn: "platform",
      factory: () => null
    });
    REQUEST_CONTEXT = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "REQUEST_CONTEXT" : "", {
      providedIn: "platform",
      factory: () => null
    });
  }
});

// node_modules/@angular/common/fesm2022/location.mjs
function getDOM() {
  return _DOM;
}
function setRootDomAdapter(adapter) {
  _DOM ??= adapter;
}
function joinWithSlash(start, end) {
  if (!start) return end;
  if (!end) return start;
  if (start.endsWith("/")) {
    return end.startsWith("/") ? start + end.slice(1) : start + end;
  }
  return end.startsWith("/") ? start + end : `${start}/${end}`;
}
function stripTrailingSlash(url) {
  const pathEndIdx = url.search(/#|\?|$/);
  return url[pathEndIdx - 1] === "/" ? url.slice(0, pathEndIdx - 1) + url.slice(pathEndIdx) : url;
}
function normalizeQueryParams(params) {
  return params && params[0] !== "?" ? `?${params}` : params;
}
function createLocation() {
  return new Location(\u0275\u0275inject(LocationStrategy));
}
function _stripBasePath(basePath, url) {
  if (!basePath || !url.startsWith(basePath)) {
    return url;
  }
  const strippedUrl = url.substring(basePath.length);
  if (strippedUrl === "" || ["/", ";", "?", "#"].includes(strippedUrl[0])) {
    return strippedUrl;
  }
  return url;
}
function _stripIndexHtml(url) {
  return url.replace(/\/index.html$/, "");
}
function _stripOrigin(baseHref) {
  const isAbsoluteUrl2 = new RegExp("^(https?:)?//").test(baseHref);
  if (isAbsoluteUrl2) {
    const [, pathname] = baseHref.split(/\/\/[^\/]+/);
    return pathname;
  }
  return baseHref;
}
var _DOM, DomAdapter, PlatformLocation, LOCATION_INITIALIZED, BrowserPlatformLocation, LocationStrategy, APP_BASE_HREF, PathLocationStrategy, Location;
var init_location = __esm({
  "node_modules/@angular/common/fesm2022/location.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_esm();
    _DOM = null;
    DomAdapter = class {
    };
    PlatformLocation = class _PlatformLocation {
      historyGo(relativePosition) {
        throw new Error(ngDevMode ? "Not implemented" : "");
      }
      static \u0275fac = function PlatformLocation_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _PlatformLocation)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _PlatformLocation,
        factory: () => (() => inject2(BrowserPlatformLocation))(),
        providedIn: "platform"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformLocation, [{
        type: Injectable,
        args: [{
          providedIn: "platform",
          useFactory: () => inject2(BrowserPlatformLocation)
        }]
      }], null, null);
    })();
    LOCATION_INITIALIZED = new InjectionToken(ngDevMode ? "Location Initialized" : "");
    BrowserPlatformLocation = class _BrowserPlatformLocation extends PlatformLocation {
      _location;
      _history;
      _doc = inject2(DOCUMENT);
      constructor() {
        super();
        this._location = window.location;
        this._history = window.history;
      }
      getBaseHrefFromDOM() {
        return getDOM().getBaseHref(this._doc);
      }
      onPopState(fn) {
        const window2 = getDOM().getGlobalEventTarget(this._doc, "window");
        window2.addEventListener("popstate", fn, false);
        return () => window2.removeEventListener("popstate", fn);
      }
      onHashChange(fn) {
        const window2 = getDOM().getGlobalEventTarget(this._doc, "window");
        window2.addEventListener("hashchange", fn, false);
        return () => window2.removeEventListener("hashchange", fn);
      }
      get href() {
        return this._location.href;
      }
      get protocol() {
        return this._location.protocol;
      }
      get hostname() {
        return this._location.hostname;
      }
      get port() {
        return this._location.port;
      }
      get pathname() {
        return this._location.pathname;
      }
      get search() {
        return this._location.search;
      }
      get hash() {
        return this._location.hash;
      }
      set pathname(newPath) {
        this._location.pathname = newPath;
      }
      pushState(state, title, url) {
        this._history.pushState(state, title, url);
      }
      replaceState(state, title, url) {
        this._history.replaceState(state, title, url);
      }
      forward() {
        this._history.forward();
      }
      back() {
        this._history.back();
      }
      historyGo(relativePosition = 0) {
        this._history.go(relativePosition);
      }
      getState() {
        return this._history.state;
      }
      static \u0275fac = function BrowserPlatformLocation_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _BrowserPlatformLocation)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _BrowserPlatformLocation,
        factory: () => (() => new _BrowserPlatformLocation())(),
        providedIn: "platform"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserPlatformLocation, [{
        type: Injectable,
        args: [{
          providedIn: "platform",
          useFactory: () => new BrowserPlatformLocation()
        }]
      }], () => [], null);
    })();
    LocationStrategy = class _LocationStrategy {
      historyGo(relativePosition) {
        throw new Error(ngDevMode ? "Not implemented" : "");
      }
      static \u0275fac = function LocationStrategy_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _LocationStrategy)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _LocationStrategy,
        factory: () => (() => inject2(PathLocationStrategy))(),
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocationStrategy, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: () => inject2(PathLocationStrategy)
        }]
      }], null, null);
    })();
    APP_BASE_HREF = new InjectionToken(ngDevMode ? "appBaseHref" : "");
    PathLocationStrategy = class _PathLocationStrategy extends LocationStrategy {
      _platformLocation;
      _baseHref;
      _removeListenerFns = [];
      constructor(_platformLocation, href) {
        super();
        this._platformLocation = _platformLocation;
        this._baseHref = href ?? this._platformLocation.getBaseHrefFromDOM() ?? inject2(DOCUMENT).location?.origin ?? "";
      }
      /** @docs-private */
      ngOnDestroy() {
        while (this._removeListenerFns.length) {
          this._removeListenerFns.pop()();
        }
      }
      onPopState(fn) {
        this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));
      }
      getBaseHref() {
        return this._baseHref;
      }
      prepareExternalUrl(internal) {
        return joinWithSlash(this._baseHref, internal);
      }
      path(includeHash = false) {
        const pathname = this._platformLocation.pathname + normalizeQueryParams(this._platformLocation.search);
        const hash = this._platformLocation.hash;
        return hash && includeHash ? `${pathname}${hash}` : pathname;
      }
      pushState(state, title, url, queryParams) {
        const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
        this._platformLocation.pushState(state, title, externalUrl);
      }
      replaceState(state, title, url, queryParams) {
        const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
        this._platformLocation.replaceState(state, title, externalUrl);
      }
      forward() {
        this._platformLocation.forward();
      }
      back() {
        this._platformLocation.back();
      }
      getState() {
        return this._platformLocation.getState();
      }
      historyGo(relativePosition = 0) {
        this._platformLocation.historyGo?.(relativePosition);
      }
      static \u0275fac = function PathLocationStrategy_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _PathLocationStrategy)(\u0275\u0275inject(PlatformLocation), \u0275\u0275inject(APP_BASE_HREF, 8));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _PathLocationStrategy,
        factory: _PathLocationStrategy.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PathLocationStrategy, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [{
        type: PlatformLocation
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [APP_BASE_HREF]
        }]
      }], null);
    })();
    Location = class _Location {
      /** @internal */
      _subject = new Subject();
      /** @internal */
      _basePath;
      /** @internal */
      _locationStrategy;
      /** @internal */
      _urlChangeListeners = [];
      /** @internal */
      _urlChangeSubscription = null;
      constructor(locationStrategy) {
        this._locationStrategy = locationStrategy;
        const baseHref = this._locationStrategy.getBaseHref();
        this._basePath = _stripOrigin(stripTrailingSlash(_stripIndexHtml(baseHref)));
        this._locationStrategy.onPopState((ev) => {
          this._subject.next({
            "url": this.path(true),
            "pop": true,
            "state": ev.state,
            "type": ev.type
          });
        });
      }
      /** @docs-private */
      ngOnDestroy() {
        this._urlChangeSubscription?.unsubscribe();
        this._urlChangeListeners = [];
      }
      /**
       * Normalizes the URL path for this location.
       *
       * @param includeHash True to include an anchor fragment in the path.
       *
       * @returns The normalized URL path.
       */
      // TODO: vsavkin. Remove the boolean flag and always include hash once the deprecated router is
      // removed.
      path(includeHash = false) {
        return this.normalize(this._locationStrategy.path(includeHash));
      }
      /**
       * Reports the current state of the location history.
       * @returns The current value of the `history.state` object.
       */
      getState() {
        return this._locationStrategy.getState();
      }
      /**
       * Normalizes the given path and compares to the current normalized path.
       *
       * @param path The given URL path.
       * @param query Query parameters.
       *
       * @returns True if the given URL path is equal to the current normalized path, false
       * otherwise.
       */
      isCurrentPathEqualTo(path, query = "") {
        return this.path() == this.normalize(path + normalizeQueryParams(query));
      }
      /**
       * Normalizes a URL path by stripping any trailing slashes.
       *
       * @param url String representing a URL.
       *
       * @returns The normalized URL string.
       */
      normalize(url) {
        return _Location.stripTrailingSlash(_stripBasePath(this._basePath, _stripIndexHtml(url)));
      }
      /**
       * Normalizes an external URL path.
       * If the given URL doesn't begin with a leading slash (`'/'`), adds one
       * before normalizing. Adds a hash if `HashLocationStrategy` is
       * in use, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.
       *
       * @param url String representing a URL.
       *
       * @returns  A normalized platform-specific URL.
       */
      prepareExternalUrl(url) {
        if (url && url[0] !== "/") {
          url = "/" + url;
        }
        return this._locationStrategy.prepareExternalUrl(url);
      }
      // TODO: rename this method to pushState
      /**
       * Changes the browser's URL to a normalized version of a given URL, and pushes a
       * new item onto the platform's history.
       *
       * @param path  URL path to normalize.
       * @param query Query parameters.
       * @param state Location history state.
       *
       */
      go(path, query = "", state = null) {
        this._locationStrategy.pushState(state, "", path, query);
        this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
      }
      /**
       * Changes the browser's URL to a normalized version of the given URL, and replaces
       * the top item on the platform's history stack.
       *
       * @param path  URL path to normalize.
       * @param query Query parameters.
       * @param state Location history state.
       */
      replaceState(path, query = "", state = null) {
        this._locationStrategy.replaceState(state, "", path, query);
        this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
      }
      /**
       * Navigates forward in the platform's history.
       */
      forward() {
        this._locationStrategy.forward();
      }
      /**
       * Navigates back in the platform's history.
       */
      back() {
        this._locationStrategy.back();
      }
      /**
       * Navigate to a specific page from session history, identified by its relative position to the
       * current page.
       *
       * @param relativePosition  Position of the target page in the history relative to the current
       *     page.
       * A negative value moves backwards, a positive value moves forwards, e.g. `location.historyGo(2)`
       * moves forward two pages and `location.historyGo(-2)` moves back two pages. When we try to go
       * beyond what's stored in the history session, we stay in the current page. Same behaviour occurs
       * when `relativePosition` equals 0.
       * @see https://developer.mozilla.org/en-US/docs/Web/API/History_API#Moving_to_a_specific_point_in_history
       */
      historyGo(relativePosition = 0) {
        this._locationStrategy.historyGo?.(relativePosition);
      }
      /**
       * Registers a URL change listener. Use to catch updates performed by the Angular
       * framework that are not detectible through "popstate" or "hashchange" events.
       *
       * @param fn The change handler function, which take a URL and a location history state.
       * @returns A function that, when executed, unregisters a URL change listener.
       */
      onUrlChange(fn) {
        this._urlChangeListeners.push(fn);
        this._urlChangeSubscription ??= this.subscribe((v) => {
          this._notifyUrlChangeListeners(v.url, v.state);
        });
        return () => {
          const fnIndex = this._urlChangeListeners.indexOf(fn);
          this._urlChangeListeners.splice(fnIndex, 1);
          if (this._urlChangeListeners.length === 0) {
            this._urlChangeSubscription?.unsubscribe();
            this._urlChangeSubscription = null;
          }
        };
      }
      /** @internal */
      _notifyUrlChangeListeners(url = "", state) {
        this._urlChangeListeners.forEach((fn) => fn(url, state));
      }
      /**
       * Subscribes to the platform's `popState` events.
       *
       * Note: `Location.go()` does not trigger the `popState` event in the browser. Use
       * `Location.onUrlChange()` to subscribe to URL changes instead.
       *
       * @param value Event that is triggered when the state history changes.
       * @param exception The exception to throw.
       *
       * @see [onpopstate](https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate)
       *
       * @returns Subscribed events.
       */
      subscribe(onNext, onThrow, onReturn) {
        return this._subject.subscribe({
          next: onNext,
          error: onThrow ?? void 0,
          complete: onReturn ?? void 0
        });
      }
      /**
       * Normalizes URL parameters by prepending with `?` if needed.
       *
       * @param  params String of URL parameters.
       *
       * @returns The normalized URL parameters string.
       */
      static normalizeQueryParams = normalizeQueryParams;
      /**
       * Joins two parts of a URL with a slash if needed.
       *
       * @param start  URL string
       * @param end    URL string
       *
       *
       * @returns The joined URL string.
       */
      static joinWithSlash = joinWithSlash;
      /**
       * Removes a trailing slash from a URL string if needed.
       * Looks for the first occurrence of either `#`, `?`, or the end of the
       * line as `/` characters and removes the trailing slash if one exists.
       *
       * @param url URL string.
       *
       * @returns The URL string, modified if needed.
       */
      static stripTrailingSlash = stripTrailingSlash;
      static \u0275fac = function Location_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Location)(\u0275\u0275inject(LocationStrategy));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _Location,
        factory: () => createLocation(),
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Location, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          // See #23917
          useFactory: createLocation
        }]
      }], () => [{
        type: LocationStrategy
      }], null);
    })();
  }
});

// node_modules/@angular/common/fesm2022/common_module.mjs
function getLocaleId2(locale) {
  return findLocaleData(locale)[LocaleDataIndex.LocaleId];
}
function getLocaleDayPeriods(locale, formStyle, width) {
  const data = findLocaleData(locale);
  const amPmData = [data[LocaleDataIndex.DayPeriodsFormat], data[LocaleDataIndex.DayPeriodsStandalone]];
  const amPm = getLastDefinedValue(amPmData, formStyle);
  return getLastDefinedValue(amPm, width);
}
function getLocaleDayNames(locale, formStyle, width) {
  const data = findLocaleData(locale);
  const daysData = [data[LocaleDataIndex.DaysFormat], data[LocaleDataIndex.DaysStandalone]];
  const days = getLastDefinedValue(daysData, formStyle);
  return getLastDefinedValue(days, width);
}
function getLocaleMonthNames(locale, formStyle, width) {
  const data = findLocaleData(locale);
  const monthsData = [data[LocaleDataIndex.MonthsFormat], data[LocaleDataIndex.MonthsStandalone]];
  const months = getLastDefinedValue(monthsData, formStyle);
  return getLastDefinedValue(months, width);
}
function getLocaleEraNames(locale, width) {
  const data = findLocaleData(locale);
  const erasData = data[LocaleDataIndex.Eras];
  return getLastDefinedValue(erasData, width);
}
function getLocaleDateFormat(locale, width) {
  const data = findLocaleData(locale);
  return getLastDefinedValue(data[LocaleDataIndex.DateFormat], width);
}
function getLocaleTimeFormat(locale, width) {
  const data = findLocaleData(locale);
  return getLastDefinedValue(data[LocaleDataIndex.TimeFormat], width);
}
function getLocaleDateTimeFormat(locale, width) {
  const data = findLocaleData(locale);
  const dateTimeFormatData = data[LocaleDataIndex.DateTimeFormat];
  return getLastDefinedValue(dateTimeFormatData, width);
}
function getLocaleNumberSymbol(locale, symbol) {
  const data = findLocaleData(locale);
  const res = data[LocaleDataIndex.NumberSymbols][symbol];
  if (typeof res === "undefined") {
    if (symbol === NumberSymbol.CurrencyDecimal) {
      return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Decimal];
    } else if (symbol === NumberSymbol.CurrencyGroup) {
      return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Group];
    }
  }
  return res;
}
function getLocaleNumberFormat(locale, type) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.NumberFormats][type];
}
function getLocaleCurrencies(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.Currencies];
}
function checkFullData(data) {
  if (!data[LocaleDataIndex.ExtraData]) {
    throw new RuntimeError(2303, ngDevMode && `Missing extra locale data for the locale "${data[LocaleDataIndex.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`);
  }
}
function getLocaleExtraDayPeriodRules(locale) {
  const data = findLocaleData(locale);
  checkFullData(data);
  const rules = data[LocaleDataIndex.ExtraData][
    2
    /* ɵExtraLocaleDataIndex.ExtraDayPeriodsRules */
  ] || [];
  return rules.map((rule) => {
    if (typeof rule === "string") {
      return extractTime(rule);
    }
    return [extractTime(rule[0]), extractTime(rule[1])];
  });
}
function getLocaleExtraDayPeriods(locale, formStyle, width) {
  const data = findLocaleData(locale);
  checkFullData(data);
  const dayPeriodsData = [data[LocaleDataIndex.ExtraData][
    0
    /* ɵExtraLocaleDataIndex.ExtraDayPeriodFormats */
  ], data[LocaleDataIndex.ExtraData][
    1
    /* ɵExtraLocaleDataIndex.ExtraDayPeriodStandalone */
  ]];
  const dayPeriods = getLastDefinedValue(dayPeriodsData, formStyle) || [];
  return getLastDefinedValue(dayPeriods, width) || [];
}
function getLastDefinedValue(data, index) {
  for (let i2 = index; i2 > -1; i2--) {
    if (typeof data[i2] !== "undefined") {
      return data[i2];
    }
  }
  throw new RuntimeError(2304, ngDevMode && "Locale data API: locale data undefined");
}
function extractTime(time) {
  const [h2, m] = time.split(":");
  return {
    hours: +h2,
    minutes: +m
  };
}
function getCurrencySymbol(code, format, locale = "en") {
  const currency = getLocaleCurrencies(locale)[code] || CURRENCIES_EN[code] || [];
  const symbolNarrow = currency[
    1
    /* ɵCurrencyIndex.SymbolNarrow */
  ];
  if (format === "narrow" && typeof symbolNarrow === "string") {
    return symbolNarrow;
  }
  return currency[
    0
    /* ɵCurrencyIndex.Symbol */
  ] || code;
}
function getNumberOfCurrencyDigits(code) {
  let digits;
  const currency = CURRENCIES_EN[code];
  if (currency) {
    digits = currency[
      2
      /* ɵCurrencyIndex.NbOfDigits */
    ];
  }
  return typeof digits === "number" ? digits : DEFAULT_NB_OF_CURRENCY_DIGITS;
}
function formatDate(value, format, locale, timezone) {
  let date = toDate(value);
  const namedFormat = getNamedFormat(locale, format);
  format = namedFormat || format;
  let parts = [];
  let match2;
  while (format) {
    match2 = DATE_FORMATS_SPLIT.exec(format);
    if (match2) {
      parts = parts.concat(match2.slice(1));
      const part = parts.pop();
      if (!part) {
        break;
      }
      format = part;
    } else {
      parts.push(format);
      break;
    }
  }
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    assertValidDateFormat(parts);
  }
  let dateTimezoneOffset = date.getTimezoneOffset();
  if (timezone) {
    dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
    date = convertTimezoneToLocal(date, timezone);
  }
  let text = "";
  parts.forEach((value2) => {
    const dateFormatter = getDateFormatter(value2);
    text += dateFormatter ? dateFormatter(date, locale, dateTimezoneOffset) : value2 === "''" ? "'" : value2.replace(/(^'|'$)/g, "").replace(/''/g, "'");
  });
  return text;
}
function assertValidDateFormat(parts) {
  if (parts.some((part) => /^Y+$/.test(part)) && !parts.some((part) => /^w+$/.test(part))) {
    const message = `Suspicious use of week-based year "Y" in date pattern "${parts.join("")}". Did you mean to use calendar year "y" instead?`;
    if (parts.length === 1) {
      console.error(formatRuntimeError(2300, message));
    } else {
      throw new RuntimeError(2300, message);
    }
  }
}
function createDate(year, month, date) {
  const newDate = /* @__PURE__ */ new Date(0);
  newDate.setFullYear(year, month, date);
  newDate.setHours(0, 0, 0);
  return newDate;
}
function getNamedFormat(locale, format) {
  const localeId = getLocaleId2(locale);
  NAMED_FORMATS[localeId] ??= {};
  if (NAMED_FORMATS[localeId][format]) {
    return NAMED_FORMATS[localeId][format];
  }
  let formatValue2 = "";
  switch (format) {
    case "shortDate":
      formatValue2 = getLocaleDateFormat(locale, FormatWidth.Short);
      break;
    case "mediumDate":
      formatValue2 = getLocaleDateFormat(locale, FormatWidth.Medium);
      break;
    case "longDate":
      formatValue2 = getLocaleDateFormat(locale, FormatWidth.Long);
      break;
    case "fullDate":
      formatValue2 = getLocaleDateFormat(locale, FormatWidth.Full);
      break;
    case "shortTime":
      formatValue2 = getLocaleTimeFormat(locale, FormatWidth.Short);
      break;
    case "mediumTime":
      formatValue2 = getLocaleTimeFormat(locale, FormatWidth.Medium);
      break;
    case "longTime":
      formatValue2 = getLocaleTimeFormat(locale, FormatWidth.Long);
      break;
    case "fullTime":
      formatValue2 = getLocaleTimeFormat(locale, FormatWidth.Full);
      break;
    case "short":
      const shortTime = getNamedFormat(locale, "shortTime");
      const shortDate = getNamedFormat(locale, "shortDate");
      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Short), [shortTime, shortDate]);
      break;
    case "medium":
      const mediumTime = getNamedFormat(locale, "mediumTime");
      const mediumDate = getNamedFormat(locale, "mediumDate");
      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Medium), [mediumTime, mediumDate]);
      break;
    case "long":
      const longTime = getNamedFormat(locale, "longTime");
      const longDate = getNamedFormat(locale, "longDate");
      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Long), [longTime, longDate]);
      break;
    case "full":
      const fullTime = getNamedFormat(locale, "fullTime");
      const fullDate = getNamedFormat(locale, "fullDate");
      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Full), [fullTime, fullDate]);
      break;
  }
  if (formatValue2) {
    NAMED_FORMATS[localeId][format] = formatValue2;
  }
  return formatValue2;
}
function formatDateTime(str, opt_values) {
  if (opt_values) {
    str = str.replace(/\{([^}]+)}/g, function(match2, key) {
      return opt_values != null && key in opt_values ? opt_values[key] : match2;
    });
  }
  return str;
}
function padNumber(num, digits, minusSign = "-", trim, negWrap) {
  let neg = "";
  if (num < 0 || negWrap && num <= 0) {
    if (negWrap) {
      num = -num + 1;
    } else {
      num = -num;
      neg = minusSign;
    }
  }
  let strNum = String(num);
  while (strNum.length < digits) {
    strNum = "0" + strNum;
  }
  if (trim) {
    strNum = strNum.slice(strNum.length - digits);
  }
  return neg + strNum;
}
function formatFractionalSeconds(milliseconds, digits) {
  const strMs = padNumber(milliseconds, 3);
  return strMs.substring(0, digits);
}
function dateGetter(name, size, offset = 0, trim = false, negWrap = false) {
  return function(date, locale) {
    let part = getDatePart(name, date);
    if (offset > 0 || part > -offset) {
      part += offset;
    }
    if (name === 3) {
      if (part === 0 && offset === -12) {
        part = 12;
      }
    } else if (name === 6) {
      return formatFractionalSeconds(part, size);
    }
    const localeMinus = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
    return padNumber(part, size, localeMinus, trim, negWrap);
  };
}
function getDatePart(part, date) {
  switch (part) {
    case 0:
      return date.getFullYear();
    case 1:
      return date.getMonth();
    case 2:
      return date.getDate();
    case 3:
      return date.getHours();
    case 4:
      return date.getMinutes();
    case 5:
      return date.getSeconds();
    case 6:
      return date.getMilliseconds();
    case 7:
      return date.getDay();
    default:
      throw new RuntimeError(2301, ngDevMode && `Unknown DateType value "${part}".`);
  }
}
function dateStrGetter(name, width, form = FormStyle.Format, extended = false) {
  return function(date, locale) {
    return getDateTranslation(date, locale, name, width, form, extended);
  };
}
function getDateTranslation(date, locale, name, width, form, extended) {
  switch (name) {
    case 2:
      return getLocaleMonthNames(locale, form, width)[date.getMonth()];
    case 1:
      return getLocaleDayNames(locale, form, width)[date.getDay()];
    case 0:
      const currentHours = date.getHours();
      const currentMinutes = date.getMinutes();
      if (extended) {
        const rules = getLocaleExtraDayPeriodRules(locale);
        const dayPeriods = getLocaleExtraDayPeriods(locale, form, width);
        const index = rules.findIndex((rule) => {
          if (Array.isArray(rule)) {
            const [from2, to2] = rule;
            const afterFrom = currentHours >= from2.hours && currentMinutes >= from2.minutes;
            const beforeTo = currentHours < to2.hours || currentHours === to2.hours && currentMinutes < to2.minutes;
            if (from2.hours < to2.hours) {
              if (afterFrom && beforeTo) {
                return true;
              }
            } else if (afterFrom || beforeTo) {
              return true;
            }
          } else {
            if (rule.hours === currentHours && rule.minutes === currentMinutes) {
              return true;
            }
          }
          return false;
        });
        if (index !== -1) {
          return dayPeriods[index];
        }
      }
      return getLocaleDayPeriods(locale, form, width)[currentHours < 12 ? 0 : 1];
    case 3:
      return getLocaleEraNames(locale, width)[date.getFullYear() <= 0 ? 0 : 1];
    default:
      const unexpected = name;
      throw new RuntimeError(2302, ngDevMode && `unexpected translation type ${unexpected}`);
  }
}
function timeZoneGetter(width) {
  return function(date, locale, offset) {
    const zone = -1 * offset;
    const minusSign = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
    const hours = zone > 0 ? Math.floor(zone / 60) : Math.ceil(zone / 60);
    switch (width) {
      case 0:
        return (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + padNumber(Math.abs(zone % 60), 2, minusSign);
      case 1:
        return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours, 1, minusSign);
      case 2:
        return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
      case 3:
        if (offset === 0) {
          return "Z";
        } else {
          return (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
        }
      default:
        throw new RuntimeError(2302, ngDevMode && `Unknown zone width "${width}"`);
    }
  };
}
function getFirstThursdayOfYear(year) {
  const firstDayOfYear = createDate(year, JANUARY, 1).getDay();
  return createDate(year, 0, 1 + (firstDayOfYear <= THURSDAY ? THURSDAY : THURSDAY + 7) - firstDayOfYear);
}
function getThursdayThisIsoWeek(datetime) {
  const currentDay = datetime.getDay();
  const deltaToThursday = currentDay === 0 ? -3 : THURSDAY - currentDay;
  return createDate(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + deltaToThursday);
}
function weekGetter(size, monthBased = false) {
  return function(date, locale) {
    let result;
    if (monthBased) {
      const nbDaysBefore1stDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1).getDay() - 1;
      const today = date.getDate();
      result = 1 + Math.floor((today + nbDaysBefore1stDayOfMonth) / 7);
    } else {
      const thisThurs = getThursdayThisIsoWeek(date);
      const firstThurs = getFirstThursdayOfYear(thisThurs.getFullYear());
      const diff = thisThurs.getTime() - firstThurs.getTime();
      result = 1 + Math.round(diff / 6048e5);
    }
    return padNumber(result, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  };
}
function weekNumberingYearGetter(size, trim = false) {
  return function(date, locale) {
    const thisThurs = getThursdayThisIsoWeek(date);
    const weekNumberingYear = thisThurs.getFullYear();
    return padNumber(weekNumberingYear, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign), trim);
  };
}
function getDateFormatter(format) {
  if (DATE_FORMATS[format]) {
    return DATE_FORMATS[format];
  }
  let formatter;
  switch (format) {
    // Era name (AD/BC)
    case "G":
    case "GG":
    case "GGG":
      formatter = dateStrGetter(3, TranslationWidth.Abbreviated);
      break;
    case "GGGG":
      formatter = dateStrGetter(3, TranslationWidth.Wide);
      break;
    case "GGGGG":
      formatter = dateStrGetter(3, TranslationWidth.Narrow);
      break;
    // 1 digit representation of the year, e.g. (AD 1 => 1, AD 199 => 199)
    case "y":
      formatter = dateGetter(0, 1, 0, false, true);
      break;
    // 2 digit representation of the year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)
    case "yy":
      formatter = dateGetter(0, 2, 0, true, true);
      break;
    // 3 digit representation of the year, padded (000-999). (e.g. AD 2001 => 01, AD 2010 => 10)
    case "yyy":
      formatter = dateGetter(0, 3, 0, false, true);
      break;
    // 4 digit representation of the year (e.g. AD 1 => 0001, AD 2010 => 2010)
    case "yyyy":
      formatter = dateGetter(0, 4, 0, false, true);
      break;
    // 1 digit representation of the week-numbering year, e.g. (AD 1 => 1, AD 199 => 199)
    case "Y":
      formatter = weekNumberingYearGetter(1);
      break;
    // 2 digit representation of the week-numbering year, padded (00-99). (e.g. AD 2001 => 01, AD
    // 2010 => 10)
    case "YY":
      formatter = weekNumberingYearGetter(2, true);
      break;
    // 3 digit representation of the week-numbering year, padded (000-999). (e.g. AD 1 => 001, AD
    // 2010 => 2010)
    case "YYY":
      formatter = weekNumberingYearGetter(3);
      break;
    // 4 digit representation of the week-numbering year (e.g. AD 1 => 0001, AD 2010 => 2010)
    case "YYYY":
      formatter = weekNumberingYearGetter(4);
      break;
    // Month of the year (1-12), numeric
    case "M":
    case "L":
      formatter = dateGetter(1, 1, 1);
      break;
    case "MM":
    case "LL":
      formatter = dateGetter(1, 2, 1);
      break;
    // Month of the year (January, ...), string, format
    case "MMM":
      formatter = dateStrGetter(2, TranslationWidth.Abbreviated);
      break;
    case "MMMM":
      formatter = dateStrGetter(2, TranslationWidth.Wide);
      break;
    case "MMMMM":
      formatter = dateStrGetter(2, TranslationWidth.Narrow);
      break;
    // Month of the year (January, ...), string, standalone
    case "LLL":
      formatter = dateStrGetter(2, TranslationWidth.Abbreviated, FormStyle.Standalone);
      break;
    case "LLLL":
      formatter = dateStrGetter(2, TranslationWidth.Wide, FormStyle.Standalone);
      break;
    case "LLLLL":
      formatter = dateStrGetter(2, TranslationWidth.Narrow, FormStyle.Standalone);
      break;
    // Week of the year (1, ... 52)
    case "w":
      formatter = weekGetter(1);
      break;
    case "ww":
      formatter = weekGetter(2);
      break;
    // Week of the month (1, ...)
    case "W":
      formatter = weekGetter(1, true);
      break;
    // Day of the month (1-31)
    case "d":
      formatter = dateGetter(2, 1);
      break;
    case "dd":
      formatter = dateGetter(2, 2);
      break;
    // Day of the Week StandAlone (1, 1, Mon, Monday, M, Mo)
    case "c":
    case "cc":
      formatter = dateGetter(7, 1);
      break;
    case "ccc":
      formatter = dateStrGetter(1, TranslationWidth.Abbreviated, FormStyle.Standalone);
      break;
    case "cccc":
      formatter = dateStrGetter(1, TranslationWidth.Wide, FormStyle.Standalone);
      break;
    case "ccccc":
      formatter = dateStrGetter(1, TranslationWidth.Narrow, FormStyle.Standalone);
      break;
    case "cccccc":
      formatter = dateStrGetter(1, TranslationWidth.Short, FormStyle.Standalone);
      break;
    // Day of the Week
    case "E":
    case "EE":
    case "EEE":
      formatter = dateStrGetter(1, TranslationWidth.Abbreviated);
      break;
    case "EEEE":
      formatter = dateStrGetter(1, TranslationWidth.Wide);
      break;
    case "EEEEE":
      formatter = dateStrGetter(1, TranslationWidth.Narrow);
      break;
    case "EEEEEE":
      formatter = dateStrGetter(1, TranslationWidth.Short);
      break;
    // Generic period of the day (am-pm)
    case "a":
    case "aa":
    case "aaa":
      formatter = dateStrGetter(0, TranslationWidth.Abbreviated);
      break;
    case "aaaa":
      formatter = dateStrGetter(0, TranslationWidth.Wide);
      break;
    case "aaaaa":
      formatter = dateStrGetter(0, TranslationWidth.Narrow);
      break;
    // Extended period of the day (midnight, at night, ...), standalone
    case "b":
    case "bb":
    case "bbb":
      formatter = dateStrGetter(0, TranslationWidth.Abbreviated, FormStyle.Standalone, true);
      break;
    case "bbbb":
      formatter = dateStrGetter(0, TranslationWidth.Wide, FormStyle.Standalone, true);
      break;
    case "bbbbb":
      formatter = dateStrGetter(0, TranslationWidth.Narrow, FormStyle.Standalone, true);
      break;
    // Extended period of the day (midnight, night, ...), standalone
    case "B":
    case "BB":
    case "BBB":
      formatter = dateStrGetter(0, TranslationWidth.Abbreviated, FormStyle.Format, true);
      break;
    case "BBBB":
      formatter = dateStrGetter(0, TranslationWidth.Wide, FormStyle.Format, true);
      break;
    case "BBBBB":
      formatter = dateStrGetter(0, TranslationWidth.Narrow, FormStyle.Format, true);
      break;
    // Hour in AM/PM, (1-12)
    case "h":
      formatter = dateGetter(3, 1, -12);
      break;
    case "hh":
      formatter = dateGetter(3, 2, -12);
      break;
    // Hour of the day (0-23)
    case "H":
      formatter = dateGetter(3, 1);
      break;
    // Hour in day, padded (00-23)
    case "HH":
      formatter = dateGetter(3, 2);
      break;
    // Minute of the hour (0-59)
    case "m":
      formatter = dateGetter(4, 1);
      break;
    case "mm":
      formatter = dateGetter(4, 2);
      break;
    // Second of the minute (0-59)
    case "s":
      formatter = dateGetter(5, 1);
      break;
    case "ss":
      formatter = dateGetter(5, 2);
      break;
    // Fractional second
    case "S":
      formatter = dateGetter(6, 1);
      break;
    case "SS":
      formatter = dateGetter(6, 2);
      break;
    case "SSS":
      formatter = dateGetter(6, 3);
      break;
    // Timezone ISO8601 short format (-0430)
    case "Z":
    case "ZZ":
    case "ZZZ":
      formatter = timeZoneGetter(
        0
        /* ZoneWidth.Short */
      );
      break;
    // Timezone ISO8601 extended format (-04:30)
    case "ZZZZZ":
      formatter = timeZoneGetter(
        3
        /* ZoneWidth.Extended */
      );
      break;
    // Timezone GMT short format (GMT+4)
    case "O":
    case "OO":
    case "OOO":
    // Should be location, but fallback to format O instead because we don't have the data yet
    case "z":
    case "zz":
    case "zzz":
      formatter = timeZoneGetter(
        1
        /* ZoneWidth.ShortGMT */
      );
      break;
    // Timezone GMT long format (GMT+0430)
    case "OOOO":
    case "ZZZZ":
    // Should be location, but fallback to format O instead because we don't have the data yet
    case "zzzz":
      formatter = timeZoneGetter(
        2
        /* ZoneWidth.Long */
      );
      break;
    default:
      return null;
  }
  DATE_FORMATS[format] = formatter;
  return formatter;
}
function timezoneToOffset(timezone, fallback) {
  timezone = timezone.replace(/:/g, "");
  const requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
  return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
}
function addDateMinutes(date, minutes) {
  date = new Date(date.getTime());
  date.setMinutes(date.getMinutes() + minutes);
  return date;
}
function convertTimezoneToLocal(date, timezone, reverse) {
  const reverseValue = -1;
  const dateTimezoneOffset = date.getTimezoneOffset();
  const timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
  return addDateMinutes(date, reverseValue * (timezoneOffset - dateTimezoneOffset));
}
function toDate(value) {
  if (isDate(value)) {
    return value;
  }
  if (typeof value === "number" && !isNaN(value)) {
    return new Date(value);
  }
  if (typeof value === "string") {
    value = value.trim();
    if (/^(\d{4}(-\d{1,2}(-\d{1,2})?)?)$/.test(value)) {
      const [y2, m = 1, d2 = 1] = value.split("-").map((val) => +val);
      return createDate(y2, m - 1, d2);
    }
    const parsedNb = parseFloat(value);
    if (!isNaN(value - parsedNb)) {
      return new Date(parsedNb);
    }
    let match2;
    if (match2 = value.match(ISO8601_DATE_REGEX)) {
      return isoStringToDate(match2);
    }
  }
  const date = new Date(value);
  if (!isDate(date)) {
    throw new RuntimeError(2302, ngDevMode && `Unable to convert "${value}" into a date`);
  }
  return date;
}
function isoStringToDate(match2) {
  const date = /* @__PURE__ */ new Date(0);
  let tzHour = 0;
  let tzMin = 0;
  const dateSetter = match2[8] ? date.setUTCFullYear : date.setFullYear;
  const timeSetter = match2[8] ? date.setUTCHours : date.setHours;
  if (match2[9]) {
    tzHour = Number(match2[9] + match2[10]);
    tzMin = Number(match2[9] + match2[11]);
  }
  dateSetter.call(date, Number(match2[1]), Number(match2[2]) - 1, Number(match2[3]));
  const h2 = Number(match2[4] || 0) - tzHour;
  const m = Number(match2[5] || 0) - tzMin;
  const s2 = Number(match2[6] || 0);
  const ms2 = Math.floor(parseFloat("0." + (match2[7] || 0)) * 1e3);
  timeSetter.call(date, h2, m, s2, ms2);
  return date;
}
function isDate(value) {
  return value instanceof Date && !isNaN(value.valueOf());
}
function formatNumberToLocaleString(value, pattern, locale, groupSymbol, decimalSymbol, digitsInfo, isPercent = false) {
  let formattedText = "";
  let isZero = false;
  if (!isFinite(value)) {
    formattedText = getLocaleNumberSymbol(locale, NumberSymbol.Infinity);
  } else {
    let parsedNumber = parseNumber(value);
    if (isPercent) {
      parsedNumber = toPercent(parsedNumber);
    }
    let minInt = pattern.minInt;
    let minFraction = pattern.minFrac;
    let maxFraction = pattern.maxFrac;
    if (digitsInfo) {
      const parts = digitsInfo.match(NUMBER_FORMAT_REGEXP);
      if (parts === null) {
        throw new RuntimeError(2306, ngDevMode && `${digitsInfo} is not a valid digit info`);
      }
      const minIntPart = parts[1];
      const minFractionPart = parts[3];
      const maxFractionPart = parts[5];
      if (minIntPart != null) {
        minInt = parseIntAutoRadix(minIntPart);
      }
      if (minFractionPart != null) {
        minFraction = parseIntAutoRadix(minFractionPart);
      }
      if (maxFractionPart != null) {
        maxFraction = parseIntAutoRadix(maxFractionPart);
      } else if (minFractionPart != null && minFraction > maxFraction) {
        maxFraction = minFraction;
      }
    }
    roundNumber(parsedNumber, minFraction, maxFraction);
    let digits = parsedNumber.digits;
    let integerLen = parsedNumber.integerLen;
    const exponent = parsedNumber.exponent;
    let decimals = [];
    isZero = digits.every((d2) => !d2);
    for (; integerLen < minInt; integerLen++) {
      digits.unshift(0);
    }
    for (; integerLen < 0; integerLen++) {
      digits.unshift(0);
    }
    if (integerLen > 0) {
      decimals = digits.splice(integerLen, digits.length);
    } else {
      decimals = digits;
      digits = [0];
    }
    const groups = [];
    if (digits.length >= pattern.lgSize) {
      groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(""));
    }
    while (digits.length > pattern.gSize) {
      groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
    }
    if (digits.length) {
      groups.unshift(digits.join(""));
    }
    formattedText = groups.join(getLocaleNumberSymbol(locale, groupSymbol));
    if (decimals.length) {
      formattedText += getLocaleNumberSymbol(locale, decimalSymbol) + decimals.join("");
    }
    if (exponent) {
      formattedText += getLocaleNumberSymbol(locale, NumberSymbol.Exponential) + "+" + exponent;
    }
  }
  if (value < 0 && !isZero) {
    formattedText = pattern.negPre + formattedText + pattern.negSuf;
  } else {
    formattedText = pattern.posPre + formattedText + pattern.posSuf;
  }
  return formattedText;
}
function formatCurrency(value, locale, currency, currencyCode, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Currency);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  pattern.minFrac = getNumberOfCurrencyDigits(currencyCode);
  pattern.maxFrac = pattern.minFrac;
  const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.CurrencyGroup, NumberSymbol.CurrencyDecimal, digitsInfo);
  return res.replace(CURRENCY_CHAR, currency).replace(CURRENCY_CHAR, "").trim();
}
function formatPercent(value, locale, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Percent);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo, true);
  return res.replace(new RegExp(PERCENT_CHAR, "g"), getLocaleNumberSymbol(locale, NumberSymbol.PercentSign));
}
function formatNumber(value, locale, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Decimal);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  return formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo);
}
function parseNumberFormat(format, minusSign = "-") {
  const p2 = {
    minInt: 1,
    minFrac: 0,
    maxFrac: 0,
    posPre: "",
    posSuf: "",
    negPre: "",
    negSuf: "",
    gSize: 0,
    lgSize: 0
  };
  const patternParts = format.split(PATTERN_SEP);
  const positive = patternParts[0];
  const negative = patternParts[1];
  const positiveParts = positive.indexOf(DECIMAL_SEP) !== -1 ? positive.split(DECIMAL_SEP) : [positive.substring(0, positive.lastIndexOf(ZERO_CHAR) + 1), positive.substring(positive.lastIndexOf(ZERO_CHAR) + 1)], integer = positiveParts[0], fraction = positiveParts[1] || "";
  p2.posPre = integer.substring(0, integer.indexOf(DIGIT_CHAR));
  for (let i2 = 0; i2 < fraction.length; i2++) {
    const ch2 = fraction.charAt(i2);
    if (ch2 === ZERO_CHAR) {
      p2.minFrac = p2.maxFrac = i2 + 1;
    } else if (ch2 === DIGIT_CHAR) {
      p2.maxFrac = i2 + 1;
    } else {
      p2.posSuf += ch2;
    }
  }
  const groups = integer.split(GROUP_SEP);
  p2.gSize = groups[1] ? groups[1].length : 0;
  p2.lgSize = groups[2] || groups[1] ? (groups[2] || groups[1]).length : 0;
  if (negative) {
    const trunkLen = positive.length - p2.posPre.length - p2.posSuf.length, pos = negative.indexOf(DIGIT_CHAR);
    p2.negPre = negative.substring(0, pos).replace(/'/g, "");
    p2.negSuf = negative.slice(pos + trunkLen).replace(/'/g, "");
  } else {
    p2.negPre = minusSign + p2.posPre;
    p2.negSuf = p2.posSuf;
  }
  return p2;
}
function toPercent(parsedNumber) {
  if (parsedNumber.digits[0] === 0) {
    return parsedNumber;
  }
  const fractionLen = parsedNumber.digits.length - parsedNumber.integerLen;
  if (parsedNumber.exponent) {
    parsedNumber.exponent += 2;
  } else {
    if (fractionLen === 0) {
      parsedNumber.digits.push(0, 0);
    } else if (fractionLen === 1) {
      parsedNumber.digits.push(0);
    }
    parsedNumber.integerLen += 2;
  }
  return parsedNumber;
}
function parseNumber(num) {
  let numStr = Math.abs(num) + "";
  let exponent = 0, digits, integerLen;
  let i2, j2, zeros;
  if ((integerLen = numStr.indexOf(DECIMAL_SEP)) > -1) {
    numStr = numStr.replace(DECIMAL_SEP, "");
  }
  if ((i2 = numStr.search(/e/i)) > 0) {
    if (integerLen < 0) integerLen = i2;
    integerLen += +numStr.slice(i2 + 1);
    numStr = numStr.substring(0, i2);
  } else if (integerLen < 0) {
    integerLen = numStr.length;
  }
  for (i2 = 0; numStr.charAt(i2) === ZERO_CHAR; i2++) {
  }
  if (i2 === (zeros = numStr.length)) {
    digits = [0];
    integerLen = 1;
  } else {
    zeros--;
    while (numStr.charAt(zeros) === ZERO_CHAR) zeros--;
    integerLen -= i2;
    digits = [];
    for (j2 = 0; i2 <= zeros; i2++, j2++) {
      digits[j2] = Number(numStr.charAt(i2));
    }
  }
  if (integerLen > MAX_DIGITS) {
    digits = digits.splice(0, MAX_DIGITS - 1);
    exponent = integerLen - 1;
    integerLen = 1;
  }
  return {
    digits,
    exponent,
    integerLen
  };
}
function roundNumber(parsedNumber, minFrac, maxFrac) {
  if (minFrac > maxFrac) {
    throw new RuntimeError(2307, ngDevMode && `The minimum number of digits after fraction (${minFrac}) is higher than the maximum (${maxFrac}).`);
  }
  let digits = parsedNumber.digits;
  let fractionLen = digits.length - parsedNumber.integerLen;
  const fractionSize = Math.min(Math.max(minFrac, fractionLen), maxFrac);
  let roundAt = fractionSize + parsedNumber.integerLen;
  let digit = digits[roundAt];
  if (roundAt > 0) {
    digits.splice(Math.max(parsedNumber.integerLen, roundAt));
    for (let j2 = roundAt; j2 < digits.length; j2++) {
      digits[j2] = 0;
    }
  } else {
    fractionLen = Math.max(0, fractionLen);
    parsedNumber.integerLen = 1;
    digits.length = Math.max(1, roundAt = fractionSize + 1);
    digits[0] = 0;
    for (let i2 = 1; i2 < roundAt; i2++) digits[i2] = 0;
  }
  if (digit >= 5) {
    if (roundAt - 1 < 0) {
      for (let k2 = 0; k2 > roundAt; k2--) {
        digits.unshift(0);
        parsedNumber.integerLen++;
      }
      digits.unshift(1);
      parsedNumber.integerLen++;
    } else {
      digits[roundAt - 1]++;
    }
  }
  for (; fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
  let dropTrailingZeros = fractionSize !== 0;
  const minLen = minFrac + parsedNumber.integerLen;
  const carry = digits.reduceRight(function(carry2, d2, i2, digits2) {
    d2 = d2 + carry2;
    digits2[i2] = d2 < 10 ? d2 : d2 - 10;
    if (dropTrailingZeros) {
      if (digits2[i2] === 0 && i2 >= minLen) {
        digits2.pop();
      } else {
        dropTrailingZeros = false;
      }
    }
    return d2 >= 10 ? 1 : 0;
  }, 0);
  if (carry) {
    digits.unshift(carry);
    parsedNumber.integerLen++;
  }
}
function parseIntAutoRadix(text) {
  const result = parseInt(text);
  if (isNaN(result)) {
    throw new RuntimeError(2305, ngDevMode && "Invalid integer literal when parsing " + text);
  }
  return result;
}
function getPluralCategory(value, cases, ngLocalization, locale) {
  let key = `=${value}`;
  if (cases.indexOf(key) > -1) {
    return key;
  }
  key = ngLocalization.getPluralCategory(value, locale);
  if (cases.indexOf(key) > -1) {
    return key;
  }
  if (cases.indexOf("other") > -1) {
    return "other";
  }
  throw new RuntimeError(2308, ngDevMode && `No plural message found for value "${value}"`);
}
function getParentInjector(injector) {
  const parentNgModule = injector.get(NgModuleRef$1);
  return parentNgModule.injector;
}
function applyViewChange(view, record) {
  view.context.$implicit = record.item;
}
function getTypeName(type) {
  return type["name"] || typeof type;
}
function assertTemplate(templateRef, property) {
  if (templateRef && !templateRef.createEmbeddedView) {
    throw new RuntimeError(2020, (typeof ngDevMode === "undefined" || ngDevMode) && `${property} must be a TemplateRef, but received '${stringify(templateRef)}'.`);
  }
}
function throwNgSwitchProviderNotFoundError(attrName, directiveName) {
  throw new RuntimeError(2e3, `An element with the "${attrName}" attribute (matching the "${directiveName}" directive) must be located inside an element with the "ngSwitch" attribute (matching "NgSwitch" directive)`);
}
function invalidPipeArgumentError(type, value) {
  return new RuntimeError(2100, ngDevMode && `InvalidPipeArgument: '${value}' for pipe '${stringify(type)}'`);
}
function makeKeyValuePair(key, value) {
  return {
    key,
    value
  };
}
function defaultComparator(keyValueA, keyValueB) {
  const a2 = keyValueA.key;
  const b2 = keyValueB.key;
  if (a2 === b2) return 0;
  if (a2 == null) return 1;
  if (b2 == null) return -1;
  if (typeof a2 == "string" && typeof b2 == "string") {
    return a2 < b2 ? -1 : 1;
  }
  if (typeof a2 == "number" && typeof b2 == "number") {
    return a2 - b2;
  }
  if (typeof a2 == "boolean" && typeof b2 == "boolean") {
    return a2 < b2 ? -1 : 1;
  }
  const aString = String(a2);
  const bString = String(b2);
  return aString == bString ? 0 : aString < bString ? -1 : 1;
}
function isValue(value) {
  return !(value == null || value === "" || value !== value);
}
function strToNumber(value) {
  if (typeof value === "string" && !isNaN(Number(value) - parseFloat(value))) {
    return Number(value);
  }
  if (typeof value !== "number") {
    throw new RuntimeError(2309, ngDevMode && `${value} is not a number`);
  }
  return value;
}
var HashLocationStrategy, CURRENCIES_EN, NumberFormatStyle, Plural, FormStyle, TranslationWidth, FormatWidth, NumberSymbol, WeekDay, getLocalePluralCase2, DEFAULT_NB_OF_CURRENCY_DIGITS, ISO8601_DATE_REGEX, NAMED_FORMATS, DATE_FORMATS_SPLIT, JANUARY, THURSDAY, DATE_FORMATS, NUMBER_FORMAT_REGEXP, MAX_DIGITS, DECIMAL_SEP, ZERO_CHAR, PATTERN_SEP, GROUP_SEP, DIGIT_CHAR, CURRENCY_CHAR, PERCENT_CHAR, NgLocalization, NgLocaleLocalization, WS_REGEXP, EMPTY_ARRAY2, NgClass, NgComponentOutlet, NgForOfContext, NgForOf, NgIf, NgIfContext, SwitchView, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase, NgStyle, NgTemplateOutlet, COMMON_DIRECTIVES, SubscribableStrategy, PromiseStrategy, _promiseStrategy, _subscribableStrategy, AsyncPipe, LowerCasePipe, unicodeWordMatch, TitleCasePipe, UpperCasePipe, DEFAULT_DATE_FORMAT, DATE_PIPE_DEFAULT_TIMEZONE, DATE_PIPE_DEFAULT_OPTIONS, DatePipe, _INTERPOLATION_REGEXP, I18nPluralPipe, I18nSelectPipe, JsonPipe, KeyValuePipe, DecimalPipe, PercentPipe, CurrencyPipe, SlicePipe, COMMON_PIPES, CommonModule;
var init_common_module = __esm({
  "node_modules/@angular/common/fesm2022/common_module.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_location();
    HashLocationStrategy = class _HashLocationStrategy extends LocationStrategy {
      _platformLocation;
      _baseHref = "";
      _removeListenerFns = [];
      constructor(_platformLocation, _baseHref) {
        super();
        this._platformLocation = _platformLocation;
        if (_baseHref != null) {
          this._baseHref = _baseHref;
        }
      }
      /** @docs-private */
      ngOnDestroy() {
        while (this._removeListenerFns.length) {
          this._removeListenerFns.pop()();
        }
      }
      onPopState(fn) {
        this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));
      }
      getBaseHref() {
        return this._baseHref;
      }
      path(includeHash = false) {
        const path = this._platformLocation.hash ?? "#";
        return path.length > 0 ? path.substring(1) : path;
      }
      prepareExternalUrl(internal) {
        const url = joinWithSlash(this._baseHref, internal);
        return url.length > 0 ? "#" + url : url;
      }
      pushState(state, title, path, queryParams) {
        const url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams)) || this._platformLocation.pathname;
        this._platformLocation.pushState(state, title, url);
      }
      replaceState(state, title, path, queryParams) {
        const url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams)) || this._platformLocation.pathname;
        this._platformLocation.replaceState(state, title, url);
      }
      forward() {
        this._platformLocation.forward();
      }
      back() {
        this._platformLocation.back();
      }
      getState() {
        return this._platformLocation.getState();
      }
      historyGo(relativePosition = 0) {
        this._platformLocation.historyGo?.(relativePosition);
      }
      static \u0275fac = function HashLocationStrategy_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HashLocationStrategy)(\u0275\u0275inject(PlatformLocation), \u0275\u0275inject(APP_BASE_HREF, 8));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _HashLocationStrategy,
        factory: _HashLocationStrategy.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HashLocationStrategy, [{
        type: Injectable
      }], () => [{
        type: PlatformLocation
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [APP_BASE_HREF]
        }]
      }], null);
    })();
    CURRENCIES_EN = {
      "ADP": [void 0, void 0, 0],
      "AFN": [void 0, "\u060B", 0],
      "ALL": [void 0, void 0, 0],
      "AMD": [void 0, "\u058F", 2],
      "AOA": [void 0, "Kz"],
      "ARS": [void 0, "$"],
      "AUD": ["A$", "$"],
      "AZN": [void 0, "\u20BC"],
      "BAM": [void 0, "KM"],
      "BBD": [void 0, "$"],
      "BDT": [void 0, "\u09F3"],
      "BHD": [void 0, void 0, 3],
      "BIF": [void 0, void 0, 0],
      "BMD": [void 0, "$"],
      "BND": [void 0, "$"],
      "BOB": [void 0, "Bs"],
      "BRL": ["R$"],
      "BSD": [void 0, "$"],
      "BWP": [void 0, "P"],
      "BYN": [void 0, void 0, 2],
      "BYR": [void 0, void 0, 0],
      "BZD": [void 0, "$"],
      "CAD": ["CA$", "$", 2],
      "CHF": [void 0, void 0, 2],
      "CLF": [void 0, void 0, 4],
      "CLP": [void 0, "$", 0],
      "CNY": ["CN\xA5", "\xA5"],
      "COP": [void 0, "$", 2],
      "CRC": [void 0, "\u20A1", 2],
      "CUC": [void 0, "$"],
      "CUP": [void 0, "$"],
      "CZK": [void 0, "K\u010D", 2],
      "DJF": [void 0, void 0, 0],
      "DKK": [void 0, "kr", 2],
      "DOP": [void 0, "$"],
      "EGP": [void 0, "E\xA3"],
      "ESP": [void 0, "\u20A7", 0],
      "EUR": ["\u20AC"],
      "FJD": [void 0, "$"],
      "FKP": [void 0, "\xA3"],
      "GBP": ["\xA3"],
      "GEL": [void 0, "\u20BE"],
      "GHS": [void 0, "GH\u20B5"],
      "GIP": [void 0, "\xA3"],
      "GNF": [void 0, "FG", 0],
      "GTQ": [void 0, "Q"],
      "GYD": [void 0, "$", 2],
      "HKD": ["HK$", "$"],
      "HNL": [void 0, "L"],
      "HRK": [void 0, "kn"],
      "HUF": [void 0, "Ft", 2],
      "IDR": [void 0, "Rp", 2],
      "ILS": ["\u20AA"],
      "INR": ["\u20B9"],
      "IQD": [void 0, void 0, 0],
      "IRR": [void 0, void 0, 0],
      "ISK": [void 0, "kr", 0],
      "ITL": [void 0, void 0, 0],
      "JMD": [void 0, "$"],
      "JOD": [void 0, void 0, 3],
      "JPY": ["\xA5", void 0, 0],
      "KHR": [void 0, "\u17DB"],
      "KMF": [void 0, "CF", 0],
      "KPW": [void 0, "\u20A9", 0],
      "KRW": ["\u20A9", void 0, 0],
      "KWD": [void 0, void 0, 3],
      "KYD": [void 0, "$"],
      "KZT": [void 0, "\u20B8"],
      "LAK": [void 0, "\u20AD", 0],
      "LBP": [void 0, "L\xA3", 0],
      "LKR": [void 0, "Rs"],
      "LRD": [void 0, "$"],
      "LTL": [void 0, "Lt"],
      "LUF": [void 0, void 0, 0],
      "LVL": [void 0, "Ls"],
      "LYD": [void 0, void 0, 3],
      "MGA": [void 0, "Ar", 0],
      "MGF": [void 0, void 0, 0],
      "MMK": [void 0, "K", 0],
      "MNT": [void 0, "\u20AE", 2],
      "MRO": [void 0, void 0, 0],
      "MUR": [void 0, "Rs", 2],
      "MXN": ["MX$", "$"],
      "MYR": [void 0, "RM"],
      "NAD": [void 0, "$"],
      "NGN": [void 0, "\u20A6"],
      "NIO": [void 0, "C$"],
      "NOK": [void 0, "kr", 2],
      "NPR": [void 0, "Rs"],
      "NZD": ["NZ$", "$"],
      "OMR": [void 0, void 0, 3],
      "PHP": ["\u20B1"],
      "PKR": [void 0, "Rs", 2],
      "PLN": [void 0, "z\u0142"],
      "PYG": [void 0, "\u20B2", 0],
      "RON": [void 0, "lei"],
      "RSD": [void 0, void 0, 0],
      "RUB": [void 0, "\u20BD"],
      "RWF": [void 0, "RF", 0],
      "SBD": [void 0, "$"],
      "SEK": [void 0, "kr", 2],
      "SGD": [void 0, "$"],
      "SHP": [void 0, "\xA3"],
      "SLE": [void 0, void 0, 2],
      "SLL": [void 0, void 0, 0],
      "SOS": [void 0, void 0, 0],
      "SRD": [void 0, "$"],
      "SSP": [void 0, "\xA3"],
      "STD": [void 0, void 0, 0],
      "STN": [void 0, "Db"],
      "SYP": [void 0, "\xA3", 0],
      "THB": [void 0, "\u0E3F"],
      "TMM": [void 0, void 0, 0],
      "TND": [void 0, void 0, 3],
      "TOP": [void 0, "T$"],
      "TRL": [void 0, void 0, 0],
      "TRY": [void 0, "\u20BA"],
      "TTD": [void 0, "$"],
      "TWD": ["NT$", "$", 2],
      "TZS": [void 0, void 0, 2],
      "UAH": [void 0, "\u20B4"],
      "UGX": [void 0, void 0, 0],
      "USD": ["$"],
      "UYI": [void 0, void 0, 0],
      "UYU": [void 0, "$"],
      "UYW": [void 0, void 0, 4],
      "UZS": [void 0, void 0, 2],
      "VEF": [void 0, "Bs", 2],
      "VND": ["\u20AB", void 0, 0],
      "VUV": [void 0, void 0, 0],
      "XAF": ["FCFA", void 0, 0],
      "XCD": ["EC$", "$"],
      "XOF": ["F\u202FCFA", void 0, 0],
      "XPF": ["CFPF", void 0, 0],
      "XXX": ["\xA4"],
      "YER": [void 0, void 0, 0],
      "ZAR": [void 0, "R"],
      "ZMK": [void 0, void 0, 0],
      "ZMW": [void 0, "ZK"],
      "ZWD": [void 0, void 0, 0]
    };
    (function(NumberFormatStyle2) {
      NumberFormatStyle2[NumberFormatStyle2["Decimal"] = 0] = "Decimal";
      NumberFormatStyle2[NumberFormatStyle2["Percent"] = 1] = "Percent";
      NumberFormatStyle2[NumberFormatStyle2["Currency"] = 2] = "Currency";
      NumberFormatStyle2[NumberFormatStyle2["Scientific"] = 3] = "Scientific";
    })(NumberFormatStyle || (NumberFormatStyle = {}));
    (function(Plural2) {
      Plural2[Plural2["Zero"] = 0] = "Zero";
      Plural2[Plural2["One"] = 1] = "One";
      Plural2[Plural2["Two"] = 2] = "Two";
      Plural2[Plural2["Few"] = 3] = "Few";
      Plural2[Plural2["Many"] = 4] = "Many";
      Plural2[Plural2["Other"] = 5] = "Other";
    })(Plural || (Plural = {}));
    (function(FormStyle2) {
      FormStyle2[FormStyle2["Format"] = 0] = "Format";
      FormStyle2[FormStyle2["Standalone"] = 1] = "Standalone";
    })(FormStyle || (FormStyle = {}));
    (function(TranslationWidth2) {
      TranslationWidth2[TranslationWidth2["Narrow"] = 0] = "Narrow";
      TranslationWidth2[TranslationWidth2["Abbreviated"] = 1] = "Abbreviated";
      TranslationWidth2[TranslationWidth2["Wide"] = 2] = "Wide";
      TranslationWidth2[TranslationWidth2["Short"] = 3] = "Short";
    })(TranslationWidth || (TranslationWidth = {}));
    (function(FormatWidth2) {
      FormatWidth2[FormatWidth2["Short"] = 0] = "Short";
      FormatWidth2[FormatWidth2["Medium"] = 1] = "Medium";
      FormatWidth2[FormatWidth2["Long"] = 2] = "Long";
      FormatWidth2[FormatWidth2["Full"] = 3] = "Full";
    })(FormatWidth || (FormatWidth = {}));
    NumberSymbol = {
      /**
       * Decimal separator.
       * For `en-US`, the dot character.
       * Example: 2,345`.`67
       */
      Decimal: 0,
      /**
       * Grouping separator, typically for thousands.
       * For `en-US`, the comma character.
       * Example: 2`,`345.67
       */
      Group: 1,
      /**
       * List-item separator.
       * Example: "one, two, and three"
       */
      List: 2,
      /**
       * Sign for percentage (out of 100).
       * Example: 23.4%
       */
      PercentSign: 3,
      /**
       * Sign for positive numbers.
       * Example: +23
       */
      PlusSign: 4,
      /**
       * Sign for negative numbers.
       * Example: -23
       */
      MinusSign: 5,
      /**
       * Computer notation for exponential value (n times a power of 10).
       * Example: 1.2E3
       */
      Exponential: 6,
      /**
       * Human-readable format of exponential.
       * Example: 1.2x103
       */
      SuperscriptingExponent: 7,
      /**
       * Sign for permille (out of 1000).
       * Example: 23.4‰
       */
      PerMille: 8,
      /**
       * Infinity, can be used with plus and minus.
       * Example: ∞, +∞, -∞
       */
      Infinity: 9,
      /**
       * Not a number.
       * Example: NaN
       */
      NaN: 10,
      /**
       * Symbol used between time units.
       * Example: 10:52
       */
      TimeSeparator: 11,
      /**
       * Decimal separator for currency values (fallback to `Decimal`).
       * Example: $2,345.67
       */
      CurrencyDecimal: 12,
      /**
       * Group separator for currency values (fallback to `Group`).
       * Example: $2,345.67
       */
      CurrencyGroup: 13
    };
    (function(WeekDay2) {
      WeekDay2[WeekDay2["Sunday"] = 0] = "Sunday";
      WeekDay2[WeekDay2["Monday"] = 1] = "Monday";
      WeekDay2[WeekDay2["Tuesday"] = 2] = "Tuesday";
      WeekDay2[WeekDay2["Wednesday"] = 3] = "Wednesday";
      WeekDay2[WeekDay2["Thursday"] = 4] = "Thursday";
      WeekDay2[WeekDay2["Friday"] = 5] = "Friday";
      WeekDay2[WeekDay2["Saturday"] = 6] = "Saturday";
    })(WeekDay || (WeekDay = {}));
    getLocalePluralCase2 = getLocalePluralCase;
    DEFAULT_NB_OF_CURRENCY_DIGITS = 2;
    ISO8601_DATE_REGEX = /^(\d{4,})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
    NAMED_FORMATS = {};
    DATE_FORMATS_SPLIT = /((?:[^BEGHLMOSWYZabcdhmswyz']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|c{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/;
    JANUARY = 0;
    THURSDAY = 4;
    DATE_FORMATS = {};
    NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
    MAX_DIGITS = 22;
    DECIMAL_SEP = ".";
    ZERO_CHAR = "0";
    PATTERN_SEP = ";";
    GROUP_SEP = ",";
    DIGIT_CHAR = "#";
    CURRENCY_CHAR = "\xA4";
    PERCENT_CHAR = "%";
    NgLocalization = class _NgLocalization {
      static \u0275fac = function NgLocalization_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgLocalization)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _NgLocalization,
        factory: function NgLocalization_Factory(__ngFactoryType__) {
          let __ngConditionalFactory__ = null;
          if (__ngFactoryType__) {
            __ngConditionalFactory__ = new __ngFactoryType__();
          } else {
            __ngConditionalFactory__ = ((locale) => new NgLocaleLocalization(locale))(\u0275\u0275inject(LOCALE_ID));
          }
          return __ngConditionalFactory__;
        },
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgLocalization, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: (locale) => new NgLocaleLocalization(locale),
          deps: [LOCALE_ID]
        }]
      }], null, null);
    })();
    NgLocaleLocalization = class _NgLocaleLocalization extends NgLocalization {
      locale;
      constructor(locale) {
        super();
        this.locale = locale;
      }
      getPluralCategory(value, locale) {
        const plural2 = getLocalePluralCase2(locale || this.locale)(value);
        switch (plural2) {
          case Plural.Zero:
            return "zero";
          case Plural.One:
            return "one";
          case Plural.Two:
            return "two";
          case Plural.Few:
            return "few";
          case Plural.Many:
            return "many";
          default:
            return "other";
        }
      }
      static \u0275fac = function NgLocaleLocalization_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgLocaleLocalization)(\u0275\u0275inject(LOCALE_ID));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _NgLocaleLocalization,
        factory: _NgLocaleLocalization.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgLocaleLocalization, [{
        type: Injectable
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [LOCALE_ID]
        }]
      }], null);
    })();
    WS_REGEXP = /\s+/;
    EMPTY_ARRAY2 = [];
    NgClass = class _NgClass {
      _ngEl;
      _renderer;
      initialClasses = EMPTY_ARRAY2;
      rawClass;
      stateMap = /* @__PURE__ */ new Map();
      constructor(_ngEl, _renderer) {
        this._ngEl = _ngEl;
        this._renderer = _renderer;
      }
      set klass(value) {
        this.initialClasses = value != null ? value.trim().split(WS_REGEXP) : EMPTY_ARRAY2;
      }
      set ngClass(value) {
        this.rawClass = typeof value === "string" ? value.trim().split(WS_REGEXP) : value;
      }
      /*
      The NgClass directive uses the custom change detection algorithm for its inputs. The custom
      algorithm is necessary since inputs are represented as complex object or arrays that need to be
      deeply-compared.
         This algorithm is perf-sensitive since NgClass is used very frequently and its poor performance
      might negatively impact runtime performance of the entire change detection cycle. The design of
      this algorithm is making sure that:
      - there is no unnecessary DOM manipulation (CSS classes are added / removed from the DOM only when
      needed), even if references to bound objects change;
      - there is no memory allocation if nothing changes (even relatively modest memory allocation
      during the change detection cycle can result in GC pauses for some of the CD cycles).
         The algorithm works by iterating over the set of bound classes, staring with [class] binding and
      then going over [ngClass] binding. For each CSS class name:
      - check if it was seen before (this information is tracked in the state map) and if its value
      changed;
      - mark it as "touched" - names that are not marked are not present in the latest set of binding
      and we can remove such class name from the internal data structures;
         After iteration over all the CSS class names we've got data structure with all the information
      necessary to synchronize changes to the DOM - it is enough to iterate over the state map, flush
      changes to the DOM and reset internal data structures so those are ready for the next change
      detection cycle.
       */
      ngDoCheck() {
        for (const klass of this.initialClasses) {
          this._updateState(klass, true);
        }
        const rawClass = this.rawClass;
        if (Array.isArray(rawClass) || rawClass instanceof Set) {
          for (const klass of rawClass) {
            this._updateState(klass, true);
          }
        } else if (rawClass != null) {
          for (const klass of Object.keys(rawClass)) {
            this._updateState(klass, Boolean(rawClass[klass]));
          }
        }
        this._applyStateDiff();
      }
      _updateState(klass, nextEnabled) {
        const state = this.stateMap.get(klass);
        if (state !== void 0) {
          if (state.enabled !== nextEnabled) {
            state.changed = true;
            state.enabled = nextEnabled;
          }
          state.touched = true;
        } else {
          this.stateMap.set(klass, {
            enabled: nextEnabled,
            changed: true,
            touched: true
          });
        }
      }
      _applyStateDiff() {
        for (const stateEntry of this.stateMap) {
          const klass = stateEntry[0];
          const state = stateEntry[1];
          if (state.changed) {
            this._toggleClass(klass, state.enabled);
            state.changed = false;
          } else if (!state.touched) {
            if (state.enabled) {
              this._toggleClass(klass, false);
            }
            this.stateMap.delete(klass);
          }
          state.touched = false;
        }
      }
      _toggleClass(klass, enabled) {
        if (ngDevMode) {
          if (typeof klass !== "string") {
            throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${stringify(klass)}`);
          }
        }
        klass = klass.trim();
        if (klass.length > 0) {
          klass.split(WS_REGEXP).forEach((klass2) => {
            if (enabled) {
              this._renderer.addClass(this._ngEl.nativeElement, klass2);
            } else {
              this._renderer.removeClass(this._ngEl.nativeElement, klass2);
            }
          });
        }
      }
      static \u0275fac = function NgClass_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgClass)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgClass,
        selectors: [["", "ngClass", ""]],
        inputs: {
          klass: [0, "class", "klass"],
          ngClass: "ngClass"
        }
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgClass, [{
        type: Directive,
        args: [{
          selector: "[ngClass]"
        }]
      }], () => [{
        type: ElementRef
      }, {
        type: Renderer2
      }], {
        klass: [{
          type: Input,
          args: ["class"]
        }],
        ngClass: [{
          type: Input,
          args: ["ngClass"]
        }]
      });
    })();
    NgComponentOutlet = class _NgComponentOutlet {
      _viewContainerRef;
      // TODO(crisbeto): this should be `Type<T>`, but doing so broke a few
      // targets in a TGP so we need to do it in a major version.
      /** Component that should be rendered in the outlet. */
      ngComponentOutlet = null;
      ngComponentOutletInputs;
      ngComponentOutletInjector;
      ngComponentOutletEnvironmentInjector;
      ngComponentOutletContent;
      ngComponentOutletNgModule;
      /**
       * @deprecated This input is deprecated, use `ngComponentOutletNgModule` instead.
       */
      ngComponentOutletNgModuleFactory;
      _componentRef;
      _moduleRef;
      /**
       * A helper data structure that allows us to track inputs that were part of the
       * ngComponentOutletInputs expression. Tracking inputs is necessary for proper removal of ones
       * that are no longer referenced.
       */
      _inputsUsed = /* @__PURE__ */ new Map();
      /**
       * Gets the instance of the currently-rendered component.
       * Will be null if no component has been rendered.
       */
      get componentInstance() {
        return this._componentRef?.instance ?? null;
      }
      constructor(_viewContainerRef) {
        this._viewContainerRef = _viewContainerRef;
      }
      _needToReCreateNgModuleInstance(changes) {
        return changes["ngComponentOutletNgModule"] !== void 0 || changes["ngComponentOutletNgModuleFactory"] !== void 0;
      }
      _needToReCreateComponentInstance(changes) {
        return changes["ngComponentOutlet"] !== void 0 || changes["ngComponentOutletContent"] !== void 0 || changes["ngComponentOutletInjector"] !== void 0 || changes["ngComponentOutletEnvironmentInjector"] !== void 0 || this._needToReCreateNgModuleInstance(changes);
      }
      /** @docs-private */
      ngOnChanges(changes) {
        if (this._needToReCreateComponentInstance(changes)) {
          this._viewContainerRef.clear();
          this._inputsUsed.clear();
          this._componentRef = void 0;
          if (this.ngComponentOutlet) {
            const injector = this.ngComponentOutletInjector || this._viewContainerRef.parentInjector;
            if (this._needToReCreateNgModuleInstance(changes)) {
              this._moduleRef?.destroy();
              if (this.ngComponentOutletNgModule) {
                this._moduleRef = createNgModule(this.ngComponentOutletNgModule, getParentInjector(injector));
              } else if (this.ngComponentOutletNgModuleFactory) {
                this._moduleRef = this.ngComponentOutletNgModuleFactory.create(getParentInjector(injector));
              } else {
                this._moduleRef = void 0;
              }
            }
            this._componentRef = this._viewContainerRef.createComponent(this.ngComponentOutlet, {
              injector,
              ngModuleRef: this._moduleRef,
              projectableNodes: this.ngComponentOutletContent,
              environmentInjector: this.ngComponentOutletEnvironmentInjector
            });
          }
        }
      }
      /** @docs-private */
      ngDoCheck() {
        if (this._componentRef) {
          if (this.ngComponentOutletInputs) {
            for (const inputName of Object.keys(this.ngComponentOutletInputs)) {
              this._inputsUsed.set(inputName, true);
            }
          }
          this._applyInputStateDiff(this._componentRef);
        }
      }
      /** @docs-private */
      ngOnDestroy() {
        this._moduleRef?.destroy();
      }
      _applyInputStateDiff(componentRef) {
        for (const [inputName, touched] of this._inputsUsed) {
          if (!touched) {
            componentRef.setInput(inputName, void 0);
            this._inputsUsed.delete(inputName);
          } else {
            componentRef.setInput(inputName, this.ngComponentOutletInputs[inputName]);
            this._inputsUsed.set(inputName, false);
          }
        }
      }
      static \u0275fac = function NgComponentOutlet_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgComponentOutlet)(\u0275\u0275directiveInject(ViewContainerRef));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgComponentOutlet,
        selectors: [["", "ngComponentOutlet", ""]],
        inputs: {
          ngComponentOutlet: "ngComponentOutlet",
          ngComponentOutletInputs: "ngComponentOutletInputs",
          ngComponentOutletInjector: "ngComponentOutletInjector",
          ngComponentOutletEnvironmentInjector: "ngComponentOutletEnvironmentInjector",
          ngComponentOutletContent: "ngComponentOutletContent",
          ngComponentOutletNgModule: "ngComponentOutletNgModule",
          ngComponentOutletNgModuleFactory: "ngComponentOutletNgModuleFactory"
        },
        exportAs: ["ngComponentOutlet"],
        features: [\u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgComponentOutlet, [{
        type: Directive,
        args: [{
          selector: "[ngComponentOutlet]",
          exportAs: "ngComponentOutlet"
        }]
      }], () => [{
        type: ViewContainerRef
      }], {
        ngComponentOutlet: [{
          type: Input
        }],
        ngComponentOutletInputs: [{
          type: Input
        }],
        ngComponentOutletInjector: [{
          type: Input
        }],
        ngComponentOutletEnvironmentInjector: [{
          type: Input
        }],
        ngComponentOutletContent: [{
          type: Input
        }],
        ngComponentOutletNgModule: [{
          type: Input
        }],
        ngComponentOutletNgModuleFactory: [{
          type: Input
        }]
      });
    })();
    NgForOfContext = class {
      $implicit;
      ngForOf;
      index;
      count;
      constructor($implicit, ngForOf, index, count) {
        this.$implicit = $implicit;
        this.ngForOf = ngForOf;
        this.index = index;
        this.count = count;
      }
      // Indicates whether this is the first item in the collection.
      get first() {
        return this.index === 0;
      }
      // Indicates whether this is the last item in the collection.
      get last() {
        return this.index === this.count - 1;
      }
      // Indicates whether an index of this item in the collection is even.
      get even() {
        return this.index % 2 === 0;
      }
      // Indicates whether an index of this item in the collection is odd.
      get odd() {
        return !this.even;
      }
    };
    NgForOf = class _NgForOf {
      _viewContainer;
      _template;
      _differs;
      /**
       * The value of the iterable expression, which can be used as a
       * [template input variable](guide/directives/structural-directives#shorthand).
       * @deprecated The `ngFor` directive is deprecated. Use the `@for` block instead.
       */
      set ngForOf(ngForOf) {
        this._ngForOf = ngForOf;
        this._ngForOfDirty = true;
      }
      /**
       * Specifies a custom `TrackByFunction` to compute the identity of items in an iterable.
       *
       * If a custom `TrackByFunction` is not provided, `NgForOf` will use the item's [object
       * identity](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)
       * as the key.
       *
       * `NgForOf` uses the computed key to associate items in an iterable with DOM elements
       * it produces for these items.
       *
       * A custom `TrackByFunction` is useful to provide good user experience in cases when items in an
       * iterable rendered using `NgForOf` have a natural identifier (for example, custom ID or a
       * primary key), and this iterable could be updated with new object instances that still
       * represent the same underlying entity (for example, when data is re-fetched from the server,
       * and the iterable is recreated and re-rendered, but most of the data is still the same).
       *
       * @see {@link TrackByFunction}
       * @deprecated The `ngFor` directive is deprecated. Use the `@for` block instead.
       */
      set ngForTrackBy(fn) {
        if ((typeof ngDevMode === "undefined" || ngDevMode) && fn != null && typeof fn !== "function") {
          console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}. See https://angular.dev/api/common/NgForOf#change-propagation for more information.`);
        }
        this._trackByFn = fn;
      }
      get ngForTrackBy() {
        return this._trackByFn;
      }
      _ngForOf = null;
      _ngForOfDirty = true;
      _differ = null;
      // waiting for microsoft/typescript#43662 to allow the return type `TrackByFunction|undefined` for
      // the getter
      _trackByFn;
      constructor(_viewContainer, _template, _differs) {
        this._viewContainer = _viewContainer;
        this._template = _template;
        this._differs = _differs;
      }
      /**
       * A reference to the template that is stamped out for each item in the iterable.
       * @see [template reference variable](guide/templates/variables#template-reference-variables)
       * @deprecated The `ngFor` directive is deprecated. Use the `@for` block instead.
       */
      set ngForTemplate(value) {
        if (value) {
          this._template = value;
        }
      }
      /**
       * Applies the changes when needed.
       * @docs-private
       */
      ngDoCheck() {
        if (this._ngForOfDirty) {
          this._ngForOfDirty = false;
          const value = this._ngForOf;
          if (!this._differ && value) {
            if (typeof ngDevMode === "undefined" || ngDevMode) {
              try {
                this._differ = this._differs.find(value).create(this.ngForTrackBy);
              } catch {
                let errorMessage = `Cannot find a differ supporting object '${value}' of type '${getTypeName(value)}'. NgFor only supports binding to Iterables, such as Arrays.`;
                if (typeof value === "object") {
                  errorMessage += " Did you mean to use the keyvalue pipe?";
                }
                throw new RuntimeError(-2200, errorMessage);
              }
            } else {
              this._differ = this._differs.find(value).create(this.ngForTrackBy);
            }
          }
        }
        if (this._differ) {
          const changes = this._differ.diff(this._ngForOf);
          if (changes) this._applyChanges(changes);
        }
      }
      _applyChanges(changes) {
        const viewContainer = this._viewContainer;
        changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
          if (item.previousIndex == null) {
            viewContainer.createEmbeddedView(this._template, new NgForOfContext(item.item, this._ngForOf, -1, -1), currentIndex === null ? void 0 : currentIndex);
          } else if (currentIndex == null) {
            viewContainer.remove(adjustedPreviousIndex === null ? void 0 : adjustedPreviousIndex);
          } else if (adjustedPreviousIndex !== null) {
            const view = viewContainer.get(adjustedPreviousIndex);
            viewContainer.move(view, currentIndex);
            applyViewChange(view, item);
          }
        });
        for (let i2 = 0, ilen = viewContainer.length; i2 < ilen; i2++) {
          const viewRef = viewContainer.get(i2);
          const context2 = viewRef.context;
          context2.index = i2;
          context2.count = ilen;
          context2.ngForOf = this._ngForOf;
        }
        changes.forEachIdentityChange((record) => {
          const viewRef = viewContainer.get(record.currentIndex);
          applyViewChange(viewRef, record);
        });
      }
      /**
       * Asserts the correct type of the context for the template that `NgForOf` will render.
       *
       * The presence of this method is a signal to the Ivy template type-check compiler that the
       * `NgForOf` structural directive renders its template with a specific context type.
       */
      static ngTemplateContextGuard(dir, ctx) {
        return true;
      }
      static \u0275fac = function NgForOf_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgForOf)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(IterableDiffers));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgForOf,
        selectors: [["", "ngFor", "", "ngForOf", ""]],
        inputs: {
          ngForOf: "ngForOf",
          ngForTrackBy: "ngForTrackBy",
          ngForTemplate: "ngForTemplate"
        }
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgForOf, [{
        type: Directive,
        args: [{
          selector: "[ngFor][ngForOf]"
        }]
      }], () => [{
        type: ViewContainerRef
      }, {
        type: TemplateRef
      }, {
        type: IterableDiffers
      }], {
        ngForOf: [{
          type: Input
        }],
        ngForTrackBy: [{
          type: Input
        }],
        ngForTemplate: [{
          type: Input
        }]
      });
    })();
    NgIf = class _NgIf {
      _viewContainer;
      _context = new NgIfContext();
      _thenTemplateRef = null;
      _elseTemplateRef = null;
      _thenViewRef = null;
      _elseViewRef = null;
      constructor(_viewContainer, templateRef) {
        this._viewContainer = _viewContainer;
        this._thenTemplateRef = templateRef;
      }
      /**
       * The Boolean expression to evaluate as the condition for showing a template.
       * @deprecated Use the `@if` block instead. Intent to remove in v22
       */
      set ngIf(condition) {
        this._context.$implicit = this._context.ngIf = condition;
        this._updateView();
      }
      /**
       * A template to show if the condition expression evaluates to true.
       * @deprecated Use the `@if` block instead. Intent to remove in v22
       */
      set ngIfThen(templateRef) {
        assertTemplate(templateRef, (typeof ngDevMode === "undefined" || ngDevMode) && "ngIfThen");
        this._thenTemplateRef = templateRef;
        this._thenViewRef = null;
        this._updateView();
      }
      /**
       * A template to show if the condition expression evaluates to false.
       * @deprecated Use the `@if` block instead. Intent to remove in v22
       */
      set ngIfElse(templateRef) {
        assertTemplate(templateRef, (typeof ngDevMode === "undefined" || ngDevMode) && "ngIfElse");
        this._elseTemplateRef = templateRef;
        this._elseViewRef = null;
        this._updateView();
      }
      _updateView() {
        if (this._context.$implicit) {
          if (!this._thenViewRef) {
            this._viewContainer.clear();
            this._elseViewRef = null;
            if (this._thenTemplateRef) {
              this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context);
            }
          }
        } else {
          if (!this._elseViewRef) {
            this._viewContainer.clear();
            this._thenViewRef = null;
            if (this._elseTemplateRef) {
              this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context);
            }
          }
        }
      }
      /** @internal */
      static ngIfUseIfTypeGuard;
      /**
       * Assert the correct type of the expression bound to the `ngIf` input within the template.
       *
       * The presence of this static field is a signal to the Ivy template type check compiler that
       * when the `NgIf` structural directive renders its template, the type of the expression bound
       * to `ngIf` should be narrowed in some way. For `NgIf`, the binding expression itself is used to
       * narrow its type, which allows the strictNullChecks feature of TypeScript to work with `NgIf`.
       */
      static ngTemplateGuard_ngIf;
      /**
       * Asserts the correct type of the context for the template that `NgIf` will render.
       *
       * The presence of this method is a signal to the Ivy template type-check compiler that the
       * `NgIf` structural directive renders its template with a specific context type.
       */
      static ngTemplateContextGuard(dir, ctx) {
        return true;
      }
      static \u0275fac = function NgIf_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgIf)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgIf,
        selectors: [["", "ngIf", ""]],
        inputs: {
          ngIf: "ngIf",
          ngIfThen: "ngIfThen",
          ngIfElse: "ngIfElse"
        }
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgIf, [{
        type: Directive,
        args: [{
          selector: "[ngIf]"
        }]
      }], () => [{
        type: ViewContainerRef
      }, {
        type: TemplateRef
      }], {
        ngIf: [{
          type: Input
        }],
        ngIfThen: [{
          type: Input
        }],
        ngIfElse: [{
          type: Input
        }]
      });
    })();
    NgIfContext = class {
      $implicit = null;
      ngIf = null;
    };
    SwitchView = class {
      _viewContainerRef;
      _templateRef;
      _created = false;
      constructor(_viewContainerRef, _templateRef) {
        this._viewContainerRef = _viewContainerRef;
        this._templateRef = _templateRef;
      }
      create() {
        this._created = true;
        this._viewContainerRef.createEmbeddedView(this._templateRef);
      }
      destroy() {
        this._created = false;
        this._viewContainerRef.clear();
      }
      enforceState(created) {
        if (created && !this._created) {
          this.create();
        } else if (!created && this._created) {
          this.destroy();
        }
      }
    };
    NgSwitch = class _NgSwitch {
      _defaultViews = [];
      _defaultUsed = false;
      _caseCount = 0;
      _lastCaseCheckIndex = 0;
      _lastCasesMatched = false;
      _ngSwitch;
      /** @deprecated Use the `@switch` block instead. Intent to remove in v22 */
      set ngSwitch(newValue) {
        this._ngSwitch = newValue;
        if (this._caseCount === 0) {
          this._updateDefaultCases(true);
        }
      }
      /** @internal */
      _addCase() {
        return this._caseCount++;
      }
      /** @internal */
      _addDefault(view) {
        this._defaultViews.push(view);
      }
      /** @internal */
      _matchCase(value) {
        const matched = value === this._ngSwitch;
        this._lastCasesMatched ||= matched;
        this._lastCaseCheckIndex++;
        if (this._lastCaseCheckIndex === this._caseCount) {
          this._updateDefaultCases(!this._lastCasesMatched);
          this._lastCaseCheckIndex = 0;
          this._lastCasesMatched = false;
        }
        return matched;
      }
      _updateDefaultCases(useDefault) {
        if (this._defaultViews.length > 0 && useDefault !== this._defaultUsed) {
          this._defaultUsed = useDefault;
          for (const defaultView of this._defaultViews) {
            defaultView.enforceState(useDefault);
          }
        }
      }
      static \u0275fac = function NgSwitch_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgSwitch)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgSwitch,
        selectors: [["", "ngSwitch", ""]],
        inputs: {
          ngSwitch: "ngSwitch"
        }
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitch, [{
        type: Directive,
        args: [{
          selector: "[ngSwitch]"
        }]
      }], null, {
        ngSwitch: [{
          type: Input
        }]
      });
    })();
    NgSwitchCase = class _NgSwitchCase {
      ngSwitch;
      _view;
      /**
       * Stores the HTML template to be selected on match.
       * @deprecated Use the `@case` block within a `@switch` block instead. Intent to remove in v22
       */
      ngSwitchCase;
      constructor(viewContainer, templateRef, ngSwitch) {
        this.ngSwitch = ngSwitch;
        if ((typeof ngDevMode === "undefined" || ngDevMode) && !ngSwitch) {
          throwNgSwitchProviderNotFoundError("ngSwitchCase", "NgSwitchCase");
        }
        ngSwitch._addCase();
        this._view = new SwitchView(viewContainer, templateRef);
      }
      /**
       * Performs case matching. For internal use only.
       * @docs-private
       */
      ngDoCheck() {
        this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase));
      }
      static \u0275fac = function NgSwitchCase_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgSwitchCase)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(NgSwitch, 9));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgSwitchCase,
        selectors: [["", "ngSwitchCase", ""]],
        inputs: {
          ngSwitchCase: "ngSwitchCase"
        }
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitchCase, [{
        type: Directive,
        args: [{
          selector: "[ngSwitchCase]"
        }]
      }], () => [{
        type: ViewContainerRef
      }, {
        type: TemplateRef
      }, {
        type: NgSwitch,
        decorators: [{
          type: Optional
        }, {
          type: Host
        }]
      }], {
        ngSwitchCase: [{
          type: Input
        }]
      });
    })();
    NgSwitchDefault = class _NgSwitchDefault {
      constructor(viewContainer, templateRef, ngSwitch) {
        if ((typeof ngDevMode === "undefined" || ngDevMode) && !ngSwitch) {
          throwNgSwitchProviderNotFoundError("ngSwitchDefault", "NgSwitchDefault");
        }
        ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));
      }
      static \u0275fac = function NgSwitchDefault_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgSwitchDefault)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(NgSwitch, 9));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgSwitchDefault,
        selectors: [["", "ngSwitchDefault", ""]]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitchDefault, [{
        type: Directive,
        args: [{
          selector: "[ngSwitchDefault]"
        }]
      }], () => [{
        type: ViewContainerRef
      }, {
        type: TemplateRef
      }, {
        type: NgSwitch,
        decorators: [{
          type: Optional
        }, {
          type: Host
        }]
      }], null);
    })();
    NgPlural = class _NgPlural {
      _localization;
      _activeView;
      _caseViews = {};
      constructor(_localization) {
        this._localization = _localization;
      }
      set ngPlural(value) {
        this._updateView(value);
      }
      addCase(value, switchView) {
        this._caseViews[value] = switchView;
      }
      _updateView(switchValue) {
        this._clearViews();
        const cases = Object.keys(this._caseViews);
        const key = getPluralCategory(switchValue, cases, this._localization);
        this._activateView(this._caseViews[key]);
      }
      _clearViews() {
        if (this._activeView) this._activeView.destroy();
      }
      _activateView(view) {
        if (view) {
          this._activeView = view;
          this._activeView.create();
        }
      }
      static \u0275fac = function NgPlural_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgPlural)(\u0275\u0275directiveInject(NgLocalization));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgPlural,
        selectors: [["", "ngPlural", ""]],
        inputs: {
          ngPlural: "ngPlural"
        }
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgPlural, [{
        type: Directive,
        args: [{
          selector: "[ngPlural]"
        }]
      }], () => [{
        type: NgLocalization
      }], {
        ngPlural: [{
          type: Input
        }]
      });
    })();
    NgPluralCase = class _NgPluralCase {
      value;
      constructor(value, template, viewContainer, ngPlural) {
        this.value = value;
        const isANumber = !isNaN(Number(value));
        ngPlural.addCase(isANumber ? `=${value}` : value, new SwitchView(viewContainer, template));
      }
      static \u0275fac = function NgPluralCase_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgPluralCase)(\u0275\u0275injectAttribute("ngPluralCase"), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(NgPlural, 1));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgPluralCase,
        selectors: [["", "ngPluralCase", ""]]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgPluralCase, [{
        type: Directive,
        args: [{
          selector: "[ngPluralCase]"
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Attribute,
          args: ["ngPluralCase"]
        }]
      }, {
        type: TemplateRef
      }, {
        type: ViewContainerRef
      }, {
        type: NgPlural,
        decorators: [{
          type: Host
        }]
      }], null);
    })();
    NgStyle = class _NgStyle {
      _ngEl;
      _differs;
      _renderer;
      _ngStyle = null;
      _differ = null;
      constructor(_ngEl, _differs, _renderer) {
        this._ngEl = _ngEl;
        this._differs = _differs;
        this._renderer = _renderer;
      }
      set ngStyle(values) {
        this._ngStyle = values;
        if (!this._differ && values) {
          this._differ = this._differs.find(values).create();
        }
      }
      ngDoCheck() {
        if (this._differ) {
          const changes = this._differ.diff(this._ngStyle);
          if (changes) {
            this._applyChanges(changes);
          }
        }
      }
      _setStyle(nameAndUnit, value) {
        const [name, unit] = nameAndUnit.split(".");
        const flags = name.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
        if (value != null) {
          this._renderer.setStyle(this._ngEl.nativeElement, name, unit ? `${value}${unit}` : value, flags);
        } else {
          this._renderer.removeStyle(this._ngEl.nativeElement, name, flags);
        }
      }
      _applyChanges(changes) {
        changes.forEachRemovedItem((record) => this._setStyle(record.key, null));
        changes.forEachAddedItem((record) => this._setStyle(record.key, record.currentValue));
        changes.forEachChangedItem((record) => this._setStyle(record.key, record.currentValue));
      }
      static \u0275fac = function NgStyle_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgStyle)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(KeyValueDiffers), \u0275\u0275directiveInject(Renderer2));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgStyle,
        selectors: [["", "ngStyle", ""]],
        inputs: {
          ngStyle: "ngStyle"
        }
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgStyle, [{
        type: Directive,
        args: [{
          selector: "[ngStyle]"
        }]
      }], () => [{
        type: ElementRef
      }, {
        type: KeyValueDiffers
      }, {
        type: Renderer2
      }], {
        ngStyle: [{
          type: Input,
          args: ["ngStyle"]
        }]
      });
    })();
    NgTemplateOutlet = class _NgTemplateOutlet {
      _viewContainerRef;
      _viewRef = null;
      /**
       * A context object to attach to the {@link EmbeddedViewRef}. This should be an
       * object, the object's keys will be available for binding by the local template `let`
       * declarations.
       * Using the key `$implicit` in the context object will set its value as default.
       */
      ngTemplateOutletContext = null;
      /**
       * A string defining the template reference and optionally the context object for the template.
       */
      ngTemplateOutlet = null;
      /** Injector to be used within the embedded view. */
      ngTemplateOutletInjector = null;
      constructor(_viewContainerRef) {
        this._viewContainerRef = _viewContainerRef;
      }
      ngOnChanges(changes) {
        if (this._shouldRecreateView(changes)) {
          const viewContainerRef = this._viewContainerRef;
          if (this._viewRef) {
            viewContainerRef.remove(viewContainerRef.indexOf(this._viewRef));
          }
          if (!this.ngTemplateOutlet) {
            this._viewRef = null;
            return;
          }
          const viewContext = this._createContextForwardProxy();
          this._viewRef = viewContainerRef.createEmbeddedView(this.ngTemplateOutlet, viewContext, {
            injector: this.ngTemplateOutletInjector ?? void 0
          });
        }
      }
      /**
       * We need to re-create existing embedded view if either is true:
       * - the outlet changed.
       * - the injector changed.
       */
      _shouldRecreateView(changes) {
        return !!changes["ngTemplateOutlet"] || !!changes["ngTemplateOutletInjector"];
      }
      /**
       * For a given outlet instance, we create a proxy object that delegates
       * to the user-specified context. This allows changing, or swapping out
       * the context object completely without having to destroy/re-create the view.
       */
      _createContextForwardProxy() {
        return new Proxy({}, {
          set: (_target, prop, newValue) => {
            if (!this.ngTemplateOutletContext) {
              return false;
            }
            return Reflect.set(this.ngTemplateOutletContext, prop, newValue);
          },
          get: (_target, prop, receiver) => {
            if (!this.ngTemplateOutletContext) {
              return void 0;
            }
            return Reflect.get(this.ngTemplateOutletContext, prop, receiver);
          }
        });
      }
      static \u0275fac = function NgTemplateOutlet_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgTemplateOutlet)(\u0275\u0275directiveInject(ViewContainerRef));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgTemplateOutlet,
        selectors: [["", "ngTemplateOutlet", ""]],
        inputs: {
          ngTemplateOutletContext: "ngTemplateOutletContext",
          ngTemplateOutlet: "ngTemplateOutlet",
          ngTemplateOutletInjector: "ngTemplateOutletInjector"
        },
        features: [\u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgTemplateOutlet, [{
        type: Directive,
        args: [{
          selector: "[ngTemplateOutlet]"
        }]
      }], () => [{
        type: ViewContainerRef
      }], {
        ngTemplateOutletContext: [{
          type: Input
        }],
        ngTemplateOutlet: [{
          type: Input
        }],
        ngTemplateOutletInjector: [{
          type: Input
        }]
      });
    })();
    COMMON_DIRECTIVES = [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase];
    SubscribableStrategy = class {
      createSubscription(async2, updateLatestValue, onError) {
        return untracked2(() => async2.subscribe({
          next: updateLatestValue,
          error: onError
        }));
      }
      dispose(subscription) {
        untracked2(() => subscription.unsubscribe());
      }
    };
    PromiseStrategy = class {
      createSubscription(async2, updateLatestValue, onError) {
        async2.then(
          // Using optional chaining because we may have set it to `null`; since the promise
          // is async, the view might be destroyed by the time the promise resolves.
          (v) => updateLatestValue?.(v),
          (e2) => onError?.(e2)
        );
        return {
          unsubscribe: () => {
            updateLatestValue = null;
            onError = null;
          }
        };
      }
      dispose(subscription) {
        subscription.unsubscribe();
      }
    };
    _promiseStrategy = new PromiseStrategy();
    _subscribableStrategy = new SubscribableStrategy();
    AsyncPipe = class _AsyncPipe {
      _ref;
      _latestValue = null;
      markForCheckOnValueUpdate = true;
      _subscription = null;
      _obj = null;
      _strategy = null;
      applicationErrorHandler = inject2(INTERNAL_APPLICATION_ERROR_HANDLER);
      constructor(ref) {
        this._ref = ref;
      }
      ngOnDestroy() {
        if (this._subscription) {
          this._dispose();
        }
        this._ref = null;
      }
      transform(obj) {
        if (!this._obj) {
          if (obj) {
            try {
              this.markForCheckOnValueUpdate = false;
              this._subscribe(obj);
            } finally {
              this.markForCheckOnValueUpdate = true;
            }
          }
          return this._latestValue;
        }
        if (obj !== this._obj) {
          this._dispose();
          return this.transform(obj);
        }
        return this._latestValue;
      }
      _subscribe(obj) {
        this._obj = obj;
        this._strategy = this._selectStrategy(obj);
        this._subscription = this._strategy.createSubscription(obj, (value) => this._updateLatestValue(obj, value), (e2) => this.applicationErrorHandler(e2));
      }
      _selectStrategy(obj) {
        if (isPromise2(obj)) {
          return _promiseStrategy;
        }
        if (isSubscribable(obj)) {
          return _subscribableStrategy;
        }
        throw invalidPipeArgumentError(_AsyncPipe, obj);
      }
      _dispose() {
        this._strategy.dispose(this._subscription);
        this._latestValue = null;
        this._subscription = null;
        this._obj = null;
      }
      _updateLatestValue(async2, value) {
        if (async2 === this._obj) {
          this._latestValue = value;
          if (this.markForCheckOnValueUpdate) {
            this._ref?.markForCheck();
          }
        }
      }
      static \u0275fac = function AsyncPipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _AsyncPipe)(\u0275\u0275directiveInject(ChangeDetectorRef, 16));
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "async",
        type: _AsyncPipe,
        pure: false
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AsyncPipe, [{
        type: Pipe,
        args: [{
          name: "async",
          pure: false
        }]
      }], () => [{
        type: ChangeDetectorRef
      }], null);
    })();
    LowerCasePipe = class _LowerCasePipe {
      transform(value) {
        if (value == null) return null;
        if (typeof value !== "string") {
          throw invalidPipeArgumentError(_LowerCasePipe, value);
        }
        return value.toLowerCase();
      }
      static \u0275fac = function LowerCasePipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _LowerCasePipe)();
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "lowercase",
        type: _LowerCasePipe,
        pure: true
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LowerCasePipe, [{
        type: Pipe,
        args: [{
          name: "lowercase"
        }]
      }], null, null);
    })();
    unicodeWordMatch = /(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])\S*/g;
    TitleCasePipe = class _TitleCasePipe {
      transform(value) {
        if (value == null) return null;
        if (typeof value !== "string") {
          throw invalidPipeArgumentError(_TitleCasePipe, value);
        }
        return value.replace(unicodeWordMatch, (txt) => txt[0].toUpperCase() + txt.slice(1).toLowerCase());
      }
      static \u0275fac = function TitleCasePipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _TitleCasePipe)();
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "titlecase",
        type: _TitleCasePipe,
        pure: true
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TitleCasePipe, [{
        type: Pipe,
        args: [{
          name: "titlecase"
        }]
      }], null, null);
    })();
    UpperCasePipe = class _UpperCasePipe {
      transform(value) {
        if (value == null) return null;
        if (typeof value !== "string") {
          throw invalidPipeArgumentError(_UpperCasePipe, value);
        }
        return value.toUpperCase();
      }
      static \u0275fac = function UpperCasePipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _UpperCasePipe)();
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "uppercase",
        type: _UpperCasePipe,
        pure: true
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UpperCasePipe, [{
        type: Pipe,
        args: [{
          name: "uppercase"
        }]
      }], null, null);
    })();
    DEFAULT_DATE_FORMAT = "mediumDate";
    DATE_PIPE_DEFAULT_TIMEZONE = new InjectionToken(ngDevMode ? "DATE_PIPE_DEFAULT_TIMEZONE" : "");
    DATE_PIPE_DEFAULT_OPTIONS = new InjectionToken(ngDevMode ? "DATE_PIPE_DEFAULT_OPTIONS" : "");
    DatePipe = class _DatePipe {
      locale;
      defaultTimezone;
      defaultOptions;
      constructor(locale, defaultTimezone, defaultOptions) {
        this.locale = locale;
        this.defaultTimezone = defaultTimezone;
        this.defaultOptions = defaultOptions;
      }
      transform(value, format, timezone, locale) {
        if (value == null || value === "" || value !== value) return null;
        try {
          const _format = format ?? this.defaultOptions?.dateFormat ?? DEFAULT_DATE_FORMAT;
          const _timezone = timezone ?? this.defaultOptions?.timezone ?? this.defaultTimezone ?? void 0;
          return formatDate(value, _format, locale || this.locale, _timezone);
        } catch (error) {
          throw invalidPipeArgumentError(_DatePipe, error.message);
        }
      }
      static \u0275fac = function DatePipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DatePipe)(\u0275\u0275directiveInject(LOCALE_ID, 16), \u0275\u0275directiveInject(DATE_PIPE_DEFAULT_TIMEZONE, 24), \u0275\u0275directiveInject(DATE_PIPE_DEFAULT_OPTIONS, 24));
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "date",
        type: _DatePipe,
        pure: true
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePipe, [{
        type: Pipe,
        args: [{
          name: "date"
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [LOCALE_ID]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DATE_PIPE_DEFAULT_TIMEZONE]
        }, {
          type: Optional
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DATE_PIPE_DEFAULT_OPTIONS]
        }, {
          type: Optional
        }]
      }], null);
    })();
    _INTERPOLATION_REGEXP = /#/g;
    I18nPluralPipe = class _I18nPluralPipe {
      _localization;
      constructor(_localization) {
        this._localization = _localization;
      }
      /**
       * @param value the number to be formatted
       * @param pluralMap an object that mimics the ICU format, see
       * https://unicode-org.github.io/icu/userguide/format_parse/messages/.
       * @param locale a `string` defining the locale to use (uses the current {@link LOCALE_ID} by
       * default).
       */
      transform(value, pluralMap, locale) {
        if (value == null) return "";
        if (typeof pluralMap !== "object" || pluralMap === null) {
          throw invalidPipeArgumentError(_I18nPluralPipe, pluralMap);
        }
        const key = getPluralCategory(value, Object.keys(pluralMap), this._localization, locale);
        return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());
      }
      static \u0275fac = function I18nPluralPipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _I18nPluralPipe)(\u0275\u0275directiveInject(NgLocalization, 16));
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "i18nPlural",
        type: _I18nPluralPipe,
        pure: true
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(I18nPluralPipe, [{
        type: Pipe,
        args: [{
          name: "i18nPlural"
        }]
      }], () => [{
        type: NgLocalization
      }], null);
    })();
    I18nSelectPipe = class _I18nSelectPipe {
      /**
       * @param value a string to be internationalized.
       * @param mapping an object that indicates the text that should be displayed
       * for different values of the provided `value`.
       */
      transform(value, mapping) {
        if (value == null) return "";
        if (typeof mapping !== "object" || typeof value !== "string") {
          throw invalidPipeArgumentError(_I18nSelectPipe, mapping);
        }
        if (mapping.hasOwnProperty(value)) {
          return mapping[value];
        }
        if (mapping.hasOwnProperty("other")) {
          return mapping["other"];
        }
        return "";
      }
      static \u0275fac = function I18nSelectPipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _I18nSelectPipe)();
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "i18nSelect",
        type: _I18nSelectPipe,
        pure: true
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(I18nSelectPipe, [{
        type: Pipe,
        args: [{
          name: "i18nSelect"
        }]
      }], null, null);
    })();
    JsonPipe = class _JsonPipe {
      /**
       * @param value A value of any type to convert into a JSON-format string.
       */
      transform(value) {
        return JSON.stringify(value, null, 2);
      }
      static \u0275fac = function JsonPipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _JsonPipe)();
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "json",
        type: _JsonPipe,
        pure: false
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonPipe, [{
        type: Pipe,
        args: [{
          name: "json",
          pure: false
        }]
      }], null, null);
    })();
    KeyValuePipe = class _KeyValuePipe {
      differs;
      constructor(differs) {
        this.differs = differs;
      }
      differ;
      keyValues = [];
      compareFn = defaultComparator;
      transform(input2, compareFn = defaultComparator) {
        if (!input2 || !(input2 instanceof Map) && typeof input2 !== "object") {
          return null;
        }
        this.differ ??= this.differs.find(input2).create();
        const differChanges = this.differ.diff(input2);
        const compareFnChanged = compareFn !== this.compareFn;
        if (differChanges) {
          this.keyValues = [];
          differChanges.forEachItem((r2) => {
            this.keyValues.push(makeKeyValuePair(r2.key, r2.currentValue));
          });
        }
        if (differChanges || compareFnChanged) {
          if (compareFn) {
            this.keyValues.sort(compareFn);
          }
          this.compareFn = compareFn;
        }
        return this.keyValues;
      }
      static \u0275fac = function KeyValuePipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _KeyValuePipe)(\u0275\u0275directiveInject(KeyValueDiffers, 16));
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "keyvalue",
        type: _KeyValuePipe,
        pure: false
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyValuePipe, [{
        type: Pipe,
        args: [{
          name: "keyvalue",
          pure: false
        }]
      }], () => [{
        type: KeyValueDiffers
      }], null);
    })();
    DecimalPipe = class _DecimalPipe {
      _locale;
      constructor(_locale) {
        this._locale = _locale;
      }
      transform(value, digitsInfo, locale) {
        if (!isValue(value)) return null;
        locale ||= this._locale;
        try {
          const num = strToNumber(value);
          return formatNumber(num, locale, digitsInfo);
        } catch (error) {
          throw invalidPipeArgumentError(_DecimalPipe, error.message);
        }
      }
      static \u0275fac = function DecimalPipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DecimalPipe)(\u0275\u0275directiveInject(LOCALE_ID, 16));
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "number",
        type: _DecimalPipe,
        pure: true
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DecimalPipe, [{
        type: Pipe,
        args: [{
          name: "number"
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [LOCALE_ID]
        }]
      }], null);
    })();
    PercentPipe = class _PercentPipe {
      _locale;
      constructor(_locale) {
        this._locale = _locale;
      }
      /**
       *
       * @param value The number to be formatted as a percentage.
       * @param digitsInfo Decimal representation options, specified by a string
       * in the following format:<br>
       * <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>.
       *   - `minIntegerDigits`: The minimum number of integer digits before the decimal point.
       * Default is `1`.
       *   - `minFractionDigits`: The minimum number of digits after the decimal point.
       * Default is `0`.
       *   - `maxFractionDigits`: The maximum number of digits after the decimal point.
       * Default is `0`.
       * @param locale A locale code for the locale format rules to use.
       * When not supplied, uses the value of `LOCALE_ID`, which is `en-US` by default.
       * See [Setting your app locale](guide/i18n/locale-id).
       */
      transform(value, digitsInfo, locale) {
        if (!isValue(value)) return null;
        locale ||= this._locale;
        try {
          const num = strToNumber(value);
          return formatPercent(num, locale, digitsInfo);
        } catch (error) {
          throw invalidPipeArgumentError(_PercentPipe, error.message);
        }
      }
      static \u0275fac = function PercentPipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _PercentPipe)(\u0275\u0275directiveInject(LOCALE_ID, 16));
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "percent",
        type: _PercentPipe,
        pure: true
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PercentPipe, [{
        type: Pipe,
        args: [{
          name: "percent"
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [LOCALE_ID]
        }]
      }], null);
    })();
    CurrencyPipe = class _CurrencyPipe {
      _locale;
      _defaultCurrencyCode;
      constructor(_locale, _defaultCurrencyCode = "USD") {
        this._locale = _locale;
        this._defaultCurrencyCode = _defaultCurrencyCode;
      }
      transform(value, currencyCode = this._defaultCurrencyCode, display = "symbol", digitsInfo, locale) {
        if (!isValue(value)) return null;
        locale ||= this._locale;
        if (typeof display === "boolean") {
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            console.warn(`Warning: the currency pipe has been changed in Angular v5. The symbolDisplay option (third parameter) is now a string instead of a boolean. The accepted values are "code", "symbol" or "symbol-narrow".`);
          }
          display = display ? "symbol" : "code";
        }
        let currency = currencyCode || this._defaultCurrencyCode;
        if (display !== "code") {
          if (display === "symbol" || display === "symbol-narrow") {
            currency = getCurrencySymbol(currency, display === "symbol" ? "wide" : "narrow", locale);
          } else {
            currency = display;
          }
        }
        try {
          const num = strToNumber(value);
          return formatCurrency(num, locale, currency, currencyCode, digitsInfo);
        } catch (error) {
          throw invalidPipeArgumentError(_CurrencyPipe, error.message);
        }
      }
      static \u0275fac = function CurrencyPipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CurrencyPipe)(\u0275\u0275directiveInject(LOCALE_ID, 16), \u0275\u0275directiveInject(DEFAULT_CURRENCY_CODE, 16));
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "currency",
        type: _CurrencyPipe,
        pure: true
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CurrencyPipe, [{
        type: Pipe,
        args: [{
          name: "currency"
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [LOCALE_ID]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DEFAULT_CURRENCY_CODE]
        }]
      }], null);
    })();
    SlicePipe = class _SlicePipe {
      transform(value, start, end) {
        if (value == null) return null;
        const supports = typeof value === "string" || Array.isArray(value);
        if (!supports) {
          throw invalidPipeArgumentError(_SlicePipe, value);
        }
        return value.slice(start, end);
      }
      static \u0275fac = function SlicePipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _SlicePipe)();
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "slice",
        type: _SlicePipe,
        pure: false
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SlicePipe, [{
        type: Pipe,
        args: [{
          name: "slice",
          pure: false
        }]
      }], null, null);
    })();
    COMMON_PIPES = [AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe];
    CommonModule = class _CommonModule {
      static \u0275fac = function CommonModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CommonModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _CommonModule,
        imports: [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase, AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe],
        exports: [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase, AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe]
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CommonModule, [{
        type: NgModule,
        args: [{
          imports: [COMMON_DIRECTIVES, COMMON_PIPES],
          exports: [COMMON_DIRECTIVES, COMMON_PIPES]
        }]
      }], null, null);
    })();
  }
});

// node_modules/@angular/common/fesm2022/xhr.mjs
function parseCookieValue(cookieStr, name) {
  name = encodeURIComponent(name);
  for (const cookie of cookieStr.split(";")) {
    const eqIndex = cookie.indexOf("=");
    const [cookieName, cookieValue] = eqIndex == -1 ? [cookie, ""] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)];
    if (cookieName.trim() === name) {
      return decodeURIComponent(cookieValue);
    }
  }
  return null;
}
var XhrFactory;
var init_xhr = __esm({
  "node_modules/@angular/common/fesm2022/xhr.mjs"() {
    "use strict";
    XhrFactory = class {
    };
  }
});

// node_modules/@angular/common/fesm2022/common.mjs
function isPlatformBrowser(platformId) {
  return platformId === PLATFORM_BROWSER_ID;
}
function findAnchorFromDocument(document2, target) {
  const documentResult = document2.getElementById(target) || document2.getElementsByName(target)[0];
  if (documentResult) {
    return documentResult;
  }
  if (typeof document2.createTreeWalker === "function" && document2.body && typeof document2.body.attachShadow === "function") {
    const treeWalker = document2.createTreeWalker(document2.body, NodeFilter.SHOW_ELEMENT);
    let currentNode = treeWalker.currentNode;
    while (currentNode) {
      const shadowRoot = currentNode.shadowRoot;
      if (shadowRoot) {
        const result = shadowRoot.getElementById(target) || shadowRoot.querySelector(`[name="${target}"]`);
        if (result) {
          return result;
        }
      }
      currentNode = treeWalker.nextNode();
    }
  }
  return null;
}
function getUrl(src, win) {
  return isAbsoluteUrl(src) ? new URL(src) : new URL(src, win.location.href);
}
function isAbsoluteUrl(src) {
  return /^https?:\/\//.test(src);
}
function extractHostname(url) {
  return isAbsoluteUrl(url) ? new URL(url).hostname : url;
}
function isValidPath(path) {
  const isString = typeof path === "string";
  if (!isString || path.trim() === "") {
    return false;
  }
  try {
    const url = new URL(path);
    return true;
  } catch {
    return false;
  }
}
function normalizePath(path) {
  return path.endsWith("/") ? path.slice(0, -1) : path;
}
function normalizeSrc(src) {
  return src.startsWith("/") ? src.slice(1) : src;
}
function createImageLoader(buildUrlFn, exampleUrls) {
  return function provideImageLoader(path) {
    if (!isValidPath(path)) {
      throwInvalidPathError(path, exampleUrls || []);
    }
    path = normalizePath(path);
    const loaderFn = (config2) => {
      if (isAbsoluteUrl(config2.src)) {
        throwUnexpectedAbsoluteUrlError(path, config2.src);
      }
      return buildUrlFn(path, __spreadProps(__spreadValues({}, config2), {
        src: normalizeSrc(config2.src)
      }));
    };
    const providers = [{
      provide: IMAGE_LOADER,
      useValue: loaderFn
    }];
    return providers;
  };
}
function throwInvalidPathError(path, exampleUrls) {
  throw new RuntimeError(2959, ngDevMode && `Image loader has detected an invalid path (\`${path}\`). To fix this, supply a path using one of the following formats: ${exampleUrls.join(" or ")}`);
}
function throwUnexpectedAbsoluteUrlError(path, url) {
  throw new RuntimeError(2959, ngDevMode && `Image loader has detected a \`<img>\` tag with an invalid \`ngSrc\` attribute: ${url}. This image loader expects \`ngSrc\` to be a relative URL - however the provided value is an absolute URL. To fix this, provide \`ngSrc\` as a path relative to the base URL configured for this loader (\`${path}\`).`);
}
function createCloudflareUrl(path, config2) {
  let params = `format=auto`;
  if (config2.width) {
    params += `,width=${config2.width}`;
  }
  if (config2.isPlaceholder) {
    params += `,quality=${PLACEHOLDER_QUALITY}`;
  }
  return `${path}/cdn-cgi/image/${params}/${config2.src}`;
}
function isCloudinaryUrl(url) {
  return CLOUDINARY_LOADER_REGEX.test(url);
}
function createCloudinaryUrl(path, config2) {
  const quality = config2.isPlaceholder ? "q_auto:low" : "q_auto";
  let params = `f_auto,${quality}`;
  if (config2.width) {
    params += `,w_${config2.width}`;
  }
  if (config2.loaderParams?.["rounded"]) {
    params += `,r_max`;
  }
  return `${path}/image/upload/${params}/${config2.src}`;
}
function isImageKitUrl(url) {
  return IMAGE_KIT_LOADER_REGEX.test(url);
}
function createImagekitUrl(path, config2) {
  const {
    src,
    width
  } = config2;
  const params = [];
  if (width) {
    params.push(`w-${width}`);
  }
  if (config2.isPlaceholder) {
    params.push(`q-${PLACEHOLDER_QUALITY}`);
  }
  const urlSegments = params.length ? [path, `tr:${params.join(",")}`, src] : [path, src];
  const url = new URL(urlSegments.join("/"));
  return url.href;
}
function isImgixUrl(url) {
  return IMGIX_LOADER_REGEX.test(url);
}
function createImgixUrl(path, config2) {
  const url = new URL(`${path}/${config2.src}`);
  url.searchParams.set("auto", "format");
  if (config2.width) {
    url.searchParams.set("w", config2.width.toString());
  }
  if (config2.isPlaceholder) {
    url.searchParams.set("q", PLACEHOLDER_QUALITY);
  }
  return url.href;
}
function isNetlifyUrl(url) {
  return NETLIFY_LOADER_REGEX.test(url);
}
function imgDirectiveDetails(ngSrc, includeNgSrc = true) {
  const ngSrcInfo = includeNgSrc ? `(activated on an <img> element with the \`ngSrc="${ngSrc}"\`) ` : "";
  return `The NgOptimizedImage directive ${ngSrcInfo}has detected that`;
}
function assertDevMode(checkName) {
  if (!ngDevMode) {
    throw new RuntimeError(2958, `Unexpected invocation of the ${checkName} in the prod mode. Please make sure that the prod mode is enabled for production builds.`);
  }
}
function logMissingPriorityError(ngSrc) {
  const directiveDetails = imgDirectiveDetails(ngSrc);
  console.error(formatRuntimeError(2955, `${directiveDetails} this image is the Largest Contentful Paint (LCP) element but was not marked "priority". This image should be marked "priority" in order to prioritize its loading. To fix this, add the "priority" attribute.`));
}
function logModifiedWarning(ngSrc) {
  const directiveDetails = imgDirectiveDetails(ngSrc);
  console.warn(formatRuntimeError(2964, `${directiveDetails} this image is the Largest Contentful Paint (LCP) element and has had its "ngSrc" attribute modified. This can cause slower loading performance. It is recommended not to modify the "ngSrc" property on any image which could be the LCP element.`));
}
function deepForEach2(input2, fn) {
  for (let value of input2) {
    Array.isArray(value) ? deepForEach2(value, fn) : fn(value);
  }
}
function processConfig(config2) {
  let sortedBreakpoints = {};
  if (config2.breakpoints) {
    sortedBreakpoints.breakpoints = config2.breakpoints.sort((a2, b2) => a2 - b2);
  }
  return Object.assign({}, IMAGE_CONFIG_DEFAULTS, config2, sortedBreakpoints);
}
function assertNoConflictingSrc(dir) {
  if (dir.src) {
    throw new RuntimeError(2950, `${imgDirectiveDetails(dir.ngSrc)} both \`src\` and \`ngSrc\` have been set. Supplying both of these attributes breaks lazy loading. The NgOptimizedImage directive sets \`src\` itself based on the value of \`ngSrc\`. To fix this, please remove the \`src\` attribute.`);
  }
}
function assertNoConflictingSrcset(dir) {
  if (dir.srcset) {
    throw new RuntimeError(2951, `${imgDirectiveDetails(dir.ngSrc)} both \`srcset\` and \`ngSrcset\` have been set. Supplying both of these attributes breaks lazy loading. The NgOptimizedImage directive sets \`srcset\` itself based on the value of \`ngSrcset\`. To fix this, please remove the \`srcset\` attribute.`);
  }
}
function assertNotBase64Image(dir) {
  let ngSrc = dir.ngSrc.trim();
  if (ngSrc.startsWith("data:")) {
    if (ngSrc.length > BASE64_IMG_MAX_LENGTH_IN_ERROR) {
      ngSrc = ngSrc.substring(0, BASE64_IMG_MAX_LENGTH_IN_ERROR) + "...";
    }
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`ngSrc\` is a Base64-encoded string (${ngSrc}). NgOptimizedImage does not support Base64-encoded strings. To fix this, disable the NgOptimizedImage directive for this element by removing \`ngSrc\` and using a standard \`src\` attribute instead.`);
  }
}
function assertNoComplexSizes(dir) {
  let sizes = dir.sizes;
  if (sizes?.match(/((\)|,)\s|^)\d+px/)) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`sizes\` was set to a string including pixel values. For automatic \`srcset\` generation, \`sizes\` must only include responsive values, such as \`sizes="50vw"\` or \`sizes="(min-width: 768px) 50vw, 100vw"\`. To fix this, modify the \`sizes\` attribute, or provide your own \`ngSrcset\` value directly.`);
  }
}
function assertValidPlaceholder(dir, imageLoader) {
  assertNoPlaceholderConfigWithoutPlaceholder(dir);
  assertNoRelativePlaceholderWithoutLoader(dir, imageLoader);
  assertNoOversizedDataUrl(dir);
}
function assertNoPlaceholderConfigWithoutPlaceholder(dir) {
  if (dir.placeholderConfig && !dir.placeholder) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`placeholderConfig\` options were provided for an image that does not use the \`placeholder\` attribute, and will have no effect.`);
  }
}
function assertNoRelativePlaceholderWithoutLoader(dir, imageLoader) {
  if (dir.placeholder === true && imageLoader === noopImageLoader) {
    throw new RuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to true but no image loader is configured (i.e. the default one is being used), which would result in the same image being used for the primary image and its placeholder. To fix this, provide a loader or remove the \`placeholder\` attribute from the image.`);
  }
}
function assertNoOversizedDataUrl(dir) {
  if (dir.placeholder && typeof dir.placeholder === "string" && dir.placeholder.startsWith("data:")) {
    if (dir.placeholder.length > DATA_URL_ERROR_LIMIT) {
      throw new RuntimeError(2965, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to a data URL which is longer than ${DATA_URL_ERROR_LIMIT} characters. This is strongly discouraged, as large inline placeholders directly increase the bundle size of Angular and hurt page load performance. To fix this, generate a smaller data URL placeholder.`);
    }
    if (dir.placeholder.length > DATA_URL_WARN_LIMIT) {
      console.warn(formatRuntimeError(2965, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to a data URL which is longer than ${DATA_URL_WARN_LIMIT} characters. This is discouraged, as large inline placeholders directly increase the bundle size of Angular and hurt page load performance. For better loading performance, generate a smaller data URL placeholder.`));
    }
  }
}
function assertNotBlobUrl(dir) {
  const ngSrc = dir.ngSrc.trim();
  if (ngSrc.startsWith("blob:")) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`ngSrc\` was set to a blob URL (${ngSrc}). Blob URLs are not supported by the NgOptimizedImage directive. To fix this, disable the NgOptimizedImage directive for this element by removing \`ngSrc\` and using a regular \`src\` attribute instead.`);
  }
}
function assertNonEmptyInput(dir, name, value) {
  const isString = typeof value === "string";
  const isEmptyString = isString && value.trim() === "";
  if (!isString || isEmptyString) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`${name}\` has an invalid value (\`${value}\`). To fix this, change the value to a non-empty string.`);
  }
}
function assertValidNgSrcset(dir, value) {
  if (value == null) return;
  assertNonEmptyInput(dir, "ngSrcset", value);
  const stringVal = value;
  const isValidWidthDescriptor = VALID_WIDTH_DESCRIPTOR_SRCSET.test(stringVal);
  const isValidDensityDescriptor = VALID_DENSITY_DESCRIPTOR_SRCSET.test(stringVal);
  if (isValidDensityDescriptor) {
    assertUnderDensityCap(dir, stringVal);
  }
  const isValidSrcset = isValidWidthDescriptor || isValidDensityDescriptor;
  if (!isValidSrcset) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`ngSrcset\` has an invalid value (\`${value}\`). To fix this, supply \`ngSrcset\` using a comma-separated list of one or more width descriptors (e.g. "100w, 200w") or density descriptors (e.g. "1x, 2x").`);
  }
}
function assertUnderDensityCap(dir, value) {
  const underDensityCap = value.split(",").every((num) => num === "" || parseFloat(num) <= ABSOLUTE_SRCSET_DENSITY_CAP);
  if (!underDensityCap) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`ngSrcset\` contains an unsupported image density:\`${value}\`. NgOptimizedImage generally recommends a max image density of ${RECOMMENDED_SRCSET_DENSITY_CAP}x but supports image densities up to ${ABSOLUTE_SRCSET_DENSITY_CAP}x. The human eye cannot distinguish between image densities greater than ${RECOMMENDED_SRCSET_DENSITY_CAP}x - which makes them unnecessary for most use cases. Images that will be pinch-zoomed are typically the primary use case for ${ABSOLUTE_SRCSET_DENSITY_CAP}x images. Please remove the high density descriptor and try again.`);
  }
}
function postInitInputChangeError(dir, inputName) {
  let reason;
  if (inputName === "width" || inputName === "height") {
    reason = `Changing \`${inputName}\` may result in different attribute value applied to the underlying image element and cause layout shifts on a page.`;
  } else {
    reason = `Changing the \`${inputName}\` would have no effect on the underlying image element, because the resource loading has already occurred.`;
  }
  return new RuntimeError(2953, `${imgDirectiveDetails(dir.ngSrc)} \`${inputName}\` was updated after initialization. The NgOptimizedImage directive will not react to this input change. ${reason} To fix this, either switch \`${inputName}\` to a static value or wrap the image element in an @if that is gated on the necessary value.`);
}
function assertNoPostInitInputChange(dir, changes, inputs) {
  inputs.forEach((input2) => {
    const isUpdated = changes.hasOwnProperty(input2);
    if (isUpdated && !changes[input2].isFirstChange()) {
      if (input2 === "ngSrc") {
        dir = {
          ngSrc: changes[input2].previousValue
        };
      }
      throw postInitInputChangeError(dir, input2);
    }
  });
}
function assertGreaterThanZero(dir, inputValue, inputName) {
  const validNumber = typeof inputValue === "number" && inputValue > 0;
  const validString = typeof inputValue === "string" && /^\d+$/.test(inputValue.trim()) && parseInt(inputValue) > 0;
  if (!validNumber && !validString) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`${inputName}\` has an invalid value. To fix this, provide \`${inputName}\` as a number greater than 0.`);
  }
}
function assertNoImageDistortion(dir, img, renderer) {
  const callback = () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
    const computedStyle = window.getComputedStyle(img);
    let renderedWidth = parseFloat(computedStyle.getPropertyValue("width"));
    let renderedHeight = parseFloat(computedStyle.getPropertyValue("height"));
    const boxSizing = computedStyle.getPropertyValue("box-sizing");
    if (boxSizing === "border-box") {
      const paddingTop = computedStyle.getPropertyValue("padding-top");
      const paddingRight = computedStyle.getPropertyValue("padding-right");
      const paddingBottom = computedStyle.getPropertyValue("padding-bottom");
      const paddingLeft = computedStyle.getPropertyValue("padding-left");
      renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);
      renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);
    }
    const renderedAspectRatio = renderedWidth / renderedHeight;
    const nonZeroRenderedDimensions = renderedWidth !== 0 && renderedHeight !== 0;
    const intrinsicWidth = img.naturalWidth;
    const intrinsicHeight = img.naturalHeight;
    const intrinsicAspectRatio = intrinsicWidth / intrinsicHeight;
    const suppliedWidth = dir.width;
    const suppliedHeight = dir.height;
    const suppliedAspectRatio = suppliedWidth / suppliedHeight;
    const inaccurateDimensions = Math.abs(suppliedAspectRatio - intrinsicAspectRatio) > ASPECT_RATIO_TOLERANCE;
    const stylingDistortion = nonZeroRenderedDimensions && Math.abs(intrinsicAspectRatio - renderedAspectRatio) > ASPECT_RATIO_TOLERANCE;
    if (inaccurateDimensions) {
      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the image does not match the aspect ratio indicated by the width and height attributes. 
Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h (aspect-ratio: ${round(intrinsicAspectRatio)}). 
Supplied width and height attributes: ${suppliedWidth}w x ${suppliedHeight}h (aspect-ratio: ${round(suppliedAspectRatio)}). 
To fix this, update the width and height attributes.`));
    } else if (stylingDistortion) {
      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the rendered image does not match the image's intrinsic aspect ratio. 
Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h (aspect-ratio: ${round(intrinsicAspectRatio)}). 
Rendered image size: ${renderedWidth}w x ${renderedHeight}h (aspect-ratio: ${round(renderedAspectRatio)}). 
This issue can occur if "width" and "height" attributes are added to an image without updating the corresponding image styling. To fix this, adjust image styling. In most cases, adding "height: auto" or "width: auto" to the image styling will fix this issue.`));
    } else if (!dir.ngSrcset && nonZeroRenderedDimensions) {
      const recommendedWidth = RECOMMENDED_SRCSET_DENSITY_CAP * renderedWidth;
      const recommendedHeight = RECOMMENDED_SRCSET_DENSITY_CAP * renderedHeight;
      const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE2;
      const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE2;
      if (oversizedWidth || oversizedHeight) {
        console.warn(formatRuntimeError(2960, `${imgDirectiveDetails(dir.ngSrc)} the intrinsic image is significantly larger than necessary. 
Rendered image size: ${renderedWidth}w x ${renderedHeight}h. 
Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h. 
Recommended intrinsic image size: ${recommendedWidth}w x ${recommendedHeight}h. 
Note: Recommended intrinsic image size is calculated assuming a maximum DPR of ${RECOMMENDED_SRCSET_DENSITY_CAP}. To improve loading time, resize the image or consider using the "ngSrcset" and "sizes" attributes.`));
      }
    }
  };
  const removeLoadListenerFn = renderer.listen(img, "load", callback);
  const removeErrorListenerFn = renderer.listen(img, "error", () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
  });
  callOnLoadIfImageIsLoaded(img, callback);
}
function assertNonEmptyWidthAndHeight(dir) {
  let missingAttributes = [];
  if (dir.width === void 0) missingAttributes.push("width");
  if (dir.height === void 0) missingAttributes.push("height");
  if (missingAttributes.length > 0) {
    throw new RuntimeError(2954, `${imgDirectiveDetails(dir.ngSrc)} these required attributes are missing: ${missingAttributes.map((attr) => `"${attr}"`).join(", ")}. Including "width" and "height" attributes will prevent image-related layout shifts. To fix this, include "width" and "height" attributes on the image tag or turn on "fill" mode with the \`fill\` attribute.`);
  }
}
function assertEmptyWidthAndHeight(dir) {
  if (dir.width || dir.height) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the attributes \`height\` and/or \`width\` are present along with the \`fill\` attribute. Because \`fill\` mode causes an image to fill its containing element, the size attributes have no effect and should be removed.`);
  }
}
function assertNonZeroRenderedHeight(dir, img, renderer) {
  const callback = () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
    const renderedHeight = img.clientHeight;
    if (dir.fill && renderedHeight === 0) {
      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the height of the fill-mode image is zero. This is likely because the containing element does not have the CSS 'position' property set to one of the following: "relative", "fixed", or "absolute". To fix this problem, make sure the container element has the CSS 'position' property defined and the height of the element is not zero.`));
    }
  };
  const removeLoadListenerFn = renderer.listen(img, "load", callback);
  const removeErrorListenerFn = renderer.listen(img, "error", () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
  });
  callOnLoadIfImageIsLoaded(img, callback);
}
function assertValidLoadingInput(dir) {
  if (dir.loading && dir.priority) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`loading\` attribute was used on an image that was marked "priority". Setting \`loading\` on priority images is not allowed because these images will always be eagerly loaded. To fix this, remove the \u201Cloading\u201D attribute from the priority image.`);
  }
  const validInputs = ["auto", "eager", "lazy"];
  if (typeof dir.loading === "string" && !validInputs.includes(dir.loading)) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`loading\` attribute has an invalid value (\`${dir.loading}\`). To fix this, provide a valid value ("lazy", "eager", or "auto").`);
  }
}
function assertValidDecodingInput(dir) {
  const validInputs = ["sync", "async", "auto"];
  if (typeof dir.decoding === "string" && !validInputs.includes(dir.decoding)) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`decoding\` attribute has an invalid value (\`${dir.decoding}\`). To fix this, provide a valid value ("sync", "async", or "auto").`);
  }
}
function assertNotMissingBuiltInLoader(ngSrc, imageLoader) {
  if (imageLoader === noopImageLoader) {
    let builtInLoaderName = "";
    for (const loader of BUILT_IN_LOADERS) {
      if (loader.testUrl(ngSrc)) {
        builtInLoaderName = loader.name;
        break;
      }
    }
    if (builtInLoaderName) {
      console.warn(formatRuntimeError(2962, `NgOptimizedImage: It looks like your images may be hosted on the ${builtInLoaderName} CDN, but your app is not using Angular's built-in loader for that CDN. We recommend switching to use the built-in by calling \`provide${builtInLoaderName}Loader()\` in your \`providers\` and passing it your instance's base URL. If you don't want to use the built-in loader, define a custom loader function using IMAGE_LOADER to silence this warning.`));
    }
  }
}
function assertNoNgSrcsetWithoutLoader(dir, imageLoader) {
  if (dir.ngSrcset && imageLoader === noopImageLoader) {
    console.warn(formatRuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`ngSrcset\` attribute is present but no image loader is configured (i.e. the default one is being used), which would result in the same image being used for all configured sizes. To fix this, provide a loader or remove the \`ngSrcset\` attribute from the image.`));
  }
}
function assertNoLoaderParamsWithoutLoader(dir, imageLoader) {
  if (dir.loaderParams && imageLoader === noopImageLoader) {
    console.warn(formatRuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`loaderParams\` attribute is present but no image loader is configured (i.e. the default one is being used), which means that the loaderParams data will not be consumed and will not affect the URL. To fix this, provide a custom loader or remove the \`loaderParams\` attribute from the image.`));
  }
}
function assetPriorityCountBelowThreshold(appRef) {
  return __async(this, null, function* () {
    if (IMGS_WITH_PRIORITY_ATTR_COUNT === 0) {
      IMGS_WITH_PRIORITY_ATTR_COUNT++;
      yield appRef.whenStable();
      if (IMGS_WITH_PRIORITY_ATTR_COUNT > PRIORITY_COUNT_THRESHOLD) {
        console.warn(formatRuntimeError(2966, `NgOptimizedImage: The "priority" attribute is set to true more than ${PRIORITY_COUNT_THRESHOLD} times (${IMGS_WITH_PRIORITY_ATTR_COUNT} times). Marking too many images as "high" priority can hurt your application's LCP (https://web.dev/lcp). "Priority" should only be set on the image expected to be the page's LCP element.`));
      }
    } else {
      IMGS_WITH_PRIORITY_ATTR_COUNT++;
    }
  });
}
function assertPlaceholderDimensions(dir, imgElement) {
  const computedStyle = window.getComputedStyle(imgElement);
  let renderedWidth = parseFloat(computedStyle.getPropertyValue("width"));
  let renderedHeight = parseFloat(computedStyle.getPropertyValue("height"));
  if (renderedWidth > PLACEHOLDER_DIMENSION_LIMIT || renderedHeight > PLACEHOLDER_DIMENSION_LIMIT) {
    console.warn(formatRuntimeError(2967, `${imgDirectiveDetails(dir.ngSrc)} it uses a placeholder image, but at least one of the dimensions attribute (height or width) exceeds the limit of ${PLACEHOLDER_DIMENSION_LIMIT}px. To fix this, use a smaller image as a placeholder.`));
  }
}
function callOnLoadIfImageIsLoaded(img, callback) {
  if (img.complete && img.naturalWidth) {
    callback();
  }
}
function round(input2) {
  return Number.isInteger(input2) ? input2 : input2.toFixed(2);
}
function unwrapSafeUrl(value) {
  if (typeof value === "string") {
    return value;
  }
  return unwrapSafeValue(value);
}
function booleanOrUrlAttribute(value) {
  if (typeof value === "string" && value !== "true" && value !== "false" && value !== "") {
    return value;
  }
  return booleanAttribute(value);
}
var PLATFORM_BROWSER_ID, VERSION2, ViewportScroller, BrowserViewportScroller, PLACEHOLDER_QUALITY, noopImageLoader, IMAGE_LOADER, provideCloudflareLoader, cloudinaryLoaderInfo, CLOUDINARY_LOADER_REGEX, provideCloudinaryLoader, imageKitLoaderInfo, IMAGE_KIT_LOADER_REGEX, provideImageKitLoader, imgixLoaderInfo, IMGIX_LOADER_REGEX, provideImgixLoader, netlifyLoaderInfo, NETLIFY_LOADER_REGEX, LCPImageObserver, INTERNAL_PRECONNECT_CHECK_BLOCKLIST, PRECONNECT_CHECK_BLOCKLIST, PreconnectLinkChecker, DEFAULT_PRELOADED_IMAGES_LIMIT, PRELOADED_IMAGES, PreloadLinkCreator, BASE64_IMG_MAX_LENGTH_IN_ERROR, VALID_WIDTH_DESCRIPTOR_SRCSET, VALID_DENSITY_DESCRIPTOR_SRCSET, ABSOLUTE_SRCSET_DENSITY_CAP, RECOMMENDED_SRCSET_DENSITY_CAP, DENSITY_SRCSET_MULTIPLIERS, VIEWPORT_BREAKPOINT_CUTOFF, ASPECT_RATIO_TOLERANCE, OVERSIZED_IMAGE_TOLERANCE2, FIXED_SRCSET_WIDTH_LIMIT, FIXED_SRCSET_HEIGHT_LIMIT, PLACEHOLDER_DIMENSION_LIMIT, DATA_URL_WARN_LIMIT, DATA_URL_ERROR_LIMIT, BUILT_IN_LOADERS, PRIORITY_COUNT_THRESHOLD, IMGS_WITH_PRIORITY_ATTR_COUNT, NgOptimizedImage;
var init_common = __esm({
  "node_modules/@angular/common/fesm2022/common.mjs"() {
    "use strict";
    init_common_module();
    init_core();
    init_core();
    init_core();
    init_xhr();
    init_location();
    PLATFORM_BROWSER_ID = "browser";
    VERSION2 = new Version("20.1.7");
    ViewportScroller = class _ViewportScroller {
      // De-sugared tree-shakable injection
      // See #23917
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _ViewportScroller,
          providedIn: "root",
          factory: () => false ? new NullViewportScroller() : new BrowserViewportScroller(inject2(DOCUMENT), window)
        })
      );
    };
    BrowserViewportScroller = class {
      document;
      window;
      offset = () => [0, 0];
      constructor(document2, window2) {
        this.document = document2;
        this.window = window2;
      }
      /**
       * Configures the top offset used when scrolling to an anchor.
       * @param offset A position in screen coordinates (a tuple with x and y values)
       * or a function that returns the top offset position.
       *
       */
      setOffset(offset) {
        if (Array.isArray(offset)) {
          this.offset = () => offset;
        } else {
          this.offset = offset;
        }
      }
      /**
       * Retrieves the current scroll position.
       * @returns The position in screen coordinates.
       */
      getScrollPosition() {
        return [this.window.scrollX, this.window.scrollY];
      }
      /**
       * Sets the scroll position.
       * @param position The new position in screen coordinates.
       */
      scrollToPosition(position, options) {
        this.window.scrollTo(__spreadProps(__spreadValues({}, options), {
          left: position[0],
          top: position[1]
        }));
      }
      /**
       * Scrolls to an element and attempts to focus the element.
       *
       * Note that the function name here is misleading in that the target string may be an ID for a
       * non-anchor element.
       *
       * @param target The ID of an element or name of the anchor.
       *
       * @see https://html.spec.whatwg.org/#the-indicated-part-of-the-document
       * @see https://html.spec.whatwg.org/#scroll-to-fragid
       */
      scrollToAnchor(target, options) {
        const elSelected = findAnchorFromDocument(this.document, target);
        if (elSelected) {
          this.scrollToElement(elSelected, options);
          elSelected.focus();
        }
      }
      /**
       * Disables automatic scroll restoration provided by the browser.
       */
      setHistoryScrollRestoration(scrollRestoration) {
        try {
          this.window.history.scrollRestoration = scrollRestoration;
        } catch {
          console.warn(formatRuntimeError(2400, ngDevMode && "Failed to set `window.history.scrollRestoration`. This may occur when:\n\u2022 The script is running inside a sandboxed iframe\n\u2022 The window is partially navigated or inactive\n\u2022 The script is executed in an untrusted or special context (e.g., test runners, browser extensions, or content previews)\nScroll position may not be preserved across navigation."));
        }
      }
      /**
       * Scrolls to an element using the native offset and the specified offset set on this scroller.
       *
       * The offset can be used when we know that there is a floating header and scrolling naively to an
       * element (ex: `scrollIntoView`) leaves the element hidden behind the floating header.
       */
      scrollToElement(el2, options) {
        const rect = el2.getBoundingClientRect();
        const left = rect.left + this.window.pageXOffset;
        const top = rect.top + this.window.pageYOffset;
        const offset = this.offset();
        this.window.scrollTo(__spreadProps(__spreadValues({}, options), {
          left: left - offset[0],
          top: top - offset[1]
        }));
      }
    };
    PLACEHOLDER_QUALITY = "20";
    noopImageLoader = (config2) => config2.src;
    IMAGE_LOADER = new InjectionToken(ngDevMode ? "ImageLoader" : "", {
      providedIn: "root",
      factory: () => noopImageLoader
    });
    provideCloudflareLoader = createImageLoader(createCloudflareUrl, ngDevMode ? ["https://<ZONE>/cdn-cgi/image/<OPTIONS>/<SOURCE-IMAGE>"] : void 0);
    cloudinaryLoaderInfo = {
      name: "Cloudinary",
      testUrl: isCloudinaryUrl
    };
    CLOUDINARY_LOADER_REGEX = /https?\:\/\/[^\/]+\.cloudinary\.com\/.+/;
    provideCloudinaryLoader = createImageLoader(createCloudinaryUrl, ngDevMode ? ["https://res.cloudinary.com/mysite", "https://mysite.cloudinary.com", "https://subdomain.mysite.com"] : void 0);
    imageKitLoaderInfo = {
      name: "ImageKit",
      testUrl: isImageKitUrl
    };
    IMAGE_KIT_LOADER_REGEX = /https?\:\/\/[^\/]+\.imagekit\.io\/.+/;
    provideImageKitLoader = createImageLoader(createImagekitUrl, ngDevMode ? ["https://ik.imagekit.io/mysite", "https://subdomain.mysite.com"] : void 0);
    imgixLoaderInfo = {
      name: "Imgix",
      testUrl: isImgixUrl
    };
    IMGIX_LOADER_REGEX = /https?\:\/\/[^\/]+\.imgix\.net\/.+/;
    provideImgixLoader = createImageLoader(createImgixUrl, ngDevMode ? ["https://somepath.imgix.net/"] : void 0);
    netlifyLoaderInfo = {
      name: "Netlify",
      testUrl: isNetlifyUrl
    };
    NETLIFY_LOADER_REGEX = /https?\:\/\/[^\/]+\.netlify\.app\/.+/;
    LCPImageObserver = class _LCPImageObserver {
      // Map of full image URLs -> original `ngSrc` values.
      images = /* @__PURE__ */ new Map();
      window = inject2(DOCUMENT).defaultView;
      observer = null;
      constructor() {
        assertDevMode("LCP checker");
        if (typeof PerformanceObserver !== "undefined") {
          this.observer = this.initPerformanceObserver();
        }
      }
      /**
       * Inits PerformanceObserver and subscribes to LCP events.
       * Based on https://web.dev/lcp/#measure-lcp-in-javascript
       */
      initPerformanceObserver() {
        const observer = new PerformanceObserver((entryList) => {
          const entries = entryList.getEntries();
          if (entries.length === 0) return;
          const lcpElement = entries[entries.length - 1];
          const imgSrc = lcpElement.element?.src ?? "";
          if (imgSrc.startsWith("data:") || imgSrc.startsWith("blob:")) return;
          const img = this.images.get(imgSrc);
          if (!img) return;
          if (!img.priority && !img.alreadyWarnedPriority) {
            img.alreadyWarnedPriority = true;
            logMissingPriorityError(imgSrc);
          }
          if (img.modified && !img.alreadyWarnedModified) {
            img.alreadyWarnedModified = true;
            logModifiedWarning(imgSrc);
          }
        });
        observer.observe({
          type: "largest-contentful-paint",
          buffered: true
        });
        return observer;
      }
      registerImage(rewrittenSrc, originalNgSrc, isPriority) {
        if (!this.observer) return;
        const newObservedImageState = {
          priority: isPriority,
          modified: false,
          alreadyWarnedModified: false,
          alreadyWarnedPriority: false
        };
        this.images.set(getUrl(rewrittenSrc, this.window).href, newObservedImageState);
      }
      unregisterImage(rewrittenSrc) {
        if (!this.observer) return;
        this.images.delete(getUrl(rewrittenSrc, this.window).href);
      }
      updateImage(originalSrc, newSrc) {
        if (!this.observer) return;
        const originalUrl = getUrl(originalSrc, this.window).href;
        const img = this.images.get(originalUrl);
        if (img) {
          img.modified = true;
          this.images.set(getUrl(newSrc, this.window).href, img);
          this.images.delete(originalUrl);
        }
      }
      ngOnDestroy() {
        if (!this.observer) return;
        this.observer.disconnect();
        this.images.clear();
      }
      static \u0275fac = function LCPImageObserver_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _LCPImageObserver)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _LCPImageObserver,
        factory: _LCPImageObserver.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LCPImageObserver, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [], null);
    })();
    INTERNAL_PRECONNECT_CHECK_BLOCKLIST = /* @__PURE__ */ new Set(["localhost", "127.0.0.1", "0.0.0.0"]);
    PRECONNECT_CHECK_BLOCKLIST = new InjectionToken(ngDevMode ? "PRECONNECT_CHECK_BLOCKLIST" : "");
    PreconnectLinkChecker = class _PreconnectLinkChecker {
      document = inject2(DOCUMENT);
      /**
       * Set of <link rel="preconnect"> tags found on this page.
       * The `null` value indicates that there was no DOM query operation performed.
       */
      preconnectLinks = null;
      /*
       * Keep track of all already seen origin URLs to avoid repeating the same check.
       */
      alreadySeen = /* @__PURE__ */ new Set();
      window = this.document.defaultView;
      blocklist = new Set(INTERNAL_PRECONNECT_CHECK_BLOCKLIST);
      constructor() {
        assertDevMode("preconnect link checker");
        const blocklist = inject2(PRECONNECT_CHECK_BLOCKLIST, {
          optional: true
        });
        if (blocklist) {
          this.populateBlocklist(blocklist);
        }
      }
      populateBlocklist(origins) {
        if (Array.isArray(origins)) {
          deepForEach2(origins, (origin) => {
            this.blocklist.add(extractHostname(origin));
          });
        } else {
          this.blocklist.add(extractHostname(origins));
        }
      }
      /**
       * Checks that a preconnect resource hint exists in the head for the
       * given src.
       *
       * @param rewrittenSrc src formatted with loader
       * @param originalNgSrc ngSrc value
       */
      assertPreconnect(rewrittenSrc, originalNgSrc) {
        if (false) return;
        const imgUrl = getUrl(rewrittenSrc, this.window);
        if (this.blocklist.has(imgUrl.hostname) || this.alreadySeen.has(imgUrl.origin)) return;
        this.alreadySeen.add(imgUrl.origin);
        this.preconnectLinks ??= this.queryPreconnectLinks();
        if (!this.preconnectLinks.has(imgUrl.origin)) {
          console.warn(formatRuntimeError(2956, `${imgDirectiveDetails(originalNgSrc)} there is no preconnect tag present for this image. Preconnecting to the origin(s) that serve priority images ensures that these images are delivered as soon as possible. To fix this, please add the following element into the <head> of the document:
  <link rel="preconnect" href="${imgUrl.origin}">`));
        }
      }
      queryPreconnectLinks() {
        const preconnectUrls = /* @__PURE__ */ new Set();
        const links = this.document.querySelectorAll("link[rel=preconnect]");
        for (const link of links) {
          const url = getUrl(link.href, this.window);
          preconnectUrls.add(url.origin);
        }
        return preconnectUrls;
      }
      ngOnDestroy() {
        this.preconnectLinks?.clear();
        this.alreadySeen.clear();
      }
      static \u0275fac = function PreconnectLinkChecker_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _PreconnectLinkChecker)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _PreconnectLinkChecker,
        factory: _PreconnectLinkChecker.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreconnectLinkChecker, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [], null);
    })();
    DEFAULT_PRELOADED_IMAGES_LIMIT = 5;
    PRELOADED_IMAGES = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "NG_OPTIMIZED_PRELOADED_IMAGES" : "", {
      providedIn: "root",
      factory: () => /* @__PURE__ */ new Set()
    });
    PreloadLinkCreator = class _PreloadLinkCreator {
      preloadedImages = inject2(PRELOADED_IMAGES);
      document = inject2(DOCUMENT);
      errorShown = false;
      /**
       * @description Add a preload `<link>` to the `<head>` of the `index.html` that is served from the
       * server while using Angular Universal and SSR to kick off image loads for high priority images.
       *
       * The `sizes` (passed in from the user) and `srcset` (parsed and formatted from `ngSrcset`)
       * properties used to set the corresponding attributes, `imagesizes` and `imagesrcset`
       * respectively, on the preload `<link>` tag so that the correctly sized image is preloaded from
       * the CDN.
       *
       * {@link https://web.dev/preload-responsive-images/#imagesrcset-and-imagesizes}
       *
       * @param renderer The `Renderer2` passed in from the directive
       * @param src The original src of the image that is set on the `ngSrc` input.
       * @param srcset The parsed and formatted srcset created from the `ngSrcset` input
       * @param sizes The value of the `sizes` attribute passed in to the `<img>` tag
       */
      createPreloadLinkTag(renderer, src, srcset, sizes) {
        if (ngDevMode && !this.errorShown && this.preloadedImages.size >= DEFAULT_PRELOADED_IMAGES_LIMIT) {
          this.errorShown = true;
          console.warn(formatRuntimeError(2961, `The \`NgOptimizedImage\` directive has detected that more than ${DEFAULT_PRELOADED_IMAGES_LIMIT} images were marked as priority. This might negatively affect an overall performance of the page. To fix this, remove the "priority" attribute from images with less priority.`));
        }
        if (this.preloadedImages.has(src)) {
          return;
        }
        this.preloadedImages.add(src);
        const preload = renderer.createElement("link");
        renderer.setAttribute(preload, "as", "image");
        renderer.setAttribute(preload, "href", src);
        renderer.setAttribute(preload, "rel", "preload");
        renderer.setAttribute(preload, "fetchpriority", "high");
        if (sizes) {
          renderer.setAttribute(preload, "imageSizes", sizes);
        }
        if (srcset) {
          renderer.setAttribute(preload, "imageSrcset", srcset);
        }
        renderer.appendChild(this.document.head, preload);
      }
      static \u0275fac = function PreloadLinkCreator_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _PreloadLinkCreator)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _PreloadLinkCreator,
        factory: _PreloadLinkCreator.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreloadLinkCreator, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    BASE64_IMG_MAX_LENGTH_IN_ERROR = 50;
    VALID_WIDTH_DESCRIPTOR_SRCSET = /^((\s*\d+w\s*(,|$)){1,})$/;
    VALID_DENSITY_DESCRIPTOR_SRCSET = /^((\s*\d+(\.\d+)?x\s*(,|$)){1,})$/;
    ABSOLUTE_SRCSET_DENSITY_CAP = 3;
    RECOMMENDED_SRCSET_DENSITY_CAP = 2;
    DENSITY_SRCSET_MULTIPLIERS = [1, 2];
    VIEWPORT_BREAKPOINT_CUTOFF = 640;
    ASPECT_RATIO_TOLERANCE = 0.1;
    OVERSIZED_IMAGE_TOLERANCE2 = 1e3;
    FIXED_SRCSET_WIDTH_LIMIT = 1920;
    FIXED_SRCSET_HEIGHT_LIMIT = 1080;
    PLACEHOLDER_DIMENSION_LIMIT = 1e3;
    DATA_URL_WARN_LIMIT = 4e3;
    DATA_URL_ERROR_LIMIT = 1e4;
    BUILT_IN_LOADERS = [imgixLoaderInfo, imageKitLoaderInfo, cloudinaryLoaderInfo, netlifyLoaderInfo];
    PRIORITY_COUNT_THRESHOLD = 10;
    IMGS_WITH_PRIORITY_ATTR_COUNT = 0;
    NgOptimizedImage = class _NgOptimizedImage {
      imageLoader = inject2(IMAGE_LOADER);
      config = processConfig(inject2(IMAGE_CONFIG));
      renderer = inject2(Renderer2);
      imgElement = inject2(ElementRef).nativeElement;
      injector = inject2(Injector);
      // An LCP image observer should be injected only in development mode.
      // Do not assign it to `null` to avoid having a redundant property in the production bundle.
      lcpObserver;
      /**
       * Calculate the rewritten `src` once and store it.
       * This is needed to avoid repetitive calculations and make sure the directive cleanup in the
       * `ngOnDestroy` does not rely on the `IMAGE_LOADER` logic (which in turn can rely on some other
       * instance that might be already destroyed).
       */
      _renderedSrc = null;
      /**
       * Name of the source image.
       * Image name will be processed by the image loader and the final URL will be applied as the `src`
       * property of the image.
       */
      ngSrc;
      /**
       * A comma separated list of width or density descriptors.
       * The image name will be taken from `ngSrc` and combined with the list of width or density
       * descriptors to generate the final `srcset` property of the image.
       *
       * Example:
       * ```html
       * <img ngSrc="hello.jpg" ngSrcset="100w, 200w" />  =>
       * <img src="path/hello.jpg" srcset="path/hello.jpg?w=100 100w, path/hello.jpg?w=200 200w" />
       * ```
       */
      ngSrcset;
      /**
       * The base `sizes` attribute passed through to the `<img>` element.
       * Providing sizes causes the image to create an automatic responsive srcset.
       */
      sizes;
      /**
       * For responsive images: the intrinsic width of the image in pixels.
       * For fixed size images: the desired rendered width of the image in pixels.
       */
      width;
      /**
       * For responsive images: the intrinsic height of the image in pixels.
       * For fixed size images: the desired rendered height of the image in pixels.
       */
      height;
      /**
       * The desired decoding behavior for the image. Defaults to `auto`
       * if not explicitly set, matching native browser behavior.
       *
       * Use `async` to decode the image off the main thread (non-blocking),
       * `sync` for immediate decoding (blocking), or `auto` to let the
       * browser decide the optimal strategy.
       *
       * [Spec](https://html.spec.whatwg.org/multipage/images.html#image-decoding-hint)
       */
      decoding;
      /**
       * The desired loading behavior (lazy, eager, or auto). Defaults to `lazy`,
       * which is recommended for most images.
       *
       * Warning: Setting images as loading="eager" or loading="auto" marks them
       * as non-priority images and can hurt loading performance. For images which
       * may be the LCP element, use the `priority` attribute instead of `loading`.
       */
      loading;
      /**
       * Indicates whether this image should have a high priority.
       */
      priority = false;
      /**
       * Data to pass through to custom loaders.
       */
      loaderParams;
      /**
       * Disables automatic srcset generation for this image.
       */
      disableOptimizedSrcset = false;
      /**
       * Sets the image to "fill mode", which eliminates the height/width requirement and adds
       * styles such that the image fills its containing element.
       */
      fill = false;
      /**
       * A URL or data URL for an image to be used as a placeholder while this image loads.
       */
      placeholder;
      /**
       * Configuration object for placeholder settings. Options:
       *   * blur: Setting this to false disables the automatic CSS blur.
       */
      placeholderConfig;
      /**
       * Value of the `src` attribute if set on the host `<img>` element.
       * This input is exclusively read to assert that `src` is not set in conflict
       * with `ngSrc` and that images don't start to load until a lazy loading strategy is set.
       * @internal
       */
      src;
      /**
       * Value of the `srcset` attribute if set on the host `<img>` element.
       * This input is exclusively read to assert that `srcset` is not set in conflict
       * with `ngSrcset` and that images don't start to load until a lazy loading strategy is set.
       * @internal
       */
      srcset;
      constructor() {
        if (ngDevMode) {
          this.lcpObserver = this.injector.get(LCPImageObserver);
          const destroyRef = inject2(DestroyRef);
          destroyRef.onDestroy(() => {
            if (!this.priority && this._renderedSrc !== null) {
              this.lcpObserver.unregisterImage(this._renderedSrc);
            }
          });
        }
      }
      /** @docs-private */
      ngOnInit() {
        performanceMarkFeature("NgOptimizedImage");
        if (ngDevMode) {
          const ngZone = this.injector.get(NgZone);
          assertNonEmptyInput(this, "ngSrc", this.ngSrc);
          assertValidNgSrcset(this, this.ngSrcset);
          assertNoConflictingSrc(this);
          if (this.ngSrcset) {
            assertNoConflictingSrcset(this);
          }
          assertNotBase64Image(this);
          assertNotBlobUrl(this);
          if (this.fill) {
            assertEmptyWidthAndHeight(this);
            ngZone.runOutsideAngular(() => assertNonZeroRenderedHeight(this, this.imgElement, this.renderer));
          } else {
            assertNonEmptyWidthAndHeight(this);
            if (this.height !== void 0) {
              assertGreaterThanZero(this, this.height, "height");
            }
            if (this.width !== void 0) {
              assertGreaterThanZero(this, this.width, "width");
            }
            ngZone.runOutsideAngular(() => assertNoImageDistortion(this, this.imgElement, this.renderer));
          }
          assertValidLoadingInput(this);
          assertValidDecodingInput(this);
          if (!this.ngSrcset) {
            assertNoComplexSizes(this);
          }
          assertValidPlaceholder(this, this.imageLoader);
          assertNotMissingBuiltInLoader(this.ngSrc, this.imageLoader);
          assertNoNgSrcsetWithoutLoader(this, this.imageLoader);
          assertNoLoaderParamsWithoutLoader(this, this.imageLoader);
          ngZone.runOutsideAngular(() => {
            this.lcpObserver.registerImage(this.getRewrittenSrc(), this.ngSrc, this.priority);
          });
          if (this.priority) {
            const checker = this.injector.get(PreconnectLinkChecker);
            checker.assertPreconnect(this.getRewrittenSrc(), this.ngSrc);
            if (true) {
              const applicationRef = this.injector.get(ApplicationRef);
              assetPriorityCountBelowThreshold(applicationRef);
            }
          }
        }
        if (this.placeholder) {
          this.removePlaceholderOnLoad(this.imgElement);
        }
        this.setHostAttributes();
      }
      setHostAttributes() {
        if (this.fill) {
          this.sizes ||= "100vw";
        } else {
          this.setHostAttribute("width", this.width.toString());
          this.setHostAttribute("height", this.height.toString());
        }
        this.setHostAttribute("loading", this.getLoadingBehavior());
        this.setHostAttribute("fetchpriority", this.getFetchPriority());
        this.setHostAttribute("decoding", this.getDecoding());
        this.setHostAttribute("ng-img", "true");
        const rewrittenSrcset = this.updateSrcAndSrcset();
        if (this.sizes) {
          if (this.getLoadingBehavior() === "lazy") {
            this.setHostAttribute("sizes", "auto, " + this.sizes);
          } else {
            this.setHostAttribute("sizes", this.sizes);
          }
        } else {
          if (this.ngSrcset && VALID_WIDTH_DESCRIPTOR_SRCSET.test(this.ngSrcset) && this.getLoadingBehavior() === "lazy") {
            this.setHostAttribute("sizes", "auto, 100vw");
          }
        }
        if (false) {
          const preloadLinkCreator = this.injector.get(PreloadLinkCreator);
          preloadLinkCreator.createPreloadLinkTag(this.renderer, this.getRewrittenSrc(), rewrittenSrcset, this.sizes);
        }
      }
      /** @docs-private */
      ngOnChanges(changes) {
        if (ngDevMode) {
          assertNoPostInitInputChange(this, changes, ["ngSrcset", "width", "height", "priority", "fill", "loading", "sizes", "loaderParams", "disableOptimizedSrcset"]);
        }
        if (changes["ngSrc"] && !changes["ngSrc"].isFirstChange()) {
          const oldSrc = this._renderedSrc;
          this.updateSrcAndSrcset(true);
          if (ngDevMode) {
            const newSrc = this._renderedSrc;
            if (oldSrc && newSrc && oldSrc !== newSrc) {
              const ngZone = this.injector.get(NgZone);
              ngZone.runOutsideAngular(() => {
                this.lcpObserver.updateImage(oldSrc, newSrc);
              });
            }
          }
        }
        if (ngDevMode && changes["placeholder"]?.currentValue && true && true) {
          assertPlaceholderDimensions(this, this.imgElement);
        }
      }
      callImageLoader(configWithoutCustomParams) {
        let augmentedConfig = configWithoutCustomParams;
        if (this.loaderParams) {
          augmentedConfig.loaderParams = this.loaderParams;
        }
        return this.imageLoader(augmentedConfig);
      }
      getLoadingBehavior() {
        if (!this.priority && this.loading !== void 0) {
          return this.loading;
        }
        return this.priority ? "eager" : "lazy";
      }
      getFetchPriority() {
        return this.priority ? "high" : "auto";
      }
      getDecoding() {
        if (this.priority) {
          return "sync";
        }
        return this.decoding ?? "auto";
      }
      getRewrittenSrc() {
        if (!this._renderedSrc) {
          const imgConfig = {
            src: this.ngSrc
          };
          this._renderedSrc = this.callImageLoader(imgConfig);
        }
        return this._renderedSrc;
      }
      getRewrittenSrcset() {
        const widthSrcSet = VALID_WIDTH_DESCRIPTOR_SRCSET.test(this.ngSrcset);
        const finalSrcs = this.ngSrcset.split(",").filter((src) => src !== "").map((srcStr) => {
          srcStr = srcStr.trim();
          const width = widthSrcSet ? parseFloat(srcStr) : parseFloat(srcStr) * this.width;
          return `${this.callImageLoader({
            src: this.ngSrc,
            width
          })} ${srcStr}`;
        });
        return finalSrcs.join(", ");
      }
      getAutomaticSrcset() {
        if (this.sizes) {
          return this.getResponsiveSrcset();
        } else {
          return this.getFixedSrcset();
        }
      }
      getResponsiveSrcset() {
        const {
          breakpoints
        } = this.config;
        let filteredBreakpoints = breakpoints;
        if (this.sizes?.trim() === "100vw") {
          filteredBreakpoints = breakpoints.filter((bp) => bp >= VIEWPORT_BREAKPOINT_CUTOFF);
        }
        const finalSrcs = filteredBreakpoints.map((bp) => `${this.callImageLoader({
          src: this.ngSrc,
          width: bp
        })} ${bp}w`);
        return finalSrcs.join(", ");
      }
      updateSrcAndSrcset(forceSrcRecalc = false) {
        if (forceSrcRecalc) {
          this._renderedSrc = null;
        }
        const rewrittenSrc = this.getRewrittenSrc();
        this.setHostAttribute("src", rewrittenSrc);
        let rewrittenSrcset = void 0;
        if (this.ngSrcset) {
          rewrittenSrcset = this.getRewrittenSrcset();
        } else if (this.shouldGenerateAutomaticSrcset()) {
          rewrittenSrcset = this.getAutomaticSrcset();
        }
        if (rewrittenSrcset) {
          this.setHostAttribute("srcset", rewrittenSrcset);
        }
        return rewrittenSrcset;
      }
      getFixedSrcset() {
        const finalSrcs = DENSITY_SRCSET_MULTIPLIERS.map((multiplier) => `${this.callImageLoader({
          src: this.ngSrc,
          width: this.width * multiplier
        })} ${multiplier}x`);
        return finalSrcs.join(", ");
      }
      shouldGenerateAutomaticSrcset() {
        let oversizedImage = false;
        if (!this.sizes) {
          oversizedImage = this.width > FIXED_SRCSET_WIDTH_LIMIT || this.height > FIXED_SRCSET_HEIGHT_LIMIT;
        }
        return !this.disableOptimizedSrcset && !this.srcset && this.imageLoader !== noopImageLoader && !oversizedImage;
      }
      /**
       * Returns an image url formatted for use with the CSS background-image property. Expects one of:
       * * A base64 encoded image, which is wrapped and passed through.
       * * A boolean. If true, calls the image loader to generate a small placeholder url.
       */
      generatePlaceholder(placeholderInput) {
        const {
          placeholderResolution
        } = this.config;
        if (placeholderInput === true) {
          return `url(${this.callImageLoader({
            src: this.ngSrc,
            width: placeholderResolution,
            isPlaceholder: true
          })})`;
        } else if (typeof placeholderInput === "string") {
          return `url(${placeholderInput})`;
        }
        return null;
      }
      /**
       * Determines if blur should be applied, based on an optional boolean
       * property `blur` within the optional configuration object `placeholderConfig`.
       */
      shouldBlurPlaceholder(placeholderConfig) {
        if (!placeholderConfig || !placeholderConfig.hasOwnProperty("blur")) {
          return true;
        }
        return Boolean(placeholderConfig.blur);
      }
      removePlaceholderOnLoad(img) {
        const callback = () => {
          const changeDetectorRef = this.injector.get(ChangeDetectorRef);
          removeLoadListenerFn();
          removeErrorListenerFn();
          this.placeholder = false;
          changeDetectorRef.markForCheck();
        };
        const removeLoadListenerFn = this.renderer.listen(img, "load", callback);
        const removeErrorListenerFn = this.renderer.listen(img, "error", callback);
        callOnLoadIfImageIsLoaded(img, callback);
      }
      setHostAttribute(name, value) {
        this.renderer.setAttribute(this.imgElement, name, value);
      }
      static \u0275fac = function NgOptimizedImage_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgOptimizedImage)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgOptimizedImage,
        selectors: [["img", "ngSrc", ""]],
        hostVars: 18,
        hostBindings: function NgOptimizedImage_HostBindings(rf2, ctx) {
          if (rf2 & 2) {
            \u0275\u0275styleProp("position", ctx.fill ? "absolute" : null)("width", ctx.fill ? "100%" : null)("height", ctx.fill ? "100%" : null)("inset", ctx.fill ? "0" : null)("background-size", ctx.placeholder ? "cover" : null)("background-position", ctx.placeholder ? "50% 50%" : null)("background-repeat", ctx.placeholder ? "no-repeat" : null)("background-image", ctx.placeholder ? ctx.generatePlaceholder(ctx.placeholder) : null)("filter", ctx.placeholder && ctx.shouldBlurPlaceholder(ctx.placeholderConfig) ? "blur(15px)" : null);
          }
        },
        inputs: {
          ngSrc: [2, "ngSrc", "ngSrc", unwrapSafeUrl],
          ngSrcset: "ngSrcset",
          sizes: "sizes",
          width: [2, "width", "width", numberAttribute],
          height: [2, "height", "height", numberAttribute],
          decoding: "decoding",
          loading: "loading",
          priority: [2, "priority", "priority", booleanAttribute],
          loaderParams: "loaderParams",
          disableOptimizedSrcset: [2, "disableOptimizedSrcset", "disableOptimizedSrcset", booleanAttribute],
          fill: [2, "fill", "fill", booleanAttribute],
          placeholder: [2, "placeholder", "placeholder", booleanOrUrlAttribute],
          placeholderConfig: "placeholderConfig",
          src: "src",
          srcset: "srcset"
        },
        features: [\u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgOptimizedImage, [{
        type: Directive,
        args: [{
          selector: "img[ngSrc]",
          host: {
            "[style.position]": 'fill ? "absolute" : null',
            "[style.width]": 'fill ? "100%" : null',
            "[style.height]": 'fill ? "100%" : null',
            "[style.inset]": 'fill ? "0" : null',
            "[style.background-size]": 'placeholder ? "cover" : null',
            "[style.background-position]": 'placeholder ? "50% 50%" : null',
            "[style.background-repeat]": 'placeholder ? "no-repeat" : null',
            "[style.background-image]": "placeholder ? generatePlaceholder(placeholder) : null",
            "[style.filter]": 'placeholder && shouldBlurPlaceholder(placeholderConfig) ? "blur(15px)" : null'
          }
        }]
      }], () => [], {
        ngSrc: [{
          type: Input,
          args: [{
            required: true,
            transform: unwrapSafeUrl
          }]
        }],
        ngSrcset: [{
          type: Input
        }],
        sizes: [{
          type: Input
        }],
        width: [{
          type: Input,
          args: [{
            transform: numberAttribute
          }]
        }],
        height: [{
          type: Input,
          args: [{
            transform: numberAttribute
          }]
        }],
        decoding: [{
          type: Input
        }],
        loading: [{
          type: Input
        }],
        priority: [{
          type: Input,
          args: [{
            transform: booleanAttribute
          }]
        }],
        loaderParams: [{
          type: Input
        }],
        disableOptimizedSrcset: [{
          type: Input,
          args: [{
            transform: booleanAttribute
          }]
        }],
        fill: [{
          type: Input,
          args: [{
            transform: booleanAttribute
          }]
        }],
        placeholder: [{
          type: Input,
          args: [{
            transform: booleanOrUrlAttribute
          }]
        }],
        placeholderConfig: [{
          type: Input
        }],
        src: [{
          type: Input
        }],
        srcset: [{
          type: Input
        }]
      });
    })();
  }
});

// node_modules/@angular/platform-browser/fesm2022/dom_renderer.mjs
function removeElements(elements) {
  for (const element of elements) {
    element.remove();
  }
}
function createStyleElement(style, doc) {
  const styleElement = doc.createElement("style");
  styleElement.textContent = style;
  return styleElement;
}
function addServerStyles(doc, appId, inline, external) {
  const elements = doc.head?.querySelectorAll(`style[${APP_ID_ATTRIBUTE_NAME}="${appId}"],link[${APP_ID_ATTRIBUTE_NAME}="${appId}"]`);
  if (elements) {
    for (const styleElement of elements) {
      styleElement.removeAttribute(APP_ID_ATTRIBUTE_NAME);
      if (styleElement instanceof HTMLLinkElement) {
        external.set(styleElement.href.slice(styleElement.href.lastIndexOf("/") + 1), {
          usage: 0,
          elements: [styleElement]
        });
      } else if (styleElement.textContent) {
        inline.set(styleElement.textContent, {
          usage: 0,
          elements: [styleElement]
        });
      }
    }
  }
}
function createLinkElement(url, doc) {
  const linkElement = doc.createElement("link");
  linkElement.setAttribute("rel", "stylesheet");
  linkElement.setAttribute("href", url);
  return linkElement;
}
function shimContentAttribute(componentShortId) {
  return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function shimHostAttribute(componentShortId) {
  return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function shimStylesContent(compId, styles) {
  return styles.map((s2) => s2.replace(COMPONENT_REGEX, compId));
}
function addBaseHrefToCssSourceMap(baseHref, styles) {
  if (!baseHref) {
    return styles;
  }
  const absoluteBaseHrefUrl = new URL(baseHref, "http://localhost");
  return styles.map((cssContent) => {
    if (!cssContent.includes("sourceMappingURL=")) {
      return cssContent;
    }
    return cssContent.replace(SOURCEMAP_URL_REGEXP, (_2, sourceMapUrl) => {
      if (sourceMapUrl[0] === "/" || sourceMapUrl.startsWith("data:") || PROTOCOL_REGEXP.test(sourceMapUrl)) {
        return `/*# sourceMappingURL=${sourceMapUrl} */`;
      }
      const {
        pathname: resolvedSourceMapUrl
      } = new URL(sourceMapUrl, absoluteBaseHrefUrl);
      return `/*# sourceMappingURL=${resolvedSourceMapUrl} */`;
    });
  });
}
function checkNoSyntheticProp(name, nameKind) {
  if (name.charCodeAt(0) === AT_CHARCODE) {
    throw new RuntimeError(5105, `Unexpected synthetic ${nameKind} ${name} found. Please make sure that:
  - Make sure \`provideAnimationsAsync()\`, \`provideAnimations()\` or \`provideNoopAnimations()\` call was added to a list of providers used to bootstrap an application.
  - There is a corresponding animation configuration named \`${name}\` defined in the \`animations\` field of the \`@Component\` decorator (see https://angular.dev/api/core/Component#animations).`);
  }
}
function isTemplateNode(node) {
  return node.tagName === "TEMPLATE" && node.content !== void 0;
}
var EVENT_MANAGER_PLUGINS, EventManager, EventManagerPlugin, APP_ID_ATTRIBUTE_NAME, SharedStylesHost, NAMESPACE_URIS, COMPONENT_REGEX, SOURCEMAP_URL_REGEXP, PROTOCOL_REGEXP, COMPONENT_VARIABLE, HOST_ATTR, CONTENT_ATTR, REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT, REMOVE_STYLES_ON_COMPONENT_DESTROY, DomRendererFactory2, DefaultDomRenderer2, AT_CHARCODE, ShadowDomRenderer, NoneEncapsulationDomRenderer, EmulatedEncapsulationDomRenderer2;
var init_dom_renderer = __esm({
  "node_modules/@angular/platform-browser/fesm2022/dom_renderer.mjs"() {
    "use strict";
    init_common();
    init_core();
    init_core();
    EVENT_MANAGER_PLUGINS = new InjectionToken(ngDevMode ? "EventManagerPlugins" : "");
    EventManager = class _EventManager {
      _zone;
      _plugins;
      _eventNameToPlugin = /* @__PURE__ */ new Map();
      /**
       * Initializes an instance of the event-manager service.
       */
      constructor(plugins, _zone) {
        this._zone = _zone;
        plugins.forEach((plugin) => {
          plugin.manager = this;
        });
        this._plugins = plugins.slice().reverse();
      }
      /**
       * Registers a handler for a specific element and event.
       *
       * @param element The HTML element to receive event notifications.
       * @param eventName The name of the event to listen for.
       * @param handler A function to call when the notification occurs. Receives the
       * event object as an argument.
       * @param options Options that configure how the event listener is bound.
       * @returns  A callback function that can be used to remove the handler.
       */
      addEventListener(element, eventName, handler, options) {
        const plugin = this._findPluginFor(eventName);
        return plugin.addEventListener(element, eventName, handler, options);
      }
      /**
       * Retrieves the compilation zone in which event listeners are registered.
       */
      getZone() {
        return this._zone;
      }
      /** @internal */
      _findPluginFor(eventName) {
        let plugin = this._eventNameToPlugin.get(eventName);
        if (plugin) {
          return plugin;
        }
        const plugins = this._plugins;
        plugin = plugins.find((plugin2) => plugin2.supports(eventName));
        if (!plugin) {
          throw new RuntimeError(5101, (typeof ngDevMode === "undefined" || ngDevMode) && `No event manager plugin found for event ${eventName}`);
        }
        this._eventNameToPlugin.set(eventName, plugin);
        return plugin;
      }
      static \u0275fac = function EventManager_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _EventManager)(\u0275\u0275inject(EVENT_MANAGER_PLUGINS), \u0275\u0275inject(NgZone));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _EventManager,
        factory: _EventManager.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EventManager, [{
        type: Injectable
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [EVENT_MANAGER_PLUGINS]
        }]
      }, {
        type: NgZone
      }], null);
    })();
    EventManagerPlugin = class {
      _doc;
      // TODO: remove (has some usage in G3)
      constructor(_doc) {
        this._doc = _doc;
      }
      // Using non-null assertion because it's set by EventManager's constructor
      manager;
    };
    APP_ID_ATTRIBUTE_NAME = "ng-app-id";
    SharedStylesHost = class _SharedStylesHost {
      doc;
      appId;
      nonce;
      /**
       * Provides usage information for active inline style content and associated HTML <style> elements.
       * Embedded styles typically originate from the `styles` metadata of a rendered component.
       */
      inline = /* @__PURE__ */ new Map();
      /**
       * Provides usage information for active external style URLs and the associated HTML <link> elements.
       * External styles typically originate from the `ɵɵExternalStylesFeature` of a rendered component.
       */
      external = /* @__PURE__ */ new Map();
      /**
       * Set of host DOM nodes that will have styles attached.
       */
      hosts = /* @__PURE__ */ new Set();
      constructor(doc, appId, nonce, platformId = {}) {
        this.doc = doc;
        this.appId = appId;
        this.nonce = nonce;
        addServerStyles(doc, appId, this.inline, this.external);
        this.hosts.add(doc.head);
      }
      /**
       * Adds embedded styles to the DOM via HTML `style` elements.
       * @param styles An array of style content strings.
       */
      addStyles(styles, urls) {
        for (const value of styles) {
          this.addUsage(value, this.inline, createStyleElement);
        }
        urls?.forEach((value) => this.addUsage(value, this.external, createLinkElement));
      }
      /**
       * Removes embedded styles from the DOM that were added as HTML `style` elements.
       * @param styles An array of style content strings.
       */
      removeStyles(styles, urls) {
        for (const value of styles) {
          this.removeUsage(value, this.inline);
        }
        urls?.forEach((value) => this.removeUsage(value, this.external));
      }
      addUsage(value, usages, creator) {
        const record = usages.get(value);
        if (record) {
          if ((typeof ngDevMode === "undefined" || ngDevMode) && record.usage === 0) {
            record.elements.forEach((element) => element.setAttribute("ng-style-reused", ""));
          }
          record.usage++;
        } else {
          usages.set(value, {
            usage: 1,
            elements: [...this.hosts].map((host) => this.addElement(host, creator(value, this.doc)))
          });
        }
      }
      removeUsage(value, usages) {
        const record = usages.get(value);
        if (record) {
          record.usage--;
          if (record.usage <= 0) {
            removeElements(record.elements);
            usages.delete(value);
          }
        }
      }
      ngOnDestroy() {
        for (const [, {
          elements
        }] of [...this.inline, ...this.external]) {
          removeElements(elements);
        }
        this.hosts.clear();
      }
      /**
       * Adds a host node to the set of style hosts and adds all existing style usage to
       * the newly added host node.
       *
       * This is currently only used for Shadow DOM encapsulation mode.
       */
      addHost(hostNode) {
        this.hosts.add(hostNode);
        for (const [style, {
          elements
        }] of this.inline) {
          elements.push(this.addElement(hostNode, createStyleElement(style, this.doc)));
        }
        for (const [url, {
          elements
        }] of this.external) {
          elements.push(this.addElement(hostNode, createLinkElement(url, this.doc)));
        }
      }
      removeHost(hostNode) {
        this.hosts.delete(hostNode);
      }
      addElement(host, element) {
        if (this.nonce) {
          element.setAttribute("nonce", this.nonce);
        }
        if (false) {
          element.setAttribute(APP_ID_ATTRIBUTE_NAME, this.appId);
        }
        return host.appendChild(element);
      }
      static \u0275fac = function SharedStylesHost_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _SharedStylesHost)(\u0275\u0275inject(DOCUMENT), \u0275\u0275inject(APP_ID), \u0275\u0275inject(CSP_NONCE, 8), \u0275\u0275inject(PLATFORM_ID));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _SharedStylesHost,
        factory: _SharedStylesHost.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SharedStylesHost, [{
        type: Injectable
      }], () => [{
        type: Document,
        decorators: [{
          type: Inject,
          args: [DOCUMENT]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [APP_ID]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [CSP_NONCE]
        }, {
          type: Optional
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [PLATFORM_ID]
        }]
      }], null);
    })();
    NAMESPACE_URIS = {
      "svg": "http://www.w3.org/2000/svg",
      "xhtml": "http://www.w3.org/1999/xhtml",
      "xlink": "http://www.w3.org/1999/xlink",
      "xml": "http://www.w3.org/XML/1998/namespace",
      "xmlns": "http://www.w3.org/2000/xmlns/",
      "math": "http://www.w3.org/1998/Math/MathML"
    };
    COMPONENT_REGEX = /%COMP%/g;
    SOURCEMAP_URL_REGEXP = /\/\*#\s*sourceMappingURL=(.+?)\s*\*\//;
    PROTOCOL_REGEXP = /^https?:/;
    COMPONENT_VARIABLE = "%COMP%";
    HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
    CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
    REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT = true;
    REMOVE_STYLES_ON_COMPONENT_DESTROY = new InjectionToken(ngDevMode ? "RemoveStylesOnCompDestroy" : "", {
      providedIn: "root",
      factory: () => REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT
    });
    DomRendererFactory2 = class _DomRendererFactory2 {
      eventManager;
      sharedStylesHost;
      appId;
      removeStylesOnCompDestroy;
      doc;
      platformId;
      ngZone;
      nonce;
      tracingService;
      rendererByCompId = /* @__PURE__ */ new Map();
      defaultRenderer;
      platformIsServer;
      constructor(eventManager, sharedStylesHost, appId, removeStylesOnCompDestroy, doc, platformId, ngZone, nonce = null, tracingService = null) {
        this.eventManager = eventManager;
        this.sharedStylesHost = sharedStylesHost;
        this.appId = appId;
        this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;
        this.doc = doc;
        this.platformId = platformId;
        this.ngZone = ngZone;
        this.nonce = nonce;
        this.tracingService = tracingService;
        this.platformIsServer = false;
        this.defaultRenderer = new DefaultDomRenderer2(eventManager, doc, ngZone, this.platformIsServer, this.tracingService);
      }
      createRenderer(element, type) {
        if (!element || !type) {
          return this.defaultRenderer;
        }
        if (false) {
          type = __spreadProps(__spreadValues({}, type), {
            encapsulation: ViewEncapsulation.Emulated
          });
        }
        const renderer = this.getOrCreateRenderer(element, type);
        if (renderer instanceof EmulatedEncapsulationDomRenderer2) {
          renderer.applyToHost(element);
        } else if (renderer instanceof NoneEncapsulationDomRenderer) {
          renderer.applyStyles();
        }
        return renderer;
      }
      getOrCreateRenderer(element, type) {
        const rendererByCompId = this.rendererByCompId;
        let renderer = rendererByCompId.get(type.id);
        if (!renderer) {
          const doc = this.doc;
          const ngZone = this.ngZone;
          const eventManager = this.eventManager;
          const sharedStylesHost = this.sharedStylesHost;
          const removeStylesOnCompDestroy = this.removeStylesOnCompDestroy;
          const platformIsServer = this.platformIsServer;
          const tracingService = this.tracingService;
          switch (type.encapsulation) {
            case ViewEncapsulation.Emulated:
              renderer = new EmulatedEncapsulationDomRenderer2(eventManager, sharedStylesHost, type, this.appId, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService);
              break;
            case ViewEncapsulation.ShadowDom:
              return new ShadowDomRenderer(eventManager, sharedStylesHost, element, type, doc, ngZone, this.nonce, platformIsServer, tracingService);
            default:
              renderer = new NoneEncapsulationDomRenderer(eventManager, sharedStylesHost, type, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService);
              break;
          }
          rendererByCompId.set(type.id, renderer);
        }
        return renderer;
      }
      ngOnDestroy() {
        this.rendererByCompId.clear();
      }
      /**
       * Used during HMR to clear any cached data about a component.
       * @param componentId ID of the component that is being replaced.
       */
      componentReplaced(componentId) {
        this.rendererByCompId.delete(componentId);
      }
      static \u0275fac = function DomRendererFactory2_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DomRendererFactory2)(\u0275\u0275inject(EventManager), \u0275\u0275inject(SharedStylesHost), \u0275\u0275inject(APP_ID), \u0275\u0275inject(REMOVE_STYLES_ON_COMPONENT_DESTROY), \u0275\u0275inject(DOCUMENT), \u0275\u0275inject(PLATFORM_ID), \u0275\u0275inject(NgZone), \u0275\u0275inject(CSP_NONCE), \u0275\u0275inject(TracingService, 8));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _DomRendererFactory2,
        factory: _DomRendererFactory2.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomRendererFactory2, [{
        type: Injectable
      }], () => [{
        type: EventManager
      }, {
        type: SharedStylesHost
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [APP_ID]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [REMOVE_STYLES_ON_COMPONENT_DESTROY]
        }]
      }, {
        type: Document,
        decorators: [{
          type: Inject,
          args: [DOCUMENT]
        }]
      }, {
        type: Object,
        decorators: [{
          type: Inject,
          args: [PLATFORM_ID]
        }]
      }, {
        type: NgZone
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [CSP_NONCE]
        }]
      }, {
        type: TracingService,
        decorators: [{
          type: Inject,
          args: [TracingService]
        }, {
          type: Optional
        }]
      }], null);
    })();
    DefaultDomRenderer2 = class {
      eventManager;
      doc;
      ngZone;
      platformIsServer;
      tracingService;
      data = /* @__PURE__ */ Object.create(null);
      /**
       * By default this renderer throws when encountering synthetic properties
       * This can be disabled for example by the AsyncAnimationRendererFactory
       */
      throwOnSyntheticProps = true;
      constructor(eventManager, doc, ngZone, platformIsServer, tracingService) {
        this.eventManager = eventManager;
        this.doc = doc;
        this.ngZone = ngZone;
        this.platformIsServer = platformIsServer;
        this.tracingService = tracingService;
      }
      destroy() {
      }
      destroyNode = null;
      createElement(name, namespace) {
        if (namespace) {
          return this.doc.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);
        }
        return this.doc.createElement(name);
      }
      createComment(value) {
        return this.doc.createComment(value);
      }
      createText(value) {
        return this.doc.createTextNode(value);
      }
      appendChild(parent, newChild) {
        const targetParent = isTemplateNode(parent) ? parent.content : parent;
        targetParent.appendChild(newChild);
      }
      insertBefore(parent, newChild, refChild) {
        if (parent) {
          const targetParent = isTemplateNode(parent) ? parent.content : parent;
          targetParent.insertBefore(newChild, refChild);
        }
      }
      removeChild(_parent, oldChild) {
        oldChild.remove();
      }
      selectRootElement(selectorOrNode, preserveContent) {
        let el2 = typeof selectorOrNode === "string" ? this.doc.querySelector(selectorOrNode) : selectorOrNode;
        if (!el2) {
          throw new RuntimeError(-5104, (typeof ngDevMode === "undefined" || ngDevMode) && `The selector "${selectorOrNode}" did not match any elements`);
        }
        if (!preserveContent) {
          el2.textContent = "";
        }
        return el2;
      }
      parentNode(node) {
        return node.parentNode;
      }
      nextSibling(node) {
        return node.nextSibling;
      }
      setAttribute(el2, name, value, namespace) {
        if (namespace) {
          name = namespace + ":" + name;
          const namespaceUri = NAMESPACE_URIS[namespace];
          if (namespaceUri) {
            el2.setAttributeNS(namespaceUri, name, value);
          } else {
            el2.setAttribute(name, value);
          }
        } else {
          el2.setAttribute(name, value);
        }
      }
      removeAttribute(el2, name, namespace) {
        if (namespace) {
          const namespaceUri = NAMESPACE_URIS[namespace];
          if (namespaceUri) {
            el2.removeAttributeNS(namespaceUri, name);
          } else {
            el2.removeAttribute(`${namespace}:${name}`);
          }
        } else {
          el2.removeAttribute(name);
        }
      }
      addClass(el2, name) {
        el2.classList.add(name);
      }
      removeClass(el2, name) {
        el2.classList.remove(name);
      }
      setStyle(el2, style, value, flags) {
        if (flags & (RendererStyleFlags2.DashCase | RendererStyleFlags2.Important)) {
          el2.style.setProperty(style, value, flags & RendererStyleFlags2.Important ? "important" : "");
        } else {
          el2.style[style] = value;
        }
      }
      removeStyle(el2, style, flags) {
        if (flags & RendererStyleFlags2.DashCase) {
          el2.style.removeProperty(style);
        } else {
          el2.style[style] = "";
        }
      }
      setProperty(el2, name, value) {
        if (el2 == null) {
          return;
        }
        (typeof ngDevMode === "undefined" || ngDevMode) && this.throwOnSyntheticProps && checkNoSyntheticProp(name, "property");
        el2[name] = value;
      }
      setValue(node, value) {
        node.nodeValue = value;
      }
      listen(target, event, callback, options) {
        (typeof ngDevMode === "undefined" || ngDevMode) && this.throwOnSyntheticProps && checkNoSyntheticProp(event, "listener");
        if (typeof target === "string") {
          target = getDOM().getGlobalEventTarget(this.doc, target);
          if (!target) {
            throw new RuntimeError(5102, (typeof ngDevMode === "undefined" || ngDevMode) && `Unsupported event target ${target} for event ${event}`);
          }
        }
        let wrappedCallback = this.decoratePreventDefault(callback);
        if (this.tracingService?.wrapEventListener) {
          wrappedCallback = this.tracingService.wrapEventListener(target, event, wrappedCallback);
        }
        return this.eventManager.addEventListener(target, event, wrappedCallback, options);
      }
      decoratePreventDefault(eventHandler) {
        return (event) => {
          if (event === "__ngUnwrap__") {
            return eventHandler;
          }
          const allowDefaultBehavior = false ? this.ngZone.runGuarded(() => eventHandler(event)) : eventHandler(event);
          if (allowDefaultBehavior === false) {
            event.preventDefault();
          }
          return void 0;
        };
      }
    };
    AT_CHARCODE = (() => "@".charCodeAt(0))();
    ShadowDomRenderer = class extends DefaultDomRenderer2 {
      sharedStylesHost;
      hostEl;
      shadowRoot;
      constructor(eventManager, sharedStylesHost, hostEl, component, doc, ngZone, nonce, platformIsServer, tracingService) {
        super(eventManager, doc, ngZone, platformIsServer, tracingService);
        this.sharedStylesHost = sharedStylesHost;
        this.hostEl = hostEl;
        this.shadowRoot = hostEl.attachShadow({
          mode: "open"
        });
        this.sharedStylesHost.addHost(this.shadowRoot);
        let styles = component.styles;
        if (ngDevMode) {
          const baseHref = getDOM().getBaseHref(doc) ?? "";
          styles = addBaseHrefToCssSourceMap(baseHref, styles);
        }
        styles = shimStylesContent(component.id, styles);
        for (const style of styles) {
          const styleEl = document.createElement("style");
          if (nonce) {
            styleEl.setAttribute("nonce", nonce);
          }
          styleEl.textContent = style;
          this.shadowRoot.appendChild(styleEl);
        }
        const styleUrls = component.getExternalStyles?.();
        if (styleUrls) {
          for (const styleUrl of styleUrls) {
            const linkEl = createLinkElement(styleUrl, doc);
            if (nonce) {
              linkEl.setAttribute("nonce", nonce);
            }
            this.shadowRoot.appendChild(linkEl);
          }
        }
      }
      nodeOrShadowRoot(node) {
        return node === this.hostEl ? this.shadowRoot : node;
      }
      appendChild(parent, newChild) {
        return super.appendChild(this.nodeOrShadowRoot(parent), newChild);
      }
      insertBefore(parent, newChild, refChild) {
        return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);
      }
      removeChild(_parent, oldChild) {
        return super.removeChild(null, oldChild);
      }
      parentNode(node) {
        return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));
      }
      destroy() {
        this.sharedStylesHost.removeHost(this.shadowRoot);
      }
    };
    NoneEncapsulationDomRenderer = class extends DefaultDomRenderer2 {
      sharedStylesHost;
      removeStylesOnCompDestroy;
      styles;
      styleUrls;
      constructor(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService, compId) {
        super(eventManager, doc, ngZone, platformIsServer, tracingService);
        this.sharedStylesHost = sharedStylesHost;
        this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;
        let styles = component.styles;
        if (ngDevMode) {
          const baseHref = getDOM().getBaseHref(doc) ?? "";
          styles = addBaseHrefToCssSourceMap(baseHref, styles);
        }
        this.styles = compId ? shimStylesContent(compId, styles) : styles;
        this.styleUrls = component.getExternalStyles?.(compId);
      }
      applyStyles() {
        this.sharedStylesHost.addStyles(this.styles, this.styleUrls);
      }
      destroy() {
        if (!this.removeStylesOnCompDestroy) {
          return;
        }
        this.sharedStylesHost.removeStyles(this.styles, this.styleUrls);
      }
    };
    EmulatedEncapsulationDomRenderer2 = class extends NoneEncapsulationDomRenderer {
      contentAttr;
      hostAttr;
      constructor(eventManager, sharedStylesHost, component, appId, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService) {
        const compId = appId + "-" + component.id;
        super(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService, compId);
        this.contentAttr = shimContentAttribute(compId);
        this.hostAttr = shimHostAttribute(compId);
      }
      applyToHost(element) {
        this.applyStyles();
        this.setAttribute(element, this.hostAttr, "");
      }
      createElement(parent, name) {
        const el2 = super.createElement(parent, name);
        super.setAttribute(el2, this.contentAttr, "");
        return el2;
      }
    };
  }
});

// node_modules/@angular/platform-browser/fesm2022/browser.mjs
function getBaseElementHref() {
  baseElement = baseElement || document.head.querySelector("base");
  return baseElement ? baseElement.getAttribute("href") : null;
}
function relativePath(url) {
  return new URL(url, document.baseURI).pathname;
}
function bootstrapApplication(rootComponent, options) {
  const config2 = __spreadValues({
    rootComponent
  }, createProvidersConfig(options));
  if (false) {
    return resolveComponentResources(fetch).catch((error) => {
      console.error(error);
      return Promise.resolve();
    }).then(() => internalCreateApplication(config2));
  }
  return internalCreateApplication(config2);
}
function createProvidersConfig(options) {
  return {
    appProviders: [...BROWSER_MODULE_PROVIDERS, ...options?.providers ?? []],
    platformProviders: INTERNAL_BROWSER_PLATFORM_PROVIDERS
  };
}
function initDomAdapter() {
  BrowserDomAdapter.makeCurrent();
}
function errorHandler() {
  return new ErrorHandler();
}
function _document() {
  setDocument(document);
  return document;
}
var BrowserDomAdapter, baseElement, BrowserGetTestability, BrowserXhr, DomEventsPlugin, MODIFIER_KEYS, _keyMap, MODIFIER_KEY_GETTERS, KeyEventsPlugin, INTERNAL_BROWSER_PLATFORM_PROVIDERS, platformBrowser, BROWSER_MODULE_PROVIDERS_MARKER, TESTABILITY_PROVIDERS, BROWSER_MODULE_PROVIDERS, BrowserModule;
var init_browser = __esm({
  "node_modules/@angular/platform-browser/fesm2022/browser.mjs"() {
    "use strict";
    init_common();
    init_core();
    init_core();
    init_dom_renderer();
    BrowserDomAdapter = class _BrowserDomAdapter extends DomAdapter {
      supportsDOMEvents = true;
      static makeCurrent() {
        setRootDomAdapter(new _BrowserDomAdapter());
      }
      onAndCancel(el2, evt, listener, options) {
        el2.addEventListener(evt, listener, options);
        return () => {
          el2.removeEventListener(evt, listener, options);
        };
      }
      dispatchEvent(el2, evt) {
        el2.dispatchEvent(evt);
      }
      remove(node) {
        node.remove();
      }
      createElement(tagName, doc) {
        doc = doc || this.getDefaultDocument();
        return doc.createElement(tagName);
      }
      createHtmlDocument() {
        return document.implementation.createHTMLDocument("fakeTitle");
      }
      getDefaultDocument() {
        return document;
      }
      isElementNode(node) {
        return node.nodeType === Node.ELEMENT_NODE;
      }
      isShadowRoot(node) {
        return node instanceof DocumentFragment;
      }
      /** @deprecated No longer being used in Ivy code. To be removed in version 14. */
      getGlobalEventTarget(doc, target) {
        if (target === "window") {
          return window;
        }
        if (target === "document") {
          return doc;
        }
        if (target === "body") {
          return doc.body;
        }
        return null;
      }
      getBaseHref(doc) {
        const href = getBaseElementHref();
        return href == null ? null : relativePath(href);
      }
      resetBaseElement() {
        baseElement = null;
      }
      getUserAgent() {
        return window.navigator.userAgent;
      }
      getCookie(name) {
        return parseCookieValue(document.cookie, name);
      }
    };
    baseElement = null;
    BrowserGetTestability = class {
      addToWindow(registry) {
        _global["getAngularTestability"] = (elem, findInAncestors = true) => {
          const testability = registry.findTestabilityInTree(elem, findInAncestors);
          if (testability == null) {
            throw new RuntimeError(5103, (typeof ngDevMode === "undefined" || ngDevMode) && "Could not find testability for element.");
          }
          return testability;
        };
        _global["getAllAngularTestabilities"] = () => registry.getAllTestabilities();
        _global["getAllAngularRootElements"] = () => registry.getAllRootElements();
        const whenAllStable = (callback) => {
          const testabilities = _global["getAllAngularTestabilities"]();
          let count = testabilities.length;
          const decrement = function() {
            count--;
            if (count == 0) {
              callback();
            }
          };
          testabilities.forEach((testability) => {
            testability.whenStable(decrement);
          });
        };
        if (!_global["frameworkStabilizers"]) {
          _global["frameworkStabilizers"] = [];
        }
        _global["frameworkStabilizers"].push(whenAllStable);
      }
      findTestabilityInTree(registry, elem, findInAncestors) {
        if (elem == null) {
          return null;
        }
        const t2 = registry.getTestability(elem);
        if (t2 != null) {
          return t2;
        } else if (!findInAncestors) {
          return null;
        }
        if (getDOM().isShadowRoot(elem)) {
          return this.findTestabilityInTree(registry, elem.host, true);
        }
        return this.findTestabilityInTree(registry, elem.parentElement, true);
      }
    };
    BrowserXhr = class _BrowserXhr {
      build() {
        return new XMLHttpRequest();
      }
      static \u0275fac = function BrowserXhr_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _BrowserXhr)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _BrowserXhr,
        factory: _BrowserXhr.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserXhr, [{
        type: Injectable
      }], null, null);
    })();
    DomEventsPlugin = class _DomEventsPlugin extends EventManagerPlugin {
      constructor(doc) {
        super(doc);
      }
      // This plugin should come last in the list of plugins, because it accepts all
      // events.
      supports(eventName) {
        return true;
      }
      addEventListener(element, eventName, handler, options) {
        element.addEventListener(eventName, handler, options);
        return () => this.removeEventListener(element, eventName, handler, options);
      }
      removeEventListener(target, eventName, callback, options) {
        return target.removeEventListener(eventName, callback, options);
      }
      static \u0275fac = function DomEventsPlugin_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DomEventsPlugin)(\u0275\u0275inject(DOCUMENT));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _DomEventsPlugin,
        factory: _DomEventsPlugin.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomEventsPlugin, [{
        type: Injectable
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DOCUMENT]
        }]
      }], null);
    })();
    MODIFIER_KEYS = ["alt", "control", "meta", "shift"];
    _keyMap = {
      "\b": "Backspace",
      "	": "Tab",
      "\x7F": "Delete",
      "\x1B": "Escape",
      "Del": "Delete",
      "Esc": "Escape",
      "Left": "ArrowLeft",
      "Right": "ArrowRight",
      "Up": "ArrowUp",
      "Down": "ArrowDown",
      "Menu": "ContextMenu",
      "Scroll": "ScrollLock",
      "Win": "OS"
    };
    MODIFIER_KEY_GETTERS = {
      "alt": (event) => event.altKey,
      "control": (event) => event.ctrlKey,
      "meta": (event) => event.metaKey,
      "shift": (event) => event.shiftKey
    };
    KeyEventsPlugin = class _KeyEventsPlugin extends EventManagerPlugin {
      /**
       * Initializes an instance of the browser plug-in.
       * @param doc The document in which key events will be detected.
       */
      constructor(doc) {
        super(doc);
      }
      /**
       * Reports whether a named key event is supported.
       * @param eventName The event name to query.
       * @return True if the named key event is supported.
       */
      supports(eventName) {
        return _KeyEventsPlugin.parseEventName(eventName) != null;
      }
      /**
       * Registers a handler for a specific element and key event.
       * @param element The HTML element to receive event notifications.
       * @param eventName The name of the key event to listen for.
       * @param handler A function to call when the notification occurs. Receives the
       * event object as an argument.
       * @returns The key event that was registered.
       */
      addEventListener(element, eventName, handler, options) {
        const parsedEvent = _KeyEventsPlugin.parseEventName(eventName);
        const outsideHandler = _KeyEventsPlugin.eventCallback(parsedEvent["fullKey"], handler, this.manager.getZone());
        return this.manager.getZone().runOutsideAngular(() => {
          return getDOM().onAndCancel(element, parsedEvent["domEventName"], outsideHandler, options);
        });
      }
      /**
       * Parses the user provided full keyboard event definition and normalizes it for
       * later internal use. It ensures the string is all lowercase, converts special
       * characters to a standard spelling, and orders all the values consistently.
       *
       * @param eventName The name of the key event to listen for.
       * @returns an object with the full, normalized string, and the dom event name
       * or null in the case when the event doesn't match a keyboard event.
       */
      static parseEventName(eventName) {
        const parts = eventName.toLowerCase().split(".");
        const domEventName = parts.shift();
        if (parts.length === 0 || !(domEventName === "keydown" || domEventName === "keyup")) {
          return null;
        }
        const key = _KeyEventsPlugin._normalizeKey(parts.pop());
        let fullKey = "";
        let codeIX = parts.indexOf("code");
        if (codeIX > -1) {
          parts.splice(codeIX, 1);
          fullKey = "code.";
        }
        MODIFIER_KEYS.forEach((modifierName) => {
          const index = parts.indexOf(modifierName);
          if (index > -1) {
            parts.splice(index, 1);
            fullKey += modifierName + ".";
          }
        });
        fullKey += key;
        if (parts.length != 0 || key.length === 0) {
          return null;
        }
        const result = {};
        result["domEventName"] = domEventName;
        result["fullKey"] = fullKey;
        return result;
      }
      /**
       * Determines whether the actual keys pressed match the configured key code string.
       * The `fullKeyCode` event is normalized in the `parseEventName` method when the
       * event is attached to the DOM during the `addEventListener` call. This is unseen
       * by the end user and is normalized for internal consistency and parsing.
       *
       * @param event The keyboard event.
       * @param fullKeyCode The normalized user defined expected key event string
       * @returns boolean.
       */
      static matchEventFullKeyCode(event, fullKeyCode) {
        let keycode = _keyMap[event.key] || event.key;
        let key = "";
        if (fullKeyCode.indexOf("code.") > -1) {
          keycode = event.code;
          key = "code.";
        }
        if (keycode == null || !keycode) return false;
        keycode = keycode.toLowerCase();
        if (keycode === " ") {
          keycode = "space";
        } else if (keycode === ".") {
          keycode = "dot";
        }
        MODIFIER_KEYS.forEach((modifierName) => {
          if (modifierName !== keycode) {
            const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
            if (modifierGetter(event)) {
              key += modifierName + ".";
            }
          }
        });
        key += keycode;
        return key === fullKeyCode;
      }
      /**
       * Configures a handler callback for a key event.
       * @param fullKey The event name that combines all simultaneous keystrokes.
       * @param handler The function that responds to the key event.
       * @param zone The zone in which the event occurred.
       * @returns A callback function.
       */
      static eventCallback(fullKey, handler, zone) {
        return (event) => {
          if (_KeyEventsPlugin.matchEventFullKeyCode(event, fullKey)) {
            zone.runGuarded(() => handler(event));
          }
        };
      }
      /** @internal */
      static _normalizeKey(keyName) {
        return keyName === "esc" ? "escape" : keyName;
      }
      static \u0275fac = function KeyEventsPlugin_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _KeyEventsPlugin)(\u0275\u0275inject(DOCUMENT));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _KeyEventsPlugin,
        factory: _KeyEventsPlugin.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyEventsPlugin, [{
        type: Injectable
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DOCUMENT]
        }]
      }], null);
    })();
    INTERNAL_BROWSER_PLATFORM_PROVIDERS = [{
      provide: PLATFORM_ID,
      useValue: PLATFORM_BROWSER_ID
    }, {
      provide: PLATFORM_INITIALIZER,
      useValue: initDomAdapter,
      multi: true
    }, {
      provide: DOCUMENT,
      useFactory: _document
    }];
    platformBrowser = createPlatformFactory(platformCore, "browser", INTERNAL_BROWSER_PLATFORM_PROVIDERS);
    BROWSER_MODULE_PROVIDERS_MARKER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "BrowserModule Providers Marker" : "");
    TESTABILITY_PROVIDERS = [{
      provide: TESTABILITY_GETTER,
      useClass: BrowserGetTestability
    }, {
      provide: TESTABILITY,
      useClass: Testability,
      deps: [NgZone, TestabilityRegistry, TESTABILITY_GETTER]
    }, {
      provide: Testability,
      // Also provide as `Testability` for backwards-compatibility.
      useClass: Testability,
      deps: [NgZone, TestabilityRegistry, TESTABILITY_GETTER]
    }];
    BROWSER_MODULE_PROVIDERS = [{
      provide: INJECTOR_SCOPE,
      useValue: "root"
    }, {
      provide: ErrorHandler,
      useFactory: errorHandler
    }, {
      provide: EVENT_MANAGER_PLUGINS,
      useClass: DomEventsPlugin,
      multi: true,
      deps: [DOCUMENT]
    }, {
      provide: EVENT_MANAGER_PLUGINS,
      useClass: KeyEventsPlugin,
      multi: true,
      deps: [DOCUMENT]
    }, DomRendererFactory2, SharedStylesHost, EventManager, {
      provide: RendererFactory2,
      useExisting: DomRendererFactory2
    }, {
      provide: XhrFactory,
      useClass: BrowserXhr
    }, typeof ngDevMode === "undefined" || ngDevMode ? {
      provide: BROWSER_MODULE_PROVIDERS_MARKER,
      useValue: true
    } : []];
    BrowserModule = class _BrowserModule {
      constructor() {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          const providersAlreadyPresent = inject2(BROWSER_MODULE_PROVIDERS_MARKER, {
            optional: true,
            skipSelf: true
          });
          if (providersAlreadyPresent) {
            throw new RuntimeError(5100, `Providers from the \`BrowserModule\` have already been loaded. If you need access to common directives such as NgIf and NgFor, import the \`CommonModule\` instead.`);
          }
        }
      }
      static \u0275fac = function BrowserModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _BrowserModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _BrowserModule,
        exports: [CommonModule, ApplicationModule]
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
        providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],
        imports: [CommonModule, ApplicationModule]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserModule, [{
        type: NgModule,
        args: [{
          providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],
          exports: [CommonModule, ApplicationModule]
        }]
      }], () => [], null);
    })();
  }
});

// node_modules/@angular/common/fesm2022/module.mjs
function assertValidHeaders(headers) {
  for (const [key, value] of Object.entries(headers)) {
    if (!(typeof value === "string" || typeof value === "number") && !Array.isArray(value)) {
      throw new Error(`Unexpected value of the \`${key}\` header provided. Expecting either a string, a number or an array, but got: \`${value}\`.`);
    }
  }
}
function paramParser(rawParams, codec) {
  const map2 = /* @__PURE__ */ new Map();
  if (rawParams.length > 0) {
    const params = rawParams.replace(/^\?/, "").split("&");
    params.forEach((param) => {
      const eqIdx = param.indexOf("=");
      const [key, val] = eqIdx == -1 ? [codec.decodeKey(param), ""] : [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))];
      const list = map2.get(key) || [];
      list.push(val);
      map2.set(key, list);
    });
  }
  return map2;
}
function standardEncoding(v) {
  return encodeURIComponent(v).replace(STANDARD_ENCODING_REGEX, (s2, t2) => STANDARD_ENCODING_REPLACEMENTS[t2] ?? s2);
}
function valueToString(value) {
  return `${value}`;
}
function mightHaveBody(method) {
  switch (method) {
    case "DELETE":
    case "GET":
    case "HEAD":
    case "OPTIONS":
    case "JSONP":
      return false;
    default:
      return true;
  }
}
function isArrayBuffer(value) {
  return typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer;
}
function isBlob(value) {
  return typeof Blob !== "undefined" && value instanceof Blob;
}
function isFormData(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}
function isUrlSearchParams(value) {
  return typeof URLSearchParams !== "undefined" && value instanceof URLSearchParams;
}
function addBody(options, body) {
  return {
    body,
    headers: options.headers,
    context: options.context,
    observe: options.observe,
    params: options.params,
    reportProgress: options.reportProgress,
    responseType: options.responseType,
    withCredentials: options.withCredentials,
    transferCache: options.transferCache,
    keepalive: options.keepalive,
    priority: options.priority,
    cache: options.cache,
    mode: options.mode,
    redirect: options.redirect
  };
}
function getResponseUrl$1(response) {
  if (response.url) {
    return response.url;
  }
  const xRequestUrl = X_REQUEST_URL_HEADER.toLocaleLowerCase();
  return response.headers.get(xRequestUrl);
}
function noop3() {
}
function warningOptionsMessage(req) {
  if (req.credentials && req.withCredentials) {
    console.warn(formatRuntimeError(2819, `Angular detected that a \`HttpClient\` request has both \`withCredentials: true\` and \`credentials: '${req.credentials}'\` options. The \`withCredentials\` option is overriding the explicit \`credentials\` setting to 'include'. Consider removing \`withCredentials\` and using \`credentials: '${req.credentials}'\` directly for clarity.`));
  }
}
function silenceSuperfluousUnhandledPromiseRejection(promise) {
  promise.then(noop3, noop3);
}
function interceptorChainEndFn(req, finalHandlerFn) {
  return finalHandlerFn(req);
}
function adaptLegacyInterceptorToChain(chainTailFn, interceptor) {
  return (initialRequest, finalHandlerFn) => interceptor.intercept(initialRequest, {
    handle: (downstreamRequest) => chainTailFn(downstreamRequest, finalHandlerFn)
  });
}
function chainedInterceptorFn(chainTailFn, interceptorFn, injector) {
  return (initialRequest, finalHandlerFn) => runInInjectionContext(injector, () => interceptorFn(initialRequest, (downstreamRequest) => chainTailFn(downstreamRequest, finalHandlerFn)));
}
function legacyInterceptorFnFactory() {
  let chain = null;
  return (req, handler) => {
    if (chain === null) {
      const interceptors = inject2(HTTP_INTERCEPTORS, {
        optional: true
      }) ?? [];
      chain = interceptors.reduceRight(adaptLegacyInterceptorToChain, interceptorChainEndFn);
    }
    const pendingTasks = inject2(PendingTasks);
    const contributeToStability = inject2(REQUESTS_CONTRIBUTE_TO_STABILITY);
    if (contributeToStability) {
      const removeTask = pendingTasks.add();
      return chain(req, handler).pipe(finalize(removeTask));
    } else {
      return chain(req, handler);
    }
  };
}
function jsonpCallbackContext() {
  if (typeof window === "object") {
    return window;
  }
  return {};
}
function jsonpInterceptorFn(req, next) {
  if (req.method === "JSONP") {
    return inject2(JsonpClientBackend).handle(req);
  }
  return next(req);
}
function getResponseUrl(xhr) {
  if ("responseURL" in xhr && xhr.responseURL) {
    return xhr.responseURL;
  }
  if (X_REQUEST_URL_REGEXP.test(xhr.getAllResponseHeaders())) {
    return xhr.getResponseHeader(X_REQUEST_URL_HEADER);
  }
  return null;
}
function validateXhrCompatibility(req) {
  const unsupportedOptions = [{
    property: "keepalive",
    errorCode: 2813
    /* RuntimeErrorCode.KEEPALIVE_NOT_SUPPORTED_WITH_XHR */
  }, {
    property: "cache",
    errorCode: 2814
    /* RuntimeErrorCode.CACHE_NOT_SUPPORTED_WITH_XHR */
  }, {
    property: "priority",
    errorCode: 2815
    /* RuntimeErrorCode.PRIORITY_NOT_SUPPORTED_WITH_XHR */
  }, {
    property: "mode",
    errorCode: 2816
    /* RuntimeErrorCode.MODE_NOT_SUPPORTED_WITH_XHR */
  }, {
    property: "redirect",
    errorCode: 2817
    /* RuntimeErrorCode.REDIRECT_NOT_SUPPORTED_WITH_XHR */
  }, {
    property: "credentials",
    errorCode: 2818
    /* RuntimeErrorCode.CREDENTIALS_NOT_SUPPORTED_WITH_XHR */
  }];
  for (const {
    property,
    errorCode
  } of unsupportedOptions) {
    if (req[property]) {
      console.warn(formatRuntimeError(errorCode, `Angular detected that a \`HttpClient\` request with the \`${property}\` option was sent using XHR, which does not support it. To use the \`${property}\` option, enable Fetch API support by passing \`withFetch()\` as an argument to \`provideHttpClient()\`.`));
    }
  }
}
function xsrfInterceptorFn(req, next) {
  const lcUrl = req.url.toLowerCase();
  if (!inject2(XSRF_ENABLED) || req.method === "GET" || req.method === "HEAD" || lcUrl.startsWith("http://") || lcUrl.startsWith("https://")) {
    return next(req);
  }
  const token = inject2(HttpXsrfTokenExtractor).getToken();
  const headerName = inject2(XSRF_HEADER_NAME);
  if (token != null && !req.headers.has(headerName)) {
    req = req.clone({
      headers: req.headers.set(headerName, token)
    });
  }
  return next(req);
}
function makeHttpFeature(kind, providers) {
  return {
    \u0275kind: kind,
    \u0275providers: providers
  };
}
function provideHttpClient(...features) {
  if (ngDevMode) {
    const featureKinds = new Set(features.map((f2) => f2.\u0275kind));
    if (featureKinds.has(HttpFeatureKind.NoXsrfProtection) && featureKinds.has(HttpFeatureKind.CustomXsrfConfiguration)) {
      throw new Error(ngDevMode ? `Configuration error: found both withXsrfConfiguration() and withNoXsrfProtection() in the same call to provideHttpClient(), which is a contradiction.` : "");
    }
  }
  const providers = [HttpClient, HttpXhrBackend, HttpInterceptorHandler, {
    provide: HttpHandler,
    useExisting: HttpInterceptorHandler
  }, {
    provide: HttpBackend,
    useFactory: () => {
      return inject2(FETCH_BACKEND, {
        optional: true
      }) ?? inject2(HttpXhrBackend);
    }
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useValue: xsrfInterceptorFn,
    multi: true
  }, {
    provide: XSRF_ENABLED,
    useValue: true
  }, {
    provide: HttpXsrfTokenExtractor,
    useClass: HttpXsrfCookieExtractor
  }];
  for (const feature of features) {
    providers.push(...feature.\u0275providers);
  }
  return makeEnvironmentProviders(providers);
}
function withInterceptorsFromDi() {
  return makeHttpFeature(HttpFeatureKind.LegacyInterceptors, [{
    provide: LEGACY_INTERCEPTOR_FN,
    useFactory: legacyInterceptorFnFactory
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useExisting: LEGACY_INTERCEPTOR_FN,
    multi: true
  }]);
}
function withXsrfConfiguration({
  cookieName,
  headerName
}) {
  const providers = [];
  if (cookieName !== void 0) {
    providers.push({
      provide: XSRF_COOKIE_NAME,
      useValue: cookieName
    });
  }
  if (headerName !== void 0) {
    providers.push({
      provide: XSRF_HEADER_NAME,
      useValue: headerName
    });
  }
  return makeHttpFeature(HttpFeatureKind.CustomXsrfConfiguration, providers);
}
function withNoXsrfProtection() {
  return makeHttpFeature(HttpFeatureKind.NoXsrfProtection, [{
    provide: XSRF_ENABLED,
    useValue: false
  }]);
}
function withJsonpSupport() {
  return makeHttpFeature(HttpFeatureKind.JsonpSupport, [JsonpClientBackend, {
    provide: JsonpCallbackContext,
    useFactory: jsonpCallbackContext
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useValue: jsonpInterceptorFn,
    multi: true
  }]);
}
var HttpHandler, HttpBackend, HttpHeaders, HttpUrlEncodingCodec, STANDARD_ENCODING_REGEX, STANDARD_ENCODING_REPLACEMENTS, HttpParams, HttpContext, CONTENT_TYPE_HEADER, ACCEPT_HEADER, X_REQUEST_URL_HEADER, TEXT_CONTENT_TYPE, JSON_CONTENT_TYPE, ACCEPT_HEADER_VALUE, HttpRequest, HttpEventType, HttpResponseBase, HttpHeaderResponse, HttpResponse, HttpErrorResponse, HTTP_STATUS_CODE_OK, HTTP_STATUS_CODE_NO_CONTENT, HttpStatusCode, HttpClient, XSSI_PREFIX$1, FETCH_BACKEND, FetchBackend, FetchFactory, HTTP_INTERCEPTORS, HTTP_INTERCEPTOR_FNS, HTTP_ROOT_INTERCEPTOR_FNS, REQUESTS_CONTRIBUTE_TO_STABILITY, fetchBackendWarningDisplayed, HttpInterceptorHandler, nextRequestId, foreignDocument, JSONP_ERR_NO_CALLBACK, JSONP_ERR_WRONG_METHOD, JSONP_ERR_WRONG_RESPONSE_TYPE, JSONP_ERR_HEADERS_NOT_SUPPORTED, JsonpCallbackContext, JsonpClientBackend, JsonpInterceptor, XSSI_PREFIX, X_REQUEST_URL_REGEXP, HttpXhrBackend, XSRF_ENABLED, XSRF_DEFAULT_COOKIE_NAME, XSRF_COOKIE_NAME, XSRF_DEFAULT_HEADER_NAME, XSRF_HEADER_NAME, HttpXsrfTokenExtractor, HttpXsrfCookieExtractor, HttpXsrfInterceptor, HttpFeatureKind, LEGACY_INTERCEPTOR_FN, HttpClientXsrfModule, HttpClientModule, HttpClientJsonpModule;
var init_module = __esm({
  "node_modules/@angular/common/fesm2022/module.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_operators();
    init_esm();
    init_xhr();
    HttpHandler = class {
    };
    HttpBackend = class {
    };
    HttpHeaders = class _HttpHeaders {
      /**
       * Internal map of lowercase header names to values.
       */
      headers;
      /**
       * Internal map of lowercased header names to the normalized
       * form of the name (the form seen first).
       */
      normalizedNames = /* @__PURE__ */ new Map();
      /**
       * Complete the lazy initialization of this object (needed before reading).
       */
      lazyInit;
      /**
       * Queued updates to be materialized the next initialization.
       */
      lazyUpdate = null;
      /**  Constructs a new HTTP header object with the given values.*/
      constructor(headers) {
        if (!headers) {
          this.headers = /* @__PURE__ */ new Map();
        } else if (typeof headers === "string") {
          this.lazyInit = () => {
            this.headers = /* @__PURE__ */ new Map();
            headers.split("\n").forEach((line) => {
              const index = line.indexOf(":");
              if (index > 0) {
                const name = line.slice(0, index);
                const value = line.slice(index + 1).trim();
                this.addHeaderEntry(name, value);
              }
            });
          };
        } else if (typeof Headers !== "undefined" && headers instanceof Headers) {
          this.headers = /* @__PURE__ */ new Map();
          headers.forEach((value, name) => {
            this.addHeaderEntry(name, value);
          });
        } else {
          this.lazyInit = () => {
            if (typeof ngDevMode === "undefined" || ngDevMode) {
              assertValidHeaders(headers);
            }
            this.headers = /* @__PURE__ */ new Map();
            Object.entries(headers).forEach(([name, values]) => {
              this.setHeaderEntries(name, values);
            });
          };
        }
      }
      /**
       * Checks for existence of a given header.
       *
       * @param name The header name to check for existence.
       *
       * @returns True if the header exists, false otherwise.
       */
      has(name) {
        this.init();
        return this.headers.has(name.toLowerCase());
      }
      /**
       * Retrieves the first value of a given header.
       *
       * @param name The header name.
       *
       * @returns The value string if the header exists, null otherwise
       */
      get(name) {
        this.init();
        const values = this.headers.get(name.toLowerCase());
        return values && values.length > 0 ? values[0] : null;
      }
      /**
       * Retrieves the names of the headers.
       *
       * @returns A list of header names.
       */
      keys() {
        this.init();
        return Array.from(this.normalizedNames.values());
      }
      /**
       * Retrieves a list of values for a given header.
       *
       * @param name The header name from which to retrieve values.
       *
       * @returns A string of values if the header exists, null otherwise.
       */
      getAll(name) {
        this.init();
        return this.headers.get(name.toLowerCase()) || null;
      }
      /**
       * Appends a new value to the existing set of values for a header
       * and returns them in a clone of the original instance.
       *
       * @param name The header name for which to append the values.
       * @param value The value to append.
       *
       * @returns A clone of the HTTP headers object with the value appended to the given header.
       */
      append(name, value) {
        return this.clone({
          name,
          value,
          op: "a"
        });
      }
      /**
       * Sets or modifies a value for a given header in a clone of the original instance.
       * If the header already exists, its value is replaced with the given value
       * in the returned object.
       *
       * @param name The header name.
       * @param value The value or values to set or override for the given header.
       *
       * @returns A clone of the HTTP headers object with the newly set header value.
       */
      set(name, value) {
        return this.clone({
          name,
          value,
          op: "s"
        });
      }
      /**
       * Deletes values for a given header in a clone of the original instance.
       *
       * @param name The header name.
       * @param value The value or values to delete for the given header.
       *
       * @returns A clone of the HTTP headers object with the given value deleted.
       */
      delete(name, value) {
        return this.clone({
          name,
          value,
          op: "d"
        });
      }
      maybeSetNormalizedName(name, lcName) {
        if (!this.normalizedNames.has(lcName)) {
          this.normalizedNames.set(lcName, name);
        }
      }
      init() {
        if (!!this.lazyInit) {
          if (this.lazyInit instanceof _HttpHeaders) {
            this.copyFrom(this.lazyInit);
          } else {
            this.lazyInit();
          }
          this.lazyInit = null;
          if (!!this.lazyUpdate) {
            this.lazyUpdate.forEach((update) => this.applyUpdate(update));
            this.lazyUpdate = null;
          }
        }
      }
      copyFrom(other) {
        other.init();
        Array.from(other.headers.keys()).forEach((key) => {
          this.headers.set(key, other.headers.get(key));
          this.normalizedNames.set(key, other.normalizedNames.get(key));
        });
      }
      clone(update) {
        const clone = new _HttpHeaders();
        clone.lazyInit = !!this.lazyInit && this.lazyInit instanceof _HttpHeaders ? this.lazyInit : this;
        clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);
        return clone;
      }
      applyUpdate(update) {
        const key = update.name.toLowerCase();
        switch (update.op) {
          case "a":
          case "s":
            let value = update.value;
            if (typeof value === "string") {
              value = [value];
            }
            if (value.length === 0) {
              return;
            }
            this.maybeSetNormalizedName(update.name, key);
            const base = (update.op === "a" ? this.headers.get(key) : void 0) || [];
            base.push(...value);
            this.headers.set(key, base);
            break;
          case "d":
            const toDelete = update.value;
            if (!toDelete) {
              this.headers.delete(key);
              this.normalizedNames.delete(key);
            } else {
              let existing = this.headers.get(key);
              if (!existing) {
                return;
              }
              existing = existing.filter((value2) => toDelete.indexOf(value2) === -1);
              if (existing.length === 0) {
                this.headers.delete(key);
                this.normalizedNames.delete(key);
              } else {
                this.headers.set(key, existing);
              }
            }
            break;
        }
      }
      addHeaderEntry(name, value) {
        const key = name.toLowerCase();
        this.maybeSetNormalizedName(name, key);
        if (this.headers.has(key)) {
          this.headers.get(key).push(value);
        } else {
          this.headers.set(key, [value]);
        }
      }
      setHeaderEntries(name, values) {
        const headerValues = (Array.isArray(values) ? values : [values]).map((value) => value.toString());
        const key = name.toLowerCase();
        this.headers.set(key, headerValues);
        this.maybeSetNormalizedName(name, key);
      }
      /**
       * @internal
       */
      forEach(fn) {
        this.init();
        Array.from(this.normalizedNames.keys()).forEach((key) => fn(this.normalizedNames.get(key), this.headers.get(key)));
      }
    };
    HttpUrlEncodingCodec = class {
      /**
       * Encodes a key name for a URL parameter or query-string.
       * @param key The key name.
       * @returns The encoded key name.
       */
      encodeKey(key) {
        return standardEncoding(key);
      }
      /**
       * Encodes the value of a URL parameter or query-string.
       * @param value The value.
       * @returns The encoded value.
       */
      encodeValue(value) {
        return standardEncoding(value);
      }
      /**
       * Decodes an encoded URL parameter or query-string key.
       * @param key The encoded key name.
       * @returns The decoded key name.
       */
      decodeKey(key) {
        return decodeURIComponent(key);
      }
      /**
       * Decodes an encoded URL parameter or query-string value.
       * @param value The encoded value.
       * @returns The decoded value.
       */
      decodeValue(value) {
        return decodeURIComponent(value);
      }
    };
    STANDARD_ENCODING_REGEX = /%(\d[a-f0-9])/gi;
    STANDARD_ENCODING_REPLACEMENTS = {
      "40": "@",
      "3A": ":",
      "24": "$",
      "2C": ",",
      "3B": ";",
      "3D": "=",
      "3F": "?",
      "2F": "/"
    };
    HttpParams = class _HttpParams {
      map;
      encoder;
      updates = null;
      cloneFrom = null;
      constructor(options = {}) {
        this.encoder = options.encoder || new HttpUrlEncodingCodec();
        if (options.fromString) {
          if (options.fromObject) {
            throw new RuntimeError(2805, ngDevMode && "Cannot specify both fromString and fromObject.");
          }
          this.map = paramParser(options.fromString, this.encoder);
        } else if (!!options.fromObject) {
          this.map = /* @__PURE__ */ new Map();
          Object.keys(options.fromObject).forEach((key) => {
            const value = options.fromObject[key];
            const values = Array.isArray(value) ? value.map(valueToString) : [valueToString(value)];
            this.map.set(key, values);
          });
        } else {
          this.map = null;
        }
      }
      /**
       * Reports whether the body includes one or more values for a given parameter.
       * @param param The parameter name.
       * @returns True if the parameter has one or more values,
       * false if it has no value or is not present.
       */
      has(param) {
        this.init();
        return this.map.has(param);
      }
      /**
       * Retrieves the first value for a parameter.
       * @param param The parameter name.
       * @returns The first value of the given parameter,
       * or `null` if the parameter is not present.
       */
      get(param) {
        this.init();
        const res = this.map.get(param);
        return !!res ? res[0] : null;
      }
      /**
       * Retrieves all values for a  parameter.
       * @param param The parameter name.
       * @returns All values in a string array,
       * or `null` if the parameter not present.
       */
      getAll(param) {
        this.init();
        return this.map.get(param) || null;
      }
      /**
       * Retrieves all the parameters for this body.
       * @returns The parameter names in a string array.
       */
      keys() {
        this.init();
        return Array.from(this.map.keys());
      }
      /**
       * Appends a new value to existing values for a parameter.
       * @param param The parameter name.
       * @param value The new value to add.
       * @return A new body with the appended value.
       */
      append(param, value) {
        return this.clone({
          param,
          value,
          op: "a"
        });
      }
      /**
       * Constructs a new body with appended values for the given parameter name.
       * @param params parameters and values
       * @return A new body with the new value.
       */
      appendAll(params) {
        const updates = [];
        Object.keys(params).forEach((param) => {
          const value = params[param];
          if (Array.isArray(value)) {
            value.forEach((_value) => {
              updates.push({
                param,
                value: _value,
                op: "a"
              });
            });
          } else {
            updates.push({
              param,
              value,
              op: "a"
            });
          }
        });
        return this.clone(updates);
      }
      /**
       * Replaces the value for a parameter.
       * @param param The parameter name.
       * @param value The new value.
       * @return A new body with the new value.
       */
      set(param, value) {
        return this.clone({
          param,
          value,
          op: "s"
        });
      }
      /**
       * Removes a given value or all values from a parameter.
       * @param param The parameter name.
       * @param value The value to remove, if provided.
       * @return A new body with the given value removed, or with all values
       * removed if no value is specified.
       */
      delete(param, value) {
        return this.clone({
          param,
          value,
          op: "d"
        });
      }
      /**
       * Serializes the body to an encoded string, where key-value pairs (separated by `=`) are
       * separated by `&`s.
       */
      toString() {
        this.init();
        return this.keys().map((key) => {
          const eKey = this.encoder.encodeKey(key);
          return this.map.get(key).map((value) => eKey + "=" + this.encoder.encodeValue(value)).join("&");
        }).filter((param) => param !== "").join("&");
      }
      clone(update) {
        const clone = new _HttpParams({
          encoder: this.encoder
        });
        clone.cloneFrom = this.cloneFrom || this;
        clone.updates = (this.updates || []).concat(update);
        return clone;
      }
      init() {
        if (this.map === null) {
          this.map = /* @__PURE__ */ new Map();
        }
        if (this.cloneFrom !== null) {
          this.cloneFrom.init();
          this.cloneFrom.keys().forEach((key) => this.map.set(key, this.cloneFrom.map.get(key)));
          this.updates.forEach((update) => {
            switch (update.op) {
              case "a":
              case "s":
                const base = (update.op === "a" ? this.map.get(update.param) : void 0) || [];
                base.push(valueToString(update.value));
                this.map.set(update.param, base);
                break;
              case "d":
                if (update.value !== void 0) {
                  let base2 = this.map.get(update.param) || [];
                  const idx = base2.indexOf(valueToString(update.value));
                  if (idx !== -1) {
                    base2.splice(idx, 1);
                  }
                  if (base2.length > 0) {
                    this.map.set(update.param, base2);
                  } else {
                    this.map.delete(update.param);
                  }
                } else {
                  this.map.delete(update.param);
                  break;
                }
            }
          });
          this.cloneFrom = this.updates = null;
        }
      }
    };
    HttpContext = class {
      map = /* @__PURE__ */ new Map();
      /**
       * Store a value in the context. If a value is already present it will be overwritten.
       *
       * @param token The reference to an instance of `HttpContextToken`.
       * @param value The value to store.
       *
       * @returns A reference to itself for easy chaining.
       */
      set(token, value) {
        this.map.set(token, value);
        return this;
      }
      /**
       * Retrieve the value associated with the given token.
       *
       * @param token The reference to an instance of `HttpContextToken`.
       *
       * @returns The stored value or default if one is defined.
       */
      get(token) {
        if (!this.map.has(token)) {
          this.map.set(token, token.defaultValue());
        }
        return this.map.get(token);
      }
      /**
       * Delete the value associated with the given token.
       *
       * @param token The reference to an instance of `HttpContextToken`.
       *
       * @returns A reference to itself for easy chaining.
       */
      delete(token) {
        this.map.delete(token);
        return this;
      }
      /**
       * Checks for existence of a given token.
       *
       * @param token The reference to an instance of `HttpContextToken`.
       *
       * @returns True if the token exists, false otherwise.
       */
      has(token) {
        return this.map.has(token);
      }
      /**
       * @returns a list of tokens currently stored in the context.
       */
      keys() {
        return this.map.keys();
      }
    };
    CONTENT_TYPE_HEADER = "Content-Type";
    ACCEPT_HEADER = "Accept";
    X_REQUEST_URL_HEADER = "X-Request-URL";
    TEXT_CONTENT_TYPE = "text/plain";
    JSON_CONTENT_TYPE = "application/json";
    ACCEPT_HEADER_VALUE = `${JSON_CONTENT_TYPE}, ${TEXT_CONTENT_TYPE}, */*`;
    HttpRequest = class _HttpRequest {
      url;
      /**
       * The request body, or `null` if one isn't set.
       *
       * Bodies are not enforced to be immutable, as they can include a reference to any
       * user-defined data type. However, interceptors should take care to preserve
       * idempotence by treating them as such.
       */
      body = null;
      /**
       * Outgoing headers for this request.
       */
      headers;
      /**
       * Shared and mutable context that can be used by interceptors
       */
      context;
      /**
       * Whether this request should be made in a way that exposes progress events.
       *
       * Progress events are expensive (change detection runs on each event) and so
       * they should only be requested if the consumer intends to monitor them.
       *
       * Note: The `FetchBackend` doesn't support progress report on uploads.
       */
      reportProgress = false;
      /**
       * Whether this request should be sent with outgoing credentials (cookies).
       */
      withCredentials = false;
      /**
       *  The credentials mode of the request, which determines how cookies and HTTP authentication are handled.
       *  This can affect whether cookies are sent with the request, and how authentication is handled.
       */
      credentials;
      /**
       * When using the fetch implementation and set to `true`, the browser will not abort the associated request if the page that initiated it is unloaded before the request is complete.
       */
      keepalive = false;
      /**
       * Controls how the request will interact with the browser's HTTP cache.
       * This affects whether a response is retrieved from the cache, how it is stored, or if it bypasses the cache altogether.
       */
      cache;
      /**
       * Indicates the relative priority of the request. This may be used by the browser to decide the order in which requests are dispatched and resources fetched.
       */
      priority;
      /**
       * The mode of the request, which determines how the request will interact with the browser's security model.
       * This can affect things like CORS (Cross-Origin Resource Sharing) and same-origin policies.
       */
      mode;
      /**
       * The redirect mode of the request, which determines how redirects are handled.
       * This can affect whether the request follows redirects automatically, or if it fails when a redirect occurs.
       */
      redirect;
      /**
       * The expected response type of the server.
       *
       * This is used to parse the response appropriately before returning it to
       * the requestee.
       */
      responseType = "json";
      /**
       * The outgoing HTTP request method.
       */
      method;
      /**
       * Outgoing URL parameters.
       *
       * To pass a string representation of HTTP parameters in the URL-query-string format,
       * the `HttpParamsOptions`' `fromString` may be used. For example:
       *
       * ```ts
       * new HttpParams({fromString: 'angular=awesome'})
       * ```
       */
      params;
      /**
       * The outgoing URL with all URL parameters set.
       */
      urlWithParams;
      /**
       * The HttpTransferCache option for the request
       */
      transferCache;
      /**
       * The timeout for the backend HTTP request in ms.
       */
      timeout;
      constructor(method, url, third, fourth) {
        this.url = url;
        this.method = method.toUpperCase();
        let options;
        if (mightHaveBody(this.method) || !!fourth) {
          this.body = third !== void 0 ? third : null;
          options = fourth;
        } else {
          options = third;
        }
        if (options) {
          this.reportProgress = !!options.reportProgress;
          this.withCredentials = !!options.withCredentials;
          this.keepalive = !!options.keepalive;
          if (!!options.responseType) {
            this.responseType = options.responseType;
          }
          if (options.headers) {
            this.headers = options.headers;
          }
          if (options.context) {
            this.context = options.context;
          }
          if (options.params) {
            this.params = options.params;
          }
          if (options.priority) {
            this.priority = options.priority;
          }
          if (options.cache) {
            this.cache = options.cache;
          }
          if (options.credentials) {
            this.credentials = options.credentials;
          }
          if (typeof options.timeout === "number") {
            if (options.timeout < 1 || !Number.isInteger(options.timeout)) {
              throw new Error(ngDevMode ? "`timeout` must be a positive integer value" : "");
            }
            this.timeout = options.timeout;
          }
          if (options.mode) {
            this.mode = options.mode;
          }
          if (options.redirect) {
            this.redirect = options.redirect;
          }
          this.transferCache = options.transferCache;
        }
        this.headers ??= new HttpHeaders();
        this.context ??= new HttpContext();
        if (!this.params) {
          this.params = new HttpParams();
          this.urlWithParams = url;
        } else {
          const params = this.params.toString();
          if (params.length === 0) {
            this.urlWithParams = url;
          } else {
            const qIdx = url.indexOf("?");
            const sep = qIdx === -1 ? "?" : qIdx < url.length - 1 ? "&" : "";
            this.urlWithParams = url + sep + params;
          }
        }
      }
      /**
       * Transform the free-form body into a serialized format suitable for
       * transmission to the server.
       */
      serializeBody() {
        if (this.body === null) {
          return null;
        }
        if (typeof this.body === "string" || isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) || isUrlSearchParams(this.body)) {
          return this.body;
        }
        if (this.body instanceof HttpParams) {
          return this.body.toString();
        }
        if (typeof this.body === "object" || typeof this.body === "boolean" || Array.isArray(this.body)) {
          return JSON.stringify(this.body);
        }
        return this.body.toString();
      }
      /**
       * Examine the body and attempt to infer an appropriate MIME type
       * for it.
       *
       * If no such type can be inferred, this method will return `null`.
       */
      detectContentTypeHeader() {
        if (this.body === null) {
          return null;
        }
        if (isFormData(this.body)) {
          return null;
        }
        if (isBlob(this.body)) {
          return this.body.type || null;
        }
        if (isArrayBuffer(this.body)) {
          return null;
        }
        if (typeof this.body === "string") {
          return TEXT_CONTENT_TYPE;
        }
        if (this.body instanceof HttpParams) {
          return "application/x-www-form-urlencoded;charset=UTF-8";
        }
        if (typeof this.body === "object" || typeof this.body === "number" || typeof this.body === "boolean") {
          return JSON_CONTENT_TYPE;
        }
        return null;
      }
      clone(update = {}) {
        const method = update.method || this.method;
        const url = update.url || this.url;
        const responseType = update.responseType || this.responseType;
        const keepalive = update.keepalive ?? this.keepalive;
        const priority = update.priority || this.priority;
        const cache = update.cache || this.cache;
        const mode = update.mode || this.mode;
        const redirect = update.redirect || this.redirect;
        const credentials = update.credentials || this.credentials;
        const transferCache = update.transferCache ?? this.transferCache;
        const timeout = update.timeout ?? this.timeout;
        const body = update.body !== void 0 ? update.body : this.body;
        const withCredentials = update.withCredentials ?? this.withCredentials;
        const reportProgress = update.reportProgress ?? this.reportProgress;
        let headers = update.headers || this.headers;
        let params = update.params || this.params;
        const context2 = update.context ?? this.context;
        if (update.setHeaders !== void 0) {
          headers = Object.keys(update.setHeaders).reduce((headers2, name) => headers2.set(name, update.setHeaders[name]), headers);
        }
        if (update.setParams) {
          params = Object.keys(update.setParams).reduce((params2, param) => params2.set(param, update.setParams[param]), params);
        }
        return new _HttpRequest(method, url, body, {
          params,
          headers,
          context: context2,
          reportProgress,
          responseType,
          withCredentials,
          transferCache,
          keepalive,
          cache,
          priority,
          timeout,
          mode,
          redirect,
          credentials
        });
      }
    };
    (function(HttpEventType2) {
      HttpEventType2[HttpEventType2["Sent"] = 0] = "Sent";
      HttpEventType2[HttpEventType2["UploadProgress"] = 1] = "UploadProgress";
      HttpEventType2[HttpEventType2["ResponseHeader"] = 2] = "ResponseHeader";
      HttpEventType2[HttpEventType2["DownloadProgress"] = 3] = "DownloadProgress";
      HttpEventType2[HttpEventType2["Response"] = 4] = "Response";
      HttpEventType2[HttpEventType2["User"] = 5] = "User";
    })(HttpEventType || (HttpEventType = {}));
    HttpResponseBase = class {
      /**
       * All response headers.
       */
      headers;
      /**
       * Response status code.
       */
      status;
      /**
       * Textual description of response status code, defaults to OK.
       *
       * Do not depend on this.
       */
      statusText;
      /**
       * URL of the resource retrieved, or null if not available.
       */
      url;
      /**
       * Whether the status code falls in the 2xx range.
       */
      ok;
      /**
       * Type of the response, narrowed to either the full response or the header.
       */
      type;
      /**
       * Super-constructor for all responses.
       *
       * The single parameter accepted is an initialization hash. Any properties
       * of the response passed there will override the default values.
       */
      constructor(init, defaultStatus = 200, defaultStatusText = "OK") {
        this.headers = init.headers || new HttpHeaders();
        this.status = init.status !== void 0 ? init.status : defaultStatus;
        this.statusText = init.statusText || defaultStatusText;
        this.url = init.url || null;
        this.ok = this.status >= 200 && this.status < 300;
      }
    };
    HttpHeaderResponse = class _HttpHeaderResponse extends HttpResponseBase {
      /**
       * Create a new `HttpHeaderResponse` with the given parameters.
       */
      constructor(init = {}) {
        super(init);
      }
      type = HttpEventType.ResponseHeader;
      /**
       * Copy this `HttpHeaderResponse`, overriding its contents with the
       * given parameter hash.
       */
      clone(update = {}) {
        return new _HttpHeaderResponse({
          headers: update.headers || this.headers,
          status: update.status !== void 0 ? update.status : this.status,
          statusText: update.statusText || this.statusText,
          url: update.url || this.url || void 0
        });
      }
    };
    HttpResponse = class _HttpResponse extends HttpResponseBase {
      /**
       * The response body, or `null` if one was not returned.
       */
      body;
      /**
       * Construct a new `HttpResponse`.
       */
      constructor(init = {}) {
        super(init);
        this.body = init.body !== void 0 ? init.body : null;
      }
      type = HttpEventType.Response;
      clone(update = {}) {
        return new _HttpResponse({
          body: update.body !== void 0 ? update.body : this.body,
          headers: update.headers || this.headers,
          status: update.status !== void 0 ? update.status : this.status,
          statusText: update.statusText || this.statusText,
          url: update.url || this.url || void 0
        });
      }
    };
    HttpErrorResponse = class extends HttpResponseBase {
      name = "HttpErrorResponse";
      message;
      error;
      /**
       * Errors are never okay, even when the status code is in the 2xx success range.
       */
      ok = false;
      constructor(init) {
        super(init, 0, "Unknown Error");
        if (this.status >= 200 && this.status < 300) {
          this.message = `Http failure during parsing for ${init.url || "(unknown url)"}`;
        } else {
          this.message = `Http failure response for ${init.url || "(unknown url)"}: ${init.status} ${init.statusText}`;
        }
        this.error = init.error || null;
      }
    };
    HTTP_STATUS_CODE_OK = 200;
    HTTP_STATUS_CODE_NO_CONTENT = 204;
    (function(HttpStatusCode2) {
      HttpStatusCode2[HttpStatusCode2["Continue"] = 100] = "Continue";
      HttpStatusCode2[HttpStatusCode2["SwitchingProtocols"] = 101] = "SwitchingProtocols";
      HttpStatusCode2[HttpStatusCode2["Processing"] = 102] = "Processing";
      HttpStatusCode2[HttpStatusCode2["EarlyHints"] = 103] = "EarlyHints";
      HttpStatusCode2[HttpStatusCode2["Ok"] = 200] = "Ok";
      HttpStatusCode2[HttpStatusCode2["Created"] = 201] = "Created";
      HttpStatusCode2[HttpStatusCode2["Accepted"] = 202] = "Accepted";
      HttpStatusCode2[HttpStatusCode2["NonAuthoritativeInformation"] = 203] = "NonAuthoritativeInformation";
      HttpStatusCode2[HttpStatusCode2["NoContent"] = 204] = "NoContent";
      HttpStatusCode2[HttpStatusCode2["ResetContent"] = 205] = "ResetContent";
      HttpStatusCode2[HttpStatusCode2["PartialContent"] = 206] = "PartialContent";
      HttpStatusCode2[HttpStatusCode2["MultiStatus"] = 207] = "MultiStatus";
      HttpStatusCode2[HttpStatusCode2["AlreadyReported"] = 208] = "AlreadyReported";
      HttpStatusCode2[HttpStatusCode2["ImUsed"] = 226] = "ImUsed";
      HttpStatusCode2[HttpStatusCode2["MultipleChoices"] = 300] = "MultipleChoices";
      HttpStatusCode2[HttpStatusCode2["MovedPermanently"] = 301] = "MovedPermanently";
      HttpStatusCode2[HttpStatusCode2["Found"] = 302] = "Found";
      HttpStatusCode2[HttpStatusCode2["SeeOther"] = 303] = "SeeOther";
      HttpStatusCode2[HttpStatusCode2["NotModified"] = 304] = "NotModified";
      HttpStatusCode2[HttpStatusCode2["UseProxy"] = 305] = "UseProxy";
      HttpStatusCode2[HttpStatusCode2["Unused"] = 306] = "Unused";
      HttpStatusCode2[HttpStatusCode2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
      HttpStatusCode2[HttpStatusCode2["PermanentRedirect"] = 308] = "PermanentRedirect";
      HttpStatusCode2[HttpStatusCode2["BadRequest"] = 400] = "BadRequest";
      HttpStatusCode2[HttpStatusCode2["Unauthorized"] = 401] = "Unauthorized";
      HttpStatusCode2[HttpStatusCode2["PaymentRequired"] = 402] = "PaymentRequired";
      HttpStatusCode2[HttpStatusCode2["Forbidden"] = 403] = "Forbidden";
      HttpStatusCode2[HttpStatusCode2["NotFound"] = 404] = "NotFound";
      HttpStatusCode2[HttpStatusCode2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
      HttpStatusCode2[HttpStatusCode2["NotAcceptable"] = 406] = "NotAcceptable";
      HttpStatusCode2[HttpStatusCode2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
      HttpStatusCode2[HttpStatusCode2["RequestTimeout"] = 408] = "RequestTimeout";
      HttpStatusCode2[HttpStatusCode2["Conflict"] = 409] = "Conflict";
      HttpStatusCode2[HttpStatusCode2["Gone"] = 410] = "Gone";
      HttpStatusCode2[HttpStatusCode2["LengthRequired"] = 411] = "LengthRequired";
      HttpStatusCode2[HttpStatusCode2["PreconditionFailed"] = 412] = "PreconditionFailed";
      HttpStatusCode2[HttpStatusCode2["PayloadTooLarge"] = 413] = "PayloadTooLarge";
      HttpStatusCode2[HttpStatusCode2["UriTooLong"] = 414] = "UriTooLong";
      HttpStatusCode2[HttpStatusCode2["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
      HttpStatusCode2[HttpStatusCode2["RangeNotSatisfiable"] = 416] = "RangeNotSatisfiable";
      HttpStatusCode2[HttpStatusCode2["ExpectationFailed"] = 417] = "ExpectationFailed";
      HttpStatusCode2[HttpStatusCode2["ImATeapot"] = 418] = "ImATeapot";
      HttpStatusCode2[HttpStatusCode2["MisdirectedRequest"] = 421] = "MisdirectedRequest";
      HttpStatusCode2[HttpStatusCode2["UnprocessableEntity"] = 422] = "UnprocessableEntity";
      HttpStatusCode2[HttpStatusCode2["Locked"] = 423] = "Locked";
      HttpStatusCode2[HttpStatusCode2["FailedDependency"] = 424] = "FailedDependency";
      HttpStatusCode2[HttpStatusCode2["TooEarly"] = 425] = "TooEarly";
      HttpStatusCode2[HttpStatusCode2["UpgradeRequired"] = 426] = "UpgradeRequired";
      HttpStatusCode2[HttpStatusCode2["PreconditionRequired"] = 428] = "PreconditionRequired";
      HttpStatusCode2[HttpStatusCode2["TooManyRequests"] = 429] = "TooManyRequests";
      HttpStatusCode2[HttpStatusCode2["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
      HttpStatusCode2[HttpStatusCode2["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
      HttpStatusCode2[HttpStatusCode2["InternalServerError"] = 500] = "InternalServerError";
      HttpStatusCode2[HttpStatusCode2["NotImplemented"] = 501] = "NotImplemented";
      HttpStatusCode2[HttpStatusCode2["BadGateway"] = 502] = "BadGateway";
      HttpStatusCode2[HttpStatusCode2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
      HttpStatusCode2[HttpStatusCode2["GatewayTimeout"] = 504] = "GatewayTimeout";
      HttpStatusCode2[HttpStatusCode2["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
      HttpStatusCode2[HttpStatusCode2["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
      HttpStatusCode2[HttpStatusCode2["InsufficientStorage"] = 507] = "InsufficientStorage";
      HttpStatusCode2[HttpStatusCode2["LoopDetected"] = 508] = "LoopDetected";
      HttpStatusCode2[HttpStatusCode2["NotExtended"] = 510] = "NotExtended";
      HttpStatusCode2[HttpStatusCode2["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
    })(HttpStatusCode || (HttpStatusCode = {}));
    HttpClient = class _HttpClient {
      handler;
      constructor(handler) {
        this.handler = handler;
      }
      /**
       * Constructs an observable for a generic HTTP request that, when subscribed,
       * fires the request through the chain of registered interceptors and on to the
       * server.
       *
       * You can pass an `HttpRequest` directly as the only parameter. In this case,
       * the call returns an observable of the raw `HttpEvent` stream.
       *
       * Alternatively you can pass an HTTP method as the first parameter,
       * a URL string as the second, and an options hash containing the request body as the third.
       * See `addBody()`. In this case, the specified `responseType` and `observe` options determine the
       * type of returned observable.
       *   * The `responseType` value determines how a successful response body is parsed.
       *   * If `responseType` is the default `json`, you can pass a type interface for the resulting
       * object as a type parameter to the call.
       *
       * The `observe` value determines the return type, according to what you are interested in
       * observing.
       *   * An `observe` value of events returns an observable of the raw `HttpEvent` stream, including
       * progress events by default.
       *   * An `observe` value of response returns an observable of `HttpResponse<T>`,
       * where the `T` parameter depends on the `responseType` and any optionally provided type
       * parameter.
       *   * An `observe` value of body returns an observable of `<T>` with the same `T` body type.
       *
       */
      request(first2, url, options = {}) {
        let req;
        if (first2 instanceof HttpRequest) {
          req = first2;
        } else {
          let headers = void 0;
          if (options.headers instanceof HttpHeaders) {
            headers = options.headers;
          } else {
            headers = new HttpHeaders(options.headers);
          }
          let params = void 0;
          if (!!options.params) {
            if (options.params instanceof HttpParams) {
              params = options.params;
            } else {
              params = new HttpParams({
                fromObject: options.params
              });
            }
          }
          req = new HttpRequest(first2, url, options.body !== void 0 ? options.body : null, {
            headers,
            context: options.context,
            params,
            reportProgress: options.reportProgress,
            // By default, JSON is assumed to be returned for all calls.
            responseType: options.responseType || "json",
            withCredentials: options.withCredentials,
            transferCache: options.transferCache,
            keepalive: options.keepalive,
            priority: options.priority,
            cache: options.cache,
            mode: options.mode,
            redirect: options.redirect,
            credentials: options.credentials
          });
        }
        const events$ = of(req).pipe(concatMap((req2) => this.handler.handle(req2)));
        if (first2 instanceof HttpRequest || options.observe === "events") {
          return events$;
        }
        const res$ = events$.pipe(filter((event) => event instanceof HttpResponse));
        switch (options.observe || "body") {
          case "body":
            switch (req.responseType) {
              case "arraybuffer":
                return res$.pipe(map((res) => {
                  if (res.body !== null && !(res.body instanceof ArrayBuffer)) {
                    throw new RuntimeError(2806, ngDevMode && "Response is not an ArrayBuffer.");
                  }
                  return res.body;
                }));
              case "blob":
                return res$.pipe(map((res) => {
                  if (res.body !== null && !(res.body instanceof Blob)) {
                    throw new RuntimeError(2807, ngDevMode && "Response is not a Blob.");
                  }
                  return res.body;
                }));
              case "text":
                return res$.pipe(map((res) => {
                  if (res.body !== null && typeof res.body !== "string") {
                    throw new RuntimeError(2808, ngDevMode && "Response is not a string.");
                  }
                  return res.body;
                }));
              case "json":
              default:
                return res$.pipe(map((res) => res.body));
            }
          case "response":
            return res$;
          default:
            throw new RuntimeError(2809, ngDevMode && `Unreachable: unhandled observe type ${options.observe}}`);
        }
      }
      /**
       * Constructs an observable that, when subscribed, causes the configured
       * `DELETE` request to execute on the server. See the individual overloads for
       * details on the return type.
       *
       * @param url     The endpoint URL.
       * @param options The HTTP options to send with the request.
       *
       */
      delete(url, options = {}) {
        return this.request("DELETE", url, options);
      }
      /**
       * Constructs an observable that, when subscribed, causes the configured
       * `GET` request to execute on the server. See the individual overloads for
       * details on the return type.
       */
      get(url, options = {}) {
        return this.request("GET", url, options);
      }
      /**
       * Constructs an observable that, when subscribed, causes the configured
       * `HEAD` request to execute on the server. The `HEAD` method returns
       * meta information about the resource without transferring the
       * resource itself. See the individual overloads for
       * details on the return type.
       */
      head(url, options = {}) {
        return this.request("HEAD", url, options);
      }
      /**
       * Constructs an `Observable` that, when subscribed, causes a request with the special method
       * `JSONP` to be dispatched via the interceptor pipeline.
       * The [JSONP pattern](https://en.wikipedia.org/wiki/JSONP) works around limitations of certain
       * API endpoints that don't support newer,
       * and preferable [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) protocol.
       * JSONP treats the endpoint API as a JavaScript file and tricks the browser to process the
       * requests even if the API endpoint is not located on the same domain (origin) as the client-side
       * application making the request.
       * The endpoint API must support JSONP callback for JSONP requests to work.
       * The resource API returns the JSON response wrapped in a callback function.
       * You can pass the callback function name as one of the query parameters.
       * Note that JSONP requests can only be used with `GET` requests.
       *
       * @param url The resource URL.
       * @param callbackParam The callback function name.
       *
       */
      jsonp(url, callbackParam) {
        return this.request("JSONP", url, {
          params: new HttpParams().append(callbackParam, "JSONP_CALLBACK"),
          observe: "body",
          responseType: "json"
        });
      }
      /**
       * Constructs an `Observable` that, when subscribed, causes the configured
       * `OPTIONS` request to execute on the server. This method allows the client
       * to determine the supported HTTP methods and other capabilities of an endpoint,
       * without implying a resource action. See the individual overloads for
       * details on the return type.
       */
      options(url, options = {}) {
        return this.request("OPTIONS", url, options);
      }
      /**
       * Constructs an observable that, when subscribed, causes the configured
       * `PATCH` request to execute on the server. See the individual overloads for
       * details on the return type.
       */
      patch(url, body, options = {}) {
        return this.request("PATCH", url, addBody(options, body));
      }
      /**
       * Constructs an observable that, when subscribed, causes the configured
       * `POST` request to execute on the server. The server responds with the location of
       * the replaced resource. See the individual overloads for
       * details on the return type.
       */
      post(url, body, options = {}) {
        return this.request("POST", url, addBody(options, body));
      }
      /**
       * Constructs an observable that, when subscribed, causes the configured
       * `PUT` request to execute on the server. The `PUT` method replaces an existing resource
       * with a new set of values.
       * See the individual overloads for details on the return type.
       */
      put(url, body, options = {}) {
        return this.request("PUT", url, addBody(options, body));
      }
      static \u0275fac = function HttpClient_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HttpClient)(\u0275\u0275inject(HttpHandler));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _HttpClient,
        factory: _HttpClient.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClient, [{
        type: Injectable
      }], () => [{
        type: HttpHandler
      }], null);
    })();
    XSSI_PREFIX$1 = /^\)\]\}',?\n/;
    FETCH_BACKEND = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "FETCH_BACKEND" : "");
    FetchBackend = class _FetchBackend {
      // We use an arrow function to always reference the current global implementation of `fetch`.
      // This is helpful for cases when the global `fetch` implementation is modified by external code,
      // see https://github.com/angular/angular/issues/57527.
      fetchImpl = inject2(FetchFactory, {
        optional: true
      })?.fetch ?? ((...args) => globalThis.fetch(...args));
      ngZone = inject2(NgZone);
      destroyRef = inject2(DestroyRef);
      destroyed = false;
      constructor() {
        this.destroyRef.onDestroy(() => {
          this.destroyed = true;
        });
      }
      handle(request) {
        return new Observable((observer) => {
          const aborter = new AbortController();
          this.doRequest(request, aborter.signal, observer).then(noop3, (error) => observer.error(new HttpErrorResponse({
            error
          })));
          let timeoutId;
          if (request.timeout) {
            timeoutId = this.ngZone.runOutsideAngular(() => setTimeout(() => {
              if (!aborter.signal.aborted) {
                aborter.abort(new DOMException("signal timed out", "TimeoutError"));
              }
            }, request.timeout));
          }
          return () => {
            if (timeoutId !== void 0) {
              clearTimeout(timeoutId);
            }
            aborter.abort();
          };
        });
      }
      doRequest(request, signal2, observer) {
        return __async(this, null, function* () {
          const init = this.createRequestInit(request);
          let response;
          try {
            const fetchPromise = this.ngZone.runOutsideAngular(() => this.fetchImpl(request.urlWithParams, __spreadValues({
              signal: signal2
            }, init)));
            silenceSuperfluousUnhandledPromiseRejection(fetchPromise);
            observer.next({
              type: HttpEventType.Sent
            });
            response = yield fetchPromise;
          } catch (error) {
            observer.error(new HttpErrorResponse({
              error,
              status: error.status ?? 0,
              statusText: error.statusText,
              url: request.urlWithParams,
              headers: error.headers
            }));
            return;
          }
          const headers = new HttpHeaders(response.headers);
          const statusText = response.statusText;
          const url = getResponseUrl$1(response) ?? request.urlWithParams;
          let status = response.status;
          let body = null;
          if (request.reportProgress) {
            observer.next(new HttpHeaderResponse({
              headers,
              status,
              statusText,
              url
            }));
          }
          if (response.body) {
            const contentLength = response.headers.get("content-length");
            const chunks = [];
            const reader = response.body.getReader();
            let receivedLength = 0;
            let decoder;
            let partialText;
            const reqZone = typeof Zone !== "undefined" && Zone.current;
            let canceled = false;
            yield this.ngZone.runOutsideAngular(() => __async(this, null, function* () {
              while (true) {
                if (this.destroyed) {
                  yield reader.cancel();
                  canceled = true;
                  break;
                }
                const {
                  done,
                  value
                } = yield reader.read();
                if (done) {
                  break;
                }
                chunks.push(value);
                receivedLength += value.length;
                if (request.reportProgress) {
                  partialText = request.responseType === "text" ? (partialText ?? "") + (decoder ??= new TextDecoder()).decode(value, {
                    stream: true
                  }) : void 0;
                  const reportProgress = () => observer.next({
                    type: HttpEventType.DownloadProgress,
                    total: contentLength ? +contentLength : void 0,
                    loaded: receivedLength,
                    partialText
                  });
                  reqZone ? reqZone.run(reportProgress) : reportProgress();
                }
              }
            }));
            if (canceled) {
              observer.complete();
              return;
            }
            const chunksAll = this.concatChunks(chunks, receivedLength);
            try {
              const contentType = response.headers.get(CONTENT_TYPE_HEADER) ?? "";
              body = this.parseBody(request, chunksAll, contentType, status);
            } catch (error) {
              observer.error(new HttpErrorResponse({
                error,
                headers: new HttpHeaders(response.headers),
                status: response.status,
                statusText: response.statusText,
                url: getResponseUrl$1(response) ?? request.urlWithParams
              }));
              return;
            }
          }
          if (status === 0) {
            status = body ? HTTP_STATUS_CODE_OK : 0;
          }
          const ok = status >= 200 && status < 300;
          if (ok) {
            observer.next(new HttpResponse({
              body,
              headers,
              status,
              statusText,
              url
            }));
            observer.complete();
          } else {
            observer.error(new HttpErrorResponse({
              error: body,
              headers,
              status,
              statusText,
              url
            }));
          }
        });
      }
      parseBody(request, binContent, contentType, status) {
        switch (request.responseType) {
          case "json":
            const text = new TextDecoder().decode(binContent).replace(XSSI_PREFIX$1, "");
            if (text === "") {
              return null;
            }
            try {
              return JSON.parse(text);
            } catch (e2) {
              if (status < 200 || status >= 300) {
                return text;
              }
              throw e2;
            }
          case "text":
            return new TextDecoder().decode(binContent);
          case "blob":
            return new Blob([binContent], {
              type: contentType
            });
          case "arraybuffer":
            return binContent.buffer;
        }
      }
      createRequestInit(req) {
        const headers = {};
        let credentials;
        credentials = req.credentials;
        if (req.withCredentials) {
          (typeof ngDevMode === "undefined" || ngDevMode) && warningOptionsMessage(req);
          credentials = "include";
        }
        req.headers.forEach((name, values) => headers[name] = values.join(","));
        if (!req.headers.has(ACCEPT_HEADER)) {
          headers[ACCEPT_HEADER] = ACCEPT_HEADER_VALUE;
        }
        if (!req.headers.has(CONTENT_TYPE_HEADER)) {
          const detectedType = req.detectContentTypeHeader();
          if (detectedType !== null) {
            headers[CONTENT_TYPE_HEADER] = detectedType;
          }
        }
        return {
          body: req.serializeBody(),
          method: req.method,
          headers,
          credentials,
          keepalive: req.keepalive,
          cache: req.cache,
          priority: req.priority,
          mode: req.mode,
          redirect: req.redirect
        };
      }
      concatChunks(chunks, totalLength) {
        const chunksAll = new Uint8Array(totalLength);
        let position = 0;
        for (const chunk of chunks) {
          chunksAll.set(chunk, position);
          position += chunk.length;
        }
        return chunksAll;
      }
      static \u0275fac = function FetchBackend_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _FetchBackend)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _FetchBackend,
        factory: _FetchBackend.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FetchBackend, [{
        type: Injectable
      }], () => [], null);
    })();
    FetchFactory = class {
    };
    HTTP_INTERCEPTORS = new InjectionToken(ngDevMode ? "HTTP_INTERCEPTORS" : "");
    HTTP_INTERCEPTOR_FNS = new InjectionToken(ngDevMode ? "HTTP_INTERCEPTOR_FNS" : "");
    HTTP_ROOT_INTERCEPTOR_FNS = new InjectionToken(ngDevMode ? "HTTP_ROOT_INTERCEPTOR_FNS" : "");
    REQUESTS_CONTRIBUTE_TO_STABILITY = new InjectionToken(ngDevMode ? "REQUESTS_CONTRIBUTE_TO_STABILITY" : "", {
      providedIn: "root",
      factory: () => true
    });
    fetchBackendWarningDisplayed = false;
    HttpInterceptorHandler = class _HttpInterceptorHandler extends HttpHandler {
      backend;
      injector;
      chain = null;
      pendingTasks = inject2(PendingTasks);
      contributeToStability = inject2(REQUESTS_CONTRIBUTE_TO_STABILITY);
      constructor(backend, injector) {
        super();
        this.backend = backend;
        this.injector = injector;
        if ((typeof ngDevMode === "undefined" || ngDevMode) && !fetchBackendWarningDisplayed) {
          const isTestingBackend = this.backend.isTestingBackend;
          if (false) {
            fetchBackendWarningDisplayed = true;
            injector.get(Console).warn(formatRuntimeError(2801, "Angular detected that `HttpClient` is not configured to use `fetch` APIs. It's strongly recommended to enable `fetch` for applications that use Server-Side Rendering for better performance and compatibility. To enable `fetch`, add the `withFetch()` to the `provideHttpClient()` call at the root of the application."));
          }
        }
      }
      handle(initialRequest) {
        if (this.chain === null) {
          const dedupedInterceptorFns = Array.from(/* @__PURE__ */ new Set([...this.injector.get(HTTP_INTERCEPTOR_FNS), ...this.injector.get(HTTP_ROOT_INTERCEPTOR_FNS, [])]));
          this.chain = dedupedInterceptorFns.reduceRight((nextSequencedFn, interceptorFn) => chainedInterceptorFn(nextSequencedFn, interceptorFn, this.injector), interceptorChainEndFn);
        }
        if (this.contributeToStability) {
          const removeTask = this.pendingTasks.add();
          return this.chain(initialRequest, (downstreamRequest) => this.backend.handle(downstreamRequest)).pipe(finalize(removeTask));
        } else {
          return this.chain(initialRequest, (downstreamRequest) => this.backend.handle(downstreamRequest));
        }
      }
      static \u0275fac = function HttpInterceptorHandler_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HttpInterceptorHandler)(\u0275\u0275inject(HttpBackend), \u0275\u0275inject(EnvironmentInjector));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _HttpInterceptorHandler,
        factory: _HttpInterceptorHandler.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpInterceptorHandler, [{
        type: Injectable
      }], () => [{
        type: HttpBackend
      }, {
        type: EnvironmentInjector
      }], null);
    })();
    nextRequestId = 0;
    JSONP_ERR_NO_CALLBACK = "JSONP injected script did not invoke callback.";
    JSONP_ERR_WRONG_METHOD = "JSONP requests must use JSONP request method.";
    JSONP_ERR_WRONG_RESPONSE_TYPE = "JSONP requests must use Json response type.";
    JSONP_ERR_HEADERS_NOT_SUPPORTED = "JSONP requests do not support headers.";
    JsonpCallbackContext = class {
    };
    JsonpClientBackend = class _JsonpClientBackend {
      callbackMap;
      document;
      /**
       * A resolved promise that can be used to schedule microtasks in the event handlers.
       */
      resolvedPromise = Promise.resolve();
      constructor(callbackMap, document2) {
        this.callbackMap = callbackMap;
        this.document = document2;
      }
      /**
       * Get the name of the next callback method, by incrementing the global `nextRequestId`.
       */
      nextCallback() {
        return `ng_jsonp_callback_${nextRequestId++}`;
      }
      /**
       * Processes a JSONP request and returns an event stream of the results.
       * @param req The request object.
       * @returns An observable of the response events.
       *
       */
      handle(req) {
        if (req.method !== "JSONP") {
          throw new RuntimeError(2810, ngDevMode && JSONP_ERR_WRONG_METHOD);
        } else if (req.responseType !== "json") {
          throw new RuntimeError(2811, ngDevMode && JSONP_ERR_WRONG_RESPONSE_TYPE);
        }
        if (req.headers.keys().length > 0) {
          throw new RuntimeError(2812, ngDevMode && JSONP_ERR_HEADERS_NOT_SUPPORTED);
        }
        return new Observable((observer) => {
          const callback = this.nextCallback();
          const url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);
          const node = this.document.createElement("script");
          node.src = url;
          let body = null;
          let finished = false;
          this.callbackMap[callback] = (data) => {
            delete this.callbackMap[callback];
            body = data;
            finished = true;
          };
          const cleanup = () => {
            node.removeEventListener("load", onLoad);
            node.removeEventListener("error", onError);
            node.remove();
            delete this.callbackMap[callback];
          };
          const onLoad = () => {
            this.resolvedPromise.then(() => {
              cleanup();
              if (!finished) {
                observer.error(new HttpErrorResponse({
                  url,
                  status: 0,
                  statusText: "JSONP Error",
                  error: new Error(JSONP_ERR_NO_CALLBACK)
                }));
                return;
              }
              observer.next(new HttpResponse({
                body,
                status: HTTP_STATUS_CODE_OK,
                statusText: "OK",
                url
              }));
              observer.complete();
            });
          };
          const onError = (error) => {
            cleanup();
            observer.error(new HttpErrorResponse({
              error,
              status: 0,
              statusText: "JSONP Error",
              url
            }));
          };
          node.addEventListener("load", onLoad);
          node.addEventListener("error", onError);
          this.document.body.appendChild(node);
          observer.next({
            type: HttpEventType.Sent
          });
          return () => {
            if (!finished) {
              this.removeListeners(node);
            }
            cleanup();
          };
        });
      }
      removeListeners(script) {
        foreignDocument ??= this.document.implementation.createHTMLDocument();
        foreignDocument.adoptNode(script);
      }
      static \u0275fac = function JsonpClientBackend_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _JsonpClientBackend)(\u0275\u0275inject(JsonpCallbackContext), \u0275\u0275inject(DOCUMENT));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _JsonpClientBackend,
        factory: _JsonpClientBackend.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonpClientBackend, [{
        type: Injectable
      }], () => [{
        type: JsonpCallbackContext
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DOCUMENT]
        }]
      }], null);
    })();
    JsonpInterceptor = class _JsonpInterceptor {
      injector;
      constructor(injector) {
        this.injector = injector;
      }
      /**
       * Identifies and handles a given JSONP request.
       * @param initialRequest The outgoing request object to handle.
       * @param next The next interceptor in the chain, or the backend
       * if no interceptors remain in the chain.
       * @returns An observable of the event stream.
       */
      intercept(initialRequest, next) {
        return runInInjectionContext(this.injector, () => jsonpInterceptorFn(initialRequest, (downstreamRequest) => next.handle(downstreamRequest)));
      }
      static \u0275fac = function JsonpInterceptor_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _JsonpInterceptor)(\u0275\u0275inject(EnvironmentInjector));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _JsonpInterceptor,
        factory: _JsonpInterceptor.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonpInterceptor, [{
        type: Injectable
      }], () => [{
        type: EnvironmentInjector
      }], null);
    })();
    XSSI_PREFIX = /^\)\]\}',?\n/;
    X_REQUEST_URL_REGEXP = RegExp(`^${X_REQUEST_URL_HEADER}:`, "m");
    HttpXhrBackend = class _HttpXhrBackend {
      xhrFactory;
      constructor(xhrFactory) {
        this.xhrFactory = xhrFactory;
      }
      /**
       * Processes a request and returns a stream of response events.
       * @param req The request object.
       * @returns An observable of the response events.
       */
      handle(req) {
        if (req.method === "JSONP") {
          throw new RuntimeError(-2800, (typeof ngDevMode === "undefined" || ngDevMode) && `Cannot make a JSONP request without JSONP support. To fix the problem, either add the \`withJsonpSupport()\` call (if \`provideHttpClient()\` is used) or import the \`HttpClientJsonpModule\` in the root NgModule.`);
        }
        ngDevMode && validateXhrCompatibility(req);
        const xhrFactory = this.xhrFactory;
        const source = (
          // Note that `ɵloadImpl` is never defined in client bundles and can be
          // safely dropped whenever we're running in the browser.
          // This branching is redundant.
          // The `ngServerMode` guard also enables tree-shaking of the `from()`
          // function from the common bundle, as it's only used in server code.
          false ? from(xhrFactory.\u0275loadImpl()) : of(null)
        );
        return source.pipe(switchMap(() => {
          return new Observable((observer) => {
            const xhr = xhrFactory.build();
            xhr.open(req.method, req.urlWithParams);
            if (req.withCredentials) {
              xhr.withCredentials = true;
            }
            req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(",")));
            if (!req.headers.has(ACCEPT_HEADER)) {
              xhr.setRequestHeader(ACCEPT_HEADER, ACCEPT_HEADER_VALUE);
            }
            if (!req.headers.has(CONTENT_TYPE_HEADER)) {
              const detectedType = req.detectContentTypeHeader();
              if (detectedType !== null) {
                xhr.setRequestHeader(CONTENT_TYPE_HEADER, detectedType);
              }
            }
            if (req.timeout) {
              xhr.timeout = req.timeout;
            }
            if (req.responseType) {
              const responseType = req.responseType.toLowerCase();
              xhr.responseType = responseType !== "json" ? responseType : "text";
            }
            const reqBody = req.serializeBody();
            let headerResponse = null;
            const partialFromXhr = () => {
              if (headerResponse !== null) {
                return headerResponse;
              }
              const statusText = xhr.statusText || "OK";
              const headers = new HttpHeaders(xhr.getAllResponseHeaders());
              const url = getResponseUrl(xhr) || req.url;
              headerResponse = new HttpHeaderResponse({
                headers,
                status: xhr.status,
                statusText,
                url
              });
              return headerResponse;
            };
            const onLoad = () => {
              let {
                headers,
                status,
                statusText,
                url
              } = partialFromXhr();
              let body = null;
              if (status !== HTTP_STATUS_CODE_NO_CONTENT) {
                body = typeof xhr.response === "undefined" ? xhr.responseText : xhr.response;
              }
              if (status === 0) {
                status = !!body ? HTTP_STATUS_CODE_OK : 0;
              }
              let ok = status >= 200 && status < 300;
              if (req.responseType === "json" && typeof body === "string") {
                const originalBody = body;
                body = body.replace(XSSI_PREFIX, "");
                try {
                  body = body !== "" ? JSON.parse(body) : null;
                } catch (error) {
                  body = originalBody;
                  if (ok) {
                    ok = false;
                    body = {
                      error,
                      text: body
                    };
                  }
                }
              }
              if (ok) {
                observer.next(new HttpResponse({
                  body,
                  headers,
                  status,
                  statusText,
                  url: url || void 0
                }));
                observer.complete();
              } else {
                observer.error(new HttpErrorResponse({
                  // The error in this case is the response body (error from the server).
                  error: body,
                  headers,
                  status,
                  statusText,
                  url: url || void 0
                }));
              }
            };
            const onError = (error) => {
              const {
                url
              } = partialFromXhr();
              const res = new HttpErrorResponse({
                error,
                status: xhr.status || 0,
                statusText: xhr.statusText || "Unknown Error",
                url: url || void 0
              });
              observer.error(res);
            };
            let onTimeout = onError;
            if (req.timeout) {
              onTimeout = (_2) => {
                const {
                  url
                } = partialFromXhr();
                const res = new HttpErrorResponse({
                  error: new DOMException("Request timed out", "TimeoutError"),
                  status: xhr.status || 0,
                  statusText: xhr.statusText || "Request timeout",
                  url: url || void 0
                });
                observer.error(res);
              };
            }
            let sentHeaders = false;
            const onDownProgress = (event) => {
              if (!sentHeaders) {
                observer.next(partialFromXhr());
                sentHeaders = true;
              }
              let progressEvent = {
                type: HttpEventType.DownloadProgress,
                loaded: event.loaded
              };
              if (event.lengthComputable) {
                progressEvent.total = event.total;
              }
              if (req.responseType === "text" && !!xhr.responseText) {
                progressEvent.partialText = xhr.responseText;
              }
              observer.next(progressEvent);
            };
            const onUpProgress = (event) => {
              let progress = {
                type: HttpEventType.UploadProgress,
                loaded: event.loaded
              };
              if (event.lengthComputable) {
                progress.total = event.total;
              }
              observer.next(progress);
            };
            xhr.addEventListener("load", onLoad);
            xhr.addEventListener("error", onError);
            xhr.addEventListener("timeout", onTimeout);
            xhr.addEventListener("abort", onError);
            if (req.reportProgress) {
              xhr.addEventListener("progress", onDownProgress);
              if (reqBody !== null && xhr.upload) {
                xhr.upload.addEventListener("progress", onUpProgress);
              }
            }
            xhr.send(reqBody);
            observer.next({
              type: HttpEventType.Sent
            });
            return () => {
              xhr.removeEventListener("error", onError);
              xhr.removeEventListener("abort", onError);
              xhr.removeEventListener("load", onLoad);
              xhr.removeEventListener("timeout", onTimeout);
              if (req.reportProgress) {
                xhr.removeEventListener("progress", onDownProgress);
                if (reqBody !== null && xhr.upload) {
                  xhr.upload.removeEventListener("progress", onUpProgress);
                }
              }
              if (xhr.readyState !== xhr.DONE) {
                xhr.abort();
              }
            };
          });
        }));
      }
      static \u0275fac = function HttpXhrBackend_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HttpXhrBackend)(\u0275\u0275inject(XhrFactory));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _HttpXhrBackend,
        factory: _HttpXhrBackend.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpXhrBackend, [{
        type: Injectable
      }], () => [{
        type: XhrFactory
      }], null);
    })();
    XSRF_ENABLED = new InjectionToken(ngDevMode ? "XSRF_ENABLED" : "");
    XSRF_DEFAULT_COOKIE_NAME = "XSRF-TOKEN";
    XSRF_COOKIE_NAME = new InjectionToken(ngDevMode ? "XSRF_COOKIE_NAME" : "", {
      providedIn: "root",
      factory: () => XSRF_DEFAULT_COOKIE_NAME
    });
    XSRF_DEFAULT_HEADER_NAME = "X-XSRF-TOKEN";
    XSRF_HEADER_NAME = new InjectionToken(ngDevMode ? "XSRF_HEADER_NAME" : "", {
      providedIn: "root",
      factory: () => XSRF_DEFAULT_HEADER_NAME
    });
    HttpXsrfTokenExtractor = class {
    };
    HttpXsrfCookieExtractor = class _HttpXsrfCookieExtractor {
      doc;
      cookieName;
      lastCookieString = "";
      lastToken = null;
      /**
       * @internal for testing
       */
      parseCount = 0;
      constructor(doc, cookieName) {
        this.doc = doc;
        this.cookieName = cookieName;
      }
      getToken() {
        if (false) {
          return null;
        }
        const cookieString = this.doc.cookie || "";
        if (cookieString !== this.lastCookieString) {
          this.parseCount++;
          this.lastToken = parseCookieValue(cookieString, this.cookieName);
          this.lastCookieString = cookieString;
        }
        return this.lastToken;
      }
      static \u0275fac = function HttpXsrfCookieExtractor_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HttpXsrfCookieExtractor)(\u0275\u0275inject(DOCUMENT), \u0275\u0275inject(XSRF_COOKIE_NAME));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _HttpXsrfCookieExtractor,
        factory: _HttpXsrfCookieExtractor.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpXsrfCookieExtractor, [{
        type: Injectable
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DOCUMENT]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [XSRF_COOKIE_NAME]
        }]
      }], null);
    })();
    HttpXsrfInterceptor = class _HttpXsrfInterceptor {
      injector;
      constructor(injector) {
        this.injector = injector;
      }
      intercept(initialRequest, next) {
        return runInInjectionContext(this.injector, () => xsrfInterceptorFn(initialRequest, (downstreamRequest) => next.handle(downstreamRequest)));
      }
      static \u0275fac = function HttpXsrfInterceptor_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HttpXsrfInterceptor)(\u0275\u0275inject(EnvironmentInjector));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _HttpXsrfInterceptor,
        factory: _HttpXsrfInterceptor.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpXsrfInterceptor, [{
        type: Injectable
      }], () => [{
        type: EnvironmentInjector
      }], null);
    })();
    (function(HttpFeatureKind2) {
      HttpFeatureKind2[HttpFeatureKind2["Interceptors"] = 0] = "Interceptors";
      HttpFeatureKind2[HttpFeatureKind2["LegacyInterceptors"] = 1] = "LegacyInterceptors";
      HttpFeatureKind2[HttpFeatureKind2["CustomXsrfConfiguration"] = 2] = "CustomXsrfConfiguration";
      HttpFeatureKind2[HttpFeatureKind2["NoXsrfProtection"] = 3] = "NoXsrfProtection";
      HttpFeatureKind2[HttpFeatureKind2["JsonpSupport"] = 4] = "JsonpSupport";
      HttpFeatureKind2[HttpFeatureKind2["RequestsMadeViaParent"] = 5] = "RequestsMadeViaParent";
      HttpFeatureKind2[HttpFeatureKind2["Fetch"] = 6] = "Fetch";
    })(HttpFeatureKind || (HttpFeatureKind = {}));
    LEGACY_INTERCEPTOR_FN = new InjectionToken(ngDevMode ? "LEGACY_INTERCEPTOR_FN" : "");
    HttpClientXsrfModule = class _HttpClientXsrfModule {
      /**
       * Disable the default XSRF protection.
       */
      static disable() {
        return {
          ngModule: _HttpClientXsrfModule,
          providers: [withNoXsrfProtection().\u0275providers]
        };
      }
      /**
       * Configure XSRF protection.
       * @param options An object that can specify either or both
       * cookie name or header name.
       * - Cookie name default is `XSRF-TOKEN`.
       * - Header name default is `X-XSRF-TOKEN`.
       *
       */
      static withOptions(options = {}) {
        return {
          ngModule: _HttpClientXsrfModule,
          providers: withXsrfConfiguration(options).\u0275providers
        };
      }
      static \u0275fac = function HttpClientXsrfModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HttpClientXsrfModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _HttpClientXsrfModule
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
        providers: [HttpXsrfInterceptor, {
          provide: HTTP_INTERCEPTORS,
          useExisting: HttpXsrfInterceptor,
          multi: true
        }, {
          provide: HttpXsrfTokenExtractor,
          useClass: HttpXsrfCookieExtractor
        }, withXsrfConfiguration({
          cookieName: XSRF_DEFAULT_COOKIE_NAME,
          headerName: XSRF_DEFAULT_HEADER_NAME
        }).\u0275providers, {
          provide: XSRF_ENABLED,
          useValue: true
        }]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClientXsrfModule, [{
        type: NgModule,
        args: [{
          providers: [HttpXsrfInterceptor, {
            provide: HTTP_INTERCEPTORS,
            useExisting: HttpXsrfInterceptor,
            multi: true
          }, {
            provide: HttpXsrfTokenExtractor,
            useClass: HttpXsrfCookieExtractor
          }, withXsrfConfiguration({
            cookieName: XSRF_DEFAULT_COOKIE_NAME,
            headerName: XSRF_DEFAULT_HEADER_NAME
          }).\u0275providers, {
            provide: XSRF_ENABLED,
            useValue: true
          }]
        }]
      }], null, null);
    })();
    HttpClientModule = class _HttpClientModule {
      static \u0275fac = function HttpClientModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HttpClientModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _HttpClientModule
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
        providers: [provideHttpClient(withInterceptorsFromDi())]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClientModule, [{
        type: NgModule,
        args: [{
          /**
           * Configures the dependency injector where it is imported
           * with supporting services for HTTP communications.
           */
          providers: [provideHttpClient(withInterceptorsFromDi())]
        }]
      }], null, null);
    })();
    HttpClientJsonpModule = class _HttpClientJsonpModule {
      static \u0275fac = function HttpClientJsonpModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HttpClientJsonpModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _HttpClientJsonpModule
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
        providers: [withJsonpSupport().\u0275providers]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClientJsonpModule, [{
        type: NgModule,
        args: [{
          providers: [withJsonpSupport().\u0275providers]
        }]
      }], null, null);
    })();
  }
});

// node_modules/@angular/common/fesm2022/http.mjs
function makeHttpResourceFn(responseType) {
  return function httpResource2(request, options) {
    if (ngDevMode && !options?.injector) {
      assertInInjectionContext(httpResource2);
    }
    const injector = options?.injector ?? inject2(Injector);
    return new HttpResourceImpl(injector, () => normalizeRequest(request, responseType), options?.defaultValue, options?.parse, options?.equal);
  };
}
function normalizeRequest(request, responseType) {
  let unwrappedRequest = typeof request === "function" ? request() : request;
  if (unwrappedRequest === void 0) {
    return void 0;
  } else if (typeof unwrappedRequest === "string") {
    unwrappedRequest = { url: unwrappedRequest };
  }
  const headers = unwrappedRequest.headers instanceof HttpHeaders ? unwrappedRequest.headers : new HttpHeaders(unwrappedRequest.headers);
  const params = unwrappedRequest.params instanceof HttpParams ? unwrappedRequest.params : new HttpParams({ fromObject: unwrappedRequest.params });
  return new HttpRequest(unwrappedRequest.method ?? "GET", unwrappedRequest.url, unwrappedRequest.body ?? null, {
    headers,
    params,
    reportProgress: unwrappedRequest.reportProgress,
    withCredentials: unwrappedRequest.withCredentials,
    keepalive: unwrappedRequest.keepalive,
    cache: unwrappedRequest.cache,
    priority: unwrappedRequest.priority,
    mode: unwrappedRequest.mode,
    redirect: unwrappedRequest.redirect,
    responseType,
    context: unwrappedRequest.context,
    transferCache: unwrappedRequest.transferCache,
    credentials: unwrappedRequest.credentials,
    timeout: unwrappedRequest.timeout
  });
}
var httpResource, HttpResourceImpl, HTTP_TRANSFER_CACHE_ORIGIN_MAP, CACHE_OPTIONS;
var init_http = __esm({
  "node_modules/@angular/common/fesm2022/http.mjs"() {
    "use strict";
    init_module();
    init_module();
    init_core();
    httpResource = (() => {
      const jsonFn = makeHttpResourceFn("json");
      jsonFn.arrayBuffer = makeHttpResourceFn("arraybuffer");
      jsonFn.blob = makeHttpResourceFn("blob");
      jsonFn.text = makeHttpResourceFn("text");
      return jsonFn;
    })();
    HttpResourceImpl = class extends ResourceImpl {
      client;
      _headers = linkedSignal({
        source: this.extRequest,
        computation: () => void 0
      });
      _progress = linkedSignal({
        source: this.extRequest,
        computation: () => void 0
      });
      _statusCode = linkedSignal({
        source: this.extRequest,
        computation: () => void 0
      });
      headers = computed(() => this.status() === "resolved" || this.status() === "error" ? this._headers() : void 0, ...ngDevMode ? [{ debugName: "headers" }] : []);
      progress = this._progress.asReadonly();
      statusCode = this._statusCode.asReadonly();
      constructor(injector, request, defaultValue, parse, equal) {
        super(request, ({ params: request2, abortSignal }) => {
          let sub;
          const onAbort = () => sub.unsubscribe();
          abortSignal.addEventListener("abort", onAbort);
          const stream = signal({ value: void 0 }, ...ngDevMode ? [{ debugName: "stream" }] : []);
          let resolve;
          const promise = new Promise((r2) => resolve = r2);
          const send = (value) => {
            stream.set(value);
            resolve?.(stream);
            resolve = void 0;
          };
          sub = this.client.request(request2).subscribe({
            next: (event) => {
              switch (event.type) {
                case HttpEventType.Response:
                  this._headers.set(event.headers);
                  this._statusCode.set(event.status);
                  try {
                    send({ value: parse ? parse(event.body) : event.body });
                  } catch (error) {
                    send({ error: encapsulateResourceError(error) });
                  }
                  break;
                case HttpEventType.DownloadProgress:
                  this._progress.set(event);
                  break;
              }
            },
            error: (error) => {
              if (error instanceof HttpErrorResponse) {
                this._headers.set(error.headers);
                this._statusCode.set(error.status);
              }
              send({ error });
              abortSignal.removeEventListener("abort", onAbort);
            },
            complete: () => {
              if (resolve) {
                send({
                  error: new RuntimeError(991, ngDevMode && "Resource completed before producing a value")
                });
              }
              abortSignal.removeEventListener("abort", onAbort);
            }
          });
          return promise;
        }, defaultValue, equal, injector);
        this.client = injector.get(HttpClient);
      }
      set(value) {
        super.set(value);
        this._headers.set(void 0);
        this._progress.set(void 0);
        this._statusCode.set(void 0);
      }
    };
    HTTP_TRANSFER_CACHE_ORIGIN_MAP = new InjectionToken(ngDevMode ? "HTTP_TRANSFER_CACHE_ORIGIN_MAP" : "");
    CACHE_OPTIONS = new InjectionToken(ngDevMode ? "HTTP_TRANSFER_STATE_CACHE_OPTIONS" : "");
  }
});

// node_modules/@angular/platform-browser/fesm2022/platform-browser.mjs
var Meta, META_KEYS_MAP, Title, EVENT_NAMES, HAMMER_GESTURE_CONFIG, HAMMER_LOADER, HammerGestureConfig, HammerGesturesPlugin, HammerModule, DomSanitizer, DomSanitizerImpl, HydrationFeatureKind, VERSION3;
var init_platform_browser = __esm({
  "node_modules/@angular/platform-browser/fesm2022/platform-browser.mjs"() {
    "use strict";
    init_browser();
    init_common();
    init_core();
    init_core();
    init_dom_renderer();
    Meta = class _Meta {
      _doc;
      _dom;
      constructor(_doc) {
        this._doc = _doc;
        this._dom = getDOM();
      }
      /**
       * Retrieves or creates a specific `<meta>` tag element in the current HTML document.
       * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute
       * values in the provided tag definition, and verifies that all other attribute values are equal.
       * If an existing element is found, it is returned and is not modified in any way.
       * @param tag The definition of a `<meta>` element to match or create.
       * @param forceCreation True to create a new element without checking whether one already exists.
       * @returns The existing element with the same attributes and values if found,
       * the new element if no match is found, or `null` if the tag parameter is not defined.
       */
      addTag(tag, forceCreation = false) {
        if (!tag) return null;
        return this._getOrCreateElement(tag, forceCreation);
      }
      /**
       * Retrieves or creates a set of `<meta>` tag elements in the current HTML document.
       * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute
       * values in the provided tag definition, and verifies that all other attribute values are equal.
       * @param tags An array of tag definitions to match or create.
       * @param forceCreation True to create new elements without checking whether they already exist.
       * @returns The matching elements if found, or the new elements.
       */
      addTags(tags, forceCreation = false) {
        if (!tags) return [];
        return tags.reduce((result, tag) => {
          if (tag) {
            result.push(this._getOrCreateElement(tag, forceCreation));
          }
          return result;
        }, []);
      }
      /**
       * Retrieves a `<meta>` tag element in the current HTML document.
       * @param attrSelector The tag attribute and value to match against, in the format
       * `"tag_attribute='value string'"`.
       * @returns The matching element, if any.
       */
      getTag(attrSelector) {
        if (!attrSelector) return null;
        return this._doc.querySelector(`meta[${attrSelector}]`) || null;
      }
      /**
       * Retrieves a set of `<meta>` tag elements in the current HTML document.
       * @param attrSelector The tag attribute and value to match against, in the format
       * `"tag_attribute='value string'"`.
       * @returns The matching elements, if any.
       */
      getTags(attrSelector) {
        if (!attrSelector) return [];
        const list = this._doc.querySelectorAll(`meta[${attrSelector}]`);
        return list ? [].slice.call(list) : [];
      }
      /**
       * Modifies an existing `<meta>` tag element in the current HTML document.
       * @param tag The tag description with which to replace the existing tag content.
       * @param selector A tag attribute and value to match against, to identify
       * an existing tag. A string in the format `"tag_attribute=`value string`"`.
       * If not supplied, matches a tag with the same `name` or `property` attribute value as the
       * replacement tag.
       * @return The modified element.
       */
      updateTag(tag, selector) {
        if (!tag) return null;
        selector = selector || this._parseSelector(tag);
        const meta = this.getTag(selector);
        if (meta) {
          return this._setMetaElementAttributes(tag, meta);
        }
        return this._getOrCreateElement(tag, true);
      }
      /**
       * Removes an existing `<meta>` tag element from the current HTML document.
       * @param attrSelector A tag attribute and value to match against, to identify
       * an existing tag. A string in the format `"tag_attribute=`value string`"`.
       */
      removeTag(attrSelector) {
        this.removeTagElement(this.getTag(attrSelector));
      }
      /**
       * Removes an existing `<meta>` tag element from the current HTML document.
       * @param meta The tag definition to match against to identify an existing tag.
       */
      removeTagElement(meta) {
        if (meta) {
          this._dom.remove(meta);
        }
      }
      _getOrCreateElement(meta, forceCreation = false) {
        if (!forceCreation) {
          const selector = this._parseSelector(meta);
          const elem = this.getTags(selector).filter((elem2) => this._containsAttributes(meta, elem2))[0];
          if (elem !== void 0) return elem;
        }
        const element = this._dom.createElement("meta");
        this._setMetaElementAttributes(meta, element);
        const head = this._doc.getElementsByTagName("head")[0];
        head.appendChild(element);
        return element;
      }
      _setMetaElementAttributes(tag, el2) {
        Object.keys(tag).forEach((prop) => el2.setAttribute(this._getMetaKeyMap(prop), tag[prop]));
        return el2;
      }
      _parseSelector(tag) {
        const attr = tag.name ? "name" : "property";
        return `${attr}="${tag[attr]}"`;
      }
      _containsAttributes(tag, elem) {
        return Object.keys(tag).every((key) => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);
      }
      _getMetaKeyMap(prop) {
        return META_KEYS_MAP[prop] || prop;
      }
      static \u0275fac = function Meta_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Meta)(\u0275\u0275inject(DOCUMENT));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _Meta,
        factory: _Meta.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Meta, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DOCUMENT]
        }]
      }], null);
    })();
    META_KEYS_MAP = {
      httpEquiv: "http-equiv"
    };
    Title = class _Title {
      _doc;
      constructor(_doc) {
        this._doc = _doc;
      }
      /**
       * Get the title of the current HTML document.
       */
      getTitle() {
        return this._doc.title;
      }
      /**
       * Set the title of the current HTML document.
       * @param newTitle
       */
      setTitle(newTitle) {
        this._doc.title = newTitle || "";
      }
      static \u0275fac = function Title_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Title)(\u0275\u0275inject(DOCUMENT));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _Title,
        factory: _Title.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Title, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DOCUMENT]
        }]
      }], null);
    })();
    EVENT_NAMES = {
      // pan
      "pan": true,
      "panstart": true,
      "panmove": true,
      "panend": true,
      "pancancel": true,
      "panleft": true,
      "panright": true,
      "panup": true,
      "pandown": true,
      // pinch
      "pinch": true,
      "pinchstart": true,
      "pinchmove": true,
      "pinchend": true,
      "pinchcancel": true,
      "pinchin": true,
      "pinchout": true,
      // press
      "press": true,
      "pressup": true,
      // rotate
      "rotate": true,
      "rotatestart": true,
      "rotatemove": true,
      "rotateend": true,
      "rotatecancel": true,
      // swipe
      "swipe": true,
      "swipeleft": true,
      "swiperight": true,
      "swipeup": true,
      "swipedown": true,
      // tap
      "tap": true,
      "doubletap": true
    };
    HAMMER_GESTURE_CONFIG = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "HammerGestureConfig" : "");
    HAMMER_LOADER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "HammerLoader" : "");
    HammerGestureConfig = class _HammerGestureConfig {
      /**
       * A set of supported event names for gestures to be used in Angular.
       * Angular supports all built-in recognizers, as listed in
       * [HammerJS documentation](https://hammerjs.github.io/).
       */
      events = [];
      /**
       * Maps gesture event names to a set of configuration options
       * that specify overrides to the default values for specific properties.
       *
       * The key is a supported event name to be configured,
       * and the options object contains a set of properties, with override values
       * to be applied to the named recognizer event.
       * For example, to disable recognition of the rotate event, specify
       *  `{"rotate": {"enable": false}}`.
       *
       * Properties that are not present take the HammerJS default values.
       * For information about which properties are supported for which events,
       * and their allowed and default values, see
       * [HammerJS documentation](https://hammerjs.github.io/).
       *
       */
      overrides = {};
      /**
       * Properties whose default values can be overridden for a given event.
       * Different sets of properties apply to different events.
       * For information about which properties are supported for which events,
       * and their allowed and default values, see
       * [HammerJS documentation](https://hammerjs.github.io/).
       */
      options;
      /**
       * Creates a [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)
       * and attaches it to a given HTML element.
       * @param element The element that will recognize gestures.
       * @returns A HammerJS event-manager object.
       */
      buildHammer(element) {
        const mc2 = new Hammer(element, this.options);
        mc2.get("pinch").set({
          enable: true
        });
        mc2.get("rotate").set({
          enable: true
        });
        for (const eventName in this.overrides) {
          mc2.get(eventName).set(this.overrides[eventName]);
        }
        return mc2;
      }
      static \u0275fac = function HammerGestureConfig_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HammerGestureConfig)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _HammerGestureConfig,
        factory: _HammerGestureConfig.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerGestureConfig, [{
        type: Injectable
      }], null, null);
    })();
    HammerGesturesPlugin = class _HammerGesturesPlugin extends EventManagerPlugin {
      _config;
      _injector;
      loader;
      _loaderPromise = null;
      constructor(doc, _config, _injector, loader) {
        super(doc);
        this._config = _config;
        this._injector = _injector;
        this.loader = loader;
      }
      supports(eventName) {
        if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
          return false;
        }
        if (!window.Hammer && !this.loader) {
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            const _console = this._injector.get(Console);
            _console.warn(`The "${eventName}" event cannot be bound because Hammer.JS is not loaded and no custom loader has been specified.`);
          }
          return false;
        }
        return true;
      }
      addEventListener(element, eventName, handler) {
        const zone = this.manager.getZone();
        eventName = eventName.toLowerCase();
        if (!window.Hammer && this.loader) {
          this._loaderPromise = this._loaderPromise || zone.runOutsideAngular(() => this.loader());
          let cancelRegistration = false;
          let deregister = () => {
            cancelRegistration = true;
          };
          zone.runOutsideAngular(() => this._loaderPromise.then(() => {
            if (!window.Hammer) {
              if (typeof ngDevMode === "undefined" || ngDevMode) {
                const _console = this._injector.get(Console);
                _console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);
              }
              deregister = () => {
              };
              return;
            }
            if (!cancelRegistration) {
              deregister = this.addEventListener(element, eventName, handler);
            }
          }).catch(() => {
            if (typeof ngDevMode === "undefined" || ngDevMode) {
              const _console = this._injector.get(Console);
              _console.warn(`The "${eventName}" event cannot be bound because the custom Hammer.JS loader failed.`);
            }
            deregister = () => {
            };
          }));
          return () => {
            deregister();
          };
        }
        return zone.runOutsideAngular(() => {
          const mc2 = this._config.buildHammer(element);
          const callback = function(eventObj) {
            zone.runGuarded(function() {
              handler(eventObj);
            });
          };
          mc2.on(eventName, callback);
          return () => {
            mc2.off(eventName, callback);
            if (typeof mc2.destroy === "function") {
              mc2.destroy();
            }
          };
        });
      }
      isCustomEvent(eventName) {
        return this._config.events.indexOf(eventName) > -1;
      }
      static \u0275fac = function HammerGesturesPlugin_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HammerGesturesPlugin)(\u0275\u0275inject(DOCUMENT), \u0275\u0275inject(HAMMER_GESTURE_CONFIG), \u0275\u0275inject(Injector), \u0275\u0275inject(HAMMER_LOADER, 8));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _HammerGesturesPlugin,
        factory: _HammerGesturesPlugin.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerGesturesPlugin, [{
        type: Injectable
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DOCUMENT]
        }]
      }, {
        type: HammerGestureConfig,
        decorators: [{
          type: Inject,
          args: [HAMMER_GESTURE_CONFIG]
        }]
      }, {
        type: Injector
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [HAMMER_LOADER]
        }]
      }], null);
    })();
    HammerModule = class _HammerModule {
      static \u0275fac = function HammerModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HammerModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _HammerModule
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
        providers: [{
          provide: EVENT_MANAGER_PLUGINS,
          useClass: HammerGesturesPlugin,
          multi: true,
          deps: [DOCUMENT, HAMMER_GESTURE_CONFIG, Injector, [new Optional(), HAMMER_LOADER]]
        }, {
          provide: HAMMER_GESTURE_CONFIG,
          useClass: HammerGestureConfig
        }]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerModule, [{
        type: NgModule,
        args: [{
          providers: [{
            provide: EVENT_MANAGER_PLUGINS,
            useClass: HammerGesturesPlugin,
            multi: true,
            deps: [DOCUMENT, HAMMER_GESTURE_CONFIG, Injector, [new Optional(), HAMMER_LOADER]]
          }, {
            provide: HAMMER_GESTURE_CONFIG,
            useClass: HammerGestureConfig
          }]
        }]
      }], null, null);
    })();
    DomSanitizer = class _DomSanitizer {
      static \u0275fac = function DomSanitizer_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DomSanitizer)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _DomSanitizer,
        factory: function DomSanitizer_Factory(__ngFactoryType__) {
          let __ngConditionalFactory__ = null;
          if (__ngFactoryType__) {
            __ngConditionalFactory__ = new (__ngFactoryType__ || _DomSanitizer)();
          } else {
            __ngConditionalFactory__ = \u0275\u0275inject(DomSanitizerImpl);
          }
          return __ngConditionalFactory__;
        },
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomSanitizer, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useExisting: forwardRef(() => DomSanitizerImpl)
        }]
      }], null, null);
    })();
    DomSanitizerImpl = class _DomSanitizerImpl extends DomSanitizer {
      _doc;
      constructor(_doc) {
        super();
        this._doc = _doc;
      }
      sanitize(ctx, value) {
        if (value == null) return null;
        switch (ctx) {
          case SecurityContext.NONE:
            return value;
          case SecurityContext.HTML:
            if (allowSanitizationBypassAndThrow(
              value,
              "HTML"
              /* BypassType.Html */
            )) {
              return unwrapSafeValue(value);
            }
            return _sanitizeHtml(this._doc, String(value)).toString();
          case SecurityContext.STYLE:
            if (allowSanitizationBypassAndThrow(
              value,
              "Style"
              /* BypassType.Style */
            )) {
              return unwrapSafeValue(value);
            }
            return value;
          case SecurityContext.SCRIPT:
            if (allowSanitizationBypassAndThrow(
              value,
              "Script"
              /* BypassType.Script */
            )) {
              return unwrapSafeValue(value);
            }
            throw new RuntimeError(5200, (typeof ngDevMode === "undefined" || ngDevMode) && "unsafe value used in a script context");
          case SecurityContext.URL:
            if (allowSanitizationBypassAndThrow(
              value,
              "URL"
              /* BypassType.Url */
            )) {
              return unwrapSafeValue(value);
            }
            return _sanitizeUrl(String(value));
          case SecurityContext.RESOURCE_URL:
            if (allowSanitizationBypassAndThrow(
              value,
              "ResourceURL"
              /* BypassType.ResourceUrl */
            )) {
              return unwrapSafeValue(value);
            }
            throw new RuntimeError(5201, (typeof ngDevMode === "undefined" || ngDevMode) && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);
          default:
            throw new RuntimeError(5202, (typeof ngDevMode === "undefined" || ngDevMode) && `Unexpected SecurityContext ${ctx} (see ${XSS_SECURITY_URL})`);
        }
      }
      bypassSecurityTrustHtml(value) {
        return bypassSanitizationTrustHtml(value);
      }
      bypassSecurityTrustStyle(value) {
        return bypassSanitizationTrustStyle(value);
      }
      bypassSecurityTrustScript(value) {
        return bypassSanitizationTrustScript(value);
      }
      bypassSecurityTrustUrl(value) {
        return bypassSanitizationTrustUrl(value);
      }
      bypassSecurityTrustResourceUrl(value) {
        return bypassSanitizationTrustResourceUrl(value);
      }
      static \u0275fac = function DomSanitizerImpl_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DomSanitizerImpl)(\u0275\u0275inject(DOCUMENT));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _DomSanitizerImpl,
        factory: _DomSanitizerImpl.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomSanitizerImpl, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DOCUMENT]
        }]
      }], null);
    })();
    (function(HydrationFeatureKind2) {
      HydrationFeatureKind2[HydrationFeatureKind2["NoHttpTransferCache"] = 0] = "NoHttpTransferCache";
      HydrationFeatureKind2[HydrationFeatureKind2["HttpTransferCacheOptions"] = 1] = "HttpTransferCacheOptions";
      HydrationFeatureKind2[HydrationFeatureKind2["I18nSupport"] = 2] = "I18nSupport";
      HydrationFeatureKind2[HydrationFeatureKind2["EventReplay"] = 3] = "EventReplay";
      HydrationFeatureKind2[HydrationFeatureKind2["IncrementalHydration"] = 4] = "IncrementalHydration";
    })(HydrationFeatureKind || (HydrationFeatureKind = {}));
    VERSION3 = new Version("20.1.7");
  }
});

// node_modules/@angular/router/fesm2022/router2.mjs
function convertToParamMap(params) {
  return new ParamsAsMap(params);
}
function defaultUrlMatcher(segments, segmentGroup, route) {
  const parts = route.path.split("/");
  if (parts.length > segments.length) {
    return null;
  }
  if (route.pathMatch === "full" && (segmentGroup.hasChildren() || parts.length < segments.length)) {
    return null;
  }
  const posParams = {};
  for (let index = 0; index < parts.length; index++) {
    const part = parts[index];
    const segment = segments[index];
    const isParameter = part[0] === ":";
    if (isParameter) {
      posParams[part.substring(1)] = segment;
    } else if (part !== segment.path) {
      return null;
    }
  }
  return {
    consumed: segments.slice(0, parts.length),
    posParams
  };
}
function shallowEqualArrays(a2, b2) {
  if (a2.length !== b2.length) return false;
  for (let i2 = 0; i2 < a2.length; ++i2) {
    if (!shallowEqual(a2[i2], b2[i2])) return false;
  }
  return true;
}
function shallowEqual(a2, b2) {
  const k1 = a2 ? getDataKeys(a2) : void 0;
  const k2 = b2 ? getDataKeys(b2) : void 0;
  if (!k1 || !k2 || k1.length != k2.length) {
    return false;
  }
  let key;
  for (let i2 = 0; i2 < k1.length; i2++) {
    key = k1[i2];
    if (!equalArraysOrString(a2[key], b2[key])) {
      return false;
    }
  }
  return true;
}
function getDataKeys(obj) {
  return [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];
}
function equalArraysOrString(a2, b2) {
  if (Array.isArray(a2) && Array.isArray(b2)) {
    if (a2.length !== b2.length) return false;
    const aSorted = [...a2].sort();
    const bSorted = [...b2].sort();
    return aSorted.every((val, index) => bSorted[index] === val);
  } else {
    return a2 === b2;
  }
}
function last3(a2) {
  return a2.length > 0 ? a2[a2.length - 1] : null;
}
function wrapIntoObservable(value) {
  if (isObservable(value)) {
    return value;
  }
  if (isPromise2(value)) {
    return from(Promise.resolve(value));
  }
  return of(value);
}
function containsTree(container, containee, options) {
  return pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) && paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) && !(options.fragment === "exact" && container.fragment !== containee.fragment);
}
function equalParams(container, containee) {
  return shallowEqual(container, containee);
}
function equalSegmentGroups(container, containee, matrixParams) {
  if (!equalPath(container.segments, containee.segments)) return false;
  if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {
    return false;
  }
  if (container.numberOfChildren !== containee.numberOfChildren) return false;
  for (const c2 in containee.children) {
    if (!container.children[c2]) return false;
    if (!equalSegmentGroups(container.children[c2], containee.children[c2], matrixParams)) return false;
  }
  return true;
}
function containsParams(container, containee) {
  return Object.keys(containee).length <= Object.keys(container).length && Object.keys(containee).every((key) => equalArraysOrString(container[key], containee[key]));
}
function containsSegmentGroup(container, containee, matrixParams) {
  return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);
}
function containsSegmentGroupHelper(container, containee, containeePaths, matrixParams) {
  if (container.segments.length > containeePaths.length) {
    const current = container.segments.slice(0, containeePaths.length);
    if (!equalPath(current, containeePaths)) return false;
    if (containee.hasChildren()) return false;
    if (!matrixParamsMatch(current, containeePaths, matrixParams)) return false;
    return true;
  } else if (container.segments.length === containeePaths.length) {
    if (!equalPath(container.segments, containeePaths)) return false;
    if (!matrixParamsMatch(container.segments, containeePaths, matrixParams)) return false;
    for (const c2 in containee.children) {
      if (!container.children[c2]) return false;
      if (!containsSegmentGroup(container.children[c2], containee.children[c2], matrixParams)) {
        return false;
      }
    }
    return true;
  } else {
    const current = containeePaths.slice(0, container.segments.length);
    const next = containeePaths.slice(container.segments.length);
    if (!equalPath(container.segments, current)) return false;
    if (!matrixParamsMatch(container.segments, current, matrixParams)) return false;
    if (!container.children[PRIMARY_OUTLET]) return false;
    return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next, matrixParams);
  }
}
function matrixParamsMatch(containerPaths, containeePaths, options) {
  return containeePaths.every((containeeSegment, i2) => {
    return paramCompareMap[options](containerPaths[i2].parameters, containeeSegment.parameters);
  });
}
function equalSegments(as2, bs2) {
  return equalPath(as2, bs2) && as2.every((a2, i2) => shallowEqual(a2.parameters, bs2[i2].parameters));
}
function equalPath(as2, bs2) {
  if (as2.length !== bs2.length) return false;
  return as2.every((a2, i2) => a2.path === bs2[i2].path);
}
function mapChildrenIntoArray(segment, fn) {
  let res = [];
  Object.entries(segment.children).forEach(([childOutlet, child]) => {
    if (childOutlet === PRIMARY_OUTLET) {
      res = res.concat(fn(child, childOutlet));
    }
  });
  Object.entries(segment.children).forEach(([childOutlet, child]) => {
    if (childOutlet !== PRIMARY_OUTLET) {
      res = res.concat(fn(child, childOutlet));
    }
  });
  return res;
}
function serializePaths(segment) {
  return segment.segments.map((p2) => serializePath(p2)).join("/");
}
function serializeSegment(segment, root) {
  if (!segment.hasChildren()) {
    return serializePaths(segment);
  }
  if (root) {
    const primary = segment.children[PRIMARY_OUTLET] ? serializeSegment(segment.children[PRIMARY_OUTLET], false) : "";
    const children = [];
    Object.entries(segment.children).forEach(([k2, v]) => {
      if (k2 !== PRIMARY_OUTLET) {
        children.push(`${k2}:${serializeSegment(v, false)}`);
      }
    });
    return children.length > 0 ? `${primary}(${children.join("//")})` : primary;
  } else {
    const children = mapChildrenIntoArray(segment, (v, k2) => {
      if (k2 === PRIMARY_OUTLET) {
        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];
      }
      return [`${k2}:${serializeSegment(v, false)}`];
    });
    if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {
      return `${serializePaths(segment)}/${children[0]}`;
    }
    return `${serializePaths(segment)}/(${children.join("//")})`;
  }
}
function encodeUriString(s2) {
  return encodeURIComponent(s2).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",");
}
function encodeUriQuery(s2) {
  return encodeUriString(s2).replace(/%3B/gi, ";");
}
function encodeUriFragment(s2) {
  return encodeURI(s2);
}
function encodeUriSegment(s2) {
  return encodeUriString(s2).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&");
}
function decode(s2) {
  return decodeURIComponent(s2);
}
function decodeQuery(s2) {
  return decode(s2.replace(/\+/g, "%20"));
}
function serializePath(path) {
  return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;
}
function serializeMatrixParams(params) {
  return Object.entries(params).map(([key, value]) => `;${encodeUriSegment(key)}=${encodeUriSegment(value)}`).join("");
}
function serializeQueryParams(params) {
  const strParams = Object.entries(params).map(([name, value]) => {
    return Array.isArray(value) ? value.map((v) => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join("&") : `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;
  }).filter((s2) => s2);
  return strParams.length ? `?${strParams.join("&")}` : "";
}
function matchSegments(str) {
  const match2 = str.match(SEGMENT_RE);
  return match2 ? match2[0] : "";
}
function matchMatrixKeySegments(str) {
  const match2 = str.match(MATRIX_PARAM_SEGMENT_RE);
  return match2 ? match2[0] : "";
}
function matchQueryParams(str) {
  const match2 = str.match(QUERY_PARAM_RE);
  return match2 ? match2[0] : "";
}
function matchUrlQueryParamValue(str) {
  const match2 = str.match(QUERY_PARAM_VALUE_RE);
  return match2 ? match2[0] : "";
}
function createRoot(rootCandidate) {
  return rootCandidate.segments.length > 0 ? new UrlSegmentGroup([], {
    [PRIMARY_OUTLET]: rootCandidate
  }) : rootCandidate;
}
function squashSegmentGroup(segmentGroup) {
  const newChildren = {};
  for (const [childOutlet, child] of Object.entries(segmentGroup.children)) {
    const childCandidate = squashSegmentGroup(child);
    if (childOutlet === PRIMARY_OUTLET && childCandidate.segments.length === 0 && childCandidate.hasChildren()) {
      for (const [grandChildOutlet, grandChild] of Object.entries(childCandidate.children)) {
        newChildren[grandChildOutlet] = grandChild;
      }
    } else if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {
      newChildren[childOutlet] = childCandidate;
    }
  }
  const s2 = new UrlSegmentGroup(segmentGroup.segments, newChildren);
  return mergeTrivialChildren(s2);
}
function mergeTrivialChildren(s2) {
  if (s2.numberOfChildren === 1 && s2.children[PRIMARY_OUTLET]) {
    const c2 = s2.children[PRIMARY_OUTLET];
    return new UrlSegmentGroup(s2.segments.concat(c2.segments), c2.children);
  }
  return s2;
}
function isUrlTree(v) {
  return v instanceof UrlTree;
}
function createUrlTreeFromSnapshot(relativeTo, commands, queryParams = null, fragment = null) {
  const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);
  return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment);
}
function createSegmentGroupFromRoute(route) {
  let targetGroup;
  function createSegmentGroupFromRouteRecursive(currentRoute) {
    const childOutlets = {};
    for (const childSnapshot of currentRoute.children) {
      const root = createSegmentGroupFromRouteRecursive(childSnapshot);
      childOutlets[childSnapshot.outlet] = root;
    }
    const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);
    if (currentRoute === route) {
      targetGroup = segmentGroup;
    }
    return segmentGroup;
  }
  const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);
  const rootSegmentGroup = createRoot(rootCandidate);
  return targetGroup ?? rootSegmentGroup;
}
function createUrlTreeFromSegmentGroup(relativeTo, commands, queryParams, fragment) {
  let root = relativeTo;
  while (root.parent) {
    root = root.parent;
  }
  if (commands.length === 0) {
    return tree(root, root, root, queryParams, fragment);
  }
  const nav = computeNavigation(commands);
  if (nav.toRoot()) {
    return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment);
  }
  const position = findStartingPositionForTargetGroup(nav, root, relativeTo);
  const newSegmentGroup = position.processChildren ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands) : updateSegmentGroup(position.segmentGroup, position.index, nav.commands);
  return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment);
}
function isMatrixParams(command) {
  return typeof command === "object" && command != null && !command.outlets && !command.segmentPath;
}
function isCommandWithOutlets(command) {
  return typeof command === "object" && command != null && command.outlets;
}
function tree(oldRoot, oldSegmentGroup, newSegmentGroup, queryParams, fragment) {
  let qp = {};
  if (queryParams) {
    Object.entries(queryParams).forEach(([name, value]) => {
      qp[name] = Array.isArray(value) ? value.map((v) => `${v}`) : `${value}`;
    });
  }
  let rootCandidate;
  if (oldRoot === oldSegmentGroup) {
    rootCandidate = newSegmentGroup;
  } else {
    rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);
  }
  const newRoot = createRoot(squashSegmentGroup(rootCandidate));
  return new UrlTree(newRoot, qp, fragment);
}
function replaceSegment(current, oldSegment, newSegment) {
  const children = {};
  Object.entries(current.children).forEach(([outletName, c2]) => {
    if (c2 === oldSegment) {
      children[outletName] = newSegment;
    } else {
      children[outletName] = replaceSegment(c2, oldSegment, newSegment);
    }
  });
  return new UrlSegmentGroup(current.segments, children);
}
function computeNavigation(commands) {
  if (typeof commands[0] === "string" && commands.length === 1 && commands[0] === "/") {
    return new Navigation(true, 0, commands);
  }
  let numberOfDoubleDots = 0;
  let isAbsolute = false;
  const res = commands.reduce((res2, cmd, cmdIdx) => {
    if (typeof cmd === "object" && cmd != null) {
      if (cmd.outlets) {
        const outlets = {};
        Object.entries(cmd.outlets).forEach(([name, commands2]) => {
          outlets[name] = typeof commands2 === "string" ? commands2.split("/") : commands2;
        });
        return [...res2, {
          outlets
        }];
      }
      if (cmd.segmentPath) {
        return [...res2, cmd.segmentPath];
      }
    }
    if (!(typeof cmd === "string")) {
      return [...res2, cmd];
    }
    if (cmdIdx === 0) {
      cmd.split("/").forEach((urlPart, partIndex) => {
        if (partIndex == 0 && urlPart === ".") ;
        else if (partIndex == 0 && urlPart === "") {
          isAbsolute = true;
        } else if (urlPart === "..") {
          numberOfDoubleDots++;
        } else if (urlPart != "") {
          res2.push(urlPart);
        }
      });
      return res2;
    }
    return [...res2, cmd];
  }, []);
  return new Navigation(isAbsolute, numberOfDoubleDots, res);
}
function findStartingPositionForTargetGroup(nav, root, target) {
  if (nav.isAbsolute) {
    return new Position(root, true, 0);
  }
  if (!target) {
    return new Position(root, false, NaN);
  }
  if (target.parent === null) {
    return new Position(target, true, 0);
  }
  const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;
  const index = target.segments.length - 1 + modifier;
  return createPositionApplyingDoubleDots(target, index, nav.numberOfDoubleDots);
}
function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {
  let g2 = group;
  let ci2 = index;
  let dd2 = numberOfDoubleDots;
  while (dd2 > ci2) {
    dd2 -= ci2;
    g2 = g2.parent;
    if (!g2) {
      throw new RuntimeError(4005, (typeof ngDevMode === "undefined" || ngDevMode) && "Invalid number of '../'");
    }
    ci2 = g2.segments.length;
  }
  return new Position(g2, false, ci2 - dd2);
}
function getOutlets(commands) {
  if (isCommandWithOutlets(commands[0])) {
    return commands[0].outlets;
  }
  return {
    [PRIMARY_OUTLET]: commands
  };
}
function updateSegmentGroup(segmentGroup, startIndex, commands) {
  segmentGroup ??= new UrlSegmentGroup([], {});
  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);
  }
  const m = prefixedWith(segmentGroup, startIndex, commands);
  const slicedCommands = commands.slice(m.commandIndex);
  if (m.match && m.pathIndex < segmentGroup.segments.length) {
    const g2 = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});
    g2.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);
    return updateSegmentGroupChildren(g2, 0, slicedCommands);
  } else if (m.match && slicedCommands.length === 0) {
    return new UrlSegmentGroup(segmentGroup.segments, {});
  } else if (m.match && !segmentGroup.hasChildren()) {
    return createNewSegmentGroup(segmentGroup, startIndex, commands);
  } else if (m.match) {
    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);
  } else {
    return createNewSegmentGroup(segmentGroup, startIndex, commands);
  }
}
function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {
  if (commands.length === 0) {
    return new UrlSegmentGroup(segmentGroup.segments, {});
  } else {
    const outlets = getOutlets(commands);
    const children = {};
    if (Object.keys(outlets).some((o2) => o2 !== PRIMARY_OUTLET) && segmentGroup.children[PRIMARY_OUTLET] && segmentGroup.numberOfChildren === 1 && segmentGroup.children[PRIMARY_OUTLET].segments.length === 0) {
      const childrenOfEmptyChild = updateSegmentGroupChildren(segmentGroup.children[PRIMARY_OUTLET], startIndex, commands);
      return new UrlSegmentGroup(segmentGroup.segments, childrenOfEmptyChild.children);
    }
    Object.entries(outlets).forEach(([outlet, commands2]) => {
      if (typeof commands2 === "string") {
        commands2 = [commands2];
      }
      if (commands2 !== null) {
        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands2);
      }
    });
    Object.entries(segmentGroup.children).forEach(([childOutlet, child]) => {
      if (outlets[childOutlet] === void 0) {
        children[childOutlet] = child;
      }
    });
    return new UrlSegmentGroup(segmentGroup.segments, children);
  }
}
function prefixedWith(segmentGroup, startIndex, commands) {
  let currentCommandIndex = 0;
  let currentPathIndex = startIndex;
  const noMatch2 = {
    match: false,
    pathIndex: 0,
    commandIndex: 0
  };
  while (currentPathIndex < segmentGroup.segments.length) {
    if (currentCommandIndex >= commands.length) return noMatch2;
    const path = segmentGroup.segments[currentPathIndex];
    const command = commands[currentCommandIndex];
    if (isCommandWithOutlets(command)) {
      break;
    }
    const curr = `${command}`;
    const next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;
    if (currentPathIndex > 0 && curr === void 0) break;
    if (curr && next && typeof next === "object" && next.outlets === void 0) {
      if (!compare(curr, next, path)) return noMatch2;
      currentCommandIndex += 2;
    } else {
      if (!compare(curr, {}, path)) return noMatch2;
      currentCommandIndex++;
    }
    currentPathIndex++;
  }
  return {
    match: true,
    pathIndex: currentPathIndex,
    commandIndex: currentCommandIndex
  };
}
function createNewSegmentGroup(segmentGroup, startIndex, commands) {
  const paths = segmentGroup.segments.slice(0, startIndex);
  let i2 = 0;
  while (i2 < commands.length) {
    const command = commands[i2];
    if (isCommandWithOutlets(command)) {
      const children = createNewSegmentChildren(command.outlets);
      return new UrlSegmentGroup(paths, children);
    }
    if (i2 === 0 && isMatrixParams(commands[0])) {
      const p2 = segmentGroup.segments[startIndex];
      paths.push(new UrlSegment(p2.path, stringify2(commands[0])));
      i2++;
      continue;
    }
    const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;
    const next = i2 < commands.length - 1 ? commands[i2 + 1] : null;
    if (curr && next && isMatrixParams(next)) {
      paths.push(new UrlSegment(curr, stringify2(next)));
      i2 += 2;
    } else {
      paths.push(new UrlSegment(curr, {}));
      i2++;
    }
  }
  return new UrlSegmentGroup(paths, {});
}
function createNewSegmentChildren(outlets) {
  const children = {};
  Object.entries(outlets).forEach(([outlet, commands]) => {
    if (typeof commands === "string") {
      commands = [commands];
    }
    if (commands !== null) {
      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);
    }
  });
  return children;
}
function stringify2(params) {
  const res = {};
  Object.entries(params).forEach(([k2, v]) => res[k2] = `${v}`);
  return res;
}
function compare(path, params, segment) {
  return path == segment.path && shallowEqual(params, segment.parameters);
}
function isPublicRouterEvent(e2) {
  return !(e2 instanceof BeforeActivateRoutes) && !(e2 instanceof RedirectRequest);
}
function stringifyEvent(routerEvent) {
  switch (routerEvent.type) {
    case EventType.ActivationEnd:
      return `ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.ActivationStart:
      return `ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.ChildActivationEnd:
      return `ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.ChildActivationStart:
      return `ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.GuardsCheckEnd:
      return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;
    case EventType.GuardsCheckStart:
      return `GuardsCheckStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.NavigationCancel:
      return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.NavigationSkipped:
      return `NavigationSkipped(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.NavigationEnd:
      return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}')`;
    case EventType.NavigationError:
      return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${routerEvent.error})`;
    case EventType.NavigationStart:
      return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.ResolveEnd:
      return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.ResolveStart:
      return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.RouteConfigLoadEnd:
      return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;
    case EventType.RouteConfigLoadStart:
      return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;
    case EventType.RoutesRecognized:
      return `RoutesRecognized(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.Scroll:
      const pos = routerEvent.position ? `${routerEvent.position[0]}, ${routerEvent.position[1]}` : null;
      return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;
  }
}
function getOrCreateRouteInjectorIfNeeded(route, currentInjector) {
  if (route.providers && !route._injector) {
    route._injector = createEnvironmentInjector(route.providers, currentInjector, `Route: ${route.path}`);
  }
  return route._injector ?? currentInjector;
}
function validateConfig(config2, parentPath = "", requireStandaloneComponents = false) {
  for (let i2 = 0; i2 < config2.length; i2++) {
    const route = config2[i2];
    const fullPath = getFullPath(parentPath, route);
    validateNode(route, fullPath, requireStandaloneComponents);
  }
}
function assertStandalone(fullPath, component) {
  if (component && isNgModule(component)) {
    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. You are using 'loadComponent' with a module, but it must be used with standalone components. Use 'loadChildren' instead.`);
  } else if (component && !isStandalone(component)) {
    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. The component must be standalone.`);
  }
}
function validateNode(route, fullPath, requireStandaloneComponents) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (!route) {
      throw new RuntimeError(4014, `
      Invalid configuration of route '${fullPath}': Encountered undefined route.
      The reason might be an extra comma.

      Example:
      const routes: Routes = [
        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },
        { path: 'dashboard',  component: DashboardComponent },, << two commas
        { path: 'detail/:id', component: HeroDetailComponent }
      ];
    `);
    }
    if (Array.isArray(route)) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': Array cannot be specified`);
    }
    if (!route.redirectTo && !route.component && !route.loadComponent && !route.children && !route.loadChildren && route.outlet && route.outlet !== PRIMARY_OUTLET) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);
    }
    if (route.redirectTo && route.children) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);
    }
    if (route.redirectTo && route.loadChildren) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);
    }
    if (route.children && route.loadChildren) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);
    }
    if (route.component && route.loadComponent) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': component and loadComponent cannot be used together`);
    }
    if (route.redirectTo) {
      if (route.component || route.loadComponent) {
        throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and component/loadComponent cannot be used together`);
      }
      if (route.canMatch || route.canActivate) {
        throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and ${route.canMatch ? "canMatch" : "canActivate"} cannot be used together.Redirects happen before guards are executed.`);
      }
    }
    if (route.path && route.matcher) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);
    }
    if (route.redirectTo === void 0 && !route.component && !route.loadComponent && !route.children && !route.loadChildren) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`);
    }
    if (route.path === void 0 && route.matcher === void 0) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);
    }
    if (typeof route.path === "string" && route.path.charAt(0) === "/") {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': path cannot start with a slash`);
    }
    if (route.path === "" && route.redirectTo !== void 0 && route.pathMatch === void 0) {
      const exp = `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;
      throw new RuntimeError(4014, `Invalid configuration of route '{path: "${fullPath}", redirectTo: "${route.redirectTo}"}': please provide 'pathMatch'. ${exp}`);
    }
    if (requireStandaloneComponents) {
      assertStandalone(fullPath, route.component);
    }
  }
  if (route.children) {
    validateConfig(route.children, fullPath, requireStandaloneComponents);
  }
}
function getFullPath(parentPath, currentRoute) {
  if (!currentRoute) {
    return parentPath;
  }
  if (!parentPath && !currentRoute.path) {
    return "";
  } else if (parentPath && !currentRoute.path) {
    return `${parentPath}/`;
  } else if (!parentPath && currentRoute.path) {
    return currentRoute.path;
  } else {
    return `${parentPath}/${currentRoute.path}`;
  }
}
function getOutlet(route) {
  return route.outlet || PRIMARY_OUTLET;
}
function sortByMatchingOutlets(routes2, outletName) {
  const sortedConfig = routes2.filter((r2) => getOutlet(r2) === outletName);
  sortedConfig.push(...routes2.filter((r2) => getOutlet(r2) !== outletName));
  return sortedConfig;
}
function getClosestRouteInjector(snapshot) {
  if (!snapshot) return null;
  if (snapshot.routeConfig?._injector) {
    return snapshot.routeConfig._injector;
  }
  for (let s2 = snapshot.parent; s2; s2 = s2.parent) {
    const route = s2.routeConfig;
    if (route?._loadedInjector) return route._loadedInjector;
    if (route?._injector) return route._injector;
  }
  return null;
}
function findNode(value, node) {
  if (value === node.value) return node;
  for (const child of node.children) {
    const node2 = findNode(value, child);
    if (node2) return node2;
  }
  return null;
}
function findPath(value, node) {
  if (value === node.value) return [node];
  for (const child of node.children) {
    const path = findPath(value, child);
    if (path.length) {
      path.unshift(node);
      return path;
    }
  }
  return [];
}
function nodeChildrenAsMap(node) {
  const map2 = {};
  if (node) {
    node.children.forEach((child) => map2[child.value.outlet] = child);
  }
  return map2;
}
function createEmptyState(rootComponent) {
  const snapshot = createEmptyStateSnapshot(rootComponent);
  const emptyUrl = new BehaviorSubject([new UrlSegment("", {})]);
  const emptyParams = new BehaviorSubject({});
  const emptyData = new BehaviorSubject({});
  const emptyQueryParams = new BehaviorSubject({});
  const fragment = new BehaviorSubject("");
  const activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);
  activated.snapshot = snapshot.root;
  return new RouterState(new TreeNode(activated, []), snapshot);
}
function createEmptyStateSnapshot(rootComponent) {
  const emptyParams = {};
  const emptyData = {};
  const emptyQueryParams = {};
  const fragment = "";
  const activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, {});
  return new RouterStateSnapshot("", new TreeNode(activated, []));
}
function getInherited(route, parent, paramsInheritanceStrategy = "emptyOnly") {
  let inherited;
  const {
    routeConfig
  } = route;
  if (parent !== null && (paramsInheritanceStrategy === "always" || // inherit parent data if route is empty path
  routeConfig?.path === "" || // inherit parent data if parent was componentless
  !parent.component && !parent.routeConfig?.loadComponent)) {
    inherited = {
      params: __spreadValues(__spreadValues({}, parent.params), route.params),
      data: __spreadValues(__spreadValues({}, parent.data), route.data),
      resolve: __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, route.data), parent.data), routeConfig?.data), route._resolvedData)
    };
  } else {
    inherited = {
      params: __spreadValues({}, route.params),
      data: __spreadValues({}, route.data),
      resolve: __spreadValues(__spreadValues({}, route.data), route._resolvedData ?? {})
    };
  }
  if (routeConfig && hasStaticTitle(routeConfig)) {
    inherited.resolve[RouteTitleKey] = routeConfig.title;
  }
  return inherited;
}
function setRouterState(state, node) {
  node.value._routerState = state;
  node.children.forEach((c2) => setRouterState(state, c2));
}
function serializeNode(node) {
  const c2 = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(", ")} } ` : "";
  return `${node.value}${c2}`;
}
function advanceActivatedRoute(route) {
  if (route.snapshot) {
    const currentSnapshot = route.snapshot;
    const nextSnapshot = route._futureSnapshot;
    route.snapshot = nextSnapshot;
    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {
      route.queryParamsSubject.next(nextSnapshot.queryParams);
    }
    if (currentSnapshot.fragment !== nextSnapshot.fragment) {
      route.fragmentSubject.next(nextSnapshot.fragment);
    }
    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {
      route.paramsSubject.next(nextSnapshot.params);
    }
    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {
      route.urlSubject.next(nextSnapshot.url);
    }
    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {
      route.dataSubject.next(nextSnapshot.data);
    }
  } else {
    route.snapshot = route._futureSnapshot;
    route.dataSubject.next(route._futureSnapshot.data);
  }
}
function equalParamsAndUrlSegments(a2, b2) {
  const equalUrlParams = shallowEqual(a2.params, b2.params) && equalSegments(a2.url, b2.url);
  const parentsMismatch = !a2.parent !== !b2.parent;
  return equalUrlParams && !parentsMismatch && (!a2.parent || equalParamsAndUrlSegments(a2.parent, b2.parent));
}
function hasStaticTitle(config2) {
  return typeof config2.title === "string" || config2.title === null;
}
function standardizeConfig(r2) {
  const children = r2.children && r2.children.map(standardizeConfig);
  const c2 = children ? __spreadProps(__spreadValues({}, r2), {
    children
  }) : __spreadValues({}, r2);
  if (!c2.component && !c2.loadComponent && (children || c2.loadChildren) && c2.outlet && c2.outlet !== PRIMARY_OUTLET) {
    c2.component = \u0275EmptyOutletComponent;
  }
  return c2;
}
function createRouterState(routeReuseStrategy, curr, prevState) {
  const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : void 0);
  return new RouterState(root, curr);
}
function createNode(routeReuseStrategy, curr, prevState) {
  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {
    const value = prevState.value;
    value._futureSnapshot = curr.value;
    const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);
    return new TreeNode(value, children);
  } else {
    if (routeReuseStrategy.shouldAttach(curr.value)) {
      const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);
      if (detachedRouteHandle !== null) {
        const tree2 = detachedRouteHandle.route;
        tree2.value._futureSnapshot = curr.value;
        tree2.children = curr.children.map((c2) => createNode(routeReuseStrategy, c2));
        return tree2;
      }
    }
    const value = createActivatedRoute(curr.value);
    const children = curr.children.map((c2) => createNode(routeReuseStrategy, c2));
    return new TreeNode(value, children);
  }
}
function createOrReuseChildren(routeReuseStrategy, curr, prevState) {
  return curr.children.map((child) => {
    for (const p2 of prevState.children) {
      if (routeReuseStrategy.shouldReuseRoute(child.value, p2.value.snapshot)) {
        return createNode(routeReuseStrategy, child, p2);
      }
    }
    return createNode(routeReuseStrategy, child);
  });
}
function createActivatedRoute(c2) {
  return new ActivatedRoute(new BehaviorSubject(c2.url), new BehaviorSubject(c2.params), new BehaviorSubject(c2.queryParams), new BehaviorSubject(c2.fragment), new BehaviorSubject(c2.data), c2.outlet, c2.component, c2);
}
function redirectingNavigationError(urlSerializer, redirect) {
  const {
    redirectTo,
    navigationBehaviorOptions
  } = isUrlTree(redirect) ? {
    redirectTo: redirect,
    navigationBehaviorOptions: void 0
  } : redirect;
  const error = navigationCancelingError(ngDevMode && `Redirecting to "${urlSerializer.serialize(redirectTo)}"`, NavigationCancellationCode.Redirect);
  error.url = redirectTo;
  error.navigationBehaviorOptions = navigationBehaviorOptions;
  return error;
}
function navigationCancelingError(message, code) {
  const error = new Error(`NavigationCancelingError: ${message || ""}`);
  error[NAVIGATION_CANCELING_ERROR] = true;
  error.cancellationCode = code;
  return error;
}
function isRedirectingNavigationCancelingError(error) {
  return isNavigationCancelingError(error) && isUrlTree(error.url);
}
function isNavigationCancelingError(error) {
  return !!error && error[NAVIGATION_CANCELING_ERROR];
}
function getAllRouteGuards(future, curr, parentContexts) {
  const futureRoot = future._root;
  const currRoot = curr ? curr._root : null;
  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);
}
function getCanActivateChild(p2) {
  const canActivateChild = p2.routeConfig ? p2.routeConfig.canActivateChild : null;
  if (!canActivateChild || canActivateChild.length === 0) return null;
  return {
    node: p2,
    guards: canActivateChild
  };
}
function getTokenOrFunctionIdentity(tokenOrFunction, injector) {
  const NOT_FOUND3 = Symbol();
  const result = injector.get(tokenOrFunction, NOT_FOUND3);
  if (result === NOT_FOUND3) {
    if (typeof tokenOrFunction === "function" && !isInjectable(tokenOrFunction)) {
      return tokenOrFunction;
    } else {
      return injector.get(tokenOrFunction);
    }
  }
  return result;
}
function getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks = {
  canDeactivateChecks: [],
  canActivateChecks: []
}) {
  const prevChildren = nodeChildrenAsMap(currNode);
  futureNode.children.forEach((c2) => {
    getRouteGuards(c2, prevChildren[c2.value.outlet], contexts, futurePath.concat([c2.value]), checks);
    delete prevChildren[c2.value.outlet];
  });
  Object.entries(prevChildren).forEach(([k2, v]) => deactivateRouteAndItsChildren(v, contexts.getContext(k2), checks));
  return checks;
}
function getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks = {
  canDeactivateChecks: [],
  canActivateChecks: []
}) {
  const future = futureNode.value;
  const curr = currNode ? currNode.value : null;
  const context2 = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;
  if (curr && future.routeConfig === curr.routeConfig) {
    const shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);
    if (shouldRun) {
      checks.canActivateChecks.push(new CanActivate(futurePath));
    } else {
      future.data = curr.data;
      future._resolvedData = curr._resolvedData;
    }
    if (future.component) {
      getChildRouteGuards(futureNode, currNode, context2 ? context2.children : null, futurePath, checks);
    } else {
      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);
    }
    if (shouldRun && context2 && context2.outlet && context2.outlet.isActivated) {
      checks.canDeactivateChecks.push(new CanDeactivate(context2.outlet.component, curr));
    }
  } else {
    if (curr) {
      deactivateRouteAndItsChildren(currNode, context2, checks);
    }
    checks.canActivateChecks.push(new CanActivate(futurePath));
    if (future.component) {
      getChildRouteGuards(futureNode, null, context2 ? context2.children : null, futurePath, checks);
    } else {
      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);
    }
  }
  return checks;
}
function shouldRunGuardsAndResolvers(curr, future, mode) {
  if (typeof mode === "function") {
    return mode(curr, future);
  }
  switch (mode) {
    case "pathParamsChange":
      return !equalPath(curr.url, future.url);
    case "pathParamsOrQueryParamsChange":
      return !equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams);
    case "always":
      return true;
    case "paramsOrQueryParamsChange":
      return !equalParamsAndUrlSegments(curr, future) || !shallowEqual(curr.queryParams, future.queryParams);
    case "paramsChange":
    default:
      return !equalParamsAndUrlSegments(curr, future);
  }
}
function deactivateRouteAndItsChildren(route, context2, checks) {
  const children = nodeChildrenAsMap(route);
  const r2 = route.value;
  Object.entries(children).forEach(([childName, node]) => {
    if (!r2.component) {
      deactivateRouteAndItsChildren(node, context2, checks);
    } else if (context2) {
      deactivateRouteAndItsChildren(node, context2.children.getContext(childName), checks);
    } else {
      deactivateRouteAndItsChildren(node, null, checks);
    }
  });
  if (!r2.component) {
    checks.canDeactivateChecks.push(new CanDeactivate(null, r2));
  } else if (context2 && context2.outlet && context2.outlet.isActivated) {
    checks.canDeactivateChecks.push(new CanDeactivate(context2.outlet.component, r2));
  } else {
    checks.canDeactivateChecks.push(new CanDeactivate(null, r2));
  }
}
function isFunction2(v) {
  return typeof v === "function";
}
function isBoolean(v) {
  return typeof v === "boolean";
}
function isCanLoad(guard) {
  return guard && isFunction2(guard.canLoad);
}
function isCanActivate(guard) {
  return guard && isFunction2(guard.canActivate);
}
function isCanActivateChild(guard) {
  return guard && isFunction2(guard.canActivateChild);
}
function isCanDeactivate(guard) {
  return guard && isFunction2(guard.canDeactivate);
}
function isCanMatch(guard) {
  return guard && isFunction2(guard.canMatch);
}
function isEmptyError(e2) {
  return e2 instanceof EmptyError || e2?.name === "EmptyError";
}
function prioritizedGuardValue() {
  return switchMap((obs) => {
    return combineLatest(obs.map((o2) => o2.pipe(take(1), startWith(INITIAL_VALUE)))).pipe(map((results) => {
      for (const result of results) {
        if (result === true) {
          continue;
        } else if (result === INITIAL_VALUE) {
          return INITIAL_VALUE;
        } else if (result === false || isRedirect(result)) {
          return result;
        }
      }
      return true;
    }), filter((item) => item !== INITIAL_VALUE), take(1));
  });
}
function isRedirect(val) {
  return isUrlTree(val) || val instanceof RedirectCommand;
}
function checkGuards(injector, forwardEvent) {
  return mergeMap((t2) => {
    const {
      targetSnapshot,
      currentSnapshot,
      guards: {
        canActivateChecks,
        canDeactivateChecks
      }
    } = t2;
    if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {
      return of(__spreadProps(__spreadValues({}, t2), {
        guardsResult: true
      }));
    }
    return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, injector).pipe(mergeMap((canDeactivate) => {
      return canDeactivate && isBoolean(canDeactivate) ? runCanActivateChecks(targetSnapshot, canActivateChecks, injector, forwardEvent) : of(canDeactivate);
    }), map((guardsResult) => __spreadProps(__spreadValues({}, t2), {
      guardsResult
    })));
  });
}
function runCanDeactivateChecks(checks, futureRSS, currRSS, injector) {
  return from(checks).pipe(mergeMap((check) => runCanDeactivate(check.component, check.route, currRSS, futureRSS, injector)), first((result) => {
    return result !== true;
  }, true));
}
function runCanActivateChecks(futureSnapshot, checks, injector, forwardEvent) {
  return from(checks).pipe(concatMap((check) => {
    return concat(fireChildActivationStart(check.route.parent, forwardEvent), fireActivationStart(check.route, forwardEvent), runCanActivateChild(futureSnapshot, check.path, injector), runCanActivate(futureSnapshot, check.route, injector));
  }), first((result) => {
    return result !== true;
  }, true));
}
function fireActivationStart(snapshot, forwardEvent) {
  if (snapshot !== null && forwardEvent) {
    forwardEvent(new ActivationStart(snapshot));
  }
  return of(true);
}
function fireChildActivationStart(snapshot, forwardEvent) {
  if (snapshot !== null && forwardEvent) {
    forwardEvent(new ChildActivationStart(snapshot));
  }
  return of(true);
}
function runCanActivate(futureRSS, futureARS, injector) {
  const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;
  if (!canActivate || canActivate.length === 0) return of(true);
  const canActivateObservables = canActivate.map((canActivate2) => {
    return defer(() => {
      const closestInjector = getClosestRouteInjector(futureARS) ?? injector;
      const guard = getTokenOrFunctionIdentity(canActivate2, closestInjector);
      const guardVal = isCanActivate(guard) ? guard.canActivate(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));
      return wrapIntoObservable(guardVal).pipe(first());
    });
  });
  return of(canActivateObservables).pipe(prioritizedGuardValue());
}
function runCanActivateChild(futureRSS, path, injector) {
  const futureARS = path[path.length - 1];
  const canActivateChildGuards = path.slice(0, path.length - 1).reverse().map((p2) => getCanActivateChild(p2)).filter((_2) => _2 !== null);
  const canActivateChildGuardsMapped = canActivateChildGuards.map((d2) => {
    return defer(() => {
      const guardsMapped = d2.guards.map((canActivateChild) => {
        const closestInjector = getClosestRouteInjector(d2.node) ?? injector;
        const guard = getTokenOrFunctionIdentity(canActivateChild, closestInjector);
        const guardVal = isCanActivateChild(guard) ? guard.canActivateChild(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));
        return wrapIntoObservable(guardVal).pipe(first());
      });
      return of(guardsMapped).pipe(prioritizedGuardValue());
    });
  });
  return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());
}
function runCanDeactivate(component, currARS, currRSS, futureRSS, injector) {
  const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;
  if (!canDeactivate || canDeactivate.length === 0) return of(true);
  const canDeactivateObservables = canDeactivate.map((c2) => {
    const closestInjector = getClosestRouteInjector(currARS) ?? injector;
    const guard = getTokenOrFunctionIdentity(c2, closestInjector);
    const guardVal = isCanDeactivate(guard) ? guard.canDeactivate(component, currARS, currRSS, futureRSS) : runInInjectionContext(closestInjector, () => guard(component, currARS, currRSS, futureRSS));
    return wrapIntoObservable(guardVal).pipe(first());
  });
  return of(canDeactivateObservables).pipe(prioritizedGuardValue());
}
function runCanLoadGuards(injector, route, segments, urlSerializer) {
  const canLoad = route.canLoad;
  if (canLoad === void 0 || canLoad.length === 0) {
    return of(true);
  }
  const canLoadObservables = canLoad.map((injectionToken) => {
    const guard = getTokenOrFunctionIdentity(injectionToken, injector);
    const guardVal = isCanLoad(guard) ? guard.canLoad(route, segments) : runInInjectionContext(injector, () => guard(route, segments));
    return wrapIntoObservable(guardVal);
  });
  return of(canLoadObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));
}
function redirectIfUrlTree(urlSerializer) {
  return pipe(tap((result) => {
    if (typeof result === "boolean") return;
    throw redirectingNavigationError(urlSerializer, result);
  }), map((result) => result === true));
}
function runCanMatchGuards(injector, route, segments, urlSerializer) {
  const canMatch = route.canMatch;
  if (!canMatch || canMatch.length === 0) return of(true);
  const canMatchObservables = canMatch.map((injectionToken) => {
    const guard = getTokenOrFunctionIdentity(injectionToken, injector);
    const guardVal = isCanMatch(guard) ? guard.canMatch(route, segments) : runInInjectionContext(injector, () => guard(route, segments));
    return wrapIntoObservable(guardVal);
  });
  return of(canMatchObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));
}
function noMatch$1(segmentGroup) {
  return throwError(new NoMatch(segmentGroup));
}
function namedOutletsRedirect(redirectTo) {
  return throwError(new RuntimeError(4e3, (typeof ngDevMode === "undefined" || ngDevMode) && `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`));
}
function canLoadFails(route) {
  return throwError(navigationCancelingError((typeof ngDevMode === "undefined" || ngDevMode) && `Cannot load children because the guard of the route "path: '${route.path}'" returned false`, NavigationCancellationCode.GuardRejected));
}
function getRedirectResult(redirectTo, currentSnapshot, injector) {
  if (typeof redirectTo === "string") {
    return of(redirectTo);
  }
  const redirectToFn = redirectTo;
  const {
    queryParams,
    fragment,
    routeConfig,
    url,
    outlet,
    params,
    data,
    title
  } = currentSnapshot;
  return wrapIntoObservable(runInInjectionContext(injector, () => redirectToFn({
    params,
    data,
    queryParams,
    fragment,
    routeConfig,
    url,
    outlet,
    title
  })));
}
function matchWithChecks(segmentGroup, route, segments, injector, urlSerializer) {
  const result = match(segmentGroup, route, segments);
  if (!result.matched) {
    return of(result);
  }
  injector = getOrCreateRouteInjectorIfNeeded(route, injector);
  return runCanMatchGuards(injector, route, segments, urlSerializer).pipe(map((v) => v === true ? result : __spreadValues({}, noMatch)));
}
function match(segmentGroup, route, segments) {
  if (route.path === "**") {
    return createWildcardMatchResult(segments);
  }
  if (route.path === "") {
    if (route.pathMatch === "full" && (segmentGroup.hasChildren() || segments.length > 0)) {
      return __spreadValues({}, noMatch);
    }
    return {
      matched: true,
      consumedSegments: [],
      remainingSegments: segments,
      parameters: {},
      positionalParamSegments: {}
    };
  }
  const matcher = route.matcher || defaultUrlMatcher;
  const res = matcher(segments, segmentGroup, route);
  if (!res) return __spreadValues({}, noMatch);
  const posParams = {};
  Object.entries(res.posParams ?? {}).forEach(([k2, v]) => {
    posParams[k2] = v.path;
  });
  const parameters = res.consumed.length > 0 ? __spreadValues(__spreadValues({}, posParams), res.consumed[res.consumed.length - 1].parameters) : posParams;
  return {
    matched: true,
    consumedSegments: res.consumed,
    remainingSegments: segments.slice(res.consumed.length),
    // TODO(atscott): investigate combining parameters and positionalParamSegments
    parameters,
    positionalParamSegments: res.posParams ?? {}
  };
}
function createWildcardMatchResult(segments) {
  return {
    matched: true,
    parameters: segments.length > 0 ? last3(segments).parameters : {},
    consumedSegments: segments,
    remainingSegments: [],
    positionalParamSegments: {}
  };
}
function split(segmentGroup, consumedSegments, slicedSegments, config2) {
  if (slicedSegments.length > 0 && containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config2)) {
    const s3 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(config2, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
    return {
      segmentGroup: s3,
      slicedSegments: []
    };
  }
  if (slicedSegments.length === 0 && containsEmptyPathMatches(segmentGroup, slicedSegments, config2)) {
    const s3 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config2, segmentGroup.children));
    return {
      segmentGroup: s3,
      slicedSegments
    };
  }
  const s2 = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);
  return {
    segmentGroup: s2,
    slicedSegments
  };
}
function addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes2, children) {
  const res = {};
  for (const r2 of routes2) {
    if (emptyPathMatch(segmentGroup, slicedSegments, r2) && !children[getOutlet(r2)]) {
      const s2 = new UrlSegmentGroup([], {});
      res[getOutlet(r2)] = s2;
    }
  }
  return __spreadValues(__spreadValues({}, children), res);
}
function createChildrenForEmptyPaths(routes2, primarySegment) {
  const res = {};
  res[PRIMARY_OUTLET] = primarySegment;
  for (const r2 of routes2) {
    if (r2.path === "" && getOutlet(r2) !== PRIMARY_OUTLET) {
      const s2 = new UrlSegmentGroup([], {});
      res[getOutlet(r2)] = s2;
    }
  }
  return res;
}
function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes2) {
  return routes2.some((r2) => emptyPathMatch(segmentGroup, slicedSegments, r2) && getOutlet(r2) !== PRIMARY_OUTLET);
}
function containsEmptyPathMatches(segmentGroup, slicedSegments, routes2) {
  return routes2.some((r2) => emptyPathMatch(segmentGroup, slicedSegments, r2));
}
function emptyPathMatch(segmentGroup, slicedSegments, r2) {
  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r2.pathMatch === "full") {
    return false;
  }
  return r2.path === "";
}
function noLeftoversInUrl(segmentGroup, segments, outlet) {
  return segments.length === 0 && !segmentGroup.children[outlet];
}
function recognize$1(injector, configLoader, rootComponentType, config2, urlTree, urlSerializer, paramsInheritanceStrategy = "emptyOnly") {
  return new Recognizer(injector, configLoader, rootComponentType, config2, urlTree, paramsInheritanceStrategy, urlSerializer).recognize();
}
function sortActivatedRouteSnapshots(nodes) {
  nodes.sort((a2, b2) => {
    if (a2.value.outlet === PRIMARY_OUTLET) return -1;
    if (b2.value.outlet === PRIMARY_OUTLET) return 1;
    return a2.value.outlet.localeCompare(b2.value.outlet);
  });
}
function hasEmptyPathConfig(node) {
  const config2 = node.value.routeConfig;
  return config2 && config2.path === "";
}
function mergeEmptyPathMatches(nodes) {
  const result = [];
  const mergedNodes = /* @__PURE__ */ new Set();
  for (const node of nodes) {
    if (!hasEmptyPathConfig(node)) {
      result.push(node);
      continue;
    }
    const duplicateEmptyPathNode = result.find((resultNode) => node.value.routeConfig === resultNode.value.routeConfig);
    if (duplicateEmptyPathNode !== void 0) {
      duplicateEmptyPathNode.children.push(...node.children);
      mergedNodes.add(duplicateEmptyPathNode);
    } else {
      result.push(node);
    }
  }
  for (const mergedNode of mergedNodes) {
    const mergedChildren = mergeEmptyPathMatches(mergedNode.children);
    result.push(new TreeNode(mergedNode.value, mergedChildren));
  }
  return result.filter((n2) => !mergedNodes.has(n2));
}
function checkOutletNameUniqueness(nodes) {
  const names = {};
  nodes.forEach((n2) => {
    const routeWithSameOutletName = names[n2.value.outlet];
    if (routeWithSameOutletName) {
      const p2 = routeWithSameOutletName.url.map((s2) => s2.toString()).join("/");
      const c2 = n2.value.url.map((s2) => s2.toString()).join("/");
      throw new RuntimeError(4006, (typeof ngDevMode === "undefined" || ngDevMode) && `Two segments cannot have the same outlet name: '${p2}' and '${c2}'.`);
    }
    names[n2.value.outlet] = n2.value;
  });
}
function getData(route) {
  return route.data || {};
}
function getResolve(route) {
  return route.resolve || {};
}
function recognize(injector, configLoader, rootComponentType, config2, serializer, paramsInheritanceStrategy) {
  return mergeMap((t2) => recognize$1(injector, configLoader, rootComponentType, config2, t2.extractedUrl, serializer, paramsInheritanceStrategy).pipe(map(({
    state: targetSnapshot,
    tree: urlAfterRedirects
  }) => {
    return __spreadProps(__spreadValues({}, t2), {
      targetSnapshot,
      urlAfterRedirects
    });
  })));
}
function resolveData(paramsInheritanceStrategy, injector) {
  return mergeMap((t2) => {
    const {
      targetSnapshot,
      guards: {
        canActivateChecks
      }
    } = t2;
    if (!canActivateChecks.length) {
      return of(t2);
    }
    const routesWithResolversToRun = new Set(canActivateChecks.map((check) => check.route));
    const routesNeedingDataUpdates = /* @__PURE__ */ new Set();
    for (const route of routesWithResolversToRun) {
      if (routesNeedingDataUpdates.has(route)) {
        continue;
      }
      for (const newRoute of flattenRouteTree(route)) {
        routesNeedingDataUpdates.add(newRoute);
      }
    }
    let routesProcessed = 0;
    return from(routesNeedingDataUpdates).pipe(concatMap((route) => {
      if (routesWithResolversToRun.has(route)) {
        return runResolve(route, targetSnapshot, paramsInheritanceStrategy, injector);
      } else {
        route.data = getInherited(route, route.parent, paramsInheritanceStrategy).resolve;
        return of(void 0);
      }
    }), tap(() => routesProcessed++), takeLast(1), mergeMap((_2) => routesProcessed === routesNeedingDataUpdates.size ? of(t2) : EMPTY));
  });
}
function flattenRouteTree(route) {
  const descendants = route.children.map((child) => flattenRouteTree(child)).flat();
  return [route, ...descendants];
}
function runResolve(futureARS, futureRSS, paramsInheritanceStrategy, injector) {
  const config2 = futureARS.routeConfig;
  const resolve = futureARS._resolve;
  if (config2?.title !== void 0 && !hasStaticTitle(config2)) {
    resolve[RouteTitleKey] = config2.title;
  }
  return defer(() => {
    futureARS.data = getInherited(futureARS, futureARS.parent, paramsInheritanceStrategy).resolve;
    return resolveNode(resolve, futureARS, futureRSS, injector).pipe(map((resolvedData) => {
      futureARS._resolvedData = resolvedData;
      futureARS.data = __spreadValues(__spreadValues({}, futureARS.data), resolvedData);
      return null;
    }));
  });
}
function resolveNode(resolve, futureARS, futureRSS, injector) {
  const keys = getDataKeys(resolve);
  if (keys.length === 0) {
    return of({});
  }
  const data = {};
  return from(keys).pipe(mergeMap((key) => getResolver(resolve[key], futureARS, futureRSS, injector).pipe(first(), tap((value) => {
    if (value instanceof RedirectCommand) {
      throw redirectingNavigationError(new DefaultUrlSerializer(), value);
    }
    data[key] = value;
  }))), takeLast(1), map(() => data), catchError((e2) => isEmptyError(e2) ? EMPTY : throwError(e2)));
}
function getResolver(injectionToken, futureARS, futureRSS, injector) {
  const closestInjector = getClosestRouteInjector(futureARS) ?? injector;
  const resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);
  const resolverValue = resolver.resolve ? resolver.resolve(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => resolver(futureARS, futureRSS));
  return wrapIntoObservable(resolverValue);
}
function switchTap(next) {
  return switchMap((v) => {
    const nextResult = next(v);
    if (nextResult) {
      return from(nextResult).pipe(map(() => v));
    }
    return of(v);
  });
}
function loadChildren(route, compiler, parentInjector, onLoadEndListener) {
  return wrapIntoObservable(runInInjectionContext(parentInjector, () => route.loadChildren())).pipe(map(maybeUnwrapDefaultExport), switchMap(maybeResolveResources), mergeMap((t2) => {
    if (t2 instanceof NgModuleFactory$1 || Array.isArray(t2)) {
      return of(t2);
    } else {
      return from(compiler.compileModuleAsync(t2));
    }
  }), map((factoryOrRoutes) => {
    if (onLoadEndListener) {
      onLoadEndListener(route);
    }
    let injector;
    let rawRoutes;
    let requireStandaloneComponents = false;
    if (Array.isArray(factoryOrRoutes)) {
      rawRoutes = factoryOrRoutes;
      requireStandaloneComponents = true;
    } else {
      injector = factoryOrRoutes.create(parentInjector).injector;
      rawRoutes = injector.get(ROUTES, [], {
        optional: true,
        self: true
      }).flat();
    }
    const routes2 = rawRoutes.map(standardizeConfig);
    (typeof ngDevMode === "undefined" || ngDevMode) && validateConfig(routes2, route.path, requireStandaloneComponents);
    return {
      routes: routes2,
      injector
    };
  }));
}
function isWrappedDefaultExport(value) {
  return value && typeof value === "object" && "default" in value;
}
function maybeUnwrapDefaultExport(input2) {
  return isWrappedDefaultExport(input2) ? input2["default"] : input2;
}
function maybeResolveResources(value) {
  if (false) {
    return resolveComponentResources(fetch).catch((error) => {
      console.error(error);
      return Promise.resolve();
    }).then(() => value);
  }
  return of(value);
}
function createViewTransition(injector, from2, to2) {
  const transitionOptions = injector.get(VIEW_TRANSITION_OPTIONS);
  const document2 = injector.get(DOCUMENT);
  if (!document2.startViewTransition || transitionOptions.skipNextTransition) {
    transitionOptions.skipNextTransition = false;
    return new Promise((resolve) => setTimeout(resolve));
  }
  let resolveViewTransitionStarted;
  const viewTransitionStarted = new Promise((resolve) => {
    resolveViewTransitionStarted = resolve;
  });
  const transition = document2.startViewTransition(() => {
    resolveViewTransitionStarted();
    return createRenderPromise(injector);
  });
  transition.ready.catch((error) => {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.error(error);
    }
  });
  const {
    onViewTransitionCreated
  } = transitionOptions;
  if (onViewTransitionCreated) {
    runInInjectionContext(injector, () => onViewTransitionCreated({
      transition,
      from: from2,
      to: to2
    }));
  }
  return viewTransitionStarted;
}
function createRenderPromise(injector) {
  return new Promise((resolve) => {
    afterNextRender({
      read: () => setTimeout(resolve)
    }, {
      injector
    });
  });
}
function isBrowserTriggeredNavigation(source) {
  return source !== IMPERATIVE_NAVIGATION;
}
function afterNextNavigation(router, action) {
  router.events.pipe(filter((e2) => e2 instanceof NavigationEnd || e2 instanceof NavigationCancel || e2 instanceof NavigationError || e2 instanceof NavigationSkipped), map((e2) => {
    if (e2 instanceof NavigationEnd || e2 instanceof NavigationSkipped) {
      return 0;
    }
    const redirecting = e2 instanceof NavigationCancel ? e2.code === NavigationCancellationCode.Redirect || e2.code === NavigationCancellationCode.SupersededByNewNavigation : false;
    return redirecting ? 2 : 1;
  }), filter(
    (result) => result !== 2
    /* NavigationResult.REDIRECTING */
  ), take(1)).subscribe(() => {
    action();
  });
}
function validateCommands(commands) {
  for (let i2 = 0; i2 < commands.length; i2++) {
    const cmd = commands[i2];
    if (cmd == null) {
      throw new RuntimeError(4008, (typeof ngDevMode === "undefined" || ngDevMode) && `The requested path contains ${cmd} segment at index ${i2}`);
    }
  }
}
var PRIMARY_OUTLET, RouteTitleKey, ParamsAsMap, pathCompareMap, paramCompareMap, UrlTree, UrlSegmentGroup, UrlSegment, UrlSerializer, DefaultUrlSerializer, DEFAULT_SERIALIZER, SEGMENT_RE, MATRIX_PARAM_SEGMENT_RE, QUERY_PARAM_RE, QUERY_PARAM_VALUE_RE, UrlParser, Navigation, Position, IMPERATIVE_NAVIGATION, EventType, RouterEvent, NavigationStart, NavigationEnd, NavigationCancellationCode, NavigationSkippedCode, NavigationCancel, NavigationSkipped, NavigationError, RoutesRecognized, GuardsCheckStart, GuardsCheckEnd, ResolveStart, ResolveEnd, RouteConfigLoadStart, RouteConfigLoadEnd, ChildActivationStart, ChildActivationEnd, ActivationStart, ActivationEnd, Scroll, BeforeActivateRoutes, RedirectRequest, OutletContext, ChildrenOutletContexts, Tree, TreeNode, RouterState, ActivatedRoute, ActivatedRouteSnapshot, RouterStateSnapshot, ROUTER_OUTLET_DATA, RouterOutlet, OutletInjector, INPUT_BINDER, RoutedComponentInputBinder, \u0275EmptyOutletComponent, RedirectCommand, NAVIGATION_CANCELING_ERROR, warnedAboutUnsupportedInputBinding, activateRoutes, ActivateRoutes, CanActivate, CanDeactivate, INITIAL_VALUE, NoMatch, AbsoluteRedirect, ApplyRedirects, noMatch, NoLeftoversInUrl, MAX_ALLOWED_REDIRECTS, Recognizer, TitleStrategy, DefaultTitleStrategy, ROUTER_CONFIGURATION, ROUTES, RouterConfigLoader, UrlHandlingStrategy, DefaultUrlHandlingStrategy, CREATE_VIEW_TRANSITION, VIEW_TRANSITION_OPTIONS, NAVIGATION_ERROR_HANDLER, NavigationTransitions, RouteReuseStrategy, BaseRouteReuseStrategy, DefaultRouteReuseStrategy, StateManager, HistoryStateManager, exactMatchOptions, subsetMatchOptions, Router;
var init_router2 = __esm({
  "node_modules/@angular/router/fesm2022/router2.mjs"() {
    "use strict";
    init_common();
    init_core();
    init_core();
    init_esm();
    init_operators();
    init_platform_browser();
    PRIMARY_OUTLET = "primary";
    RouteTitleKey = /* @__PURE__ */ Symbol("RouteTitle");
    ParamsAsMap = class {
      params;
      constructor(params) {
        this.params = params || {};
      }
      has(name) {
        return Object.prototype.hasOwnProperty.call(this.params, name);
      }
      get(name) {
        if (this.has(name)) {
          const v = this.params[name];
          return Array.isArray(v) ? v[0] : v;
        }
        return null;
      }
      getAll(name) {
        if (this.has(name)) {
          const v = this.params[name];
          return Array.isArray(v) ? v : [v];
        }
        return [];
      }
      get keys() {
        return Object.keys(this.params);
      }
    };
    pathCompareMap = {
      "exact": equalSegmentGroups,
      "subset": containsSegmentGroup
    };
    paramCompareMap = {
      "exact": equalParams,
      "subset": containsParams,
      "ignored": () => true
    };
    UrlTree = class {
      root;
      queryParams;
      fragment;
      /** @internal */
      _queryParamMap;
      constructor(root = new UrlSegmentGroup([], {}), queryParams = {}, fragment = null) {
        this.root = root;
        this.queryParams = queryParams;
        this.fragment = fragment;
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          if (root.segments.length > 0) {
            throw new RuntimeError(4015, "The root `UrlSegmentGroup` should not contain `segments`. Instead, these segments belong in the `children` so they can be associated with a named outlet.");
          }
        }
      }
      get queryParamMap() {
        this._queryParamMap ??= convertToParamMap(this.queryParams);
        return this._queryParamMap;
      }
      /** @docsNotRequired */
      toString() {
        return DEFAULT_SERIALIZER.serialize(this);
      }
    };
    UrlSegmentGroup = class {
      segments;
      children;
      /** The parent node in the url tree */
      parent = null;
      constructor(segments, children) {
        this.segments = segments;
        this.children = children;
        Object.values(children).forEach((v) => v.parent = this);
      }
      /** Whether the segment has child segments */
      hasChildren() {
        return this.numberOfChildren > 0;
      }
      /** Number of child segments */
      get numberOfChildren() {
        return Object.keys(this.children).length;
      }
      /** @docsNotRequired */
      toString() {
        return serializePaths(this);
      }
    };
    UrlSegment = class {
      path;
      parameters;
      /** @internal */
      _parameterMap;
      constructor(path, parameters) {
        this.path = path;
        this.parameters = parameters;
      }
      get parameterMap() {
        this._parameterMap ??= convertToParamMap(this.parameters);
        return this._parameterMap;
      }
      /** @docsNotRequired */
      toString() {
        return serializePath(this);
      }
    };
    UrlSerializer = class _UrlSerializer {
      static \u0275fac = function UrlSerializer_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _UrlSerializer)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _UrlSerializer,
        factory: () => (() => new DefaultUrlSerializer())(),
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UrlSerializer, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: () => new DefaultUrlSerializer()
        }]
      }], null, null);
    })();
    DefaultUrlSerializer = class {
      /** Parses a url into a `UrlTree` */
      parse(url) {
        const p2 = new UrlParser(url);
        return new UrlTree(p2.parseRootSegment(), p2.parseQueryParams(), p2.parseFragment());
      }
      /** Converts a `UrlTree` into a url */
      serialize(tree2) {
        const segment = `/${serializeSegment(tree2.root, true)}`;
        const query = serializeQueryParams(tree2.queryParams);
        const fragment = typeof tree2.fragment === `string` ? `#${encodeUriFragment(tree2.fragment)}` : "";
        return `${segment}${query}${fragment}`;
      }
    };
    DEFAULT_SERIALIZER = new DefaultUrlSerializer();
    SEGMENT_RE = /^[^\/()?;#]+/;
    MATRIX_PARAM_SEGMENT_RE = /^[^\/()?;=#]+/;
    QUERY_PARAM_RE = /^[^=?&#]+/;
    QUERY_PARAM_VALUE_RE = /^[^&#]+/;
    UrlParser = class {
      url;
      remaining;
      constructor(url) {
        this.url = url;
        this.remaining = url;
      }
      parseRootSegment() {
        this.consumeOptional("/");
        if (this.remaining === "" || this.peekStartsWith("?") || this.peekStartsWith("#")) {
          return new UrlSegmentGroup([], {});
        }
        return new UrlSegmentGroup([], this.parseChildren());
      }
      parseQueryParams() {
        const params = {};
        if (this.consumeOptional("?")) {
          do {
            this.parseQueryParam(params);
          } while (this.consumeOptional("&"));
        }
        return params;
      }
      parseFragment() {
        return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null;
      }
      parseChildren() {
        if (this.remaining === "") {
          return {};
        }
        this.consumeOptional("/");
        const segments = [];
        if (!this.peekStartsWith("(")) {
          segments.push(this.parseSegment());
        }
        while (this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(")) {
          this.capture("/");
          segments.push(this.parseSegment());
        }
        let children = {};
        if (this.peekStartsWith("/(")) {
          this.capture("/");
          children = this.parseParens(true);
        }
        let res = {};
        if (this.peekStartsWith("(")) {
          res = this.parseParens(false);
        }
        if (segments.length > 0 || Object.keys(children).length > 0) {
          res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);
        }
        return res;
      }
      // parse a segment with its matrix parameters
      // ie `name;k1=v1;k2`
      parseSegment() {
        const path = matchSegments(this.remaining);
        if (path === "" && this.peekStartsWith(";")) {
          throw new RuntimeError(4009, (typeof ngDevMode === "undefined" || ngDevMode) && `Empty path url segment cannot have parameters: '${this.remaining}'.`);
        }
        this.capture(path);
        return new UrlSegment(decode(path), this.parseMatrixParams());
      }
      parseMatrixParams() {
        const params = {};
        while (this.consumeOptional(";")) {
          this.parseParam(params);
        }
        return params;
      }
      parseParam(params) {
        const key = matchMatrixKeySegments(this.remaining);
        if (!key) {
          return;
        }
        this.capture(key);
        let value = "";
        if (this.consumeOptional("=")) {
          const valueMatch = matchSegments(this.remaining);
          if (valueMatch) {
            value = valueMatch;
            this.capture(value);
          }
        }
        params[decode(key)] = decode(value);
      }
      // Parse a single query parameter `name[=value]`
      parseQueryParam(params) {
        const key = matchQueryParams(this.remaining);
        if (!key) {
          return;
        }
        this.capture(key);
        let value = "";
        if (this.consumeOptional("=")) {
          const valueMatch = matchUrlQueryParamValue(this.remaining);
          if (valueMatch) {
            value = valueMatch;
            this.capture(value);
          }
        }
        const decodedKey = decodeQuery(key);
        const decodedVal = decodeQuery(value);
        if (params.hasOwnProperty(decodedKey)) {
          let currentVal = params[decodedKey];
          if (!Array.isArray(currentVal)) {
            currentVal = [currentVal];
            params[decodedKey] = currentVal;
          }
          currentVal.push(decodedVal);
        } else {
          params[decodedKey] = decodedVal;
        }
      }
      // parse `(a/b//outlet_name:c/d)`
      parseParens(allowPrimary) {
        const segments = {};
        this.capture("(");
        while (!this.consumeOptional(")") && this.remaining.length > 0) {
          const path = matchSegments(this.remaining);
          const next = this.remaining[path.length];
          if (next !== "/" && next !== ")" && next !== ";") {
            throw new RuntimeError(4010, (typeof ngDevMode === "undefined" || ngDevMode) && `Cannot parse url '${this.url}'`);
          }
          let outletName = void 0;
          if (path.indexOf(":") > -1) {
            outletName = path.slice(0, path.indexOf(":"));
            this.capture(outletName);
            this.capture(":");
          } else if (allowPrimary) {
            outletName = PRIMARY_OUTLET;
          }
          const children = this.parseChildren();
          segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] : new UrlSegmentGroup([], children);
          this.consumeOptional("//");
        }
        return segments;
      }
      peekStartsWith(str) {
        return this.remaining.startsWith(str);
      }
      // Consumes the prefix when it is present and returns whether it has been consumed
      consumeOptional(str) {
        if (this.peekStartsWith(str)) {
          this.remaining = this.remaining.substring(str.length);
          return true;
        }
        return false;
      }
      capture(str) {
        if (!this.consumeOptional(str)) {
          throw new RuntimeError(4011, (typeof ngDevMode === "undefined" || ngDevMode) && `Expected "${str}".`);
        }
      }
    };
    Navigation = class {
      isAbsolute;
      numberOfDoubleDots;
      commands;
      constructor(isAbsolute, numberOfDoubleDots, commands) {
        this.isAbsolute = isAbsolute;
        this.numberOfDoubleDots = numberOfDoubleDots;
        this.commands = commands;
        if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {
          throw new RuntimeError(4003, (typeof ngDevMode === "undefined" || ngDevMode) && "Root segment cannot have matrix parameters");
        }
        const cmdWithOutlet = commands.find(isCommandWithOutlets);
        if (cmdWithOutlet && cmdWithOutlet !== last3(commands)) {
          throw new RuntimeError(4004, (typeof ngDevMode === "undefined" || ngDevMode) && "{outlets:{}} has to be the last command");
        }
      }
      toRoot() {
        return this.isAbsolute && this.commands.length === 1 && this.commands[0] == "/";
      }
    };
    Position = class {
      segmentGroup;
      processChildren;
      index;
      constructor(segmentGroup, processChildren, index) {
        this.segmentGroup = segmentGroup;
        this.processChildren = processChildren;
        this.index = index;
      }
    };
    IMPERATIVE_NAVIGATION = "imperative";
    (function(EventType2) {
      EventType2[EventType2["NavigationStart"] = 0] = "NavigationStart";
      EventType2[EventType2["NavigationEnd"] = 1] = "NavigationEnd";
      EventType2[EventType2["NavigationCancel"] = 2] = "NavigationCancel";
      EventType2[EventType2["NavigationError"] = 3] = "NavigationError";
      EventType2[EventType2["RoutesRecognized"] = 4] = "RoutesRecognized";
      EventType2[EventType2["ResolveStart"] = 5] = "ResolveStart";
      EventType2[EventType2["ResolveEnd"] = 6] = "ResolveEnd";
      EventType2[EventType2["GuardsCheckStart"] = 7] = "GuardsCheckStart";
      EventType2[EventType2["GuardsCheckEnd"] = 8] = "GuardsCheckEnd";
      EventType2[EventType2["RouteConfigLoadStart"] = 9] = "RouteConfigLoadStart";
      EventType2[EventType2["RouteConfigLoadEnd"] = 10] = "RouteConfigLoadEnd";
      EventType2[EventType2["ChildActivationStart"] = 11] = "ChildActivationStart";
      EventType2[EventType2["ChildActivationEnd"] = 12] = "ChildActivationEnd";
      EventType2[EventType2["ActivationStart"] = 13] = "ActivationStart";
      EventType2[EventType2["ActivationEnd"] = 14] = "ActivationEnd";
      EventType2[EventType2["Scroll"] = 15] = "Scroll";
      EventType2[EventType2["NavigationSkipped"] = 16] = "NavigationSkipped";
    })(EventType || (EventType = {}));
    RouterEvent = class {
      id;
      url;
      constructor(id2, url) {
        this.id = id2;
        this.url = url;
      }
    };
    NavigationStart = class extends RouterEvent {
      type = EventType.NavigationStart;
      /**
       * Identifies the call or event that triggered the navigation.
       * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.
       *
       * @see {@link NavigationEnd}
       * @see {@link NavigationCancel}
       * @see {@link NavigationError}
       */
      navigationTrigger;
      /**
       * The navigation state that was previously supplied to the `pushState` call,
       * when the navigation is triggered by a `popstate` event. Otherwise null.
       *
       * The state object is defined by `NavigationExtras`, and contains any
       * developer-defined state value, as well as a unique ID that
       * the router assigns to every router transition/navigation.
       *
       * From the perspective of the router, the router never "goes back".
       * When the user clicks on the back button in the browser,
       * a new navigation ID is created.
       *
       * Use the ID in this previous-state object to differentiate between a newly created
       * state and one returned to by a `popstate` event, so that you can restore some
       * remembered state, such as scroll position.
       *
       */
      restoredState;
      constructor(id2, url, navigationTrigger = "imperative", restoredState = null) {
        super(id2, url);
        this.navigationTrigger = navigationTrigger;
        this.restoredState = restoredState;
      }
      /** @docsNotRequired */
      toString() {
        return `NavigationStart(id: ${this.id}, url: '${this.url}')`;
      }
    };
    NavigationEnd = class extends RouterEvent {
      urlAfterRedirects;
      type = EventType.NavigationEnd;
      constructor(id2, url, urlAfterRedirects) {
        super(id2, url);
        this.urlAfterRedirects = urlAfterRedirects;
      }
      /** @docsNotRequired */
      toString() {
        return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;
      }
    };
    (function(NavigationCancellationCode2) {
      NavigationCancellationCode2[NavigationCancellationCode2["Redirect"] = 0] = "Redirect";
      NavigationCancellationCode2[NavigationCancellationCode2["SupersededByNewNavigation"] = 1] = "SupersededByNewNavigation";
      NavigationCancellationCode2[NavigationCancellationCode2["NoDataFromResolver"] = 2] = "NoDataFromResolver";
      NavigationCancellationCode2[NavigationCancellationCode2["GuardRejected"] = 3] = "GuardRejected";
      NavigationCancellationCode2[NavigationCancellationCode2["Aborted"] = 4] = "Aborted";
    })(NavigationCancellationCode || (NavigationCancellationCode = {}));
    (function(NavigationSkippedCode2) {
      NavigationSkippedCode2[NavigationSkippedCode2["IgnoredSameUrlNavigation"] = 0] = "IgnoredSameUrlNavigation";
      NavigationSkippedCode2[NavigationSkippedCode2["IgnoredByUrlHandlingStrategy"] = 1] = "IgnoredByUrlHandlingStrategy";
    })(NavigationSkippedCode || (NavigationSkippedCode = {}));
    NavigationCancel = class extends RouterEvent {
      reason;
      code;
      type = EventType.NavigationCancel;
      constructor(id2, url, reason, code) {
        super(id2, url);
        this.reason = reason;
        this.code = code;
      }
      /** @docsNotRequired */
      toString() {
        return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;
      }
    };
    NavigationSkipped = class extends RouterEvent {
      reason;
      code;
      type = EventType.NavigationSkipped;
      constructor(id2, url, reason, code) {
        super(id2, url);
        this.reason = reason;
        this.code = code;
      }
    };
    NavigationError = class extends RouterEvent {
      error;
      target;
      type = EventType.NavigationError;
      constructor(id2, url, error, target) {
        super(id2, url);
        this.error = error;
        this.target = target;
      }
      /** @docsNotRequired */
      toString() {
        return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;
      }
    };
    RoutesRecognized = class extends RouterEvent {
      urlAfterRedirects;
      state;
      type = EventType.RoutesRecognized;
      constructor(id2, url, urlAfterRedirects, state) {
        super(id2, url);
        this.urlAfterRedirects = urlAfterRedirects;
        this.state = state;
      }
      /** @docsNotRequired */
      toString() {
        return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
      }
    };
    GuardsCheckStart = class extends RouterEvent {
      urlAfterRedirects;
      state;
      type = EventType.GuardsCheckStart;
      constructor(id2, url, urlAfterRedirects, state) {
        super(id2, url);
        this.urlAfterRedirects = urlAfterRedirects;
        this.state = state;
      }
      toString() {
        return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
      }
    };
    GuardsCheckEnd = class extends RouterEvent {
      urlAfterRedirects;
      state;
      shouldActivate;
      type = EventType.GuardsCheckEnd;
      constructor(id2, url, urlAfterRedirects, state, shouldActivate) {
        super(id2, url);
        this.urlAfterRedirects = urlAfterRedirects;
        this.state = state;
        this.shouldActivate = shouldActivate;
      }
      toString() {
        return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;
      }
    };
    ResolveStart = class extends RouterEvent {
      urlAfterRedirects;
      state;
      type = EventType.ResolveStart;
      constructor(id2, url, urlAfterRedirects, state) {
        super(id2, url);
        this.urlAfterRedirects = urlAfterRedirects;
        this.state = state;
      }
      toString() {
        return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
      }
    };
    ResolveEnd = class extends RouterEvent {
      urlAfterRedirects;
      state;
      type = EventType.ResolveEnd;
      constructor(id2, url, urlAfterRedirects, state) {
        super(id2, url);
        this.urlAfterRedirects = urlAfterRedirects;
        this.state = state;
      }
      toString() {
        return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
      }
    };
    RouteConfigLoadStart = class {
      route;
      type = EventType.RouteConfigLoadStart;
      constructor(route) {
        this.route = route;
      }
      toString() {
        return `RouteConfigLoadStart(path: ${this.route.path})`;
      }
    };
    RouteConfigLoadEnd = class {
      route;
      type = EventType.RouteConfigLoadEnd;
      constructor(route) {
        this.route = route;
      }
      toString() {
        return `RouteConfigLoadEnd(path: ${this.route.path})`;
      }
    };
    ChildActivationStart = class {
      snapshot;
      type = EventType.ChildActivationStart;
      constructor(snapshot) {
        this.snapshot = snapshot;
      }
      toString() {
        const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
        return `ChildActivationStart(path: '${path}')`;
      }
    };
    ChildActivationEnd = class {
      snapshot;
      type = EventType.ChildActivationEnd;
      constructor(snapshot) {
        this.snapshot = snapshot;
      }
      toString() {
        const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
        return `ChildActivationEnd(path: '${path}')`;
      }
    };
    ActivationStart = class {
      snapshot;
      type = EventType.ActivationStart;
      constructor(snapshot) {
        this.snapshot = snapshot;
      }
      toString() {
        const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
        return `ActivationStart(path: '${path}')`;
      }
    };
    ActivationEnd = class {
      snapshot;
      type = EventType.ActivationEnd;
      constructor(snapshot) {
        this.snapshot = snapshot;
      }
      toString() {
        const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
        return `ActivationEnd(path: '${path}')`;
      }
    };
    Scroll = class {
      routerEvent;
      position;
      anchor;
      type = EventType.Scroll;
      constructor(routerEvent, position, anchor) {
        this.routerEvent = routerEvent;
        this.position = position;
        this.anchor = anchor;
      }
      toString() {
        const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;
        return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;
      }
    };
    BeforeActivateRoutes = class {
    };
    RedirectRequest = class {
      url;
      navigationBehaviorOptions;
      constructor(url, navigationBehaviorOptions) {
        this.url = url;
        this.navigationBehaviorOptions = navigationBehaviorOptions;
      }
    };
    OutletContext = class {
      rootInjector;
      outlet = null;
      route = null;
      children;
      attachRef = null;
      get injector() {
        return getClosestRouteInjector(this.route?.snapshot) ?? this.rootInjector;
      }
      constructor(rootInjector) {
        this.rootInjector = rootInjector;
        this.children = new ChildrenOutletContexts(this.rootInjector);
      }
    };
    ChildrenOutletContexts = class _ChildrenOutletContexts {
      rootInjector;
      // contexts for child outlets, by name.
      contexts = /* @__PURE__ */ new Map();
      /** @docs-private */
      constructor(rootInjector) {
        this.rootInjector = rootInjector;
      }
      /** Called when a `RouterOutlet` directive is instantiated */
      onChildOutletCreated(childName, outlet) {
        const context2 = this.getOrCreateContext(childName);
        context2.outlet = outlet;
        this.contexts.set(childName, context2);
      }
      /**
       * Called when a `RouterOutlet` directive is destroyed.
       * We need to keep the context as the outlet could be destroyed inside a NgIf and might be
       * re-created later.
       */
      onChildOutletDestroyed(childName) {
        const context2 = this.getContext(childName);
        if (context2) {
          context2.outlet = null;
          context2.attachRef = null;
        }
      }
      /**
       * Called when the corresponding route is deactivated during navigation.
       * Because the component get destroyed, all children outlet are destroyed.
       */
      onOutletDeactivated() {
        const contexts = this.contexts;
        this.contexts = /* @__PURE__ */ new Map();
        return contexts;
      }
      onOutletReAttached(contexts) {
        this.contexts = contexts;
      }
      getOrCreateContext(childName) {
        let context2 = this.getContext(childName);
        if (!context2) {
          context2 = new OutletContext(this.rootInjector);
          this.contexts.set(childName, context2);
        }
        return context2;
      }
      getContext(childName) {
        return this.contexts.get(childName) || null;
      }
      static \u0275fac = function ChildrenOutletContexts_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ChildrenOutletContexts)(\u0275\u0275inject(EnvironmentInjector));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _ChildrenOutletContexts,
        factory: _ChildrenOutletContexts.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChildrenOutletContexts, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [{
        type: EnvironmentInjector
      }], null);
    })();
    Tree = class {
      /** @internal */
      _root;
      constructor(root) {
        this._root = root;
      }
      get root() {
        return this._root.value;
      }
      /**
       * @internal
       */
      parent(t2) {
        const p2 = this.pathFromRoot(t2);
        return p2.length > 1 ? p2[p2.length - 2] : null;
      }
      /**
       * @internal
       */
      children(t2) {
        const n2 = findNode(t2, this._root);
        return n2 ? n2.children.map((t3) => t3.value) : [];
      }
      /**
       * @internal
       */
      firstChild(t2) {
        const n2 = findNode(t2, this._root);
        return n2 && n2.children.length > 0 ? n2.children[0].value : null;
      }
      /**
       * @internal
       */
      siblings(t2) {
        const p2 = findPath(t2, this._root);
        if (p2.length < 2) return [];
        const c2 = p2[p2.length - 2].children.map((c3) => c3.value);
        return c2.filter((cc2) => cc2 !== t2);
      }
      /**
       * @internal
       */
      pathFromRoot(t2) {
        return findPath(t2, this._root).map((s2) => s2.value);
      }
    };
    TreeNode = class {
      value;
      children;
      constructor(value, children) {
        this.value = value;
        this.children = children;
      }
      toString() {
        return `TreeNode(${this.value})`;
      }
    };
    RouterState = class extends Tree {
      snapshot;
      /** @internal */
      constructor(root, snapshot) {
        super(root);
        this.snapshot = snapshot;
        setRouterState(this, root);
      }
      toString() {
        return this.snapshot.toString();
      }
    };
    ActivatedRoute = class {
      urlSubject;
      paramsSubject;
      queryParamsSubject;
      fragmentSubject;
      dataSubject;
      outlet;
      component;
      /** The current snapshot of this route */
      snapshot;
      /** @internal */
      _futureSnapshot;
      /** @internal */
      _routerState;
      /** @internal */
      _paramMap;
      /** @internal */
      _queryParamMap;
      /** An Observable of the resolved route title */
      title;
      /** An observable of the URL segments matched by this route. */
      url;
      /** An observable of the matrix parameters scoped to this route. */
      params;
      /** An observable of the query parameters shared by all the routes. */
      queryParams;
      /** An observable of the URL fragment shared by all the routes. */
      fragment;
      /** An observable of the static and resolved data of this route. */
      data;
      /** @internal */
      constructor(urlSubject, paramsSubject, queryParamsSubject, fragmentSubject, dataSubject, outlet, component, futureSnapshot) {
        this.urlSubject = urlSubject;
        this.paramsSubject = paramsSubject;
        this.queryParamsSubject = queryParamsSubject;
        this.fragmentSubject = fragmentSubject;
        this.dataSubject = dataSubject;
        this.outlet = outlet;
        this.component = component;
        this._futureSnapshot = futureSnapshot;
        this.title = this.dataSubject?.pipe(map((d2) => d2[RouteTitleKey])) ?? of(void 0);
        this.url = urlSubject;
        this.params = paramsSubject;
        this.queryParams = queryParamsSubject;
        this.fragment = fragmentSubject;
        this.data = dataSubject;
      }
      /** The configuration used to match this route. */
      get routeConfig() {
        return this._futureSnapshot.routeConfig;
      }
      /** The root of the router state. */
      get root() {
        return this._routerState.root;
      }
      /** The parent of this route in the router state tree. */
      get parent() {
        return this._routerState.parent(this);
      }
      /** The first child of this route in the router state tree. */
      get firstChild() {
        return this._routerState.firstChild(this);
      }
      /** The children of this route in the router state tree. */
      get children() {
        return this._routerState.children(this);
      }
      /** The path from the root of the router state tree to this route. */
      get pathFromRoot() {
        return this._routerState.pathFromRoot(this);
      }
      /**
       * An Observable that contains a map of the required and optional parameters
       * specific to the route.
       * The map supports retrieving single and multiple values from the same parameter.
       */
      get paramMap() {
        this._paramMap ??= this.params.pipe(map((p2) => convertToParamMap(p2)));
        return this._paramMap;
      }
      /**
       * An Observable that contains a map of the query parameters available to all routes.
       * The map supports retrieving single and multiple values from the query parameter.
       */
      get queryParamMap() {
        this._queryParamMap ??= this.queryParams.pipe(map((p2) => convertToParamMap(p2)));
        return this._queryParamMap;
      }
      toString() {
        return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;
      }
    };
    ActivatedRouteSnapshot = class {
      url;
      params;
      queryParams;
      fragment;
      data;
      outlet;
      component;
      /** The configuration used to match this route **/
      routeConfig;
      /** @internal */
      _resolve;
      /** @internal */
      _resolvedData;
      /** @internal */
      _routerState;
      /** @internal */
      _paramMap;
      /** @internal */
      _queryParamMap;
      /** The resolved route title */
      get title() {
        return this.data?.[RouteTitleKey];
      }
      /** @internal */
      constructor(url, params, queryParams, fragment, data, outlet, component, routeConfig, resolve) {
        this.url = url;
        this.params = params;
        this.queryParams = queryParams;
        this.fragment = fragment;
        this.data = data;
        this.outlet = outlet;
        this.component = component;
        this.routeConfig = routeConfig;
        this._resolve = resolve;
      }
      /** The root of the router state */
      get root() {
        return this._routerState.root;
      }
      /** The parent of this route in the router state tree */
      get parent() {
        return this._routerState.parent(this);
      }
      /** The first child of this route in the router state tree */
      get firstChild() {
        return this._routerState.firstChild(this);
      }
      /** The children of this route in the router state tree */
      get children() {
        return this._routerState.children(this);
      }
      /** The path from the root of the router state tree to this route */
      get pathFromRoot() {
        return this._routerState.pathFromRoot(this);
      }
      get paramMap() {
        this._paramMap ??= convertToParamMap(this.params);
        return this._paramMap;
      }
      get queryParamMap() {
        this._queryParamMap ??= convertToParamMap(this.queryParams);
        return this._queryParamMap;
      }
      toString() {
        const url = this.url.map((segment) => segment.toString()).join("/");
        const matched = this.routeConfig ? this.routeConfig.path : "";
        return `Route(url:'${url}', path:'${matched}')`;
      }
    };
    RouterStateSnapshot = class extends Tree {
      url;
      /** @internal */
      constructor(url, root) {
        super(root);
        this.url = url;
        setRouterState(this, root);
      }
      toString() {
        return serializeNode(this._root);
      }
    };
    ROUTER_OUTLET_DATA = new InjectionToken(ngDevMode ? "RouterOutlet data" : "");
    RouterOutlet = class _RouterOutlet {
      activated = null;
      /** @internal */
      get activatedComponentRef() {
        return this.activated;
      }
      _activatedRoute = null;
      /**
       * The name of the outlet
       *
       */
      name = PRIMARY_OUTLET;
      activateEvents = new EventEmitter();
      deactivateEvents = new EventEmitter();
      /**
       * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a
       * previously detached subtree.
       **/
      attachEvents = new EventEmitter();
      /**
       * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the
       * subtree.
       */
      detachEvents = new EventEmitter();
      /**
       * Data that will be provided to the child injector through the `ROUTER_OUTLET_DATA` token.
       *
       * When unset, the value of the token is `undefined` by default.
       */
      routerOutletData = input(void 0, ...ngDevMode ? [{
        debugName: "routerOutletData"
      }] : []);
      parentContexts = inject2(ChildrenOutletContexts);
      location = inject2(ViewContainerRef);
      changeDetector = inject2(ChangeDetectorRef);
      inputBinder = inject2(INPUT_BINDER, {
        optional: true
      });
      /** @docs-private */
      supportsBindingToComponentInputs = true;
      /** @docs-private */
      ngOnChanges(changes) {
        if (changes["name"]) {
          const {
            firstChange,
            previousValue
          } = changes["name"];
          if (firstChange) {
            return;
          }
          if (this.isTrackedInParentContexts(previousValue)) {
            this.deactivate();
            this.parentContexts.onChildOutletDestroyed(previousValue);
          }
          this.initializeOutletWithName();
        }
      }
      /** @docs-private */
      ngOnDestroy() {
        if (this.isTrackedInParentContexts(this.name)) {
          this.parentContexts.onChildOutletDestroyed(this.name);
        }
        this.inputBinder?.unsubscribeFromRouteData(this);
      }
      isTrackedInParentContexts(outletName) {
        return this.parentContexts.getContext(outletName)?.outlet === this;
      }
      /** @docs-private */
      ngOnInit() {
        this.initializeOutletWithName();
      }
      initializeOutletWithName() {
        this.parentContexts.onChildOutletCreated(this.name, this);
        if (this.activated) {
          return;
        }
        const context2 = this.parentContexts.getContext(this.name);
        if (context2?.route) {
          if (context2.attachRef) {
            this.attach(context2.attachRef, context2.route);
          } else {
            this.activateWith(context2.route, context2.injector);
          }
        }
      }
      get isActivated() {
        return !!this.activated;
      }
      /**
       * @returns The currently activated component instance.
       * @throws An error if the outlet is not activated.
       */
      get component() {
        if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === "undefined" || ngDevMode) && "Outlet is not activated");
        return this.activated.instance;
      }
      get activatedRoute() {
        if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === "undefined" || ngDevMode) && "Outlet is not activated");
        return this._activatedRoute;
      }
      get activatedRouteData() {
        if (this._activatedRoute) {
          return this._activatedRoute.snapshot.data;
        }
        return {};
      }
      /**
       * Called when the `RouteReuseStrategy` instructs to detach the subtree
       */
      detach() {
        if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === "undefined" || ngDevMode) && "Outlet is not activated");
        this.location.detach();
        const cmp = this.activated;
        this.activated = null;
        this._activatedRoute = null;
        this.detachEvents.emit(cmp.instance);
        return cmp;
      }
      /**
       * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
       */
      attach(ref, activatedRoute) {
        this.activated = ref;
        this._activatedRoute = activatedRoute;
        this.location.insert(ref.hostView);
        this.inputBinder?.bindActivatedRouteToOutletComponent(this);
        this.attachEvents.emit(ref.instance);
      }
      deactivate() {
        if (this.activated) {
          const c2 = this.component;
          this.activated.destroy();
          this.activated = null;
          this._activatedRoute = null;
          this.deactivateEvents.emit(c2);
        }
      }
      activateWith(activatedRoute, environmentInjector) {
        if (this.isActivated) {
          throw new RuntimeError(4013, (typeof ngDevMode === "undefined" || ngDevMode) && "Cannot activate an already activated outlet");
        }
        this._activatedRoute = activatedRoute;
        const location2 = this.location;
        const snapshot = activatedRoute.snapshot;
        const component = snapshot.component;
        const childContexts = this.parentContexts.getOrCreateContext(this.name).children;
        const injector = new OutletInjector(activatedRoute, childContexts, location2.injector, this.routerOutletData);
        this.activated = location2.createComponent(component, {
          index: location2.length,
          injector,
          environmentInjector
        });
        this.changeDetector.markForCheck();
        this.inputBinder?.bindActivatedRouteToOutletComponent(this);
        this.activateEvents.emit(this.activated.instance);
      }
      static \u0275fac = function RouterOutlet_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _RouterOutlet)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _RouterOutlet,
        selectors: [["router-outlet"]],
        inputs: {
          name: "name",
          routerOutletData: [1, "routerOutletData"]
        },
        outputs: {
          activateEvents: "activate",
          deactivateEvents: "deactivate",
          attachEvents: "attach",
          detachEvents: "detach"
        },
        exportAs: ["outlet"],
        features: [\u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterOutlet, [{
        type: Directive,
        args: [{
          selector: "router-outlet",
          exportAs: "outlet"
        }]
      }], null, {
        name: [{
          type: Input
        }],
        activateEvents: [{
          type: Output,
          args: ["activate"]
        }],
        deactivateEvents: [{
          type: Output,
          args: ["deactivate"]
        }],
        attachEvents: [{
          type: Output,
          args: ["attach"]
        }],
        detachEvents: [{
          type: Output,
          args: ["detach"]
        }]
      });
    })();
    OutletInjector = class {
      route;
      childContexts;
      parent;
      outletData;
      constructor(route, childContexts, parent, outletData) {
        this.route = route;
        this.childContexts = childContexts;
        this.parent = parent;
        this.outletData = outletData;
      }
      get(token, notFoundValue) {
        if (token === ActivatedRoute) {
          return this.route;
        }
        if (token === ChildrenOutletContexts) {
          return this.childContexts;
        }
        if (token === ROUTER_OUTLET_DATA) {
          return this.outletData;
        }
        return this.parent.get(token, notFoundValue);
      }
    };
    INPUT_BINDER = new InjectionToken("");
    RoutedComponentInputBinder = class _RoutedComponentInputBinder {
      outletDataSubscriptions = /* @__PURE__ */ new Map();
      bindActivatedRouteToOutletComponent(outlet) {
        this.unsubscribeFromRouteData(outlet);
        this.subscribeToRouteData(outlet);
      }
      unsubscribeFromRouteData(outlet) {
        this.outletDataSubscriptions.get(outlet)?.unsubscribe();
        this.outletDataSubscriptions.delete(outlet);
      }
      subscribeToRouteData(outlet) {
        const {
          activatedRoute
        } = outlet;
        const dataSubscription = combineLatest([activatedRoute.queryParams, activatedRoute.params, activatedRoute.data]).pipe(switchMap(([queryParams, params, data], index) => {
          data = __spreadValues(__spreadValues(__spreadValues({}, queryParams), params), data);
          if (index === 0) {
            return of(data);
          }
          return Promise.resolve(data);
        })).subscribe((data) => {
          if (!outlet.isActivated || !outlet.activatedComponentRef || outlet.activatedRoute !== activatedRoute || activatedRoute.component === null) {
            this.unsubscribeFromRouteData(outlet);
            return;
          }
          const mirror = reflectComponentType(activatedRoute.component);
          if (!mirror) {
            this.unsubscribeFromRouteData(outlet);
            return;
          }
          for (const {
            templateName
          } of mirror.inputs) {
            outlet.activatedComponentRef.setInput(templateName, data[templateName]);
          }
        });
        this.outletDataSubscriptions.set(outlet, dataSubscription);
      }
      static \u0275fac = function RoutedComponentInputBinder_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _RoutedComponentInputBinder)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _RoutedComponentInputBinder,
        factory: _RoutedComponentInputBinder.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RoutedComponentInputBinder, [{
        type: Injectable
      }], null, null);
    })();
    \u0275EmptyOutletComponent = class _\u0275EmptyOutletComponent {
      static \u0275fac = function \u0275EmptyOutletComponent_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _\u0275EmptyOutletComponent)();
      };
      static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
        type: _\u0275EmptyOutletComponent,
        selectors: [["ng-component"]],
        exportAs: ["emptyRouterOutlet"],
        decls: 1,
        vars: 0,
        template: function _EmptyOutletComponent_Template(rf2, ctx) {
          if (rf2 & 1) {
            \u0275\u0275element(0, "router-outlet");
          }
        },
        dependencies: [RouterOutlet],
        encapsulation: 2
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275EmptyOutletComponent, [{
        type: Component,
        args: [{
          template: `<router-outlet/>`,
          imports: [RouterOutlet],
          // Used to avoid component ID collisions with user code.
          exportAs: "emptyRouterOutlet"
        }]
      }], null, null);
    })();
    RedirectCommand = class {
      redirectTo;
      navigationBehaviorOptions;
      constructor(redirectTo, navigationBehaviorOptions) {
        this.redirectTo = redirectTo;
        this.navigationBehaviorOptions = navigationBehaviorOptions;
      }
    };
    NAVIGATION_CANCELING_ERROR = "ngNavigationCancelingError";
    warnedAboutUnsupportedInputBinding = false;
    activateRoutes = (rootContexts, routeReuseStrategy, forwardEvent, inputBindingEnabled) => map((t2) => {
      new ActivateRoutes(routeReuseStrategy, t2.targetRouterState, t2.currentRouterState, forwardEvent, inputBindingEnabled).activate(rootContexts);
      return t2;
    });
    ActivateRoutes = class {
      routeReuseStrategy;
      futureState;
      currState;
      forwardEvent;
      inputBindingEnabled;
      constructor(routeReuseStrategy, futureState, currState, forwardEvent, inputBindingEnabled) {
        this.routeReuseStrategy = routeReuseStrategy;
        this.futureState = futureState;
        this.currState = currState;
        this.forwardEvent = forwardEvent;
        this.inputBindingEnabled = inputBindingEnabled;
      }
      activate(parentContexts) {
        const futureRoot = this.futureState._root;
        const currRoot = this.currState ? this.currState._root : null;
        this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);
        advanceActivatedRoute(this.futureState.root);
        this.activateChildRoutes(futureRoot, currRoot, parentContexts);
      }
      // De-activate the child route that are not re-used for the future state
      deactivateChildRoutes(futureNode, currNode, contexts) {
        const children = nodeChildrenAsMap(currNode);
        futureNode.children.forEach((futureChild) => {
          const childOutletName = futureChild.value.outlet;
          this.deactivateRoutes(futureChild, children[childOutletName], contexts);
          delete children[childOutletName];
        });
        Object.values(children).forEach((v) => {
          this.deactivateRouteAndItsChildren(v, contexts);
        });
      }
      deactivateRoutes(futureNode, currNode, parentContext) {
        const future = futureNode.value;
        const curr = currNode ? currNode.value : null;
        if (future === curr) {
          if (future.component) {
            const context2 = parentContext.getContext(future.outlet);
            if (context2) {
              this.deactivateChildRoutes(futureNode, currNode, context2.children);
            }
          } else {
            this.deactivateChildRoutes(futureNode, currNode, parentContext);
          }
        } else {
          if (curr) {
            this.deactivateRouteAndItsChildren(currNode, parentContext);
          }
        }
      }
      deactivateRouteAndItsChildren(route, parentContexts) {
        if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {
          this.detachAndStoreRouteSubtree(route, parentContexts);
        } else {
          this.deactivateRouteAndOutlet(route, parentContexts);
        }
      }
      detachAndStoreRouteSubtree(route, parentContexts) {
        const context2 = parentContexts.getContext(route.value.outlet);
        const contexts = context2 && route.value.component ? context2.children : parentContexts;
        const children = nodeChildrenAsMap(route);
        for (const treeNode of Object.values(children)) {
          this.deactivateRouteAndItsChildren(treeNode, contexts);
        }
        if (context2 && context2.outlet) {
          const componentRef = context2.outlet.detach();
          const contexts2 = context2.children.onOutletDeactivated();
          this.routeReuseStrategy.store(route.value.snapshot, {
            componentRef,
            route,
            contexts: contexts2
          });
        }
      }
      deactivateRouteAndOutlet(route, parentContexts) {
        const context2 = parentContexts.getContext(route.value.outlet);
        const contexts = context2 && route.value.component ? context2.children : parentContexts;
        const children = nodeChildrenAsMap(route);
        for (const treeNode of Object.values(children)) {
          this.deactivateRouteAndItsChildren(treeNode, contexts);
        }
        if (context2) {
          if (context2.outlet) {
            context2.outlet.deactivate();
            context2.children.onOutletDeactivated();
          }
          context2.attachRef = null;
          context2.route = null;
        }
      }
      activateChildRoutes(futureNode, currNode, contexts) {
        const children = nodeChildrenAsMap(currNode);
        futureNode.children.forEach((c2) => {
          this.activateRoutes(c2, children[c2.value.outlet], contexts);
          this.forwardEvent(new ActivationEnd(c2.value.snapshot));
        });
        if (futureNode.children.length) {
          this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));
        }
      }
      activateRoutes(futureNode, currNode, parentContexts) {
        const future = futureNode.value;
        const curr = currNode ? currNode.value : null;
        advanceActivatedRoute(future);
        if (future === curr) {
          if (future.component) {
            const context2 = parentContexts.getOrCreateContext(future.outlet);
            this.activateChildRoutes(futureNode, currNode, context2.children);
          } else {
            this.activateChildRoutes(futureNode, currNode, parentContexts);
          }
        } else {
          if (future.component) {
            const context2 = parentContexts.getOrCreateContext(future.outlet);
            if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {
              const stored = this.routeReuseStrategy.retrieve(future.snapshot);
              this.routeReuseStrategy.store(future.snapshot, null);
              context2.children.onOutletReAttached(stored.contexts);
              context2.attachRef = stored.componentRef;
              context2.route = stored.route.value;
              if (context2.outlet) {
                context2.outlet.attach(stored.componentRef, stored.route.value);
              }
              advanceActivatedRoute(stored.route.value);
              this.activateChildRoutes(futureNode, null, context2.children);
            } else {
              context2.attachRef = null;
              context2.route = future;
              if (context2.outlet) {
                context2.outlet.activateWith(future, context2.injector);
              }
              this.activateChildRoutes(futureNode, null, context2.children);
            }
          } else {
            this.activateChildRoutes(futureNode, null, parentContexts);
          }
        }
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          const context2 = parentContexts.getOrCreateContext(future.outlet);
          const outlet = context2.outlet;
          if (outlet && this.inputBindingEnabled && !outlet.supportsBindingToComponentInputs && !warnedAboutUnsupportedInputBinding) {
            console.warn(`'withComponentInputBinding' feature is enabled but this application is using an outlet that may not support binding to component inputs.`);
            warnedAboutUnsupportedInputBinding = true;
          }
        }
      }
    };
    CanActivate = class {
      path;
      route;
      constructor(path) {
        this.path = path;
        this.route = this.path[this.path.length - 1];
      }
    };
    CanDeactivate = class {
      component;
      route;
      constructor(component, route) {
        this.component = component;
        this.route = route;
      }
    };
    INITIAL_VALUE = /* @__PURE__ */ Symbol("INITIAL_VALUE");
    NoMatch = class {
      segmentGroup;
      constructor(segmentGroup) {
        this.segmentGroup = segmentGroup || null;
      }
    };
    AbsoluteRedirect = class extends Error {
      urlTree;
      constructor(urlTree) {
        super();
        this.urlTree = urlTree;
      }
    };
    ApplyRedirects = class {
      urlSerializer;
      urlTree;
      constructor(urlSerializer, urlTree) {
        this.urlSerializer = urlSerializer;
        this.urlTree = urlTree;
      }
      lineralizeSegments(route, urlTree) {
        let res = [];
        let c2 = urlTree.root;
        while (true) {
          res = res.concat(c2.segments);
          if (c2.numberOfChildren === 0) {
            return of(res);
          }
          if (c2.numberOfChildren > 1 || !c2.children[PRIMARY_OUTLET]) {
            return namedOutletsRedirect(`${route.redirectTo}`);
          }
          c2 = c2.children[PRIMARY_OUTLET];
        }
      }
      applyRedirectCommands(segments, redirectTo, posParams, currentSnapshot, injector) {
        return getRedirectResult(redirectTo, currentSnapshot, injector).pipe(map((redirect) => {
          if (redirect instanceof UrlTree) {
            throw new AbsoluteRedirect(redirect);
          }
          const newTree = this.applyRedirectCreateUrlTree(redirect, this.urlSerializer.parse(redirect), segments, posParams);
          if (redirect[0] === "/") {
            throw new AbsoluteRedirect(newTree);
          }
          return newTree;
        }));
      }
      applyRedirectCreateUrlTree(redirectTo, urlTree, segments, posParams) {
        const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);
        return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);
      }
      createQueryParams(redirectToParams, actualParams) {
        const res = {};
        Object.entries(redirectToParams).forEach(([k2, v]) => {
          const copySourceValue = typeof v === "string" && v[0] === ":";
          if (copySourceValue) {
            const sourceName = v.substring(1);
            res[k2] = actualParams[sourceName];
          } else {
            res[k2] = v;
          }
        });
        return res;
      }
      createSegmentGroup(redirectTo, group, segments, posParams) {
        const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);
        let children = {};
        Object.entries(group.children).forEach(([name, child]) => {
          children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);
        });
        return new UrlSegmentGroup(updatedSegments, children);
      }
      createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {
        return redirectToSegments.map((s2) => s2.path[0] === ":" ? this.findPosParam(redirectTo, s2, posParams) : this.findOrReturn(s2, actualSegments));
      }
      findPosParam(redirectTo, redirectToUrlSegment, posParams) {
        const pos = posParams[redirectToUrlSegment.path.substring(1)];
        if (!pos) throw new RuntimeError(4001, (typeof ngDevMode === "undefined" || ngDevMode) && `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);
        return pos;
      }
      findOrReturn(redirectToUrlSegment, actualSegments) {
        let idx = 0;
        for (const s2 of actualSegments) {
          if (s2.path === redirectToUrlSegment.path) {
            actualSegments.splice(idx);
            return s2;
          }
          idx++;
        }
        return redirectToUrlSegment;
      }
    };
    noMatch = {
      matched: false,
      consumedSegments: [],
      remainingSegments: [],
      parameters: {},
      positionalParamSegments: {}
    };
    NoLeftoversInUrl = class {
    };
    MAX_ALLOWED_REDIRECTS = 31;
    Recognizer = class {
      injector;
      configLoader;
      rootComponentType;
      config;
      urlTree;
      paramsInheritanceStrategy;
      urlSerializer;
      applyRedirects;
      absoluteRedirectCount = 0;
      allowRedirects = true;
      constructor(injector, configLoader, rootComponentType, config2, urlTree, paramsInheritanceStrategy, urlSerializer) {
        this.injector = injector;
        this.configLoader = configLoader;
        this.rootComponentType = rootComponentType;
        this.config = config2;
        this.urlTree = urlTree;
        this.paramsInheritanceStrategy = paramsInheritanceStrategy;
        this.urlSerializer = urlSerializer;
        this.applyRedirects = new ApplyRedirects(this.urlSerializer, this.urlTree);
      }
      noMatchError(e2) {
        return new RuntimeError(4002, typeof ngDevMode === "undefined" || ngDevMode ? `Cannot match any routes. URL Segment: '${e2.segmentGroup}'` : `'${e2.segmentGroup}'`);
      }
      recognize() {
        const rootSegmentGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;
        return this.match(rootSegmentGroup).pipe(map(({
          children,
          rootSnapshot
        }) => {
          const rootNode = new TreeNode(rootSnapshot, children);
          const routeState = new RouterStateSnapshot("", rootNode);
          const tree2 = createUrlTreeFromSnapshot(rootSnapshot, [], this.urlTree.queryParams, this.urlTree.fragment);
          tree2.queryParams = this.urlTree.queryParams;
          routeState.url = this.urlSerializer.serialize(tree2);
          return {
            state: routeState,
            tree: tree2
          };
        }));
      }
      match(rootSegmentGroup) {
        const rootSnapshot = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, Object.freeze({}), PRIMARY_OUTLET, this.rootComponentType, null, {});
        return this.processSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET, rootSnapshot).pipe(map((children) => {
          return {
            children,
            rootSnapshot
          };
        }), catchError((e2) => {
          if (e2 instanceof AbsoluteRedirect) {
            this.urlTree = e2.urlTree;
            return this.match(e2.urlTree.root);
          }
          if (e2 instanceof NoMatch) {
            throw this.noMatchError(e2);
          }
          throw e2;
        }));
      }
      processSegmentGroup(injector, config2, segmentGroup, outlet, parentRoute) {
        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
          return this.processChildren(injector, config2, segmentGroup, parentRoute);
        }
        return this.processSegment(injector, config2, segmentGroup, segmentGroup.segments, outlet, true, parentRoute).pipe(map((child) => child instanceof TreeNode ? [child] : []));
      }
      /**
       * Matches every child outlet in the `segmentGroup` to a `Route` in the config. Returns `null` if
       * we cannot find a match for _any_ of the children.
       *
       * @param config - The `Routes` to match against
       * @param segmentGroup - The `UrlSegmentGroup` whose children need to be matched against the
       *     config.
       */
      processChildren(injector, config2, segmentGroup, parentRoute) {
        const childOutlets = [];
        for (const child of Object.keys(segmentGroup.children)) {
          if (child === "primary") {
            childOutlets.unshift(child);
          } else {
            childOutlets.push(child);
          }
        }
        return from(childOutlets).pipe(concatMap((childOutlet) => {
          const child = segmentGroup.children[childOutlet];
          const sortedConfig = sortByMatchingOutlets(config2, childOutlet);
          return this.processSegmentGroup(injector, sortedConfig, child, childOutlet, parentRoute);
        }), scan((children, outletChildren) => {
          children.push(...outletChildren);
          return children;
        }), defaultIfEmpty(null), last2(), mergeMap((children) => {
          if (children === null) return noMatch$1(segmentGroup);
          const mergedChildren = mergeEmptyPathMatches(children);
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            checkOutletNameUniqueness(mergedChildren);
          }
          sortActivatedRouteSnapshots(mergedChildren);
          return of(mergedChildren);
        }));
      }
      processSegment(injector, routes2, segmentGroup, segments, outlet, allowRedirects, parentRoute) {
        return from(routes2).pipe(concatMap((r2) => {
          return this.processSegmentAgainstRoute(r2._injector ?? injector, routes2, r2, segmentGroup, segments, outlet, allowRedirects, parentRoute).pipe(catchError((e2) => {
            if (e2 instanceof NoMatch) {
              return of(null);
            }
            throw e2;
          }));
        }), first((x2) => !!x2), catchError((e2) => {
          if (isEmptyError(e2)) {
            if (noLeftoversInUrl(segmentGroup, segments, outlet)) {
              return of(new NoLeftoversInUrl());
            }
            return noMatch$1(segmentGroup);
          }
          throw e2;
        }));
      }
      processSegmentAgainstRoute(injector, routes2, route, rawSegment, segments, outlet, allowRedirects, parentRoute) {
        if (getOutlet(route) !== outlet && (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {
          return noMatch$1(rawSegment);
        }
        if (route.redirectTo === void 0) {
          return this.matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute);
        }
        if (this.allowRedirects && allowRedirects) {
          return this.expandSegmentAgainstRouteUsingRedirect(injector, rawSegment, routes2, route, segments, outlet, parentRoute);
        }
        return noMatch$1(rawSegment);
      }
      expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes2, route, segments, outlet, parentRoute) {
        const {
          matched,
          parameters,
          consumedSegments,
          positionalParamSegments,
          remainingSegments
        } = match(segmentGroup, route, segments);
        if (!matched) return noMatch$1(segmentGroup);
        if (typeof route.redirectTo === "string" && route.redirectTo[0] === "/") {
          this.absoluteRedirectCount++;
          if (this.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS) {
            if (ngDevMode) {
              throw new RuntimeError(4016, `Detected possible infinite redirect when redirecting from '${this.urlTree}' to '${route.redirectTo}'.
This is currently a dev mode only error but will become a call stack size exceeded error in production in a future major version.`);
            }
            this.allowRedirects = false;
          }
        }
        const currentSnapshot = new ActivatedRouteSnapshot(segments, parameters, Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));
        const inherited = getInherited(currentSnapshot, parentRoute, this.paramsInheritanceStrategy);
        currentSnapshot.params = Object.freeze(inherited.params);
        currentSnapshot.data = Object.freeze(inherited.data);
        const newTree$ = this.applyRedirects.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments, currentSnapshot, injector);
        return newTree$.pipe(switchMap((newTree) => this.applyRedirects.lineralizeSegments(route, newTree)), mergeMap((newSegments) => {
          return this.processSegment(injector, routes2, segmentGroup, newSegments.concat(remainingSegments), outlet, false, parentRoute);
        }));
      }
      matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute) {
        const matchResult = matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer);
        if (route.path === "**") {
          rawSegment.children = {};
        }
        return matchResult.pipe(switchMap((result) => {
          if (!result.matched) {
            return noMatch$1(rawSegment);
          }
          injector = route._injector ?? injector;
          return this.getChildConfig(injector, route, segments).pipe(switchMap(({
            routes: childConfig
          }) => {
            const childInjector = route._loadedInjector ?? injector;
            const {
              parameters,
              consumedSegments,
              remainingSegments
            } = result;
            const snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));
            const inherited = getInherited(snapshot, parentRoute, this.paramsInheritanceStrategy);
            snapshot.params = Object.freeze(inherited.params);
            snapshot.data = Object.freeze(inherited.data);
            const {
              segmentGroup,
              slicedSegments
            } = split(rawSegment, consumedSegments, remainingSegments, childConfig);
            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
              return this.processChildren(childInjector, childConfig, segmentGroup, snapshot).pipe(map((children) => {
                return new TreeNode(snapshot, children);
              }));
            }
            if (childConfig.length === 0 && slicedSegments.length === 0) {
              return of(new TreeNode(snapshot, []));
            }
            const matchedOnOutlet = getOutlet(route) === outlet;
            return this.processSegment(childInjector, childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet, true, snapshot).pipe(map((child) => {
              return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);
            }));
          }));
        }));
      }
      getChildConfig(injector, route, segments) {
        if (route.children) {
          return of({
            routes: route.children,
            injector
          });
        }
        if (route.loadChildren) {
          if (route._loadedRoutes !== void 0) {
            return of({
              routes: route._loadedRoutes,
              injector: route._loadedInjector
            });
          }
          return runCanLoadGuards(injector, route, segments, this.urlSerializer).pipe(mergeMap((shouldLoadResult) => {
            if (shouldLoadResult) {
              return this.configLoader.loadChildren(injector, route).pipe(tap((cfg) => {
                route._loadedRoutes = cfg.routes;
                route._loadedInjector = cfg.injector;
              }));
            }
            return canLoadFails(route);
          }));
        }
        return of({
          routes: [],
          injector
        });
      }
    };
    TitleStrategy = class _TitleStrategy {
      /**
       * @returns The `title` of the deepest primary route.
       */
      buildTitle(snapshot) {
        let pageTitle;
        let route = snapshot.root;
        while (route !== void 0) {
          pageTitle = this.getResolvedTitleForRoute(route) ?? pageTitle;
          route = route.children.find((child) => child.outlet === PRIMARY_OUTLET);
        }
        return pageTitle;
      }
      /**
       * Given an `ActivatedRouteSnapshot`, returns the final value of the
       * `Route.title` property, which can either be a static string or a resolved value.
       */
      getResolvedTitleForRoute(snapshot) {
        return snapshot.data[RouteTitleKey];
      }
      static \u0275fac = function TitleStrategy_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _TitleStrategy)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _TitleStrategy,
        factory: () => (() => inject2(DefaultTitleStrategy))(),
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TitleStrategy, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: () => inject2(DefaultTitleStrategy)
        }]
      }], null, null);
    })();
    DefaultTitleStrategy = class _DefaultTitleStrategy extends TitleStrategy {
      title;
      constructor(title) {
        super();
        this.title = title;
      }
      /**
       * Sets the title of the browser to the given value.
       *
       * @param title The `pageTitle` from the deepest primary route.
       */
      updateTitle(snapshot) {
        const title = this.buildTitle(snapshot);
        if (title !== void 0) {
          this.title.setTitle(title);
        }
      }
      static \u0275fac = function DefaultTitleStrategy_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DefaultTitleStrategy)(\u0275\u0275inject(Title));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _DefaultTitleStrategy,
        factory: _DefaultTitleStrategy.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultTitleStrategy, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [{
        type: Title
      }], null);
    })();
    ROUTER_CONFIGURATION = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "router config" : "", {
      providedIn: "root",
      factory: () => ({})
    });
    ROUTES = new InjectionToken(ngDevMode ? "ROUTES" : "");
    RouterConfigLoader = class _RouterConfigLoader {
      componentLoaders = /* @__PURE__ */ new WeakMap();
      childrenLoaders = /* @__PURE__ */ new WeakMap();
      onLoadStartListener;
      onLoadEndListener;
      compiler = inject2(Compiler);
      loadComponent(injector, route) {
        if (this.componentLoaders.get(route)) {
          return this.componentLoaders.get(route);
        } else if (route._loadedComponent) {
          return of(route._loadedComponent);
        }
        if (this.onLoadStartListener) {
          this.onLoadStartListener(route);
        }
        const loadRunner = wrapIntoObservable(runInInjectionContext(injector, () => route.loadComponent())).pipe(map(maybeUnwrapDefaultExport), switchMap(maybeResolveResources), tap((component) => {
          if (this.onLoadEndListener) {
            this.onLoadEndListener(route);
          }
          (typeof ngDevMode === "undefined" || ngDevMode) && assertStandalone(route.path ?? "", component);
          route._loadedComponent = component;
        }), finalize(() => {
          this.componentLoaders.delete(route);
        }));
        const loader = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());
        this.componentLoaders.set(route, loader);
        return loader;
      }
      loadChildren(parentInjector, route) {
        if (this.childrenLoaders.get(route)) {
          return this.childrenLoaders.get(route);
        } else if (route._loadedRoutes) {
          return of({
            routes: route._loadedRoutes,
            injector: route._loadedInjector
          });
        }
        if (this.onLoadStartListener) {
          this.onLoadStartListener(route);
        }
        const moduleFactoryOrRoutes$ = loadChildren(route, this.compiler, parentInjector, this.onLoadEndListener);
        const loadRunner = moduleFactoryOrRoutes$.pipe(finalize(() => {
          this.childrenLoaders.delete(route);
        }));
        const loader = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());
        this.childrenLoaders.set(route, loader);
        return loader;
      }
      static \u0275fac = function RouterConfigLoader_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _RouterConfigLoader)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _RouterConfigLoader,
        factory: _RouterConfigLoader.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterConfigLoader, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    UrlHandlingStrategy = class _UrlHandlingStrategy {
      static \u0275fac = function UrlHandlingStrategy_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _UrlHandlingStrategy)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _UrlHandlingStrategy,
        factory: () => (() => inject2(DefaultUrlHandlingStrategy))(),
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UrlHandlingStrategy, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: () => inject2(DefaultUrlHandlingStrategy)
        }]
      }], null, null);
    })();
    DefaultUrlHandlingStrategy = class _DefaultUrlHandlingStrategy {
      shouldProcessUrl(url) {
        return true;
      }
      extract(url) {
        return url;
      }
      merge(newUrlPart, wholeUrl) {
        return newUrlPart;
      }
      static \u0275fac = function DefaultUrlHandlingStrategy_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DefaultUrlHandlingStrategy)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _DefaultUrlHandlingStrategy,
        factory: _DefaultUrlHandlingStrategy.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultUrlHandlingStrategy, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    CREATE_VIEW_TRANSITION = new InjectionToken(ngDevMode ? "view transition helper" : "");
    VIEW_TRANSITION_OPTIONS = new InjectionToken(ngDevMode ? "view transition options" : "");
    NAVIGATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "navigation error handler" : "");
    NavigationTransitions = class _NavigationTransitions {
      currentNavigation = null;
      currentTransition = null;
      lastSuccessfulNavigation = null;
      /**
       * These events are used to communicate back to the Router about the state of the transition. The
       * Router wants to respond to these events in various ways. Because the `NavigationTransition`
       * class is not public, this event subject is not publicly exposed.
       */
      events = new Subject();
      /**
       * Used to abort the current transition with an error.
       */
      transitionAbortWithErrorSubject = new Subject();
      configLoader = inject2(RouterConfigLoader);
      environmentInjector = inject2(EnvironmentInjector);
      destroyRef = inject2(DestroyRef);
      urlSerializer = inject2(UrlSerializer);
      rootContexts = inject2(ChildrenOutletContexts);
      location = inject2(Location);
      inputBindingEnabled = inject2(INPUT_BINDER, {
        optional: true
      }) !== null;
      titleStrategy = inject2(TitleStrategy);
      options = inject2(ROUTER_CONFIGURATION, {
        optional: true
      }) || {};
      paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly";
      urlHandlingStrategy = inject2(UrlHandlingStrategy);
      createViewTransition = inject2(CREATE_VIEW_TRANSITION, {
        optional: true
      });
      navigationErrorHandler = inject2(NAVIGATION_ERROR_HANDLER, {
        optional: true
      });
      navigationId = 0;
      get hasRequestedNavigation() {
        return this.navigationId !== 0;
      }
      transitions;
      /**
       * Hook that enables you to pause navigation after the preactivation phase.
       * Used by `RouterModule`.
       *
       * @internal
       */
      afterPreactivation = () => of(void 0);
      /** @internal */
      rootComponentType = null;
      destroyed = false;
      constructor() {
        const onLoadStart = (r2) => this.events.next(new RouteConfigLoadStart(r2));
        const onLoadEnd = (r2) => this.events.next(new RouteConfigLoadEnd(r2));
        this.configLoader.onLoadEndListener = onLoadEnd;
        this.configLoader.onLoadStartListener = onLoadStart;
        this.destroyRef.onDestroy(() => {
          this.destroyed = true;
        });
      }
      complete() {
        this.transitions?.complete();
      }
      handleNavigationRequest(request) {
        const id2 = ++this.navigationId;
        this.transitions?.next(__spreadProps(__spreadValues({}, request), {
          extractedUrl: this.urlHandlingStrategy.extract(request.rawUrl),
          targetSnapshot: null,
          targetRouterState: null,
          guards: {
            canActivateChecks: [],
            canDeactivateChecks: []
          },
          guardsResult: null,
          abortController: new AbortController(),
          id: id2
        }));
      }
      setupNavigations(router) {
        this.transitions = new BehaviorSubject(null);
        return this.transitions.pipe(
          filter((t2) => t2 !== null),
          // Using switchMap so we cancel executing navigations when a new one comes in
          switchMap((overallTransitionState) => {
            let completedOrAborted = false;
            return of(overallTransitionState).pipe(
              switchMap((t2) => {
                if (this.navigationId > overallTransitionState.id) {
                  const cancellationReason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : "";
                  this.cancelNavigationTransition(overallTransitionState, cancellationReason, NavigationCancellationCode.SupersededByNewNavigation);
                  return EMPTY;
                }
                this.currentTransition = overallTransitionState;
                this.currentNavigation = {
                  id: t2.id,
                  initialUrl: t2.rawUrl,
                  extractedUrl: t2.extractedUrl,
                  targetBrowserUrl: typeof t2.extras.browserUrl === "string" ? this.urlSerializer.parse(t2.extras.browserUrl) : t2.extras.browserUrl,
                  trigger: t2.source,
                  extras: t2.extras,
                  previousNavigation: !this.lastSuccessfulNavigation ? null : __spreadProps(__spreadValues({}, this.lastSuccessfulNavigation), {
                    previousNavigation: null
                  }),
                  abort: () => t2.abortController.abort()
                };
                const urlTransition = !router.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl();
                const onSameUrlNavigation = t2.extras.onSameUrlNavigation ?? router.onSameUrlNavigation;
                if (!urlTransition && onSameUrlNavigation !== "reload") {
                  const reason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation to ${t2.rawUrl} was ignored because it is the same as the current Router URL.` : "";
                  this.events.next(new NavigationSkipped(t2.id, this.urlSerializer.serialize(t2.rawUrl), reason, NavigationSkippedCode.IgnoredSameUrlNavigation));
                  t2.resolve(false);
                  return EMPTY;
                }
                if (this.urlHandlingStrategy.shouldProcessUrl(t2.rawUrl)) {
                  return of(t2).pipe(
                    // Fire NavigationStart event
                    switchMap((t3) => {
                      this.events.next(new NavigationStart(t3.id, this.urlSerializer.serialize(t3.extractedUrl), t3.source, t3.restoredState));
                      if (t3.id !== this.navigationId) {
                        return EMPTY;
                      }
                      return Promise.resolve(t3);
                    }),
                    // Recognize
                    recognize(this.environmentInjector, this.configLoader, this.rootComponentType, router.config, this.urlSerializer, this.paramsInheritanceStrategy),
                    // Update URL if in `eager` update mode
                    tap((t3) => {
                      overallTransitionState.targetSnapshot = t3.targetSnapshot;
                      overallTransitionState.urlAfterRedirects = t3.urlAfterRedirects;
                      this.currentNavigation = __spreadProps(__spreadValues({}, this.currentNavigation), {
                        finalUrl: t3.urlAfterRedirects
                      });
                      const routesRecognized = new RoutesRecognized(t3.id, this.urlSerializer.serialize(t3.extractedUrl), this.urlSerializer.serialize(t3.urlAfterRedirects), t3.targetSnapshot);
                      this.events.next(routesRecognized);
                    })
                  );
                } else if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(t2.currentRawUrl)) {
                  const {
                    id: id2,
                    extractedUrl,
                    source,
                    restoredState,
                    extras
                  } = t2;
                  const navStart = new NavigationStart(id2, this.urlSerializer.serialize(extractedUrl), source, restoredState);
                  this.events.next(navStart);
                  const targetSnapshot = createEmptyState(this.rootComponentType).snapshot;
                  this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t2), {
                    targetSnapshot,
                    urlAfterRedirects: extractedUrl,
                    extras: __spreadProps(__spreadValues({}, extras), {
                      skipLocationChange: false,
                      replaceUrl: false
                    })
                  });
                  this.currentNavigation.finalUrl = extractedUrl;
                  return of(overallTransitionState);
                } else {
                  const reason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation was ignored because the UrlHandlingStrategy indicated neither the current URL ${t2.currentRawUrl} nor target URL ${t2.rawUrl} should be processed.` : "";
                  this.events.next(new NavigationSkipped(t2.id, this.urlSerializer.serialize(t2.extractedUrl), reason, NavigationSkippedCode.IgnoredByUrlHandlingStrategy));
                  t2.resolve(false);
                  return EMPTY;
                }
              }),
              // --- GUARDS ---
              tap((t2) => {
                const guardsStart = new GuardsCheckStart(t2.id, this.urlSerializer.serialize(t2.extractedUrl), this.urlSerializer.serialize(t2.urlAfterRedirects), t2.targetSnapshot);
                this.events.next(guardsStart);
              }),
              map((t2) => {
                this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t2), {
                  guards: getAllRouteGuards(t2.targetSnapshot, t2.currentSnapshot, this.rootContexts)
                });
                return overallTransitionState;
              }),
              checkGuards(this.environmentInjector, (evt) => this.events.next(evt)),
              tap((t2) => {
                overallTransitionState.guardsResult = t2.guardsResult;
                if (t2.guardsResult && typeof t2.guardsResult !== "boolean") {
                  throw redirectingNavigationError(this.urlSerializer, t2.guardsResult);
                }
                const guardsEnd = new GuardsCheckEnd(t2.id, this.urlSerializer.serialize(t2.extractedUrl), this.urlSerializer.serialize(t2.urlAfterRedirects), t2.targetSnapshot, !!t2.guardsResult);
                this.events.next(guardsEnd);
              }),
              filter((t2) => {
                if (!t2.guardsResult) {
                  this.cancelNavigationTransition(t2, "", NavigationCancellationCode.GuardRejected);
                  return false;
                }
                return true;
              }),
              // --- RESOLVE ---
              switchTap((t2) => {
                if (t2.guards.canActivateChecks.length === 0) {
                  return void 0;
                }
                return of(t2).pipe(tap((t3) => {
                  const resolveStart = new ResolveStart(t3.id, this.urlSerializer.serialize(t3.extractedUrl), this.urlSerializer.serialize(t3.urlAfterRedirects), t3.targetSnapshot);
                  this.events.next(resolveStart);
                }), switchMap((t3) => {
                  let dataResolved = false;
                  return of(t3).pipe(resolveData(this.paramsInheritanceStrategy, this.environmentInjector), tap({
                    next: () => dataResolved = true,
                    complete: () => {
                      if (!dataResolved) {
                        this.cancelNavigationTransition(t3, typeof ngDevMode === "undefined" || ngDevMode ? `At least one route resolver didn't emit any value.` : "", NavigationCancellationCode.NoDataFromResolver);
                      }
                    }
                  }));
                }), tap((t3) => {
                  const resolveEnd = new ResolveEnd(t3.id, this.urlSerializer.serialize(t3.extractedUrl), this.urlSerializer.serialize(t3.urlAfterRedirects), t3.targetSnapshot);
                  this.events.next(resolveEnd);
                }));
              }),
              // --- LOAD COMPONENTS ---
              switchTap((t2) => {
                const loadComponents = (route) => {
                  const loaders = [];
                  if (route.routeConfig?.loadComponent && !route.routeConfig._loadedComponent) {
                    const injector = getClosestRouteInjector(route) ?? this.environmentInjector;
                    loaders.push(this.configLoader.loadComponent(injector, route.routeConfig).pipe(tap((loadedComponent) => {
                      route.component = loadedComponent;
                    }), map(() => void 0)));
                  }
                  for (const child of route.children) {
                    loaders.push(...loadComponents(child));
                  }
                  return loaders;
                };
                return combineLatest(loadComponents(t2.targetSnapshot.root)).pipe(defaultIfEmpty(null), take(1));
              }),
              switchTap(() => this.afterPreactivation()),
              switchMap(() => {
                const {
                  currentSnapshot,
                  targetSnapshot
                } = overallTransitionState;
                const viewTransitionStarted = this.createViewTransition?.(this.environmentInjector, currentSnapshot.root, targetSnapshot.root);
                return viewTransitionStarted ? from(viewTransitionStarted).pipe(map(() => overallTransitionState)) : of(overallTransitionState);
              }),
              map((t2) => {
                const targetRouterState = createRouterState(router.routeReuseStrategy, t2.targetSnapshot, t2.currentRouterState);
                this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t2), {
                  targetRouterState
                });
                this.currentNavigation.targetRouterState = targetRouterState;
                return overallTransitionState;
              }),
              tap(() => {
                this.events.next(new BeforeActivateRoutes());
              }),
              activateRoutes(this.rootContexts, router.routeReuseStrategy, (evt) => this.events.next(evt), this.inputBindingEnabled),
              // Ensure that if some observable used to drive the transition doesn't
              // complete, the navigation still finalizes This should never happen, but
              // this is done as a safety measure to avoid surfacing this error (#49567).
              take(1),
              takeUntil(new Observable((subscriber) => {
                const abortSignal = overallTransitionState.abortController.signal;
                const handler = () => subscriber.next();
                abortSignal.addEventListener("abort", handler);
                return () => abortSignal.removeEventListener("abort", handler);
              }).pipe(
                // Ignore aborts if we are already completed, canceled, or are in the activation stage (we have targetRouterState)
                filter(() => !completedOrAborted && !overallTransitionState.targetRouterState),
                tap(() => {
                  this.cancelNavigationTransition(overallTransitionState, overallTransitionState.abortController.signal.reason + "", NavigationCancellationCode.Aborted);
                })
              )),
              tap({
                next: (t2) => {
                  completedOrAborted = true;
                  this.lastSuccessfulNavigation = this.currentNavigation;
                  this.events.next(new NavigationEnd(t2.id, this.urlSerializer.serialize(t2.extractedUrl), this.urlSerializer.serialize(t2.urlAfterRedirects)));
                  this.titleStrategy?.updateTitle(t2.targetRouterState.snapshot);
                  t2.resolve(true);
                },
                complete: () => {
                  completedOrAborted = true;
                }
              }),
              // There used to be a lot more logic happening directly within the
              // transition Observable. Some of this logic has been refactored out to
              // other places but there may still be errors that happen there. This gives
              // us a way to cancel the transition from the outside. This may also be
              // required in the future to support something like the abort signal of the
              // Navigation API where the navigation gets aborted from outside the
              // transition.
              takeUntil(this.transitionAbortWithErrorSubject.pipe(tap((err) => {
                throw err;
              }))),
              finalize(() => {
                if (!completedOrAborted) {
                  const cancelationReason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : "";
                  this.cancelNavigationTransition(overallTransitionState, cancelationReason, NavigationCancellationCode.SupersededByNewNavigation);
                }
                if (this.currentTransition?.id === overallTransitionState.id) {
                  this.currentNavigation = null;
                  this.currentTransition = null;
                }
              }),
              catchError((e2) => {
                if (this.destroyed) {
                  overallTransitionState.resolve(false);
                  return EMPTY;
                }
                completedOrAborted = true;
                if (isNavigationCancelingError(e2)) {
                  this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e2.message, e2.cancellationCode));
                  if (!isRedirectingNavigationCancelingError(e2)) {
                    overallTransitionState.resolve(false);
                  } else {
                    this.events.next(new RedirectRequest(e2.url, e2.navigationBehaviorOptions));
                  }
                } else {
                  const navigationError = new NavigationError(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e2, overallTransitionState.targetSnapshot ?? void 0);
                  try {
                    const navigationErrorHandlerResult = runInInjectionContext(this.environmentInjector, () => this.navigationErrorHandler?.(navigationError));
                    if (navigationErrorHandlerResult instanceof RedirectCommand) {
                      const {
                        message,
                        cancellationCode
                      } = redirectingNavigationError(this.urlSerializer, navigationErrorHandlerResult);
                      this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), message, cancellationCode));
                      this.events.next(new RedirectRequest(navigationErrorHandlerResult.redirectTo, navigationErrorHandlerResult.navigationBehaviorOptions));
                    } else {
                      this.events.next(navigationError);
                      throw e2;
                    }
                  } catch (ee2) {
                    if (this.options.resolveNavigationPromiseOnError) {
                      overallTransitionState.resolve(false);
                    } else {
                      overallTransitionState.reject(ee2);
                    }
                  }
                }
                return EMPTY;
              })
            );
          })
        );
      }
      cancelNavigationTransition(t2, reason, code) {
        const navCancel = new NavigationCancel(t2.id, this.urlSerializer.serialize(t2.extractedUrl), reason, code);
        this.events.next(navCancel);
        t2.resolve(false);
      }
      /**
       * @returns Whether we're navigating to somewhere that is not what the Router is
       * currently set to.
       */
      isUpdatingInternalState() {
        return this.currentTransition?.extractedUrl.toString() !== this.currentTransition?.currentUrlTree.toString();
      }
      /**
       * @returns Whether we're updating the browser URL to something new (navigation is going
       * to somewhere not displayed in the URL bar and we will update the URL
       * bar if navigation succeeds).
       */
      isUpdatedBrowserUrl() {
        const currentBrowserUrl = this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(true)));
        const targetBrowserUrl = this.currentNavigation?.targetBrowserUrl ?? this.currentNavigation?.extractedUrl;
        return currentBrowserUrl.toString() !== targetBrowserUrl?.toString() && !this.currentNavigation?.extras.skipLocationChange;
      }
      static \u0275fac = function NavigationTransitions_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NavigationTransitions)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _NavigationTransitions,
        factory: _NavigationTransitions.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationTransitions, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [], null);
    })();
    RouteReuseStrategy = class _RouteReuseStrategy {
      static \u0275fac = function RouteReuseStrategy_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _RouteReuseStrategy)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _RouteReuseStrategy,
        factory: () => (() => inject2(DefaultRouteReuseStrategy))(),
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouteReuseStrategy, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: () => inject2(DefaultRouteReuseStrategy)
        }]
      }], null, null);
    })();
    BaseRouteReuseStrategy = class {
      /**
       * Whether the given route should detach for later reuse.
       * Always returns false for `BaseRouteReuseStrategy`.
       * */
      shouldDetach(route) {
        return false;
      }
      /**
       * A no-op; the route is never stored since this strategy never detaches routes for later re-use.
       */
      store(route, detachedTree) {
      }
      /** Returns `false`, meaning the route (and its subtree) is never reattached */
      shouldAttach(route) {
        return false;
      }
      /** Returns `null` because this strategy does not store routes for later re-use. */
      retrieve(route) {
        return null;
      }
      /**
       * Determines if a route should be reused.
       * This strategy returns `true` when the future route config and current route config are
       * identical.
       */
      shouldReuseRoute(future, curr) {
        return future.routeConfig === curr.routeConfig;
      }
    };
    DefaultRouteReuseStrategy = class _DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275DefaultRouteReuseStrategy_BaseFactory;
        return function DefaultRouteReuseStrategy_Factory(__ngFactoryType__) {
          return (\u0275DefaultRouteReuseStrategy_BaseFactory || (\u0275DefaultRouteReuseStrategy_BaseFactory = \u0275\u0275getInheritedFactory(_DefaultRouteReuseStrategy)))(__ngFactoryType__ || _DefaultRouteReuseStrategy);
        };
      })();
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _DefaultRouteReuseStrategy,
        factory: _DefaultRouteReuseStrategy.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultRouteReuseStrategy, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    StateManager = class _StateManager {
      urlSerializer = inject2(UrlSerializer);
      options = inject2(ROUTER_CONFIGURATION, {
        optional: true
      }) || {};
      canceledNavigationResolution = this.options.canceledNavigationResolution || "replace";
      location = inject2(Location);
      urlHandlingStrategy = inject2(UrlHandlingStrategy);
      urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred";
      currentUrlTree = new UrlTree();
      /**
       * Returns the currently activated `UrlTree`.
       *
       * This `UrlTree` shows only URLs that the `Router` is configured to handle (through
       * `UrlHandlingStrategy`).
       *
       * The value is set after finding the route config tree to activate but before activating the
       * route.
       */
      getCurrentUrlTree() {
        return this.currentUrlTree;
      }
      rawUrlTree = this.currentUrlTree;
      /**
       * Returns a `UrlTree` that is represents what the browser is actually showing.
       *
       * In the life of a navigation transition:
       * 1. When a navigation begins, the raw `UrlTree` is updated to the full URL that's being
       * navigated to.
       * 2. During a navigation, redirects are applied, which might only apply to _part_ of the URL (due
       * to `UrlHandlingStrategy`).
       * 3. Just before activation, the raw `UrlTree` is updated to include the redirects on top of the
       * original raw URL.
       *
       * Note that this is _only_ here to support `UrlHandlingStrategy.extract` and
       * `UrlHandlingStrategy.shouldProcessUrl`. Without those APIs, the current `UrlTree` would not
       * deviated from the raw `UrlTree`.
       *
       * For `extract`, a raw `UrlTree` is needed because `extract` may only return part
       * of the navigation URL. Thus, the current `UrlTree` may only represent _part_ of the browser
       * URL. When a navigation gets cancelled and the router needs to reset the URL or a new navigation
       * occurs, it needs to know the _whole_ browser URL, not just the part handled by
       * `UrlHandlingStrategy`.
       * For `shouldProcessUrl`, when the return is `false`, the router ignores the navigation but
       * still updates the raw `UrlTree` with the assumption that the navigation was caused by the
       * location change listener due to a URL update by the AngularJS router. In this case, the router
       * still need to know what the browser's URL is for future navigations.
       */
      getRawUrlTree() {
        return this.rawUrlTree;
      }
      createBrowserPath({
        finalUrl,
        initialUrl,
        targetBrowserUrl
      }) {
        const rawUrl = finalUrl !== void 0 ? this.urlHandlingStrategy.merge(finalUrl, initialUrl) : initialUrl;
        const url = targetBrowserUrl ?? rawUrl;
        const path = url instanceof UrlTree ? this.urlSerializer.serialize(url) : url;
        return path;
      }
      commitTransition({
        targetRouterState,
        finalUrl,
        initialUrl
      }) {
        if (finalUrl && targetRouterState) {
          this.currentUrlTree = finalUrl;
          this.rawUrlTree = this.urlHandlingStrategy.merge(finalUrl, initialUrl);
          this.routerState = targetRouterState;
        } else {
          this.rawUrlTree = initialUrl;
        }
      }
      routerState = createEmptyState(null);
      /** Returns the current RouterState. */
      getRouterState() {
        return this.routerState;
      }
      stateMemento = this.createStateMemento();
      updateStateMemento() {
        this.stateMemento = this.createStateMemento();
      }
      createStateMemento() {
        return {
          rawUrlTree: this.rawUrlTree,
          currentUrlTree: this.currentUrlTree,
          routerState: this.routerState
        };
      }
      resetInternalState({
        finalUrl
      }) {
        this.routerState = this.stateMemento.routerState;
        this.currentUrlTree = this.stateMemento.currentUrlTree;
        this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, finalUrl ?? this.rawUrlTree);
      }
      static \u0275fac = function StateManager_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _StateManager)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _StateManager,
        factory: () => (() => inject2(HistoryStateManager))(),
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StateManager, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: () => inject2(HistoryStateManager)
        }]
      }], null, null);
    })();
    HistoryStateManager = class _HistoryStateManager extends StateManager {
      /**
       * The id of the currently active page in the router.
       * Updated to the transition's target id on a successful navigation.
       *
       * This is used to track what page the router last activated. When an attempted navigation fails,
       * the router can then use this to compute how to restore the state back to the previously active
       * page.
       */
      currentPageId = 0;
      lastSuccessfulId = -1;
      restoredState() {
        return this.location.getState();
      }
      /**
       * The ɵrouterPageId of whatever page is currently active in the browser history. This is
       * important for computing the target page id for new navigations because we need to ensure each
       * page id in the browser history is 1 more than the previous entry.
       */
      get browserPageId() {
        if (this.canceledNavigationResolution !== "computed") {
          return this.currentPageId;
        }
        return this.restoredState()?.\u0275routerPageId ?? this.currentPageId;
      }
      registerNonRouterCurrentEntryChangeListener(listener) {
        return this.location.subscribe((event) => {
          if (event["type"] === "popstate") {
            setTimeout(() => {
              listener(event["url"], event.state, "popstate");
            });
          }
        });
      }
      handleRouterEvent(e2, currentTransition) {
        if (e2 instanceof NavigationStart) {
          this.updateStateMemento();
        } else if (e2 instanceof NavigationSkipped) {
          this.commitTransition(currentTransition);
        } else if (e2 instanceof RoutesRecognized) {
          if (this.urlUpdateStrategy === "eager") {
            if (!currentTransition.extras.skipLocationChange) {
              this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);
            }
          }
        } else if (e2 instanceof BeforeActivateRoutes) {
          this.commitTransition(currentTransition);
          if (this.urlUpdateStrategy === "deferred" && !currentTransition.extras.skipLocationChange) {
            this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);
          }
        } else if (e2 instanceof NavigationCancel && e2.code !== NavigationCancellationCode.SupersededByNewNavigation && e2.code !== NavigationCancellationCode.Redirect) {
          this.restoreHistory(currentTransition);
        } else if (e2 instanceof NavigationError) {
          this.restoreHistory(currentTransition, true);
        } else if (e2 instanceof NavigationEnd) {
          this.lastSuccessfulId = e2.id;
          this.currentPageId = this.browserPageId;
        }
      }
      setBrowserUrl(path, {
        extras,
        id: id2
      }) {
        const {
          replaceUrl,
          state
        } = extras;
        if (this.location.isCurrentPathEqualTo(path) || !!replaceUrl) {
          const currentBrowserPageId = this.browserPageId;
          const newState = __spreadValues(__spreadValues({}, state), this.generateNgRouterState(id2, currentBrowserPageId));
          this.location.replaceState(path, "", newState);
        } else {
          const newState = __spreadValues(__spreadValues({}, state), this.generateNgRouterState(id2, this.browserPageId + 1));
          this.location.go(path, "", newState);
        }
      }
      /**
       * Performs the necessary rollback action to restore the browser URL to the
       * state before the transition.
       */
      restoreHistory(navigation, restoringFromCaughtError = false) {
        if (this.canceledNavigationResolution === "computed") {
          const currentBrowserPageId = this.browserPageId;
          const targetPagePosition = this.currentPageId - currentBrowserPageId;
          if (targetPagePosition !== 0) {
            this.location.historyGo(targetPagePosition);
          } else if (this.getCurrentUrlTree() === navigation.finalUrl && targetPagePosition === 0) {
            this.resetInternalState(navigation);
            this.resetUrlToCurrentUrlTree();
          } else ;
        } else if (this.canceledNavigationResolution === "replace") {
          if (restoringFromCaughtError) {
            this.resetInternalState(navigation);
          }
          this.resetUrlToCurrentUrlTree();
        }
      }
      resetUrlToCurrentUrlTree() {
        this.location.replaceState(this.urlSerializer.serialize(this.getRawUrlTree()), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));
      }
      generateNgRouterState(navigationId, routerPageId) {
        if (this.canceledNavigationResolution === "computed") {
          return {
            navigationId,
            \u0275routerPageId: routerPageId
          };
        }
        return {
          navigationId
        };
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275HistoryStateManager_BaseFactory;
        return function HistoryStateManager_Factory(__ngFactoryType__) {
          return (\u0275HistoryStateManager_BaseFactory || (\u0275HistoryStateManager_BaseFactory = \u0275\u0275getInheritedFactory(_HistoryStateManager)))(__ngFactoryType__ || _HistoryStateManager);
        };
      })();
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _HistoryStateManager,
        factory: _HistoryStateManager.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HistoryStateManager, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    exactMatchOptions = {
      paths: "exact",
      fragment: "ignored",
      matrixParams: "ignored",
      queryParams: "exact"
    };
    subsetMatchOptions = {
      paths: "subset",
      fragment: "ignored",
      matrixParams: "ignored",
      queryParams: "subset"
    };
    Router = class _Router {
      get currentUrlTree() {
        return this.stateManager.getCurrentUrlTree();
      }
      get rawUrlTree() {
        return this.stateManager.getRawUrlTree();
      }
      disposed = false;
      nonRouterCurrentEntryChangeSubscription;
      console = inject2(Console);
      stateManager = inject2(StateManager);
      options = inject2(ROUTER_CONFIGURATION, {
        optional: true
      }) || {};
      pendingTasks = inject2(PendingTasksInternal);
      urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred";
      navigationTransitions = inject2(NavigationTransitions);
      urlSerializer = inject2(UrlSerializer);
      location = inject2(Location);
      urlHandlingStrategy = inject2(UrlHandlingStrategy);
      injector = inject2(EnvironmentInjector);
      /**
       * The private `Subject` type for the public events exposed in the getter. This is used internally
       * to push events to. The separate field allows us to expose separate types in the public API
       * (i.e., an Observable rather than the Subject).
       */
      _events = new Subject();
      /**
       * An event stream for routing events.
       */
      get events() {
        return this._events;
      }
      /**
       * The current state of routing in this NgModule.
       */
      get routerState() {
        return this.stateManager.getRouterState();
      }
      /**
       * True if at least one navigation event has occurred,
       * false otherwise.
       */
      navigated = false;
      /**
       * A strategy for re-using routes.
       *
       * @deprecated Configure using `providers` instead:
       *   `{provide: RouteReuseStrategy, useClass: MyStrategy}`.
       */
      routeReuseStrategy = inject2(RouteReuseStrategy);
      /**
       * How to handle a navigation request to the current URL.
       *
       *
       * @deprecated Configure this through `provideRouter` or `RouterModule.forRoot` instead.
       * @see {@link withRouterConfig}
       * @see {@link provideRouter}
       * @see {@link RouterModule}
       */
      onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore";
      config = inject2(ROUTES, {
        optional: true
      })?.flat() ?? [];
      /**
       * Indicates whether the application has opted in to binding Router data to component inputs.
       *
       * This option is enabled by the `withComponentInputBinding` feature of `provideRouter` or
       * `bindToComponentInputs` in the `ExtraOptions` of `RouterModule.forRoot`.
       */
      componentInputBindingEnabled = !!inject2(INPUT_BINDER, {
        optional: true
      });
      constructor() {
        this.resetConfig(this.config);
        this.navigationTransitions.setupNavigations(this).subscribe({
          error: (e2) => {
            this.console.warn(ngDevMode ? `Unhandled Navigation Error: ${e2}` : e2);
          }
        });
        this.subscribeToNavigationEvents();
      }
      eventsSubscription = new Subscription();
      subscribeToNavigationEvents() {
        const subscription = this.navigationTransitions.events.subscribe((e2) => {
          try {
            const currentTransition = this.navigationTransitions.currentTransition;
            const currentNavigation = this.navigationTransitions.currentNavigation;
            if (currentTransition !== null && currentNavigation !== null) {
              this.stateManager.handleRouterEvent(e2, currentNavigation);
              if (e2 instanceof NavigationCancel && e2.code !== NavigationCancellationCode.Redirect && e2.code !== NavigationCancellationCode.SupersededByNewNavigation) {
                this.navigated = true;
              } else if (e2 instanceof NavigationEnd) {
                this.navigated = true;
              } else if (e2 instanceof RedirectRequest) {
                const opts = e2.navigationBehaviorOptions;
                const mergedTree = this.urlHandlingStrategy.merge(e2.url, currentTransition.currentRawUrl);
                const extras = __spreadValues({
                  browserUrl: currentTransition.extras.browserUrl,
                  info: currentTransition.extras.info,
                  skipLocationChange: currentTransition.extras.skipLocationChange,
                  // The URL is already updated at this point if we have 'eager' URL
                  // updates or if the navigation was triggered by the browser (back
                  // button, URL bar, etc). We want to replace that item in history
                  // if the navigation is rejected.
                  replaceUrl: currentTransition.extras.replaceUrl || this.urlUpdateStrategy === "eager" || isBrowserTriggeredNavigation(currentTransition.source)
                }, opts);
                this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras, {
                  resolve: currentTransition.resolve,
                  reject: currentTransition.reject,
                  promise: currentTransition.promise
                });
              }
            }
            if (isPublicRouterEvent(e2)) {
              this._events.next(e2);
            }
          } catch (e3) {
            this.navigationTransitions.transitionAbortWithErrorSubject.next(e3);
          }
        });
        this.eventsSubscription.add(subscription);
      }
      /** @internal */
      resetRootComponentType(rootComponentType) {
        this.routerState.root.component = rootComponentType;
        this.navigationTransitions.rootComponentType = rootComponentType;
      }
      /**
       * Sets up the location change listener and performs the initial navigation.
       */
      initialNavigation() {
        this.setUpLocationChangeListener();
        if (!this.navigationTransitions.hasRequestedNavigation) {
          this.navigateToSyncWithBrowser(this.location.path(true), IMPERATIVE_NAVIGATION, this.stateManager.restoredState());
        }
      }
      /**
       * Sets up the location change listener. This listener detects navigations triggered from outside
       * the Router (the browser back/forward buttons, for example) and schedules a corresponding Router
       * navigation so that the correct events, guards, etc. are triggered.
       */
      setUpLocationChangeListener() {
        this.nonRouterCurrentEntryChangeSubscription ??= this.stateManager.registerNonRouterCurrentEntryChangeListener((url, state, source) => {
          this.navigateToSyncWithBrowser(url, source, state);
        });
      }
      /**
       * Schedules a router navigation to synchronize Router state with the browser state.
       *
       * This is done as a response to a popstate event and the initial navigation. These
       * two scenarios represent times when the browser URL/state has been updated and
       * the Router needs to respond to ensure its internal state matches.
       */
      navigateToSyncWithBrowser(url, source, state) {
        const extras = {
          replaceUrl: true
        };
        const restoredState = state?.navigationId ? state : null;
        if (state) {
          const stateCopy = __spreadValues({}, state);
          delete stateCopy.navigationId;
          delete stateCopy.\u0275routerPageId;
          if (Object.keys(stateCopy).length !== 0) {
            extras.state = stateCopy;
          }
        }
        const urlTree = this.parseUrl(url);
        this.scheduleNavigation(urlTree, source, restoredState, extras).catch((e2) => {
          if (this.disposed) {
            return;
          }
          this.injector.get(INTERNAL_APPLICATION_ERROR_HANDLER)(e2);
        });
      }
      /** The current URL. */
      get url() {
        return this.serializeUrl(this.currentUrlTree);
      }
      /**
       * Returns the current `Navigation` object when the router is navigating,
       * and `null` when idle.
       */
      getCurrentNavigation() {
        return this.navigationTransitions.currentNavigation;
      }
      /**
       * The `Navigation` object of the most recent navigation to succeed and `null` if there
       *     has not been a successful navigation yet.
       */
      get lastSuccessfulNavigation() {
        return this.navigationTransitions.lastSuccessfulNavigation;
      }
      /**
       * Resets the route configuration used for navigation and generating links.
       *
       * @param config The route array for the new configuration.
       *
       * @usageNotes
       *
       * ```ts
       * router.resetConfig([
       *  { path: 'team/:id', component: TeamCmp, children: [
       *    { path: 'simple', component: SimpleCmp },
       *    { path: 'user/:name', component: UserCmp }
       *  ]}
       * ]);
       * ```
       */
      resetConfig(config2) {
        (typeof ngDevMode === "undefined" || ngDevMode) && validateConfig(config2);
        this.config = config2.map(standardizeConfig);
        this.navigated = false;
      }
      /** @docs-private */
      ngOnDestroy() {
        this.dispose();
      }
      /** Disposes of the router. */
      dispose() {
        this._events.unsubscribe();
        this.navigationTransitions.complete();
        if (this.nonRouterCurrentEntryChangeSubscription) {
          this.nonRouterCurrentEntryChangeSubscription.unsubscribe();
          this.nonRouterCurrentEntryChangeSubscription = void 0;
        }
        this.disposed = true;
        this.eventsSubscription.unsubscribe();
      }
      /**
       * Appends URL segments to the current URL tree to create a new URL tree.
       *
       * @param commands An array of URL fragments with which to construct the new URL tree.
       * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path
       * segments, followed by the parameters for each segment.
       * The fragments are applied to the current URL tree or the one provided  in the `relativeTo`
       * property of the options object, if supplied.
       * @param navigationExtras Options that control the navigation strategy.
       * @returns The new URL tree.
       *
       * @usageNotes
       *
       * ```
       * // create /team/33/user/11
       * router.createUrlTree(['/team', 33, 'user', 11]);
       *
       * // create /team/33;expand=true/user/11
       * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);
       *
       * // you can collapse static segments like this (this works only with the first passed-in value):
       * router.createUrlTree(['/team/33/user', userId]);
       *
       * // If the first segment can contain slashes, and you do not want the router to split it,
       * // you can do the following:
       * router.createUrlTree([{segmentPath: '/one/two'}]);
       *
       * // create /team/33/(user/11//right:chat)
       * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);
       *
       * // remove the right secondary node
       * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);
       *
       * // assuming the current url is `/team/33/user/11` and the route points to `user/11`
       *
       * // navigate to /team/33/user/11/details
       * router.createUrlTree(['details'], {relativeTo: route});
       *
       * // navigate to /team/33/user/22
       * router.createUrlTree(['../22'], {relativeTo: route});
       *
       * // navigate to /team/44/user/22
       * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});
       *
       * Note that a value of `null` or `undefined` for `relativeTo` indicates that the
       * tree should be created relative to the root.
       * ```
       */
      createUrlTree(commands, navigationExtras = {}) {
        const {
          relativeTo,
          queryParams,
          fragment,
          queryParamsHandling,
          preserveFragment
        } = navigationExtras;
        const f2 = preserveFragment ? this.currentUrlTree.fragment : fragment;
        let q2 = null;
        switch (queryParamsHandling ?? this.options.defaultQueryParamsHandling) {
          case "merge":
            q2 = __spreadValues(__spreadValues({}, this.currentUrlTree.queryParams), queryParams);
            break;
          case "preserve":
            q2 = this.currentUrlTree.queryParams;
            break;
          default:
            q2 = queryParams || null;
        }
        if (q2 !== null) {
          q2 = this.removeEmptyProps(q2);
        }
        let relativeToUrlSegmentGroup;
        try {
          const relativeToSnapshot = relativeTo ? relativeTo.snapshot : this.routerState.snapshot.root;
          relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeToSnapshot);
        } catch (e2) {
          if (typeof commands[0] !== "string" || commands[0][0] !== "/") {
            commands = [];
          }
          relativeToUrlSegmentGroup = this.currentUrlTree.root;
        }
        return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, q2, f2 ?? null);
      }
      /**
       * Navigates to a view using an absolute route path.
       *
       * @param url An absolute path for a defined route. The function does not apply any delta to the
       *     current URL.
       * @param extras An object containing properties that modify the navigation strategy.
       *
       * @returns A Promise that resolves to 'true' when navigation succeeds,
       * to 'false' when navigation fails, or is rejected on error.
       *
       * @usageNotes
       *
       * The following calls request navigation to an absolute path.
       *
       * ```ts
       * router.navigateByUrl("/team/33/user/11");
       *
       * // Navigate without updating the URL
       * router.navigateByUrl("/team/33/user/11", { skipLocationChange: true });
       * ```
       *
       * @see [Routing and Navigation guide](guide/routing/common-router-tasks)
       *
       */
      navigateByUrl(url, extras = {
        skipLocationChange: false
      }) {
        const urlTree = isUrlTree(url) ? url : this.parseUrl(url);
        const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);
        return this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras);
      }
      /**
       * Navigate based on the provided array of commands and a starting point.
       * If no starting route is provided, the navigation is absolute.
       *
       * @param commands An array of URL fragments with which to construct the target URL.
       * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path
       * segments, followed by the parameters for each segment.
       * The fragments are applied to the current URL or the one provided  in the `relativeTo` property
       * of the options object, if supplied.
       * @param extras An options object that determines how the URL should be constructed or
       *     interpreted.
       *
       * @returns A Promise that resolves to `true` when navigation succeeds, or `false` when navigation
       *     fails. The Promise is rejected when an error occurs if `resolveNavigationPromiseOnError` is
       * not `true`.
       *
       * @usageNotes
       *
       * The following calls request navigation to a dynamic route path relative to the current URL.
       *
       * ```ts
       * router.navigate(['team', 33, 'user', 11], {relativeTo: route});
       *
       * // Navigate without updating the URL, overriding the default behavior
       * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});
       * ```
       *
       * @see [Routing and Navigation guide](guide/routing/common-router-tasks)
       *
       */
      navigate(commands, extras = {
        skipLocationChange: false
      }) {
        validateCommands(commands);
        return this.navigateByUrl(this.createUrlTree(commands, extras), extras);
      }
      /** Serializes a `UrlTree` into a string */
      serializeUrl(url) {
        return this.urlSerializer.serialize(url);
      }
      /** Parses a string into a `UrlTree` */
      parseUrl(url) {
        try {
          return this.urlSerializer.parse(url);
        } catch {
          return this.urlSerializer.parse("/");
        }
      }
      isActive(url, matchOptions) {
        let options;
        if (matchOptions === true) {
          options = __spreadValues({}, exactMatchOptions);
        } else if (matchOptions === false) {
          options = __spreadValues({}, subsetMatchOptions);
        } else {
          options = matchOptions;
        }
        if (isUrlTree(url)) {
          return containsTree(this.currentUrlTree, url, options);
        }
        const urlTree = this.parseUrl(url);
        return containsTree(this.currentUrlTree, urlTree, options);
      }
      removeEmptyProps(params) {
        return Object.entries(params).reduce((result, [key, value]) => {
          if (value !== null && value !== void 0) {
            result[key] = value;
          }
          return result;
        }, {});
      }
      scheduleNavigation(rawUrl, source, restoredState, extras, priorPromise) {
        if (this.disposed) {
          return Promise.resolve(false);
        }
        let resolve;
        let reject;
        let promise;
        if (priorPromise) {
          resolve = priorPromise.resolve;
          reject = priorPromise.reject;
          promise = priorPromise.promise;
        } else {
          promise = new Promise((res, rej) => {
            resolve = res;
            reject = rej;
          });
        }
        const taskId = this.pendingTasks.add();
        afterNextNavigation(this, () => {
          queueMicrotask(() => this.pendingTasks.remove(taskId));
        });
        this.navigationTransitions.handleNavigationRequest({
          source,
          restoredState,
          currentUrlTree: this.currentUrlTree,
          currentRawUrl: this.currentUrlTree,
          rawUrl,
          extras,
          resolve,
          reject,
          promise,
          currentSnapshot: this.routerState.snapshot,
          currentRouterState: this.routerState
        });
        return promise.catch((e2) => {
          return Promise.reject(e2);
        });
      }
      static \u0275fac = function Router_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Router)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _Router,
        factory: _Router.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Router, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [], null);
    })();
  }
});

// node_modules/@angular/router/fesm2022/router_module.mjs
function isActiveMatchOptions(options) {
  return !!options.paths;
}
function provideRouter(routes2, ...features) {
  return makeEnvironmentProviders([{
    provide: ROUTES,
    multi: true,
    useValue: routes2
  }, typeof ngDevMode === "undefined" || ngDevMode ? {
    provide: ROUTER_IS_PROVIDED,
    useValue: true
  } : [], {
    provide: ActivatedRoute,
    useFactory: rootRoute,
    deps: [Router]
  }, {
    provide: APP_BOOTSTRAP_LISTENER,
    multi: true,
    useFactory: getBootstrapListener
  }, features.map((feature) => feature.\u0275providers)]);
}
function rootRoute(router) {
  return router.routerState.root;
}
function routerFeature(kind, providers) {
  return {
    \u0275kind: kind,
    \u0275providers: providers
  };
}
function getBootstrapListener() {
  const injector = inject2(Injector);
  return (bootstrappedComponentRef) => {
    const ref = injector.get(ApplicationRef);
    if (bootstrappedComponentRef !== ref.components[0]) {
      return;
    }
    const router = injector.get(Router);
    const bootstrapDone = injector.get(BOOTSTRAP_DONE);
    if (injector.get(INITIAL_NAVIGATION) === 1) {
      router.initialNavigation();
    }
    injector.get(ROUTER_PRELOADER, null, {
      optional: true
    })?.setUpPreloading();
    injector.get(ROUTER_SCROLLER, null, {
      optional: true
    })?.init();
    router.resetRootComponentType(ref.componentTypes[0]);
    if (!bootstrapDone.closed) {
      bootstrapDone.next();
      bootstrapDone.complete();
      bootstrapDone.unsubscribe();
    }
  };
}
function withEnabledBlockingInitialNavigation() {
  const providers = [{
    provide: INITIAL_NAVIGATION,
    useValue: 0
    /* InitialNavigation.EnabledBlocking */
  }, provideAppInitializer(() => {
    const injector = inject2(Injector);
    const locationInitialized = injector.get(LOCATION_INITIALIZED, Promise.resolve());
    return locationInitialized.then(() => {
      return new Promise((resolve) => {
        const router = injector.get(Router);
        const bootstrapDone = injector.get(BOOTSTRAP_DONE);
        afterNextNavigation(router, () => {
          resolve(true);
        });
        injector.get(NavigationTransitions).afterPreactivation = () => {
          resolve(true);
          return bootstrapDone.closed ? of(void 0) : bootstrapDone;
        };
        router.initialNavigation();
      });
    });
  })];
  return routerFeature(2, providers);
}
function withDisabledInitialNavigation() {
  const providers = [provideAppInitializer(() => {
    inject2(Router).setUpLocationChangeListener();
  }), {
    provide: INITIAL_NAVIGATION,
    useValue: 2
    /* InitialNavigation.Disabled */
  }];
  return routerFeature(3, providers);
}
function withDebugTracing() {
  let providers = [];
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    providers = [{
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const router = inject2(Router);
        return () => router.events.subscribe((e2) => {
          console.group?.(`Router Event: ${e2.constructor.name}`);
          console.log(stringifyEvent(e2));
          console.log(e2);
          console.groupEnd?.();
        });
      }
    }];
  } else {
    providers = [];
  }
  return routerFeature(1, providers);
}
function withPreloading(preloadingStrategy) {
  const providers = [{
    provide: ROUTER_PRELOADER,
    useExisting: RouterPreloader
  }, {
    provide: PreloadingStrategy,
    useExisting: preloadingStrategy
  }];
  return routerFeature(0, providers);
}
function withComponentInputBinding() {
  const providers = [RoutedComponentInputBinder, {
    provide: INPUT_BINDER,
    useExisting: RoutedComponentInputBinder
  }];
  return routerFeature(8, providers);
}
function withViewTransitions(options) {
  performanceMarkFeature("NgRouterViewTransitions");
  const providers = [{
    provide: CREATE_VIEW_TRANSITION,
    useValue: createViewTransition
  }, {
    provide: VIEW_TRANSITION_OPTIONS,
    useValue: __spreadValues({
      skipNextTransition: !!options?.skipInitialTransition
    }, options)
  }];
  return routerFeature(9, providers);
}
function provideRouterScroller() {
  return {
    provide: ROUTER_SCROLLER,
    useFactory: () => {
      const viewportScroller = inject2(ViewportScroller);
      const zone = inject2(NgZone);
      const config2 = inject2(ROUTER_CONFIGURATION);
      const transitions = inject2(NavigationTransitions);
      const urlSerializer = inject2(UrlSerializer);
      if (config2.scrollOffset) {
        viewportScroller.setOffset(config2.scrollOffset);
      }
      return new RouterScroller(urlSerializer, transitions, viewportScroller, zone, config2);
    }
  };
}
function provideHashLocationStrategy() {
  return {
    provide: LocationStrategy,
    useClass: HashLocationStrategy
  };
}
function providePathLocationStrategy() {
  return {
    provide: LocationStrategy,
    useClass: PathLocationStrategy
  };
}
function provideForRootGuard(router) {
  if (router) {
    throw new RuntimeError(4007, `The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector. Lazy loaded modules should use RouterModule.forChild() instead.`);
  }
  return "guarded";
}
function provideInitialNavigation(config2) {
  return [config2.initialNavigation === "disabled" ? withDisabledInitialNavigation().\u0275providers : [], config2.initialNavigation === "enabledBlocking" ? withEnabledBlockingInitialNavigation().\u0275providers : []];
}
function provideRouterInitializer() {
  return [
    // ROUTER_INITIALIZER token should be removed. It's public API but shouldn't be. We can just
    // have `getBootstrapListener` directly attached to APP_BOOTSTRAP_LISTENER.
    {
      provide: ROUTER_INITIALIZER,
      useFactory: getBootstrapListener
    },
    {
      provide: APP_BOOTSTRAP_LISTENER,
      multi: true,
      useExisting: ROUTER_INITIALIZER
    }
  ];
}
var RouterLink, RouterLinkActive, PreloadingStrategy, PreloadAllModules, NoPreloading, RouterPreloader, ROUTER_SCROLLER, RouterScroller, ROUTER_IS_PROVIDED, BOOTSTRAP_DONE, INITIAL_NAVIGATION, ROUTER_PRELOADER, ROUTER_DIRECTIVES, ROUTER_FORROOT_GUARD, ROUTER_PROVIDERS, RouterModule, ROUTER_INITIALIZER;
var init_router_module = __esm({
  "node_modules/@angular/router/fesm2022/router_module.mjs"() {
    "use strict";
    init_common();
    init_common();
    init_core();
    init_core();
    init_router2();
    init_esm();
    init_operators();
    RouterLink = class _RouterLink {
      router;
      route;
      tabIndexAttribute;
      renderer;
      el;
      locationStrategy;
      /** @nodoc */
      reactiveHref = signal(null, ...ngDevMode ? [{
        debugName: "reactiveHref"
      }] : []);
      /**
       * Represents an `href` attribute value applied to a host element,
       * when a host element is an `<a>`/`<area>` tag or a compatible custom element.
       * For other tags, the value is `null`.
       */
      get href() {
        return untracked2(this.reactiveHref);
      }
      /** @deprecated */
      set href(value) {
        this.reactiveHref.set(value);
      }
      /**
       * Represents the `target` attribute on a host element.
       * This is only used when the host element is
       * an `<a>`/`<area>` tag or a compatible custom element.
       */
      target;
      /**
       * Passed to {@link Router#createUrlTree} as part of the
       * `UrlCreationOptions`.
       * @see {@link UrlCreationOptions#queryParams}
       * @see {@link Router#createUrlTree}
       */
      queryParams;
      /**
       * Passed to {@link Router#createUrlTree} as part of the
       * `UrlCreationOptions`.
       * @see {@link UrlCreationOptions#fragment}
       * @see {@link Router#createUrlTree}
       */
      fragment;
      /**
       * Passed to {@link Router#createUrlTree} as part of the
       * `UrlCreationOptions`.
       * @see {@link UrlCreationOptions#queryParamsHandling}
       * @see {@link Router#createUrlTree}
       */
      queryParamsHandling;
      /**
       * Passed to {@link Router#navigateByUrl} as part of the
       * `NavigationBehaviorOptions`.
       * @see {@link NavigationBehaviorOptions#state}
       * @see {@link Router#navigateByUrl}
       */
      state;
      /**
       * Passed to {@link Router#navigateByUrl} as part of the
       * `NavigationBehaviorOptions`.
       * @see {@link NavigationBehaviorOptions#info}
       * @see {@link Router#navigateByUrl}
       */
      info;
      /**
       * Passed to {@link Router#createUrlTree} as part of the
       * `UrlCreationOptions`.
       * Specify a value here when you do not want to use the default value
       * for `routerLink`, which is the current activated route.
       * Note that a value of `undefined` here will use the `routerLink` default.
       * @see {@link UrlCreationOptions#relativeTo}
       * @see {@link Router#createUrlTree}
       */
      relativeTo;
      /** Whether a host element is an `<a>`/`<area>` tag or a compatible custom element. */
      isAnchorElement;
      subscription;
      /** @internal */
      onChanges = new Subject();
      applicationErrorHandler = inject2(INTERNAL_APPLICATION_ERROR_HANDLER);
      options = inject2(ROUTER_CONFIGURATION, {
        optional: true
      });
      constructor(router, route, tabIndexAttribute, renderer, el2, locationStrategy) {
        this.router = router;
        this.route = route;
        this.tabIndexAttribute = tabIndexAttribute;
        this.renderer = renderer;
        this.el = el2;
        this.locationStrategy = locationStrategy;
        this.reactiveHref.set(inject2(new HostAttributeToken("href"), {
          optional: true
        }));
        const tagName = el2.nativeElement.tagName?.toLowerCase();
        this.isAnchorElement = tagName === "a" || tagName === "area" || !!// Avoid breaking in an SSR context where customElements might not be defined.
        (typeof customElements === "object" && // observedAttributes is an optional static property/getter on a custom element.
        // The spec states that this must be an array of strings.
        customElements.get(tagName)?.observedAttributes?.includes?.("href"));
        if (!this.isAnchorElement) {
          this.subscribeToNavigationEventsIfNecessary();
        } else {
          this.setTabIndexIfNotOnNativeEl("0");
        }
      }
      subscribeToNavigationEventsIfNecessary() {
        if (this.subscription !== void 0 || !this.isAnchorElement) {
          return;
        }
        let createSubcription = this.preserveFragment;
        const dependsOnRouterState = (handling) => handling === "merge" || handling === "preserve";
        createSubcription ||= dependsOnRouterState(this.queryParamsHandling);
        createSubcription ||= !this.queryParamsHandling && !dependsOnRouterState(this.options?.defaultQueryParamsHandling);
        if (!createSubcription) {
          return;
        }
        this.subscription = this.router.events.subscribe((s2) => {
          if (s2 instanceof NavigationEnd) {
            this.updateHref();
          }
        });
      }
      /**
       * Passed to {@link Router#createUrlTree} as part of the
       * `UrlCreationOptions`.
       * @see {@link UrlCreationOptions#preserveFragment}
       * @see {@link Router#createUrlTree}
       */
      preserveFragment = false;
      /**
       * Passed to {@link Router#navigateByUrl} as part of the
       * `NavigationBehaviorOptions`.
       * @see {@link NavigationBehaviorOptions#skipLocationChange}
       * @see {@link Router#navigateByUrl}
       */
      skipLocationChange = false;
      /**
       * Passed to {@link Router#navigateByUrl} as part of the
       * `NavigationBehaviorOptions`.
       * @see {@link NavigationBehaviorOptions#replaceUrl}
       * @see {@link Router#navigateByUrl}
       */
      replaceUrl = false;
      /**
       * Modifies the tab index if there was not a tabindex attribute on the element during
       * instantiation.
       */
      setTabIndexIfNotOnNativeEl(newTabIndex) {
        if (this.tabIndexAttribute != null || this.isAnchorElement) {
          return;
        }
        this.applyAttributeValue("tabindex", newTabIndex);
      }
      /** @docs-private */
      // TODO(atscott): Remove changes parameter in major version as a breaking change.
      ngOnChanges(changes) {
        if (ngDevMode && isUrlTree(this.routerLinkInput) && (this.fragment !== void 0 || this.queryParams || this.queryParamsHandling || this.preserveFragment || this.relativeTo)) {
          throw new RuntimeError(4016, "Cannot configure queryParams or fragment when using a UrlTree as the routerLink input value.");
        }
        if (this.isAnchorElement) {
          this.updateHref();
          this.subscribeToNavigationEventsIfNecessary();
        }
        this.onChanges.next(this);
      }
      routerLinkInput = null;
      /**
       * Commands to pass to {@link Router#createUrlTree} or a `UrlTree`.
       *   - **array**: commands to pass to {@link Router#createUrlTree}.
       *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`
       *   - **UrlTree**: a `UrlTree` for this link rather than creating one from the commands
       *     and other inputs that correspond to properties of `UrlCreationOptions`.
       *   - **null|undefined**: effectively disables the `routerLink`
       * @see {@link Router#createUrlTree}
       */
      set routerLink(commandsOrUrlTree) {
        if (commandsOrUrlTree == null) {
          this.routerLinkInput = null;
          this.setTabIndexIfNotOnNativeEl(null);
        } else {
          if (isUrlTree(commandsOrUrlTree)) {
            this.routerLinkInput = commandsOrUrlTree;
          } else {
            this.routerLinkInput = Array.isArray(commandsOrUrlTree) ? commandsOrUrlTree : [commandsOrUrlTree];
          }
          this.setTabIndexIfNotOnNativeEl("0");
        }
      }
      /** @docs-private */
      onClick(button, ctrlKey, shiftKey, altKey, metaKey) {
        const urlTree = this.urlTree;
        if (urlTree === null) {
          return true;
        }
        if (this.isAnchorElement) {
          if (button !== 0 || ctrlKey || shiftKey || altKey || metaKey) {
            return true;
          }
          if (typeof this.target === "string" && this.target != "_self") {
            return true;
          }
        }
        const extras = {
          skipLocationChange: this.skipLocationChange,
          replaceUrl: this.replaceUrl,
          state: this.state,
          info: this.info
        };
        this.router.navigateByUrl(urlTree, extras)?.catch((e2) => {
          this.applicationErrorHandler(e2);
        });
        return !this.isAnchorElement;
      }
      /** @docs-private */
      ngOnDestroy() {
        this.subscription?.unsubscribe();
      }
      updateHref() {
        const urlTree = this.urlTree;
        this.reactiveHref.set(urlTree !== null && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(urlTree)) ?? "" : null);
      }
      applyAttributeValue(attrName, attrValue) {
        const renderer = this.renderer;
        const nativeElement = this.el.nativeElement;
        if (attrValue !== null) {
          renderer.setAttribute(nativeElement, attrName, attrValue);
        } else {
          renderer.removeAttribute(nativeElement, attrName);
        }
      }
      get urlTree() {
        if (this.routerLinkInput === null) {
          return null;
        } else if (isUrlTree(this.routerLinkInput)) {
          return this.routerLinkInput;
        }
        return this.router.createUrlTree(this.routerLinkInput, {
          // If the `relativeTo` input is not defined, we want to use `this.route` by default.
          // Otherwise, we should use the value provided by the user in the input.
          relativeTo: this.relativeTo !== void 0 ? this.relativeTo : this.route,
          queryParams: this.queryParams,
          fragment: this.fragment,
          queryParamsHandling: this.queryParamsHandling,
          preserveFragment: this.preserveFragment
        });
      }
      static \u0275fac = function RouterLink_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _RouterLink)(\u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275injectAttribute("tabindex"), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(LocationStrategy));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _RouterLink,
        selectors: [["", "routerLink", ""]],
        hostVars: 2,
        hostBindings: function RouterLink_HostBindings(rf2, ctx) {
          if (rf2 & 1) {
            \u0275\u0275listener("click", function RouterLink_click_HostBindingHandler($event) {
              return ctx.onClick($event.button, $event.ctrlKey, $event.shiftKey, $event.altKey, $event.metaKey);
            });
          }
          if (rf2 & 2) {
            \u0275\u0275attribute("href", ctx.reactiveHref(), \u0275\u0275sanitizeUrlOrResourceUrl)("target", ctx.target);
          }
        },
        inputs: {
          target: "target",
          queryParams: "queryParams",
          fragment: "fragment",
          queryParamsHandling: "queryParamsHandling",
          state: "state",
          info: "info",
          relativeTo: "relativeTo",
          preserveFragment: [2, "preserveFragment", "preserveFragment", booleanAttribute],
          skipLocationChange: [2, "skipLocationChange", "skipLocationChange", booleanAttribute],
          replaceUrl: [2, "replaceUrl", "replaceUrl", booleanAttribute],
          routerLink: "routerLink"
        },
        features: [\u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterLink, [{
        type: Directive,
        args: [{
          selector: "[routerLink]",
          host: {
            "[attr.href]": "reactiveHref()"
          }
        }]
      }], () => [{
        type: Router
      }, {
        type: ActivatedRoute
      }, {
        type: void 0,
        decorators: [{
          type: Attribute,
          args: ["tabindex"]
        }]
      }, {
        type: Renderer2
      }, {
        type: ElementRef
      }, {
        type: LocationStrategy
      }], {
        target: [{
          type: HostBinding,
          args: ["attr.target"]
        }, {
          type: Input
        }],
        queryParams: [{
          type: Input
        }],
        fragment: [{
          type: Input
        }],
        queryParamsHandling: [{
          type: Input
        }],
        state: [{
          type: Input
        }],
        info: [{
          type: Input
        }],
        relativeTo: [{
          type: Input
        }],
        preserveFragment: [{
          type: Input,
          args: [{
            transform: booleanAttribute
          }]
        }],
        skipLocationChange: [{
          type: Input,
          args: [{
            transform: booleanAttribute
          }]
        }],
        replaceUrl: [{
          type: Input,
          args: [{
            transform: booleanAttribute
          }]
        }],
        routerLink: [{
          type: Input
        }],
        onClick: [{
          type: HostListener,
          args: ["click", ["$event.button", "$event.ctrlKey", "$event.shiftKey", "$event.altKey", "$event.metaKey"]]
        }]
      });
    })();
    RouterLinkActive = class _RouterLinkActive {
      router;
      element;
      renderer;
      cdr;
      link;
      links;
      classes = [];
      routerEventsSubscription;
      linkInputChangesSubscription;
      _isActive = false;
      get isActive() {
        return this._isActive;
      }
      /**
       * Options to configure how to determine if the router link is active.
       *
       * These options are passed to the `Router.isActive()` function.
       *
       * @see {@link Router#isActive}
       */
      routerLinkActiveOptions = {
        exact: false
      };
      /**
       * Aria-current attribute to apply when the router link is active.
       *
       * Possible values: `'page'` | `'step'` | `'location'` | `'date'` | `'time'` | `true` | `false`.
       *
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-current}
       */
      ariaCurrentWhenActive;
      /**
       *
       * You can use the output `isActiveChange` to get notified each time the link becomes
       * active or inactive.
       *
       * Emits:
       * true  -> Route is active
       * false -> Route is inactive
       *
       * ```html
       * <a
       *  routerLink="/user/bob"
       *  routerLinkActive="active-link"
       *  (isActiveChange)="this.onRouterLinkActive($event)">Bob</a>
       * ```
       */
      isActiveChange = new EventEmitter();
      constructor(router, element, renderer, cdr, link) {
        this.router = router;
        this.element = element;
        this.renderer = renderer;
        this.cdr = cdr;
        this.link = link;
        this.routerEventsSubscription = router.events.subscribe((s2) => {
          if (s2 instanceof NavigationEnd) {
            this.update();
          }
        });
      }
      /** @docs-private */
      ngAfterContentInit() {
        of(this.links.changes, of(null)).pipe(mergeAll()).subscribe((_2) => {
          this.update();
          this.subscribeToEachLinkOnChanges();
        });
      }
      subscribeToEachLinkOnChanges() {
        this.linkInputChangesSubscription?.unsubscribe();
        const allLinkChanges = [...this.links.toArray(), this.link].filter((link) => !!link).map((link) => link.onChanges);
        this.linkInputChangesSubscription = from(allLinkChanges).pipe(mergeAll()).subscribe((link) => {
          if (this._isActive !== this.isLinkActive(this.router)(link)) {
            this.update();
          }
        });
      }
      set routerLinkActive(data) {
        const classes = Array.isArray(data) ? data : data.split(" ");
        this.classes = classes.filter((c2) => !!c2);
      }
      /** @docs-private */
      ngOnChanges(changes) {
        this.update();
      }
      /** @docs-private */
      ngOnDestroy() {
        this.routerEventsSubscription.unsubscribe();
        this.linkInputChangesSubscription?.unsubscribe();
      }
      update() {
        if (!this.links || !this.router.navigated) return;
        queueMicrotask(() => {
          const hasActiveLinks = this.hasActiveLinks();
          this.classes.forEach((c2) => {
            if (hasActiveLinks) {
              this.renderer.addClass(this.element.nativeElement, c2);
            } else {
              this.renderer.removeClass(this.element.nativeElement, c2);
            }
          });
          if (hasActiveLinks && this.ariaCurrentWhenActive !== void 0) {
            this.renderer.setAttribute(this.element.nativeElement, "aria-current", this.ariaCurrentWhenActive.toString());
          } else {
            this.renderer.removeAttribute(this.element.nativeElement, "aria-current");
          }
          if (this._isActive !== hasActiveLinks) {
            this._isActive = hasActiveLinks;
            this.cdr.markForCheck();
            this.isActiveChange.emit(hasActiveLinks);
          }
        });
      }
      isLinkActive(router) {
        const options = isActiveMatchOptions(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : (
          // While the types should disallow `undefined` here, it's possible without strict inputs
          this.routerLinkActiveOptions.exact || false
        );
        return (link) => {
          const urlTree = link.urlTree;
          return urlTree ? router.isActive(urlTree, options) : false;
        };
      }
      hasActiveLinks() {
        const isActiveCheckFn = this.isLinkActive(this.router);
        return this.link && isActiveCheckFn(this.link) || this.links.some(isActiveCheckFn);
      }
      static \u0275fac = function RouterLinkActive_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _RouterLinkActive)(\u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(RouterLink, 8));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _RouterLinkActive,
        selectors: [["", "routerLinkActive", ""]],
        contentQueries: function RouterLinkActive_ContentQueries(rf2, ctx, dirIndex) {
          if (rf2 & 1) {
            \u0275\u0275contentQuery(dirIndex, RouterLink, 5);
          }
          if (rf2 & 2) {
            let _t2;
            \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.links = _t2);
          }
        },
        inputs: {
          routerLinkActiveOptions: "routerLinkActiveOptions",
          ariaCurrentWhenActive: "ariaCurrentWhenActive",
          routerLinkActive: "routerLinkActive"
        },
        outputs: {
          isActiveChange: "isActiveChange"
        },
        exportAs: ["routerLinkActive"],
        features: [\u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterLinkActive, [{
        type: Directive,
        args: [{
          selector: "[routerLinkActive]",
          exportAs: "routerLinkActive"
        }]
      }], () => [{
        type: Router
      }, {
        type: ElementRef
      }, {
        type: Renderer2
      }, {
        type: ChangeDetectorRef
      }, {
        type: RouterLink,
        decorators: [{
          type: Optional
        }]
      }], {
        links: [{
          type: ContentChildren,
          args: [RouterLink, {
            descendants: true
          }]
        }],
        routerLinkActiveOptions: [{
          type: Input
        }],
        ariaCurrentWhenActive: [{
          type: Input
        }],
        isActiveChange: [{
          type: Output
        }],
        routerLinkActive: [{
          type: Input
        }]
      });
    })();
    PreloadingStrategy = class {
    };
    PreloadAllModules = class _PreloadAllModules {
      preload(route, fn) {
        return fn().pipe(catchError(() => of(null)));
      }
      static \u0275fac = function PreloadAllModules_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _PreloadAllModules)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _PreloadAllModules,
        factory: _PreloadAllModules.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreloadAllModules, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    NoPreloading = class _NoPreloading {
      preload(route, fn) {
        return of(null);
      }
      static \u0275fac = function NoPreloading_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NoPreloading)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _NoPreloading,
        factory: _NoPreloading.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoPreloading, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    RouterPreloader = class _RouterPreloader {
      router;
      injector;
      preloadingStrategy;
      loader;
      subscription;
      constructor(router, injector, preloadingStrategy, loader) {
        this.router = router;
        this.injector = injector;
        this.preloadingStrategy = preloadingStrategy;
        this.loader = loader;
      }
      setUpPreloading() {
        this.subscription = this.router.events.pipe(filter((e2) => e2 instanceof NavigationEnd), concatMap(() => this.preload())).subscribe(() => {
        });
      }
      preload() {
        return this.processRoutes(this.injector, this.router.config);
      }
      /** @docs-private */
      ngOnDestroy() {
        if (this.subscription) {
          this.subscription.unsubscribe();
        }
      }
      processRoutes(injector, routes2) {
        const res = [];
        for (const route of routes2) {
          if (route.providers && !route._injector) {
            route._injector = createEnvironmentInjector(route.providers, injector, `Route: ${route.path}`);
          }
          const injectorForCurrentRoute = route._injector ?? injector;
          const injectorForChildren = route._loadedInjector ?? injectorForCurrentRoute;
          if (route.loadChildren && !route._loadedRoutes && route.canLoad === void 0 || route.loadComponent && !route._loadedComponent) {
            res.push(this.preloadConfig(injectorForCurrentRoute, route));
          }
          if (route.children || route._loadedRoutes) {
            res.push(this.processRoutes(injectorForChildren, route.children ?? route._loadedRoutes));
          }
        }
        return from(res).pipe(mergeAll());
      }
      preloadConfig(injector, route) {
        return this.preloadingStrategy.preload(route, () => {
          let loadedChildren$;
          if (route.loadChildren && route.canLoad === void 0) {
            loadedChildren$ = this.loader.loadChildren(injector, route);
          } else {
            loadedChildren$ = of(null);
          }
          const recursiveLoadChildren$ = loadedChildren$.pipe(mergeMap((config2) => {
            if (config2 === null) {
              return of(void 0);
            }
            route._loadedRoutes = config2.routes;
            route._loadedInjector = config2.injector;
            return this.processRoutes(config2.injector ?? injector, config2.routes);
          }));
          if (route.loadComponent && !route._loadedComponent) {
            const loadComponent$ = this.loader.loadComponent(injector, route);
            return from([recursiveLoadChildren$, loadComponent$]).pipe(mergeAll());
          } else {
            return recursiveLoadChildren$;
          }
        });
      }
      static \u0275fac = function RouterPreloader_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _RouterPreloader)(\u0275\u0275inject(Router), \u0275\u0275inject(EnvironmentInjector), \u0275\u0275inject(PreloadingStrategy), \u0275\u0275inject(RouterConfigLoader));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _RouterPreloader,
        factory: _RouterPreloader.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterPreloader, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [{
        type: Router
      }, {
        type: EnvironmentInjector
      }, {
        type: PreloadingStrategy
      }, {
        type: RouterConfigLoader
      }], null);
    })();
    ROUTER_SCROLLER = new InjectionToken("");
    RouterScroller = class _RouterScroller {
      urlSerializer;
      transitions;
      viewportScroller;
      zone;
      options;
      routerEventsSubscription;
      scrollEventsSubscription;
      lastId = 0;
      lastSource = IMPERATIVE_NAVIGATION;
      restoredId = 0;
      store = {};
      /** @docs-private */
      constructor(urlSerializer, transitions, viewportScroller, zone, options = {}) {
        this.urlSerializer = urlSerializer;
        this.transitions = transitions;
        this.viewportScroller = viewportScroller;
        this.zone = zone;
        this.options = options;
        options.scrollPositionRestoration ||= "disabled";
        options.anchorScrolling ||= "disabled";
      }
      init() {
        if (this.options.scrollPositionRestoration !== "disabled") {
          this.viewportScroller.setHistoryScrollRestoration("manual");
        }
        this.routerEventsSubscription = this.createScrollEvents();
        this.scrollEventsSubscription = this.consumeScrollEvents();
      }
      createScrollEvents() {
        return this.transitions.events.subscribe((e2) => {
          if (e2 instanceof NavigationStart) {
            this.store[this.lastId] = this.viewportScroller.getScrollPosition();
            this.lastSource = e2.navigationTrigger;
            this.restoredId = e2.restoredState ? e2.restoredState.navigationId : 0;
          } else if (e2 instanceof NavigationEnd) {
            this.lastId = e2.id;
            this.scheduleScrollEvent(e2, this.urlSerializer.parse(e2.urlAfterRedirects).fragment);
          } else if (e2 instanceof NavigationSkipped && e2.code === NavigationSkippedCode.IgnoredSameUrlNavigation) {
            this.lastSource = void 0;
            this.restoredId = 0;
            this.scheduleScrollEvent(e2, this.urlSerializer.parse(e2.url).fragment);
          }
        });
      }
      consumeScrollEvents() {
        return this.transitions.events.subscribe((e2) => {
          if (!(e2 instanceof Scroll)) return;
          if (e2.position) {
            if (this.options.scrollPositionRestoration === "top") {
              this.viewportScroller.scrollToPosition([0, 0]);
            } else if (this.options.scrollPositionRestoration === "enabled") {
              this.viewportScroller.scrollToPosition(e2.position);
            }
          } else {
            if (e2.anchor && this.options.anchorScrolling === "enabled") {
              this.viewportScroller.scrollToAnchor(e2.anchor);
            } else if (this.options.scrollPositionRestoration !== "disabled") {
              this.viewportScroller.scrollToPosition([0, 0]);
            }
          }
        });
      }
      scheduleScrollEvent(routerEvent, anchor) {
        this.zone.runOutsideAngular(() => __async(this, null, function* () {
          yield new Promise((resolve) => {
            setTimeout(resolve);
            if (typeof requestAnimationFrame !== "undefined") {
              requestAnimationFrame(resolve);
            }
          });
          this.zone.run(() => {
            this.transitions.events.next(new Scroll(routerEvent, this.lastSource === "popstate" ? this.store[this.restoredId] : null, anchor));
          });
        }));
      }
      /** @docs-private */
      ngOnDestroy() {
        this.routerEventsSubscription?.unsubscribe();
        this.scrollEventsSubscription?.unsubscribe();
      }
      static \u0275fac = function RouterScroller_Factory(__ngFactoryType__) {
        \u0275\u0275invalidFactory();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _RouterScroller,
        factory: _RouterScroller.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterScroller, [{
        type: Injectable
      }], () => [{
        type: UrlSerializer
      }, {
        type: NavigationTransitions
      }, {
        type: ViewportScroller
      }, {
        type: NgZone
      }, {
        type: void 0
      }], null);
    })();
    ROUTER_IS_PROVIDED = new InjectionToken("", {
      providedIn: "root",
      factory: () => false
    });
    BOOTSTRAP_DONE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "bootstrap done indicator" : "", {
      factory: () => {
        return new Subject();
      }
    });
    INITIAL_NAVIGATION = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "initial navigation" : "", {
      providedIn: "root",
      factory: () => 1
      /* InitialNavigation.EnabledNonBlocking */
    });
    ROUTER_PRELOADER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "router preloader" : "");
    ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkActive, \u0275EmptyOutletComponent];
    ROUTER_FORROOT_GUARD = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "router duplicate forRoot guard" : "");
    ROUTER_PROVIDERS = [
      Location,
      {
        provide: UrlSerializer,
        useClass: DefaultUrlSerializer
      },
      Router,
      ChildrenOutletContexts,
      {
        provide: ActivatedRoute,
        useFactory: rootRoute,
        deps: [Router]
      },
      RouterConfigLoader,
      // Only used to warn when `provideRoutes` is used without `RouterModule` or `provideRouter`. Can
      // be removed when `provideRoutes` is removed.
      typeof ngDevMode === "undefined" || ngDevMode ? {
        provide: ROUTER_IS_PROVIDED,
        useValue: true
      } : []
    ];
    RouterModule = class _RouterModule {
      constructor() {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          inject2(ROUTER_FORROOT_GUARD, {
            optional: true
          });
        }
      }
      /**
       * Creates and configures a module with all the router providers and directives.
       * Optionally sets up an application listener to perform an initial navigation.
       *
       * When registering the NgModule at the root, import as follows:
       *
       * ```ts
       * @NgModule({
       *   imports: [RouterModule.forRoot(ROUTES)]
       * })
       * class MyNgModule {}
       * ```
       *
       * @param routes An array of `Route` objects that define the navigation paths for the application.
       * @param config An `ExtraOptions` configuration object that controls how navigation is performed.
       * @return The new `NgModule`.
       *
       */
      static forRoot(routes2, config2) {
        return {
          ngModule: _RouterModule,
          providers: [ROUTER_PROVIDERS, typeof ngDevMode === "undefined" || ngDevMode ? config2?.enableTracing ? withDebugTracing().\u0275providers : [] : [], {
            provide: ROUTES,
            multi: true,
            useValue: routes2
          }, typeof ngDevMode === "undefined" || ngDevMode ? {
            provide: ROUTER_FORROOT_GUARD,
            useFactory: provideForRootGuard,
            deps: [[Router, new Optional(), new SkipSelf()]]
          } : [], config2?.errorHandler ? {
            provide: NAVIGATION_ERROR_HANDLER,
            useValue: config2.errorHandler
          } : [], {
            provide: ROUTER_CONFIGURATION,
            useValue: config2 ? config2 : {}
          }, config2?.useHash ? provideHashLocationStrategy() : providePathLocationStrategy(), provideRouterScroller(), config2?.preloadingStrategy ? withPreloading(config2.preloadingStrategy).\u0275providers : [], config2?.initialNavigation ? provideInitialNavigation(config2) : [], config2?.bindToComponentInputs ? withComponentInputBinding().\u0275providers : [], config2?.enableViewTransitions ? withViewTransitions().\u0275providers : [], provideRouterInitializer()]
        };
      }
      /**
       * Creates a module with all the router directives and a provider registering routes,
       * without creating a new Router service.
       * When registering for submodules and lazy-loaded submodules, create the NgModule as follows:
       *
       * ```ts
       * @NgModule({
       *   imports: [RouterModule.forChild(ROUTES)]
       * })
       * class MyNgModule {}
       * ```
       *
       * @param routes An array of `Route` objects that define the navigation paths for the submodule.
       * @return The new NgModule.
       *
       */
      static forChild(routes2) {
        return {
          ngModule: _RouterModule,
          providers: [{
            provide: ROUTES,
            multi: true,
            useValue: routes2
          }]
        };
      }
      static \u0275fac = function RouterModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _RouterModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _RouterModule,
        imports: [RouterOutlet, RouterLink, RouterLinkActive, \u0275EmptyOutletComponent],
        exports: [RouterOutlet, RouterLink, RouterLinkActive, \u0275EmptyOutletComponent]
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterModule, [{
        type: NgModule,
        args: [{
          imports: ROUTER_DIRECTIVES,
          exports: ROUTER_DIRECTIVES
        }]
      }], () => [], null);
    })();
    ROUTER_INITIALIZER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "Router Initializer" : "");
  }
});

// node_modules/@angular/router/fesm2022/router.mjs
var VERSION4;
var init_router = __esm({
  "node_modules/@angular/router/fesm2022/router.mjs"() {
    "use strict";
    init_router_module();
    init_core();
    VERSION4 = new Version("20.1.7");
  }
});

// node_modules/@angular/forms/fesm2022/forms.mjs
function _isAndroid() {
  const userAgent = getDOM() ? getDOM().getUserAgent() : "";
  return /android (\d+)/.test(userAgent.toLowerCase());
}
function isEmptyInputValue(value) {
  return value == null || lengthOrSize(value) === 0;
}
function lengthOrSize(value) {
  if (value == null) {
    return null;
  } else if (Array.isArray(value) || typeof value === "string") {
    return value.length;
  } else if (value instanceof Set) {
    return value.size;
  }
  return null;
}
function minValidator(min) {
  return (control) => {
    if (control.value == null || min == null) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value < min ? {
      "min": {
        "min": min,
        "actual": control.value
      }
    } : null;
  };
}
function maxValidator(max) {
  return (control) => {
    if (control.value == null || max == null) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value > max ? {
      "max": {
        "max": max,
        "actual": control.value
      }
    } : null;
  };
}
function requiredValidator(control) {
  return isEmptyInputValue(control.value) ? {
    "required": true
  } : null;
}
function requiredTrueValidator(control) {
  return control.value === true ? null : {
    "required": true
  };
}
function emailValidator(control) {
  if (isEmptyInputValue(control.value)) {
    return null;
  }
  return EMAIL_REGEXP.test(control.value) ? null : {
    "email": true
  };
}
function minLengthValidator(minLength) {
  return (control) => {
    const length = control.value?.length ?? lengthOrSize(control.value);
    if (length === null || length === 0) {
      return null;
    }
    return length < minLength ? {
      "minlength": {
        "requiredLength": minLength,
        "actualLength": length
      }
    } : null;
  };
}
function maxLengthValidator(maxLength) {
  return (control) => {
    const length = control.value?.length ?? lengthOrSize(control.value);
    if (length !== null && length > maxLength) {
      return {
        "maxlength": {
          "requiredLength": maxLength,
          "actualLength": length
        }
      };
    }
    return null;
  };
}
function patternValidator(pattern) {
  if (!pattern) return nullValidator;
  let regex;
  let regexStr;
  if (typeof pattern === "string") {
    regexStr = "";
    if (pattern.charAt(0) !== "^") regexStr += "^";
    regexStr += pattern;
    if (pattern.charAt(pattern.length - 1) !== "$") regexStr += "$";
    regex = new RegExp(regexStr);
  } else {
    regexStr = pattern.toString();
    regex = pattern;
  }
  return (control) => {
    if (isEmptyInputValue(control.value)) {
      return null;
    }
    const value = control.value;
    return regex.test(value) ? null : {
      "pattern": {
        "requiredPattern": regexStr,
        "actualValue": value
      }
    };
  };
}
function nullValidator(control) {
  return null;
}
function isPresent(o2) {
  return o2 != null;
}
function toObservable(value) {
  const obs = isPromise2(value) ? from(value) : value;
  if ((typeof ngDevMode === "undefined" || ngDevMode) && !isSubscribable(obs)) {
    let errorMessage = `Expected async validator to return Promise or Observable.`;
    if (typeof value === "object") {
      errorMessage += " Are you using a synchronous validator where an async validator is expected?";
    }
    throw new RuntimeError(-1101, errorMessage);
  }
  return obs;
}
function mergeErrors(arrayOfErrors) {
  let res = {};
  arrayOfErrors.forEach((errors) => {
    res = errors != null ? __spreadValues(__spreadValues({}, res), errors) : res;
  });
  return Object.keys(res).length === 0 ? null : res;
}
function executeValidators(control, validators) {
  return validators.map((validator) => validator(control));
}
function isValidatorFn(validator) {
  return !validator.validate;
}
function normalizeValidators(validators) {
  return validators.map((validator) => {
    return isValidatorFn(validator) ? validator : (c2) => validator.validate(c2);
  });
}
function compose(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function(control) {
    return mergeErrors(executeValidators(control, presentValidators));
  };
}
function composeValidators(validators) {
  return validators != null ? compose(normalizeValidators(validators)) : null;
}
function composeAsync(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function(control) {
    const observables = executeValidators(control, presentValidators).map(toObservable);
    return forkJoin(observables).pipe(map(mergeErrors));
  };
}
function composeAsyncValidators(validators) {
  return validators != null ? composeAsync(normalizeValidators(validators)) : null;
}
function mergeValidators(controlValidators, dirValidator) {
  if (controlValidators === null) return [dirValidator];
  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] : [controlValidators, dirValidator];
}
function getControlValidators(control) {
  return control._rawValidators;
}
function getControlAsyncValidators(control) {
  return control._rawAsyncValidators;
}
function makeValidatorsArray(validators) {
  if (!validators) return [];
  return Array.isArray(validators) ? validators : [validators];
}
function hasValidator(validators, validator) {
  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;
}
function addValidators(validators, currentValidators) {
  const current = makeValidatorsArray(currentValidators);
  const validatorsToAdd = makeValidatorsArray(validators);
  validatorsToAdd.forEach((v) => {
    if (!hasValidator(current, v)) {
      current.push(v);
    }
  });
  return current;
}
function removeValidators(validators, currentValidators) {
  return makeValidatorsArray(currentValidators).filter((v) => !hasValidator(validators, v));
}
function controlParentException(nameOrIndex) {
  return new RuntimeError(1050, `formControlName must be used with a parent formGroup directive. You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      ${describeFormControl(nameOrIndex)}

    Example:

    ${formControlNameExample}`);
}
function describeFormControl(nameOrIndex) {
  if (nameOrIndex == null || nameOrIndex === "") {
    return "";
  }
  const valueType = typeof nameOrIndex === "string" ? "name" : "index";
  return `Affected Form Control ${valueType}: "${nameOrIndex}"`;
}
function ngModelGroupException() {
  return new RuntimeError(1051, `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents
      that also have a "form" prefix: formGroupName, formArrayName, or formGroup.

      Option 1:  Update the parent to be formGroupName (reactive form strategy)

      ${formGroupNameExample}

      Option 2: Use ngModel instead of formControlName (template-driven strategy)

      ${ngModelGroupExample}`);
}
function missingFormException() {
  return new RuntimeError(1052, `formGroup expects a FormGroup instance. Please pass one in.

      Example:

      ${formControlNameExample}`);
}
function groupParentException() {
  return new RuntimeError(1053, `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup
    directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formGroupNameExample}`);
}
function arrayParentException() {
  return new RuntimeError(1054, `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      Example:

      ${formArrayNameExample}`);
}
function ngModelWarning(directiveName) {
  return `
  It looks like you're using ngModel on the same form field as ${directiveName}.
  Support for using the ngModel input property and ngModelChange event with
  reactive form directives has been deprecated in Angular v6 and will be removed
  in a future version of Angular.

  For more information on this, see our API docs here:
  https://angular.io/api/forms/${directiveName === "formControl" ? "FormControlDirective" : "FormControlName"}#use-with-ngmodel
  `;
}
function describeKey(isFormGroup, key) {
  return isFormGroup ? `with name: '${key}'` : `at index: ${key}`;
}
function noControlsError(isFormGroup) {
  return `
    There are no form controls registered with this ${isFormGroup ? "group" : "array"} yet. If you're using ngModel,
    you may want to check next tick (e.g. use setTimeout).
  `;
}
function missingControlError(isFormGroup, key) {
  return `Cannot find form control ${describeKey(isFormGroup, key)}`;
}
function missingControlValueError(isFormGroup, key) {
  return `Must supply a value for form control ${describeKey(isFormGroup, key)}`;
}
function pickValidators(validatorOrOpts) {
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;
}
function coerceToValidator(validator) {
  return Array.isArray(validator) ? composeValidators(validator) : validator || null;
}
function pickAsyncValidators(asyncValidator, validatorOrOpts) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (isOptionsObj(validatorOrOpts) && asyncValidator) {
      console.warn(asyncValidatorsDroppedWithOptsWarning);
    }
  }
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;
}
function coerceToAsyncValidator(asyncValidator) {
  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator || null;
}
function isOptionsObj(validatorOrOpts) {
  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) && typeof validatorOrOpts === "object";
}
function assertControlPresent(parent, isGroup, key) {
  const controls = parent.controls;
  const collection = isGroup ? Object.keys(controls) : controls;
  if (!collection.length) {
    throw new RuntimeError(1e3, typeof ngDevMode === "undefined" || ngDevMode ? noControlsError(isGroup) : "");
  }
  if (!controls[key]) {
    throw new RuntimeError(1001, typeof ngDevMode === "undefined" || ngDevMode ? missingControlError(isGroup, key) : "");
  }
}
function assertAllValuesPresent(control, isGroup, value) {
  control._forEachChild((_2, key) => {
    if (value[key] === void 0) {
      throw new RuntimeError(1002, typeof ngDevMode === "undefined" || ngDevMode ? missingControlValueError(isGroup, key) : "");
    }
  });
}
function validateFormGroupControls(controls) {
  const invalidKeys = Object.keys(controls).filter((key) => key.includes("."));
  if (invalidKeys.length > 0) {
    console.warn(`FormGroup keys cannot include \`.\`, please replace the keys for: ${invalidKeys.join(",")}.`);
  }
}
function controlPath(name, parent) {
  return [...parent.path, name];
}
function setUpControl(control, dir, callSetDisabledState = setDisabledStateDefault) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (!control) _throwError(dir, "Cannot find control with");
    if (!dir.valueAccessor) _throwMissingValueAccessorError(dir);
  }
  setUpValidators(control, dir);
  dir.valueAccessor.writeValue(control.value);
  if (control.disabled || callSetDisabledState === "always") {
    dir.valueAccessor.setDisabledState?.(control.disabled);
  }
  setUpViewChangePipeline(control, dir);
  setUpModelChangePipeline(control, dir);
  setUpBlurPipeline(control, dir);
  setUpDisabledChangeHandler(control, dir);
}
function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {
  const noop4 = () => {
    if (validateControlPresenceOnChange && (typeof ngDevMode === "undefined" || ngDevMode)) {
      _noControlError(dir);
    }
  };
  if (dir.valueAccessor) {
    dir.valueAccessor.registerOnChange(noop4);
    dir.valueAccessor.registerOnTouched(noop4);
  }
  cleanUpValidators(control, dir);
  if (control) {
    dir._invokeOnDestroyCallbacks();
    control._registerOnCollectionChange(() => {
    });
  }
}
function registerOnValidatorChange(validators, onChange) {
  validators.forEach((validator) => {
    if (validator.registerOnValidatorChange) validator.registerOnValidatorChange(onChange);
  });
}
function setUpDisabledChangeHandler(control, dir) {
  if (dir.valueAccessor.setDisabledState) {
    const onDisabledChange = (isDisabled) => {
      dir.valueAccessor.setDisabledState(isDisabled);
    };
    control.registerOnDisabledChange(onDisabledChange);
    dir._registerOnDestroy(() => {
      control._unregisterOnDisabledChange(onDisabledChange);
    });
  }
}
function setUpValidators(control, dir) {
  const validators = getControlValidators(control);
  if (dir.validator !== null) {
    control.setValidators(mergeValidators(validators, dir.validator));
  } else if (typeof validators === "function") {
    control.setValidators([validators]);
  }
  const asyncValidators = getControlAsyncValidators(control);
  if (dir.asyncValidator !== null) {
    control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));
  } else if (typeof asyncValidators === "function") {
    control.setAsyncValidators([asyncValidators]);
  }
  const onValidatorChange = () => control.updateValueAndValidity();
  registerOnValidatorChange(dir._rawValidators, onValidatorChange);
  registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);
}
function cleanUpValidators(control, dir) {
  let isControlUpdated = false;
  if (control !== null) {
    if (dir.validator !== null) {
      const validators = getControlValidators(control);
      if (Array.isArray(validators) && validators.length > 0) {
        const updatedValidators = validators.filter((validator) => validator !== dir.validator);
        if (updatedValidators.length !== validators.length) {
          isControlUpdated = true;
          control.setValidators(updatedValidators);
        }
      }
    }
    if (dir.asyncValidator !== null) {
      const asyncValidators = getControlAsyncValidators(control);
      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {
        const updatedAsyncValidators = asyncValidators.filter((asyncValidator) => asyncValidator !== dir.asyncValidator);
        if (updatedAsyncValidators.length !== asyncValidators.length) {
          isControlUpdated = true;
          control.setAsyncValidators(updatedAsyncValidators);
        }
      }
    }
  }
  const noop4 = () => {
  };
  registerOnValidatorChange(dir._rawValidators, noop4);
  registerOnValidatorChange(dir._rawAsyncValidators, noop4);
  return isControlUpdated;
}
function setUpViewChangePipeline(control, dir) {
  dir.valueAccessor.registerOnChange((newValue) => {
    control._pendingValue = newValue;
    control._pendingChange = true;
    control._pendingDirty = true;
    if (control.updateOn === "change") updateControl(control, dir);
  });
}
function setUpBlurPipeline(control, dir) {
  dir.valueAccessor.registerOnTouched(() => {
    control._pendingTouched = true;
    if (control.updateOn === "blur" && control._pendingChange) updateControl(control, dir);
    if (control.updateOn !== "submit") control.markAsTouched();
  });
}
function updateControl(control, dir) {
  if (control._pendingDirty) control.markAsDirty();
  control.setValue(control._pendingValue, {
    emitModelToViewChange: false
  });
  dir.viewToModelUpdate(control._pendingValue);
  control._pendingChange = false;
}
function setUpModelChangePipeline(control, dir) {
  const onChange = (newValue, emitModelEvent) => {
    dir.valueAccessor.writeValue(newValue);
    if (emitModelEvent) dir.viewToModelUpdate(newValue);
  };
  control.registerOnChange(onChange);
  dir._registerOnDestroy(() => {
    control._unregisterOnChange(onChange);
  });
}
function setUpFormContainer(control, dir) {
  if (control == null && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "Cannot find control with");
  setUpValidators(control, dir);
}
function cleanUpFormContainer(control, dir) {
  return cleanUpValidators(control, dir);
}
function _noControlError(dir) {
  return _throwError(dir, "There is no FormControl instance attached to form control element with");
}
function _throwError(dir, message) {
  const messageEnd = _describeControlLocation(dir);
  throw new Error(`${message} ${messageEnd}`);
}
function _describeControlLocation(dir) {
  const path = dir.path;
  if (path && path.length > 1) return `path: '${path.join(" -> ")}'`;
  if (path?.[0]) return `name: '${path}'`;
  return "unspecified name attribute";
}
function _throwMissingValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(-1203, `No value accessor for form control ${loc}.`);
}
function _throwInvalidValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(1200, `Value accessor was not provided as an array for form control with ${loc}. Check that the \`NG_VALUE_ACCESSOR\` token is configured as a \`multi: true\` provider.`);
}
function isPropertyUpdated(changes, viewModel) {
  if (!changes.hasOwnProperty("model")) return false;
  const change = changes["model"];
  if (change.isFirstChange()) return true;
  return !Object.is(viewModel, change.currentValue);
}
function isBuiltInAccessor(valueAccessor) {
  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;
}
function syncPendingControls(form, directives) {
  form._syncPendingControls();
  directives.forEach((dir) => {
    const control = dir.control;
    if (control.updateOn === "submit" && control._pendingChange) {
      dir.viewToModelUpdate(control._pendingValue);
      control._pendingChange = false;
    }
  });
}
function selectValueAccessor(dir, valueAccessors) {
  if (!valueAccessors) return null;
  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === "undefined" || ngDevMode)) _throwInvalidValueAccessorError(dir);
  let defaultAccessor = void 0;
  let builtinAccessor = void 0;
  let customAccessor = void 0;
  valueAccessors.forEach((v) => {
    if (v.constructor === DefaultValueAccessor) {
      defaultAccessor = v;
    } else if (isBuiltInAccessor(v)) {
      if (builtinAccessor && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "More than one built-in value accessor matches form control with");
      builtinAccessor = v;
    } else {
      if (customAccessor && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "More than one custom value accessor matches form control with");
      customAccessor = v;
    }
  });
  if (customAccessor) return customAccessor;
  if (builtinAccessor) return builtinAccessor;
  if (defaultAccessor) return defaultAccessor;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    _throwError(dir, "No valid value accessor for form control with");
  }
  return null;
}
function removeListItem$1(list, el2) {
  const index = list.indexOf(el2);
  if (index > -1) list.splice(index, 1);
}
function _ngModelWarning(name, type, instance, warningConfig) {
  if (warningConfig === "never") return;
  if ((warningConfig === null || warningConfig === "once") && !type._ngModelWarningSentOnce || warningConfig === "always" && !instance._ngModelWarningSent) {
    console.warn(ngModelWarning(name));
    type._ngModelWarningSentOnce = true;
    instance._ngModelWarningSent = true;
  }
}
function removeListItem(list, el2) {
  const index = list.indexOf(el2);
  if (index > -1) list.splice(index, 1);
}
function isFormControlState(formState) {
  return typeof formState === "object" && formState !== null && Object.keys(formState).length === 2 && "value" in formState && "disabled" in formState;
}
function modelParentException() {
  return new RuntimeError(1350, `
    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using
    formGroup's partner directive "formControlName" instead.  Example:

    ${formControlNameExample}

    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:

    Example:

    ${ngModelWithFormGroupExample}`);
}
function formGroupNameException() {
  return new RuntimeError(1351, `
    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.

    Option 1: Use formControlName instead of ngModel (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):

    ${ngModelGroupExample}`);
}
function missingNameException() {
  return new RuntimeError(1352, `If ngModel is used within a form tag, either the name attribute must be set or the form
    control must be defined as 'standalone' in ngModelOptions.

    Example 1: <input [(ngModel)]="person.firstName" name="first">
    Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">`);
}
function modelGroupParentException() {
  return new RuntimeError(1353, `
    ngModelGroup cannot be used with a parent formGroup directive.

    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):

    ${ngModelGroupExample}`);
}
function checkParentType$1(parent) {
  if (!(parent instanceof NgModelGroup) && parent instanceof AbstractFormGroupDirective) {
    throw formGroupNameException();
  } else if (!(parent instanceof NgModelGroup) && !(parent instanceof NgForm)) {
    throw modelParentException();
  }
}
function throwNameError() {
  throw new RuntimeError(1202, `
      If you define both a name and a formControlName attribute on your radio button, their values
      must match. Ex: <input type="radio" formControlName="food" name="food">
    `);
}
function hasInvalidParent(parent) {
  return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName);
}
function checkParentType(parent, name) {
  if (!(parent instanceof FormGroupName) && parent instanceof AbstractFormGroupDirective) {
    throw ngModelGroupException();
  } else if (!(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName)) {
    throw controlParentException(name);
  }
}
function _buildValueString$1(id2, value) {
  if (id2 == null) return `${value}`;
  if (value && typeof value === "object") value = "Object";
  return `${id2}: ${value}`.slice(0, 50);
}
function _extractId$1(valueString) {
  return valueString.split(":")[0];
}
function _buildValueString(id2, value) {
  if (id2 == null) return `${value}`;
  if (typeof value === "string") value = `'${value}'`;
  if (value && typeof value === "object") value = "Object";
  return `${id2}: ${value}`.slice(0, 50);
}
function _extractId(valueString) {
  return valueString.split(":")[0];
}
function toInteger(value) {
  return typeof value === "number" ? value : parseInt(value, 10);
}
function toFloat(value) {
  return typeof value === "number" ? value : parseFloat(value);
}
function isAbstractControlOptions(options) {
  return !!options && (options.asyncValidators !== void 0 || options.validators !== void 0 || options.updateOn !== void 0);
}
var BaseControlValueAccessor, BuiltInControlValueAccessor, NG_VALUE_ACCESSOR, CHECKBOX_VALUE_ACCESSOR, CheckboxControlValueAccessor, DEFAULT_VALUE_ACCESSOR, COMPOSITION_BUFFER_MODE, DefaultValueAccessor, NG_VALIDATORS, NG_ASYNC_VALIDATORS, EMAIL_REGEXP, AbstractControlDirective, ControlContainer, NgControl, AbstractControlStatus, ngControlStatusHost, ngGroupStatusHost, NgControlStatus, NgControlStatusGroup, formControlNameExample, formGroupNameExample, formArrayNameExample, ngModelGroupExample, ngModelWithFormGroupExample, disabledAttrWarning, asyncValidatorsDroppedWithOptsWarning, VALID, INVALID, PENDING, DISABLED, ControlEvent, ValueChangeEvent, PristineChangeEvent, TouchedChangeEvent, StatusChangeEvent, FormSubmittedEvent, FormResetEvent, AbstractControl, FormGroup, FormRecord, CALL_SET_DISABLED_STATE, setDisabledStateDefault, formDirectiveProvider$1, resolvedPromise$1, NgForm, FormControl, isFormControl, AbstractFormGroupDirective, modelGroupProvider, NgModelGroup, formControlBinding$1, resolvedPromise, NgModel, \u0275NgNoValidate, NUMBER_VALUE_ACCESSOR, NumberValueAccessor, RADIO_VALUE_ACCESSOR, RadioControlRegistry, RadioControlValueAccessor, RANGE_VALUE_ACCESSOR, RangeValueAccessor, NG_MODEL_WITH_FORM_CONTROL_WARNING, formControlBinding, FormControlDirective, formDirectiveProvider, FormGroupDirective, formGroupNameProvider, FormGroupName, formArrayNameProvider, FormArrayName, controlNameBinding, FormControlName, SELECT_VALUE_ACCESSOR, SelectControlValueAccessor, NgSelectOption, SELECT_MULTIPLE_VALUE_ACCESSOR, SelectMultipleControlValueAccessor, \u0275NgSelectMultipleOption, AbstractValidatorDirective, MAX_VALIDATOR, MaxValidator, MIN_VALIDATOR, MinValidator, REQUIRED_VALIDATOR, CHECKBOX_REQUIRED_VALIDATOR, RequiredValidator, CheckboxRequiredValidator, EMAIL_VALIDATOR, EmailValidator, MIN_LENGTH_VALIDATOR, MinLengthValidator, MAX_LENGTH_VALIDATOR, MaxLengthValidator, PATTERN_VALIDATOR, PatternValidator, SHARED_FORM_DIRECTIVES, TEMPLATE_DRIVEN_DIRECTIVES, REACTIVE_DRIVEN_DIRECTIVES, \u0275InternalFormsSharedModule, FormArray, FormBuilder, NonNullableFormBuilder, UntypedFormBuilder, VERSION5, FormsModule, ReactiveFormsModule;
var init_forms = __esm({
  "node_modules/@angular/forms/fesm2022/forms.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_common();
    init_esm();
    init_operators();
    BaseControlValueAccessor = class _BaseControlValueAccessor {
      _renderer;
      _elementRef;
      /**
       * The registered callback function called when a change or input event occurs on the input
       * element.
       * @docs-private
       */
      onChange = (_2) => {
      };
      /**
       * The registered callback function called when a blur event occurs on the input element.
       * @docs-private
       */
      onTouched = () => {
      };
      constructor(_renderer, _elementRef) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
      }
      /**
       * Helper method that sets a property on a target element using the current Renderer
       * implementation.
       * @docs-private
       */
      setProperty(key, value) {
        this._renderer.setProperty(this._elementRef.nativeElement, key, value);
      }
      /**
       * Registers a function called when the control is touched.
       * @docs-private
       */
      registerOnTouched(fn) {
        this.onTouched = fn;
      }
      /**
       * Registers a function called when the control value changes.
       * @docs-private
       */
      registerOnChange(fn) {
        this.onChange = fn;
      }
      /**
       * Sets the "disabled" property on the range input element.
       * @docs-private
       */
      setDisabledState(isDisabled) {
        this.setProperty("disabled", isDisabled);
      }
      static \u0275fac = function BaseControlValueAccessor_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _BaseControlValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _BaseControlValueAccessor
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseControlValueAccessor, [{
        type: Directive
      }], () => [{
        type: Renderer2
      }, {
        type: ElementRef
      }], null);
    })();
    BuiltInControlValueAccessor = class _BuiltInControlValueAccessor extends BaseControlValueAccessor {
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275BuiltInControlValueAccessor_BaseFactory;
        return function BuiltInControlValueAccessor_Factory(__ngFactoryType__) {
          return (\u0275BuiltInControlValueAccessor_BaseFactory || (\u0275BuiltInControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_BuiltInControlValueAccessor)))(__ngFactoryType__ || _BuiltInControlValueAccessor);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _BuiltInControlValueAccessor,
        features: [\u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BuiltInControlValueAccessor, [{
        type: Directive
      }], null, null);
    })();
    NG_VALUE_ACCESSOR = new InjectionToken(ngDevMode ? "NgValueAccessor" : "");
    CHECKBOX_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => CheckboxControlValueAccessor),
      multi: true
    };
    CheckboxControlValueAccessor = class _CheckboxControlValueAccessor extends BuiltInControlValueAccessor {
      /**
       * Sets the "checked" property on the input element.
       * @docs-private
       */
      writeValue(value) {
        this.setProperty("checked", value);
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275CheckboxControlValueAccessor_BaseFactory;
        return function CheckboxControlValueAccessor_Factory(__ngFactoryType__) {
          return (\u0275CheckboxControlValueAccessor_BaseFactory || (\u0275CheckboxControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_CheckboxControlValueAccessor)))(__ngFactoryType__ || _CheckboxControlValueAccessor);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CheckboxControlValueAccessor,
        selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]],
        hostBindings: function CheckboxControlValueAccessor_HostBindings(rf2, ctx) {
          if (rf2 & 1) {
            \u0275\u0275listener("change", function CheckboxControlValueAccessor_change_HostBindingHandler($event) {
              return ctx.onChange($event.target.checked);
            })("blur", function CheckboxControlValueAccessor_blur_HostBindingHandler() {
              return ctx.onTouched();
            });
          }
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([CHECKBOX_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxControlValueAccessor, [{
        type: Directive,
        args: [{
          selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]",
          host: {
            "(change)": "onChange($any($event.target).checked)",
            "(blur)": "onTouched()"
          },
          providers: [CHECKBOX_VALUE_ACCESSOR],
          standalone: false
        }]
      }], null, null);
    })();
    DEFAULT_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => DefaultValueAccessor),
      multi: true
    };
    COMPOSITION_BUFFER_MODE = new InjectionToken(ngDevMode ? "CompositionEventMode" : "");
    DefaultValueAccessor = class _DefaultValueAccessor extends BaseControlValueAccessor {
      _compositionMode;
      /** Whether the user is creating a composition string (IME events). */
      _composing = false;
      constructor(renderer, elementRef, _compositionMode) {
        super(renderer, elementRef);
        this._compositionMode = _compositionMode;
        if (this._compositionMode == null) {
          this._compositionMode = !_isAndroid();
        }
      }
      /**
       * Sets the "value" property on the input element.
       * @docs-private
       */
      writeValue(value) {
        const normalizedValue = value == null ? "" : value;
        this.setProperty("value", normalizedValue);
      }
      /** @internal */
      _handleInput(value) {
        if (!this._compositionMode || this._compositionMode && !this._composing) {
          this.onChange(value);
        }
      }
      /** @internal */
      _compositionStart() {
        this._composing = true;
      }
      /** @internal */
      _compositionEnd(value) {
        this._composing = false;
        this._compositionMode && this.onChange(value);
      }
      static \u0275fac = function DefaultValueAccessor_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DefaultValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(COMPOSITION_BUFFER_MODE, 8));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _DefaultValueAccessor,
        selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]],
        hostBindings: function DefaultValueAccessor_HostBindings(rf2, ctx) {
          if (rf2 & 1) {
            \u0275\u0275listener("input", function DefaultValueAccessor_input_HostBindingHandler($event) {
              return ctx._handleInput($event.target.value);
            })("blur", function DefaultValueAccessor_blur_HostBindingHandler() {
              return ctx.onTouched();
            })("compositionstart", function DefaultValueAccessor_compositionstart_HostBindingHandler() {
              return ctx._compositionStart();
            })("compositionend", function DefaultValueAccessor_compositionend_HostBindingHandler($event) {
              return ctx._compositionEnd($event.target.value);
            });
          }
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([DEFAULT_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultValueAccessor, [{
        type: Directive,
        args: [{
          selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]",
          // TODO: vsavkin replace the above selector with the one below it once
          // https://github.com/angular/angular/issues/3011 is implemented
          // selector: '[ngModel],[formControl],[formControlName]',
          host: {
            "(input)": "_handleInput($any($event.target).value)",
            "(blur)": "onTouched()",
            "(compositionstart)": "_compositionStart()",
            "(compositionend)": "_compositionEnd($any($event.target).value)"
          },
          providers: [DEFAULT_VALUE_ACCESSOR],
          standalone: false
        }]
      }], () => [{
        type: Renderer2
      }, {
        type: ElementRef
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [COMPOSITION_BUFFER_MODE]
        }]
      }], null);
    })();
    NG_VALIDATORS = new InjectionToken(ngDevMode ? "NgValidators" : "");
    NG_ASYNC_VALIDATORS = new InjectionToken(ngDevMode ? "NgAsyncValidators" : "");
    EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    AbstractControlDirective = class {
      /**
       * @description
       * Reports the value of the control if it is present, otherwise null.
       */
      get value() {
        return this.control ? this.control.value : null;
      }
      /**
       * @description
       * Reports whether the control is valid. A control is considered valid if no
       * validation errors exist with the current value.
       * If the control is not present, null is returned.
       */
      get valid() {
        return this.control ? this.control.valid : null;
      }
      /**
       * @description
       * Reports whether the control is invalid, meaning that an error exists in the input value.
       * If the control is not present, null is returned.
       */
      get invalid() {
        return this.control ? this.control.invalid : null;
      }
      /**
       * @description
       * Reports whether a control is pending, meaning that async validation is occurring and
       * errors are not yet available for the input value. If the control is not present, null is
       * returned.
       */
      get pending() {
        return this.control ? this.control.pending : null;
      }
      /**
       * @description
       * Reports whether the control is disabled, meaning that the control is disabled
       * in the UI and is exempt from validation checks and excluded from aggregate
       * values of ancestor controls. If the control is not present, null is returned.
       */
      get disabled() {
        return this.control ? this.control.disabled : null;
      }
      /**
       * @description
       * Reports whether the control is enabled, meaning that the control is included in ancestor
       * calculations of validity or value. If the control is not present, null is returned.
       */
      get enabled() {
        return this.control ? this.control.enabled : null;
      }
      /**
       * @description
       * Reports the control's validation errors. If the control is not present, null is returned.
       */
      get errors() {
        return this.control ? this.control.errors : null;
      }
      /**
       * @description
       * Reports whether the control is pristine, meaning that the user has not yet changed
       * the value in the UI. If the control is not present, null is returned.
       */
      get pristine() {
        return this.control ? this.control.pristine : null;
      }
      /**
       * @description
       * Reports whether the control is dirty, meaning that the user has changed
       * the value in the UI. If the control is not present, null is returned.
       */
      get dirty() {
        return this.control ? this.control.dirty : null;
      }
      /**
       * @description
       * Reports whether the control is touched, meaning that the user has triggered
       * a `blur` event on it. If the control is not present, null is returned.
       */
      get touched() {
        return this.control ? this.control.touched : null;
      }
      /**
       * @description
       * Reports the validation status of the control. Possible values include:
       * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.
       * If the control is not present, null is returned.
       */
      get status() {
        return this.control ? this.control.status : null;
      }
      /**
       * @description
       * Reports whether the control is untouched, meaning that the user has not yet triggered
       * a `blur` event on it. If the control is not present, null is returned.
       */
      get untouched() {
        return this.control ? this.control.untouched : null;
      }
      /**
       * @description
       * Returns a multicasting observable that emits a validation status whenever it is
       * calculated for the control. If the control is not present, null is returned.
       */
      get statusChanges() {
        return this.control ? this.control.statusChanges : null;
      }
      /**
       * @description
       * Returns a multicasting observable of value changes for the control that emits every time the
       * value of the control changes in the UI or programmatically.
       * If the control is not present, null is returned.
       */
      get valueChanges() {
        return this.control ? this.control.valueChanges : null;
      }
      /**
       * @description
       * Returns an array that represents the path from the top-level form to this control.
       * Each index is the string name of the control on that level.
       */
      get path() {
        return null;
      }
      /**
       * Contains the result of merging synchronous validators into a single validator function
       * (combined using `Validators.compose`).
       */
      _composedValidatorFn;
      /**
       * Contains the result of merging asynchronous validators into a single validator function
       * (combined using `Validators.composeAsync`).
       */
      _composedAsyncValidatorFn;
      /**
       * Set of synchronous validators as they were provided while calling `setValidators` function.
       * @internal
       */
      _rawValidators = [];
      /**
       * Set of asynchronous validators as they were provided while calling `setAsyncValidators`
       * function.
       * @internal
       */
      _rawAsyncValidators = [];
      /**
       * Sets synchronous validators for this directive.
       * @internal
       */
      _setValidators(validators) {
        this._rawValidators = validators || [];
        this._composedValidatorFn = composeValidators(this._rawValidators);
      }
      /**
       * Sets asynchronous validators for this directive.
       * @internal
       */
      _setAsyncValidators(validators) {
        this._rawAsyncValidators = validators || [];
        this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);
      }
      /**
       * @description
       * Synchronous validator function composed of all the synchronous validators registered with this
       * directive.
       */
      get validator() {
        return this._composedValidatorFn || null;
      }
      /**
       * @description
       * Asynchronous validator function composed of all the asynchronous validators registered with
       * this directive.
       */
      get asyncValidator() {
        return this._composedAsyncValidatorFn || null;
      }
      /*
       * The set of callbacks to be invoked when directive instance is being destroyed.
       */
      _onDestroyCallbacks = [];
      /**
       * Internal function to register callbacks that should be invoked
       * when directive instance is being destroyed.
       * @internal
       */
      _registerOnDestroy(fn) {
        this._onDestroyCallbacks.push(fn);
      }
      /**
       * Internal function to invoke all registered "on destroy" callbacks.
       * Note: calling this function also clears the list of callbacks.
       * @internal
       */
      _invokeOnDestroyCallbacks() {
        this._onDestroyCallbacks.forEach((fn) => fn());
        this._onDestroyCallbacks = [];
      }
      /**
       * @description
       * Resets the control with the provided value if the control is present.
       */
      reset(value = void 0) {
        if (this.control) this.control.reset(value);
      }
      /**
       * @description
       * Reports whether the control with the given path has the error specified.
       *
       * @param errorCode The code of the error to check
       * @param path A list of control names that designates how to move from the current control
       * to the control that should be queried for errors.
       *
       * @usageNotes
       * For example, for the following `FormGroup`:
       *
       * ```ts
       * form = new FormGroup({
       *   address: new FormGroup({ street: new FormControl() })
       * });
       * ```
       *
       * The path to the 'street' control from the root form would be 'address' -> 'street'.
       *
       * It can be provided to this method in one of two formats:
       *
       * 1. An array of string control names, e.g. `['address', 'street']`
       * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
       *
       * If no path is given, this method checks for the error on the current control.
       *
       * @returns whether the given error is present in the control at the given path.
       *
       * If the control is not present, false is returned.
       */
      hasError(errorCode, path) {
        return this.control ? this.control.hasError(errorCode, path) : false;
      }
      /**
       * @description
       * Reports error data for the control with the given path.
       *
       * @param errorCode The code of the error to check
       * @param path A list of control names that designates how to move from the current control
       * to the control that should be queried for errors.
       *
       * @usageNotes
       * For example, for the following `FormGroup`:
       *
       * ```ts
       * form = new FormGroup({
       *   address: new FormGroup({ street: new FormControl() })
       * });
       * ```
       *
       * The path to the 'street' control from the root form would be 'address' -> 'street'.
       *
       * It can be provided to this method in one of two formats:
       *
       * 1. An array of string control names, e.g. `['address', 'street']`
       * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
       *
       * @returns error data for that particular error. If the control or error is not present,
       * null is returned.
       */
      getError(errorCode, path) {
        return this.control ? this.control.getError(errorCode, path) : null;
      }
    };
    ControlContainer = class extends AbstractControlDirective {
      /**
       * @description
       * The name for the control
       */
      name;
      /**
       * @description
       * The top-level form directive for the control.
       */
      get formDirective() {
        return null;
      }
      /**
       * @description
       * The path to this group.
       */
      get path() {
        return null;
      }
    };
    NgControl = class extends AbstractControlDirective {
      /**
       * @description
       * The parent form for the control.
       *
       * @internal
       */
      _parent = null;
      /**
       * @description
       * The name for the control
       */
      name = null;
      /**
       * @description
       * The value accessor for the control
       */
      valueAccessor = null;
    };
    AbstractControlStatus = class {
      _cd;
      constructor(cd2) {
        this._cd = cd2;
      }
      get isTouched() {
        this._cd?.control?._touched?.();
        return !!this._cd?.control?.touched;
      }
      get isUntouched() {
        return !!this._cd?.control?.untouched;
      }
      get isPristine() {
        this._cd?.control?._pristine?.();
        return !!this._cd?.control?.pristine;
      }
      get isDirty() {
        return !!this._cd?.control?.dirty;
      }
      get isValid() {
        this._cd?.control?._status?.();
        return !!this._cd?.control?.valid;
      }
      get isInvalid() {
        return !!this._cd?.control?.invalid;
      }
      get isPending() {
        return !!this._cd?.control?.pending;
      }
      get isSubmitted() {
        this._cd?._submitted?.();
        return !!this._cd?.submitted;
      }
    };
    ngControlStatusHost = {
      "[class.ng-untouched]": "isUntouched",
      "[class.ng-touched]": "isTouched",
      "[class.ng-pristine]": "isPristine",
      "[class.ng-dirty]": "isDirty",
      "[class.ng-valid]": "isValid",
      "[class.ng-invalid]": "isInvalid",
      "[class.ng-pending]": "isPending"
    };
    ngGroupStatusHost = __spreadProps(__spreadValues({}, ngControlStatusHost), {
      "[class.ng-submitted]": "isSubmitted"
    });
    NgControlStatus = class _NgControlStatus extends AbstractControlStatus {
      constructor(cd2) {
        super(cd2);
      }
      static \u0275fac = function NgControlStatus_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgControlStatus)(\u0275\u0275directiveInject(NgControl, 2));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgControlStatus,
        selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]],
        hostVars: 14,
        hostBindings: function NgControlStatus_HostBindings(rf2, ctx) {
          if (rf2 & 2) {
            \u0275\u0275classProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending);
          }
        },
        standalone: false,
        features: [\u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatus, [{
        type: Directive,
        args: [{
          selector: "[formControlName],[ngModel],[formControl]",
          host: ngControlStatusHost,
          standalone: false
        }]
      }], () => [{
        type: NgControl,
        decorators: [{
          type: Self
        }]
      }], null);
    })();
    NgControlStatusGroup = class _NgControlStatusGroup extends AbstractControlStatus {
      constructor(cd2) {
        super(cd2);
      }
      static \u0275fac = function NgControlStatusGroup_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgControlStatusGroup)(\u0275\u0275directiveInject(ControlContainer, 10));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgControlStatusGroup,
        selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]],
        hostVars: 16,
        hostBindings: function NgControlStatusGroup_HostBindings(rf2, ctx) {
          if (rf2 & 2) {
            \u0275\u0275classProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending)("ng-submitted", ctx.isSubmitted);
          }
        },
        standalone: false,
        features: [\u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatusGroup, [{
        type: Directive,
        args: [{
          selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]",
          host: ngGroupStatusHost,
          standalone: false
        }]
      }], () => [{
        type: ControlContainer,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }]
      }], null);
    })();
    formControlNameExample = `
  <div [formGroup]="myGroup">
    <input formControlName="firstName">
  </div>

  In your class:

  this.myGroup = new FormGroup({
      firstName: new FormControl()
  });`;
    formGroupNameExample = `
  <div [formGroup]="myGroup">
      <div formGroupName="person">
        <input formControlName="firstName">
      </div>
  </div>

  In your class:

  this.myGroup = new FormGroup({
      person: new FormGroup({ firstName: new FormControl() })
  });`;
    formArrayNameExample = `
  <div [formGroup]="myGroup">
    <div formArrayName="cities">
      <div *ngFor="let city of cityArray.controls; index as i">
        <input [formControlName]="i">
      </div>
    </div>
  </div>

  In your class:

  this.cityArray = new FormArray([new FormControl('SF')]);
  this.myGroup = new FormGroup({
    cities: this.cityArray
  });`;
    ngModelGroupExample = `
  <form>
      <div ngModelGroup="person">
        <input [(ngModel)]="person.name" name="firstName">
      </div>
  </form>`;
    ngModelWithFormGroupExample = `
  <div [formGroup]="myGroup">
      <input formControlName="firstName">
      <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">
  </div>
`;
    disabledAttrWarning = `
  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true
  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for
  you. We recommend using this approach to avoid 'changed after checked' errors.

  Example:
  // Specify the \`disabled\` property at control creation time:
  form = new FormGroup({
    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),
    last: new FormControl('Drew', Validators.required)
  });

  // Controls can also be enabled/disabled after creation:
  form.get('first')?.enable();
  form.get('last')?.disable();
`;
    asyncValidatorsDroppedWithOptsWarning = `
  It looks like you're constructing using a FormControl with both an options argument and an
  async validators argument. Mixing these arguments will cause your async validators to be dropped.
  You should either put all your validators in the options object, or in separate validators
  arguments. For example:

  // Using validators arguments
  fc = new FormControl(42, Validators.required, myAsyncValidator);

  // Using AbstractControlOptions
  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});

  // Do NOT mix them: async validators will be dropped!
  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);
`;
    VALID = "VALID";
    INVALID = "INVALID";
    PENDING = "PENDING";
    DISABLED = "DISABLED";
    ControlEvent = class {
    };
    ValueChangeEvent = class extends ControlEvent {
      value;
      source;
      constructor(value, source) {
        super();
        this.value = value;
        this.source = source;
      }
    };
    PristineChangeEvent = class extends ControlEvent {
      pristine;
      source;
      constructor(pristine, source) {
        super();
        this.pristine = pristine;
        this.source = source;
      }
    };
    TouchedChangeEvent = class extends ControlEvent {
      touched;
      source;
      constructor(touched, source) {
        super();
        this.touched = touched;
        this.source = source;
      }
    };
    StatusChangeEvent = class extends ControlEvent {
      status;
      source;
      constructor(status, source) {
        super();
        this.status = status;
        this.source = source;
      }
    };
    FormSubmittedEvent = class extends ControlEvent {
      source;
      constructor(source) {
        super();
        this.source = source;
      }
    };
    FormResetEvent = class extends ControlEvent {
      source;
      constructor(source) {
        super();
        this.source = source;
      }
    };
    AbstractControl = class {
      /** @internal */
      _pendingDirty = false;
      /**
       * Indicates that a control has its own pending asynchronous validation in progress.
       * It also stores if the control should emit events when the validation status changes.
       *
       * @internal
       */
      _hasOwnPendingAsyncValidator = null;
      /** @internal */
      _pendingTouched = false;
      /** @internal */
      _onCollectionChange = () => {
      };
      /** @internal */
      _updateOn;
      _parent = null;
      _asyncValidationSubscription;
      /**
       * Contains the result of merging synchronous validators into a single validator function
       * (combined using `Validators.compose`).
       *
       * @internal
       */
      _composedValidatorFn;
      /**
       * Contains the result of merging asynchronous validators into a single validator function
       * (combined using `Validators.composeAsync`).
       *
       * @internal
       */
      _composedAsyncValidatorFn;
      /**
       * Synchronous validators as they were provided:
       *  - in `AbstractControl` constructor
       *  - as an argument while calling `setValidators` function
       *  - while calling the setter on the `validator` field (e.g. `control.validator = validatorFn`)
       *
       * @internal
       */
      _rawValidators;
      /**
       * Asynchronous validators as they were provided:
       *  - in `AbstractControl` constructor
       *  - as an argument while calling `setAsyncValidators` function
       *  - while calling the setter on the `asyncValidator` field (e.g. `control.asyncValidator =
       * asyncValidatorFn`)
       *
       * @internal
       */
      _rawAsyncValidators;
      /**
       * The current value of the control.
       *
       * * For a `FormControl`, the current value.
       * * For an enabled `FormGroup`, the values of enabled controls as an object
       * with a key-value pair for each member of the group.
       * * For a disabled `FormGroup`, the values of all controls as an object
       * with a key-value pair for each member of the group.
       * * For a `FormArray`, the values of enabled controls as an array.
       *
       */
      value;
      /**
       * Initialize the AbstractControl instance.
       *
       * @param validators The function or array of functions that is used to determine the validity of
       *     this control synchronously.
       * @param asyncValidators The function or array of functions that is used to determine validity of
       *     this control asynchronously.
       */
      constructor(validators, asyncValidators) {
        this._assignValidators(validators);
        this._assignAsyncValidators(asyncValidators);
      }
      /**
       * Returns the function that is used to determine the validity of this control synchronously.
       * If multiple validators have been added, this will be a single composed function.
       * See `Validators.compose()` for additional information.
       */
      get validator() {
        return this._composedValidatorFn;
      }
      set validator(validatorFn) {
        this._rawValidators = this._composedValidatorFn = validatorFn;
      }
      /**
       * Returns the function that is used to determine the validity of this control asynchronously.
       * If multiple validators have been added, this will be a single composed function.
       * See `Validators.compose()` for additional information.
       */
      get asyncValidator() {
        return this._composedAsyncValidatorFn;
      }
      set asyncValidator(asyncValidatorFn) {
        this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;
      }
      /**
       * The parent control.
       */
      get parent() {
        return this._parent;
      }
      /**
       * The validation status of the control.
       *
       * @see {@link FormControlStatus}
       *
       * These status values are mutually exclusive, so a control cannot be
       * both valid AND invalid or invalid AND disabled.
       */
      get status() {
        return untracked2(this.statusReactive);
      }
      set status(v) {
        untracked2(() => this.statusReactive.set(v));
      }
      /** @internal */
      _status = computed(() => this.statusReactive(), ...ngDevMode ? [{
        debugName: "_status"
      }] : []);
      statusReactive = signal(void 0, ...ngDevMode ? [{
        debugName: "statusReactive"
      }] : []);
      /**
       * A control is `valid` when its `status` is `VALID`.
       *
       * @see {@link AbstractControl.status}
       *
       * @returns True if the control has passed all of its validation tests,
       * false otherwise.
       */
      get valid() {
        return this.status === VALID;
      }
      /**
       * A control is `invalid` when its `status` is `INVALID`.
       *
       * @see {@link AbstractControl.status}
       *
       * @returns True if this control has failed one or more of its validation checks,
       * false otherwise.
       */
      get invalid() {
        return this.status === INVALID;
      }
      /**
       * A control is `pending` when its `status` is `PENDING`.
       *
       * @see {@link AbstractControl.status}
       *
       * @returns True if this control is in the process of conducting a validation check,
       * false otherwise.
       */
      get pending() {
        return this.status == PENDING;
      }
      /**
       * A control is `disabled` when its `status` is `DISABLED`.
       *
       * Disabled controls are exempt from validation checks and
       * are not included in the aggregate value of their ancestor
       * controls.
       *
       * @see {@link AbstractControl.status}
       *
       * @returns True if the control is disabled, false otherwise.
       */
      get disabled() {
        return this.status === DISABLED;
      }
      /**
       * A control is `enabled` as long as its `status` is not `DISABLED`.
       *
       * @returns True if the control has any status other than 'DISABLED',
       * false if the status is 'DISABLED'.
       *
       * @see {@link AbstractControl.status}
       *
       */
      get enabled() {
        return this.status !== DISABLED;
      }
      /**
       * An object containing any errors generated by failing validation,
       * or null if there are no errors.
       */
      errors;
      /**
       * A control is `pristine` if the user has not yet changed
       * the value in the UI.
       *
       * @returns True if the user has not yet changed the value in the UI; compare `dirty`.
       * Programmatic changes to a control's value do not mark it dirty.
       */
      get pristine() {
        return untracked2(this.pristineReactive);
      }
      set pristine(v) {
        untracked2(() => this.pristineReactive.set(v));
      }
      /** @internal */
      _pristine = computed(() => this.pristineReactive(), ...ngDevMode ? [{
        debugName: "_pristine"
      }] : []);
      pristineReactive = signal(true, ...ngDevMode ? [{
        debugName: "pristineReactive"
      }] : []);
      /**
       * A control is `dirty` if the user has changed the value
       * in the UI.
       *
       * @returns True if the user has changed the value of this control in the UI; compare `pristine`.
       * Programmatic changes to a control's value do not mark it dirty.
       */
      get dirty() {
        return !this.pristine;
      }
      /**
       * True if the control is marked as `touched`.
       *
       * A control is marked `touched` once the user has triggered
       * a `blur` event on it.
       */
      get touched() {
        return untracked2(this.touchedReactive);
      }
      set touched(v) {
        untracked2(() => this.touchedReactive.set(v));
      }
      /** @internal */
      _touched = computed(() => this.touchedReactive(), ...ngDevMode ? [{
        debugName: "_touched"
      }] : []);
      touchedReactive = signal(false, ...ngDevMode ? [{
        debugName: "touchedReactive"
      }] : []);
      /**
       * True if the control has not been marked as touched
       *
       * A control is `untouched` if the user has not yet triggered
       * a `blur` event on it.
       */
      get untouched() {
        return !this.touched;
      }
      /**
       * Exposed as observable, see below.
       *
       * @internal
       */
      _events = new Subject();
      /**
       * A multicasting observable that emits an event every time the state of the control changes.
       * It emits for value, status, pristine or touched changes.
       *
       * **Note**: On value change, the emit happens right after a value of this control is updated. The
       * value of a parent control (for example if this FormControl is a part of a FormGroup) is updated
       * later, so accessing a value of a parent control (using the `value` property) from the callback
       * of this event might result in getting a value that has not been updated yet. Subscribe to the
       * `events` of the parent control instead.
       * For other event types, the events are emitted after the parent control has been updated.
       *
       */
      events = this._events.asObservable();
      /**
       * A multicasting observable that emits an event every time the value of the control changes, in
       * the UI or programmatically. It also emits an event each time you call enable() or disable()
       * without passing along {emitEvent: false} as a function argument.
       *
       * **Note**: the emit happens right after a value of this control is updated. The value of a
       * parent control (for example if this FormControl is a part of a FormGroup) is updated later, so
       * accessing a value of a parent control (using the `value` property) from the callback of this
       * event might result in getting a value that has not been updated yet. Subscribe to the
       * `valueChanges` event of the parent control instead.
       */
      valueChanges;
      /**
       * A multicasting observable that emits an event every time the validation `status` of the control
       * recalculates.
       *
       * @see {@link FormControlStatus}
       * @see {@link AbstractControl.status}
       */
      statusChanges;
      /**
       * Reports the update strategy of the `AbstractControl` (meaning
       * the event on which the control updates itself).
       * Possible values: `'change'` | `'blur'` | `'submit'`
       * Default value: `'change'`
       */
      get updateOn() {
        return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change";
      }
      /**
       * Sets the synchronous validators that are active on this control.  Calling
       * this overwrites any existing synchronous validators.
       *
       * When you add or remove a validator at run time, you must call
       * `updateValueAndValidity()` for the new validation to take effect.
       *
       * If you want to add a new validator without affecting existing ones, consider
       * using `addValidators()` method instead.
       */
      setValidators(validators) {
        this._assignValidators(validators);
      }
      /**
       * Sets the asynchronous validators that are active on this control. Calling this
       * overwrites any existing asynchronous validators.
       *
       * When you add or remove a validator at run time, you must call
       * `updateValueAndValidity()` for the new validation to take effect.
       *
       * If you want to add a new validator without affecting existing ones, consider
       * using `addAsyncValidators()` method instead.
       */
      setAsyncValidators(validators) {
        this._assignAsyncValidators(validators);
      }
      /**
       * Add a synchronous validator or validators to this control, without affecting other validators.
       *
       * When you add or remove a validator at run time, you must call
       * `updateValueAndValidity()` for the new validation to take effect.
       *
       * Adding a validator that already exists will have no effect. If duplicate validator functions
       * are present in the `validators` array, only the first instance would be added to a form
       * control.
       *
       * @param validators The new validator function or functions to add to this control.
       */
      addValidators(validators) {
        this.setValidators(addValidators(validators, this._rawValidators));
      }
      /**
       * Add an asynchronous validator or validators to this control, without affecting other
       * validators.
       *
       * When you add or remove a validator at run time, you must call
       * `updateValueAndValidity()` for the new validation to take effect.
       *
       * Adding a validator that already exists will have no effect.
       *
       * @param validators The new asynchronous validator function or functions to add to this control.
       */
      addAsyncValidators(validators) {
        this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));
      }
      /**
       * Remove a synchronous validator from this control, without affecting other validators.
       * Validators are compared by function reference; you must pass a reference to the exact same
       * validator function as the one that was originally set. If a provided validator is not found,
       * it is ignored.
       *
       * @usageNotes
       *
       * ### Reference to a ValidatorFn
       *
       * ```
       * // Reference to the RequiredValidator
       * const ctrl = new FormControl<string | null>('', Validators.required);
       * ctrl.removeValidators(Validators.required);
       *
       * // Reference to anonymous function inside MinValidator
       * const minValidator = Validators.min(3);
       * const ctrl = new FormControl<string | null>('', minValidator);
       * expect(ctrl.hasValidator(minValidator)).toEqual(true)
       * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
       *
       * ctrl.removeValidators(minValidator);
       * ```
       *
       * When you add or remove a validator at run time, you must call
       * `updateValueAndValidity()` for the new validation to take effect.
       *
       * @param validators The validator or validators to remove.
       */
      removeValidators(validators) {
        this.setValidators(removeValidators(validators, this._rawValidators));
      }
      /**
       * Remove an asynchronous validator from this control, without affecting other validators.
       * Validators are compared by function reference; you must pass a reference to the exact same
       * validator function as the one that was originally set. If a provided validator is not found, it
       * is ignored.
       *
       * When you add or remove a validator at run time, you must call
       * `updateValueAndValidity()` for the new validation to take effect.
       *
       * @param validators The asynchronous validator or validators to remove.
       */
      removeAsyncValidators(validators) {
        this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));
      }
      /**
       * Check whether a synchronous validator function is present on this control. The provided
       * validator must be a reference to the exact same function that was provided.
       *
       * @usageNotes
       *
       * ### Reference to a ValidatorFn
       *
       * ```
       * // Reference to the RequiredValidator
       * const ctrl = new FormControl<number | null>(0, Validators.required);
       * expect(ctrl.hasValidator(Validators.required)).toEqual(true)
       *
       * // Reference to anonymous function inside MinValidator
       * const minValidator = Validators.min(3);
       * const ctrl = new FormControl<number | null>(0, minValidator);
       * expect(ctrl.hasValidator(minValidator)).toEqual(true)
       * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
       * ```
       *
       * @param validator The validator to check for presence. Compared by function reference.
       * @returns Whether the provided validator was found on this control.
       */
      hasValidator(validator) {
        return hasValidator(this._rawValidators, validator);
      }
      /**
       * Check whether an asynchronous validator function is present on this control. The provided
       * validator must be a reference to the exact same function that was provided.
       *
       * @param validator The asynchronous validator to check for presence. Compared by function
       *     reference.
       * @returns Whether the provided asynchronous validator was found on this control.
       */
      hasAsyncValidator(validator) {
        return hasValidator(this._rawAsyncValidators, validator);
      }
      /**
       * Empties out the synchronous validator list.
       *
       * When you add or remove a validator at run time, you must call
       * `updateValueAndValidity()` for the new validation to take effect.
       *
       */
      clearValidators() {
        this.validator = null;
      }
      /**
       * Empties out the async validator list.
       *
       * When you add or remove a validator at run time, you must call
       * `updateValueAndValidity()` for the new validation to take effect.
       *
       */
      clearAsyncValidators() {
        this.asyncValidator = null;
      }
      markAsTouched(opts = {}) {
        const changed = this.touched === false;
        this.touched = true;
        const sourceControl = opts.sourceControl ?? this;
        if (this._parent && !opts.onlySelf) {
          this._parent.markAsTouched(__spreadProps(__spreadValues({}, opts), {
            sourceControl
          }));
        }
        if (changed && opts.emitEvent !== false) {
          this._events.next(new TouchedChangeEvent(true, sourceControl));
        }
      }
      /**
       * Marks the control and all its descendant controls as `dirty`.
       * @see {@link markAsDirty()}
       *
       * @param opts Configuration options that determine how the control propagates changes
       * and emits events after marking is applied.
       * * `emitEvent`: When true or not supplied (the default), the `events`
       * observable emits a `PristineChangeEvent` with the `pristine` property being `false`.
       * When false, no events are emitted.
       */
      markAllAsDirty(opts = {}) {
        this.markAsDirty({
          onlySelf: true,
          emitEvent: opts.emitEvent,
          sourceControl: this
        });
        this._forEachChild((control) => control.markAllAsDirty(opts));
      }
      /**
       * Marks the control and all its descendant controls as `touched`.
       * @see {@link markAsTouched()}
       *
       * @param opts Configuration options that determine how the control propagates changes
       * and emits events after marking is applied.
       * * `emitEvent`: When true or not supplied (the default), the `events`
       * observable emits a `TouchedChangeEvent` with the `touched` property being `true`.
       * When false, no events are emitted.
       */
      markAllAsTouched(opts = {}) {
        this.markAsTouched({
          onlySelf: true,
          emitEvent: opts.emitEvent,
          sourceControl: this
        });
        this._forEachChild((control) => control.markAllAsTouched(opts));
      }
      markAsUntouched(opts = {}) {
        const changed = this.touched === true;
        this.touched = false;
        this._pendingTouched = false;
        const sourceControl = opts.sourceControl ?? this;
        this._forEachChild((control) => {
          control.markAsUntouched({
            onlySelf: true,
            emitEvent: opts.emitEvent,
            sourceControl
          });
        });
        if (this._parent && !opts.onlySelf) {
          this._parent._updateTouched(opts, sourceControl);
        }
        if (changed && opts.emitEvent !== false) {
          this._events.next(new TouchedChangeEvent(false, sourceControl));
        }
      }
      markAsDirty(opts = {}) {
        const changed = this.pristine === true;
        this.pristine = false;
        const sourceControl = opts.sourceControl ?? this;
        if (this._parent && !opts.onlySelf) {
          this._parent.markAsDirty(__spreadProps(__spreadValues({}, opts), {
            sourceControl
          }));
        }
        if (changed && opts.emitEvent !== false) {
          this._events.next(new PristineChangeEvent(false, sourceControl));
        }
      }
      markAsPristine(opts = {}) {
        const changed = this.pristine === false;
        this.pristine = true;
        this._pendingDirty = false;
        const sourceControl = opts.sourceControl ?? this;
        this._forEachChild((control) => {
          control.markAsPristine({
            onlySelf: true,
            emitEvent: opts.emitEvent
          });
        });
        if (this._parent && !opts.onlySelf) {
          this._parent._updatePristine(opts, sourceControl);
        }
        if (changed && opts.emitEvent !== false) {
          this._events.next(new PristineChangeEvent(true, sourceControl));
        }
      }
      markAsPending(opts = {}) {
        this.status = PENDING;
        const sourceControl = opts.sourceControl ?? this;
        if (opts.emitEvent !== false) {
          this._events.next(new StatusChangeEvent(this.status, sourceControl));
          this.statusChanges.emit(this.status);
        }
        if (this._parent && !opts.onlySelf) {
          this._parent.markAsPending(__spreadProps(__spreadValues({}, opts), {
            sourceControl
          }));
        }
      }
      disable(opts = {}) {
        const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
        this.status = DISABLED;
        this.errors = null;
        this._forEachChild((control) => {
          control.disable(__spreadProps(__spreadValues({}, opts), {
            onlySelf: true
          }));
        });
        this._updateValue();
        const sourceControl = opts.sourceControl ?? this;
        if (opts.emitEvent !== false) {
          this._events.next(new ValueChangeEvent(this.value, sourceControl));
          this._events.next(new StatusChangeEvent(this.status, sourceControl));
          this.valueChanges.emit(this.value);
          this.statusChanges.emit(this.status);
        }
        this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
          skipPristineCheck
        }), this);
        this._onDisabledChange.forEach((changeFn) => changeFn(true));
      }
      /**
       * Enables the control. This means the control is included in validation checks and
       * the aggregate value of its parent. Its status recalculates based on its value and
       * its validators.
       *
       * By default, if the control has children, all children are enabled.
       *
       * @see {@link AbstractControl.status}
       *
       * @param opts Configure options that control how the control propagates changes and
       * emits events when marked as untouched
       * * `onlySelf`: When true, mark only this control. When false or not supplied,
       * marks all direct ancestors. Default is false.
       * * `emitEvent`: When true or not supplied (the default), the `statusChanges`,
       * `valueChanges` and `events`
       * observables emit events with the latest status and value when the control is enabled.
       * When false, no events are emitted.
       */
      enable(opts = {}) {
        const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
        this.status = VALID;
        this._forEachChild((control) => {
          control.enable(__spreadProps(__spreadValues({}, opts), {
            onlySelf: true
          }));
        });
        this.updateValueAndValidity({
          onlySelf: true,
          emitEvent: opts.emitEvent
        });
        this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
          skipPristineCheck
        }), this);
        this._onDisabledChange.forEach((changeFn) => changeFn(false));
      }
      _updateAncestors(opts, sourceControl) {
        if (this._parent && !opts.onlySelf) {
          this._parent.updateValueAndValidity(opts);
          if (!opts.skipPristineCheck) {
            this._parent._updatePristine({}, sourceControl);
          }
          this._parent._updateTouched({}, sourceControl);
        }
      }
      /**
       * Sets the parent of the control
       *
       * @param parent The new parent.
       */
      setParent(parent) {
        this._parent = parent;
      }
      /**
       * The raw value of this control. For most control implementations, the raw value will include
       * disabled children.
       */
      getRawValue() {
        return this.value;
      }
      updateValueAndValidity(opts = {}) {
        this._setInitialStatus();
        this._updateValue();
        if (this.enabled) {
          const shouldHaveEmitted = this._cancelExistingSubscription();
          this.errors = this._runValidator();
          this.status = this._calculateStatus();
          if (this.status === VALID || this.status === PENDING) {
            this._runAsyncValidator(shouldHaveEmitted, opts.emitEvent);
          }
        }
        const sourceControl = opts.sourceControl ?? this;
        if (opts.emitEvent !== false) {
          this._events.next(new ValueChangeEvent(this.value, sourceControl));
          this._events.next(new StatusChangeEvent(this.status, sourceControl));
          this.valueChanges.emit(this.value);
          this.statusChanges.emit(this.status);
        }
        if (this._parent && !opts.onlySelf) {
          this._parent.updateValueAndValidity(__spreadProps(__spreadValues({}, opts), {
            sourceControl
          }));
        }
      }
      /** @internal */
      _updateTreeValidity(opts = {
        emitEvent: true
      }) {
        this._forEachChild((ctrl) => ctrl._updateTreeValidity(opts));
        this.updateValueAndValidity({
          onlySelf: true,
          emitEvent: opts.emitEvent
        });
      }
      _setInitialStatus() {
        this.status = this._allControlsDisabled() ? DISABLED : VALID;
      }
      _runValidator() {
        return this.validator ? this.validator(this) : null;
      }
      _runAsyncValidator(shouldHaveEmitted, emitEvent) {
        if (this.asyncValidator) {
          this.status = PENDING;
          this._hasOwnPendingAsyncValidator = {
            emitEvent: emitEvent !== false,
            shouldHaveEmitted: shouldHaveEmitted !== false
          };
          const obs = toObservable(this.asyncValidator(this));
          this._asyncValidationSubscription = obs.subscribe((errors) => {
            this._hasOwnPendingAsyncValidator = null;
            this.setErrors(errors, {
              emitEvent,
              shouldHaveEmitted
            });
          });
        }
      }
      _cancelExistingSubscription() {
        if (this._asyncValidationSubscription) {
          this._asyncValidationSubscription.unsubscribe();
          const shouldHaveEmitted = (this._hasOwnPendingAsyncValidator?.emitEvent || this._hasOwnPendingAsyncValidator?.shouldHaveEmitted) ?? false;
          this._hasOwnPendingAsyncValidator = null;
          return shouldHaveEmitted;
        }
        return false;
      }
      setErrors(errors, opts = {}) {
        this.errors = errors;
        this._updateControlsErrors(opts.emitEvent !== false, this, opts.shouldHaveEmitted);
      }
      /**
       * Retrieves a child control given the control's name or path.
       *
       * @param path A dot-delimited string or array of string/number values that define the path to the
       * control. If a string is provided, passing it as a string literal will result in improved type
       * information. Likewise, if an array is provided, passing it `as const` will cause improved type
       * information to be available.
       *
       * @usageNotes
       * ### Retrieve a nested control
       *
       * For example, to get a `name` control nested within a `person` sub-group:
       *
       * * `this.form.get('person.name');`
       *
       * -OR-
       *
       * * `this.form.get(['person', 'name'] as const);` // `as const` gives improved typings
       *
       * ### Retrieve a control in a FormArray
       *
       * When accessing an element inside a FormArray, you can use an element index.
       * For example, to get a `price` control from the first element in an `items` array you can use:
       *
       * * `this.form.get('items.0.price');`
       *
       * -OR-
       *
       * * `this.form.get(['items', 0, 'price']);`
       */
      get(path) {
        let currPath = path;
        if (currPath == null) return null;
        if (!Array.isArray(currPath)) currPath = currPath.split(".");
        if (currPath.length === 0) return null;
        return currPath.reduce((control, name) => control && control._find(name), this);
      }
      /**
       * @description
       * Reports error data for the control with the given path.
       *
       * @param errorCode The code of the error to check
       * @param path A list of control names that designates how to move from the current control
       * to the control that should be queried for errors.
       *
       * @usageNotes
       * For example, for the following `FormGroup`:
       *
       * ```ts
       * form = new FormGroup({
       *   address: new FormGroup({ street: new FormControl() })
       * });
       * ```
       *
       * The path to the 'street' control from the root form would be 'address' -> 'street'.
       *
       * It can be provided to this method in one of two formats:
       *
       * 1. An array of string control names, e.g. `['address', 'street']`
       * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
       *
       * @returns error data for that particular error. If the control or error is not present,
       * null is returned.
       */
      getError(errorCode, path) {
        const control = path ? this.get(path) : this;
        return control && control.errors ? control.errors[errorCode] : null;
      }
      /**
       * @description
       * Reports whether the control with the given path has the error specified.
       *
       * @param errorCode The code of the error to check
       * @param path A list of control names that designates how to move from the current control
       * to the control that should be queried for errors.
       *
       * @usageNotes
       * For example, for the following `FormGroup`:
       *
       * ```ts
       * form = new FormGroup({
       *   address: new FormGroup({ street: new FormControl() })
       * });
       * ```
       *
       * The path to the 'street' control from the root form would be 'address' -> 'street'.
       *
       * It can be provided to this method in one of two formats:
       *
       * 1. An array of string control names, e.g. `['address', 'street']`
       * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
       *
       * If no path is given, this method checks for the error on the current control.
       *
       * @returns whether the given error is present in the control at the given path.
       *
       * If the control is not present, false is returned.
       */
      hasError(errorCode, path) {
        return !!this.getError(errorCode, path);
      }
      /**
       * Retrieves the top-level ancestor of this control.
       */
      get root() {
        let x2 = this;
        while (x2._parent) {
          x2 = x2._parent;
        }
        return x2;
      }
      /** @internal */
      _updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted) {
        this.status = this._calculateStatus();
        if (emitEvent) {
          this.statusChanges.emit(this.status);
        }
        if (emitEvent || shouldHaveEmitted) {
          this._events.next(new StatusChangeEvent(this.status, changedControl));
        }
        if (this._parent) {
          this._parent._updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted);
        }
      }
      /** @internal */
      _initObservables() {
        this.valueChanges = new EventEmitter();
        this.statusChanges = new EventEmitter();
      }
      _calculateStatus() {
        if (this._allControlsDisabled()) return DISABLED;
        if (this.errors) return INVALID;
        if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) return PENDING;
        if (this._anyControlsHaveStatus(INVALID)) return INVALID;
        return VALID;
      }
      /** @internal */
      _anyControlsHaveStatus(status) {
        return this._anyControls((control) => control.status === status);
      }
      /** @internal */
      _anyControlsDirty() {
        return this._anyControls((control) => control.dirty);
      }
      /** @internal */
      _anyControlsTouched() {
        return this._anyControls((control) => control.touched);
      }
      /** @internal */
      _updatePristine(opts, changedControl) {
        const newPristine = !this._anyControlsDirty();
        const changed = this.pristine !== newPristine;
        this.pristine = newPristine;
        if (this._parent && !opts.onlySelf) {
          this._parent._updatePristine(opts, changedControl);
        }
        if (changed) {
          this._events.next(new PristineChangeEvent(this.pristine, changedControl));
        }
      }
      /** @internal */
      _updateTouched(opts = {}, changedControl) {
        this.touched = this._anyControlsTouched();
        this._events.next(new TouchedChangeEvent(this.touched, changedControl));
        if (this._parent && !opts.onlySelf) {
          this._parent._updateTouched(opts, changedControl);
        }
      }
      /** @internal */
      _onDisabledChange = [];
      /** @internal */
      _registerOnCollectionChange(fn) {
        this._onCollectionChange = fn;
      }
      /** @internal */
      _setUpdateStrategy(opts) {
        if (isOptionsObj(opts) && opts.updateOn != null) {
          this._updateOn = opts.updateOn;
        }
      }
      /**
       * Check to see if parent has been marked artificially dirty.
       *
       * @internal
       */
      _parentMarkedDirty(onlySelf) {
        const parentDirty = this._parent && this._parent.dirty;
        return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();
      }
      /** @internal */
      _find(name) {
        return null;
      }
      /**
       * Internal implementation of the `setValidators` method. Needs to be separated out into a
       * different method, because it is called in the constructor and it can break cases where
       * a control is extended.
       */
      _assignValidators(validators) {
        this._rawValidators = Array.isArray(validators) ? validators.slice() : validators;
        this._composedValidatorFn = coerceToValidator(this._rawValidators);
      }
      /**
       * Internal implementation of the `setAsyncValidators` method. Needs to be separated out into a
       * different method, because it is called in the constructor and it can break cases where
       * a control is extended.
       */
      _assignAsyncValidators(validators) {
        this._rawAsyncValidators = Array.isArray(validators) ? validators.slice() : validators;
        this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);
      }
    };
    FormGroup = class extends AbstractControl {
      /**
       * Creates a new `FormGroup` instance.
       *
       * @param controls A collection of child controls. The key for each child is the name
       * under which it is registered.
       *
       * @param validatorOrOpts A synchronous validator function, or an array of
       * such functions, or an `AbstractControlOptions` object that contains validation functions
       * and a validation trigger.
       *
       * @param asyncValidator A single async validator or array of async validator functions
       *
       */
      constructor(controls, validatorOrOpts, asyncValidator) {
        super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
        (typeof ngDevMode === "undefined" || ngDevMode) && validateFormGroupControls(controls);
        this.controls = controls;
        this._initObservables();
        this._setUpdateStrategy(validatorOrOpts);
        this._setUpControls();
        this.updateValueAndValidity({
          onlySelf: true,
          // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
          // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,
          // so we set `emitEvent` to `true` to allow that during the control creation process.
          emitEvent: !!this.asyncValidator
        });
      }
      controls;
      registerControl(name, control) {
        if (this.controls[name]) return this.controls[name];
        this.controls[name] = control;
        control.setParent(this);
        control._registerOnCollectionChange(this._onCollectionChange);
        return control;
      }
      addControl(name, control, options = {}) {
        this.registerControl(name, control);
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
        this._onCollectionChange();
      }
      /**
       * Remove a control from this group. In a strongly-typed group, required controls cannot be
       * removed.
       *
       * This method also updates the value and validity of the control.
       *
       * @param name The control name to remove from the collection
       * @param options Specifies whether this FormGroup instance should emit events after a
       *     control is removed.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges` observables emit events with the latest status and value when the control is
       * removed. When false, no events are emitted.
       */
      removeControl(name, options = {}) {
        if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {
        });
        delete this.controls[name];
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
        this._onCollectionChange();
      }
      setControl(name, control, options = {}) {
        if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {
        });
        delete this.controls[name];
        if (control) this.registerControl(name, control);
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
        this._onCollectionChange();
      }
      contains(controlName) {
        return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
      }
      /**
       * Sets the value of the `FormGroup`. It accepts an object that matches
       * the structure of the group, with control names as keys.
       *
       * @usageNotes
       * ### Set the complete value for the form group
       *
       * ```ts
       * const form = new FormGroup({
       *   first: new FormControl(),
       *   last: new FormControl()
       * });
       *
       * console.log(form.value);   // {first: null, last: null}
       *
       * form.setValue({first: 'Nancy', last: 'Drew'});
       * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
       * ```
       *
       * @throws When strict checks fail, such as setting the value of a control
       * that doesn't exist or if you exclude a value of a control that does exist.
       *
       * @param value The new value for the control that matches the structure of the group.
       * @param options Configuration options that determine how the control propagates changes
       * and emits events after the value changes.
       * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
       * updateValueAndValidity} method.
       *
       * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
       * false.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges`
       * observables emit events with the latest status and value when the control value is updated.
       * When false, no events are emitted.
       */
      setValue(value, options = {}) {
        assertAllValuesPresent(this, true, value);
        Object.keys(value).forEach((name) => {
          assertControlPresent(this, true, name);
          this.controls[name].setValue(value[name], {
            onlySelf: true,
            emitEvent: options.emitEvent
          });
        });
        this.updateValueAndValidity(options);
      }
      /**
       * Patches the value of the `FormGroup`. It accepts an object with control
       * names as keys, and does its best to match the values to the correct controls
       * in the group.
       *
       * It accepts both super-sets and sub-sets of the group without throwing an error.
       *
       * @usageNotes
       * ### Patch the value for a form group
       *
       * ```ts
       * const form = new FormGroup({
       *    first: new FormControl(),
       *    last: new FormControl()
       * });
       * console.log(form.value);   // {first: null, last: null}
       *
       * form.patchValue({first: 'Nancy'});
       * console.log(form.value);   // {first: 'Nancy', last: null}
       * ```
       *
       * @param value The object that matches the structure of the group.
       * @param options Configuration options that determine how the control propagates changes and
       * emits events after the value is patched.
       * * `onlySelf`: When true, each change only affects this control and not its parent. Default is
       * true.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges` observables emit events with the latest status and value when the control value
       * is updated. When false, no events are emitted. The configuration options are passed to
       * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
       */
      patchValue(value, options = {}) {
        if (value == null) return;
        Object.keys(value).forEach((name) => {
          const control = this.controls[name];
          if (control) {
            control.patchValue(
              /* Guaranteed to be present, due to the outer forEach. */
              value[name],
              {
                onlySelf: true,
                emitEvent: options.emitEvent
              }
            );
          }
        });
        this.updateValueAndValidity(options);
      }
      /**
       * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets
       * the value of all descendants to their default values, or null if no defaults were provided.
       *
       * You reset to a specific form state by passing in a map of states
       * that matches the structure of your form, with control names as keys. The state
       * is a standalone value or a form state object with both a value and a disabled
       * status.
       *
       * @param value Resets the control with an initial value,
       * or an object that defines the initial value and disabled state.
       *
       * @param options Configuration options that determine how the control propagates changes
       * and emits events when the group is reset.
       * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
       * false.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges`
       * observables emit events with the latest status and value when the control is reset.
       * When false, no events are emitted.
       * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
       * updateValueAndValidity} method.
       *
       * @usageNotes
       *
       * ### Reset the form group values
       *
       * ```ts
       * const form = new FormGroup({
       *   first: new FormControl('first name'),
       *   last: new FormControl('last name')
       * });
       *
       * console.log(form.value);  // {first: 'first name', last: 'last name'}
       *
       * form.reset({ first: 'name', last: 'last name' });
       *
       * console.log(form.value);  // {first: 'name', last: 'last name'}
       * ```
       *
       * ### Reset the form group values and disabled status
       *
       * ```ts
       * const form = new FormGroup({
       *   first: new FormControl('first name'),
       *   last: new FormControl('last name')
       * });
       *
       * form.reset({
       *   first: {value: 'name', disabled: true},
       *   last: 'last'
       * });
       *
       * console.log(form.value);  // {last: 'last'}
       * console.log(form.get('first').status);  // 'DISABLED'
       * ```
       */
      reset(value = {}, options = {}) {
        this._forEachChild((control, name) => {
          control.reset(value ? value[name] : null, {
            onlySelf: true,
            emitEvent: options.emitEvent
          });
        });
        this._updatePristine(options, this);
        this._updateTouched(options, this);
        this.updateValueAndValidity(options);
      }
      /**
       * The aggregate value of the `FormGroup`, including any disabled controls.
       *
       * Retrieves all values regardless of disabled status.
       */
      getRawValue() {
        return this._reduceChildren({}, (acc, control, name) => {
          acc[name] = control.getRawValue();
          return acc;
        });
      }
      /** @internal */
      _syncPendingControls() {
        let subtreeUpdated = this._reduceChildren(false, (updated, child) => {
          return child._syncPendingControls() ? true : updated;
        });
        if (subtreeUpdated) this.updateValueAndValidity({
          onlySelf: true
        });
        return subtreeUpdated;
      }
      /** @internal */
      _forEachChild(cb) {
        Object.keys(this.controls).forEach((key) => {
          const control = this.controls[key];
          control && cb(control, key);
        });
      }
      /** @internal */
      _setUpControls() {
        this._forEachChild((control) => {
          control.setParent(this);
          control._registerOnCollectionChange(this._onCollectionChange);
        });
      }
      /** @internal */
      _updateValue() {
        this.value = this._reduceValue();
      }
      /** @internal */
      _anyControls(condition) {
        for (const [controlName, control] of Object.entries(this.controls)) {
          if (this.contains(controlName) && condition(control)) {
            return true;
          }
        }
        return false;
      }
      /** @internal */
      _reduceValue() {
        let acc = {};
        return this._reduceChildren(acc, (acc2, control, name) => {
          if (control.enabled || this.disabled) {
            acc2[name] = control.value;
          }
          return acc2;
        });
      }
      /** @internal */
      _reduceChildren(initValue, fn) {
        let res = initValue;
        this._forEachChild((control, name) => {
          res = fn(res, control, name);
        });
        return res;
      }
      /** @internal */
      _allControlsDisabled() {
        for (const controlName of Object.keys(this.controls)) {
          if (this.controls[controlName].enabled) {
            return false;
          }
        }
        return Object.keys(this.controls).length > 0 || this.disabled;
      }
      /** @internal */
      _find(name) {
        return this.controls.hasOwnProperty(name) ? this.controls[name] : null;
      }
    };
    FormRecord = class extends FormGroup {
    };
    CALL_SET_DISABLED_STATE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "CallSetDisabledState" : "", {
      providedIn: "root",
      factory: () => setDisabledStateDefault
    });
    setDisabledStateDefault = "always";
    formDirectiveProvider$1 = {
      provide: ControlContainer,
      useExisting: forwardRef(() => NgForm)
    };
    resolvedPromise$1 = (() => Promise.resolve())();
    NgForm = class _NgForm extends ControlContainer {
      callSetDisabledState;
      /**
       * @description
       * Returns whether the form submission has been triggered.
       */
      get submitted() {
        return untracked2(this.submittedReactive);
      }
      /** @internal */
      _submitted = computed(() => this.submittedReactive(), ...ngDevMode ? [{
        debugName: "_submitted"
      }] : []);
      submittedReactive = signal(false, ...ngDevMode ? [{
        debugName: "submittedReactive"
      }] : []);
      _directives = /* @__PURE__ */ new Set();
      /**
       * @description
       * The `FormGroup` instance created for this form.
       */
      form;
      /**
       * @description
       * Event emitter for the "ngSubmit" event
       */
      ngSubmit = new EventEmitter();
      /**
       * @description
       * Tracks options for the `NgForm` instance.
       *
       * **updateOn**: Sets the default `updateOn` value for all child `NgModels` below it
       * unless explicitly set by a child `NgModel` using `ngModelOptions`). Defaults to 'change'.
       * Possible values: `'change'` | `'blur'` | `'submit'`.
       *
       */
      options;
      constructor(validators, asyncValidators, callSetDisabledState) {
        super();
        this.callSetDisabledState = callSetDisabledState;
        this.form = new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
      }
      /** @docs-private */
      ngAfterViewInit() {
        this._setUpdateStrategy();
      }
      /**
       * @description
       * The directive instance.
       */
      get formDirective() {
        return this;
      }
      /**
       * @description
       * The internal `FormGroup` instance.
       */
      get control() {
        return this.form;
      }
      /**
       * @description
       * Returns an array representing the path to this group. Because this directive
       * always lives at the top level of a form, it is always an empty array.
       */
      get path() {
        return [];
      }
      /**
       * @description
       * Returns a map of the controls in this group.
       */
      get controls() {
        return this.form.controls;
      }
      /**
       * @description
       * Method that sets up the control directive in this group, re-calculates its value
       * and validity, and adds the instance to the internal list of directives.
       *
       * @param dir The `NgModel` directive instance.
       */
      addControl(dir) {
        resolvedPromise$1.then(() => {
          const container = this._findContainer(dir.path);
          dir.control = container.registerControl(dir.name, dir.control);
          setUpControl(dir.control, dir, this.callSetDisabledState);
          dir.control.updateValueAndValidity({
            emitEvent: false
          });
          this._directives.add(dir);
        });
      }
      /**
       * @description
       * Retrieves the `FormControl` instance from the provided `NgModel` directive.
       *
       * @param dir The `NgModel` directive instance.
       */
      getControl(dir) {
        return this.form.get(dir.path);
      }
      /**
       * @description
       * Removes the `NgModel` instance from the internal list of directives
       *
       * @param dir The `NgModel` directive instance.
       */
      removeControl(dir) {
        resolvedPromise$1.then(() => {
          const container = this._findContainer(dir.path);
          if (container) {
            container.removeControl(dir.name);
          }
          this._directives.delete(dir);
        });
      }
      /**
       * @description
       * Adds a new `NgModelGroup` directive instance to the form.
       *
       * @param dir The `NgModelGroup` directive instance.
       */
      addFormGroup(dir) {
        resolvedPromise$1.then(() => {
          const container = this._findContainer(dir.path);
          const group = new FormGroup({});
          setUpFormContainer(group, dir);
          container.registerControl(dir.name, group);
          group.updateValueAndValidity({
            emitEvent: false
          });
        });
      }
      /**
       * @description
       * Removes the `NgModelGroup` directive instance from the form.
       *
       * @param dir The `NgModelGroup` directive instance.
       */
      removeFormGroup(dir) {
        resolvedPromise$1.then(() => {
          const container = this._findContainer(dir.path);
          if (container) {
            container.removeControl(dir.name);
          }
        });
      }
      /**
       * @description
       * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance
       *
       * @param dir The `NgModelGroup` directive instance.
       */
      getFormGroup(dir) {
        return this.form.get(dir.path);
      }
      /**
       * Sets the new value for the provided `NgControl` directive.
       *
       * @param dir The `NgControl` directive instance.
       * @param value The new value for the directive's control.
       */
      updateModel(dir, value) {
        resolvedPromise$1.then(() => {
          const ctrl = this.form.get(dir.path);
          ctrl.setValue(value);
        });
      }
      /**
       * @description
       * Sets the value for this `FormGroup`.
       *
       * @param value The new value
       */
      setValue(value) {
        this.control.setValue(value);
      }
      /**
       * @description
       * Method called when the "submit" event is triggered on the form.
       * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
       *
       * @param $event The "submit" event object
       */
      onSubmit($event) {
        this.submittedReactive.set(true);
        syncPendingControls(this.form, this._directives);
        this.ngSubmit.emit($event);
        this.form._events.next(new FormSubmittedEvent(this.control));
        return $event?.target?.method === "dialog";
      }
      /**
       * @description
       * Method called when the "reset" event is triggered on the form.
       */
      onReset() {
        this.resetForm();
      }
      /**
       * @description
       * Resets the form to an initial value and resets its submitted status.
       *
       * @param value The new value for the form.
       */
      resetForm(value = void 0) {
        this.form.reset(value);
        this.submittedReactive.set(false);
        this.form._events.next(new FormResetEvent(this.form));
      }
      _setUpdateStrategy() {
        if (this.options && this.options.updateOn != null) {
          this.form._updateOn = this.options.updateOn;
        }
      }
      _findContainer(path) {
        path.pop();
        return path.length ? this.form.get(path) : this.form;
      }
      static \u0275fac = function NgForm_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgForm)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgForm,
        selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]],
        hostBindings: function NgForm_HostBindings(rf2, ctx) {
          if (rf2 & 1) {
            \u0275\u0275listener("submit", function NgForm_submit_HostBindingHandler($event) {
              return ctx.onSubmit($event);
            })("reset", function NgForm_reset_HostBindingHandler() {
              return ctx.onReset();
            });
          }
        },
        inputs: {
          options: [0, "ngFormOptions", "options"]
        },
        outputs: {
          ngSubmit: "ngSubmit"
        },
        exportAs: ["ngForm"],
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([formDirectiveProvider$1]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgForm, [{
        type: Directive,
        args: [{
          selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]",
          providers: [formDirectiveProvider$1],
          host: {
            "(submit)": "onSubmit($event)",
            "(reset)": "onReset()"
          },
          outputs: ["ngSubmit"],
          exportAs: "ngForm",
          standalone: false
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_ASYNC_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [CALL_SET_DISABLED_STATE]
        }]
      }], {
        options: [{
          type: Input,
          args: ["ngFormOptions"]
        }]
      });
    })();
    FormControl = class FormControl2 extends AbstractControl {
      /** @publicApi */
      defaultValue = null;
      /** @internal */
      _onChange = [];
      /** @internal */
      _pendingValue;
      /** @internal */
      _pendingChange = false;
      constructor(formState = null, validatorOrOpts, asyncValidator) {
        super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
        this._applyFormState(formState);
        this._setUpdateStrategy(validatorOrOpts);
        this._initObservables();
        this.updateValueAndValidity({
          onlySelf: true,
          // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
          // `VALID` or `INVALID`.
          // The status should be broadcasted via the `statusChanges` observable, so we set
          // `emitEvent` to `true` to allow that during the control creation process.
          emitEvent: !!this.asyncValidator
        });
        if (isOptionsObj(validatorOrOpts) && (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)) {
          if (isFormControlState(formState)) {
            this.defaultValue = formState.value;
          } else {
            this.defaultValue = formState;
          }
        }
      }
      setValue(value, options = {}) {
        this.value = this._pendingValue = value;
        if (this._onChange.length && options.emitModelToViewChange !== false) {
          this._onChange.forEach((changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));
        }
        this.updateValueAndValidity(options);
      }
      patchValue(value, options = {}) {
        this.setValue(value, options);
      }
      reset(formState = this.defaultValue, options = {}) {
        this._applyFormState(formState);
        this.markAsPristine(options);
        this.markAsUntouched(options);
        this.setValue(this.value, options);
        this._pendingChange = false;
      }
      /**  @internal */
      _updateValue() {
      }
      /**  @internal */
      _anyControls(condition) {
        return false;
      }
      /**  @internal */
      _allControlsDisabled() {
        return this.disabled;
      }
      registerOnChange(fn) {
        this._onChange.push(fn);
      }
      /** @internal */
      _unregisterOnChange(fn) {
        removeListItem(this._onChange, fn);
      }
      registerOnDisabledChange(fn) {
        this._onDisabledChange.push(fn);
      }
      /** @internal */
      _unregisterOnDisabledChange(fn) {
        removeListItem(this._onDisabledChange, fn);
      }
      /** @internal */
      _forEachChild(cb) {
      }
      /** @internal */
      _syncPendingControls() {
        if (this.updateOn === "submit") {
          if (this._pendingDirty) this.markAsDirty();
          if (this._pendingTouched) this.markAsTouched();
          if (this._pendingChange) {
            this.setValue(this._pendingValue, {
              onlySelf: true,
              emitModelToViewChange: false
            });
            return true;
          }
        }
        return false;
      }
      _applyFormState(formState) {
        if (isFormControlState(formState)) {
          this.value = this._pendingValue = formState.value;
          formState.disabled ? this.disable({
            onlySelf: true,
            emitEvent: false
          }) : this.enable({
            onlySelf: true,
            emitEvent: false
          });
        } else {
          this.value = this._pendingValue = formState;
        }
      }
    };
    isFormControl = (control) => control instanceof FormControl;
    AbstractFormGroupDirective = class _AbstractFormGroupDirective extends ControlContainer {
      /**
       * @description
       * The parent control for the group
       *
       * @internal
       */
      _parent;
      /** @docs-private */
      ngOnInit() {
        this._checkParentType();
        this.formDirective.addFormGroup(this);
      }
      /** @docs-private */
      ngOnDestroy() {
        if (this.formDirective) {
          this.formDirective.removeFormGroup(this);
        }
      }
      /**
       * @description
       * The `FormGroup` bound to this directive.
       */
      get control() {
        return this.formDirective.getFormGroup(this);
      }
      /**
       * @description
       * The path to this group from the top-level directive.
       */
      get path() {
        return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
      }
      /**
       * @description
       * The top-level directive for this group if present, otherwise null.
       */
      get formDirective() {
        return this._parent ? this._parent.formDirective : null;
      }
      /** @internal */
      _checkParentType() {
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275AbstractFormGroupDirective_BaseFactory;
        return function AbstractFormGroupDirective_Factory(__ngFactoryType__) {
          return (\u0275AbstractFormGroupDirective_BaseFactory || (\u0275AbstractFormGroupDirective_BaseFactory = \u0275\u0275getInheritedFactory(_AbstractFormGroupDirective)))(__ngFactoryType__ || _AbstractFormGroupDirective);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _AbstractFormGroupDirective,
        standalone: false,
        features: [\u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractFormGroupDirective, [{
        type: Directive,
        args: [{
          standalone: false
        }]
      }], null, null);
    })();
    modelGroupProvider = {
      provide: ControlContainer,
      useExisting: forwardRef(() => NgModelGroup)
    };
    NgModelGroup = class _NgModelGroup extends AbstractFormGroupDirective {
      /**
       * @description
       * Tracks the name of the `NgModelGroup` bound to the directive. The name corresponds
       * to a key in the parent `NgForm`.
       */
      name = "";
      constructor(parent, validators, asyncValidators) {
        super();
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
      }
      /** @internal */
      _checkParentType() {
        if (!(this._parent instanceof _NgModelGroup) && !(this._parent instanceof NgForm) && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw modelGroupParentException();
        }
      }
      static \u0275fac = function NgModelGroup_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgModelGroup)(\u0275\u0275directiveInject(ControlContainer, 5), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgModelGroup,
        selectors: [["", "ngModelGroup", ""]],
        inputs: {
          name: [0, "ngModelGroup", "name"]
        },
        exportAs: ["ngModelGroup"],
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([modelGroupProvider]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModelGroup, [{
        type: Directive,
        args: [{
          selector: "[ngModelGroup]",
          providers: [modelGroupProvider],
          exportAs: "ngModelGroup",
          standalone: false
        }]
      }], () => [{
        type: ControlContainer,
        decorators: [{
          type: Host
        }, {
          type: SkipSelf
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_ASYNC_VALIDATORS]
        }]
      }], {
        name: [{
          type: Input,
          args: ["ngModelGroup"]
        }]
      });
    })();
    formControlBinding$1 = {
      provide: NgControl,
      useExisting: forwardRef(() => NgModel)
    };
    resolvedPromise = (() => Promise.resolve())();
    NgModel = class _NgModel extends NgControl {
      _changeDetectorRef;
      callSetDisabledState;
      control = new FormControl();
      // At runtime we coerce arbitrary values assigned to the "disabled" input to a "boolean".
      // This is not reflected in the type of the property because outside of templates, consumers
      // should only deal with booleans. In templates, a string is allowed for convenience and to
      // match the native "disabled attribute" semantics which can be observed on input elements.
      // This static member tells the compiler that values of type "string" can also be assigned
      // to the input in a template.
      /** @docs-private */
      static ngAcceptInputType_isDisabled;
      /** @internal */
      _registered = false;
      /**
       * Internal reference to the view model value.
       * @docs-private
       */
      viewModel;
      /**
       * @description
       * Tracks the name bound to the directive. If a parent form exists, it
       * uses this name as a key to retrieve this control's value.
       */
      name = "";
      /**
       * @description
       * Tracks whether the control is disabled.
       */
      isDisabled;
      /**
       * @description
       * Tracks the value bound to this directive.
       */
      model;
      /**
       * @description
       * Tracks the configuration options for this `ngModel` instance.
       *
       * **name**: An alternative to setting the name attribute on the form control element. See
       * the [example](api/forms/NgModel#using-ngmodel-on-a-standalone-control) for using `NgModel`
       * as a standalone control.
       *
       * **standalone**: When set to true, the `ngModel` will not register itself with its parent form,
       * and acts as if it's not in the form. Defaults to false. If no parent form exists, this option
       * has no effect.
       *
       * **updateOn**: Defines the event upon which the form control value and validity update.
       * Defaults to 'change'. Possible values: `'change'` | `'blur'` | `'submit'`.
       *
       */
      options;
      /**
       * @description
       * Event emitter for producing the `ngModelChange` event after
       * the view model updates.
       */
      update = new EventEmitter();
      constructor(parent, validators, asyncValidators, valueAccessors, _changeDetectorRef, callSetDisabledState) {
        super();
        this._changeDetectorRef = _changeDetectorRef;
        this.callSetDisabledState = callSetDisabledState;
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
        this.valueAccessor = selectValueAccessor(this, valueAccessors);
      }
      /** @docs-private */
      ngOnChanges(changes) {
        this._checkForErrors();
        if (!this._registered || "name" in changes) {
          if (this._registered) {
            this._checkName();
            if (this.formDirective) {
              const oldName = changes["name"].previousValue;
              this.formDirective.removeControl({
                name: oldName,
                path: this._getPath(oldName)
              });
            }
          }
          this._setUpControl();
        }
        if ("isDisabled" in changes) {
          this._updateDisabled(changes);
        }
        if (isPropertyUpdated(changes, this.viewModel)) {
          this._updateValue(this.model);
          this.viewModel = this.model;
        }
      }
      /** @docs-private */
      ngOnDestroy() {
        this.formDirective && this.formDirective.removeControl(this);
      }
      /**
       * @description
       * Returns an array that represents the path from the top-level form to this control.
       * Each index is the string name of the control on that level.
       */
      get path() {
        return this._getPath(this.name);
      }
      /**
       * @description
       * The top-level directive for this control if present, otherwise null.
       */
      get formDirective() {
        return this._parent ? this._parent.formDirective : null;
      }
      /**
       * @description
       * Sets the new value for the view model and emits an `ngModelChange` event.
       *
       * @param newValue The new value emitted by `ngModelChange`.
       */
      viewToModelUpdate(newValue) {
        this.viewModel = newValue;
        this.update.emit(newValue);
      }
      _setUpControl() {
        this._setUpdateStrategy();
        this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
        this._registered = true;
      }
      _setUpdateStrategy() {
        if (this.options && this.options.updateOn != null) {
          this.control._updateOn = this.options.updateOn;
        }
      }
      _isStandalone() {
        return !this._parent || !!(this.options && this.options.standalone);
      }
      _setUpStandalone() {
        setUpControl(this.control, this, this.callSetDisabledState);
        this.control.updateValueAndValidity({
          emitEvent: false
        });
      }
      _checkForErrors() {
        if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._isStandalone()) {
          checkParentType$1(this._parent);
        }
        this._checkName();
      }
      _checkName() {
        if (this.options && this.options.name) this.name = this.options.name;
        if (!this._isStandalone() && !this.name && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw missingNameException();
        }
      }
      _updateValue(value) {
        resolvedPromise.then(() => {
          this.control.setValue(value, {
            emitViewToModelChange: false
          });
          this._changeDetectorRef?.markForCheck();
        });
      }
      _updateDisabled(changes) {
        const disabledValue = changes["isDisabled"].currentValue;
        const isDisabled = disabledValue !== 0 && booleanAttribute(disabledValue);
        resolvedPromise.then(() => {
          if (isDisabled && !this.control.disabled) {
            this.control.disable();
          } else if (!isDisabled && this.control.disabled) {
            this.control.enable();
          }
          this._changeDetectorRef?.markForCheck();
        });
      }
      _getPath(controlName) {
        return this._parent ? controlPath(controlName, this._parent) : [controlName];
      }
      static \u0275fac = function NgModel_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgModel)(\u0275\u0275directiveInject(ControlContainer, 9), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(ChangeDetectorRef, 8), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgModel,
        selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]],
        inputs: {
          name: "name",
          isDisabled: [0, "disabled", "isDisabled"],
          model: [0, "ngModel", "model"],
          options: [0, "ngModelOptions", "options"]
        },
        outputs: {
          update: "ngModelChange"
        },
        exportAs: ["ngModel"],
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([formControlBinding$1]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModel, [{
        type: Directive,
        args: [{
          selector: "[ngModel]:not([formControlName]):not([formControl])",
          providers: [formControlBinding$1],
          exportAs: "ngModel",
          standalone: false
        }]
      }], () => [{
        type: ControlContainer,
        decorators: [{
          type: Optional
        }, {
          type: Host
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_ASYNC_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALUE_ACCESSOR]
        }]
      }, {
        type: ChangeDetectorRef,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [ChangeDetectorRef]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [CALL_SET_DISABLED_STATE]
        }]
      }], {
        name: [{
          type: Input
        }],
        isDisabled: [{
          type: Input,
          args: ["disabled"]
        }],
        model: [{
          type: Input,
          args: ["ngModel"]
        }],
        options: [{
          type: Input,
          args: ["ngModelOptions"]
        }],
        update: [{
          type: Output,
          args: ["ngModelChange"]
        }]
      });
    })();
    \u0275NgNoValidate = class _\u0275NgNoValidate {
      static \u0275fac = function \u0275NgNoValidate_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _\u0275NgNoValidate)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _\u0275NgNoValidate,
        selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]],
        hostAttrs: ["novalidate", ""],
        standalone: false
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275NgNoValidate, [{
        type: Directive,
        args: [{
          selector: "form:not([ngNoForm]):not([ngNativeValidate])",
          host: {
            "novalidate": ""
          },
          standalone: false
        }]
      }], null, null);
    })();
    NUMBER_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => NumberValueAccessor),
      multi: true
    };
    NumberValueAccessor = class _NumberValueAccessor extends BuiltInControlValueAccessor {
      /**
       * Sets the "value" property on the input element.
       * @docs-private
       */
      writeValue(value) {
        const normalizedValue = value == null ? "" : value;
        this.setProperty("value", normalizedValue);
      }
      /**
       * Registers a function called when the control value changes.
       * @docs-private
       */
      registerOnChange(fn) {
        this.onChange = (value) => {
          fn(value == "" ? null : parseFloat(value));
        };
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275NumberValueAccessor_BaseFactory;
        return function NumberValueAccessor_Factory(__ngFactoryType__) {
          return (\u0275NumberValueAccessor_BaseFactory || (\u0275NumberValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_NumberValueAccessor)))(__ngFactoryType__ || _NumberValueAccessor);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NumberValueAccessor,
        selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]],
        hostBindings: function NumberValueAccessor_HostBindings(rf2, ctx) {
          if (rf2 & 1) {
            \u0275\u0275listener("input", function NumberValueAccessor_input_HostBindingHandler($event) {
              return ctx.onChange($event.target.value);
            })("blur", function NumberValueAccessor_blur_HostBindingHandler() {
              return ctx.onTouched();
            });
          }
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([NUMBER_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberValueAccessor, [{
        type: Directive,
        args: [{
          selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]",
          host: {
            "(input)": "onChange($any($event.target).value)",
            "(blur)": "onTouched()"
          },
          providers: [NUMBER_VALUE_ACCESSOR],
          standalone: false
        }]
      }], null, null);
    })();
    RADIO_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => RadioControlValueAccessor),
      multi: true
    };
    RadioControlRegistry = class _RadioControlRegistry {
      _accessors = [];
      /**
       * @description
       * Adds a control to the internal registry. For internal use only.
       */
      add(control, accessor) {
        this._accessors.push([control, accessor]);
      }
      /**
       * @description
       * Removes a control from the internal registry. For internal use only.
       */
      remove(accessor) {
        for (let i2 = this._accessors.length - 1; i2 >= 0; --i2) {
          if (this._accessors[i2][1] === accessor) {
            this._accessors.splice(i2, 1);
            return;
          }
        }
      }
      /**
       * @description
       * Selects a radio button. For internal use only.
       */
      select(accessor) {
        this._accessors.forEach((c2) => {
          if (this._isSameGroup(c2, accessor) && c2[1] !== accessor) {
            c2[1].fireUncheck(accessor.value);
          }
        });
      }
      _isSameGroup(controlPair, accessor) {
        if (!controlPair[0].control) return false;
        return controlPair[0]._parent === accessor._control._parent && controlPair[1].name === accessor.name;
      }
      static \u0275fac = function RadioControlRegistry_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _RadioControlRegistry)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _RadioControlRegistry,
        factory: _RadioControlRegistry.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlRegistry, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    RadioControlValueAccessor = class _RadioControlValueAccessor extends BuiltInControlValueAccessor {
      _registry;
      _injector;
      /** @internal */
      _state;
      /** @internal */
      _control;
      /** @internal */
      _fn;
      setDisabledStateFired = false;
      /**
       * The registered callback function called when a change event occurs on the input element.
       * Note: we declare `onChange` here (also used as host listener) as a function with no arguments
       * to override the `onChange` function (which expects 1 argument) in the parent
       * `BaseControlValueAccessor` class.
       * @docs-private
       */
      onChange = () => {
      };
      /**
       * @description
       * Tracks the name of the radio input element.
       */
      name;
      /**
       * @description
       * Tracks the name of the `FormControl` bound to the directive. The name corresponds
       * to a key in the parent `FormGroup` or `FormArray`.
       */
      formControlName;
      /**
       * @description
       * Tracks the value of the radio input element
       */
      value;
      callSetDisabledState = inject2(CALL_SET_DISABLED_STATE, {
        optional: true
      }) ?? setDisabledStateDefault;
      constructor(renderer, elementRef, _registry, _injector) {
        super(renderer, elementRef);
        this._registry = _registry;
        this._injector = _injector;
      }
      /** @docs-private */
      ngOnInit() {
        this._control = this._injector.get(NgControl);
        this._checkName();
        this._registry.add(this._control, this);
      }
      /** @docs-private */
      ngOnDestroy() {
        this._registry.remove(this);
      }
      /**
       * Sets the "checked" property value on the radio input element.
       * @docs-private
       */
      writeValue(value) {
        this._state = value === this.value;
        this.setProperty("checked", this._state);
      }
      /**
       * Registers a function called when the control value changes.
       * @docs-private
       */
      registerOnChange(fn) {
        this._fn = fn;
        this.onChange = () => {
          fn(this.value);
          this._registry.select(this);
        };
      }
      /** @docs-private */
      setDisabledState(isDisabled) {
        if (this.setDisabledStateFired || isDisabled || this.callSetDisabledState === "whenDisabledForLegacyCode") {
          this.setProperty("disabled", isDisabled);
        }
        this.setDisabledStateFired = true;
      }
      /**
       * Sets the "value" on the radio input element and unchecks it.
       *
       * @param value
       */
      fireUncheck(value) {
        this.writeValue(value);
      }
      _checkName() {
        if (this.name && this.formControlName && this.name !== this.formControlName && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throwNameError();
        }
        if (!this.name && this.formControlName) this.name = this.formControlName;
      }
      static \u0275fac = function RadioControlValueAccessor_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _RadioControlValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(RadioControlRegistry), \u0275\u0275directiveInject(Injector));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _RadioControlValueAccessor,
        selectors: [["input", "type", "radio", "formControlName", ""], ["input", "type", "radio", "formControl", ""], ["input", "type", "radio", "ngModel", ""]],
        hostBindings: function RadioControlValueAccessor_HostBindings(rf2, ctx) {
          if (rf2 & 1) {
            \u0275\u0275listener("change", function RadioControlValueAccessor_change_HostBindingHandler() {
              return ctx.onChange();
            })("blur", function RadioControlValueAccessor_blur_HostBindingHandler() {
              return ctx.onTouched();
            });
          }
        },
        inputs: {
          name: "name",
          formControlName: "formControlName",
          value: "value"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([RADIO_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlValueAccessor, [{
        type: Directive,
        args: [{
          selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]",
          host: {
            "(change)": "onChange()",
            "(blur)": "onTouched()"
          },
          providers: [RADIO_VALUE_ACCESSOR],
          standalone: false
        }]
      }], () => [{
        type: Renderer2
      }, {
        type: ElementRef
      }, {
        type: RadioControlRegistry
      }, {
        type: Injector
      }], {
        name: [{
          type: Input
        }],
        formControlName: [{
          type: Input
        }],
        value: [{
          type: Input
        }]
      });
    })();
    RANGE_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => RangeValueAccessor),
      multi: true
    };
    RangeValueAccessor = class _RangeValueAccessor extends BuiltInControlValueAccessor {
      /**
       * Sets the "value" property on the input element.
       * @docs-private
       */
      writeValue(value) {
        this.setProperty("value", parseFloat(value));
      }
      /**
       * Registers a function called when the control value changes.
       * @docs-private
       */
      registerOnChange(fn) {
        this.onChange = (value) => {
          fn(value == "" ? null : parseFloat(value));
        };
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275RangeValueAccessor_BaseFactory;
        return function RangeValueAccessor_Factory(__ngFactoryType__) {
          return (\u0275RangeValueAccessor_BaseFactory || (\u0275RangeValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_RangeValueAccessor)))(__ngFactoryType__ || _RangeValueAccessor);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _RangeValueAccessor,
        selectors: [["input", "type", "range", "formControlName", ""], ["input", "type", "range", "formControl", ""], ["input", "type", "range", "ngModel", ""]],
        hostBindings: function RangeValueAccessor_HostBindings(rf2, ctx) {
          if (rf2 & 1) {
            \u0275\u0275listener("change", function RangeValueAccessor_change_HostBindingHandler($event) {
              return ctx.onChange($event.target.value);
            })("input", function RangeValueAccessor_input_HostBindingHandler($event) {
              return ctx.onChange($event.target.value);
            })("blur", function RangeValueAccessor_blur_HostBindingHandler() {
              return ctx.onTouched();
            });
          }
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([RANGE_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeValueAccessor, [{
        type: Directive,
        args: [{
          selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]",
          host: {
            "(change)": "onChange($any($event.target).value)",
            "(input)": "onChange($any($event.target).value)",
            "(blur)": "onTouched()"
          },
          providers: [RANGE_VALUE_ACCESSOR],
          standalone: false
        }]
      }], null, null);
    })();
    NG_MODEL_WITH_FORM_CONTROL_WARNING = new InjectionToken(ngDevMode ? "NgModelWithFormControlWarning" : "");
    formControlBinding = {
      provide: NgControl,
      useExisting: forwardRef(() => FormControlDirective)
    };
    FormControlDirective = class _FormControlDirective extends NgControl {
      _ngModelWarningConfig;
      callSetDisabledState;
      /**
       * Internal reference to the view model value.
       * @docs-private
       */
      viewModel;
      /**
       * @description
       * Tracks the `FormControl` instance bound to the directive.
       */
      form;
      /**
       * @description
       * Triggers a warning in dev mode that this input should not be used with reactive forms.
       */
      set isDisabled(isDisabled) {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          console.warn(disabledAttrWarning);
        }
      }
      // TODO(kara): remove next 4 properties once deprecation period is over
      /** @deprecated as of v6 */
      model;
      /** @deprecated as of v6 */
      update = new EventEmitter();
      /**
       * @description
       * Static property used to track whether any ngModel warnings have been sent across
       * all instances of FormControlDirective. Used to support warning config of "once".
       *
       * @internal
       */
      static _ngModelWarningSentOnce = false;
      /**
       * @description
       * Instance property used to track whether an ngModel warning has been sent out for this
       * particular `FormControlDirective` instance. Used to support warning config of "always".
       *
       * @internal
       */
      _ngModelWarningSent = false;
      constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig, callSetDisabledState) {
        super();
        this._ngModelWarningConfig = _ngModelWarningConfig;
        this.callSetDisabledState = callSetDisabledState;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
        this.valueAccessor = selectValueAccessor(this, valueAccessors);
      }
      /** @docs-private */
      ngOnChanges(changes) {
        if (this._isControlChanged(changes)) {
          const previousForm = changes["form"].previousValue;
          if (previousForm) {
            cleanUpControl(
              previousForm,
              this,
              /* validateControlPresenceOnChange */
              false
            );
          }
          setUpControl(this.form, this, this.callSetDisabledState);
          this.form.updateValueAndValidity({
            emitEvent: false
          });
        }
        if (isPropertyUpdated(changes, this.viewModel)) {
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            _ngModelWarning("formControl", _FormControlDirective, this, this._ngModelWarningConfig);
          }
          this.form.setValue(this.model);
          this.viewModel = this.model;
        }
      }
      /** @docs-private */
      ngOnDestroy() {
        if (this.form) {
          cleanUpControl(
            this.form,
            this,
            /* validateControlPresenceOnChange */
            false
          );
        }
      }
      /**
       * @description
       * Returns an array that represents the path from the top-level form to this control.
       * Each index is the string name of the control on that level.
       */
      get path() {
        return [];
      }
      /**
       * @description
       * The `FormControl` bound to this directive.
       */
      get control() {
        return this.form;
      }
      /**
       * @description
       * Sets the new value for the view model and emits an `ngModelChange` event.
       *
       * @param newValue The new value for the view model.
       */
      viewToModelUpdate(newValue) {
        this.viewModel = newValue;
        this.update.emit(newValue);
      }
      _isControlChanged(changes) {
        return changes.hasOwnProperty("form");
      }
      static \u0275fac = function FormControlDirective_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _FormControlDirective)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _FormControlDirective,
        selectors: [["", "formControl", ""]],
        inputs: {
          form: [0, "formControl", "form"],
          isDisabled: [0, "disabled", "isDisabled"],
          model: [0, "ngModel", "model"]
        },
        outputs: {
          update: "ngModelChange"
        },
        exportAs: ["ngForm"],
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([formControlBinding]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlDirective, [{
        type: Directive,
        args: [{
          selector: "[formControl]",
          providers: [formControlBinding],
          exportAs: "ngForm",
          standalone: false
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_ASYNC_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALUE_ACCESSOR]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [CALL_SET_DISABLED_STATE]
        }]
      }], {
        form: [{
          type: Input,
          args: ["formControl"]
        }],
        isDisabled: [{
          type: Input,
          args: ["disabled"]
        }],
        model: [{
          type: Input,
          args: ["ngModel"]
        }],
        update: [{
          type: Output,
          args: ["ngModelChange"]
        }]
      });
    })();
    formDirectiveProvider = {
      provide: ControlContainer,
      useExisting: forwardRef(() => FormGroupDirective)
    };
    FormGroupDirective = class _FormGroupDirective extends ControlContainer {
      callSetDisabledState;
      /**
       * @description
       * Reports whether the form submission has been triggered.
       */
      get submitted() {
        return untracked2(this._submittedReactive);
      }
      // TODO(atscott): Remove once invalid API usage is cleaned up internally
      set submitted(value) {
        this._submittedReactive.set(value);
      }
      /** @internal */
      _submitted = computed(() => this._submittedReactive(), ...ngDevMode ? [{
        debugName: "_submitted"
      }] : []);
      _submittedReactive = signal(false, ...ngDevMode ? [{
        debugName: "_submittedReactive"
      }] : []);
      /**
       * Reference to an old form group input value, which is needed to cleanup
       * old instance in case it was replaced with a new one.
       */
      _oldForm;
      /**
       * Callback that should be invoked when controls in FormGroup or FormArray collection change
       * (added or removed). This callback triggers corresponding DOM updates.
       */
      _onCollectionChange = () => this._updateDomValue();
      /**
       * @description
       * Tracks the list of added `FormControlName` instances
       */
      directives = [];
      /**
       * @description
       * Tracks the `FormGroup` bound to this directive.
       */
      form = null;
      /**
       * @description
       * Emits an event when the form submission has been triggered.
       */
      ngSubmit = new EventEmitter();
      constructor(validators, asyncValidators, callSetDisabledState) {
        super();
        this.callSetDisabledState = callSetDisabledState;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
      }
      /** @docs-private */
      ngOnChanges(changes) {
        if ((typeof ngDevMode === "undefined" || ngDevMode) && !this.form) {
          throw missingFormException();
        }
        if (changes.hasOwnProperty("form")) {
          this._updateValidators();
          this._updateDomValue();
          this._updateRegistrations();
          this._oldForm = this.form;
        }
      }
      /** @docs-private */
      ngOnDestroy() {
        if (this.form) {
          cleanUpValidators(this.form, this);
          if (this.form._onCollectionChange === this._onCollectionChange) {
            this.form._registerOnCollectionChange(() => {
            });
          }
        }
      }
      /**
       * @description
       * Returns this directive's instance.
       */
      get formDirective() {
        return this;
      }
      /**
       * @description
       * Returns the `FormGroup` bound to this directive.
       */
      get control() {
        return this.form;
      }
      /**
       * @description
       * Returns an array representing the path to this group. Because this directive
       * always lives at the top level of a form, it always an empty array.
       */
      get path() {
        return [];
      }
      /**
       * @description
       * Method that sets up the control directive in this group, re-calculates its value
       * and validity, and adds the instance to the internal list of directives.
       *
       * @param dir The `FormControlName` directive instance.
       */
      addControl(dir) {
        const ctrl = this.form.get(dir.path);
        setUpControl(ctrl, dir, this.callSetDisabledState);
        ctrl.updateValueAndValidity({
          emitEvent: false
        });
        this.directives.push(dir);
        return ctrl;
      }
      /**
       * @description
       * Retrieves the `FormControl` instance from the provided `FormControlName` directive
       *
       * @param dir The `FormControlName` directive instance.
       */
      getControl(dir) {
        return this.form.get(dir.path);
      }
      /**
       * @description
       * Removes the `FormControlName` instance from the internal list of directives
       *
       * @param dir The `FormControlName` directive instance.
       */
      removeControl(dir) {
        cleanUpControl(
          dir.control || null,
          dir,
          /* validateControlPresenceOnChange */
          false
        );
        removeListItem$1(this.directives, dir);
      }
      /**
       * Adds a new `FormGroupName` directive instance to the form.
       *
       * @param dir The `FormGroupName` directive instance.
       */
      addFormGroup(dir) {
        this._setUpFormContainer(dir);
      }
      /**
       * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the
       * view.
       *
       * @param dir The `FormGroupName` directive instance.
       */
      removeFormGroup(dir) {
        this._cleanUpFormContainer(dir);
      }
      /**
       * @description
       * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance
       *
       * @param dir The `FormGroupName` directive instance.
       */
      getFormGroup(dir) {
        return this.form.get(dir.path);
      }
      /**
       * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.
       *
       * @param dir The `FormArrayName` directive instance.
       */
      addFormArray(dir) {
        this._setUpFormContainer(dir);
      }
      /**
       * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the
       * view.
       *
       * @param dir The `FormArrayName` directive instance.
       */
      removeFormArray(dir) {
        this._cleanUpFormContainer(dir);
      }
      /**
       * @description
       * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.
       *
       * @param dir The `FormArrayName` directive instance.
       */
      getFormArray(dir) {
        return this.form.get(dir.path);
      }
      /**
       * Sets the new value for the provided `FormControlName` directive.
       *
       * @param dir The `FormControlName` directive instance.
       * @param value The new value for the directive's control.
       */
      updateModel(dir, value) {
        const ctrl = this.form.get(dir.path);
        ctrl.setValue(value);
      }
      /**
       * @description
       * Method called with the "submit" event is triggered on the form.
       * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
       *
       * @param $event The "submit" event object
       */
      onSubmit($event) {
        this._submittedReactive.set(true);
        syncPendingControls(this.form, this.directives);
        this.ngSubmit.emit($event);
        this.form._events.next(new FormSubmittedEvent(this.control));
        return $event?.target?.method === "dialog";
      }
      /**
       * @description
       * Method called when the "reset" event is triggered on the form.
       */
      onReset() {
        this.resetForm();
      }
      /**
       * @description
       * Resets the form to an initial value and resets its submitted status.
       *
       * @param value The new value for the form, `undefined` by default
       */
      resetForm(value = void 0, options = {}) {
        this.form.reset(value, options);
        this._submittedReactive.set(false);
        if (options?.emitEvent !== false) {
          this.form._events.next(new FormResetEvent(this.form));
        }
      }
      /** @internal */
      _updateDomValue() {
        this.directives.forEach((dir) => {
          const oldCtrl = dir.control;
          const newCtrl = this.form.get(dir.path);
          if (oldCtrl !== newCtrl) {
            cleanUpControl(oldCtrl || null, dir);
            if (isFormControl(newCtrl)) {
              setUpControl(newCtrl, dir, this.callSetDisabledState);
              dir.control = newCtrl;
            }
          }
        });
        this.form._updateTreeValidity({
          emitEvent: false
        });
      }
      _setUpFormContainer(dir) {
        const ctrl = this.form.get(dir.path);
        setUpFormContainer(ctrl, dir);
        ctrl.updateValueAndValidity({
          emitEvent: false
        });
      }
      _cleanUpFormContainer(dir) {
        if (this.form) {
          const ctrl = this.form.get(dir.path);
          if (ctrl) {
            const isControlUpdated = cleanUpFormContainer(ctrl, dir);
            if (isControlUpdated) {
              ctrl.updateValueAndValidity({
                emitEvent: false
              });
            }
          }
        }
      }
      _updateRegistrations() {
        this.form._registerOnCollectionChange(this._onCollectionChange);
        if (this._oldForm) {
          this._oldForm._registerOnCollectionChange(() => {
          });
        }
      }
      _updateValidators() {
        setUpValidators(this.form, this);
        if (this._oldForm) {
          cleanUpValidators(this._oldForm, this);
        }
      }
      static \u0275fac = function FormGroupDirective_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _FormGroupDirective)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _FormGroupDirective,
        selectors: [["", "formGroup", ""]],
        hostBindings: function FormGroupDirective_HostBindings(rf2, ctx) {
          if (rf2 & 1) {
            \u0275\u0275listener("submit", function FormGroupDirective_submit_HostBindingHandler($event) {
              return ctx.onSubmit($event);
            })("reset", function FormGroupDirective_reset_HostBindingHandler() {
              return ctx.onReset();
            });
          }
        },
        inputs: {
          form: [0, "formGroup", "form"]
        },
        outputs: {
          ngSubmit: "ngSubmit"
        },
        exportAs: ["ngForm"],
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([formDirectiveProvider]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupDirective, [{
        type: Directive,
        args: [{
          selector: "[formGroup]",
          providers: [formDirectiveProvider],
          host: {
            "(submit)": "onSubmit($event)",
            "(reset)": "onReset()"
          },
          exportAs: "ngForm",
          standalone: false
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_ASYNC_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [CALL_SET_DISABLED_STATE]
        }]
      }], {
        form: [{
          type: Input,
          args: ["formGroup"]
        }],
        ngSubmit: [{
          type: Output
        }]
      });
    })();
    formGroupNameProvider = {
      provide: ControlContainer,
      useExisting: forwardRef(() => FormGroupName)
    };
    FormGroupName = class _FormGroupName extends AbstractFormGroupDirective {
      /**
       * @description
       * Tracks the name of the `FormGroup` bound to the directive. The name corresponds
       * to a key in the parent `FormGroup` or `FormArray`.
       * Accepts a name as a string or a number.
       * The name in the form of a string is useful for individual forms,
       * while the numerical form allows for form groups to be bound
       * to indices when iterating over groups in a `FormArray`.
       */
      name = null;
      constructor(parent, validators, asyncValidators) {
        super();
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
      }
      /** @internal */
      _checkParentType() {
        if (hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw groupParentException();
        }
      }
      static \u0275fac = function FormGroupName_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _FormGroupName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _FormGroupName,
        selectors: [["", "formGroupName", ""]],
        inputs: {
          name: [0, "formGroupName", "name"]
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([formGroupNameProvider]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupName, [{
        type: Directive,
        args: [{
          selector: "[formGroupName]",
          providers: [formGroupNameProvider],
          standalone: false
        }]
      }], () => [{
        type: ControlContainer,
        decorators: [{
          type: Optional
        }, {
          type: Host
        }, {
          type: SkipSelf
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_ASYNC_VALIDATORS]
        }]
      }], {
        name: [{
          type: Input,
          args: ["formGroupName"]
        }]
      });
    })();
    formArrayNameProvider = {
      provide: ControlContainer,
      useExisting: forwardRef(() => FormArrayName)
    };
    FormArrayName = class _FormArrayName extends ControlContainer {
      /** @internal */
      _parent;
      /**
       * @description
       * Tracks the name of the `FormArray` bound to the directive. The name corresponds
       * to a key in the parent `FormGroup` or `FormArray`.
       * Accepts a name as a string or a number.
       * The name in the form of a string is useful for individual forms,
       * while the numerical form allows for form arrays to be bound
       * to indices when iterating over arrays in a `FormArray`.
       */
      name = null;
      constructor(parent, validators, asyncValidators) {
        super();
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
      }
      /**
       * A lifecycle method called when the directive's inputs are initialized. For internal use only.
       * @throws If the directive does not have a valid parent.
       * @docs-private
       */
      ngOnInit() {
        if (hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw arrayParentException();
        }
        this.formDirective.addFormArray(this);
      }
      /**
       * A lifecycle method called before the directive's instance is destroyed. For internal use only.
       * @docs-private
       */
      ngOnDestroy() {
        this.formDirective?.removeFormArray(this);
      }
      /**
       * @description
       * The `FormArray` bound to this directive.
       */
      get control() {
        return this.formDirective.getFormArray(this);
      }
      /**
       * @description
       * The top-level directive for this group if present, otherwise null.
       */
      get formDirective() {
        return this._parent ? this._parent.formDirective : null;
      }
      /**
       * @description
       * Returns an array that represents the path from the top-level form to this control.
       * Each index is the string name of the control on that level.
       */
      get path() {
        return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
      }
      static \u0275fac = function FormArrayName_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _FormArrayName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _FormArrayName,
        selectors: [["", "formArrayName", ""]],
        inputs: {
          name: [0, "formArrayName", "name"]
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([formArrayNameProvider]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormArrayName, [{
        type: Directive,
        args: [{
          selector: "[formArrayName]",
          providers: [formArrayNameProvider],
          standalone: false
        }]
      }], () => [{
        type: ControlContainer,
        decorators: [{
          type: Optional
        }, {
          type: Host
        }, {
          type: SkipSelf
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_ASYNC_VALIDATORS]
        }]
      }], {
        name: [{
          type: Input,
          args: ["formArrayName"]
        }]
      });
    })();
    controlNameBinding = {
      provide: NgControl,
      useExisting: forwardRef(() => FormControlName)
    };
    FormControlName = class _FormControlName extends NgControl {
      _ngModelWarningConfig;
      _added = false;
      /**
       * Internal reference to the view model value.
       * @internal
       */
      viewModel;
      /**
       * @description
       * Tracks the `FormControl` instance bound to the directive.
       */
      control;
      /**
       * @description
       * Tracks the name of the `FormControl` bound to the directive. The name corresponds
       * to a key in the parent `FormGroup` or `FormArray`.
       * Accepts a name as a string or a number.
       * The name in the form of a string is useful for individual forms,
       * while the numerical form allows for form controls to be bound
       * to indices when iterating over controls in a `FormArray`.
       */
      name = null;
      /**
       * @description
       * Triggers a warning in dev mode that this input should not be used with reactive forms.
       */
      set isDisabled(isDisabled) {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          console.warn(disabledAttrWarning);
        }
      }
      // TODO(kara): remove next 4 properties once deprecation period is over
      /** @deprecated as of v6 */
      model;
      /** @deprecated as of v6 */
      update = new EventEmitter();
      /**
       * @description
       * Static property used to track whether any ngModel warnings have been sent across
       * all instances of FormControlName. Used to support warning config of "once".
       *
       * @internal
       */
      static _ngModelWarningSentOnce = false;
      /**
       * @description
       * Instance property used to track whether an ngModel warning has been sent out for this
       * particular FormControlName instance. Used to support warning config of "always".
       *
       * @internal
       */
      _ngModelWarningSent = false;
      constructor(parent, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
        super();
        this._ngModelWarningConfig = _ngModelWarningConfig;
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
        this.valueAccessor = selectValueAccessor(this, valueAccessors);
      }
      /** @docs-private */
      ngOnChanges(changes) {
        if (!this._added) this._setUpControl();
        if (isPropertyUpdated(changes, this.viewModel)) {
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            _ngModelWarning("formControlName", _FormControlName, this, this._ngModelWarningConfig);
          }
          this.viewModel = this.model;
          this.formDirective.updateModel(this, this.model);
        }
      }
      /** @docs-private */
      ngOnDestroy() {
        if (this.formDirective) {
          this.formDirective.removeControl(this);
        }
      }
      /**
       * @description
       * Sets the new value for the view model and emits an `ngModelChange` event.
       *
       * @param newValue The new value for the view model.
       */
      viewToModelUpdate(newValue) {
        this.viewModel = newValue;
        this.update.emit(newValue);
      }
      /**
       * @description
       * Returns an array that represents the path from the top-level form to this control.
       * Each index is the string name of the control on that level.
       */
      get path() {
        return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
      }
      /**
       * @description
       * The top-level directive for this group if present, otherwise null.
       */
      get formDirective() {
        return this._parent ? this._parent.formDirective : null;
      }
      _setUpControl() {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          checkParentType(this._parent, this.name);
        }
        this.control = this.formDirective.addControl(this);
        this._added = true;
      }
      static \u0275fac = function FormControlName_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _FormControlName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _FormControlName,
        selectors: [["", "formControlName", ""]],
        inputs: {
          name: [0, "formControlName", "name"],
          isDisabled: [0, "disabled", "isDisabled"],
          model: [0, "ngModel", "model"]
        },
        outputs: {
          update: "ngModelChange"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([controlNameBinding]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlName, [{
        type: Directive,
        args: [{
          selector: "[formControlName]",
          providers: [controlNameBinding],
          standalone: false
        }]
      }], () => [{
        type: ControlContainer,
        decorators: [{
          type: Optional
        }, {
          type: Host
        }, {
          type: SkipSelf
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_ASYNC_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALUE_ACCESSOR]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
        }]
      }], {
        name: [{
          type: Input,
          args: ["formControlName"]
        }],
        isDisabled: [{
          type: Input,
          args: ["disabled"]
        }],
        model: [{
          type: Input,
          args: ["ngModel"]
        }],
        update: [{
          type: Output,
          args: ["ngModelChange"]
        }]
      });
    })();
    SELECT_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => SelectControlValueAccessor),
      multi: true
    };
    SelectControlValueAccessor = class _SelectControlValueAccessor extends BuiltInControlValueAccessor {
      /** @docs-private */
      value;
      /** @internal */
      _optionMap = /* @__PURE__ */ new Map();
      /** @internal */
      _idCounter = 0;
      /**
       * @description
       * Tracks the option comparison algorithm for tracking identities when
       * checking for changes.
       */
      set compareWith(fn) {
        if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
        }
        this._compareWith = fn;
      }
      _compareWith = Object.is;
      // We need this because we might be in the process of destroying the root
      // injector, which is marked as destroyed before running destroy hooks.
      // Attempting to use afterNextRender with the node injector would evntually
      // run into that already destroyed injector.
      appRefInjector = inject2(ApplicationRef).injector;
      destroyRef = inject2(DestroyRef);
      cdr = inject2(ChangeDetectorRef);
      _queuedWrite = false;
      /**
       * This is needed to efficiently set the select value when adding/removing options. If
       * writeValue is instead called for every added/removed option, this results in exponentially
       * more _compareValue calls than the number of option elements (issue #41330).
       *
       * Secondly, calling writeValue when rendering individual option elements instead of after they
       * are all rendered caused an issue in Safari and IE 11 where the first option element failed
       * to be deselected when no option matched the select ngModel. This was because Angular would
       * set the select element's value property before appending the option's child text node to the
       * DOM (issue #14505).
       *
       * Finally, this approach is necessary to avoid an issue with delayed element removal when
       * using the animations module (in all browsers). Otherwise when a selected option is removed
       * (so no option matches the ngModel anymore), Angular would change the select element value
       * before actually removing the option from the DOM. Then when the option is finally removed
       * from the DOM, the browser would change the select value to that of the first option, even
       * though it doesn't match the ngModel (issue #18430).
       *
       * @internal
       */
      _writeValueAfterRender() {
        if (this._queuedWrite || this.appRefInjector.destroyed) {
          return;
        }
        this._queuedWrite = true;
        afterNextRender({
          write: () => {
            if (this.destroyRef.destroyed) {
              return;
            }
            this._queuedWrite = false;
            this.writeValue(this.value);
          }
        }, {
          injector: this.appRefInjector
        });
      }
      /**
       * Sets the "value" property on the select element.
       * @docs-private
       */
      writeValue(value) {
        this.cdr.markForCheck();
        this.value = value;
        const id2 = this._getOptionId(value);
        const valueString = _buildValueString$1(id2, value);
        this.setProperty("value", valueString);
      }
      /**
       * Registers a function called when the control value changes.
       * @docs-private
       */
      registerOnChange(fn) {
        this.onChange = (valueString) => {
          this.value = this._getOptionValue(valueString);
          fn(this.value);
        };
      }
      /** @internal */
      _registerOption() {
        return (this._idCounter++).toString();
      }
      /** @internal */
      _getOptionId(value) {
        for (const id2 of this._optionMap.keys()) {
          if (this._compareWith(this._optionMap.get(id2), value)) return id2;
        }
        return null;
      }
      /** @internal */
      _getOptionValue(valueString) {
        const id2 = _extractId$1(valueString);
        return this._optionMap.has(id2) ? this._optionMap.get(id2) : valueString;
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275SelectControlValueAccessor_BaseFactory;
        return function SelectControlValueAccessor_Factory(__ngFactoryType__) {
          return (\u0275SelectControlValueAccessor_BaseFactory || (\u0275SelectControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_SelectControlValueAccessor)))(__ngFactoryType__ || _SelectControlValueAccessor);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _SelectControlValueAccessor,
        selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]],
        hostBindings: function SelectControlValueAccessor_HostBindings(rf2, ctx) {
          if (rf2 & 1) {
            \u0275\u0275listener("change", function SelectControlValueAccessor_change_HostBindingHandler($event) {
              return ctx.onChange($event.target.value);
            })("blur", function SelectControlValueAccessor_blur_HostBindingHandler() {
              return ctx.onTouched();
            });
          }
        },
        inputs: {
          compareWith: "compareWith"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([SELECT_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectControlValueAccessor, [{
        type: Directive,
        args: [{
          selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]",
          host: {
            "(change)": "onChange($any($event.target).value)",
            "(blur)": "onTouched()"
          },
          providers: [SELECT_VALUE_ACCESSOR],
          standalone: false
        }]
      }], null, {
        compareWith: [{
          type: Input
        }]
      });
    })();
    NgSelectOption = class _NgSelectOption {
      _element;
      _renderer;
      _select;
      /**
       * @description
       * ID of the option element
       */
      id;
      constructor(_element, _renderer, _select) {
        this._element = _element;
        this._renderer = _renderer;
        this._select = _select;
        if (this._select) this.id = this._select._registerOption();
      }
      /**
       * @description
       * Tracks the value bound to the option element. Unlike the value binding,
       * ngValue supports binding to objects.
       */
      set ngValue(value) {
        if (this._select == null) return;
        this._select._optionMap.set(this.id, value);
        this._setElementValue(_buildValueString$1(this.id, value));
        this._select._writeValueAfterRender();
      }
      /**
       * @description
       * Tracks simple string values bound to the option element.
       * For objects, use the `ngValue` input binding.
       */
      set value(value) {
        this._setElementValue(value);
        if (this._select) this._select._writeValueAfterRender();
      }
      /** @internal */
      _setElementValue(value) {
        this._renderer.setProperty(this._element.nativeElement, "value", value);
      }
      /** @docs-private */
      ngOnDestroy() {
        if (this._select) {
          this._select._optionMap.delete(this.id);
          this._select._writeValueAfterRender();
        }
      }
      static \u0275fac = function NgSelectOption_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgSelectOption)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(SelectControlValueAccessor, 9));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgSelectOption,
        selectors: [["option"]],
        inputs: {
          ngValue: "ngValue",
          value: "value"
        },
        standalone: false
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSelectOption, [{
        type: Directive,
        args: [{
          selector: "option",
          standalone: false
        }]
      }], () => [{
        type: ElementRef
      }, {
        type: Renderer2
      }, {
        type: SelectControlValueAccessor,
        decorators: [{
          type: Optional
        }, {
          type: Host
        }]
      }], {
        ngValue: [{
          type: Input,
          args: ["ngValue"]
        }],
        value: [{
          type: Input,
          args: ["value"]
        }]
      });
    })();
    SELECT_MULTIPLE_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => SelectMultipleControlValueAccessor),
      multi: true
    };
    SelectMultipleControlValueAccessor = class _SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor {
      /**
       * The current value.
       * @docs-private
       */
      value;
      /** @internal */
      _optionMap = /* @__PURE__ */ new Map();
      /** @internal */
      _idCounter = 0;
      /**
       * @description
       * Tracks the option comparison algorithm for tracking identities when
       * checking for changes.
       */
      set compareWith(fn) {
        if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
        }
        this._compareWith = fn;
      }
      _compareWith = Object.is;
      /**
       * Sets the "value" property on one or of more of the select's options.
       * @docs-private
       */
      writeValue(value) {
        this.value = value;
        let optionSelectedStateSetter;
        if (Array.isArray(value)) {
          const ids = value.map((v) => this._getOptionId(v));
          optionSelectedStateSetter = (opt, o2) => {
            opt._setSelected(ids.indexOf(o2.toString()) > -1);
          };
        } else {
          optionSelectedStateSetter = (opt, o2) => {
            opt._setSelected(false);
          };
        }
        this._optionMap.forEach(optionSelectedStateSetter);
      }
      /**
       * Registers a function called when the control value changes
       * and writes an array of the selected options.
       * @docs-private
       */
      registerOnChange(fn) {
        this.onChange = (element) => {
          const selected = [];
          const selectedOptions = element.selectedOptions;
          if (selectedOptions !== void 0) {
            const options = selectedOptions;
            for (let i2 = 0; i2 < options.length; i2++) {
              const opt = options[i2];
              const val = this._getOptionValue(opt.value);
              selected.push(val);
            }
          } else {
            const options = element.options;
            for (let i2 = 0; i2 < options.length; i2++) {
              const opt = options[i2];
              if (opt.selected) {
                const val = this._getOptionValue(opt.value);
                selected.push(val);
              }
            }
          }
          this.value = selected;
          fn(selected);
        };
      }
      /** @internal */
      _registerOption(value) {
        const id2 = (this._idCounter++).toString();
        this._optionMap.set(id2, value);
        return id2;
      }
      /** @internal */
      _getOptionId(value) {
        for (const id2 of this._optionMap.keys()) {
          if (this._compareWith(this._optionMap.get(id2)._value, value)) return id2;
        }
        return null;
      }
      /** @internal */
      _getOptionValue(valueString) {
        const id2 = _extractId(valueString);
        return this._optionMap.has(id2) ? this._optionMap.get(id2)._value : valueString;
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275SelectMultipleControlValueAccessor_BaseFactory;
        return function SelectMultipleControlValueAccessor_Factory(__ngFactoryType__) {
          return (\u0275SelectMultipleControlValueAccessor_BaseFactory || (\u0275SelectMultipleControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_SelectMultipleControlValueAccessor)))(__ngFactoryType__ || _SelectMultipleControlValueAccessor);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _SelectMultipleControlValueAccessor,
        selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]],
        hostBindings: function SelectMultipleControlValueAccessor_HostBindings(rf2, ctx) {
          if (rf2 & 1) {
            \u0275\u0275listener("change", function SelectMultipleControlValueAccessor_change_HostBindingHandler($event) {
              return ctx.onChange($event.target);
            })("blur", function SelectMultipleControlValueAccessor_blur_HostBindingHandler() {
              return ctx.onTouched();
            });
          }
        },
        inputs: {
          compareWith: "compareWith"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([SELECT_MULTIPLE_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectMultipleControlValueAccessor, [{
        type: Directive,
        args: [{
          selector: "select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]",
          host: {
            "(change)": "onChange($event.target)",
            "(blur)": "onTouched()"
          },
          providers: [SELECT_MULTIPLE_VALUE_ACCESSOR],
          standalone: false
        }]
      }], null, {
        compareWith: [{
          type: Input
        }]
      });
    })();
    \u0275NgSelectMultipleOption = class _\u0275NgSelectMultipleOption {
      _element;
      _renderer;
      _select;
      id;
      /** @internal */
      _value;
      constructor(_element, _renderer, _select) {
        this._element = _element;
        this._renderer = _renderer;
        this._select = _select;
        if (this._select) {
          this.id = this._select._registerOption(this);
        }
      }
      /**
       * @description
       * Tracks the value bound to the option element. Unlike the value binding,
       * ngValue supports binding to objects.
       */
      set ngValue(value) {
        if (this._select == null) return;
        this._value = value;
        this._setElementValue(_buildValueString(this.id, value));
        this._select.writeValue(this._select.value);
      }
      /**
       * @description
       * Tracks simple string values bound to the option element.
       * For objects, use the `ngValue` input binding.
       */
      set value(value) {
        if (this._select) {
          this._value = value;
          this._setElementValue(_buildValueString(this.id, value));
          this._select.writeValue(this._select.value);
        } else {
          this._setElementValue(value);
        }
      }
      /** @internal */
      _setElementValue(value) {
        this._renderer.setProperty(this._element.nativeElement, "value", value);
      }
      /** @internal */
      _setSelected(selected) {
        this._renderer.setProperty(this._element.nativeElement, "selected", selected);
      }
      /** @docs-private */
      ngOnDestroy() {
        if (this._select) {
          this._select._optionMap.delete(this.id);
          this._select.writeValue(this._select.value);
        }
      }
      static \u0275fac = function \u0275NgSelectMultipleOption_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _\u0275NgSelectMultipleOption)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(SelectMultipleControlValueAccessor, 9));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _\u0275NgSelectMultipleOption,
        selectors: [["option"]],
        inputs: {
          ngValue: "ngValue",
          value: "value"
        },
        standalone: false
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275NgSelectMultipleOption, [{
        type: Directive,
        args: [{
          selector: "option",
          standalone: false
        }]
      }], () => [{
        type: ElementRef
      }, {
        type: Renderer2
      }, {
        type: SelectMultipleControlValueAccessor,
        decorators: [{
          type: Optional
        }, {
          type: Host
        }]
      }], {
        ngValue: [{
          type: Input,
          args: ["ngValue"]
        }],
        value: [{
          type: Input,
          args: ["value"]
        }]
      });
    })();
    AbstractValidatorDirective = class _AbstractValidatorDirective {
      _validator = nullValidator;
      _onChange;
      /**
       * A flag that tracks whether this validator is enabled.
       *
       * Marking it `internal` (vs `protected`), so that this flag can be used in host bindings of
       * directive classes that extend this base class.
       * @internal
       */
      _enabled;
      /** @docs-private */
      ngOnChanges(changes) {
        if (this.inputName in changes) {
          const input2 = this.normalizeInput(changes[this.inputName].currentValue);
          this._enabled = this.enabled(input2);
          this._validator = this._enabled ? this.createValidator(input2) : nullValidator;
          if (this._onChange) {
            this._onChange();
          }
        }
      }
      /** @docs-private */
      validate(control) {
        return this._validator(control);
      }
      /** @docs-private */
      registerOnValidatorChange(fn) {
        this._onChange = fn;
      }
      /**
       * @description
       * Determines whether this validator should be active or not based on an input.
       * Base class implementation checks whether an input is defined (if the value is different from
       * `null` and `undefined`). Validator classes that extend this base class can override this
       * function with the logic specific to a particular validator directive.
       */
      enabled(input2) {
        return input2 != null;
      }
      static \u0275fac = function AbstractValidatorDirective_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _AbstractValidatorDirective)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _AbstractValidatorDirective,
        features: [\u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractValidatorDirective, [{
        type: Directive
      }], null, null);
    })();
    MAX_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => MaxValidator),
      multi: true
    };
    MaxValidator = class _MaxValidator extends AbstractValidatorDirective {
      /**
       * @description
       * Tracks changes to the max bound to this directive.
       */
      max;
      /** @internal */
      inputName = "max";
      /** @internal */
      normalizeInput = (input2) => toFloat(input2);
      /** @internal */
      createValidator = (max) => maxValidator(max);
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275MaxValidator_BaseFactory;
        return function MaxValidator_Factory(__ngFactoryType__) {
          return (\u0275MaxValidator_BaseFactory || (\u0275MaxValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MaxValidator)))(__ngFactoryType__ || _MaxValidator);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _MaxValidator,
        selectors: [["input", "type", "number", "max", "", "formControlName", ""], ["input", "type", "number", "max", "", "formControl", ""], ["input", "type", "number", "max", "", "ngModel", ""]],
        hostVars: 1,
        hostBindings: function MaxValidator_HostBindings(rf2, ctx) {
          if (rf2 & 2) {
            \u0275\u0275attribute("max", ctx._enabled ? ctx.max : null);
          }
        },
        inputs: {
          max: "max"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([MAX_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxValidator, [{
        type: Directive,
        args: [{
          selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]",
          providers: [MAX_VALIDATOR],
          host: {
            "[attr.max]": "_enabled ? max : null"
          },
          standalone: false
        }]
      }], null, {
        max: [{
          type: Input
        }]
      });
    })();
    MIN_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => MinValidator),
      multi: true
    };
    MinValidator = class _MinValidator extends AbstractValidatorDirective {
      /**
       * @description
       * Tracks changes to the min bound to this directive.
       */
      min;
      /** @internal */
      inputName = "min";
      /** @internal */
      normalizeInput = (input2) => toFloat(input2);
      /** @internal */
      createValidator = (min) => minValidator(min);
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275MinValidator_BaseFactory;
        return function MinValidator_Factory(__ngFactoryType__) {
          return (\u0275MinValidator_BaseFactory || (\u0275MinValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MinValidator)))(__ngFactoryType__ || _MinValidator);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _MinValidator,
        selectors: [["input", "type", "number", "min", "", "formControlName", ""], ["input", "type", "number", "min", "", "formControl", ""], ["input", "type", "number", "min", "", "ngModel", ""]],
        hostVars: 1,
        hostBindings: function MinValidator_HostBindings(rf2, ctx) {
          if (rf2 & 2) {
            \u0275\u0275attribute("min", ctx._enabled ? ctx.min : null);
          }
        },
        inputs: {
          min: "min"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([MIN_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinValidator, [{
        type: Directive,
        args: [{
          selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]",
          providers: [MIN_VALIDATOR],
          host: {
            "[attr.min]": "_enabled ? min : null"
          },
          standalone: false
        }]
      }], null, {
        min: [{
          type: Input
        }]
      });
    })();
    REQUIRED_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => RequiredValidator),
      multi: true
    };
    CHECKBOX_REQUIRED_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => CheckboxRequiredValidator),
      multi: true
    };
    RequiredValidator = class _RequiredValidator extends AbstractValidatorDirective {
      /**
       * @description
       * Tracks changes to the required attribute bound to this directive.
       */
      required;
      /** @internal */
      inputName = "required";
      /** @internal */
      normalizeInput = booleanAttribute;
      /** @internal */
      createValidator = (input2) => requiredValidator;
      /** @docs-private */
      enabled(input2) {
        return input2;
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275RequiredValidator_BaseFactory;
        return function RequiredValidator_Factory(__ngFactoryType__) {
          return (\u0275RequiredValidator_BaseFactory || (\u0275RequiredValidator_BaseFactory = \u0275\u0275getInheritedFactory(_RequiredValidator)))(__ngFactoryType__ || _RequiredValidator);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _RequiredValidator,
        selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]],
        hostVars: 1,
        hostBindings: function RequiredValidator_HostBindings(rf2, ctx) {
          if (rf2 & 2) {
            \u0275\u0275attribute("required", ctx._enabled ? "" : null);
          }
        },
        inputs: {
          required: "required"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([REQUIRED_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RequiredValidator, [{
        type: Directive,
        args: [{
          selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]",
          providers: [REQUIRED_VALIDATOR],
          host: {
            "[attr.required]": '_enabled ? "" : null'
          },
          standalone: false
        }]
      }], null, {
        required: [{
          type: Input
        }]
      });
    })();
    CheckboxRequiredValidator = class _CheckboxRequiredValidator extends RequiredValidator {
      /** @internal */
      createValidator = (input2) => requiredTrueValidator;
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275CheckboxRequiredValidator_BaseFactory;
        return function CheckboxRequiredValidator_Factory(__ngFactoryType__) {
          return (\u0275CheckboxRequiredValidator_BaseFactory || (\u0275CheckboxRequiredValidator_BaseFactory = \u0275\u0275getInheritedFactory(_CheckboxRequiredValidator)))(__ngFactoryType__ || _CheckboxRequiredValidator);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CheckboxRequiredValidator,
        selectors: [["input", "type", "checkbox", "required", "", "formControlName", ""], ["input", "type", "checkbox", "required", "", "formControl", ""], ["input", "type", "checkbox", "required", "", "ngModel", ""]],
        hostVars: 1,
        hostBindings: function CheckboxRequiredValidator_HostBindings(rf2, ctx) {
          if (rf2 & 2) {
            \u0275\u0275attribute("required", ctx._enabled ? "" : null);
          }
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([CHECKBOX_REQUIRED_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxRequiredValidator, [{
        type: Directive,
        args: [{
          selector: "input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]",
          providers: [CHECKBOX_REQUIRED_VALIDATOR],
          host: {
            "[attr.required]": '_enabled ? "" : null'
          },
          standalone: false
        }]
      }], null, null);
    })();
    EMAIL_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => EmailValidator),
      multi: true
    };
    EmailValidator = class _EmailValidator extends AbstractValidatorDirective {
      /**
       * @description
       * Tracks changes to the email attribute bound to this directive.
       */
      email;
      /** @internal */
      inputName = "email";
      /** @internal */
      normalizeInput = booleanAttribute;
      /** @internal */
      createValidator = (input2) => emailValidator;
      /** @docs-private */
      enabled(input2) {
        return input2;
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275EmailValidator_BaseFactory;
        return function EmailValidator_Factory(__ngFactoryType__) {
          return (\u0275EmailValidator_BaseFactory || (\u0275EmailValidator_BaseFactory = \u0275\u0275getInheritedFactory(_EmailValidator)))(__ngFactoryType__ || _EmailValidator);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _EmailValidator,
        selectors: [["", "email", "", "formControlName", ""], ["", "email", "", "formControl", ""], ["", "email", "", "ngModel", ""]],
        inputs: {
          email: "email"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([EMAIL_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EmailValidator, [{
        type: Directive,
        args: [{
          selector: "[email][formControlName],[email][formControl],[email][ngModel]",
          providers: [EMAIL_VALIDATOR],
          standalone: false
        }]
      }], null, {
        email: [{
          type: Input
        }]
      });
    })();
    MIN_LENGTH_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => MinLengthValidator),
      multi: true
    };
    MinLengthValidator = class _MinLengthValidator extends AbstractValidatorDirective {
      /**
       * @description
       * Tracks changes to the minimum length bound to this directive.
       */
      minlength;
      /** @internal */
      inputName = "minlength";
      /** @internal */
      normalizeInput = (input2) => toInteger(input2);
      /** @internal */
      createValidator = (minlength) => minLengthValidator(minlength);
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275MinLengthValidator_BaseFactory;
        return function MinLengthValidator_Factory(__ngFactoryType__) {
          return (\u0275MinLengthValidator_BaseFactory || (\u0275MinLengthValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MinLengthValidator)))(__ngFactoryType__ || _MinLengthValidator);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _MinLengthValidator,
        selectors: [["", "minlength", "", "formControlName", ""], ["", "minlength", "", "formControl", ""], ["", "minlength", "", "ngModel", ""]],
        hostVars: 1,
        hostBindings: function MinLengthValidator_HostBindings(rf2, ctx) {
          if (rf2 & 2) {
            \u0275\u0275attribute("minlength", ctx._enabled ? ctx.minlength : null);
          }
        },
        inputs: {
          minlength: "minlength"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([MIN_LENGTH_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinLengthValidator, [{
        type: Directive,
        args: [{
          selector: "[minlength][formControlName],[minlength][formControl],[minlength][ngModel]",
          providers: [MIN_LENGTH_VALIDATOR],
          host: {
            "[attr.minlength]": "_enabled ? minlength : null"
          },
          standalone: false
        }]
      }], null, {
        minlength: [{
          type: Input
        }]
      });
    })();
    MAX_LENGTH_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => MaxLengthValidator),
      multi: true
    };
    MaxLengthValidator = class _MaxLengthValidator extends AbstractValidatorDirective {
      /**
       * @description
       * Tracks changes to the maximum length bound to this directive.
       */
      maxlength;
      /** @internal */
      inputName = "maxlength";
      /** @internal */
      normalizeInput = (input2) => toInteger(input2);
      /** @internal */
      createValidator = (maxlength) => maxLengthValidator(maxlength);
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275MaxLengthValidator_BaseFactory;
        return function MaxLengthValidator_Factory(__ngFactoryType__) {
          return (\u0275MaxLengthValidator_BaseFactory || (\u0275MaxLengthValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MaxLengthValidator)))(__ngFactoryType__ || _MaxLengthValidator);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _MaxLengthValidator,
        selectors: [["", "maxlength", "", "formControlName", ""], ["", "maxlength", "", "formControl", ""], ["", "maxlength", "", "ngModel", ""]],
        hostVars: 1,
        hostBindings: function MaxLengthValidator_HostBindings(rf2, ctx) {
          if (rf2 & 2) {
            \u0275\u0275attribute("maxlength", ctx._enabled ? ctx.maxlength : null);
          }
        },
        inputs: {
          maxlength: "maxlength"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([MAX_LENGTH_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxLengthValidator, [{
        type: Directive,
        args: [{
          selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]",
          providers: [MAX_LENGTH_VALIDATOR],
          host: {
            "[attr.maxlength]": "_enabled ? maxlength : null"
          },
          standalone: false
        }]
      }], null, {
        maxlength: [{
          type: Input
        }]
      });
    })();
    PATTERN_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => PatternValidator),
      multi: true
    };
    PatternValidator = class _PatternValidator extends AbstractValidatorDirective {
      /**
       * @description
       * Tracks changes to the pattern bound to this directive.
       */
      pattern;
      // This input is always defined, since the name matches selector.
      /** @internal */
      inputName = "pattern";
      /** @internal */
      normalizeInput = (input2) => input2;
      /** @internal */
      createValidator = (input2) => patternValidator(input2);
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275PatternValidator_BaseFactory;
        return function PatternValidator_Factory(__ngFactoryType__) {
          return (\u0275PatternValidator_BaseFactory || (\u0275PatternValidator_BaseFactory = \u0275\u0275getInheritedFactory(_PatternValidator)))(__ngFactoryType__ || _PatternValidator);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _PatternValidator,
        selectors: [["", "pattern", "", "formControlName", ""], ["", "pattern", "", "formControl", ""], ["", "pattern", "", "ngModel", ""]],
        hostVars: 1,
        hostBindings: function PatternValidator_HostBindings(rf2, ctx) {
          if (rf2 & 2) {
            \u0275\u0275attribute("pattern", ctx._enabled ? ctx.pattern : null);
          }
        },
        inputs: {
          pattern: "pattern"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([PATTERN_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PatternValidator, [{
        type: Directive,
        args: [{
          selector: "[pattern][formControlName],[pattern][formControl],[pattern][ngModel]",
          providers: [PATTERN_VALIDATOR],
          host: {
            "[attr.pattern]": "_enabled ? pattern : null"
          },
          standalone: false
        }]
      }], null, {
        pattern: [{
          type: Input
        }]
      });
    })();
    SHARED_FORM_DIRECTIVES = [\u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator];
    TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
    REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
    \u0275InternalFormsSharedModule = class _\u0275InternalFormsSharedModule {
      static \u0275fac = function \u0275InternalFormsSharedModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _\u0275InternalFormsSharedModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _\u0275InternalFormsSharedModule,
        declarations: [\u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator],
        exports: [\u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator]
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275InternalFormsSharedModule, [{
        type: NgModule,
        args: [{
          declarations: SHARED_FORM_DIRECTIVES,
          exports: SHARED_FORM_DIRECTIVES
        }]
      }], null, null);
    })();
    FormArray = class extends AbstractControl {
      /**
       * Creates a new `FormArray` instance.
       *
       * @param controls An array of child controls. Each child control is given an index
       * where it is registered.
       *
       * @param validatorOrOpts A synchronous validator function, or an array of
       * such functions, or an `AbstractControlOptions` object that contains validation functions
       * and a validation trigger.
       *
       * @param asyncValidator A single async validator or array of async validator functions
       *
       */
      constructor(controls, validatorOrOpts, asyncValidator) {
        super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
        this.controls = controls;
        this._initObservables();
        this._setUpdateStrategy(validatorOrOpts);
        this._setUpControls();
        this.updateValueAndValidity({
          onlySelf: true,
          // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
          // `VALID` or `INVALID`.
          // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`
          // to `true` to allow that during the control creation process.
          emitEvent: !!this.asyncValidator
        });
      }
      controls;
      /**
       * Get the `AbstractControl` at the given `index` in the array.
       *
       * @param index Index in the array to retrieve the control. If `index` is negative, it will wrap
       *     around from the back, and if index is greatly negative (less than `-length`), the result is
       * undefined. This behavior is the same as `Array.at(index)`.
       */
      at(index) {
        return this.controls[this._adjustIndex(index)];
      }
      /**
       * Insert a new `AbstractControl` at the end of the array.
       *
       * @param control Form control to be inserted
       * @param options Specifies whether this FormArray instance should emit events after a new
       *     control is added.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges` observables emit events with the latest status and value when the control is
       * inserted. When false, no events are emitted.
       */
      push(control, options = {}) {
        this.controls.push(control);
        this._registerControl(control);
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
        this._onCollectionChange();
      }
      /**
       * Insert a new `AbstractControl` at the given `index` in the array.
       *
       * @param index Index in the array to insert the control. If `index` is negative, wraps around
       *     from the back. If `index` is greatly negative (less than `-length`), prepends to the array.
       * This behavior is the same as `Array.splice(index, 0, control)`.
       * @param control Form control to be inserted
       * @param options Specifies whether this FormArray instance should emit events after a new
       *     control is inserted.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges` observables emit events with the latest status and value when the control is
       * inserted. When false, no events are emitted.
       */
      insert(index, control, options = {}) {
        this.controls.splice(index, 0, control);
        this._registerControl(control);
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
      }
      /**
       * Remove the control at the given `index` in the array.
       *
       * @param index Index in the array to remove the control.  If `index` is negative, wraps around
       *     from the back. If `index` is greatly negative (less than `-length`), removes the first
       *     element. This behavior is the same as `Array.splice(index, 1)`.
       * @param options Specifies whether this FormArray instance should emit events after a
       *     control is removed.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges` observables emit events with the latest status and value when the control is
       * removed. When false, no events are emitted.
       */
      removeAt(index, options = {}) {
        let adjustedIndex = this._adjustIndex(index);
        if (adjustedIndex < 0) adjustedIndex = 0;
        if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {
        });
        this.controls.splice(adjustedIndex, 1);
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
      }
      /**
       * Replace an existing control.
       *
       * @param index Index in the array to replace the control. If `index` is negative, wraps around
       *     from the back. If `index` is greatly negative (less than `-length`), replaces the first
       *     element. This behavior is the same as `Array.splice(index, 1, control)`.
       * @param control The `AbstractControl` control to replace the existing control
       * @param options Specifies whether this FormArray instance should emit events after an
       *     existing control is replaced with a new one.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges` observables emit events with the latest status and value when the control is
       * replaced with a new one. When false, no events are emitted.
       */
      setControl(index, control, options = {}) {
        let adjustedIndex = this._adjustIndex(index);
        if (adjustedIndex < 0) adjustedIndex = 0;
        if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {
        });
        this.controls.splice(adjustedIndex, 1);
        if (control) {
          this.controls.splice(adjustedIndex, 0, control);
          this._registerControl(control);
        }
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
        this._onCollectionChange();
      }
      /**
       * Length of the control array.
       */
      get length() {
        return this.controls.length;
      }
      /**
       * Sets the value of the `FormArray`. It accepts an array that matches
       * the structure of the control.
       *
       * This method performs strict checks, and throws an error if you try
       * to set the value of a control that doesn't exist or if you exclude the
       * value of a control.
       *
       * @usageNotes
       * ### Set the values for the controls in the form array
       *
       * ```ts
       * const arr = new FormArray([
       *   new FormControl(),
       *   new FormControl()
       * ]);
       * console.log(arr.value);   // [null, null]
       *
       * arr.setValue(['Nancy', 'Drew']);
       * console.log(arr.value);   // ['Nancy', 'Drew']
       * ```
       *
       * @param value Array of values for the controls
       * @param options Configure options that determine how the control propagates changes and
       * emits events after the value changes
       *
       * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
       * is false.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges`
       * observables emit events with the latest status and value when the control value is updated.
       * When false, no events are emitted.
       * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
       * updateValueAndValidity} method.
       */
      setValue(value, options = {}) {
        assertAllValuesPresent(this, false, value);
        value.forEach((newValue, index) => {
          assertControlPresent(this, false, index);
          this.at(index).setValue(newValue, {
            onlySelf: true,
            emitEvent: options.emitEvent
          });
        });
        this.updateValueAndValidity(options);
      }
      /**
       * Patches the value of the `FormArray`. It accepts an array that matches the
       * structure of the control, and does its best to match the values to the correct
       * controls in the group.
       *
       * It accepts both super-sets and sub-sets of the array without throwing an error.
       *
       * @usageNotes
       * ### Patch the values for controls in a form array
       *
       * ```ts
       * const arr = new FormArray([
       *    new FormControl(),
       *    new FormControl()
       * ]);
       * console.log(arr.value);   // [null, null]
       *
       * arr.patchValue(['Nancy']);
       * console.log(arr.value);   // ['Nancy', null]
       * ```
       *
       * @param value Array of latest values for the controls
       * @param options Configure options that determine how the control propagates changes and
       * emits events after the value changes
       *
       * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
       * is false.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges` observables emit events with the latest status and value when the control
       * value is updated. When false, no events are emitted. The configuration options are passed to
       * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
       */
      patchValue(value, options = {}) {
        if (value == null) return;
        value.forEach((newValue, index) => {
          if (this.at(index)) {
            this.at(index).patchValue(newValue, {
              onlySelf: true,
              emitEvent: options.emitEvent
            });
          }
        });
        this.updateValueAndValidity(options);
      }
      /**
       * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the
       * value of all descendants to null or null maps.
       *
       * You reset to a specific form state by passing in an array of states
       * that matches the structure of the control. The state is a standalone value
       * or a form state object with both a value and a disabled status.
       *
       * @usageNotes
       * ### Reset the values in a form array
       *
       * ```ts
       * const arr = new FormArray([
       *    new FormControl(),
       *    new FormControl()
       * ]);
       * arr.reset(['name', 'last name']);
       *
       * console.log(arr.value);  // ['name', 'last name']
       * ```
       *
       * ### Reset the values in a form array and the disabled status for the first control
       *
       * ```ts
       * arr.reset([
       *   {value: 'name', disabled: true},
       *   'last'
       * ]);
       *
       * console.log(arr.value);  // ['last']
       * console.log(arr.at(0).status);  // 'DISABLED'
       * ```
       *
       * @param value Array of values for the controls
       * @param options Configure options that determine how the control propagates changes and
       * emits events after the value changes
       *
       * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
       * is false.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges`
       * observables emit events with the latest status and value when the control is reset.
       * When false, no events are emitted.
       * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
       * updateValueAndValidity} method.
       */
      reset(value = [], options = {}) {
        this._forEachChild((control, index) => {
          control.reset(value[index], {
            onlySelf: true,
            emitEvent: options.emitEvent
          });
        });
        this._updatePristine(options, this);
        this._updateTouched(options, this);
        this.updateValueAndValidity(options);
      }
      /**
       * The aggregate value of the array, including any disabled controls.
       *
       * Reports all values regardless of disabled status.
       */
      getRawValue() {
        return this.controls.map((control) => control.getRawValue());
      }
      /**
       * Remove all controls in the `FormArray`.
       *
       * @param options Specifies whether this FormArray instance should emit events after all
       *     controls are removed.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges` observables emit events with the latest status and value when all controls
       * in this FormArray instance are removed. When false, no events are emitted.
       *
       * @usageNotes
       * ### Remove all elements from a FormArray
       *
       * ```ts
       * const arr = new FormArray([
       *    new FormControl(),
       *    new FormControl()
       * ]);
       * console.log(arr.length);  // 2
       *
       * arr.clear();
       * console.log(arr.length);  // 0
       * ```
       *
       * It's a simpler and more efficient alternative to removing all elements one by one:
       *
       * ```ts
       * const arr = new FormArray([
       *    new FormControl(),
       *    new FormControl()
       * ]);
       *
       * while (arr.length) {
       *    arr.removeAt(0);
       * }
       * ```
       */
      clear(options = {}) {
        if (this.controls.length < 1) return;
        this._forEachChild((control) => control._registerOnCollectionChange(() => {
        }));
        this.controls.splice(0);
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
      }
      /**
       * Adjusts a negative index by summing it with the length of the array. For very negative
       * indices, the result may remain negative.
       * @internal
       */
      _adjustIndex(index) {
        return index < 0 ? index + this.length : index;
      }
      /** @internal */
      _syncPendingControls() {
        let subtreeUpdated = this.controls.reduce((updated, child) => {
          return child._syncPendingControls() ? true : updated;
        }, false);
        if (subtreeUpdated) this.updateValueAndValidity({
          onlySelf: true
        });
        return subtreeUpdated;
      }
      /** @internal */
      _forEachChild(cb) {
        this.controls.forEach((control, index) => {
          cb(control, index);
        });
      }
      /** @internal */
      _updateValue() {
        this.value = this.controls.filter((control) => control.enabled || this.disabled).map((control) => control.value);
      }
      /** @internal */
      _anyControls(condition) {
        return this.controls.some((control) => control.enabled && condition(control));
      }
      /** @internal */
      _setUpControls() {
        this._forEachChild((control) => this._registerControl(control));
      }
      /** @internal */
      _allControlsDisabled() {
        for (const control of this.controls) {
          if (control.enabled) return false;
        }
        return this.controls.length > 0 || this.disabled;
      }
      _registerControl(control) {
        control.setParent(this);
        control._registerOnCollectionChange(this._onCollectionChange);
      }
      /** @internal */
      _find(name) {
        return this.at(name) ?? null;
      }
    };
    FormBuilder = class _FormBuilder {
      useNonNullable = false;
      /**
       * @description
       * Returns a FormBuilder in which automatically constructed `FormControl` elements
       * have `{nonNullable: true}` and are non-nullable.
       *
       * **Constructing non-nullable controls**
       *
       * When constructing a control, it will be non-nullable, and will reset to its initial value.
       *
       * ```ts
       * let nnfb = new FormBuilder().nonNullable;
       * let name = nnfb.control('Alex'); // FormControl<string>
       * name.reset();
       * console.log(name); // 'Alex'
       * ```
       *
       * **Constructing non-nullable groups or arrays**
       *
       * When constructing a group or array, all automatically created inner controls will be
       * non-nullable, and will reset to their initial values.
       *
       * ```ts
       * let nnfb = new FormBuilder().nonNullable;
       * let name = nnfb.group({who: 'Alex'}); // FormGroup<{who: FormControl<string>}>
       * name.reset();
       * console.log(name); // {who: 'Alex'}
       * ```
       * **Constructing *nullable* fields on groups or arrays**
       *
       * It is still possible to have a nullable field. In particular, any `FormControl` which is
       * *already* constructed will not be altered. For example:
       *
       * ```ts
       * let nnfb = new FormBuilder().nonNullable;
       * // FormGroup<{who: FormControl<string|null>}>
       * let name = nnfb.group({who: new FormControl('Alex')});
       * name.reset(); console.log(name); // {who: null}
       * ```
       *
       * Because the inner control is constructed explicitly by the caller, the builder has
       * no control over how it is created, and cannot exclude the `null`.
       */
      get nonNullable() {
        const nnfb = new _FormBuilder();
        nnfb.useNonNullable = true;
        return nnfb;
      }
      group(controls, options = null) {
        const reducedControls = this._reduceControls(controls);
        let newOptions = {};
        if (isAbstractControlOptions(options)) {
          newOptions = options;
        } else if (options !== null) {
          newOptions.validators = options.validator;
          newOptions.asyncValidators = options.asyncValidator;
        }
        return new FormGroup(reducedControls, newOptions);
      }
      /**
       * @description
       * Constructs a new `FormRecord` instance. Accepts a single generic argument, which is an object
       * containing all the keys and corresponding inner control types.
       *
       * @param controls A collection of child controls. The key for each child is the name
       * under which it is registered.
       *
       * @param options Configuration options object for the `FormRecord`. The object should have the
       * `AbstractControlOptions` type and might contain the following fields:
       * * `validators`: A synchronous validator function, or an array of validator functions.
       * * `asyncValidators`: A single async validator or array of async validator functions.
       * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur'
       * | submit').
       */
      record(controls, options = null) {
        const reducedControls = this._reduceControls(controls);
        return new FormRecord(reducedControls, options);
      }
      /**
       * @description
       * Constructs a new `FormControl` with the given state, validators and options. Sets
       * `{nonNullable: true}` in the options to get a non-nullable control. Otherwise, the
       * control will be nullable. Accepts a single generic argument, which is the type  of the
       * control's value.
       *
       * @param formState Initializes the control with an initial state value, or
       * with an object that contains both a value and a disabled status.
       *
       * @param validatorOrOpts A synchronous validator function, or an array of
       * such functions, or a `FormControlOptions` object that contains
       * validation functions and a validation trigger.
       *
       * @param asyncValidator A single async validator or array of async validator
       * functions.
       *
       * @usageNotes
       *
       * ### Initialize a control as disabled
       *
       * The following example returns a control with an initial value in a disabled state.
       *
       * {@example forms/ts/formBuilder/form_builder_example.ts region='disabled-control'}
       */
      control(formState, validatorOrOpts, asyncValidator) {
        let newOptions = {};
        if (!this.useNonNullable) {
          return new FormControl(formState, validatorOrOpts, asyncValidator);
        }
        if (isAbstractControlOptions(validatorOrOpts)) {
          newOptions = validatorOrOpts;
        } else {
          newOptions.validators = validatorOrOpts;
          newOptions.asyncValidators = asyncValidator;
        }
        return new FormControl(formState, __spreadProps(__spreadValues({}, newOptions), {
          nonNullable: true
        }));
      }
      /**
       * Constructs a new `FormArray` from the given array of configurations,
       * validators and options. Accepts a single generic argument, which is the type of each control
       * inside the array.
       *
       * @param controls An array of child controls or control configs. Each child control is given an
       *     index when it is registered.
       *
       * @param validatorOrOpts A synchronous validator function, or an array of such functions, or an
       *     `AbstractControlOptions` object that contains
       * validation functions and a validation trigger.
       *
       * @param asyncValidator A single async validator or array of async validator functions.
       */
      array(controls, validatorOrOpts, asyncValidator) {
        const createdControls = controls.map((c2) => this._createControl(c2));
        return new FormArray(createdControls, validatorOrOpts, asyncValidator);
      }
      /** @internal */
      _reduceControls(controls) {
        const createdControls = {};
        Object.keys(controls).forEach((controlName) => {
          createdControls[controlName] = this._createControl(controls[controlName]);
        });
        return createdControls;
      }
      /** @internal */
      _createControl(controls) {
        if (controls instanceof FormControl) {
          return controls;
        } else if (controls instanceof AbstractControl) {
          return controls;
        } else if (Array.isArray(controls)) {
          const value = controls[0];
          const validator = controls.length > 1 ? controls[1] : null;
          const asyncValidator = controls.length > 2 ? controls[2] : null;
          return this.control(value, validator, asyncValidator);
        } else {
          return this.control(controls);
        }
      }
      static \u0275fac = function FormBuilder_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _FormBuilder)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _FormBuilder,
        factory: _FormBuilder.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormBuilder, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    NonNullableFormBuilder = class _NonNullableFormBuilder {
      static \u0275fac = function NonNullableFormBuilder_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NonNullableFormBuilder)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _NonNullableFormBuilder,
        factory: () => (() => inject2(FormBuilder).nonNullable)(),
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NonNullableFormBuilder, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: () => inject2(FormBuilder).nonNullable
        }]
      }], null, null);
    })();
    UntypedFormBuilder = class _UntypedFormBuilder extends FormBuilder {
      group(controlsConfig, options = null) {
        return super.group(controlsConfig, options);
      }
      /**
       * Like `FormBuilder#control`, except the resulting control is untyped.
       */
      control(formState, validatorOrOpts, asyncValidator) {
        return super.control(formState, validatorOrOpts, asyncValidator);
      }
      /**
       * Like `FormBuilder#array`, except the resulting array is untyped.
       */
      array(controlsConfig, validatorOrOpts, asyncValidator) {
        return super.array(controlsConfig, validatorOrOpts, asyncValidator);
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275UntypedFormBuilder_BaseFactory;
        return function UntypedFormBuilder_Factory(__ngFactoryType__) {
          return (\u0275UntypedFormBuilder_BaseFactory || (\u0275UntypedFormBuilder_BaseFactory = \u0275\u0275getInheritedFactory(_UntypedFormBuilder)))(__ngFactoryType__ || _UntypedFormBuilder);
        };
      })();
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _UntypedFormBuilder,
        factory: _UntypedFormBuilder.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UntypedFormBuilder, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    VERSION5 = new Version("20.1.7");
    FormsModule = class _FormsModule {
      /**
       * @description
       * Provides options for configuring the forms module.
       *
       * @param opts An object of configuration options
       * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
       * correct, or to only call it `whenDisabled`, which is the legacy behavior.
       */
      static withConfig(opts) {
        return {
          ngModule: _FormsModule,
          providers: [{
            provide: CALL_SET_DISABLED_STATE,
            useValue: opts.callSetDisabledState ?? setDisabledStateDefault
          }]
        };
      }
      static \u0275fac = function FormsModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _FormsModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _FormsModule,
        declarations: [NgModel, NgModelGroup, NgForm],
        exports: [\u0275InternalFormsSharedModule, NgModel, NgModelGroup, NgForm]
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
        imports: [\u0275InternalFormsSharedModule]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormsModule, [{
        type: NgModule,
        args: [{
          declarations: TEMPLATE_DRIVEN_DIRECTIVES,
          exports: [\u0275InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
        }]
      }], null, null);
    })();
    ReactiveFormsModule = class _ReactiveFormsModule {
      /**
       * @description
       * Provides options for configuring the reactive forms module.
       *
       * @param opts An object of configuration options
       * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`
       * binding is used with reactive form directives.
       * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
       * correct, or to only call it `whenDisabled`, which is the legacy behavior.
       */
      static withConfig(opts) {
        return {
          ngModule: _ReactiveFormsModule,
          providers: [{
            provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,
            useValue: opts.warnOnNgModelWithFormControl ?? "always"
          }, {
            provide: CALL_SET_DISABLED_STATE,
            useValue: opts.callSetDisabledState ?? setDisabledStateDefault
          }]
        };
      }
      static \u0275fac = function ReactiveFormsModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ReactiveFormsModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _ReactiveFormsModule,
        declarations: [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName],
        exports: [\u0275InternalFormsSharedModule, FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName]
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
        imports: [\u0275InternalFormsSharedModule]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReactiveFormsModule, [{
        type: NgModule,
        args: [{
          declarations: [REACTIVE_DRIVEN_DIRECTIVES],
          exports: [\u0275InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
        }]
      }], null, null);
    })();
  }
});

// src/app/dashboard/signaling.service.ts
var SignalingService;
var init_signaling_service = __esm({
  "src/app/dashboard/signaling.service.ts"() {
    "use strict";
    init_core();
    init_esm();
    init_core();
    SignalingService = class _SignalingService {
      ws = null;
      messagesSubject = new Subject();
      messages$ = this.messagesSubject.asObservable();
      room;
      buildUrl(room) {
        const override = window.__SIGNALING_URL__;
        if (override) {
          return `${override.replace(/\/$/, "")}/${encodeURIComponent(room)}/`;
        }
        const scheme = location.protocol === "https:" ? "wss" : "ws";
        return `${scheme}://${location.host}/ws/signaling/${encodeURIComponent(room)}/`;
      }
      connect(room) {
        this.room = room;
        const url = this.buildUrl(room);
        console.log("[SignalingService] connecting \u2192", url);
        this.ws = new WebSocket(url);
        this.ws.onopen = () => {
          console.log("[SignalingService] \u2705 WebSocket connected");
        };
        this.ws.onmessage = (ev) => {
          try {
            const data = JSON.parse(ev.data);
            this.messagesSubject.next(data);
          } catch (err) {
            console.error("[SignalingService] JSON parse error", err, ev.data);
          }
        };
        this.ws.onclose = () => {
          console.warn("[SignalingService] WebSocket closed, attempting reconnect\u2026");
          setTimeout(() => this.reconnect(), 1e3);
        };
        this.ws.onerror = (err) => {
          console.error("[SignalingService] WebSocket error", err);
          this.ws?.close();
        };
      }
      reconnect() {
        if (this.room)
          this.connect(this.room);
      }
      disconnect() {
        this.ws?.close();
        this.ws = null;
      }
      sendMessage(msg) {
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
          console.warn("[SignalingService] sendMessage failed, socket not open");
          return;
        }
        try {
          this.ws.send(JSON.stringify(msg));
        } catch (err) {
          console.error("[SignalingService] sendMessage error", err, msg);
        }
      }
      static \u0275fac = function SignalingService_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _SignalingService)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _SignalingService, factory: _SignalingService.\u0275fac, providedIn: "root" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SignalingService, [{
        type: Injectable,
        args: [{ providedIn: "root" }]
      }], null, null);
    })();
  }
});

// src/app/dashboard/src-object.directive.ts
var SrcObjectDirective;
var init_src_object_directive = __esm({
  "src/app/dashboard/src-object.directive.ts"() {
    "use strict";
    init_core();
    init_core();
    SrcObjectDirective = class _SrcObjectDirective {
      el;
      srcObject;
      constructor(el2) {
        this.el = el2;
      }
      ngOnChanges(changes) {
        if ("srcObject" in changes) {
          const element = this.el.nativeElement;
          if (this.srcObject instanceof MediaStream) {
            element.srcObject = this.srcObject;
          } else {
            element.srcObject = null;
          }
        }
      }
      static \u0275fac = function SrcObjectDirective_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _SrcObjectDirective)(\u0275\u0275directiveInject(ElementRef));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({ type: _SrcObjectDirective, selectors: [["", "appSrcObject", ""]], inputs: { srcObject: [0, "appSrcObject", "srcObject"] }, features: [\u0275\u0275NgOnChangesFeature] });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SrcObjectDirective, [{
        type: Directive,
        args: [{
          selector: "[appSrcObject]",
          standalone: true
        }]
      }], () => [{ type: ElementRef }], { srcObject: [{
        type: Input,
        args: ["appSrcObject"]
      }] });
    })();
  }
});

// node_modules/@angular/cdk/fesm2022/shadow-dom.mjs
function _supportsShadowDom() {
  if (shadowDomIsSupported == null) {
    const head = typeof document !== "undefined" ? document.head : null;
    shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));
  }
  return shadowDomIsSupported;
}
function _getShadowRoot(element) {
  if (_supportsShadowDom()) {
    const rootNode = element.getRootNode ? element.getRootNode() : null;
    if (typeof ShadowRoot !== "undefined" && ShadowRoot && rootNode instanceof ShadowRoot) {
      return rootNode;
    }
  }
  return null;
}
function _getEventTarget(event) {
  return event.composedPath ? event.composedPath()[0] : event.target;
}
var shadowDomIsSupported;
var init_shadow_dom = __esm({
  "node_modules/@angular/cdk/fesm2022/shadow-dom.mjs"() {
    "use strict";
  }
});

// node_modules/@angular/cdk/fesm2022/fake-event-detection.mjs
function isFakeMousedownFromScreenReader(event) {
  return event.buttons === 0 || event.detail === 0;
}
function isFakeTouchstartFromScreenReader(event) {
  const touch = event.touches && event.touches[0] || event.changedTouches && event.changedTouches[0];
  return !!touch && touch.identifier === -1 && (touch.radiusX == null || touch.radiusX === 1) && (touch.radiusY == null || touch.radiusY === 1);
}
var init_fake_event_detection = __esm({
  "node_modules/@angular/cdk/fesm2022/fake-event-detection.mjs"() {
    "use strict";
  }
});

// node_modules/@angular/cdk/fesm2022/element.mjs
function coerceNumberProperty(value, fallbackValue = 0) {
  if (_isNumberValue(value)) {
    return Number(value);
  }
  return arguments.length === 2 ? fallbackValue : 0;
}
function _isNumberValue(value) {
  return !isNaN(parseFloat(value)) && !isNaN(Number(value));
}
function coerceElement(elementOrRef) {
  return elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;
}
var init_element = __esm({
  "node_modules/@angular/cdk/fesm2022/element.mjs"() {
    "use strict";
    init_core();
  }
});

// node_modules/@angular/cdk/fesm2022/style-loader.mjs
var appsWithLoaders, _CdkPrivateStyleLoader;
var init_style_loader = __esm({
  "node_modules/@angular/cdk/fesm2022/style-loader.mjs"() {
    "use strict";
    init_core();
    init_core();
    appsWithLoaders = /* @__PURE__ */ new WeakMap();
    _CdkPrivateStyleLoader = class __CdkPrivateStyleLoader {
      _appRef;
      _injector = inject2(Injector);
      _environmentInjector = inject2(EnvironmentInjector);
      /**
       * Loads a set of styles.
       * @param loader Component which will be instantiated to load the styles.
       */
      load(loader) {
        const appRef = this._appRef = this._appRef || this._injector.get(ApplicationRef);
        let data = appsWithLoaders.get(appRef);
        if (!data) {
          data = {
            loaders: /* @__PURE__ */ new Set(),
            refs: []
          };
          appsWithLoaders.set(appRef, data);
          appRef.onDestroy(() => {
            appsWithLoaders.get(appRef)?.refs.forEach((ref) => ref.destroy());
            appsWithLoaders.delete(appRef);
          });
        }
        if (!data.loaders.has(loader)) {
          data.loaders.add(loader);
          data.refs.push(createComponent(loader, {
            environmentInjector: this._environmentInjector
          }));
        }
      }
      static \u0275fac = function _CdkPrivateStyleLoader_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || __CdkPrivateStyleLoader)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: __CdkPrivateStyleLoader,
        factory: __CdkPrivateStyleLoader.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_CdkPrivateStyleLoader, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
  }
});

// node_modules/@angular/cdk/fesm2022/platform2.mjs
var hasV8BreakIterator, Platform;
var init_platform2 = __esm({
  "node_modules/@angular/cdk/fesm2022/platform2.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_common();
    try {
      hasV8BreakIterator = typeof Intl !== "undefined" && Intl.v8BreakIterator;
    } catch {
      hasV8BreakIterator = false;
    }
    Platform = class _Platform {
      _platformId = inject2(PLATFORM_ID);
      // We want to use the Angular platform check because if the Document is shimmed
      // without the navigator, the following checks will fail. This is preferred because
      // sometimes the Document may be shimmed without the user's knowledge or intention
      /** Whether the Angular application is being rendered in the browser. */
      isBrowser = this._platformId ? isPlatformBrowser(this._platformId) : typeof document === "object" && !!document;
      /** Whether the current browser is Microsoft Edge. */
      EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);
      /** Whether the current rendering engine is Microsoft Trident. */
      TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);
      // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.
      /** Whether the current rendering engine is Blink. */
      BLINK = this.isBrowser && !!(window.chrome || hasV8BreakIterator) && typeof CSS !== "undefined" && !this.EDGE && !this.TRIDENT;
      // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to
      // ensure that Webkit runs standalone and is not used as another engine's base.
      /** Whether the current rendering engine is WebKit. */
      WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;
      /** Whether the current platform is Apple iOS. */
      IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window);
      // It's difficult to detect the plain Gecko engine, because most of the browsers identify
      // them self as Gecko-like browsers and modify the userAgent's according to that.
      // Since we only cover one explicit Firefox case, we can simply check for Firefox
      // instead of having an unstable check for Gecko.
      /** Whether the current browser is Firefox. */
      FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);
      /** Whether the current platform is Android. */
      // Trident on mobile adds the android platform to the userAgent to trick detections.
      ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;
      // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake
      // this and just place the Safari keyword in the userAgent. To be more safe about Safari every
      // Safari browser should also use Webkit as its layout engine.
      /** Whether the current browser is Safari. */
      SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
      constructor() {
      }
      static \u0275fac = function Platform_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Platform)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _Platform,
        factory: _Platform.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Platform, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [], null);
    })();
  }
});

// node_modules/@angular/cdk/fesm2022/directionality.mjs
function DIR_DOCUMENT_FACTORY() {
  return inject2(DOCUMENT);
}
function _resolveDirectionality(rawValue) {
  const value = rawValue?.toLowerCase() || "";
  if (value === "auto" && typeof navigator !== "undefined" && navigator?.language) {
    return RTL_LOCALE_PATTERN.test(navigator.language) ? "rtl" : "ltr";
  }
  return value === "rtl" ? "rtl" : "ltr";
}
var DIR_DOCUMENT, RTL_LOCALE_PATTERN, Directionality;
var init_directionality = __esm({
  "node_modules/@angular/cdk/fesm2022/directionality.mjs"() {
    "use strict";
    init_core();
    init_core();
    DIR_DOCUMENT = new InjectionToken("cdk-dir-doc", {
      providedIn: "root",
      factory: DIR_DOCUMENT_FACTORY
    });
    RTL_LOCALE_PATTERN = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;
    Directionality = class _Directionality {
      /** The current 'ltr' or 'rtl' value. */
      get value() {
        return this.valueSignal();
      }
      /**
       * The current 'ltr' or 'rtl' value.
       */
      valueSignal = signal("ltr", ...ngDevMode ? [{
        debugName: "valueSignal"
      }] : []);
      /** Stream that emits whenever the 'ltr' / 'rtl' state changes. */
      change = new EventEmitter();
      constructor() {
        const _document2 = inject2(DIR_DOCUMENT, {
          optional: true
        });
        if (_document2) {
          const bodyDir = _document2.body ? _document2.body.dir : null;
          const htmlDir = _document2.documentElement ? _document2.documentElement.dir : null;
          this.valueSignal.set(_resolveDirectionality(bodyDir || htmlDir || "ltr"));
        }
      }
      ngOnDestroy() {
        this.change.complete();
      }
      static \u0275fac = function Directionality_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Directionality)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _Directionality,
        factory: _Directionality.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Directionality, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [], null);
    })();
  }
});

// node_modules/@angular/cdk/fesm2022/scrolling2.mjs
function supportsScrollBehavior() {
  if (scrollBehaviorSupported == null) {
    if (typeof document !== "object" || !document || typeof Element !== "function" || !Element) {
      scrollBehaviorSupported = false;
      return scrollBehaviorSupported;
    }
    if ("scrollBehavior" in document.documentElement.style) {
      scrollBehaviorSupported = true;
    } else {
      const scrollToFunction = Element.prototype.scrollTo;
      if (scrollToFunction) {
        scrollBehaviorSupported = !/\{\s*\[native code\]\s*\}/.test(scrollToFunction.toString());
      } else {
        scrollBehaviorSupported = false;
      }
    }
  }
  return scrollBehaviorSupported;
}
function getRtlScrollAxisType() {
  if (typeof document !== "object" || !document) {
    return RtlScrollAxisType.NORMAL;
  }
  if (rtlScrollAxisType == null) {
    const scrollContainer = document.createElement("div");
    const containerStyle = scrollContainer.style;
    scrollContainer.dir = "rtl";
    containerStyle.width = "1px";
    containerStyle.overflow = "auto";
    containerStyle.visibility = "hidden";
    containerStyle.pointerEvents = "none";
    containerStyle.position = "absolute";
    const content = document.createElement("div");
    const contentStyle = content.style;
    contentStyle.width = "2px";
    contentStyle.height = "1px";
    scrollContainer.appendChild(content);
    document.body.appendChild(scrollContainer);
    rtlScrollAxisType = RtlScrollAxisType.NORMAL;
    if (scrollContainer.scrollLeft === 0) {
      scrollContainer.scrollLeft = 1;
      rtlScrollAxisType = scrollContainer.scrollLeft === 0 ? RtlScrollAxisType.NEGATED : RtlScrollAxisType.INVERTED;
    }
    scrollContainer.remove();
  }
  return rtlScrollAxisType;
}
var RtlScrollAxisType, rtlScrollAxisType, scrollBehaviorSupported;
var init_scrolling2 = __esm({
  "node_modules/@angular/cdk/fesm2022/scrolling2.mjs"() {
    "use strict";
    (function(RtlScrollAxisType2) {
      RtlScrollAxisType2[RtlScrollAxisType2["NORMAL"] = 0] = "NORMAL";
      RtlScrollAxisType2[RtlScrollAxisType2["NEGATED"] = 1] = "NEGATED";
      RtlScrollAxisType2[RtlScrollAxisType2["INVERTED"] = 2] = "INVERTED";
    })(RtlScrollAxisType || (RtlScrollAxisType = {}));
  }
});

// node_modules/@angular/cdk/fesm2022/bidi.mjs
var Dir, BidiModule;
var init_bidi = __esm({
  "node_modules/@angular/cdk/fesm2022/bidi.mjs"() {
    "use strict";
    init_directionality();
    init_core();
    init_core();
    Dir = class _Dir {
      /** Whether the `value` has been set to its initial value. */
      _isInitialized = false;
      /** Direction as passed in by the consumer. */
      _rawDir;
      /** Event emitted when the direction changes. */
      change = new EventEmitter();
      /** @docs-private */
      get dir() {
        return this.valueSignal();
      }
      set dir(value) {
        const previousValue = this.valueSignal();
        this.valueSignal.set(_resolveDirectionality(value));
        this._rawDir = value;
        if (previousValue !== this.valueSignal() && this._isInitialized) {
          this.change.emit(this.valueSignal());
        }
      }
      /** Current layout direction of the element. */
      get value() {
        return this.dir;
      }
      valueSignal = signal("ltr", ...ngDevMode ? [{
        debugName: "valueSignal"
      }] : []);
      /** Initialize once default value has been set. */
      ngAfterContentInit() {
        this._isInitialized = true;
      }
      ngOnDestroy() {
        this.change.complete();
      }
      static \u0275fac = function Dir_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Dir)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _Dir,
        selectors: [["", "dir", ""]],
        hostVars: 1,
        hostBindings: function Dir_HostBindings(rf2, ctx) {
          if (rf2 & 2) {
            \u0275\u0275attribute("dir", ctx._rawDir);
          }
        },
        inputs: {
          dir: "dir"
        },
        outputs: {
          change: "dirChange"
        },
        exportAs: ["dir"],
        features: [\u0275\u0275ProvidersFeature([{
          provide: Directionality,
          useExisting: _Dir
        }])]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Dir, [{
        type: Directive,
        args: [{
          selector: "[dir]",
          providers: [{
            provide: Directionality,
            useExisting: Dir
          }],
          host: {
            "[attr.dir]": "_rawDir"
          },
          exportAs: "dir"
        }]
      }], null, {
        change: [{
          type: Output,
          args: ["dirChange"]
        }],
        dir: [{
          type: Input
        }]
      });
    })();
    BidiModule = class _BidiModule {
      static \u0275fac = function BidiModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _BidiModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _BidiModule,
        imports: [Dir],
        exports: [Dir]
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BidiModule, [{
        type: NgModule,
        args: [{
          imports: [Dir],
          exports: [Dir]
        }]
      }], null, null);
    })();
  }
});

// node_modules/@angular/cdk/fesm2022/data-source.mjs
function isDataSource(value) {
  return value && typeof value.connect === "function" && !(value instanceof ConnectableObservable);
}
var DataSource;
var init_data_source = __esm({
  "node_modules/@angular/cdk/fesm2022/data-source.mjs"() {
    "use strict";
    init_esm();
    DataSource = class {
    };
  }
});

// node_modules/@angular/cdk/fesm2022/recycle-view-repeater-strategy.mjs
var ArrayDataSource, _ViewRepeaterOperation, _VIEW_REPEATER_STRATEGY, _RecycleViewRepeaterStrategy;
var init_recycle_view_repeater_strategy = __esm({
  "node_modules/@angular/cdk/fesm2022/recycle-view-repeater-strategy.mjs"() {
    "use strict";
    init_esm();
    init_data_source();
    init_core();
    ArrayDataSource = class extends DataSource {
      _data;
      constructor(_data) {
        super();
        this._data = _data;
      }
      connect() {
        return isObservable(this._data) ? this._data : of(this._data);
      }
      disconnect() {
      }
    };
    (function(_ViewRepeaterOperation2) {
      _ViewRepeaterOperation2[_ViewRepeaterOperation2["REPLACED"] = 0] = "REPLACED";
      _ViewRepeaterOperation2[_ViewRepeaterOperation2["INSERTED"] = 1] = "INSERTED";
      _ViewRepeaterOperation2[_ViewRepeaterOperation2["MOVED"] = 2] = "MOVED";
      _ViewRepeaterOperation2[_ViewRepeaterOperation2["REMOVED"] = 3] = "REMOVED";
    })(_ViewRepeaterOperation || (_ViewRepeaterOperation = {}));
    _VIEW_REPEATER_STRATEGY = new InjectionToken("_ViewRepeater");
    _RecycleViewRepeaterStrategy = class {
      /**
       * The size of the cache used to store unused views.
       * Setting the cache size to `0` will disable caching. Defaults to 20 views.
       */
      viewCacheSize = 20;
      /**
       * View cache that stores embedded view instances that have been previously stamped out,
       * but don't are not currently rendered. The view repeater will reuse these views rather than
       * creating brand new ones.
       *
       * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.
       */
      _viewCache = [];
      /** Apply changes to the DOM. */
      applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {
        changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {
          let view;
          let operation;
          if (record.previousIndex == null) {
            const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);
            view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));
            operation = view ? _ViewRepeaterOperation.INSERTED : _ViewRepeaterOperation.REPLACED;
          } else if (currentIndex == null) {
            this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);
            operation = _ViewRepeaterOperation.REMOVED;
          } else {
            view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));
            operation = _ViewRepeaterOperation.MOVED;
          }
          if (itemViewChanged) {
            itemViewChanged({
              context: view?.context,
              operation,
              record
            });
          }
        });
      }
      detach() {
        for (const view of this._viewCache) {
          view.destroy();
        }
        this._viewCache = [];
      }
      /**
       * Inserts a view for a new item, either from the cache or by creating a new
       * one. Returns `undefined` if the item was inserted into a cached view.
       */
      _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {
        const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);
        if (cachedView) {
          cachedView.context.$implicit = value;
          return void 0;
        }
        const viewArgs = viewArgsFactory();
        return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);
      }
      /** Detaches the view at the given index and inserts into the view cache. */
      _detachAndCacheView(index, viewContainerRef) {
        const detachedView = viewContainerRef.detach(index);
        this._maybeCacheView(detachedView, viewContainerRef);
      }
      /** Moves view at the previous index to the current index. */
      _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {
        const view = viewContainerRef.get(adjustedPreviousIndex);
        viewContainerRef.move(view, currentIndex);
        view.context.$implicit = value;
        return view;
      }
      /**
       * Cache the given detached view. If the cache is full, the view will be
       * destroyed.
       */
      _maybeCacheView(view, viewContainerRef) {
        if (this._viewCache.length < this.viewCacheSize) {
          this._viewCache.push(view);
        } else {
          const index = viewContainerRef.indexOf(view);
          if (index === -1) {
            view.destroy();
          } else {
            viewContainerRef.remove(index);
          }
        }
      }
      /** Inserts a recycled view from the cache at the given index. */
      _insertViewFromCache(index, viewContainerRef) {
        const cachedView = this._viewCache.pop();
        if (cachedView) {
          viewContainerRef.insert(cachedView, index);
        }
        return cachedView || null;
      }
    };
  }
});

// node_modules/@angular/cdk/fesm2022/scrolling.mjs
function _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {
  return fixedSizeDir._scrollStrategy;
}
function rangesEqual(r1, r2) {
  return r1.start == r2.start && r1.end == r2.end;
}
function getOffset(orientation, direction, node) {
  const el2 = node;
  if (!el2.getBoundingClientRect) {
    return 0;
  }
  const rect = el2.getBoundingClientRect();
  if (orientation === "horizontal") {
    return direction === "start" ? rect.left : rect.right;
  }
  return direction === "start" ? rect.top : rect.bottom;
}
var _c0, _c1, VIRTUAL_SCROLL_STRATEGY, FixedSizeVirtualScrollStrategy, CdkFixedSizeVirtualScroll, DEFAULT_SCROLL_TIME, ScrollDispatcher, CdkScrollable, DEFAULT_RESIZE_TIME, ViewportRuler, VIRTUAL_SCROLLABLE, CdkVirtualScrollable, SCROLL_SCHEDULER, CdkVirtualScrollViewport, CdkVirtualForOf, CdkVirtualScrollableElement, CdkVirtualScrollableWindow, CdkScrollableModule, ScrollingModule;
var init_scrolling = __esm({
  "node_modules/@angular/cdk/fesm2022/scrolling.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_esm();
    init_operators();
    init_element();
    init_platform2();
    init_directionality();
    init_scrolling2();
    init_bidi();
    init_recycle_view_repeater_strategy();
    init_data_source();
    _c0 = ["contentWrapper"];
    _c1 = ["*"];
    VIRTUAL_SCROLL_STRATEGY = new InjectionToken("VIRTUAL_SCROLL_STRATEGY");
    FixedSizeVirtualScrollStrategy = class {
      _scrolledIndexChange = new Subject();
      /** @docs-private Implemented as part of VirtualScrollStrategy. */
      scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());
      /** The attached viewport. */
      _viewport = null;
      /** The size of the items in the virtually scrolling list. */
      _itemSize;
      /** The minimum amount of buffer rendered beyond the viewport (in pixels). */
      _minBufferPx;
      /** The number of buffer items to render beyond the edge of the viewport (in pixels). */
      _maxBufferPx;
      /**
       * @param itemSize The size of the items in the virtually scrolling list.
       * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
       * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
       */
      constructor(itemSize, minBufferPx, maxBufferPx) {
        this._itemSize = itemSize;
        this._minBufferPx = minBufferPx;
        this._maxBufferPx = maxBufferPx;
      }
      /**
       * Attaches this scroll strategy to a viewport.
       * @param viewport The viewport to attach this strategy to.
       */
      attach(viewport) {
        this._viewport = viewport;
        this._updateTotalContentSize();
        this._updateRenderedRange();
      }
      /** Detaches this scroll strategy from the currently attached viewport. */
      detach() {
        this._scrolledIndexChange.complete();
        this._viewport = null;
      }
      /**
       * Update the item size and buffer size.
       * @param itemSize The size of the items in the virtually scrolling list.
       * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
       * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
       */
      updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {
        if (maxBufferPx < minBufferPx && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw Error("CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx");
        }
        this._itemSize = itemSize;
        this._minBufferPx = minBufferPx;
        this._maxBufferPx = maxBufferPx;
        this._updateTotalContentSize();
        this._updateRenderedRange();
      }
      /** @docs-private Implemented as part of VirtualScrollStrategy. */
      onContentScrolled() {
        this._updateRenderedRange();
      }
      /** @docs-private Implemented as part of VirtualScrollStrategy. */
      onDataLengthChanged() {
        this._updateTotalContentSize();
        this._updateRenderedRange();
      }
      /** @docs-private Implemented as part of VirtualScrollStrategy. */
      onContentRendered() {
      }
      /** @docs-private Implemented as part of VirtualScrollStrategy. */
      onRenderedOffsetChanged() {
      }
      /**
       * Scroll to the offset for the given index.
       * @param index The index of the element to scroll to.
       * @param behavior The ScrollBehavior to use when scrolling.
       */
      scrollToIndex(index, behavior) {
        if (this._viewport) {
          this._viewport.scrollToOffset(index * this._itemSize, behavior);
        }
      }
      /** Update the viewport's total content size. */
      _updateTotalContentSize() {
        if (!this._viewport) {
          return;
        }
        this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);
      }
      /** Update the viewport's rendered range. */
      _updateRenderedRange() {
        if (!this._viewport) {
          return;
        }
        const renderedRange = this._viewport.getRenderedRange();
        const newRange = {
          start: renderedRange.start,
          end: renderedRange.end
        };
        const viewportSize = this._viewport.getViewportSize();
        const dataLength = this._viewport.getDataLength();
        let scrollOffset = this._viewport.measureScrollOffset();
        let firstVisibleIndex = this._itemSize > 0 ? scrollOffset / this._itemSize : 0;
        if (newRange.end > dataLength) {
          const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);
          const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));
          if (firstVisibleIndex != newVisibleIndex) {
            firstVisibleIndex = newVisibleIndex;
            scrollOffset = newVisibleIndex * this._itemSize;
            newRange.start = Math.floor(firstVisibleIndex);
          }
          newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));
        }
        const startBuffer = scrollOffset - newRange.start * this._itemSize;
        if (startBuffer < this._minBufferPx && newRange.start != 0) {
          const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);
          newRange.start = Math.max(0, newRange.start - expandStart);
          newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));
        } else {
          const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);
          if (endBuffer < this._minBufferPx && newRange.end != dataLength) {
            const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);
            if (expandEnd > 0) {
              newRange.end = Math.min(dataLength, newRange.end + expandEnd);
              newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));
            }
          }
        }
        this._viewport.setRenderedRange(newRange);
        this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);
        this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));
      }
    };
    CdkFixedSizeVirtualScroll = class _CdkFixedSizeVirtualScroll {
      /** The size of the items in the list (in pixels). */
      get itemSize() {
        return this._itemSize;
      }
      set itemSize(value) {
        this._itemSize = coerceNumberProperty(value);
      }
      _itemSize = 20;
      /**
       * The minimum amount of buffer rendered beyond the viewport (in pixels).
       * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.
       */
      get minBufferPx() {
        return this._minBufferPx;
      }
      set minBufferPx(value) {
        this._minBufferPx = coerceNumberProperty(value);
      }
      _minBufferPx = 100;
      /**
       * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.
       */
      get maxBufferPx() {
        return this._maxBufferPx;
      }
      set maxBufferPx(value) {
        this._maxBufferPx = coerceNumberProperty(value);
      }
      _maxBufferPx = 200;
      /** The scroll strategy used by this directive. */
      _scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);
      ngOnChanges() {
        this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);
      }
      static \u0275fac = function CdkFixedSizeVirtualScroll_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkFixedSizeVirtualScroll)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkFixedSizeVirtualScroll,
        selectors: [["cdk-virtual-scroll-viewport", "itemSize", ""]],
        inputs: {
          itemSize: "itemSize",
          minBufferPx: "minBufferPx",
          maxBufferPx: "maxBufferPx"
        },
        features: [\u0275\u0275ProvidersFeature([{
          provide: VIRTUAL_SCROLL_STRATEGY,
          useFactory: _fixedSizeVirtualScrollStrategyFactory,
          deps: [forwardRef(() => _CdkFixedSizeVirtualScroll)]
        }]), \u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFixedSizeVirtualScroll, [{
        type: Directive,
        args: [{
          selector: "cdk-virtual-scroll-viewport[itemSize]",
          providers: [{
            provide: VIRTUAL_SCROLL_STRATEGY,
            useFactory: _fixedSizeVirtualScrollStrategyFactory,
            deps: [forwardRef(() => CdkFixedSizeVirtualScroll)]
          }]
        }]
      }], null, {
        itemSize: [{
          type: Input
        }],
        minBufferPx: [{
          type: Input
        }],
        maxBufferPx: [{
          type: Input
        }]
      });
    })();
    DEFAULT_SCROLL_TIME = 20;
    ScrollDispatcher = class _ScrollDispatcher {
      _ngZone = inject2(NgZone);
      _platform = inject2(Platform);
      _renderer = inject2(RendererFactory2).createRenderer(null, null);
      _cleanupGlobalListener;
      constructor() {
      }
      /** Subject for notifying that a registered scrollable reference element has been scrolled. */
      _scrolled = new Subject();
      /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */
      _scrolledCount = 0;
      /**
       * Map of all the scrollable references that are registered with the service and their
       * scroll event subscriptions.
       */
      scrollContainers = /* @__PURE__ */ new Map();
      /**
       * Registers a scrollable instance with the service and listens for its scrolled events. When the
       * scrollable is scrolled, the service emits the event to its scrolled observable.
       * @param scrollable Scrollable instance to be registered.
       */
      register(scrollable) {
        if (!this.scrollContainers.has(scrollable)) {
          this.scrollContainers.set(scrollable, scrollable.elementScrolled().subscribe(() => this._scrolled.next(scrollable)));
        }
      }
      /**
       * De-registers a Scrollable reference and unsubscribes from its scroll event observable.
       * @param scrollable Scrollable instance to be deregistered.
       */
      deregister(scrollable) {
        const scrollableReference = this.scrollContainers.get(scrollable);
        if (scrollableReference) {
          scrollableReference.unsubscribe();
          this.scrollContainers.delete(scrollable);
        }
      }
      /**
       * Returns an observable that emits an event whenever any of the registered Scrollable
       * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
       * to override the default "throttle" time.
       *
       * **Note:** in order to avoid hitting change detection for every scroll event,
       * all of the events emitted from this stream will be run outside the Angular zone.
       * If you need to update any data bindings as a result of a scroll event, you have
       * to run the callback using `NgZone.run`.
       */
      scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {
        if (!this._platform.isBrowser) {
          return of();
        }
        return new Observable((observer) => {
          if (!this._cleanupGlobalListener) {
            this._cleanupGlobalListener = this._ngZone.runOutsideAngular(() => this._renderer.listen("document", "scroll", () => this._scrolled.next()));
          }
          const subscription = auditTimeInMs > 0 ? this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) : this._scrolled.subscribe(observer);
          this._scrolledCount++;
          return () => {
            subscription.unsubscribe();
            this._scrolledCount--;
            if (!this._scrolledCount) {
              this._cleanupGlobalListener?.();
              this._cleanupGlobalListener = void 0;
            }
          };
        });
      }
      ngOnDestroy() {
        this._cleanupGlobalListener?.();
        this._cleanupGlobalListener = void 0;
        this.scrollContainers.forEach((_2, container) => this.deregister(container));
        this._scrolled.complete();
      }
      /**
       * Returns an observable that emits whenever any of the
       * scrollable ancestors of an element are scrolled.
       * @param elementOrElementRef Element whose ancestors to listen for.
       * @param auditTimeInMs Time to throttle the scroll events.
       */
      ancestorScrolled(elementOrElementRef, auditTimeInMs) {
        const ancestors = this.getAncestorScrollContainers(elementOrElementRef);
        return this.scrolled(auditTimeInMs).pipe(filter((target) => !target || ancestors.indexOf(target) > -1));
      }
      /** Returns all registered Scrollables that contain the provided element. */
      getAncestorScrollContainers(elementOrElementRef) {
        const scrollingContainers = [];
        this.scrollContainers.forEach((_subscription, scrollable) => {
          if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {
            scrollingContainers.push(scrollable);
          }
        });
        return scrollingContainers;
      }
      /** Returns true if the element is contained within the provided Scrollable. */
      _scrollableContainsElement(scrollable, elementOrElementRef) {
        let element = coerceElement(elementOrElementRef);
        let scrollableElement = scrollable.getElementRef().nativeElement;
        do {
          if (element == scrollableElement) {
            return true;
          }
        } while (element = element.parentElement);
        return false;
      }
      static \u0275fac = function ScrollDispatcher_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ScrollDispatcher)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _ScrollDispatcher,
        factory: _ScrollDispatcher.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollDispatcher, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [], null);
    })();
    CdkScrollable = class _CdkScrollable {
      elementRef = inject2(ElementRef);
      scrollDispatcher = inject2(ScrollDispatcher);
      ngZone = inject2(NgZone);
      dir = inject2(Directionality, {
        optional: true
      });
      _scrollElement = this.elementRef.nativeElement;
      _destroyed = new Subject();
      _renderer = inject2(Renderer2);
      _cleanupScroll;
      _elementScrolled = new Subject();
      constructor() {
      }
      ngOnInit() {
        this._cleanupScroll = this.ngZone.runOutsideAngular(() => this._renderer.listen(this._scrollElement, "scroll", (event) => this._elementScrolled.next(event)));
        this.scrollDispatcher.register(this);
      }
      ngOnDestroy() {
        this._cleanupScroll?.();
        this._elementScrolled.complete();
        this.scrollDispatcher.deregister(this);
        this._destroyed.next();
        this._destroyed.complete();
      }
      /** Returns observable that emits when a scroll event is fired on the host element. */
      elementScrolled() {
        return this._elementScrolled;
      }
      /** Gets the ElementRef for the viewport. */
      getElementRef() {
        return this.elementRef;
      }
      /**
       * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
       * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
       * left and right always refer to the left and right side of the scrolling container irrespective
       * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
       * in an RTL context.
       * @param options specified the offsets to scroll to.
       */
      scrollTo(options) {
        const el2 = this.elementRef.nativeElement;
        const isRtl = this.dir && this.dir.value == "rtl";
        if (options.left == null) {
          options.left = isRtl ? options.end : options.start;
        }
        if (options.right == null) {
          options.right = isRtl ? options.start : options.end;
        }
        if (options.bottom != null) {
          options.top = el2.scrollHeight - el2.clientHeight - options.bottom;
        }
        if (isRtl && getRtlScrollAxisType() != RtlScrollAxisType.NORMAL) {
          if (options.left != null) {
            options.right = el2.scrollWidth - el2.clientWidth - options.left;
          }
          if (getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
            options.left = options.right;
          } else if (getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
            options.left = options.right ? -options.right : options.right;
          }
        } else {
          if (options.right != null) {
            options.left = el2.scrollWidth - el2.clientWidth - options.right;
          }
        }
        this._applyScrollToOptions(options);
      }
      _applyScrollToOptions(options) {
        const el2 = this.elementRef.nativeElement;
        if (supportsScrollBehavior()) {
          el2.scrollTo(options);
        } else {
          if (options.top != null) {
            el2.scrollTop = options.top;
          }
          if (options.left != null) {
            el2.scrollLeft = options.left;
          }
        }
      }
      /**
       * Measures the scroll offset relative to the specified edge of the viewport. This method can be
       * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent
       * about what scrollLeft means in RTL. The values returned by this method are normalized such that
       * left and right always refer to the left and right side of the scrolling container irrespective
       * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
       * in an RTL context.
       * @param from The edge to measure from.
       */
      measureScrollOffset(from2) {
        const LEFT = "left";
        const RIGHT = "right";
        const el2 = this.elementRef.nativeElement;
        if (from2 == "top") {
          return el2.scrollTop;
        }
        if (from2 == "bottom") {
          return el2.scrollHeight - el2.clientHeight - el2.scrollTop;
        }
        const isRtl = this.dir && this.dir.value == "rtl";
        if (from2 == "start") {
          from2 = isRtl ? RIGHT : LEFT;
        } else if (from2 == "end") {
          from2 = isRtl ? LEFT : RIGHT;
        }
        if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
          if (from2 == LEFT) {
            return el2.scrollWidth - el2.clientWidth - el2.scrollLeft;
          } else {
            return el2.scrollLeft;
          }
        } else if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
          if (from2 == LEFT) {
            return el2.scrollLeft + el2.scrollWidth - el2.clientWidth;
          } else {
            return -el2.scrollLeft;
          }
        } else {
          if (from2 == LEFT) {
            return el2.scrollLeft;
          } else {
            return el2.scrollWidth - el2.clientWidth - el2.scrollLeft;
          }
        }
      }
      static \u0275fac = function CdkScrollable_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkScrollable)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkScrollable,
        selectors: [["", "cdk-scrollable", ""], ["", "cdkScrollable", ""]]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkScrollable, [{
        type: Directive,
        args: [{
          selector: "[cdk-scrollable], [cdkScrollable]"
        }]
      }], () => [], null);
    })();
    DEFAULT_RESIZE_TIME = 20;
    ViewportRuler = class _ViewportRuler {
      _platform = inject2(Platform);
      _listeners;
      /** Cached viewport dimensions. */
      _viewportSize;
      /** Stream of viewport change events. */
      _change = new Subject();
      /** Used to reference correct document/window */
      _document = inject2(DOCUMENT);
      constructor() {
        const ngZone = inject2(NgZone);
        const renderer = inject2(RendererFactory2).createRenderer(null, null);
        ngZone.runOutsideAngular(() => {
          if (this._platform.isBrowser) {
            const changeListener = (event) => this._change.next(event);
            this._listeners = [renderer.listen("window", "resize", changeListener), renderer.listen("window", "orientationchange", changeListener)];
          }
          this.change().subscribe(() => this._viewportSize = null);
        });
      }
      ngOnDestroy() {
        this._listeners?.forEach((cleanup) => cleanup());
        this._change.complete();
      }
      /** Returns the viewport's width and height. */
      getViewportSize() {
        if (!this._viewportSize) {
          this._updateViewportSize();
        }
        const output = {
          width: this._viewportSize.width,
          height: this._viewportSize.height
        };
        if (!this._platform.isBrowser) {
          this._viewportSize = null;
        }
        return output;
      }
      /** Gets a DOMRect for the viewport's bounds. */
      getViewportRect() {
        const scrollPosition = this.getViewportScrollPosition();
        const {
          width,
          height
        } = this.getViewportSize();
        return {
          top: scrollPosition.top,
          left: scrollPosition.left,
          bottom: scrollPosition.top + height,
          right: scrollPosition.left + width,
          height,
          width
        };
      }
      /** Gets the (top, left) scroll position of the viewport. */
      getViewportScrollPosition() {
        if (!this._platform.isBrowser) {
          return {
            top: 0,
            left: 0
          };
        }
        const document2 = this._document;
        const window2 = this._getWindow();
        const documentElement = document2.documentElement;
        const documentRect = documentElement.getBoundingClientRect();
        const top = -documentRect.top || document2.body.scrollTop || window2.scrollY || documentElement.scrollTop || 0;
        const left = -documentRect.left || document2.body.scrollLeft || window2.scrollX || documentElement.scrollLeft || 0;
        return {
          top,
          left
        };
      }
      /**
       * Returns a stream that emits whenever the size of the viewport changes.
       * This stream emits outside of the Angular zone.
       * @param throttleTime Time in milliseconds to throttle the stream.
       */
      change(throttleTime = DEFAULT_RESIZE_TIME) {
        return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;
      }
      /** Use defaultView of injected document if available or fallback to global window reference */
      _getWindow() {
        return this._document.defaultView || window;
      }
      /** Updates the cached viewport size. */
      _updateViewportSize() {
        const window2 = this._getWindow();
        this._viewportSize = this._platform.isBrowser ? {
          width: window2.innerWidth,
          height: window2.innerHeight
        } : {
          width: 0,
          height: 0
        };
      }
      static \u0275fac = function ViewportRuler_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ViewportRuler)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _ViewportRuler,
        factory: _ViewportRuler.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewportRuler, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [], null);
    })();
    VIRTUAL_SCROLLABLE = new InjectionToken("VIRTUAL_SCROLLABLE");
    CdkVirtualScrollable = class _CdkVirtualScrollable extends CdkScrollable {
      constructor() {
        super();
      }
      /**
       * Measure the viewport size for the provided orientation.
       *
       * @param orientation The orientation to measure the size from.
       */
      measureViewportSize(orientation) {
        const viewportEl = this.elementRef.nativeElement;
        return orientation === "horizontal" ? viewportEl.clientWidth : viewportEl.clientHeight;
      }
      static \u0275fac = function CdkVirtualScrollable_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkVirtualScrollable)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkVirtualScrollable,
        features: [\u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollable, [{
        type: Directive
      }], () => [], null);
    })();
    SCROLL_SCHEDULER = typeof requestAnimationFrame !== "undefined" ? animationFrameScheduler : asapScheduler;
    CdkVirtualScrollViewport = class _CdkVirtualScrollViewport extends CdkVirtualScrollable {
      elementRef = inject2(ElementRef);
      _changeDetectorRef = inject2(ChangeDetectorRef);
      _scrollStrategy = inject2(VIRTUAL_SCROLL_STRATEGY, {
        optional: true
      });
      scrollable = inject2(VIRTUAL_SCROLLABLE, {
        optional: true
      });
      _platform = inject2(Platform);
      /** Emits when the viewport is detached from a CdkVirtualForOf. */
      _detachedSubject = new Subject();
      /** Emits when the rendered range changes. */
      _renderedRangeSubject = new Subject();
      /** The direction the viewport scrolls. */
      get orientation() {
        return this._orientation;
      }
      set orientation(orientation) {
        if (this._orientation !== orientation) {
          this._orientation = orientation;
          this._calculateSpacerSize();
        }
      }
      _orientation = "vertical";
      /**
       * Whether rendered items should persist in the DOM after scrolling out of view. By default, items
       * will be removed.
       */
      appendOnly = false;
      // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll
      // strategy lazily (i.e. only if the user is actually listening to the events). We do this because
      // depending on how the strategy calculates the scrolled index, it may come at a cost to
      // performance.
      /** Emits when the index of the first element visible in the viewport changes. */
      scrolledIndexChange = new Observable((observer) => this._scrollStrategy.scrolledIndexChange.subscribe((index) => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));
      /** The element that wraps the rendered content. */
      _contentWrapper;
      /** A stream that emits whenever the rendered range changes. */
      renderedRangeStream = this._renderedRangeSubject;
      /**
       * The total size of all content (in pixels), including content that is not currently rendered.
       */
      _totalContentSize = 0;
      /** A string representing the `style.width` property value to be used for the spacer element. */
      _totalContentWidth = signal("", ...ngDevMode ? [{
        debugName: "_totalContentWidth"
      }] : []);
      /** A string representing the `style.height` property value to be used for the spacer element. */
      _totalContentHeight = signal("", ...ngDevMode ? [{
        debugName: "_totalContentHeight"
      }] : []);
      /**
       * The CSS transform applied to the rendered subset of items so that they appear within the bounds
       * of the visible viewport.
       */
      _renderedContentTransform;
      /** The currently rendered range of indices. */
      _renderedRange = {
        start: 0,
        end: 0
      };
      /** The length of the data bound to this viewport (in number of items). */
      _dataLength = 0;
      /** The size of the viewport (in pixels). */
      _viewportSize = 0;
      /** the currently attached CdkVirtualScrollRepeater. */
      _forOf;
      /** The last rendered content offset that was set. */
      _renderedContentOffset = 0;
      /**
       * Whether the last rendered content offset was to the end of the content (and therefore needs to
       * be rewritten as an offset to the start of the content).
       */
      _renderedContentOffsetNeedsRewrite = false;
      _changeDetectionNeeded = signal(false, ...ngDevMode ? [{
        debugName: "_changeDetectionNeeded"
      }] : []);
      /** A list of functions to run after the next change detection cycle. */
      _runAfterChangeDetection = [];
      /** Subscription to changes in the viewport size. */
      _viewportChanges = Subscription.EMPTY;
      _injector = inject2(Injector);
      _isDestroyed = false;
      constructor() {
        super();
        const viewportRuler = inject2(ViewportRuler);
        if (!this._scrollStrategy && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw Error('Error: cdk-virtual-scroll-viewport requires the "itemSize" property to be set.');
        }
        this._viewportChanges = viewportRuler.change().subscribe(() => {
          this.checkViewportSize();
        });
        if (!this.scrollable) {
          this.elementRef.nativeElement.classList.add("cdk-virtual-scrollable");
          this.scrollable = this;
        }
        const ref = effect(() => {
          if (this._changeDetectionNeeded()) {
            this._doChangeDetection();
          }
        }, ...ngDevMode ? [{
          debugName: "ref",
          injector: inject2(ApplicationRef).injector
        }] : [
          // Using ApplicationRef injector is important here because we want this to be a root
          // effect that runs before change detection of any application views (since we're depending on markForCheck marking parents dirty)
          {
            injector: inject2(ApplicationRef).injector
          }
        ]);
        inject2(DestroyRef).onDestroy(() => void ref.destroy());
      }
      ngOnInit() {
        if (!this._platform.isBrowser) {
          return;
        }
        if (this.scrollable === this) {
          super.ngOnInit();
        }
        this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {
          this._measureViewportSize();
          this._scrollStrategy.attach(this);
          this.scrollable.elementScrolled().pipe(
            // Start off with a fake scroll event so we properly detect our initial position.
            startWith(null),
            // Collect multiple events into one until the next animation frame. This way if
            // there are multiple scroll events in the same frame we only need to recheck
            // our layout once.
            auditTime(0, SCROLL_SCHEDULER),
            // Usually `elementScrolled` is completed when the scrollable is destroyed, but
            // that may not be the case if a `CdkVirtualScrollableElement` is used so we have
            // to unsubscribe here just in case.
            takeUntil(this._destroyed)
          ).subscribe(() => this._scrollStrategy.onContentScrolled());
          this._markChangeDetectionNeeded();
        }));
      }
      ngOnDestroy() {
        this.detach();
        this._scrollStrategy.detach();
        this._renderedRangeSubject.complete();
        this._detachedSubject.complete();
        this._viewportChanges.unsubscribe();
        this._isDestroyed = true;
        super.ngOnDestroy();
      }
      /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */
      attach(forOf) {
        if (this._forOf && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw Error("CdkVirtualScrollViewport is already attached.");
        }
        this.ngZone.runOutsideAngular(() => {
          this._forOf = forOf;
          this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe((data) => {
            const newLength = data.length;
            if (newLength !== this._dataLength) {
              this._dataLength = newLength;
              this._scrollStrategy.onDataLengthChanged();
            }
            this._doChangeDetection();
          });
        });
      }
      /** Detaches the current `CdkVirtualForOf`. */
      detach() {
        this._forOf = null;
        this._detachedSubject.next();
      }
      /** Gets the length of the data bound to this viewport (in number of items). */
      getDataLength() {
        return this._dataLength;
      }
      /** Gets the size of the viewport (in pixels). */
      getViewportSize() {
        return this._viewportSize;
      }
      // TODO(mmalerba): This is technically out of sync with what's really rendered until a render
      // cycle happens. I'm being careful to only call it after the render cycle is complete and before
      // setting it to something else, but its error prone and should probably be split into
      // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.
      /** Get the current rendered range of items. */
      getRenderedRange() {
        return this._renderedRange;
      }
      measureBoundingClientRectWithScrollOffset(from2) {
        return this.getElementRef().nativeElement.getBoundingClientRect()[from2];
      }
      /**
       * Sets the total size of all content (in pixels), including content that is not currently
       * rendered.
       */
      setTotalContentSize(size) {
        if (this._totalContentSize !== size) {
          this._totalContentSize = size;
          this._calculateSpacerSize();
          this._markChangeDetectionNeeded();
        }
      }
      /** Sets the currently rendered range of indices. */
      setRenderedRange(range2) {
        if (!rangesEqual(this._renderedRange, range2)) {
          if (this.appendOnly) {
            range2 = {
              start: 0,
              end: Math.max(this._renderedRange.end, range2.end)
            };
          }
          this._renderedRangeSubject.next(this._renderedRange = range2);
          this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());
        }
      }
      /**
       * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).
       */
      getOffsetToRenderedContentStart() {
        return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;
      }
      /**
       * Sets the offset from the start of the viewport to either the start or end of the rendered data
       * (in pixels).
       */
      setRenderedContentOffset(offset, to2 = "to-start") {
        offset = this.appendOnly && to2 === "to-start" ? 0 : offset;
        const isRtl = this.dir && this.dir.value == "rtl";
        const isHorizontal = this.orientation == "horizontal";
        const axis = isHorizontal ? "X" : "Y";
        const axisDirection = isHorizontal && isRtl ? -1 : 1;
        let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;
        this._renderedContentOffset = offset;
        if (to2 === "to-end") {
          transform += ` translate${axis}(-100%)`;
          this._renderedContentOffsetNeedsRewrite = true;
        }
        if (this._renderedContentTransform != transform) {
          this._renderedContentTransform = transform;
          this._markChangeDetectionNeeded(() => {
            if (this._renderedContentOffsetNeedsRewrite) {
              this._renderedContentOffset -= this.measureRenderedContentSize();
              this._renderedContentOffsetNeedsRewrite = false;
              this.setRenderedContentOffset(this._renderedContentOffset);
            } else {
              this._scrollStrategy.onRenderedOffsetChanged();
            }
          });
        }
      }
      /**
       * Scrolls to the given offset from the start of the viewport. Please note that this is not always
       * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left
       * direction, this would be the equivalent of setting a fictional `scrollRight` property.
       * @param offset The offset to scroll to.
       * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
       */
      scrollToOffset(offset, behavior = "auto") {
        const options = {
          behavior
        };
        if (this.orientation === "horizontal") {
          options.start = offset;
        } else {
          options.top = offset;
        }
        this.scrollable.scrollTo(options);
      }
      /**
       * Scrolls to the offset for the given index.
       * @param index The index of the element to scroll to.
       * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
       */
      scrollToIndex(index, behavior = "auto") {
        this._scrollStrategy.scrollToIndex(index, behavior);
      }
      /**
       * Gets the current scroll offset from the start of the scrollable (in pixels).
       * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'
       *     in horizontal mode.
       */
      measureScrollOffset(from2) {
        let measureScrollOffset;
        if (this.scrollable == this) {
          measureScrollOffset = (_from) => super.measureScrollOffset(_from);
        } else {
          measureScrollOffset = (_from) => this.scrollable.measureScrollOffset(_from);
        }
        return Math.max(0, measureScrollOffset(from2 ?? (this.orientation === "horizontal" ? "start" : "top")) - this.measureViewportOffset());
      }
      /**
       * Measures the offset of the viewport from the scrolling container
       * @param from The edge to measure from.
       */
      measureViewportOffset(from2) {
        let fromRect;
        const LEFT = "left";
        const RIGHT = "right";
        const isRtl = this.dir?.value == "rtl";
        if (from2 == "start") {
          fromRect = isRtl ? RIGHT : LEFT;
        } else if (from2 == "end") {
          fromRect = isRtl ? LEFT : RIGHT;
        } else if (from2) {
          fromRect = from2;
        } else {
          fromRect = this.orientation === "horizontal" ? "left" : "top";
        }
        const scrollerClientRect = this.scrollable.measureBoundingClientRectWithScrollOffset(fromRect);
        const viewportClientRect = this.elementRef.nativeElement.getBoundingClientRect()[fromRect];
        return viewportClientRect - scrollerClientRect;
      }
      /** Measure the combined size of all of the rendered items. */
      measureRenderedContentSize() {
        const contentEl = this._contentWrapper.nativeElement;
        return this.orientation === "horizontal" ? contentEl.offsetWidth : contentEl.offsetHeight;
      }
      /**
       * Measure the total combined size of the given range. Throws if the range includes items that are
       * not rendered.
       */
      measureRangeSize(range2) {
        if (!this._forOf) {
          return 0;
        }
        return this._forOf.measureRangeSize(range2, this.orientation);
      }
      /** Update the viewport dimensions and re-render. */
      checkViewportSize() {
        this._measureViewportSize();
        this._scrollStrategy.onDataLengthChanged();
      }
      /** Measure the viewport size. */
      _measureViewportSize() {
        this._viewportSize = this.scrollable.measureViewportSize(this.orientation);
      }
      /** Queue up change detection to run. */
      _markChangeDetectionNeeded(runAfter) {
        if (runAfter) {
          this._runAfterChangeDetection.push(runAfter);
        }
        if (untracked2(this._changeDetectionNeeded)) {
          return;
        }
        this.ngZone.runOutsideAngular(() => {
          Promise.resolve().then(() => {
            this.ngZone.run(() => {
              this._changeDetectionNeeded.set(true);
            });
          });
        });
      }
      /** Run change detection. */
      _doChangeDetection() {
        if (this._isDestroyed) {
          return;
        }
        this.ngZone.run(() => {
          this._changeDetectorRef.markForCheck();
          this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;
          afterNextRender(() => {
            this._changeDetectionNeeded.set(false);
            const runAfterChangeDetection = this._runAfterChangeDetection;
            this._runAfterChangeDetection = [];
            for (const fn of runAfterChangeDetection) {
              fn();
            }
          }, {
            injector: this._injector
          });
        });
      }
      /** Calculates the `style.width` and `style.height` for the spacer element. */
      _calculateSpacerSize() {
        this._totalContentHeight.set(this.orientation === "horizontal" ? "" : `${this._totalContentSize}px`);
        this._totalContentWidth.set(this.orientation === "horizontal" ? `${this._totalContentSize}px` : "");
      }
      static \u0275fac = function CdkVirtualScrollViewport_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkVirtualScrollViewport)();
      };
      static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
        type: _CdkVirtualScrollViewport,
        selectors: [["cdk-virtual-scroll-viewport"]],
        viewQuery: function CdkVirtualScrollViewport_Query(rf2, ctx) {
          if (rf2 & 1) {
            \u0275\u0275viewQuery(_c0, 7);
          }
          if (rf2 & 2) {
            let _t2;
            \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx._contentWrapper = _t2.first);
          }
        },
        hostAttrs: [1, "cdk-virtual-scroll-viewport"],
        hostVars: 4,
        hostBindings: function CdkVirtualScrollViewport_HostBindings(rf2, ctx) {
          if (rf2 & 2) {
            \u0275\u0275classProp("cdk-virtual-scroll-orientation-horizontal", ctx.orientation === "horizontal")("cdk-virtual-scroll-orientation-vertical", ctx.orientation !== "horizontal");
          }
        },
        inputs: {
          orientation: "orientation",
          appendOnly: [2, "appendOnly", "appendOnly", booleanAttribute]
        },
        outputs: {
          scrolledIndexChange: "scrolledIndexChange"
        },
        features: [\u0275\u0275ProvidersFeature([{
          provide: CdkScrollable,
          useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,
          deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], _CdkVirtualScrollViewport]
        }]), \u0275\u0275InheritDefinitionFeature],
        ngContentSelectors: _c1,
        decls: 4,
        vars: 4,
        consts: [["contentWrapper", ""], [1, "cdk-virtual-scroll-content-wrapper"], [1, "cdk-virtual-scroll-spacer"]],
        template: function CdkVirtualScrollViewport_Template(rf2, ctx) {
          if (rf2 & 1) {
            \u0275\u0275projectionDef();
            \u0275\u0275domElementStart(0, "div", 1, 0);
            \u0275\u0275projection(2);
            \u0275\u0275domElementEnd();
            \u0275\u0275domElement(3, "div", 2);
          }
          if (rf2 & 2) {
            \u0275\u0275advance(3);
            \u0275\u0275styleProp("width", ctx._totalContentWidth())("height", ctx._totalContentHeight());
          }
        },
        styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}\n"],
        encapsulation: 2,
        changeDetection: 0
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollViewport, [{
        type: Component,
        args: [{
          selector: "cdk-virtual-scroll-viewport",
          host: {
            "class": "cdk-virtual-scroll-viewport",
            "[class.cdk-virtual-scroll-orientation-horizontal]": 'orientation === "horizontal"',
            "[class.cdk-virtual-scroll-orientation-vertical]": 'orientation !== "horizontal"'
          },
          encapsulation: ViewEncapsulation.None,
          changeDetection: ChangeDetectionStrategy.OnPush,
          providers: [{
            provide: CdkScrollable,
            useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,
            deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], CdkVirtualScrollViewport]
          }],
          template: '<!--\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\n  position.\n-->\n<div #contentWrapper class="cdk-virtual-scroll-content-wrapper">\n  <ng-content></ng-content>\n</div>\n<!--\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\n  so that the scrollbar captures the size of the entire data set.\n-->\n<div class="cdk-virtual-scroll-spacer"\n     [style.width]="_totalContentWidth()" [style.height]="_totalContentHeight()"></div>\n',
          styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}\n"]
        }]
      }], () => [], {
        orientation: [{
          type: Input
        }],
        appendOnly: [{
          type: Input,
          args: [{
            transform: booleanAttribute
          }]
        }],
        scrolledIndexChange: [{
          type: Output
        }],
        _contentWrapper: [{
          type: ViewChild,
          args: ["contentWrapper", {
            static: true
          }]
        }]
      });
    })();
    CdkVirtualForOf = class _CdkVirtualForOf {
      _viewContainerRef = inject2(ViewContainerRef);
      _template = inject2(TemplateRef);
      _differs = inject2(IterableDiffers);
      _viewRepeater = inject2(_VIEW_REPEATER_STRATEGY);
      _viewport = inject2(CdkVirtualScrollViewport, {
        skipSelf: true
      });
      /** Emits when the rendered view of the data changes. */
      viewChange = new Subject();
      /** Subject that emits when a new DataSource instance is given. */
      _dataSourceChanges = new Subject();
      /** The DataSource to display. */
      get cdkVirtualForOf() {
        return this._cdkVirtualForOf;
      }
      set cdkVirtualForOf(value) {
        this._cdkVirtualForOf = value;
        if (isDataSource(value)) {
          this._dataSourceChanges.next(value);
        } else {
          this._dataSourceChanges.next(new ArrayDataSource(isObservable(value) ? value : Array.from(value || [])));
        }
      }
      _cdkVirtualForOf;
      /**
       * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and
       * the item and produces a value to be used as the item's identity when tracking changes.
       */
      get cdkVirtualForTrackBy() {
        return this._cdkVirtualForTrackBy;
      }
      set cdkVirtualForTrackBy(fn) {
        this._needsUpdate = true;
        this._cdkVirtualForTrackBy = fn ? (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item) : void 0;
      }
      _cdkVirtualForTrackBy;
      /** The template used to stamp out new elements. */
      set cdkVirtualForTemplate(value) {
        if (value) {
          this._needsUpdate = true;
          this._template = value;
        }
      }
      /**
       * The size of the cache used to store templates that are not being used for re-use later.
       * Setting the cache size to `0` will disable caching. Defaults to 20 templates.
       */
      get cdkVirtualForTemplateCacheSize() {
        return this._viewRepeater.viewCacheSize;
      }
      set cdkVirtualForTemplateCacheSize(size) {
        this._viewRepeater.viewCacheSize = coerceNumberProperty(size);
      }
      /** Emits whenever the data in the current DataSource changes. */
      dataStream = this._dataSourceChanges.pipe(
        // Start off with null `DataSource`.
        startWith(null),
        // Bundle up the previous and current data sources so we can work with both.
        pairwise(),
        // Use `_changeDataSource` to disconnect from the previous data source and connect to the
        // new one, passing back a stream of data changes which we run through `switchMap` to give
        // us a data stream that emits the latest data from whatever the current `DataSource` is.
        switchMap(([prev, cur]) => this._changeDataSource(prev, cur)),
        // Replay the last emitted data when someone subscribes.
        shareReplay(1)
      );
      /** The differ used to calculate changes to the data. */
      _differ = null;
      /** The most recent data emitted from the DataSource. */
      _data;
      /** The currently rendered items. */
      _renderedItems;
      /** The currently rendered range of indices. */
      _renderedRange;
      /** Whether the rendered data should be updated during the next ngDoCheck cycle. */
      _needsUpdate = false;
      _destroyed = new Subject();
      constructor() {
        const ngZone = inject2(NgZone);
        this.dataStream.subscribe((data) => {
          this._data = data;
          this._onRenderedDataChange();
        });
        this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe((range2) => {
          this._renderedRange = range2;
          if (this.viewChange.observers.length) {
            ngZone.run(() => this.viewChange.next(this._renderedRange));
          }
          this._onRenderedDataChange();
        });
        this._viewport.attach(this);
      }
      /**
       * Measures the combined size (width for horizontal orientation, height for vertical) of all items
       * in the specified range. Throws an error if the range includes items that are not currently
       * rendered.
       */
      measureRangeSize(range2, orientation) {
        if (range2.start >= range2.end) {
          return 0;
        }
        if ((range2.start < this._renderedRange.start || range2.end > this._renderedRange.end) && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw Error(`Error: attempted to measure an item that isn't rendered.`);
        }
        const renderedStartIndex = range2.start - this._renderedRange.start;
        const rangeLen = range2.end - range2.start;
        let firstNode;
        let lastNode;
        for (let i2 = 0; i2 < rangeLen; i2++) {
          const view = this._viewContainerRef.get(i2 + renderedStartIndex);
          if (view && view.rootNodes.length) {
            firstNode = lastNode = view.rootNodes[0];
            break;
          }
        }
        for (let i2 = rangeLen - 1; i2 > -1; i2--) {
          const view = this._viewContainerRef.get(i2 + renderedStartIndex);
          if (view && view.rootNodes.length) {
            lastNode = view.rootNodes[view.rootNodes.length - 1];
            break;
          }
        }
        return firstNode && lastNode ? getOffset(orientation, "end", lastNode) - getOffset(orientation, "start", firstNode) : 0;
      }
      ngDoCheck() {
        if (this._differ && this._needsUpdate) {
          const changes = this._differ.diff(this._renderedItems);
          if (!changes) {
            this._updateContext();
          } else {
            this._applyChanges(changes);
          }
          this._needsUpdate = false;
        }
      }
      ngOnDestroy() {
        this._viewport.detach();
        this._dataSourceChanges.next(void 0);
        this._dataSourceChanges.complete();
        this.viewChange.complete();
        this._destroyed.next();
        this._destroyed.complete();
        this._viewRepeater.detach();
      }
      /** React to scroll state changes in the viewport. */
      _onRenderedDataChange() {
        if (!this._renderedRange) {
          return;
        }
        this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);
        if (!this._differ) {
          this._differ = this._differs.find(this._renderedItems).create((index, item) => {
            return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;
          });
        }
        this._needsUpdate = true;
      }
      /** Swap out one `DataSource` for another. */
      _changeDataSource(oldDs, newDs) {
        if (oldDs) {
          oldDs.disconnect(this);
        }
        this._needsUpdate = true;
        return newDs ? newDs.connect(this) : of();
      }
      /** Update the `CdkVirtualForOfContext` for all views. */
      _updateContext() {
        const count = this._data.length;
        let i2 = this._viewContainerRef.length;
        while (i2--) {
          const view = this._viewContainerRef.get(i2);
          view.context.index = this._renderedRange.start + i2;
          view.context.count = count;
          this._updateComputedContextProperties(view.context);
          view.detectChanges();
        }
      }
      /** Apply changes to the DOM. */
      _applyChanges(changes) {
        this._viewRepeater.applyChanges(changes, this._viewContainerRef, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record, currentIndex), (record) => record.item);
        changes.forEachIdentityChange((record) => {
          const view = this._viewContainerRef.get(record.currentIndex);
          view.context.$implicit = record.item;
        });
        const count = this._data.length;
        let i2 = this._viewContainerRef.length;
        while (i2--) {
          const view = this._viewContainerRef.get(i2);
          view.context.index = this._renderedRange.start + i2;
          view.context.count = count;
          this._updateComputedContextProperties(view.context);
        }
      }
      /** Update the computed properties on the `CdkVirtualForOfContext`. */
      _updateComputedContextProperties(context2) {
        context2.first = context2.index === 0;
        context2.last = context2.index === context2.count - 1;
        context2.even = context2.index % 2 === 0;
        context2.odd = !context2.even;
      }
      _getEmbeddedViewArgs(record, index) {
        return {
          templateRef: this._template,
          context: {
            $implicit: record.item,
            // It's guaranteed that the iterable is not "undefined" or "null" because we only
            // generate views for elements if the "cdkVirtualForOf" iterable has elements.
            cdkVirtualForOf: this._cdkVirtualForOf,
            index: -1,
            count: -1,
            first: false,
            last: false,
            odd: false,
            even: false
          },
          index
        };
      }
      static ngTemplateContextGuard(directive, context2) {
        return true;
      }
      static \u0275fac = function CdkVirtualForOf_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkVirtualForOf)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkVirtualForOf,
        selectors: [["", "cdkVirtualFor", "", "cdkVirtualForOf", ""]],
        inputs: {
          cdkVirtualForOf: "cdkVirtualForOf",
          cdkVirtualForTrackBy: "cdkVirtualForTrackBy",
          cdkVirtualForTemplate: "cdkVirtualForTemplate",
          cdkVirtualForTemplateCacheSize: "cdkVirtualForTemplateCacheSize"
        },
        features: [\u0275\u0275ProvidersFeature([{
          provide: _VIEW_REPEATER_STRATEGY,
          useClass: _RecycleViewRepeaterStrategy
        }])]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualForOf, [{
        type: Directive,
        args: [{
          selector: "[cdkVirtualFor][cdkVirtualForOf]",
          providers: [{
            provide: _VIEW_REPEATER_STRATEGY,
            useClass: _RecycleViewRepeaterStrategy
          }]
        }]
      }], () => [], {
        cdkVirtualForOf: [{
          type: Input
        }],
        cdkVirtualForTrackBy: [{
          type: Input
        }],
        cdkVirtualForTemplate: [{
          type: Input
        }],
        cdkVirtualForTemplateCacheSize: [{
          type: Input
        }]
      });
    })();
    CdkVirtualScrollableElement = class _CdkVirtualScrollableElement extends CdkVirtualScrollable {
      constructor() {
        super();
      }
      measureBoundingClientRectWithScrollOffset(from2) {
        return this.getElementRef().nativeElement.getBoundingClientRect()[from2] - this.measureScrollOffset(from2);
      }
      static \u0275fac = function CdkVirtualScrollableElement_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkVirtualScrollableElement)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkVirtualScrollableElement,
        selectors: [["", "cdkVirtualScrollingElement", ""]],
        hostAttrs: [1, "cdk-virtual-scrollable"],
        features: [\u0275\u0275ProvidersFeature([{
          provide: VIRTUAL_SCROLLABLE,
          useExisting: _CdkVirtualScrollableElement
        }]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollableElement, [{
        type: Directive,
        args: [{
          selector: "[cdkVirtualScrollingElement]",
          providers: [{
            provide: VIRTUAL_SCROLLABLE,
            useExisting: CdkVirtualScrollableElement
          }],
          host: {
            "class": "cdk-virtual-scrollable"
          }
        }]
      }], () => [], null);
    })();
    CdkVirtualScrollableWindow = class _CdkVirtualScrollableWindow extends CdkVirtualScrollable {
      constructor() {
        super();
        const document2 = inject2(DOCUMENT);
        this.elementRef = new ElementRef(document2.documentElement);
        this._scrollElement = document2;
      }
      measureBoundingClientRectWithScrollOffset(from2) {
        return this.getElementRef().nativeElement.getBoundingClientRect()[from2];
      }
      static \u0275fac = function CdkVirtualScrollableWindow_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkVirtualScrollableWindow)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkVirtualScrollableWindow,
        selectors: [["cdk-virtual-scroll-viewport", "scrollWindow", ""]],
        features: [\u0275\u0275ProvidersFeature([{
          provide: VIRTUAL_SCROLLABLE,
          useExisting: _CdkVirtualScrollableWindow
        }]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollableWindow, [{
        type: Directive,
        args: [{
          selector: "cdk-virtual-scroll-viewport[scrollWindow]",
          providers: [{
            provide: VIRTUAL_SCROLLABLE,
            useExisting: CdkVirtualScrollableWindow
          }]
        }]
      }], () => [], null);
    })();
    CdkScrollableModule = class _CdkScrollableModule {
      static \u0275fac = function CdkScrollableModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkScrollableModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _CdkScrollableModule,
        imports: [CdkScrollable],
        exports: [CdkScrollable]
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkScrollableModule, [{
        type: NgModule,
        args: [{
          exports: [CdkScrollable],
          imports: [CdkScrollable]
        }]
      }], null, null);
    })();
    ScrollingModule = class _ScrollingModule {
      static \u0275fac = function ScrollingModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ScrollingModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _ScrollingModule,
        imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],
        exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
        imports: [BidiModule, CdkScrollableModule, BidiModule, CdkScrollableModule]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollingModule, [{
        type: NgModule,
        args: [{
          imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],
          exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]
        }]
      }], null, null);
    })();
  }
});

// node_modules/@angular/cdk/fesm2022/id-generator.mjs
var counters, _IdGenerator;
var init_id_generator = __esm({
  "node_modules/@angular/cdk/fesm2022/id-generator.mjs"() {
    "use strict";
    init_core();
    init_core();
    counters = {};
    _IdGenerator = class __IdGenerator {
      _appId = inject2(APP_ID);
      /**
       * Generates a unique ID with a specific prefix.
       * @param prefix Prefix to add to the ID.
       */
      getId(prefix) {
        if (this._appId !== "ng") {
          prefix += this._appId;
        }
        if (!counters.hasOwnProperty(prefix)) {
          counters[prefix] = 0;
        }
        return `${prefix}${counters[prefix]++}`;
      }
      static \u0275fac = function _IdGenerator_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || __IdGenerator)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: __IdGenerator,
        factory: __IdGenerator.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_IdGenerator, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
  }
});

// node_modules/@angular/cdk/fesm2022/array.mjs
function coerceArray(value) {
  return Array.isArray(value) ? value : [value];
}
var init_array = __esm({
  "node_modules/@angular/cdk/fesm2022/array.mjs"() {
    "use strict";
  }
});

// node_modules/@angular/cdk/fesm2022/drag-drop.mjs
function deepCloneNode(node) {
  const clone = node.cloneNode(true);
  const descendantsWithId = clone.querySelectorAll("[id]");
  const nodeName = node.nodeName.toLowerCase();
  clone.removeAttribute("id");
  for (let i2 = 0; i2 < descendantsWithId.length; i2++) {
    descendantsWithId[i2].removeAttribute("id");
  }
  if (nodeName === "canvas") {
    transferCanvasData(node, clone);
  } else if (nodeName === "input" || nodeName === "select" || nodeName === "textarea") {
    transferInputData(node, clone);
  }
  transferData("canvas", node, clone, transferCanvasData);
  transferData("input, textarea, select", node, clone, transferInputData);
  return clone;
}
function transferData(selector, node, clone, callback) {
  const descendantElements = node.querySelectorAll(selector);
  if (descendantElements.length) {
    const cloneElements = clone.querySelectorAll(selector);
    for (let i2 = 0; i2 < descendantElements.length; i2++) {
      callback(descendantElements[i2], cloneElements[i2]);
    }
  }
}
function transferInputData(source, clone) {
  if (clone.type !== "file") {
    clone.value = source.value;
  }
  if (clone.type === "radio" && clone.name) {
    clone.name = `mat-clone-${clone.name}-${cloneUniqueId++}`;
  }
}
function transferCanvasData(source, clone) {
  const context2 = clone.getContext("2d");
  if (context2) {
    try {
      context2.drawImage(source, 0, 0);
    } catch {
    }
  }
}
function getMutableClientRect(element) {
  const rect = element.getBoundingClientRect();
  return {
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    width: rect.width,
    height: rect.height,
    x: rect.x,
    y: rect.y
  };
}
function isInsideClientRect(clientRect, x2, y2) {
  const {
    top,
    bottom,
    left,
    right
  } = clientRect;
  return y2 >= top && y2 <= bottom && x2 >= left && x2 <= right;
}
function isOverflowingParent(parentRect, childRect) {
  const isLeftOverflowing = childRect.left < parentRect.left;
  const isRightOverflowing = childRect.left + childRect.width > parentRect.right;
  const isTopOverflowing = childRect.top < parentRect.top;
  const isBottomOverflowing = childRect.top + childRect.height > parentRect.bottom;
  return isLeftOverflowing || isRightOverflowing || isTopOverflowing || isBottomOverflowing;
}
function adjustDomRect(domRect, top, left) {
  domRect.top += top;
  domRect.bottom = domRect.top + domRect.height;
  domRect.left += left;
  domRect.right = domRect.left + domRect.width;
}
function isPointerNearDomRect(rect, threshold, pointerX, pointerY) {
  const {
    top,
    right,
    bottom,
    left,
    width,
    height
  } = rect;
  const xThreshold = width * threshold;
  const yThreshold = height * threshold;
  return pointerY > top - yThreshold && pointerY < bottom + yThreshold && pointerX > left - xThreshold && pointerX < right + xThreshold;
}
function getRootNode(viewRef, _document2) {
  const rootNodes = viewRef.rootNodes;
  if (rootNodes.length === 1 && rootNodes[0].nodeType === _document2.ELEMENT_NODE) {
    return rootNodes[0];
  }
  const wrapper = _document2.createElement("div");
  rootNodes.forEach((node) => wrapper.appendChild(node));
  return wrapper;
}
function extendStyles(dest, source, importantProperties2) {
  for (let key in source) {
    if (source.hasOwnProperty(key)) {
      const value = source[key];
      if (value) {
        dest.setProperty(key, value, importantProperties2?.has(key) ? "important" : "");
      } else {
        dest.removeProperty(key);
      }
    }
  }
  return dest;
}
function toggleNativeDragInteractions(element, enable) {
  const userSelect = enable ? "" : "none";
  extendStyles(element.style, {
    "touch-action": enable ? "" : "none",
    "-webkit-user-drag": enable ? "" : "none",
    "-webkit-tap-highlight-color": enable ? "" : "transparent",
    "user-select": userSelect,
    "-ms-user-select": userSelect,
    "-webkit-user-select": userSelect,
    "-moz-user-select": userSelect
  });
}
function toggleVisibility(element, enable, importantProperties2) {
  extendStyles(element.style, {
    position: enable ? "" : "fixed",
    top: enable ? "" : "0",
    opacity: enable ? "" : "0",
    left: enable ? "" : "-999em"
  }, importantProperties2);
}
function combineTransforms(transform, initialTransform) {
  return initialTransform && initialTransform != "none" ? transform + " " + initialTransform : transform;
}
function matchElementSize(target, sourceRect) {
  target.style.width = `${sourceRect.width}px`;
  target.style.height = `${sourceRect.height}px`;
  target.style.transform = getTransform(sourceRect.left, sourceRect.top);
}
function getTransform(x2, y2) {
  return `translate3d(${Math.round(x2)}px, ${Math.round(y2)}px, 0)`;
}
function parseCssTimeUnitsToMs(value) {
  const multiplier = value.toLowerCase().indexOf("ms") > -1 ? 1 : 1e3;
  return parseFloat(value) * multiplier;
}
function getTransformTransitionDurationInMs(element) {
  const computedStyle = getComputedStyle(element);
  const transitionedProperties = parseCssPropertyValue(computedStyle, "transition-property");
  const property = transitionedProperties.find((prop) => prop === "transform" || prop === "all");
  if (!property) {
    return 0;
  }
  const propertyIndex = transitionedProperties.indexOf(property);
  const rawDurations = parseCssPropertyValue(computedStyle, "transition-duration");
  const rawDelays = parseCssPropertyValue(computedStyle, "transition-delay");
  return parseCssTimeUnitsToMs(rawDurations[propertyIndex]) + parseCssTimeUnitsToMs(rawDelays[propertyIndex]);
}
function parseCssPropertyValue(computedStyle, name) {
  const value = computedStyle.getPropertyValue(name);
  return value.split(",").map((part) => part.trim());
}
function supportsPopover(element) {
  return "showPopover" in element;
}
function clamp$1(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function isTouchEvent(event) {
  return event.type[0] === "t";
}
function shadowDomSelectStart(event) {
  event.preventDefault();
}
function moveItemInArray(array, fromIndex, toIndex) {
  const from2 = clamp(fromIndex, array.length - 1);
  const to2 = clamp(toIndex, array.length - 1);
  if (from2 === to2) {
    return;
  }
  const target = array[from2];
  const delta = to2 < from2 ? -1 : 1;
  for (let i2 = from2; i2 !== to2; i2 += delta) {
    array[i2] = array[i2 + delta];
  }
  array[to2] = target;
}
function clamp(value, max) {
  return Math.max(0, Math.min(max, value));
}
function getVerticalScrollDirection(clientRect, pointerY) {
  const {
    top,
    bottom,
    height
  } = clientRect;
  const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;
  if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {
    return AutoScrollVerticalDirection.UP;
  } else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {
    return AutoScrollVerticalDirection.DOWN;
  }
  return AutoScrollVerticalDirection.NONE;
}
function getHorizontalScrollDirection(clientRect, pointerX) {
  const {
    left,
    right,
    width
  } = clientRect;
  const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;
  if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {
    return AutoScrollHorizontalDirection.LEFT;
  } else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {
    return AutoScrollHorizontalDirection.RIGHT;
  }
  return AutoScrollHorizontalDirection.NONE;
}
function getElementScrollDirections(element, clientRect, direction, pointerX, pointerY) {
  const computedVertical = getVerticalScrollDirection(clientRect, pointerY);
  const computedHorizontal = getHorizontalScrollDirection(clientRect, pointerX);
  let verticalScrollDirection = AutoScrollVerticalDirection.NONE;
  let horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
  if (computedVertical) {
    const scrollTop = element.scrollTop;
    if (computedVertical === AutoScrollVerticalDirection.UP) {
      if (scrollTop > 0) {
        verticalScrollDirection = AutoScrollVerticalDirection.UP;
      }
    } else if (element.scrollHeight - scrollTop > element.clientHeight) {
      verticalScrollDirection = AutoScrollVerticalDirection.DOWN;
    }
  }
  if (computedHorizontal) {
    const scrollLeft = element.scrollLeft;
    if (direction === "rtl") {
      if (computedHorizontal === AutoScrollHorizontalDirection.RIGHT) {
        if (scrollLeft < 0) {
          horizontalScrollDirection = AutoScrollHorizontalDirection.RIGHT;
        }
      } else if (element.scrollWidth + scrollLeft > element.clientWidth) {
        horizontalScrollDirection = AutoScrollHorizontalDirection.LEFT;
      }
    } else {
      if (computedHorizontal === AutoScrollHorizontalDirection.LEFT) {
        if (scrollLeft > 0) {
          horizontalScrollDirection = AutoScrollHorizontalDirection.LEFT;
        }
      } else if (element.scrollWidth - scrollLeft > element.clientWidth) {
        horizontalScrollDirection = AutoScrollHorizontalDirection.RIGHT;
      }
    }
  }
  return [verticalScrollDirection, horizontalScrollDirection];
}
function assertElementNode(node, name) {
  if (node.nodeType !== 1) {
    throw Error(`${name} must be attached to an element node. Currently attached to "${node.nodeName}".`);
  }
}
var cloneUniqueId, ParentPositionTracker, importantProperties, PreviewRef, passiveEventListenerOptions, activeEventListenerOptions, activeCapturingEventOptions$1, MOUSE_EVENT_IGNORE_TIME, PLACEHOLDER_CLASS, dragImportantProperties, DragRef, SingleAxisSortStrategy, MixedSortStrategy, DROP_PROXIMITY_THRESHOLD, SCROLL_PROXIMITY_THRESHOLD, AutoScrollVerticalDirection, AutoScrollHorizontalDirection, DropListRef, capturingEventOptions, activeCapturingEventOptions, _ResetsLoader, DragDropRegistry, DEFAULT_CONFIG, DragDrop, CDK_DRAG_PARENT, CDK_DRAG_HANDLE, CdkDragHandle, CDK_DRAG_CONFIG, CDK_DROP_LIST, CdkDrag, CDK_DROP_LIST_GROUP, CdkDropListGroup, CdkDropList, CDK_DRAG_PREVIEW, CdkDragPreview, CDK_DRAG_PLACEHOLDER, CdkDragPlaceholder, DRAG_DROP_DIRECTIVES, DragDropModule;
var init_drag_drop = __esm({
  "node_modules/@angular/cdk/fesm2022/drag-drop.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_esm();
    init_shadow_dom();
    init_fake_event_detection();
    init_element();
    init_operators();
    init_style_loader();
    init_scrolling();
    init_directionality();
    init_id_generator();
    init_array();
    cloneUniqueId = 0;
    ParentPositionTracker = class {
      _document;
      /** Cached positions of the scrollable parent elements. */
      positions = /* @__PURE__ */ new Map();
      constructor(_document2) {
        this._document = _document2;
      }
      /** Clears the cached positions. */
      clear() {
        this.positions.clear();
      }
      /** Caches the positions. Should be called at the beginning of a drag sequence. */
      cache(elements) {
        this.clear();
        this.positions.set(this._document, {
          scrollPosition: this.getViewportScrollPosition()
        });
        elements.forEach((element) => {
          this.positions.set(element, {
            scrollPosition: {
              top: element.scrollTop,
              left: element.scrollLeft
            },
            clientRect: getMutableClientRect(element)
          });
        });
      }
      /** Handles scrolling while a drag is taking place. */
      handleScroll(event) {
        const target = _getEventTarget(event);
        const cachedPosition = this.positions.get(target);
        if (!cachedPosition) {
          return null;
        }
        const scrollPosition = cachedPosition.scrollPosition;
        let newTop;
        let newLeft;
        if (target === this._document) {
          const viewportScrollPosition = this.getViewportScrollPosition();
          newTop = viewportScrollPosition.top;
          newLeft = viewportScrollPosition.left;
        } else {
          newTop = target.scrollTop;
          newLeft = target.scrollLeft;
        }
        const topDifference = scrollPosition.top - newTop;
        const leftDifference = scrollPosition.left - newLeft;
        this.positions.forEach((position, node) => {
          if (position.clientRect && target !== node && target.contains(node)) {
            adjustDomRect(position.clientRect, topDifference, leftDifference);
          }
        });
        scrollPosition.top = newTop;
        scrollPosition.left = newLeft;
        return {
          top: topDifference,
          left: leftDifference
        };
      }
      /**
       * Gets the scroll position of the viewport. Note that we use the scrollX and scrollY directly,
       * instead of going through the `ViewportRuler`, because the first value the ruler looks at is
       * the top/left offset of the `document.documentElement` which works for most cases, but breaks
       * if the element is offset by something like the `BlockScrollStrategy`.
       */
      getViewportScrollPosition() {
        return {
          top: window.scrollY,
          left: window.scrollX
        };
      }
    };
    importantProperties = /* @__PURE__ */ new Set([
      // Needs to be important, because some `mat-table` sets `position: sticky !important`. See #22781.
      "position"
    ]);
    PreviewRef = class {
      _document;
      _rootElement;
      _direction;
      _initialDomRect;
      _previewTemplate;
      _previewClass;
      _pickupPositionOnPage;
      _initialTransform;
      _zIndex;
      _renderer;
      /** Reference to the view of the preview element. */
      _previewEmbeddedView;
      /** Reference to the preview element. */
      _preview;
      get element() {
        return this._preview;
      }
      constructor(_document2, _rootElement, _direction, _initialDomRect, _previewTemplate, _previewClass, _pickupPositionOnPage, _initialTransform, _zIndex, _renderer) {
        this._document = _document2;
        this._rootElement = _rootElement;
        this._direction = _direction;
        this._initialDomRect = _initialDomRect;
        this._previewTemplate = _previewTemplate;
        this._previewClass = _previewClass;
        this._pickupPositionOnPage = _pickupPositionOnPage;
        this._initialTransform = _initialTransform;
        this._zIndex = _zIndex;
        this._renderer = _renderer;
      }
      attach(parent) {
        this._preview = this._createPreview();
        parent.appendChild(this._preview);
        if (supportsPopover(this._preview)) {
          this._preview["showPopover"]();
        }
      }
      destroy() {
        this._preview.remove();
        this._previewEmbeddedView?.destroy();
        this._preview = this._previewEmbeddedView = null;
      }
      setTransform(value) {
        this._preview.style.transform = value;
      }
      getBoundingClientRect() {
        return this._preview.getBoundingClientRect();
      }
      addClass(className) {
        this._preview.classList.add(className);
      }
      getTransitionDuration() {
        return getTransformTransitionDurationInMs(this._preview);
      }
      addEventListener(name, handler) {
        return this._renderer.listen(this._preview, name, handler);
      }
      _createPreview() {
        const previewConfig = this._previewTemplate;
        const previewClass = this._previewClass;
        const previewTemplate = previewConfig ? previewConfig.template : null;
        let preview;
        if (previewTemplate && previewConfig) {
          const rootRect = previewConfig.matchSize ? this._initialDomRect : null;
          const viewRef = previewConfig.viewContainer.createEmbeddedView(previewTemplate, previewConfig.context);
          viewRef.detectChanges();
          preview = getRootNode(viewRef, this._document);
          this._previewEmbeddedView = viewRef;
          if (previewConfig.matchSize) {
            matchElementSize(preview, rootRect);
          } else {
            preview.style.transform = getTransform(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);
          }
        } else {
          preview = deepCloneNode(this._rootElement);
          matchElementSize(preview, this._initialDomRect);
          if (this._initialTransform) {
            preview.style.transform = this._initialTransform;
          }
        }
        extendStyles(preview.style, {
          // It's important that we disable the pointer events on the preview, because
          // it can throw off the `document.elementFromPoint` calls in the `CdkDropList`.
          "pointer-events": "none",
          // If the preview has a margin, it can throw off our positioning so we reset it. The reset
          // value for `margin-right` needs to be `auto` when opened as a popover, because our
          // positioning is always top/left based, but native popover seems to position itself
          // to the top/right if `<html>` or `<body>` have `dir="rtl"` (see #29604). Setting it
          // to `auto` pushed it to the top/left corner in RTL and is a noop in LTR.
          "margin": supportsPopover(preview) ? "0 auto 0 0" : "0",
          "position": "fixed",
          "top": "0",
          "left": "0",
          "z-index": this._zIndex + ""
        }, importantProperties);
        toggleNativeDragInteractions(preview, false);
        preview.classList.add("cdk-drag-preview");
        preview.setAttribute("popover", "manual");
        preview.setAttribute("dir", this._direction);
        if (previewClass) {
          if (Array.isArray(previewClass)) {
            previewClass.forEach((className) => preview.classList.add(className));
          } else {
            preview.classList.add(previewClass);
          }
        }
        return preview;
      }
    };
    passiveEventListenerOptions = {
      passive: true
    };
    activeEventListenerOptions = {
      passive: false
    };
    activeCapturingEventOptions$1 = {
      passive: false,
      capture: true
    };
    MOUSE_EVENT_IGNORE_TIME = 800;
    PLACEHOLDER_CLASS = "cdk-drag-placeholder";
    dragImportantProperties = /* @__PURE__ */ new Set([
      // Needs to be important, because some `mat-table` sets `position: sticky !important`. See #22781.
      "position"
    ]);
    DragRef = class {
      _config;
      _document;
      _ngZone;
      _viewportRuler;
      _dragDropRegistry;
      _renderer;
      _rootElementCleanups;
      _cleanupShadowRootSelectStart;
      /** Element displayed next to the user's pointer while the element is dragged. */
      _preview;
      /** Container into which to insert the preview. */
      _previewContainer;
      /** Reference to the view of the placeholder element. */
      _placeholderRef;
      /** Element that is rendered instead of the draggable item while it is being sorted. */
      _placeholder;
      /** Coordinates within the element at which the user picked up the element. */
      _pickupPositionInElement;
      /** Coordinates on the page at which the user picked up the element. */
      _pickupPositionOnPage;
      /**
       * Marker node used to save the place in the DOM where the element was
       * picked up so that it can be restored at the end of the drag sequence.
       */
      _marker;
      /**
       * Element indicating the position from which the item was picked up initially.
       */
      _anchor = null;
      /**
       * CSS `transform` applied to the element when it isn't being dragged. We need a
       * passive transform in order for the dragged element to retain its new position
       * after the user has stopped dragging and because we need to know the relative
       * position in case they start dragging again. This corresponds to `element.style.transform`.
       */
      _passiveTransform = {
        x: 0,
        y: 0
      };
      /** CSS `transform` that is applied to the element while it's being dragged. */
      _activeTransform = {
        x: 0,
        y: 0
      };
      /** Inline `transform` value that the element had before the first dragging sequence. */
      _initialTransform;
      /**
       * Whether the dragging sequence has been started. Doesn't
       * necessarily mean that the element has been moved.
       */
      _hasStartedDragging = signal(false, ...ngDevMode ? [{
        debugName: "_hasStartedDragging"
      }] : []);
      /** Whether the element has moved since the user started dragging it. */
      _hasMoved;
      /** Drop container in which the DragRef resided when dragging began. */
      _initialContainer;
      /** Index at which the item started in its initial container. */
      _initialIndex;
      /** Cached positions of scrollable parent elements. */
      _parentPositions;
      /** Emits when the item is being moved. */
      _moveEvents = new Subject();
      /** Keeps track of the direction in which the user is dragging along each axis. */
      _pointerDirectionDelta;
      /** Pointer position at which the last change in the delta occurred. */
      _pointerPositionAtLastDirectionChange;
      /** Position of the pointer at the last pointer event. */
      _lastKnownPointerPosition;
      /**
       * Root DOM node of the drag instance. This is the element that will
       * be moved around as the user is dragging.
       */
      _rootElement;
      /**
       * Nearest ancestor SVG, relative to which coordinates are calculated if dragging SVGElement
       */
      _ownerSVGElement;
      /**
       * Inline style value of `-webkit-tap-highlight-color` at the time the
       * dragging was started. Used to restore the value once we're done dragging.
       */
      _rootElementTapHighlight;
      /** Subscription to pointer movement events. */
      _pointerMoveSubscription = Subscription.EMPTY;
      /** Subscription to the event that is dispatched when the user lifts their pointer. */
      _pointerUpSubscription = Subscription.EMPTY;
      /** Subscription to the viewport being scrolled. */
      _scrollSubscription = Subscription.EMPTY;
      /** Subscription to the viewport being resized. */
      _resizeSubscription = Subscription.EMPTY;
      /**
       * Time at which the last touch event occurred. Used to avoid firing the same
       * events multiple times on touch devices where the browser will fire a fake
       * mouse event for each touch event, after a certain time.
       */
      _lastTouchEventTime;
      /** Time at which the last dragging sequence was started. */
      _dragStartTime;
      /** Cached reference to the boundary element. */
      _boundaryElement = null;
      /** Whether the native dragging interactions have been enabled on the root element. */
      _nativeInteractionsEnabled = true;
      /** Client rect of the root element when the dragging sequence has started. */
      _initialDomRect;
      /** Cached dimensions of the preview element. Should be read via `_getPreviewRect`. */
      _previewRect;
      /** Cached dimensions of the boundary element. */
      _boundaryRect;
      /** Element that will be used as a template to create the draggable item's preview. */
      _previewTemplate;
      /** Template for placeholder element rendered to show where a draggable would be dropped. */
      _placeholderTemplate;
      /** Elements that can be used to drag the draggable item. */
      _handles = [];
      /** Registered handles that are currently disabled. */
      _disabledHandles = /* @__PURE__ */ new Set();
      /** Droppable container that the draggable is a part of. */
      _dropContainer;
      /** Layout direction of the item. */
      _direction = "ltr";
      /** Ref that the current drag item is nested in. */
      _parentDragRef;
      /**
       * Cached shadow root that the element is placed in. `null` means that the element isn't in
       * the shadow DOM and `undefined` means that it hasn't been resolved yet. Should be read via
       * `_getShadowRoot`, not directly.
       */
      _cachedShadowRoot;
      /** Axis along which dragging is locked. */
      lockAxis;
      /**
       * Amount of milliseconds to wait after the user has put their
       * pointer down before starting to drag the element.
       */
      dragStartDelay = 0;
      /** Class to be added to the preview element. */
      previewClass;
      /**
       * If the parent of the dragged element has a `scale` transform, it can throw off the
       * positioning when the user starts dragging. Use this input to notify the CDK of the scale.
       */
      scale = 1;
      /** Whether starting to drag this element is disabled. */
      get disabled() {
        return this._disabled || !!(this._dropContainer && this._dropContainer.disabled);
      }
      set disabled(value) {
        if (value !== this._disabled) {
          this._disabled = value;
          this._toggleNativeDragInteractions();
          this._handles.forEach((handle) => toggleNativeDragInteractions(handle, value));
        }
      }
      _disabled = false;
      /** Emits as the drag sequence is being prepared. */
      beforeStarted = new Subject();
      /** Emits when the user starts dragging the item. */
      started = new Subject();
      /** Emits when the user has released a drag item, before any animations have started. */
      released = new Subject();
      /** Emits when the user stops dragging an item in the container. */
      ended = new Subject();
      /** Emits when the user has moved the item into a new container. */
      entered = new Subject();
      /** Emits when the user removes the item its container by dragging it into another container. */
      exited = new Subject();
      /** Emits when the user drops the item inside a container. */
      dropped = new Subject();
      /**
       * Emits as the user is dragging the item. Use with caution,
       * because this event will fire for every pixel that the user has dragged.
       */
      moved = this._moveEvents;
      /** Arbitrary data that can be attached to the drag item. */
      data;
      /**
       * Function that can be used to customize the logic of how the position of the drag item
       * is limited while it's being dragged. Gets called with a point containing the current position
       * of the user's pointer on the page, a reference to the item being dragged and its dimensions.
       * Should return a point describing where the item should be rendered.
       */
      constrainPosition;
      constructor(element, _config, _document2, _ngZone, _viewportRuler, _dragDropRegistry, _renderer) {
        this._config = _config;
        this._document = _document2;
        this._ngZone = _ngZone;
        this._viewportRuler = _viewportRuler;
        this._dragDropRegistry = _dragDropRegistry;
        this._renderer = _renderer;
        this.withRootElement(element).withParent(_config.parentDragRef || null);
        this._parentPositions = new ParentPositionTracker(_document2);
        _dragDropRegistry.registerDragItem(this);
      }
      /**
       * Returns the element that is being used as a placeholder
       * while the current element is being dragged.
       */
      getPlaceholderElement() {
        return this._placeholder;
      }
      /** Returns the root draggable element. */
      getRootElement() {
        return this._rootElement;
      }
      /**
       * Gets the currently-visible element that represents the drag item.
       * While dragging this is the placeholder, otherwise it's the root element.
       */
      getVisibleElement() {
        return this.isDragging() ? this.getPlaceholderElement() : this.getRootElement();
      }
      /** Registers the handles that can be used to drag the element. */
      withHandles(handles) {
        this._handles = handles.map((handle) => coerceElement(handle));
        this._handles.forEach((handle) => toggleNativeDragInteractions(handle, this.disabled));
        this._toggleNativeDragInteractions();
        const disabledHandles = /* @__PURE__ */ new Set();
        this._disabledHandles.forEach((handle) => {
          if (this._handles.indexOf(handle) > -1) {
            disabledHandles.add(handle);
          }
        });
        this._disabledHandles = disabledHandles;
        return this;
      }
      /**
       * Registers the template that should be used for the drag preview.
       * @param template Template that from which to stamp out the preview.
       */
      withPreviewTemplate(template) {
        this._previewTemplate = template;
        return this;
      }
      /**
       * Registers the template that should be used for the drag placeholder.
       * @param template Template that from which to stamp out the placeholder.
       */
      withPlaceholderTemplate(template) {
        this._placeholderTemplate = template;
        return this;
      }
      /**
       * Sets an alternate drag root element. The root element is the element that will be moved as
       * the user is dragging. Passing an alternate root element is useful when trying to enable
       * dragging on an element that you might not have access to.
       */
      withRootElement(rootElement) {
        const element = coerceElement(rootElement);
        if (element !== this._rootElement) {
          this._removeRootElementListeners();
          const renderer = this._renderer;
          this._rootElementCleanups = this._ngZone.runOutsideAngular(() => [renderer.listen(element, "mousedown", this._pointerDown, activeEventListenerOptions), renderer.listen(element, "touchstart", this._pointerDown, passiveEventListenerOptions), renderer.listen(element, "dragstart", this._nativeDragStart, activeEventListenerOptions)]);
          this._initialTransform = void 0;
          this._rootElement = element;
        }
        if (typeof SVGElement !== "undefined" && this._rootElement instanceof SVGElement) {
          this._ownerSVGElement = this._rootElement.ownerSVGElement;
        }
        return this;
      }
      /**
       * Element to which the draggable's position will be constrained.
       */
      withBoundaryElement(boundaryElement) {
        this._boundaryElement = boundaryElement ? coerceElement(boundaryElement) : null;
        this._resizeSubscription.unsubscribe();
        if (boundaryElement) {
          this._resizeSubscription = this._viewportRuler.change(10).subscribe(() => this._containInsideBoundaryOnResize());
        }
        return this;
      }
      /** Sets the parent ref that the ref is nested in.  */
      withParent(parent) {
        this._parentDragRef = parent;
        return this;
      }
      /** Removes the dragging functionality from the DOM element. */
      dispose() {
        this._removeRootElementListeners();
        if (this.isDragging()) {
          this._rootElement?.remove();
        }
        this._marker?.remove();
        this._destroyPreview();
        this._destroyPlaceholder();
        this._dragDropRegistry.removeDragItem(this);
        this._removeListeners();
        this.beforeStarted.complete();
        this.started.complete();
        this.released.complete();
        this.ended.complete();
        this.entered.complete();
        this.exited.complete();
        this.dropped.complete();
        this._moveEvents.complete();
        this._handles = [];
        this._disabledHandles.clear();
        this._dropContainer = void 0;
        this._resizeSubscription.unsubscribe();
        this._parentPositions.clear();
        this._boundaryElement = this._rootElement = this._ownerSVGElement = this._placeholderTemplate = this._previewTemplate = this._marker = this._parentDragRef = null;
      }
      /** Checks whether the element is currently being dragged. */
      isDragging() {
        return this._hasStartedDragging() && this._dragDropRegistry.isDragging(this);
      }
      /** Resets a standalone drag item to its initial position. */
      reset() {
        this._rootElement.style.transform = this._initialTransform || "";
        this._activeTransform = {
          x: 0,
          y: 0
        };
        this._passiveTransform = {
          x: 0,
          y: 0
        };
      }
      /** Resets drag item to end of boundary element. */
      resetToBoundary() {
        if (
          // can be null if the drag item was never dragged.
          this._boundaryElement && this._rootElement && // check if we are overflowing off our boundary element
          isOverflowingParent(this._boundaryElement.getBoundingClientRect(), this._rootElement.getBoundingClientRect())
        ) {
          const parentRect = this._boundaryElement.getBoundingClientRect();
          const childRect = this._rootElement.getBoundingClientRect();
          let offsetX = 0;
          let offsetY = 0;
          if (childRect.left < parentRect.left) {
            offsetX = parentRect.left - childRect.left;
          } else if (childRect.right > parentRect.right) {
            offsetX = parentRect.right - childRect.right;
          }
          if (childRect.top < parentRect.top) {
            offsetY = parentRect.top - childRect.top;
          } else if (childRect.bottom > parentRect.bottom) {
            offsetY = parentRect.bottom - childRect.bottom;
          }
          const currentLeft = this._activeTransform.x;
          const currentTop = this._activeTransform.y;
          let x2 = currentLeft + offsetX, y2 = currentTop + offsetY;
          this._rootElement.style.transform = getTransform(x2, y2);
          this._activeTransform = {
            x: x2,
            y: y2
          };
          this._passiveTransform = {
            x: x2,
            y: y2
          };
        }
      }
      /**
       * Sets a handle as disabled. While a handle is disabled, it'll capture and interrupt dragging.
       * @param handle Handle element that should be disabled.
       */
      disableHandle(handle) {
        if (!this._disabledHandles.has(handle) && this._handles.indexOf(handle) > -1) {
          this._disabledHandles.add(handle);
          toggleNativeDragInteractions(handle, true);
        }
      }
      /**
       * Enables a handle, if it has been disabled.
       * @param handle Handle element to be enabled.
       */
      enableHandle(handle) {
        if (this._disabledHandles.has(handle)) {
          this._disabledHandles.delete(handle);
          toggleNativeDragInteractions(handle, this.disabled);
        }
      }
      /** Sets the layout direction of the draggable item. */
      withDirection(direction) {
        this._direction = direction;
        return this;
      }
      /** Sets the container that the item is part of. */
      _withDropContainer(container) {
        this._dropContainer = container;
      }
      /**
       * Gets the current position in pixels the draggable outside of a drop container.
       */
      getFreeDragPosition() {
        const position = this.isDragging() ? this._activeTransform : this._passiveTransform;
        return {
          x: position.x,
          y: position.y
        };
      }
      /**
       * Sets the current position in pixels the draggable outside of a drop container.
       * @param value New position to be set.
       */
      setFreeDragPosition(value) {
        this._activeTransform = {
          x: 0,
          y: 0
        };
        this._passiveTransform.x = value.x;
        this._passiveTransform.y = value.y;
        if (!this._dropContainer) {
          this._applyRootElementTransform(value.x, value.y);
        }
        return this;
      }
      /**
       * Sets the container into which to insert the preview element.
       * @param value Container into which to insert the preview.
       */
      withPreviewContainer(value) {
        this._previewContainer = value;
        return this;
      }
      /** Updates the item's sort order based on the last-known pointer position. */
      _sortFromLastPointerPosition() {
        const position = this._lastKnownPointerPosition;
        if (position && this._dropContainer) {
          this._updateActiveDropContainer(this._getConstrainedPointerPosition(position), position);
        }
      }
      /** Unsubscribes from the global subscriptions. */
      _removeListeners() {
        this._pointerMoveSubscription.unsubscribe();
        this._pointerUpSubscription.unsubscribe();
        this._scrollSubscription.unsubscribe();
        this._cleanupShadowRootSelectStart?.();
        this._cleanupShadowRootSelectStart = void 0;
      }
      /** Destroys the preview element and its ViewRef. */
      _destroyPreview() {
        this._preview?.destroy();
        this._preview = null;
      }
      /** Destroys the placeholder element and its ViewRef. */
      _destroyPlaceholder() {
        this._anchor?.remove();
        this._placeholder?.remove();
        this._placeholderRef?.destroy();
        this._placeholder = this._anchor = this._placeholderRef = null;
      }
      /** Handler for the `mousedown`/`touchstart` events. */
      _pointerDown = (event) => {
        this.beforeStarted.next();
        if (this._handles.length) {
          const targetHandle = this._getTargetHandle(event);
          if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {
            this._initializeDragSequence(targetHandle, event);
          }
        } else if (!this.disabled) {
          this._initializeDragSequence(this._rootElement, event);
        }
      };
      /** Handler that is invoked when the user moves their pointer after they've initiated a drag. */
      _pointerMove = (event) => {
        const pointerPosition = this._getPointerPositionOnPage(event);
        if (!this._hasStartedDragging()) {
          const distanceX = Math.abs(pointerPosition.x - this._pickupPositionOnPage.x);
          const distanceY = Math.abs(pointerPosition.y - this._pickupPositionOnPage.y);
          const isOverThreshold = distanceX + distanceY >= this._config.dragStartThreshold;
          if (isOverThreshold) {
            const isDelayElapsed = Date.now() >= this._dragStartTime + this._getDragStartDelay(event);
            const container = this._dropContainer;
            if (!isDelayElapsed) {
              this._endDragSequence(event);
              return;
            }
            if (!container || !container.isDragging() && !container.isReceiving()) {
              if (event.cancelable) {
                event.preventDefault();
              }
              this._hasStartedDragging.set(true);
              this._ngZone.run(() => this._startDragSequence(event));
            }
          }
          return;
        }
        if (event.cancelable) {
          event.preventDefault();
        }
        const constrainedPointerPosition = this._getConstrainedPointerPosition(pointerPosition);
        this._hasMoved = true;
        this._lastKnownPointerPosition = pointerPosition;
        this._updatePointerDirectionDelta(constrainedPointerPosition);
        if (this._dropContainer) {
          this._updateActiveDropContainer(constrainedPointerPosition, pointerPosition);
        } else {
          const offset = this.constrainPosition ? this._initialDomRect : this._pickupPositionOnPage;
          const activeTransform = this._activeTransform;
          activeTransform.x = constrainedPointerPosition.x - offset.x + this._passiveTransform.x;
          activeTransform.y = constrainedPointerPosition.y - offset.y + this._passiveTransform.y;
          this._applyRootElementTransform(activeTransform.x, activeTransform.y);
        }
        if (this._moveEvents.observers.length) {
          this._ngZone.run(() => {
            this._moveEvents.next({
              source: this,
              pointerPosition: constrainedPointerPosition,
              event,
              distance: this._getDragDistance(constrainedPointerPosition),
              delta: this._pointerDirectionDelta
            });
          });
        }
      };
      /** Handler that is invoked when the user lifts their pointer up, after initiating a drag. */
      _pointerUp = (event) => {
        this._endDragSequence(event);
      };
      /**
       * Clears subscriptions and stops the dragging sequence.
       * @param event Browser event object that ended the sequence.
       */
      _endDragSequence(event) {
        if (!this._dragDropRegistry.isDragging(this)) {
          return;
        }
        this._removeListeners();
        this._dragDropRegistry.stopDragging(this);
        this._toggleNativeDragInteractions();
        if (this._handles) {
          this._rootElement.style.webkitTapHighlightColor = this._rootElementTapHighlight;
        }
        if (!this._hasStartedDragging()) {
          return;
        }
        this.released.next({
          source: this,
          event
        });
        if (this._dropContainer) {
          this._dropContainer._stopScrolling();
          this._animatePreviewToPlaceholder().then(() => {
            this._cleanupDragArtifacts(event);
            this._cleanupCachedDimensions();
            this._dragDropRegistry.stopDragging(this);
          });
        } else {
          this._passiveTransform.x = this._activeTransform.x;
          const pointerPosition = this._getPointerPositionOnPage(event);
          this._passiveTransform.y = this._activeTransform.y;
          this._ngZone.run(() => {
            this.ended.next({
              source: this,
              distance: this._getDragDistance(pointerPosition),
              dropPoint: pointerPosition,
              event
            });
          });
          this._cleanupCachedDimensions();
          this._dragDropRegistry.stopDragging(this);
        }
      }
      /** Starts the dragging sequence. */
      _startDragSequence(event) {
        if (isTouchEvent(event)) {
          this._lastTouchEventTime = Date.now();
        }
        this._toggleNativeDragInteractions();
        const shadowRoot = this._getShadowRoot();
        const dropContainer = this._dropContainer;
        if (shadowRoot) {
          this._ngZone.runOutsideAngular(() => {
            this._cleanupShadowRootSelectStart = this._renderer.listen(shadowRoot, "selectstart", shadowDomSelectStart, activeCapturingEventOptions$1);
          });
        }
        if (dropContainer) {
          const element = this._rootElement;
          const parent = element.parentNode;
          const placeholder = this._placeholder = this._createPlaceholderElement();
          const marker = this._marker = this._marker || this._document.createComment(typeof ngDevMode === "undefined" || ngDevMode ? "cdk-drag-marker" : "");
          parent.insertBefore(marker, element);
          this._initialTransform = element.style.transform || "";
          this._preview = new PreviewRef(this._document, this._rootElement, this._direction, this._initialDomRect, this._previewTemplate || null, this.previewClass || null, this._pickupPositionOnPage, this._initialTransform, this._config.zIndex || 1e3, this._renderer);
          this._preview.attach(this._getPreviewInsertionPoint(parent, shadowRoot));
          toggleVisibility(element, false, dragImportantProperties);
          this._document.body.appendChild(parent.replaceChild(placeholder, element));
          this.started.next({
            source: this,
            event
          });
          dropContainer.start();
          this._initialContainer = dropContainer;
          this._initialIndex = dropContainer.getItemIndex(this);
        } else {
          this.started.next({
            source: this,
            event
          });
          this._initialContainer = this._initialIndex = void 0;
        }
        this._parentPositions.cache(dropContainer ? dropContainer.getScrollableParents() : []);
      }
      /**
       * Sets up the different variables and subscriptions
       * that will be necessary for the dragging sequence.
       * @param referenceElement Element that started the drag sequence.
       * @param event Browser event object that started the sequence.
       */
      _initializeDragSequence(referenceElement, event) {
        if (this._parentDragRef) {
          event.stopPropagation();
        }
        const isDragging = this.isDragging();
        const isTouchSequence = isTouchEvent(event);
        const isAuxiliaryMouseButton = !isTouchSequence && event.button !== 0;
        const rootElement = this._rootElement;
        const target = _getEventTarget(event);
        const isSyntheticEvent = !isTouchSequence && this._lastTouchEventTime && this._lastTouchEventTime + MOUSE_EVENT_IGNORE_TIME > Date.now();
        const isFakeEvent = isTouchSequence ? isFakeTouchstartFromScreenReader(event) : isFakeMousedownFromScreenReader(event);
        if (target && target.draggable && event.type === "mousedown") {
          event.preventDefault();
        }
        if (isDragging || isAuxiliaryMouseButton || isSyntheticEvent || isFakeEvent) {
          return;
        }
        if (this._handles.length) {
          const rootStyles = rootElement.style;
          this._rootElementTapHighlight = rootStyles.webkitTapHighlightColor || "";
          rootStyles.webkitTapHighlightColor = "transparent";
        }
        this._hasMoved = false;
        this._hasStartedDragging.set(this._hasMoved);
        this._removeListeners();
        this._initialDomRect = this._rootElement.getBoundingClientRect();
        this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove);
        this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp);
        this._scrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe((scrollEvent) => this._updateOnScroll(scrollEvent));
        if (this._boundaryElement) {
          this._boundaryRect = getMutableClientRect(this._boundaryElement);
        }
        const previewTemplate = this._previewTemplate;
        this._pickupPositionInElement = previewTemplate && previewTemplate.template && !previewTemplate.matchSize ? {
          x: 0,
          y: 0
        } : this._getPointerPositionInElement(this._initialDomRect, referenceElement, event);
        const pointerPosition = this._pickupPositionOnPage = this._lastKnownPointerPosition = this._getPointerPositionOnPage(event);
        this._pointerDirectionDelta = {
          x: 0,
          y: 0
        };
        this._pointerPositionAtLastDirectionChange = {
          x: pointerPosition.x,
          y: pointerPosition.y
        };
        this._dragStartTime = Date.now();
        this._dragDropRegistry.startDragging(this, event);
      }
      /** Cleans up the DOM artifacts that were added to facilitate the element being dragged. */
      _cleanupDragArtifacts(event) {
        toggleVisibility(this._rootElement, true, dragImportantProperties);
        this._marker.parentNode.replaceChild(this._rootElement, this._marker);
        this._destroyPreview();
        this._destroyPlaceholder();
        this._initialDomRect = this._boundaryRect = this._previewRect = this._initialTransform = void 0;
        this._ngZone.run(() => {
          const container = this._dropContainer;
          const currentIndex = container.getItemIndex(this);
          const pointerPosition = this._getPointerPositionOnPage(event);
          const distance = this._getDragDistance(pointerPosition);
          const isPointerOverContainer = container._isOverContainer(pointerPosition.x, pointerPosition.y);
          this.ended.next({
            source: this,
            distance,
            dropPoint: pointerPosition,
            event
          });
          this.dropped.next({
            item: this,
            currentIndex,
            previousIndex: this._initialIndex,
            container,
            previousContainer: this._initialContainer,
            isPointerOverContainer,
            distance,
            dropPoint: pointerPosition,
            event
          });
          container.drop(this, currentIndex, this._initialIndex, this._initialContainer, isPointerOverContainer, distance, pointerPosition, event);
          this._dropContainer = this._initialContainer;
        });
      }
      /**
       * Updates the item's position in its drop container, or moves it
       * into a new one, depending on its current drag position.
       */
      _updateActiveDropContainer({
        x: x2,
        y: y2
      }, {
        x: rawX,
        y: rawY
      }) {
        let newContainer = this._initialContainer._getSiblingContainerFromPosition(this, x2, y2);
        if (!newContainer && this._dropContainer !== this._initialContainer && this._initialContainer._isOverContainer(x2, y2)) {
          newContainer = this._initialContainer;
        }
        if (newContainer && newContainer !== this._dropContainer) {
          this._ngZone.run(() => {
            const exitIndex = this._dropContainer.getItemIndex(this);
            const nextItemElement = this._dropContainer.getItemAtIndex(exitIndex + 1)?.getVisibleElement() || null;
            this.exited.next({
              item: this,
              container: this._dropContainer
            });
            this._dropContainer.exit(this);
            this._conditionallyInsertAnchor(newContainer, this._dropContainer, nextItemElement);
            this._dropContainer = newContainer;
            this._dropContainer.enter(
              this,
              x2,
              y2,
              // If we're re-entering the initial container and sorting is disabled,
              // put item the into its starting index to begin with.
              newContainer === this._initialContainer && newContainer.sortingDisabled ? this._initialIndex : void 0
            );
            this.entered.next({
              item: this,
              container: newContainer,
              currentIndex: newContainer.getItemIndex(this)
            });
          });
        }
        if (this.isDragging()) {
          this._dropContainer._startScrollingIfNecessary(rawX, rawY);
          this._dropContainer._sortItem(this, x2, y2, this._pointerDirectionDelta);
          if (this.constrainPosition) {
            this._applyPreviewTransform(x2, y2);
          } else {
            this._applyPreviewTransform(x2 - this._pickupPositionInElement.x, y2 - this._pickupPositionInElement.y);
          }
        }
      }
      /**
       * Animates the preview element from its current position to the location of the drop placeholder.
       * @returns Promise that resolves when the animation completes.
       */
      _animatePreviewToPlaceholder() {
        if (!this._hasMoved) {
          return Promise.resolve();
        }
        const placeholderRect = this._placeholder.getBoundingClientRect();
        this._preview.addClass("cdk-drag-animating");
        this._applyPreviewTransform(placeholderRect.left, placeholderRect.top);
        const duration = this._preview.getTransitionDuration();
        if (duration === 0) {
          return Promise.resolve();
        }
        return this._ngZone.runOutsideAngular(() => {
          return new Promise((resolve) => {
            const handler = (event) => {
              if (!event || this._preview && _getEventTarget(event) === this._preview.element && event.propertyName === "transform") {
                cleanupListener();
                resolve();
                clearTimeout(timeout);
              }
            };
            const timeout = setTimeout(handler, duration * 1.5);
            const cleanupListener = this._preview.addEventListener("transitionend", handler);
          });
        });
      }
      /** Creates an element that will be shown instead of the current element while dragging. */
      _createPlaceholderElement() {
        const placeholderConfig = this._placeholderTemplate;
        const placeholderTemplate = placeholderConfig ? placeholderConfig.template : null;
        let placeholder;
        if (placeholderTemplate) {
          this._placeholderRef = placeholderConfig.viewContainer.createEmbeddedView(placeholderTemplate, placeholderConfig.context);
          this._placeholderRef.detectChanges();
          placeholder = getRootNode(this._placeholderRef, this._document);
        } else {
          placeholder = deepCloneNode(this._rootElement);
        }
        placeholder.style.pointerEvents = "none";
        placeholder.classList.add(PLACEHOLDER_CLASS);
        return placeholder;
      }
      /**
       * Figures out the coordinates at which an element was picked up.
       * @param referenceElement Element that initiated the dragging.
       * @param event Event that initiated the dragging.
       */
      _getPointerPositionInElement(elementRect, referenceElement, event) {
        const handleElement = referenceElement === this._rootElement ? null : referenceElement;
        const referenceRect = handleElement ? handleElement.getBoundingClientRect() : elementRect;
        const point = isTouchEvent(event) ? event.targetTouches[0] : event;
        const scrollPosition = this._getViewportScrollPosition();
        const x2 = point.pageX - referenceRect.left - scrollPosition.left;
        const y2 = point.pageY - referenceRect.top - scrollPosition.top;
        return {
          x: referenceRect.left - elementRect.left + x2,
          y: referenceRect.top - elementRect.top + y2
        };
      }
      /** Determines the point of the page that was touched by the user. */
      _getPointerPositionOnPage(event) {
        const scrollPosition = this._getViewportScrollPosition();
        const point = isTouchEvent(event) ? (
          // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.
          // Also note that on real devices we're guaranteed for either `touches` or `changedTouches`
          // to have a value, but Firefox in device emulation mode has a bug where both can be empty
          // for `touchstart` and `touchend` so we fall back to a dummy object in order to avoid
          // throwing an error. The value returned here will be incorrect, but since this only
          // breaks inside a developer tool and the value is only used for secondary information,
          // we can get away with it. See https://bugzilla.mozilla.org/show_bug.cgi?id=1615824.
          event.touches[0] || event.changedTouches[0] || {
            pageX: 0,
            pageY: 0
          }
        ) : event;
        const x2 = point.pageX - scrollPosition.left;
        const y2 = point.pageY - scrollPosition.top;
        if (this._ownerSVGElement) {
          const svgMatrix = this._ownerSVGElement.getScreenCTM();
          if (svgMatrix) {
            const svgPoint = this._ownerSVGElement.createSVGPoint();
            svgPoint.x = x2;
            svgPoint.y = y2;
            return svgPoint.matrixTransform(svgMatrix.inverse());
          }
        }
        return {
          x: x2,
          y: y2
        };
      }
      /** Gets the pointer position on the page, accounting for any position constraints. */
      _getConstrainedPointerPosition(point) {
        const dropContainerLock = this._dropContainer ? this._dropContainer.lockAxis : null;
        let {
          x: x2,
          y: y2
        } = this.constrainPosition ? this.constrainPosition(point, this, this._initialDomRect, this._pickupPositionInElement) : point;
        if (this.lockAxis === "x" || dropContainerLock === "x") {
          y2 = this._pickupPositionOnPage.y - (this.constrainPosition ? this._pickupPositionInElement.y : 0);
        } else if (this.lockAxis === "y" || dropContainerLock === "y") {
          x2 = this._pickupPositionOnPage.x - (this.constrainPosition ? this._pickupPositionInElement.x : 0);
        }
        if (this._boundaryRect) {
          const {
            x: pickupX,
            y: pickupY
          } = !this.constrainPosition ? this._pickupPositionInElement : {
            x: 0,
            y: 0
          };
          const boundaryRect = this._boundaryRect;
          const {
            width: previewWidth,
            height: previewHeight
          } = this._getPreviewRect();
          const minY = boundaryRect.top + pickupY;
          const maxY = boundaryRect.bottom - (previewHeight - pickupY);
          const minX = boundaryRect.left + pickupX;
          const maxX = boundaryRect.right - (previewWidth - pickupX);
          x2 = clamp$1(x2, minX, maxX);
          y2 = clamp$1(y2, minY, maxY);
        }
        return {
          x: x2,
          y: y2
        };
      }
      /** Updates the current drag delta, based on the user's current pointer position on the page. */
      _updatePointerDirectionDelta(pointerPositionOnPage) {
        const {
          x: x2,
          y: y2
        } = pointerPositionOnPage;
        const delta = this._pointerDirectionDelta;
        const positionSinceLastChange = this._pointerPositionAtLastDirectionChange;
        const changeX = Math.abs(x2 - positionSinceLastChange.x);
        const changeY = Math.abs(y2 - positionSinceLastChange.y);
        if (changeX > this._config.pointerDirectionChangeThreshold) {
          delta.x = x2 > positionSinceLastChange.x ? 1 : -1;
          positionSinceLastChange.x = x2;
        }
        if (changeY > this._config.pointerDirectionChangeThreshold) {
          delta.y = y2 > positionSinceLastChange.y ? 1 : -1;
          positionSinceLastChange.y = y2;
        }
        return delta;
      }
      /** Toggles the native drag interactions, based on how many handles are registered. */
      _toggleNativeDragInteractions() {
        if (!this._rootElement || !this._handles) {
          return;
        }
        const shouldEnable = this._handles.length > 0 || !this.isDragging();
        if (shouldEnable !== this._nativeInteractionsEnabled) {
          this._nativeInteractionsEnabled = shouldEnable;
          toggleNativeDragInteractions(this._rootElement, shouldEnable);
        }
      }
      /** Removes the manually-added event listeners from the root element. */
      _removeRootElementListeners() {
        this._rootElementCleanups?.forEach((cleanup) => cleanup());
        this._rootElementCleanups = void 0;
      }
      /**
       * Applies a `transform` to the root element, taking into account any existing transforms on it.
       * @param x New transform value along the X axis.
       * @param y New transform value along the Y axis.
       */
      _applyRootElementTransform(x2, y2) {
        const scale2 = 1 / this.scale;
        const transform = getTransform(x2 * scale2, y2 * scale2);
        const styles = this._rootElement.style;
        if (this._initialTransform == null) {
          this._initialTransform = styles.transform && styles.transform != "none" ? styles.transform : "";
        }
        styles.transform = combineTransforms(transform, this._initialTransform);
      }
      /**
       * Applies a `transform` to the preview, taking into account any existing transforms on it.
       * @param x New transform value along the X axis.
       * @param y New transform value along the Y axis.
       */
      _applyPreviewTransform(x2, y2) {
        const initialTransform = this._previewTemplate?.template ? void 0 : this._initialTransform;
        const transform = getTransform(x2, y2);
        this._preview.setTransform(combineTransforms(transform, initialTransform));
      }
      /**
       * Gets the distance that the user has dragged during the current drag sequence.
       * @param currentPosition Current position of the user's pointer.
       */
      _getDragDistance(currentPosition) {
        const pickupPosition = this._pickupPositionOnPage;
        if (pickupPosition) {
          return {
            x: currentPosition.x - pickupPosition.x,
            y: currentPosition.y - pickupPosition.y
          };
        }
        return {
          x: 0,
          y: 0
        };
      }
      /** Cleans up any cached element dimensions that we don't need after dragging has stopped. */
      _cleanupCachedDimensions() {
        this._boundaryRect = this._previewRect = void 0;
        this._parentPositions.clear();
      }
      /**
       * Checks whether the element is still inside its boundary after the viewport has been resized.
       * If not, the position is adjusted so that the element fits again.
       */
      _containInsideBoundaryOnResize() {
        let {
          x: x2,
          y: y2
        } = this._passiveTransform;
        if (x2 === 0 && y2 === 0 || this.isDragging() || !this._boundaryElement) {
          return;
        }
        const elementRect = this._rootElement.getBoundingClientRect();
        const boundaryRect = this._boundaryElement.getBoundingClientRect();
        if (boundaryRect.width === 0 && boundaryRect.height === 0 || elementRect.width === 0 && elementRect.height === 0) {
          return;
        }
        const leftOverflow = boundaryRect.left - elementRect.left;
        const rightOverflow = elementRect.right - boundaryRect.right;
        const topOverflow = boundaryRect.top - elementRect.top;
        const bottomOverflow = elementRect.bottom - boundaryRect.bottom;
        if (boundaryRect.width > elementRect.width) {
          if (leftOverflow > 0) {
            x2 += leftOverflow;
          }
          if (rightOverflow > 0) {
            x2 -= rightOverflow;
          }
        } else {
          x2 = 0;
        }
        if (boundaryRect.height > elementRect.height) {
          if (topOverflow > 0) {
            y2 += topOverflow;
          }
          if (bottomOverflow > 0) {
            y2 -= bottomOverflow;
          }
        } else {
          y2 = 0;
        }
        if (x2 !== this._passiveTransform.x || y2 !== this._passiveTransform.y) {
          this.setFreeDragPosition({
            y: y2,
            x: x2
          });
        }
      }
      /** Gets the drag start delay, based on the event type. */
      _getDragStartDelay(event) {
        const value = this.dragStartDelay;
        if (typeof value === "number") {
          return value;
        } else if (isTouchEvent(event)) {
          return value.touch;
        }
        return value ? value.mouse : 0;
      }
      /** Updates the internal state of the draggable element when scrolling has occurred. */
      _updateOnScroll(event) {
        const scrollDifference = this._parentPositions.handleScroll(event);
        if (scrollDifference) {
          const target = _getEventTarget(event);
          if (this._boundaryRect && target !== this._boundaryElement && target.contains(this._boundaryElement)) {
            adjustDomRect(this._boundaryRect, scrollDifference.top, scrollDifference.left);
          }
          this._pickupPositionOnPage.x += scrollDifference.left;
          this._pickupPositionOnPage.y += scrollDifference.top;
          if (!this._dropContainer) {
            this._activeTransform.x -= scrollDifference.left;
            this._activeTransform.y -= scrollDifference.top;
            this._applyRootElementTransform(this._activeTransform.x, this._activeTransform.y);
          }
        }
      }
      /** Gets the scroll position of the viewport. */
      _getViewportScrollPosition() {
        return this._parentPositions.positions.get(this._document)?.scrollPosition || this._parentPositions.getViewportScrollPosition();
      }
      /**
       * Lazily resolves and returns the shadow root of the element. We do this in a function, rather
       * than saving it in property directly on init, because we want to resolve it as late as possible
       * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the
       * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.
       */
      _getShadowRoot() {
        if (this._cachedShadowRoot === void 0) {
          this._cachedShadowRoot = _getShadowRoot(this._rootElement);
        }
        return this._cachedShadowRoot;
      }
      /** Gets the element into which the drag preview should be inserted. */
      _getPreviewInsertionPoint(initialParent, shadowRoot) {
        const previewContainer = this._previewContainer || "global";
        if (previewContainer === "parent") {
          return initialParent;
        }
        if (previewContainer === "global") {
          const documentRef = this._document;
          return shadowRoot || documentRef.fullscreenElement || documentRef.webkitFullscreenElement || documentRef.mozFullScreenElement || documentRef.msFullscreenElement || documentRef.body;
        }
        return coerceElement(previewContainer);
      }
      /** Lazily resolves and returns the dimensions of the preview. */
      _getPreviewRect() {
        if (!this._previewRect || !this._previewRect.width && !this._previewRect.height) {
          this._previewRect = this._preview ? this._preview.getBoundingClientRect() : this._initialDomRect;
        }
        return this._previewRect;
      }
      /** Handles a native `dragstart` event. */
      _nativeDragStart = (event) => {
        if (this._handles.length) {
          const targetHandle = this._getTargetHandle(event);
          if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {
            event.preventDefault();
          }
        } else if (!this.disabled) {
          event.preventDefault();
        }
      };
      /** Gets a handle that is the target of an event. */
      _getTargetHandle(event) {
        return this._handles.find((handle) => {
          return event.target && (event.target === handle || handle.contains(event.target));
        });
      }
      /** Inserts the anchor element, if it's valid. */
      _conditionallyInsertAnchor(newContainer, exitContainer, nextItemElement) {
        if (newContainer === this._initialContainer) {
          this._anchor?.remove();
          this._anchor = null;
        } else if (exitContainer === this._initialContainer && exitContainer.hasAnchor) {
          const anchor = this._anchor ??= deepCloneNode(this._placeholder);
          anchor.classList.remove(PLACEHOLDER_CLASS);
          anchor.classList.add("cdk-drag-anchor");
          anchor.style.transform = "";
          if (nextItemElement) {
            nextItemElement.before(anchor);
          } else {
            coerceElement(exitContainer.element).appendChild(anchor);
          }
        }
      }
    };
    SingleAxisSortStrategy = class {
      _dragDropRegistry;
      /** Root element container of the drop list. */
      _element;
      /** Function used to determine if an item can be sorted into a specific index. */
      _sortPredicate;
      /** Cache of the dimensions of all the items inside the container. */
      _itemPositions = [];
      /**
       * Draggable items that are currently active inside the container. Includes the items
       * that were there at the start of the sequence, as well as any items that have been dragged
       * in, but haven't been dropped yet.
       */
      _activeDraggables;
      /** Direction in which the list is oriented. */
      orientation = "vertical";
      /** Layout direction of the drop list. */
      direction;
      constructor(_dragDropRegistry) {
        this._dragDropRegistry = _dragDropRegistry;
      }
      /**
       * Keeps track of the item that was last swapped with the dragged item, as well as what direction
       * the pointer was moving in when the swap occurred and whether the user's pointer continued to
       * overlap with the swapped item after the swapping occurred.
       */
      _previousSwap = {
        drag: null,
        delta: 0,
        overlaps: false
      };
      /**
       * To be called when the drag sequence starts.
       * @param items Items that are currently in the list.
       */
      start(items) {
        this.withItems(items);
      }
      /**
       * To be called when an item is being sorted.
       * @param item Item to be sorted.
       * @param pointerX Position of the item along the X axis.
       * @param pointerY Position of the item along the Y axis.
       * @param pointerDelta Direction in which the pointer is moving along each axis.
       */
      sort(item, pointerX, pointerY, pointerDelta) {
        const siblings = this._itemPositions;
        const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);
        if (newIndex === -1 && siblings.length > 0) {
          return null;
        }
        const isHorizontal = this.orientation === "horizontal";
        const currentIndex = siblings.findIndex((currentItem) => currentItem.drag === item);
        const siblingAtNewPosition = siblings[newIndex];
        const currentPosition = siblings[currentIndex].clientRect;
        const newPosition = siblingAtNewPosition.clientRect;
        const delta = currentIndex > newIndex ? 1 : -1;
        const itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);
        const siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);
        const oldOrder = siblings.slice();
        moveItemInArray(siblings, currentIndex, newIndex);
        siblings.forEach((sibling, index) => {
          if (oldOrder[index] === sibling) {
            return;
          }
          const isDraggedItem = sibling.drag === item;
          const offset = isDraggedItem ? itemOffset : siblingOffset;
          const elementToOffset = isDraggedItem ? item.getPlaceholderElement() : sibling.drag.getRootElement();
          sibling.offset += offset;
          const transformAmount = Math.round(sibling.offset * (1 / sibling.drag.scale));
          if (isHorizontal) {
            elementToOffset.style.transform = combineTransforms(`translate3d(${transformAmount}px, 0, 0)`, sibling.initialTransform);
            adjustDomRect(sibling.clientRect, 0, offset);
          } else {
            elementToOffset.style.transform = combineTransforms(`translate3d(0, ${transformAmount}px, 0)`, sibling.initialTransform);
            adjustDomRect(sibling.clientRect, offset, 0);
          }
        });
        this._previousSwap.overlaps = isInsideClientRect(newPosition, pointerX, pointerY);
        this._previousSwap.drag = siblingAtNewPosition.drag;
        this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;
        return {
          previousIndex: currentIndex,
          currentIndex: newIndex
        };
      }
      /**
       * Called when an item is being moved into the container.
       * @param item Item that was moved into the container.
       * @param pointerX Position of the item along the X axis.
       * @param pointerY Position of the item along the Y axis.
       * @param index Index at which the item entered. If omitted, the container will try to figure it
       *   out automatically.
       */
      enter(item, pointerX, pointerY, index) {
        const newIndex = index == null || index < 0 ? (
          // We use the coordinates of where the item entered the drop
          // zone to figure out at which index it should be inserted.
          this._getItemIndexFromPointerPosition(item, pointerX, pointerY)
        ) : index;
        const activeDraggables = this._activeDraggables;
        const currentIndex = activeDraggables.indexOf(item);
        const placeholder = item.getPlaceholderElement();
        let newPositionReference = activeDraggables[newIndex];
        if (newPositionReference === item) {
          newPositionReference = activeDraggables[newIndex + 1];
        }
        if (!newPositionReference && (newIndex == null || newIndex === -1 || newIndex < activeDraggables.length - 1) && this._shouldEnterAsFirstChild(pointerX, pointerY)) {
          newPositionReference = activeDraggables[0];
        }
        if (currentIndex > -1) {
          activeDraggables.splice(currentIndex, 1);
        }
        if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {
          const element = newPositionReference.getRootElement();
          element.parentElement.insertBefore(placeholder, element);
          activeDraggables.splice(newIndex, 0, item);
        } else {
          this._element.appendChild(placeholder);
          activeDraggables.push(item);
        }
        placeholder.style.transform = "";
        this._cacheItemPositions();
      }
      /** Sets the items that are currently part of the list. */
      withItems(items) {
        this._activeDraggables = items.slice();
        this._cacheItemPositions();
      }
      /** Assigns a sort predicate to the strategy. */
      withSortPredicate(predicate) {
        this._sortPredicate = predicate;
      }
      /** Resets the strategy to its initial state before dragging was started. */
      reset() {
        this._activeDraggables?.forEach((item) => {
          const rootElement = item.getRootElement();
          if (rootElement) {
            const initialTransform = this._itemPositions.find((p2) => p2.drag === item)?.initialTransform;
            rootElement.style.transform = initialTransform || "";
          }
        });
        this._itemPositions = [];
        this._activeDraggables = [];
        this._previousSwap.drag = null;
        this._previousSwap.delta = 0;
        this._previousSwap.overlaps = false;
      }
      /**
       * Gets a snapshot of items currently in the list.
       * Can include items that we dragged in from another list.
       */
      getActiveItemsSnapshot() {
        return this._activeDraggables;
      }
      /** Gets the index of a specific item. */
      getItemIndex(item) {
        return this._getVisualItemPositions().findIndex((currentItem) => currentItem.drag === item);
      }
      /** Gets the item at a specific index. */
      getItemAtIndex(index) {
        return this._getVisualItemPositions()[index]?.drag || null;
      }
      /** Used to notify the strategy that the scroll position has changed. */
      updateOnScroll(topDifference, leftDifference) {
        this._itemPositions.forEach(({
          clientRect
        }) => {
          adjustDomRect(clientRect, topDifference, leftDifference);
        });
        this._itemPositions.forEach(({
          drag
        }) => {
          if (this._dragDropRegistry.isDragging(drag)) {
            drag._sortFromLastPointerPosition();
          }
        });
      }
      withElementContainer(container) {
        this._element = container;
      }
      /** Refreshes the position cache of the items and sibling containers. */
      _cacheItemPositions() {
        const isHorizontal = this.orientation === "horizontal";
        this._itemPositions = this._activeDraggables.map((drag) => {
          const elementToMeasure = drag.getVisibleElement();
          return {
            drag,
            offset: 0,
            initialTransform: elementToMeasure.style.transform || "",
            clientRect: getMutableClientRect(elementToMeasure)
          };
        }).sort((a2, b2) => {
          return isHorizontal ? a2.clientRect.left - b2.clientRect.left : a2.clientRect.top - b2.clientRect.top;
        });
      }
      _getVisualItemPositions() {
        return this.orientation === "horizontal" && this.direction === "rtl" ? this._itemPositions.slice().reverse() : this._itemPositions;
      }
      /**
       * Gets the offset in pixels by which the item that is being dragged should be moved.
       * @param currentPosition Current position of the item.
       * @param newPosition Position of the item where the current item should be moved.
       * @param delta Direction in which the user is moving.
       */
      _getItemOffsetPx(currentPosition, newPosition, delta) {
        const isHorizontal = this.orientation === "horizontal";
        let itemOffset = isHorizontal ? newPosition.left - currentPosition.left : newPosition.top - currentPosition.top;
        if (delta === -1) {
          itemOffset += isHorizontal ? newPosition.width - currentPosition.width : newPosition.height - currentPosition.height;
        }
        return itemOffset;
      }
      /**
       * Gets the offset in pixels by which the items that aren't being dragged should be moved.
       * @param currentIndex Index of the item currently being dragged.
       * @param siblings All of the items in the list.
       * @param delta Direction in which the user is moving.
       */
      _getSiblingOffsetPx(currentIndex, siblings, delta) {
        const isHorizontal = this.orientation === "horizontal";
        const currentPosition = siblings[currentIndex].clientRect;
        const immediateSibling = siblings[currentIndex + delta * -1];
        let siblingOffset = currentPosition[isHorizontal ? "width" : "height"] * delta;
        if (immediateSibling) {
          const start = isHorizontal ? "left" : "top";
          const end = isHorizontal ? "right" : "bottom";
          if (delta === -1) {
            siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];
          } else {
            siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];
          }
        }
        return siblingOffset;
      }
      /**
       * Checks if pointer is entering in the first position
       * @param pointerX Position of the user's pointer along the X axis.
       * @param pointerY Position of the user's pointer along the Y axis.
       */
      _shouldEnterAsFirstChild(pointerX, pointerY) {
        if (!this._activeDraggables.length) {
          return false;
        }
        const itemPositions = this._itemPositions;
        const isHorizontal = this.orientation === "horizontal";
        const reversed = itemPositions[0].drag !== this._activeDraggables[0];
        if (reversed) {
          const lastItemRect = itemPositions[itemPositions.length - 1].clientRect;
          return isHorizontal ? pointerX >= lastItemRect.right : pointerY >= lastItemRect.bottom;
        } else {
          const firstItemRect = itemPositions[0].clientRect;
          return isHorizontal ? pointerX <= firstItemRect.left : pointerY <= firstItemRect.top;
        }
      }
      /**
       * Gets the index of an item in the drop container, based on the position of the user's pointer.
       * @param item Item that is being sorted.
       * @param pointerX Position of the user's pointer along the X axis.
       * @param pointerY Position of the user's pointer along the Y axis.
       * @param delta Direction in which the user is moving their pointer.
       */
      _getItemIndexFromPointerPosition(item, pointerX, pointerY, delta) {
        const isHorizontal = this.orientation === "horizontal";
        const index = this._itemPositions.findIndex(({
          drag,
          clientRect
        }) => {
          if (drag === item) {
            return false;
          }
          if (delta) {
            const direction = isHorizontal ? delta.x : delta.y;
            if (drag === this._previousSwap.drag && this._previousSwap.overlaps && direction === this._previousSwap.delta) {
              return false;
            }
          }
          return isHorizontal ? (
            // Round these down since most browsers report client rects with
            // sub-pixel precision, whereas the pointer coordinates are rounded to pixels.
            pointerX >= Math.floor(clientRect.left) && pointerX < Math.floor(clientRect.right)
          ) : pointerY >= Math.floor(clientRect.top) && pointerY < Math.floor(clientRect.bottom);
        });
        return index === -1 || !this._sortPredicate(index, item) ? -1 : index;
      }
    };
    MixedSortStrategy = class {
      _document;
      _dragDropRegistry;
      /** Root element container of the drop list. */
      _element;
      /** Function used to determine if an item can be sorted into a specific index. */
      _sortPredicate;
      /** Lazily-resolved root node containing the list. Use `_getRootNode` to read this. */
      _rootNode;
      /**
       * Draggable items that are currently active inside the container. Includes the items
       * that were there at the start of the sequence, as well as any items that have been dragged
       * in, but haven't been dropped yet.
       */
      _activeItems;
      /**
       * Keeps track of the item that was last swapped with the dragged item, as well as what direction
       * the pointer was moving in when the swap occurred and whether the user's pointer continued to
       * overlap with the swapped item after the swapping occurred.
       */
      _previousSwap = {
        drag: null,
        deltaX: 0,
        deltaY: 0,
        overlaps: false
      };
      /**
       * Keeps track of the relationship between a node and its next sibling. This information
       * is used to restore the DOM to the order it was in before dragging started.
       */
      _relatedNodes = [];
      constructor(_document2, _dragDropRegistry) {
        this._document = _document2;
        this._dragDropRegistry = _dragDropRegistry;
      }
      /**
       * To be called when the drag sequence starts.
       * @param items Items that are currently in the list.
       */
      start(items) {
        const childNodes = this._element.childNodes;
        this._relatedNodes = [];
        for (let i2 = 0; i2 < childNodes.length; i2++) {
          const node = childNodes[i2];
          this._relatedNodes.push([node, node.nextSibling]);
        }
        this.withItems(items);
      }
      /**
       * To be called when an item is being sorted.
       * @param item Item to be sorted.
       * @param pointerX Position of the item along the X axis.
       * @param pointerY Position of the item along the Y axis.
       * @param pointerDelta Direction in which the pointer is moving along each axis.
       */
      sort(item, pointerX, pointerY, pointerDelta) {
        const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY);
        const previousSwap = this._previousSwap;
        if (newIndex === -1 || this._activeItems[newIndex] === item) {
          return null;
        }
        const toSwapWith = this._activeItems[newIndex];
        if (previousSwap.drag === toSwapWith && previousSwap.overlaps && previousSwap.deltaX === pointerDelta.x && previousSwap.deltaY === pointerDelta.y) {
          return null;
        }
        const previousIndex = this.getItemIndex(item);
        const current = item.getPlaceholderElement();
        const overlapElement = toSwapWith.getRootElement();
        if (newIndex > previousIndex) {
          overlapElement.after(current);
        } else {
          overlapElement.before(current);
        }
        moveItemInArray(this._activeItems, previousIndex, newIndex);
        const newOverlapElement = this._getRootNode().elementFromPoint(pointerX, pointerY);
        previousSwap.deltaX = pointerDelta.x;
        previousSwap.deltaY = pointerDelta.y;
        previousSwap.drag = toSwapWith;
        previousSwap.overlaps = overlapElement === newOverlapElement || overlapElement.contains(newOverlapElement);
        return {
          previousIndex,
          currentIndex: newIndex
        };
      }
      /**
       * Called when an item is being moved into the container.
       * @param item Item that was moved into the container.
       * @param pointerX Position of the item along the X axis.
       * @param pointerY Position of the item along the Y axis.
       * @param index Index at which the item entered. If omitted, the container will try to figure it
       *   out automatically.
       */
      enter(item, pointerX, pointerY, index) {
        const currentIndex = this._activeItems.indexOf(item);
        if (currentIndex > -1) {
          this._activeItems.splice(currentIndex, 1);
        }
        let enterIndex = index == null || index < 0 ? this._getItemIndexFromPointerPosition(item, pointerX, pointerY) : index;
        if (enterIndex === -1) {
          enterIndex = this._getClosestItemIndexToPointer(item, pointerX, pointerY);
        }
        const targetItem = this._activeItems[enterIndex];
        if (targetItem && !this._dragDropRegistry.isDragging(targetItem)) {
          this._activeItems.splice(enterIndex, 0, item);
          targetItem.getRootElement().before(item.getPlaceholderElement());
        } else {
          this._activeItems.push(item);
          this._element.appendChild(item.getPlaceholderElement());
        }
      }
      /** Sets the items that are currently part of the list. */
      withItems(items) {
        this._activeItems = items.slice();
      }
      /** Assigns a sort predicate to the strategy. */
      withSortPredicate(predicate) {
        this._sortPredicate = predicate;
      }
      /** Resets the strategy to its initial state before dragging was started. */
      reset() {
        const root = this._element;
        const previousSwap = this._previousSwap;
        for (let i2 = this._relatedNodes.length - 1; i2 > -1; i2--) {
          const [node, nextSibling] = this._relatedNodes[i2];
          if (node.parentNode === root && node.nextSibling !== nextSibling) {
            if (nextSibling === null) {
              root.appendChild(node);
            } else if (nextSibling.parentNode === root) {
              root.insertBefore(node, nextSibling);
            }
          }
        }
        this._relatedNodes = [];
        this._activeItems = [];
        previousSwap.drag = null;
        previousSwap.deltaX = previousSwap.deltaY = 0;
        previousSwap.overlaps = false;
      }
      /**
       * Gets a snapshot of items currently in the list.
       * Can include items that we dragged in from another list.
       */
      getActiveItemsSnapshot() {
        return this._activeItems;
      }
      /** Gets the index of a specific item. */
      getItemIndex(item) {
        return this._activeItems.indexOf(item);
      }
      /** Gets the item at a specific index. */
      getItemAtIndex(index) {
        return this._activeItems[index] || null;
      }
      /** Used to notify the strategy that the scroll position has changed. */
      updateOnScroll() {
        this._activeItems.forEach((item) => {
          if (this._dragDropRegistry.isDragging(item)) {
            item._sortFromLastPointerPosition();
          }
        });
      }
      withElementContainer(container) {
        if (container !== this._element) {
          this._element = container;
          this._rootNode = void 0;
        }
      }
      /**
       * Gets the index of an item in the drop container, based on the position of the user's pointer.
       * @param item Item that is being sorted.
       * @param pointerX Position of the user's pointer along the X axis.
       * @param pointerY Position of the user's pointer along the Y axis.
       * @param delta Direction in which the user is moving their pointer.
       */
      _getItemIndexFromPointerPosition(item, pointerX, pointerY) {
        const elementAtPoint = this._getRootNode().elementFromPoint(Math.floor(pointerX), Math.floor(pointerY));
        const index = elementAtPoint ? this._activeItems.findIndex((item2) => {
          const root = item2.getRootElement();
          return elementAtPoint === root || root.contains(elementAtPoint);
        }) : -1;
        return index === -1 || !this._sortPredicate(index, item) ? -1 : index;
      }
      /** Lazily resolves the list's root node. */
      _getRootNode() {
        if (!this._rootNode) {
          this._rootNode = _getShadowRoot(this._element) || this._document;
        }
        return this._rootNode;
      }
      /**
       * Finds the index of the item that's closest to the item being dragged.
       * @param item Item being dragged.
       * @param pointerX Position of the user's pointer along the X axis.
       * @param pointerY Position of the user's pointer along the Y axis.
       */
      _getClosestItemIndexToPointer(item, pointerX, pointerY) {
        if (this._activeItems.length === 0) {
          return -1;
        }
        if (this._activeItems.length === 1) {
          return 0;
        }
        let minDistance = Infinity;
        let minIndex = -1;
        for (let i2 = 0; i2 < this._activeItems.length; i2++) {
          const current = this._activeItems[i2];
          if (current !== item) {
            const {
              x: x2,
              y: y2
            } = current.getRootElement().getBoundingClientRect();
            const distance = Math.hypot(pointerX - x2, pointerY - y2);
            if (distance < minDistance) {
              minDistance = distance;
              minIndex = i2;
            }
          }
        }
        return minIndex;
      }
    };
    DROP_PROXIMITY_THRESHOLD = 0.05;
    SCROLL_PROXIMITY_THRESHOLD = 0.05;
    (function(AutoScrollVerticalDirection2) {
      AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["NONE"] = 0] = "NONE";
      AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["UP"] = 1] = "UP";
      AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["DOWN"] = 2] = "DOWN";
    })(AutoScrollVerticalDirection || (AutoScrollVerticalDirection = {}));
    (function(AutoScrollHorizontalDirection2) {
      AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["NONE"] = 0] = "NONE";
      AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["LEFT"] = 1] = "LEFT";
      AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["RIGHT"] = 2] = "RIGHT";
    })(AutoScrollHorizontalDirection || (AutoScrollHorizontalDirection = {}));
    DropListRef = class {
      _dragDropRegistry;
      _ngZone;
      _viewportRuler;
      /** Element that the drop list is attached to. */
      element;
      /** Whether starting a dragging sequence from this container is disabled. */
      disabled = false;
      /** Whether sorting items within the list is disabled. */
      sortingDisabled = false;
      /** Locks the position of the draggable elements inside the container along the specified axis. */
      lockAxis;
      /**
       * Whether auto-scrolling the view when the user
       * moves their pointer close to the edges is disabled.
       */
      autoScrollDisabled = false;
      /** Number of pixels to scroll for each frame when auto-scrolling an element. */
      autoScrollStep = 2;
      /**
       * Whether the items in the list should leave an anchor node when leaving the initial container.
       */
      hasAnchor = false;
      /**
       * Function that is used to determine whether an item
       * is allowed to be moved into a drop container.
       */
      enterPredicate = () => true;
      /** Function that is used to determine whether an item can be sorted into a particular index. */
      sortPredicate = () => true;
      /** Emits right before dragging has started. */
      beforeStarted = new Subject();
      /**
       * Emits when the user has moved a new drag item into this container.
       */
      entered = new Subject();
      /**
       * Emits when the user removes an item from the container
       * by dragging it into another container.
       */
      exited = new Subject();
      /** Emits when the user drops an item inside the container. */
      dropped = new Subject();
      /** Emits as the user is swapping items while actively dragging. */
      sorted = new Subject();
      /** Emits when a dragging sequence is started in a list connected to the current one. */
      receivingStarted = new Subject();
      /** Emits when a dragging sequence is stopped from a list connected to the current one. */
      receivingStopped = new Subject();
      /** Arbitrary data that can be attached to the drop list. */
      data;
      /** Element that is the direct parent of the drag items. */
      _container;
      /** Whether an item in the list is being dragged. */
      _isDragging = false;
      /** Keeps track of the positions of any parent scrollable elements. */
      _parentPositions;
      /** Strategy being used to sort items within the list. */
      _sortStrategy;
      /** Cached `DOMRect` of the drop list. */
      _domRect;
      /** Draggable items in the container. */
      _draggables = [];
      /** Drop lists that are connected to the current one. */
      _siblings = [];
      /** Connected siblings that currently have a dragged item. */
      _activeSiblings = /* @__PURE__ */ new Set();
      /** Subscription to the window being scrolled. */
      _viewportScrollSubscription = Subscription.EMPTY;
      /** Vertical direction in which the list is currently scrolling. */
      _verticalScrollDirection = AutoScrollVerticalDirection.NONE;
      /** Horizontal direction in which the list is currently scrolling. */
      _horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
      /** Node that is being auto-scrolled. */
      _scrollNode;
      /** Used to signal to the current auto-scroll sequence when to stop. */
      _stopScrollTimers = new Subject();
      /** Shadow root of the current element. Necessary for `elementFromPoint` to resolve correctly. */
      _cachedShadowRoot = null;
      /** Reference to the document. */
      _document;
      /** Elements that can be scrolled while the user is dragging. */
      _scrollableElements = [];
      /** Initial value for the element's `scroll-snap-type` style. */
      _initialScrollSnap;
      /** Direction of the list's layout. */
      _direction = "ltr";
      constructor(element, _dragDropRegistry, _document2, _ngZone, _viewportRuler) {
        this._dragDropRegistry = _dragDropRegistry;
        this._ngZone = _ngZone;
        this._viewportRuler = _viewportRuler;
        const coercedElement = this.element = coerceElement(element);
        this._document = _document2;
        this.withOrientation("vertical").withElementContainer(coercedElement);
        _dragDropRegistry.registerDropContainer(this);
        this._parentPositions = new ParentPositionTracker(_document2);
      }
      /** Removes the drop list functionality from the DOM element. */
      dispose() {
        this._stopScrolling();
        this._stopScrollTimers.complete();
        this._viewportScrollSubscription.unsubscribe();
        this.beforeStarted.complete();
        this.entered.complete();
        this.exited.complete();
        this.dropped.complete();
        this.sorted.complete();
        this.receivingStarted.complete();
        this.receivingStopped.complete();
        this._activeSiblings.clear();
        this._scrollNode = null;
        this._parentPositions.clear();
        this._dragDropRegistry.removeDropContainer(this);
      }
      /** Whether an item from this list is currently being dragged. */
      isDragging() {
        return this._isDragging;
      }
      /** Starts dragging an item. */
      start() {
        this._draggingStarted();
        this._notifyReceivingSiblings();
      }
      /**
       * Attempts to move an item into the container.
       * @param item Item that was moved into the container.
       * @param pointerX Position of the item along the X axis.
       * @param pointerY Position of the item along the Y axis.
       * @param index Index at which the item entered. If omitted, the container will try to figure it
       *   out automatically.
       */
      enter(item, pointerX, pointerY, index) {
        this._draggingStarted();
        if (index == null && this.sortingDisabled) {
          index = this._draggables.indexOf(item);
        }
        this._sortStrategy.enter(item, pointerX, pointerY, index);
        this._cacheParentPositions();
        this._notifyReceivingSiblings();
        this.entered.next({
          item,
          container: this,
          currentIndex: this.getItemIndex(item)
        });
      }
      /**
       * Removes an item from the container after it was dragged into another container by the user.
       * @param item Item that was dragged out.
       */
      exit(item) {
        this._reset();
        this.exited.next({
          item,
          container: this
        });
      }
      /**
       * Drops an item into this container.
       * @param item Item being dropped into the container.
       * @param currentIndex Index at which the item should be inserted.
       * @param previousIndex Index of the item when dragging started.
       * @param previousContainer Container from which the item got dragged in.
       * @param isPointerOverContainer Whether the user's pointer was over the
       *    container when the item was dropped.
       * @param distance Distance the user has dragged since the start of the dragging sequence.
       * @param event Event that triggered the dropping sequence.
       *
       * @breaking-change 15.0.0 `previousIndex` and `event` parameters to become required.
       */
      drop(item, currentIndex, previousIndex, previousContainer, isPointerOverContainer, distance, dropPoint, event = {}) {
        this._reset();
        this.dropped.next({
          item,
          currentIndex,
          previousIndex,
          container: this,
          previousContainer,
          isPointerOverContainer,
          distance,
          dropPoint,
          event
        });
      }
      /**
       * Sets the draggable items that are a part of this list.
       * @param items Items that are a part of this list.
       */
      withItems(items) {
        const previousItems = this._draggables;
        this._draggables = items;
        items.forEach((item) => item._withDropContainer(this));
        if (this.isDragging()) {
          const draggedItems = previousItems.filter((item) => item.isDragging());
          if (draggedItems.every((item) => items.indexOf(item) === -1)) {
            this._reset();
          } else {
            this._sortStrategy.withItems(this._draggables);
          }
        }
        return this;
      }
      /** Sets the layout direction of the drop list. */
      withDirection(direction) {
        this._direction = direction;
        if (this._sortStrategy instanceof SingleAxisSortStrategy) {
          this._sortStrategy.direction = direction;
        }
        return this;
      }
      /**
       * Sets the containers that are connected to this one. When two or more containers are
       * connected, the user will be allowed to transfer items between them.
       * @param connectedTo Other containers that the current containers should be connected to.
       */
      connectedTo(connectedTo) {
        this._siblings = connectedTo.slice();
        return this;
      }
      /**
       * Sets the orientation of the container.
       * @param orientation New orientation for the container.
       */
      withOrientation(orientation) {
        if (orientation === "mixed") {
          this._sortStrategy = new MixedSortStrategy(this._document, this._dragDropRegistry);
        } else {
          const strategy = new SingleAxisSortStrategy(this._dragDropRegistry);
          strategy.direction = this._direction;
          strategy.orientation = orientation;
          this._sortStrategy = strategy;
        }
        this._sortStrategy.withElementContainer(this._container);
        this._sortStrategy.withSortPredicate((index, item) => this.sortPredicate(index, item, this));
        return this;
      }
      /**
       * Sets which parent elements are can be scrolled while the user is dragging.
       * @param elements Elements that can be scrolled.
       */
      withScrollableParents(elements) {
        const element = this._container;
        this._scrollableElements = elements.indexOf(element) === -1 ? [element, ...elements] : elements.slice();
        return this;
      }
      /**
       * Configures the drop list so that a different element is used as the container for the
       * dragged items. This is useful for the cases when one might not have control over the
       * full DOM that sets up the dragging.
       * Note that the alternate container needs to be a descendant of the drop list.
       * @param container New element container to be assigned.
       */
      withElementContainer(container) {
        if (container === this._container) {
          return this;
        }
        const element = coerceElement(this.element);
        if ((typeof ngDevMode === "undefined" || ngDevMode) && container !== element && !element.contains(container)) {
          throw new Error("Invalid DOM structure for drop list. Alternate container element must be a descendant of the drop list.");
        }
        const oldContainerIndex = this._scrollableElements.indexOf(this._container);
        const newContainerIndex = this._scrollableElements.indexOf(container);
        if (oldContainerIndex > -1) {
          this._scrollableElements.splice(oldContainerIndex, 1);
        }
        if (newContainerIndex > -1) {
          this._scrollableElements.splice(newContainerIndex, 1);
        }
        if (this._sortStrategy) {
          this._sortStrategy.withElementContainer(container);
        }
        this._cachedShadowRoot = null;
        this._scrollableElements.unshift(container);
        this._container = container;
        return this;
      }
      /** Gets the scrollable parents that are registered with this drop container. */
      getScrollableParents() {
        return this._scrollableElements;
      }
      /**
       * Figures out the index of an item in the container.
       * @param item Item whose index should be determined.
       */
      getItemIndex(item) {
        return this._isDragging ? this._sortStrategy.getItemIndex(item) : this._draggables.indexOf(item);
      }
      /**
       * Gets the item at a specific index.
       * @param index Index at which to retrieve the item.
       */
      getItemAtIndex(index) {
        return this._isDragging ? this._sortStrategy.getItemAtIndex(index) : this._draggables[index] || null;
      }
      /**
       * Whether the list is able to receive the item that
       * is currently being dragged inside a connected drop list.
       */
      isReceiving() {
        return this._activeSiblings.size > 0;
      }
      /**
       * Sorts an item inside the container based on its position.
       * @param item Item to be sorted.
       * @param pointerX Position of the item along the X axis.
       * @param pointerY Position of the item along the Y axis.
       * @param pointerDelta Direction in which the pointer is moving along each axis.
       */
      _sortItem(item, pointerX, pointerY, pointerDelta) {
        if (this.sortingDisabled || !this._domRect || !isPointerNearDomRect(this._domRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {
          return;
        }
        const result = this._sortStrategy.sort(item, pointerX, pointerY, pointerDelta);
        if (result) {
          this.sorted.next({
            previousIndex: result.previousIndex,
            currentIndex: result.currentIndex,
            container: this,
            item
          });
        }
      }
      /**
       * Checks whether the user's pointer is close to the edges of either the
       * viewport or the drop list and starts the auto-scroll sequence.
       * @param pointerX User's pointer position along the x axis.
       * @param pointerY User's pointer position along the y axis.
       */
      _startScrollingIfNecessary(pointerX, pointerY) {
        if (this.autoScrollDisabled) {
          return;
        }
        let scrollNode;
        let verticalScrollDirection = AutoScrollVerticalDirection.NONE;
        let horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
        this._parentPositions.positions.forEach((position, element) => {
          if (element === this._document || !position.clientRect || scrollNode) {
            return;
          }
          if (isPointerNearDomRect(position.clientRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {
            [verticalScrollDirection, horizontalScrollDirection] = getElementScrollDirections(element, position.clientRect, this._direction, pointerX, pointerY);
            if (verticalScrollDirection || horizontalScrollDirection) {
              scrollNode = element;
            }
          }
        });
        if (!verticalScrollDirection && !horizontalScrollDirection) {
          const {
            width,
            height
          } = this._viewportRuler.getViewportSize();
          const domRect = {
            width,
            height,
            top: 0,
            right: width,
            bottom: height,
            left: 0
          };
          verticalScrollDirection = getVerticalScrollDirection(domRect, pointerY);
          horizontalScrollDirection = getHorizontalScrollDirection(domRect, pointerX);
          scrollNode = window;
        }
        if (scrollNode && (verticalScrollDirection !== this._verticalScrollDirection || horizontalScrollDirection !== this._horizontalScrollDirection || scrollNode !== this._scrollNode)) {
          this._verticalScrollDirection = verticalScrollDirection;
          this._horizontalScrollDirection = horizontalScrollDirection;
          this._scrollNode = scrollNode;
          if ((verticalScrollDirection || horizontalScrollDirection) && scrollNode) {
            this._ngZone.runOutsideAngular(this._startScrollInterval);
          } else {
            this._stopScrolling();
          }
        }
      }
      /** Stops any currently-running auto-scroll sequences. */
      _stopScrolling() {
        this._stopScrollTimers.next();
      }
      /** Starts the dragging sequence within the list. */
      _draggingStarted() {
        const styles = this._container.style;
        this.beforeStarted.next();
        this._isDragging = true;
        if ((typeof ngDevMode === "undefined" || ngDevMode) && // Prevent the check from running on apps not using an alternate container. Ideally we
        // would always run it, but introducing it at this stage would be a breaking change.
        this._container !== coerceElement(this.element)) {
          for (const drag of this._draggables) {
            if (!drag.isDragging() && drag.getVisibleElement().parentNode !== this._container) {
              throw new Error("Invalid DOM structure for drop list. All items must be placed directly inside of the element container.");
            }
          }
        }
        this._initialScrollSnap = styles.msScrollSnapType || styles.scrollSnapType || "";
        styles.scrollSnapType = styles.msScrollSnapType = "none";
        this._sortStrategy.start(this._draggables);
        this._cacheParentPositions();
        this._viewportScrollSubscription.unsubscribe();
        this._listenToScrollEvents();
      }
      /** Caches the positions of the configured scrollable parents. */
      _cacheParentPositions() {
        this._parentPositions.cache(this._scrollableElements);
        this._domRect = this._parentPositions.positions.get(this._container).clientRect;
      }
      /** Resets the container to its initial state. */
      _reset() {
        this._isDragging = false;
        const styles = this._container.style;
        styles.scrollSnapType = styles.msScrollSnapType = this._initialScrollSnap;
        this._siblings.forEach((sibling) => sibling._stopReceiving(this));
        this._sortStrategy.reset();
        this._stopScrolling();
        this._viewportScrollSubscription.unsubscribe();
        this._parentPositions.clear();
      }
      /** Starts the interval that'll auto-scroll the element. */
      _startScrollInterval = () => {
        this._stopScrolling();
        interval(0, animationFrameScheduler).pipe(takeUntil(this._stopScrollTimers)).subscribe(() => {
          const node = this._scrollNode;
          const scrollStep = this.autoScrollStep;
          if (this._verticalScrollDirection === AutoScrollVerticalDirection.UP) {
            node.scrollBy(0, -scrollStep);
          } else if (this._verticalScrollDirection === AutoScrollVerticalDirection.DOWN) {
            node.scrollBy(0, scrollStep);
          }
          if (this._horizontalScrollDirection === AutoScrollHorizontalDirection.LEFT) {
            node.scrollBy(-scrollStep, 0);
          } else if (this._horizontalScrollDirection === AutoScrollHorizontalDirection.RIGHT) {
            node.scrollBy(scrollStep, 0);
          }
        });
      };
      /**
       * Checks whether the user's pointer is positioned over the container.
       * @param x Pointer position along the X axis.
       * @param y Pointer position along the Y axis.
       */
      _isOverContainer(x2, y2) {
        return this._domRect != null && isInsideClientRect(this._domRect, x2, y2);
      }
      /**
       * Figures out whether an item should be moved into a sibling
       * drop container, based on its current position.
       * @param item Drag item that is being moved.
       * @param x Position of the item along the X axis.
       * @param y Position of the item along the Y axis.
       */
      _getSiblingContainerFromPosition(item, x2, y2) {
        return this._siblings.find((sibling) => sibling._canReceive(item, x2, y2));
      }
      /**
       * Checks whether the drop list can receive the passed-in item.
       * @param item Item that is being dragged into the list.
       * @param x Position of the item along the X axis.
       * @param y Position of the item along the Y axis.
       */
      _canReceive(item, x2, y2) {
        if (!this._domRect || !isInsideClientRect(this._domRect, x2, y2) || !this.enterPredicate(item, this)) {
          return false;
        }
        const elementFromPoint = this._getShadowRoot().elementFromPoint(x2, y2);
        if (!elementFromPoint) {
          return false;
        }
        return elementFromPoint === this._container || this._container.contains(elementFromPoint);
      }
      /**
       * Called by one of the connected drop lists when a dragging sequence has started.
       * @param sibling Sibling in which dragging has started.
       */
      _startReceiving(sibling, items) {
        const activeSiblings = this._activeSiblings;
        if (!activeSiblings.has(sibling) && items.every((item) => {
          return this.enterPredicate(item, this) || this._draggables.indexOf(item) > -1;
        })) {
          activeSiblings.add(sibling);
          this._cacheParentPositions();
          this._listenToScrollEvents();
          this.receivingStarted.next({
            initiator: sibling,
            receiver: this,
            items
          });
        }
      }
      /**
       * Called by a connected drop list when dragging has stopped.
       * @param sibling Sibling whose dragging has stopped.
       */
      _stopReceiving(sibling) {
        this._activeSiblings.delete(sibling);
        this._viewportScrollSubscription.unsubscribe();
        this.receivingStopped.next({
          initiator: sibling,
          receiver: this
        });
      }
      /**
       * Starts listening to scroll events on the viewport.
       * Used for updating the internal state of the list.
       */
      _listenToScrollEvents() {
        this._viewportScrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe((event) => {
          if (this.isDragging()) {
            const scrollDifference = this._parentPositions.handleScroll(event);
            if (scrollDifference) {
              this._sortStrategy.updateOnScroll(scrollDifference.top, scrollDifference.left);
            }
          } else if (this.isReceiving()) {
            this._cacheParentPositions();
          }
        });
      }
      /**
       * Lazily resolves and returns the shadow root of the element. We do this in a function, rather
       * than saving it in property directly on init, because we want to resolve it as late as possible
       * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the
       * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.
       */
      _getShadowRoot() {
        if (!this._cachedShadowRoot) {
          const shadowRoot = _getShadowRoot(this._container);
          this._cachedShadowRoot = shadowRoot || this._document;
        }
        return this._cachedShadowRoot;
      }
      /** Notifies any siblings that may potentially receive the item. */
      _notifyReceivingSiblings() {
        const draggedItems = this._sortStrategy.getActiveItemsSnapshot().filter((item) => item.isDragging());
        this._siblings.forEach((sibling) => sibling._startReceiving(this, draggedItems));
      }
    };
    capturingEventOptions = {
      capture: true
    };
    activeCapturingEventOptions = {
      passive: false,
      capture: true
    };
    _ResetsLoader = class __ResetsLoader {
      static \u0275fac = function _ResetsLoader_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || __ResetsLoader)();
      };
      static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
        type: __ResetsLoader,
        selectors: [["ng-component"]],
        hostAttrs: ["cdk-drag-resets-container", ""],
        decls: 0,
        vars: 0,
        template: function _ResetsLoader_Template(rf2, ctx) {
        },
        styles: ["@layer cdk-resets{.cdk-drag-preview{background:none;border:none;padding:0;color:inherit;inset:auto}}.cdk-drag-placeholder *,.cdk-drag-preview *{pointer-events:none !important}\n"],
        encapsulation: 2,
        changeDetection: 0
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_ResetsLoader, [{
        type: Component,
        args: [{
          encapsulation: ViewEncapsulation.None,
          template: "",
          changeDetection: ChangeDetectionStrategy.OnPush,
          host: {
            "cdk-drag-resets-container": ""
          },
          styles: ["@layer cdk-resets{.cdk-drag-preview{background:none;border:none;padding:0;color:inherit;inset:auto}}.cdk-drag-placeholder *,.cdk-drag-preview *{pointer-events:none !important}\n"]
        }]
      }], null, null);
    })();
    DragDropRegistry = class _DragDropRegistry {
      _ngZone = inject2(NgZone);
      _document = inject2(DOCUMENT);
      _styleLoader = inject2(_CdkPrivateStyleLoader);
      _renderer = inject2(RendererFactory2).createRenderer(null, null);
      _cleanupDocumentTouchmove;
      _scroll = new Subject();
      /** Registered drop container instances. */
      _dropInstances = /* @__PURE__ */ new Set();
      /** Registered drag item instances. */
      _dragInstances = /* @__PURE__ */ new Set();
      /** Drag item instances that are currently being dragged. */
      _activeDragInstances = signal([], ...ngDevMode ? [{
        debugName: "_activeDragInstances"
      }] : []);
      /** Keeps track of the event listeners that we've bound to the `document`. */
      _globalListeners;
      /**
       * Predicate function to check if an item is being dragged.  Moved out into a property,
       * because it'll be called a lot and we don't want to create a new function every time.
       */
      _draggingPredicate = (item) => item.isDragging();
      /**
       * Map tracking DOM nodes and their corresponding drag directives. Note that this is different
       * from looking through the `_dragInstances` and getting their root node, because the root node
       * isn't necessarily the node that the directive is set on.
       */
      _domNodesToDirectives = null;
      /**
       * Emits the `touchmove` or `mousemove` events that are dispatched
       * while the user is dragging a drag item instance.
       */
      pointerMove = new Subject();
      /**
       * Emits the `touchend` or `mouseup` events that are dispatched
       * while the user is dragging a drag item instance.
       */
      pointerUp = new Subject();
      constructor() {
      }
      /** Adds a drop container to the registry. */
      registerDropContainer(drop) {
        if (!this._dropInstances.has(drop)) {
          this._dropInstances.add(drop);
        }
      }
      /** Adds a drag item instance to the registry. */
      registerDragItem(drag) {
        this._dragInstances.add(drag);
        if (this._dragInstances.size === 1) {
          this._ngZone.runOutsideAngular(() => {
            this._cleanupDocumentTouchmove?.();
            this._cleanupDocumentTouchmove = this._renderer.listen(this._document, "touchmove", this._persistentTouchmoveListener, activeCapturingEventOptions);
          });
        }
      }
      /** Removes a drop container from the registry. */
      removeDropContainer(drop) {
        this._dropInstances.delete(drop);
      }
      /** Removes a drag item instance from the registry. */
      removeDragItem(drag) {
        this._dragInstances.delete(drag);
        this.stopDragging(drag);
        if (this._dragInstances.size === 0) {
          this._cleanupDocumentTouchmove?.();
        }
      }
      /**
       * Starts the dragging sequence for a drag instance.
       * @param drag Drag instance which is being dragged.
       * @param event Event that initiated the dragging.
       */
      startDragging(drag, event) {
        if (this._activeDragInstances().indexOf(drag) > -1) {
          return;
        }
        this._styleLoader.load(_ResetsLoader);
        this._activeDragInstances.update((instances) => [...instances, drag]);
        if (this._activeDragInstances().length === 1) {
          const isTouchEvent2 = event.type.startsWith("touch");
          const endEventHandler = (e2) => this.pointerUp.next(e2);
          const toBind = [
            // Use capturing so that we pick up scroll changes in any scrollable nodes that aren't
            // the document. See https://github.com/angular/components/issues/17144.
            ["scroll", (e2) => this._scroll.next(e2), capturingEventOptions],
            // Preventing the default action on `mousemove` isn't enough to disable text selection
            // on Safari so we need to prevent the selection event as well. Alternatively this can
            // be done by setting `user-select: none` on the `body`, however it has causes a style
            // recalculation which can be expensive on pages with a lot of elements.
            ["selectstart", this._preventDefaultWhileDragging, activeCapturingEventOptions]
          ];
          if (isTouchEvent2) {
            toBind.push(["touchend", endEventHandler, capturingEventOptions], ["touchcancel", endEventHandler, capturingEventOptions]);
          } else {
            toBind.push(["mouseup", endEventHandler, capturingEventOptions]);
          }
          if (!isTouchEvent2) {
            toBind.push(["mousemove", (e2) => this.pointerMove.next(e2), activeCapturingEventOptions]);
          }
          this._ngZone.runOutsideAngular(() => {
            this._globalListeners = toBind.map(([name, handler, options]) => this._renderer.listen(this._document, name, handler, options));
          });
        }
      }
      /** Stops dragging a drag item instance. */
      stopDragging(drag) {
        this._activeDragInstances.update((instances) => {
          const index = instances.indexOf(drag);
          if (index > -1) {
            instances.splice(index, 1);
            return [...instances];
          }
          return instances;
        });
        if (this._activeDragInstances().length === 0) {
          this._clearGlobalListeners();
        }
      }
      /** Gets whether a drag item instance is currently being dragged. */
      isDragging(drag) {
        return this._activeDragInstances().indexOf(drag) > -1;
      }
      /**
       * Gets a stream that will emit when any element on the page is scrolled while an item is being
       * dragged.
       * @param shadowRoot Optional shadow root that the current dragging sequence started from.
       *   Top-level listeners won't pick up events coming from the shadow DOM so this parameter can
       *   be used to include an additional top-level listener at the shadow root level.
       */
      scrolled(shadowRoot) {
        const streams = [this._scroll];
        if (shadowRoot && shadowRoot !== this._document) {
          streams.push(new Observable((observer) => {
            return this._ngZone.runOutsideAngular(() => {
              const cleanup = this._renderer.listen(shadowRoot, "scroll", (event) => {
                if (this._activeDragInstances().length) {
                  observer.next(event);
                }
              }, capturingEventOptions);
              return () => {
                cleanup();
              };
            });
          }));
        }
        return merge(...streams);
      }
      /**
       * Tracks the DOM node which has a draggable directive.
       * @param node Node to track.
       * @param dragRef Drag directive set on the node.
       */
      registerDirectiveNode(node, dragRef) {
        this._domNodesToDirectives ??= /* @__PURE__ */ new WeakMap();
        this._domNodesToDirectives.set(node, dragRef);
      }
      /**
       * Stops tracking a draggable directive node.
       * @param node Node to stop tracking.
       */
      removeDirectiveNode(node) {
        this._domNodesToDirectives?.delete(node);
      }
      /**
       * Gets the drag directive corresponding to a specific DOM node, if any.
       * @param node Node for which to do the lookup.
       */
      getDragDirectiveForNode(node) {
        return this._domNodesToDirectives?.get(node) || null;
      }
      ngOnDestroy() {
        this._dragInstances.forEach((instance) => this.removeDragItem(instance));
        this._dropInstances.forEach((instance) => this.removeDropContainer(instance));
        this._domNodesToDirectives = null;
        this._clearGlobalListeners();
        this.pointerMove.complete();
        this.pointerUp.complete();
      }
      /**
       * Event listener that will prevent the default browser action while the user is dragging.
       * @param event Event whose default action should be prevented.
       */
      _preventDefaultWhileDragging = (event) => {
        if (this._activeDragInstances().length > 0) {
          event.preventDefault();
        }
      };
      /** Event listener for `touchmove` that is bound even if no dragging is happening. */
      _persistentTouchmoveListener = (event) => {
        if (this._activeDragInstances().length > 0) {
          if (this._activeDragInstances().some(this._draggingPredicate)) {
            event.preventDefault();
          }
          this.pointerMove.next(event);
        }
      };
      /** Clears out the global event listeners from the `document`. */
      _clearGlobalListeners() {
        this._globalListeners?.forEach((cleanup) => cleanup());
        this._globalListeners = void 0;
      }
      static \u0275fac = function DragDropRegistry_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DragDropRegistry)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _DragDropRegistry,
        factory: _DragDropRegistry.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDropRegistry, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [], null);
    })();
    DEFAULT_CONFIG = {
      dragStartThreshold: 5,
      pointerDirectionChangeThreshold: 5
    };
    DragDrop = class _DragDrop {
      _document = inject2(DOCUMENT);
      _ngZone = inject2(NgZone);
      _viewportRuler = inject2(ViewportRuler);
      _dragDropRegistry = inject2(DragDropRegistry);
      _renderer = inject2(RendererFactory2).createRenderer(null, null);
      constructor() {
      }
      /**
       * Turns an element into a draggable item.
       * @param element Element to which to attach the dragging functionality.
       * @param config Object used to configure the dragging behavior.
       */
      createDrag(element, config2 = DEFAULT_CONFIG) {
        return new DragRef(element, config2, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry, this._renderer);
      }
      /**
       * Turns an element into a drop list.
       * @param element Element to which to attach the drop list functionality.
       */
      createDropList(element) {
        return new DropListRef(element, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler);
      }
      static \u0275fac = function DragDrop_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DragDrop)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _DragDrop,
        factory: _DragDrop.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDrop, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [], null);
    })();
    CDK_DRAG_PARENT = new InjectionToken("CDK_DRAG_PARENT");
    CDK_DRAG_HANDLE = new InjectionToken("CdkDragHandle");
    CdkDragHandle = class _CdkDragHandle {
      element = inject2(ElementRef);
      _parentDrag = inject2(CDK_DRAG_PARENT, {
        optional: true,
        skipSelf: true
      });
      _dragDropRegistry = inject2(DragDropRegistry);
      /** Emits when the state of the handle has changed. */
      _stateChanges = new Subject();
      /** Whether starting to drag through this handle is disabled. */
      get disabled() {
        return this._disabled;
      }
      set disabled(value) {
        this._disabled = value;
        this._stateChanges.next(this);
      }
      _disabled = false;
      constructor() {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          assertElementNode(this.element.nativeElement, "cdkDragHandle");
        }
        this._parentDrag?._addHandle(this);
      }
      ngAfterViewInit() {
        if (!this._parentDrag) {
          let parent = this.element.nativeElement.parentElement;
          while (parent) {
            const ref = this._dragDropRegistry.getDragDirectiveForNode(parent);
            if (ref) {
              this._parentDrag = ref;
              ref._addHandle(this);
              break;
            }
            parent = parent.parentElement;
          }
        }
      }
      ngOnDestroy() {
        this._parentDrag?._removeHandle(this);
        this._stateChanges.complete();
      }
      static \u0275fac = function CdkDragHandle_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkDragHandle)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkDragHandle,
        selectors: [["", "cdkDragHandle", ""]],
        hostAttrs: [1, "cdk-drag-handle"],
        inputs: {
          disabled: [2, "cdkDragHandleDisabled", "disabled", booleanAttribute]
        },
        features: [\u0275\u0275ProvidersFeature([{
          provide: CDK_DRAG_HANDLE,
          useExisting: _CdkDragHandle
        }])]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragHandle, [{
        type: Directive,
        args: [{
          selector: "[cdkDragHandle]",
          host: {
            "class": "cdk-drag-handle"
          },
          providers: [{
            provide: CDK_DRAG_HANDLE,
            useExisting: CdkDragHandle
          }]
        }]
      }], () => [], {
        disabled: [{
          type: Input,
          args: [{
            alias: "cdkDragHandleDisabled",
            transform: booleanAttribute
          }]
        }]
      });
    })();
    CDK_DRAG_CONFIG = new InjectionToken("CDK_DRAG_CONFIG");
    CDK_DROP_LIST = new InjectionToken("CdkDropList");
    CdkDrag = class _CdkDrag {
      element = inject2(ElementRef);
      dropContainer = inject2(CDK_DROP_LIST, {
        optional: true,
        skipSelf: true
      });
      _ngZone = inject2(NgZone);
      _viewContainerRef = inject2(ViewContainerRef);
      _dir = inject2(Directionality, {
        optional: true
      });
      _changeDetectorRef = inject2(ChangeDetectorRef);
      _selfHandle = inject2(CDK_DRAG_HANDLE, {
        optional: true,
        self: true
      });
      _parentDrag = inject2(CDK_DRAG_PARENT, {
        optional: true,
        skipSelf: true
      });
      _dragDropRegistry = inject2(DragDropRegistry);
      _destroyed = new Subject();
      _handles = new BehaviorSubject([]);
      _previewTemplate;
      _placeholderTemplate;
      /** Reference to the underlying drag instance. */
      _dragRef;
      /** Arbitrary data to attach to this drag instance. */
      data;
      /** Locks the position of the dragged element along the specified axis. */
      lockAxis;
      /**
       * Selector that will be used to determine the root draggable element, starting from
       * the `cdkDrag` element and going up the DOM. Passing an alternate root element is useful
       * when trying to enable dragging on an element that you might not have access to.
       */
      rootElementSelector;
      /**
       * Node or selector that will be used to determine the element to which the draggable's
       * position will be constrained. If a string is passed in, it'll be used as a selector that
       * will be matched starting from the element's parent and going up the DOM until a match
       * has been found.
       */
      boundaryElement;
      /**
       * Amount of milliseconds to wait after the user has put their
       * pointer down before starting to drag the element.
       */
      dragStartDelay;
      /**
       * Sets the position of a `CdkDrag` that is outside of a drop container.
       * Can be used to restore the element's position for a returning user.
       */
      freeDragPosition;
      /** Whether starting to drag this element is disabled. */
      get disabled() {
        return this._disabled || !!(this.dropContainer && this.dropContainer.disabled);
      }
      set disabled(value) {
        this._disabled = value;
        this._dragRef.disabled = this._disabled;
      }
      _disabled;
      /**
       * Function that can be used to customize the logic of how the position of the drag item
       * is limited while it's being dragged. Gets called with a point containing the current position
       * of the user's pointer on the page, a reference to the item being dragged and its dimensions.
       * Should return a point describing where the item should be rendered.
       */
      constrainPosition;
      /** Class to be added to the preview element. */
      previewClass;
      /**
       * Configures the place into which the preview of the item will be inserted. Can be configured
       * globally through `CDK_DROP_LIST`. Possible values:
       * - `global` - Preview will be inserted at the bottom of the `<body>`. The advantage is that
       * you don't have to worry about `overflow: hidden` or `z-index`, but the item won't retain
       * its inherited styles.
       * - `parent` - Preview will be inserted into the parent of the drag item. The advantage is that
       * inherited styles will be preserved, but it may be clipped by `overflow: hidden` or not be
       * visible due to `z-index`. Furthermore, the preview is going to have an effect over selectors
       * like `:nth-child` and some flexbox configurations.
       * - `ElementRef<HTMLElement> | HTMLElement` - Preview will be inserted into a specific element.
       * Same advantages and disadvantages as `parent`.
       */
      previewContainer;
      /**
       * If the parent of the dragged element has a `scale` transform, it can throw off the
       * positioning when the user starts dragging. Use this input to notify the CDK of the scale.
       */
      scale = 1;
      /** Emits when the user starts dragging the item. */
      started = new EventEmitter();
      /** Emits when the user has released a drag item, before any animations have started. */
      released = new EventEmitter();
      /** Emits when the user stops dragging an item in the container. */
      ended = new EventEmitter();
      /** Emits when the user has moved the item into a new container. */
      entered = new EventEmitter();
      /** Emits when the user removes the item its container by dragging it into another container. */
      exited = new EventEmitter();
      /** Emits when the user drops the item inside a container. */
      dropped = new EventEmitter();
      /**
       * Emits as the user is dragging the item. Use with caution,
       * because this event will fire for every pixel that the user has dragged.
       */
      moved = new Observable((observer) => {
        const subscription = this._dragRef.moved.pipe(map((movedEvent) => ({
          source: this,
          pointerPosition: movedEvent.pointerPosition,
          event: movedEvent.event,
          delta: movedEvent.delta,
          distance: movedEvent.distance
        }))).subscribe(observer);
        return () => {
          subscription.unsubscribe();
        };
      });
      _injector = inject2(Injector);
      constructor() {
        const dropContainer = this.dropContainer;
        const config2 = inject2(CDK_DRAG_CONFIG, {
          optional: true
        });
        const dragDrop = inject2(DragDrop);
        this._dragRef = dragDrop.createDrag(this.element, {
          dragStartThreshold: config2 && config2.dragStartThreshold != null ? config2.dragStartThreshold : 5,
          pointerDirectionChangeThreshold: config2 && config2.pointerDirectionChangeThreshold != null ? config2.pointerDirectionChangeThreshold : 5,
          zIndex: config2?.zIndex
        });
        this._dragRef.data = this;
        this._dragDropRegistry.registerDirectiveNode(this.element.nativeElement, this);
        if (config2) {
          this._assignDefaults(config2);
        }
        if (dropContainer) {
          dropContainer.addItem(this);
          dropContainer._dropListRef.beforeStarted.pipe(takeUntil(this._destroyed)).subscribe(() => {
            this._dragRef.scale = this.scale;
          });
        }
        this._syncInputs(this._dragRef);
        this._handleEvents(this._dragRef);
      }
      /**
       * Returns the element that is being used as a placeholder
       * while the current element is being dragged.
       */
      getPlaceholderElement() {
        return this._dragRef.getPlaceholderElement();
      }
      /** Returns the root draggable element. */
      getRootElement() {
        return this._dragRef.getRootElement();
      }
      /** Resets a standalone drag item to its initial position. */
      reset() {
        this._dragRef.reset();
      }
      /** Resets drag item to end of boundary element. */
      resetToBoundary() {
        this._dragRef.resetToBoundary();
      }
      /**
       * Gets the pixel coordinates of the draggable outside of a drop container.
       */
      getFreeDragPosition() {
        return this._dragRef.getFreeDragPosition();
      }
      /**
       * Sets the current position in pixels the draggable outside of a drop container.
       * @param value New position to be set.
       */
      setFreeDragPosition(value) {
        this._dragRef.setFreeDragPosition(value);
      }
      ngAfterViewInit() {
        afterNextRender(() => {
          this._updateRootElement();
          this._setupHandlesListener();
          this._dragRef.scale = this.scale;
          if (this.freeDragPosition) {
            this._dragRef.setFreeDragPosition(this.freeDragPosition);
          }
        }, {
          injector: this._injector
        });
      }
      ngOnChanges(changes) {
        const rootSelectorChange = changes["rootElementSelector"];
        const positionChange = changes["freeDragPosition"];
        if (rootSelectorChange && !rootSelectorChange.firstChange) {
          this._updateRootElement();
        }
        this._dragRef.scale = this.scale;
        if (positionChange && !positionChange.firstChange && this.freeDragPosition) {
          this._dragRef.setFreeDragPosition(this.freeDragPosition);
        }
      }
      ngOnDestroy() {
        if (this.dropContainer) {
          this.dropContainer.removeItem(this);
        }
        this._dragDropRegistry.removeDirectiveNode(this.element.nativeElement);
        this._ngZone.runOutsideAngular(() => {
          this._handles.complete();
          this._destroyed.next();
          this._destroyed.complete();
          this._dragRef.dispose();
        });
      }
      _addHandle(handle) {
        const handles = this._handles.getValue();
        handles.push(handle);
        this._handles.next(handles);
      }
      _removeHandle(handle) {
        const handles = this._handles.getValue();
        const index = handles.indexOf(handle);
        if (index > -1) {
          handles.splice(index, 1);
          this._handles.next(handles);
        }
      }
      _setPreviewTemplate(preview) {
        this._previewTemplate = preview;
      }
      _resetPreviewTemplate(preview) {
        if (preview === this._previewTemplate) {
          this._previewTemplate = null;
        }
      }
      _setPlaceholderTemplate(placeholder) {
        this._placeholderTemplate = placeholder;
      }
      _resetPlaceholderTemplate(placeholder) {
        if (placeholder === this._placeholderTemplate) {
          this._placeholderTemplate = null;
        }
      }
      /** Syncs the root element with the `DragRef`. */
      _updateRootElement() {
        const element = this.element.nativeElement;
        let rootElement = element;
        if (this.rootElementSelector) {
          rootElement = element.closest !== void 0 ? element.closest(this.rootElementSelector) : (
            // Comment tag doesn't have closest method, so use parent's one.
            element.parentElement?.closest(this.rootElementSelector)
          );
        }
        if (rootElement && (typeof ngDevMode === "undefined" || ngDevMode)) {
          assertElementNode(rootElement, "cdkDrag");
        }
        this._dragRef.withRootElement(rootElement || element);
      }
      /** Gets the boundary element, based on the `boundaryElement` value. */
      _getBoundaryElement() {
        const boundary = this.boundaryElement;
        if (!boundary) {
          return null;
        }
        if (typeof boundary === "string") {
          return this.element.nativeElement.closest(boundary);
        }
        return coerceElement(boundary);
      }
      /** Syncs the inputs of the CdkDrag with the options of the underlying DragRef. */
      _syncInputs(ref) {
        ref.beforeStarted.subscribe(() => {
          if (!ref.isDragging()) {
            const dir = this._dir;
            const dragStartDelay = this.dragStartDelay;
            const placeholder = this._placeholderTemplate ? {
              template: this._placeholderTemplate.templateRef,
              context: this._placeholderTemplate.data,
              viewContainer: this._viewContainerRef
            } : null;
            const preview = this._previewTemplate ? {
              template: this._previewTemplate.templateRef,
              context: this._previewTemplate.data,
              matchSize: this._previewTemplate.matchSize,
              viewContainer: this._viewContainerRef
            } : null;
            ref.disabled = this.disabled;
            ref.lockAxis = this.lockAxis;
            ref.scale = this.scale;
            ref.dragStartDelay = typeof dragStartDelay === "object" && dragStartDelay ? dragStartDelay : coerceNumberProperty(dragStartDelay);
            ref.constrainPosition = this.constrainPosition;
            ref.previewClass = this.previewClass;
            ref.withBoundaryElement(this._getBoundaryElement()).withPlaceholderTemplate(placeholder).withPreviewTemplate(preview).withPreviewContainer(this.previewContainer || "global");
            if (dir) {
              ref.withDirection(dir.value);
            }
          }
        });
        ref.beforeStarted.pipe(take(1)).subscribe(() => {
          if (this._parentDrag) {
            ref.withParent(this._parentDrag._dragRef);
            return;
          }
          let parent = this.element.nativeElement.parentElement;
          while (parent) {
            const parentDrag = this._dragDropRegistry.getDragDirectiveForNode(parent);
            if (parentDrag) {
              ref.withParent(parentDrag._dragRef);
              break;
            }
            parent = parent.parentElement;
          }
        });
      }
      /** Handles the events from the underlying `DragRef`. */
      _handleEvents(ref) {
        ref.started.subscribe((startEvent) => {
          this.started.emit({
            source: this,
            event: startEvent.event
          });
          this._changeDetectorRef.markForCheck();
        });
        ref.released.subscribe((releaseEvent) => {
          this.released.emit({
            source: this,
            event: releaseEvent.event
          });
        });
        ref.ended.subscribe((endEvent) => {
          this.ended.emit({
            source: this,
            distance: endEvent.distance,
            dropPoint: endEvent.dropPoint,
            event: endEvent.event
          });
          this._changeDetectorRef.markForCheck();
        });
        ref.entered.subscribe((enterEvent) => {
          this.entered.emit({
            container: enterEvent.container.data,
            item: this,
            currentIndex: enterEvent.currentIndex
          });
        });
        ref.exited.subscribe((exitEvent) => {
          this.exited.emit({
            container: exitEvent.container.data,
            item: this
          });
        });
        ref.dropped.subscribe((dropEvent) => {
          this.dropped.emit({
            previousIndex: dropEvent.previousIndex,
            currentIndex: dropEvent.currentIndex,
            previousContainer: dropEvent.previousContainer.data,
            container: dropEvent.container.data,
            isPointerOverContainer: dropEvent.isPointerOverContainer,
            item: this,
            distance: dropEvent.distance,
            dropPoint: dropEvent.dropPoint,
            event: dropEvent.event
          });
        });
      }
      /** Assigns the default input values based on a provided config object. */
      _assignDefaults(config2) {
        const {
          lockAxis,
          dragStartDelay,
          constrainPosition,
          previewClass,
          boundaryElement,
          draggingDisabled,
          rootElementSelector,
          previewContainer
        } = config2;
        this.disabled = draggingDisabled == null ? false : draggingDisabled;
        this.dragStartDelay = dragStartDelay || 0;
        if (lockAxis) {
          this.lockAxis = lockAxis;
        }
        if (constrainPosition) {
          this.constrainPosition = constrainPosition;
        }
        if (previewClass) {
          this.previewClass = previewClass;
        }
        if (boundaryElement) {
          this.boundaryElement = boundaryElement;
        }
        if (rootElementSelector) {
          this.rootElementSelector = rootElementSelector;
        }
        if (previewContainer) {
          this.previewContainer = previewContainer;
        }
      }
      /** Sets up the listener that syncs the handles with the drag ref. */
      _setupHandlesListener() {
        this._handles.pipe(
          // Sync the new handles with the DragRef.
          tap((handles) => {
            const handleElements = handles.map((handle) => handle.element);
            if (this._selfHandle && this.rootElementSelector) {
              handleElements.push(this.element);
            }
            this._dragRef.withHandles(handleElements);
          }),
          // Listen if the state of any of the handles changes.
          switchMap((handles) => {
            return merge(...handles.map((item) => item._stateChanges.pipe(startWith(item))));
          }),
          takeUntil(this._destroyed)
        ).subscribe((handleInstance) => {
          const dragRef = this._dragRef;
          const handle = handleInstance.element.nativeElement;
          handleInstance.disabled ? dragRef.disableHandle(handle) : dragRef.enableHandle(handle);
        });
      }
      static \u0275fac = function CdkDrag_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkDrag)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkDrag,
        selectors: [["", "cdkDrag", ""]],
        hostAttrs: [1, "cdk-drag"],
        hostVars: 4,
        hostBindings: function CdkDrag_HostBindings(rf2, ctx) {
          if (rf2 & 2) {
            \u0275\u0275classProp("cdk-drag-disabled", ctx.disabled)("cdk-drag-dragging", ctx._dragRef.isDragging());
          }
        },
        inputs: {
          data: [0, "cdkDragData", "data"],
          lockAxis: [0, "cdkDragLockAxis", "lockAxis"],
          rootElementSelector: [0, "cdkDragRootElement", "rootElementSelector"],
          boundaryElement: [0, "cdkDragBoundary", "boundaryElement"],
          dragStartDelay: [0, "cdkDragStartDelay", "dragStartDelay"],
          freeDragPosition: [0, "cdkDragFreeDragPosition", "freeDragPosition"],
          disabled: [2, "cdkDragDisabled", "disabled", booleanAttribute],
          constrainPosition: [0, "cdkDragConstrainPosition", "constrainPosition"],
          previewClass: [0, "cdkDragPreviewClass", "previewClass"],
          previewContainer: [0, "cdkDragPreviewContainer", "previewContainer"],
          scale: [2, "cdkDragScale", "scale", numberAttribute]
        },
        outputs: {
          started: "cdkDragStarted",
          released: "cdkDragReleased",
          ended: "cdkDragEnded",
          entered: "cdkDragEntered",
          exited: "cdkDragExited",
          dropped: "cdkDragDropped",
          moved: "cdkDragMoved"
        },
        exportAs: ["cdkDrag"],
        features: [\u0275\u0275ProvidersFeature([{
          provide: CDK_DRAG_PARENT,
          useExisting: _CdkDrag
        }]), \u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDrag, [{
        type: Directive,
        args: [{
          selector: "[cdkDrag]",
          exportAs: "cdkDrag",
          host: {
            "class": "cdk-drag",
            "[class.cdk-drag-disabled]": "disabled",
            "[class.cdk-drag-dragging]": "_dragRef.isDragging()"
          },
          providers: [{
            provide: CDK_DRAG_PARENT,
            useExisting: CdkDrag
          }]
        }]
      }], () => [], {
        data: [{
          type: Input,
          args: ["cdkDragData"]
        }],
        lockAxis: [{
          type: Input,
          args: ["cdkDragLockAxis"]
        }],
        rootElementSelector: [{
          type: Input,
          args: ["cdkDragRootElement"]
        }],
        boundaryElement: [{
          type: Input,
          args: ["cdkDragBoundary"]
        }],
        dragStartDelay: [{
          type: Input,
          args: ["cdkDragStartDelay"]
        }],
        freeDragPosition: [{
          type: Input,
          args: ["cdkDragFreeDragPosition"]
        }],
        disabled: [{
          type: Input,
          args: [{
            alias: "cdkDragDisabled",
            transform: booleanAttribute
          }]
        }],
        constrainPosition: [{
          type: Input,
          args: ["cdkDragConstrainPosition"]
        }],
        previewClass: [{
          type: Input,
          args: ["cdkDragPreviewClass"]
        }],
        previewContainer: [{
          type: Input,
          args: ["cdkDragPreviewContainer"]
        }],
        scale: [{
          type: Input,
          args: [{
            alias: "cdkDragScale",
            transform: numberAttribute
          }]
        }],
        started: [{
          type: Output,
          args: ["cdkDragStarted"]
        }],
        released: [{
          type: Output,
          args: ["cdkDragReleased"]
        }],
        ended: [{
          type: Output,
          args: ["cdkDragEnded"]
        }],
        entered: [{
          type: Output,
          args: ["cdkDragEntered"]
        }],
        exited: [{
          type: Output,
          args: ["cdkDragExited"]
        }],
        dropped: [{
          type: Output,
          args: ["cdkDragDropped"]
        }],
        moved: [{
          type: Output,
          args: ["cdkDragMoved"]
        }]
      });
    })();
    CDK_DROP_LIST_GROUP = new InjectionToken("CdkDropListGroup");
    CdkDropListGroup = class _CdkDropListGroup {
      /** Drop lists registered inside the group. */
      _items = /* @__PURE__ */ new Set();
      /** Whether starting a dragging sequence from inside this group is disabled. */
      disabled = false;
      ngOnDestroy() {
        this._items.clear();
      }
      static \u0275fac = function CdkDropListGroup_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkDropListGroup)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkDropListGroup,
        selectors: [["", "cdkDropListGroup", ""]],
        inputs: {
          disabled: [2, "cdkDropListGroupDisabled", "disabled", booleanAttribute]
        },
        exportAs: ["cdkDropListGroup"],
        features: [\u0275\u0275ProvidersFeature([{
          provide: CDK_DROP_LIST_GROUP,
          useExisting: _CdkDropListGroup
        }])]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDropListGroup, [{
        type: Directive,
        args: [{
          selector: "[cdkDropListGroup]",
          exportAs: "cdkDropListGroup",
          providers: [{
            provide: CDK_DROP_LIST_GROUP,
            useExisting: CdkDropListGroup
          }]
        }]
      }], null, {
        disabled: [{
          type: Input,
          args: [{
            alias: "cdkDropListGroupDisabled",
            transform: booleanAttribute
          }]
        }]
      });
    })();
    CdkDropList = class _CdkDropList {
      element = inject2(ElementRef);
      _changeDetectorRef = inject2(ChangeDetectorRef);
      _scrollDispatcher = inject2(ScrollDispatcher);
      _dir = inject2(Directionality, {
        optional: true
      });
      _group = inject2(CDK_DROP_LIST_GROUP, {
        optional: true,
        skipSelf: true
      });
      /** Refs that have been synced with the drop ref most recently. */
      _latestSortedRefs;
      /** Emits when the list has been destroyed. */
      _destroyed = new Subject();
      /** Whether the element's scrollable parents have been resolved. */
      _scrollableParentsResolved;
      /** Keeps track of the drop lists that are currently on the page. */
      static _dropLists = [];
      /** Reference to the underlying drop list instance. */
      _dropListRef;
      /**
       * Other draggable containers that this container is connected to and into which the
       * container's items can be transferred. Can either be references to other drop containers,
       * or their unique IDs.
       */
      connectedTo = [];
      /** Arbitrary data to attach to this container. */
      data;
      /** Direction in which the list is oriented. */
      orientation;
      /**
       * Unique ID for the drop zone. Can be used as a reference
       * in the `connectedTo` of another `CdkDropList`.
       */
      id = inject2(_IdGenerator).getId("cdk-drop-list-");
      /** Locks the position of the draggable elements inside the container along the specified axis. */
      lockAxis;
      /** Whether starting a dragging sequence from this container is disabled. */
      get disabled() {
        return this._disabled || !!this._group && this._group.disabled;
      }
      set disabled(value) {
        this._dropListRef.disabled = this._disabled = value;
      }
      _disabled;
      /** Whether sorting within this drop list is disabled. */
      sortingDisabled;
      /**
       * Function that is used to determine whether an item
       * is allowed to be moved into a drop container.
       */
      enterPredicate = () => true;
      /** Functions that is used to determine whether an item can be sorted into a particular index. */
      sortPredicate = () => true;
      /** Whether to auto-scroll the view when the user moves their pointer close to the edges. */
      autoScrollDisabled;
      /** Number of pixels to scroll for each frame when auto-scrolling an element. */
      autoScrollStep;
      /**
       * Selector that will be used to resolve an alternate element container for the drop list.
       * Passing an alternate container is useful for the cases where one might not have control
       * over the parent node of the draggable items within the list (e.g. due to content projection).
       * This allows for usages like:
       *
       * ```
       * <div cdkDropList cdkDropListElementContainer=".inner">
       *   <div class="inner">
       *     <div cdkDrag></div>
       *   </div>
       * </div>
       * ```
       */
      elementContainerSelector;
      /**
       * By default when an item leaves its initial container, its placeholder will be transferred
       * to the new container. If that's not desirable for your use case, you can enable this option
       * which will clone the placeholder and leave it inside the original container. If the item is
       * returned to the initial container, the anchor element will be removed automatically.
       *
       * The cloned placeholder can be styled by targeting the `cdk-drag-anchor` class.
       *
       * This option is useful in combination with `cdkDropListSortingDisabled` to implement copying
       * behavior in a drop list.
       */
      hasAnchor;
      /** Emits when the user drops an item inside the container. */
      dropped = new EventEmitter();
      /**
       * Emits when the user has moved a new drag item into this container.
       */
      entered = new EventEmitter();
      /**
       * Emits when the user removes an item from the container
       * by dragging it into another container.
       */
      exited = new EventEmitter();
      /** Emits as the user is swapping items while actively dragging. */
      sorted = new EventEmitter();
      /**
       * Keeps track of the items that are registered with this container. Historically we used to
       * do this with a `ContentChildren` query, however queries don't handle transplanted views very
       * well which means that we can't handle cases like dragging the headers of a `mat-table`
       * correctly. What we do instead is to have the items register themselves with the container
       * and then we sort them based on their position in the DOM.
       */
      _unsortedItems = /* @__PURE__ */ new Set();
      constructor() {
        const dragDrop = inject2(DragDrop);
        const config2 = inject2(CDK_DRAG_CONFIG, {
          optional: true
        });
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          assertElementNode(this.element.nativeElement, "cdkDropList");
        }
        this._dropListRef = dragDrop.createDropList(this.element);
        this._dropListRef.data = this;
        if (config2) {
          this._assignDefaults(config2);
        }
        this._dropListRef.enterPredicate = (drag, drop) => {
          return this.enterPredicate(drag.data, drop.data);
        };
        this._dropListRef.sortPredicate = (index, drag, drop) => {
          return this.sortPredicate(index, drag.data, drop.data);
        };
        this._setupInputSyncSubscription(this._dropListRef);
        this._handleEvents(this._dropListRef);
        _CdkDropList._dropLists.push(this);
        if (this._group) {
          this._group._items.add(this);
        }
      }
      /** Registers an items with the drop list. */
      addItem(item) {
        this._unsortedItems.add(item);
        item._dragRef._withDropContainer(this._dropListRef);
        if (this._dropListRef.isDragging()) {
          this._syncItemsWithRef(this.getSortedItems().map((item2) => item2._dragRef));
        }
      }
      /** Removes an item from the drop list. */
      removeItem(item) {
        this._unsortedItems.delete(item);
        if (this._latestSortedRefs) {
          const index = this._latestSortedRefs.indexOf(item._dragRef);
          if (index > -1) {
            this._latestSortedRefs.splice(index, 1);
            this._syncItemsWithRef(this._latestSortedRefs);
          }
        }
      }
      /** Gets the registered items in the list, sorted by their position in the DOM. */
      getSortedItems() {
        return Array.from(this._unsortedItems).sort((a2, b2) => {
          const documentPosition = a2._dragRef.getVisibleElement().compareDocumentPosition(b2._dragRef.getVisibleElement());
          return documentPosition & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
        });
      }
      ngOnDestroy() {
        const index = _CdkDropList._dropLists.indexOf(this);
        if (index > -1) {
          _CdkDropList._dropLists.splice(index, 1);
        }
        if (this._group) {
          this._group._items.delete(this);
        }
        this._latestSortedRefs = void 0;
        this._unsortedItems.clear();
        this._dropListRef.dispose();
        this._destroyed.next();
        this._destroyed.complete();
      }
      /** Syncs the inputs of the CdkDropList with the options of the underlying DropListRef. */
      _setupInputSyncSubscription(ref) {
        if (this._dir) {
          this._dir.change.pipe(startWith(this._dir.value), takeUntil(this._destroyed)).subscribe((value) => ref.withDirection(value));
        }
        ref.beforeStarted.subscribe(() => {
          const siblings = coerceArray(this.connectedTo).map((drop) => {
            if (typeof drop === "string") {
              const correspondingDropList = _CdkDropList._dropLists.find((list) => list.id === drop);
              if (!correspondingDropList && (typeof ngDevMode === "undefined" || ngDevMode)) {
                console.warn(`CdkDropList could not find connected drop list with id "${drop}"`);
              }
              return correspondingDropList;
            }
            return drop;
          });
          if (this._group) {
            this._group._items.forEach((drop) => {
              if (siblings.indexOf(drop) === -1) {
                siblings.push(drop);
              }
            });
          }
          if (!this._scrollableParentsResolved) {
            const scrollableParents = this._scrollDispatcher.getAncestorScrollContainers(this.element).map((scrollable) => scrollable.getElementRef().nativeElement);
            this._dropListRef.withScrollableParents(scrollableParents);
            this._scrollableParentsResolved = true;
          }
          if (this.elementContainerSelector) {
            const container = this.element.nativeElement.querySelector(this.elementContainerSelector);
            if (!container && (typeof ngDevMode === "undefined" || ngDevMode)) {
              throw new Error(`CdkDropList could not find an element container matching the selector "${this.elementContainerSelector}"`);
            }
            ref.withElementContainer(container);
          }
          ref.disabled = this.disabled;
          ref.lockAxis = this.lockAxis;
          ref.sortingDisabled = this.sortingDisabled;
          ref.autoScrollDisabled = this.autoScrollDisabled;
          ref.autoScrollStep = coerceNumberProperty(this.autoScrollStep, 2);
          ref.hasAnchor = this.hasAnchor;
          ref.connectedTo(siblings.filter((drop) => drop && drop !== this).map((list) => list._dropListRef)).withOrientation(this.orientation);
        });
      }
      /** Handles events from the underlying DropListRef. */
      _handleEvents(ref) {
        ref.beforeStarted.subscribe(() => {
          this._syncItemsWithRef(this.getSortedItems().map((item) => item._dragRef));
          this._changeDetectorRef.markForCheck();
        });
        ref.entered.subscribe((event) => {
          this.entered.emit({
            container: this,
            item: event.item.data,
            currentIndex: event.currentIndex
          });
        });
        ref.exited.subscribe((event) => {
          this.exited.emit({
            container: this,
            item: event.item.data
          });
          this._changeDetectorRef.markForCheck();
        });
        ref.sorted.subscribe((event) => {
          this.sorted.emit({
            previousIndex: event.previousIndex,
            currentIndex: event.currentIndex,
            container: this,
            item: event.item.data
          });
        });
        ref.dropped.subscribe((dropEvent) => {
          this.dropped.emit({
            previousIndex: dropEvent.previousIndex,
            currentIndex: dropEvent.currentIndex,
            previousContainer: dropEvent.previousContainer.data,
            container: dropEvent.container.data,
            item: dropEvent.item.data,
            isPointerOverContainer: dropEvent.isPointerOverContainer,
            distance: dropEvent.distance,
            dropPoint: dropEvent.dropPoint,
            event: dropEvent.event
          });
          this._changeDetectorRef.markForCheck();
        });
        merge(ref.receivingStarted, ref.receivingStopped).subscribe(() => this._changeDetectorRef.markForCheck());
      }
      /** Assigns the default input values based on a provided config object. */
      _assignDefaults(config2) {
        const {
          lockAxis,
          draggingDisabled,
          sortingDisabled,
          listAutoScrollDisabled,
          listOrientation
        } = config2;
        this.disabled = draggingDisabled == null ? false : draggingDisabled;
        this.sortingDisabled = sortingDisabled == null ? false : sortingDisabled;
        this.autoScrollDisabled = listAutoScrollDisabled == null ? false : listAutoScrollDisabled;
        this.orientation = listOrientation || "vertical";
        if (lockAxis) {
          this.lockAxis = lockAxis;
        }
      }
      /** Syncs up the registered drag items with underlying drop list ref. */
      _syncItemsWithRef(items) {
        this._latestSortedRefs = items;
        this._dropListRef.withItems(items);
      }
      static \u0275fac = function CdkDropList_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkDropList)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkDropList,
        selectors: [["", "cdkDropList", ""], ["cdk-drop-list"]],
        hostAttrs: [1, "cdk-drop-list"],
        hostVars: 7,
        hostBindings: function CdkDropList_HostBindings(rf2, ctx) {
          if (rf2 & 2) {
            \u0275\u0275attribute("id", ctx.id);
            \u0275\u0275classProp("cdk-drop-list-disabled", ctx.disabled)("cdk-drop-list-dragging", ctx._dropListRef.isDragging())("cdk-drop-list-receiving", ctx._dropListRef.isReceiving());
          }
        },
        inputs: {
          connectedTo: [0, "cdkDropListConnectedTo", "connectedTo"],
          data: [0, "cdkDropListData", "data"],
          orientation: [0, "cdkDropListOrientation", "orientation"],
          id: "id",
          lockAxis: [0, "cdkDropListLockAxis", "lockAxis"],
          disabled: [2, "cdkDropListDisabled", "disabled", booleanAttribute],
          sortingDisabled: [2, "cdkDropListSortingDisabled", "sortingDisabled", booleanAttribute],
          enterPredicate: [0, "cdkDropListEnterPredicate", "enterPredicate"],
          sortPredicate: [0, "cdkDropListSortPredicate", "sortPredicate"],
          autoScrollDisabled: [2, "cdkDropListAutoScrollDisabled", "autoScrollDisabled", booleanAttribute],
          autoScrollStep: [0, "cdkDropListAutoScrollStep", "autoScrollStep"],
          elementContainerSelector: [0, "cdkDropListElementContainer", "elementContainerSelector"],
          hasAnchor: [2, "cdkDropListHasAnchor", "hasAnchor", booleanAttribute]
        },
        outputs: {
          dropped: "cdkDropListDropped",
          entered: "cdkDropListEntered",
          exited: "cdkDropListExited",
          sorted: "cdkDropListSorted"
        },
        exportAs: ["cdkDropList"],
        features: [\u0275\u0275ProvidersFeature([
          // Prevent child drop lists from picking up the same group as their parent.
          {
            provide: CDK_DROP_LIST_GROUP,
            useValue: void 0
          },
          {
            provide: CDK_DROP_LIST,
            useExisting: _CdkDropList
          }
        ])]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDropList, [{
        type: Directive,
        args: [{
          selector: "[cdkDropList], cdk-drop-list",
          exportAs: "cdkDropList",
          providers: [
            // Prevent child drop lists from picking up the same group as their parent.
            {
              provide: CDK_DROP_LIST_GROUP,
              useValue: void 0
            },
            {
              provide: CDK_DROP_LIST,
              useExisting: CdkDropList
            }
          ],
          host: {
            "class": "cdk-drop-list",
            "[attr.id]": "id",
            "[class.cdk-drop-list-disabled]": "disabled",
            "[class.cdk-drop-list-dragging]": "_dropListRef.isDragging()",
            "[class.cdk-drop-list-receiving]": "_dropListRef.isReceiving()"
          }
        }]
      }], () => [], {
        connectedTo: [{
          type: Input,
          args: ["cdkDropListConnectedTo"]
        }],
        data: [{
          type: Input,
          args: ["cdkDropListData"]
        }],
        orientation: [{
          type: Input,
          args: ["cdkDropListOrientation"]
        }],
        id: [{
          type: Input
        }],
        lockAxis: [{
          type: Input,
          args: ["cdkDropListLockAxis"]
        }],
        disabled: [{
          type: Input,
          args: [{
            alias: "cdkDropListDisabled",
            transform: booleanAttribute
          }]
        }],
        sortingDisabled: [{
          type: Input,
          args: [{
            alias: "cdkDropListSortingDisabled",
            transform: booleanAttribute
          }]
        }],
        enterPredicate: [{
          type: Input,
          args: ["cdkDropListEnterPredicate"]
        }],
        sortPredicate: [{
          type: Input,
          args: ["cdkDropListSortPredicate"]
        }],
        autoScrollDisabled: [{
          type: Input,
          args: [{
            alias: "cdkDropListAutoScrollDisabled",
            transform: booleanAttribute
          }]
        }],
        autoScrollStep: [{
          type: Input,
          args: ["cdkDropListAutoScrollStep"]
        }],
        elementContainerSelector: [{
          type: Input,
          args: ["cdkDropListElementContainer"]
        }],
        hasAnchor: [{
          type: Input,
          args: [{
            alias: "cdkDropListHasAnchor",
            transform: booleanAttribute
          }]
        }],
        dropped: [{
          type: Output,
          args: ["cdkDropListDropped"]
        }],
        entered: [{
          type: Output,
          args: ["cdkDropListEntered"]
        }],
        exited: [{
          type: Output,
          args: ["cdkDropListExited"]
        }],
        sorted: [{
          type: Output,
          args: ["cdkDropListSorted"]
        }]
      });
    })();
    CDK_DRAG_PREVIEW = new InjectionToken("CdkDragPreview");
    CdkDragPreview = class _CdkDragPreview {
      templateRef = inject2(TemplateRef);
      _drag = inject2(CDK_DRAG_PARENT, {
        optional: true
      });
      /** Context data to be added to the preview template instance. */
      data;
      /** Whether the preview should preserve the same size as the item that is being dragged. */
      matchSize = false;
      constructor() {
        this._drag?._setPreviewTemplate(this);
      }
      ngOnDestroy() {
        this._drag?._resetPreviewTemplate(this);
      }
      static \u0275fac = function CdkDragPreview_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkDragPreview)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkDragPreview,
        selectors: [["ng-template", "cdkDragPreview", ""]],
        inputs: {
          data: "data",
          matchSize: [2, "matchSize", "matchSize", booleanAttribute]
        },
        features: [\u0275\u0275ProvidersFeature([{
          provide: CDK_DRAG_PREVIEW,
          useExisting: _CdkDragPreview
        }])]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragPreview, [{
        type: Directive,
        args: [{
          selector: "ng-template[cdkDragPreview]",
          providers: [{
            provide: CDK_DRAG_PREVIEW,
            useExisting: CdkDragPreview
          }]
        }]
      }], () => [], {
        data: [{
          type: Input
        }],
        matchSize: [{
          type: Input,
          args: [{
            transform: booleanAttribute
          }]
        }]
      });
    })();
    CDK_DRAG_PLACEHOLDER = new InjectionToken("CdkDragPlaceholder");
    CdkDragPlaceholder = class _CdkDragPlaceholder {
      templateRef = inject2(TemplateRef);
      _drag = inject2(CDK_DRAG_PARENT, {
        optional: true
      });
      /** Context data to be added to the placeholder template instance. */
      data;
      constructor() {
        this._drag?._setPlaceholderTemplate(this);
      }
      ngOnDestroy() {
        this._drag?._resetPlaceholderTemplate(this);
      }
      static \u0275fac = function CdkDragPlaceholder_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkDragPlaceholder)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkDragPlaceholder,
        selectors: [["ng-template", "cdkDragPlaceholder", ""]],
        inputs: {
          data: "data"
        },
        features: [\u0275\u0275ProvidersFeature([{
          provide: CDK_DRAG_PLACEHOLDER,
          useExisting: _CdkDragPlaceholder
        }])]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragPlaceholder, [{
        type: Directive,
        args: [{
          selector: "ng-template[cdkDragPlaceholder]",
          providers: [{
            provide: CDK_DRAG_PLACEHOLDER,
            useExisting: CdkDragPlaceholder
          }]
        }]
      }], () => [], {
        data: [{
          type: Input
        }]
      });
    })();
    DRAG_DROP_DIRECTIVES = [CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder];
    DragDropModule = class _DragDropModule {
      static \u0275fac = function DragDropModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DragDropModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _DragDropModule,
        imports: [CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder],
        exports: [CdkScrollableModule, CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder]
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
        providers: [DragDrop],
        imports: [CdkScrollableModule]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDropModule, [{
        type: NgModule,
        args: [{
          imports: DRAG_DROP_DIRECTIVES,
          exports: [CdkScrollableModule, ...DRAG_DROP_DIRECTIVES],
          providers: [DragDrop]
        }]
      }], null, null);
    })();
  }
});

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
    "use strict";
  }
});

// (disabled):node_modules/node-fetch/browser.js
var require_browser = __commonJS({
  "(disabled):node_modules/node-fetch/browser.js"(exports, module2) {
    "use strict";
    module2.exports = exports = window.fetch;
    exports.default = window.fetch.bind(window);
    exports.Headers = window.Headers;
    exports.Request = window.Request;
    exports.Response = window.Response;
  }
});

// (disabled):util
var require_util = __commonJS({
  "(disabled):util"() {
    "use strict";
  }
});

// node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js
function e(e2, n2) {
  function r2() {
    this.constructor = e2;
  }
  t(e2, n2), e2.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
}
function n(t2, e2, n2, r2) {
  return new (n2 || (n2 = Promise))(function(o2, a2) {
    function i2(t3) {
      try {
        u3(r2.next(t3));
      } catch (t4) {
        a2(t4);
      }
    }
    function s2(t3) {
      try {
        u3(r2.throw(t3));
      } catch (t4) {
        a2(t4);
      }
    }
    function u3(t3) {
      t3.done ? o2(t3.value) : new n2(function(e3) {
        e3(t3.value);
      }).then(i2, s2);
    }
    u3((r2 = r2.apply(t2, e2 || [])).next());
  });
}
function r(t2, e2) {
  var n2, r2, o2, a2, i2 = { label: 0, sent: function() {
    if (1 & o2[0]) throw o2[1];
    return o2[1];
  }, trys: [], ops: [] };
  return a2 = { next: s2(0), throw: s2(1), return: s2(2) }, "function" == typeof Symbol && (a2[Symbol.iterator] = function() {
    return this;
  }), a2;
  function s2(a3) {
    return function(s3) {
      return function(a4) {
        if (n2) throw new TypeError("Generator is already executing.");
        for (; i2; ) try {
          if (n2 = 1, r2 && (o2 = 2 & a4[0] ? r2.return : a4[0] ? r2.throw || ((o2 = r2.return) && o2.call(r2), 0) : r2.next) && !(o2 = o2.call(r2, a4[1])).done) return o2;
          switch (r2 = 0, o2 && (a4 = [2 & a4[0], o2.value]), a4[0]) {
            case 0:
            case 1:
              o2 = a4;
              break;
            case 4:
              return i2.label++, { value: a4[1], done: false };
            case 5:
              i2.label++, r2 = a4[1], a4 = [0];
              continue;
            case 7:
              a4 = i2.ops.pop(), i2.trys.pop();
              continue;
            default:
              if (!(o2 = (o2 = i2.trys).length > 0 && o2[o2.length - 1]) && (6 === a4[0] || 2 === a4[0])) {
                i2 = 0;
                continue;
              }
              if (3 === a4[0] && (!o2 || a4[1] > o2[0] && a4[1] < o2[3])) {
                i2.label = a4[1];
                break;
              }
              if (6 === a4[0] && i2.label < o2[1]) {
                i2.label = o2[1], o2 = a4;
                break;
              }
              if (o2 && i2.label < o2[2]) {
                i2.label = o2[2], i2.ops.push(a4);
                break;
              }
              o2[2] && i2.ops.pop(), i2.trys.pop();
              continue;
          }
          a4 = e2.call(t2, i2);
        } catch (t3) {
          a4 = [6, t3], r2 = 0;
        } finally {
          n2 = o2 = 0;
        }
        if (5 & a4[0]) throw a4[1];
        return { value: a4[0] ? a4[1] : void 0, done: true };
      }([a3, s3]);
    };
  }
}
function a(t2, e2, n2) {
  t2[decodeURIComponent(e2)] = decodeURIComponent(n2 || "");
}
function i() {
  return s;
}
function l(t2, e2) {
  var n2 = g(t2, e2);
  return u2.get(n2);
}
function h(t2) {
  return c.get(t2);
}
function f(t2) {
  for (var e2 = u2.entries(), n2 = []; ; ) {
    var r2 = e2.next(), o2 = r2.done, a2 = r2.value;
    if (o2) break;
    var i2 = a2[0], s2 = a2[1];
    i2.split("_")[0] === t2 && n2.push(s2);
  }
  return n2;
}
function d(t2) {
  var e2 = t2.kernelName, n2 = t2.backendName, r2 = g(e2, n2);
  if (u2.has(r2)) throw new Error("The kernel '" + e2 + "' for backend '" + n2 + "' is already registered");
  u2.set(r2, t2);
}
function p(t2) {
  var e2 = t2.kernelName;
  c.has(e2) && console.warn("Overriding the gradient for '" + e2 + "'"), c.set(e2, t2);
}
function g(t2, e2) {
  return e2 + "_" + t2;
}
function y(t2) {
  for (var e2 = t2.length, n2 = 0, r2 = 0; e2 > 0; ) r2 = Math.random() * e2 | 0, n2 = t2[--e2], t2[e2] = t2[r2], t2[r2] = n2;
}
function x(t2, e2, n2) {
  return Math.max(t2, Math.min(e2, n2));
}
function b(t2) {
  return t2 % 2 == 0 ? t2 : t2 + 1;
}
function w(t2) {
  for (var e2 = 0, n2 = 0; n2 < t2.length; n2++) e2 += t2[n2];
  return e2;
}
function C(t2, e2) {
  if (!t2) throw new Error("string" == typeof e2 ? e2 : e2());
}
function E(t2, e2, n2) {
  void 0 === n2 && (n2 = ""), C(S(t2, e2), function() {
    return n2 + " Shapes " + t2 + " and " + e2 + " must match";
  });
}
function R(t2) {
  C(null != t2, function() {
    return "The input to the tensor constructor must be a non-null value.";
  });
}
function I(t2, e2, n2) {
  if (void 0 === e2 && (e2 = []), void 0 === n2 && (n2 = false), null == e2 && (e2 = []), Array.isArray(t2) || V(t2) && !n2) for (var r2 = 0; r2 < t2.length; ++r2) I(t2[r2], e2, n2);
  else e2.push(t2);
  return e2;
}
function k(t2) {
  if (0 === t2.length) return 1;
  for (var e2 = t2[0], n2 = 1; n2 < t2.length; n2++) e2 *= t2[n2];
  return e2;
}
function S(t2, e2) {
  if (t2 === e2) return true;
  if (null == t2 || null == e2) return false;
  if (t2.length !== e2.length) return false;
  for (var n2 = 0; n2 < t2.length; n2++) if (t2[n2] !== e2[n2]) return false;
  return true;
}
function A(t2) {
  return t2 % 1 == 0;
}
function D(t2) {
  if (null != Math.tanh) return Math.tanh(t2);
  if (t2 === 1 / 0) return 1;
  if (t2 === -1 / 0) return -1;
  var e2 = Math.exp(2 * t2);
  return (e2 - 1) / (e2 + 1);
}
function T(t2) {
  var e2 = Math.ceil(Math.sqrt(t2));
  return [e2, Math.ceil(t2 / e2)];
}
function N(t2, e2) {
  return e2 <= t2.length ? t2 : t2 + " ".repeat(e2 - t2.length);
}
function F(t2, e2, n2) {
  return void 0 === e2 && (e2 = function(t3) {
    return 0;
  }), new Promise(function(r2, o2) {
    var a2 = 0, i2 = function() {
      if (t2()) r2();
      else {
        a2++;
        var s2 = e2(a2);
        null != n2 && a2 >= n2 ? o2() : setTimeout(i2, s2);
      }
    };
    i2();
  });
}
function _(t2, e2) {
  for (var n2 = 1, r2 = -1, o2 = 0; o2 < t2.length; ++o2) if (t2[o2] >= 0) n2 *= t2[o2];
  else if (-1 === t2[o2]) {
    if (-1 !== r2) throw Error("Shapes can only have 1 implicit size. Found -1 at dim " + r2 + " and dim " + o2);
    r2 = o2;
  } else if (t2[o2] < 0) throw Error("Shapes can not be < 0. Found " + t2[o2] + " at dim " + o2);
  if (-1 === r2) {
    if (e2 > 0 && e2 !== n2) throw Error("Size(" + e2 + ") must match the product of shape " + t2);
    return t2;
  }
  if (0 === n2) throw Error("Cannot infer the missing size in [" + t2 + "] when there are 0 elements");
  if (e2 % n2 != 0) throw Error("The implicit shape can't be a fractional number. Got " + e2 + " / " + n2);
  var a2 = t2.slice();
  return a2[r2] = e2 / n2, a2;
}
function O(t2, e2) {
  var n2 = e2.length;
  return C((t2 = null == t2 ? e2.map(function(t3, e3) {
    return e3;
  }) : [].concat(t2)).every(function(t3) {
    return t3 >= -n2 && t3 < n2;
  }), function() {
    return "All values in axis param must be in range [-" + n2 + ", " + n2 + ") but got axis " + t2;
  }), C(t2.every(function(t3) {
    return A(t3);
  }), function() {
    return "All values in axis param must be integers but got axis " + t2;
  }), t2.map(function(t3) {
    return t3 < 0 ? n2 + t3 : t3;
  });
}
function M(t2, e2) {
  for (var n2 = [], r2 = [], o2 = null != e2 && Array.isArray(e2) && 0 === e2.length, a2 = null == e2 || o2 ? null : O(e2, t2).sort(), i2 = 0, s2 = 0; s2 < t2.length; ++s2) {
    if (null != a2) {
      if (a2[i2] === s2 && 1 !== t2[s2]) throw new Error("Can't squeeze axis " + s2 + " since its dim '" + t2[s2] + "' is not 1");
      (null == a2[i2] || a2[i2] > s2) && 1 === t2[s2] && (n2.push(t2[s2]), r2.push(s2)), a2[i2] <= s2 && i2++;
    }
    1 !== t2[s2] && (n2.push(t2[s2]), r2.push(s2));
  }
  return { newShape: n2, keptDims: r2 };
}
function B(t2, e2) {
  var n2 = null;
  if (null == t2 || "float32" === t2) n2 = new Float32Array(e2);
  else if ("int32" === t2) n2 = new Int32Array(e2);
  else {
    if ("bool" !== t2) throw new Error("Unknown data type " + t2);
    n2 = new Uint8Array(e2);
  }
  return n2;
}
function P(t2, e2) {
  var n2 = null;
  if (null == t2 || "float32" === t2) n2 = new Float32Array(e2);
  else if ("int32" === t2) n2 = new Int32Array(e2);
  else if ("bool" === t2) n2 = new Uint8Array(e2);
  else {
    if ("string" !== t2) throw new Error("Unknown data type " + t2);
    n2 = new Array(e2);
  }
  return n2;
}
function L(t2, e2) {
  for (var n2 = 0; n2 < t2.length; n2++) {
    var r2 = t2[n2];
    if (isNaN(r2) || !isFinite(r2)) throw Error("A tensor of type " + e2 + " being uploaded contains " + r2 + ".");
  }
}
function W(t2) {
  return "bool" === t2 || "complex64" === t2 || "float32" === t2 || "int32" === t2 || "string" === t2;
}
function U(t2, e2) {
  return "complex64" !== e2 && (("float32" !== e2 || "complex64" === t2) && (("int32" !== e2 || "float32" === t2 || "complex64" === t2) && ("bool" !== e2 || "bool" !== t2)));
}
function V(t2) {
  return t2 instanceof Float32Array || t2 instanceof Int32Array || t2 instanceof Uint8Array;
}
function z(t2) {
  if ("float32" === t2 || "int32" === t2) return 4;
  if ("complex64" === t2) return 8;
  if ("bool" === t2) return 1;
  throw new Error("Unknown dtype " + t2);
}
function G(t2) {
  if (null == t2) return 0;
  var e2 = 0;
  return t2.forEach(function(t3) {
    return e2 += t3.length;
  }), e2;
}
function H(t2) {
  return "string" == typeof t2 || t2 instanceof String;
}
function q(t2) {
  return "boolean" == typeof t2;
}
function K(t2) {
  return "number" == typeof t2;
}
function j(t2) {
  return Array.isArray(t2) ? j(t2[0]) : t2 instanceof Float32Array ? "float32" : t2 instanceof Int32Array || t2 instanceof Uint8Array ? "int32" : K(t2) ? "float32" : H(t2) ? "string" : q(t2) ? "bool" : "float32";
}
function X(t2) {
  return !!(t2 && t2.constructor && t2.call && t2.apply);
}
function Y(t2, e2) {
  for (var n2 = e2; n2 < t2; ++n2) if (t2 % n2 == 0) return n2;
  return t2;
}
function $(t2) {
  var e2 = t2.length;
  if (e2 < 2) return [];
  var n2 = new Array(e2 - 1);
  n2[e2 - 2] = t2[e2 - 1];
  for (var r2 = e2 - 3; r2 >= 0; --r2) n2[r2] = n2[r2 + 1] * t2[r2 + 1];
  return n2;
}
function Q(t2, e2, n2) {
  if ("string" === e2) throw new Error("Cannot convert a string[] to a TypedArray");
  if (Array.isArray(t2) && (t2 = I(t2)), n2 && L(t2, e2), function(t3, e3) {
    return t3 instanceof Float32Array && "float32" === e3 || t3 instanceof Int32Array && "int32" === e3 || t3 instanceof Uint8Array && "bool" === e3;
  }(t2, e2)) return t2;
  if (null == e2 || "float32" === e2 || "complex64" === e2) return new Float32Array(t2);
  if ("int32" === e2) return new Int32Array(t2);
  if ("bool" === e2) {
    for (var r2 = new Uint8Array(t2.length), o2 = 0; o2 < r2.length; ++o2) 0 !== Math.round(t2[o2]) && (r2[o2] = 1);
    return r2;
  }
  throw new Error("Unknown data type " + e2);
}
function J(t2, e2) {
  if (0 === t2.length) return e2[0];
  var n2 = t2.reduce(function(t3, e3) {
    return t3 * e3;
  });
  if (0 === n2) return [];
  if (n2 !== e2.length) throw new Error("[" + t2 + "] does not match the input size.");
  return function t3(e3, n3, r2) {
    var o2 = new Array();
    if (1 === n3.length) for (var a2 = n3[0], i2 = 0; i2 < a2; i2++) o2[i2] = r2[e3 + i2];
    else {
      a2 = n3[0];
      var s2 = n3.slice(1), u3 = s2.reduce(function(t4, e4) {
        return t4 * e4;
      });
      for (i2 = 0; i2 < a2; i2++) o2[i2] = t3(e3 + i2 * u3, s2, r2);
    }
    return o2;
  }(0, t2, e2);
}
function Z(t2, e2) {
  for (var n2 = tt(t2, e2), r2 = 0; r2 < n2.length; r2++) n2[r2] = 1;
  return n2;
}
function tt(t2, e2) {
  if (null == e2 || "float32" === e2 || "complex64" === e2) return new Float32Array(t2);
  if ("int32" === e2) return new Int32Array(t2);
  if ("bool" === e2) return new Uint8Array(t2);
  throw new Error("Unknown data type " + e2);
}
function et() {
  return i().platform.now();
}
function nt(t2) {
  t2.forEach(function(e2) {
    C(Number.isInteger(e2) && e2 >= 0, function() {
      return "Tensor must have a shape comprised of positive integers but got shape [" + t2 + "].";
    });
  });
}
function rt(t2, e2) {
  return void 0 === e2 && (e2 = "utf-8"), e2 = e2 || "utf-8", i().platform.encode(t2, e2);
}
function ot(t2, e2) {
  return void 0 === e2 && (e2 = "utf-8"), e2 = e2 || "utf-8", i().platform.decode(t2, e2);
}
function at(t2, e2, n2) {
  if (0 === e2) return 0;
  if (1 === e2) return t2[0];
  for (var r2 = t2[t2.length - 1], o2 = 0; o2 < t2.length - 1; ++o2) r2 += n2[o2] * t2[o2];
  return r2;
}
function it(t2, e2, n2) {
  if (0 === e2) return [];
  if (1 === e2) return [t2];
  for (var r2 = new Array(e2), o2 = 0; o2 < r2.length - 1; ++o2) r2[o2] = Math.floor(t2 / n2[o2]), t2 -= r2[o2] * n2[o2];
  return r2[r2.length - 1] = t2, r2;
}
function dt(t2, e2, n2, r2) {
  var o2 = $(e2), a2 = function(t3, e3, n3, r3) {
    var o3 = k(e3), a3 = r3[r3.length - 1], i3 = new Array(a3).fill(0), s3 = e3.length, u4 = "complex64" === n3 ? mt(t3) : t3;
    if (s3 > 1) for (var c2 = 0; c2 < o3 / a3; c2++) for (var l2 = c2 * a3, h2 = 0; h2 < a3; h2++) i3[h2] = Math.max(i3[h2], pt(u4[l2 + h2], 0, n3).length);
    return i3;
  }(t2, e2, n2, o2), i2 = e2.length, s2 = function t3(e3, n3, r3, o3, a3, i3) {
    void 0 === i3 && (i3 = true);
    var s3 = "complex64" === r3 ? 2 : 1, u4 = n3[0], c2 = n3.length;
    if (0 === c2) {
      return "complex64" === r3 ? [pt(mt(e3)[0], 0, r3)] : "bool" === r3 ? [vt(e3[0])] : [e3[0].toString()];
    }
    if (1 === c2) {
      if (u4 > lt) {
        var l2 = ht * s3, h2 = Array.from(e3.slice(0, l2)), f2 = Array.from(e3.slice((u4 - ht) * s3, u4 * s3));
        return "complex64" === r3 && (h2 = mt(h2), f2 = mt(f2)), ["[" + h2.map(function(t4, e4) {
          return pt(t4, a3[e4], r3);
        }).join(", ") + ", ..., " + f2.map(function(t4, e4) {
          return pt(t4, a3[u4 - ht + e4], r3);
        }).join(", ") + "]"];
      }
      return ["[" + ("complex64" === r3 ? mt(e3) : Array.from(e3)).map(function(t4, e4) {
        return pt(t4, a3[e4], r3);
      }).join(", ") + "]"];
    }
    var d2 = n3.slice(1), p2 = o3.slice(1), v = o3[0] * s3, m = [];
    if (u4 > lt) {
      for (var g2 = 0; g2 < ht; g2++) {
        var y2 = (x2 = g2 * v) + v;
        m.push.apply(m, t3(e3.slice(x2, y2), d2, r3, p2, a3, false));
      }
      m.push("...");
      for (g2 = u4 - ht; g2 < u4; g2++) {
        y2 = (x2 = g2 * v) + v;
        m.push.apply(m, t3(e3.slice(x2, y2), d2, r3, p2, a3, g2 === u4 - 1));
      }
    } else for (g2 = 0; g2 < u4; g2++) {
      var x2;
      y2 = (x2 = g2 * v) + v;
      m.push.apply(m, t3(e3.slice(x2, y2), d2, r3, p2, a3, g2 === u4 - 1));
    }
    var b2 = 2 === c2 ? "," : "";
    m[0] = "[" + m[0] + b2;
    for (g2 = 1; g2 < m.length - 1; g2++) m[g2] = " " + m[g2] + b2;
    var w2 = ",\n";
    for (g2 = 2; g2 < c2; g2++) w2 += "\n";
    return m[m.length - 1] = " " + m[m.length - 1] + "]" + (i3 ? "" : w2), m;
  }(t2, e2, n2, o2, a2), u3 = ["Tensor"];
  return r2 && (u3.push("  dtype: " + n2), u3.push("  rank: " + i2), u3.push("  shape: [" + e2 + "]"), u3.push("  values:")), u3.push(s2.map(function(t3) {
    return "    " + t3;
  }).join("\n")), u3.join("\n");
}
function pt(t2, e2, n2) {
  return N(Array.isArray(t2) ? parseFloat(t2[0].toFixed(ft)) + " + " + parseFloat(t2[1].toFixed(ft)) + "j" : H(t2) ? "'" + t2 + "'" : "bool" === n2 ? vt(t2) : parseFloat(t2.toFixed(ft)).toString(), e2);
}
function vt(t2) {
  return 0 === t2 ? "false" : "true";
}
function mt(t2) {
  for (var e2 = [], n2 = 0; n2 < t2.length; n2 += 2) e2.push([t2[n2], t2[n2 + 1]]);
  return e2;
}
function Dt(t2, e2) {
  if ("string" === t2 || "string" === e2) {
    if ("string" === t2 && "string" === e2) return "string";
    throw new Error("Can not upcast " + t2 + " with " + e2);
  }
  return At[t2][e2];
}
function Tt(t2) {
  return Dt(t2, "int32");
}
function Nt(t2, e2) {
  if (t2.dtype === e2.dtype) return [t2, e2];
  var n2 = Dt(t2.dtype, e2.dtype);
  return [t2.cast(n2), e2.cast(n2)];
}
function Ft(t2, e2) {
  C(t2.dtype === e2.dtype, function() {
    return "The dtypes of the first(" + t2.dtype + ") and second(" + e2.dtype + ") input must match";
  });
}
function _t(t2) {
  var e2 = [];
  return function t3(e3, n2, r2) {
    if (null == e3) return;
    if (e3 instanceof wt) return void n2.push(e3);
    if (o2 = e3, !Array.isArray(o2) && "object" != typeof o2) return;
    var o2;
    var a2 = e3;
    for (var i2 in a2) {
      var s2 = a2[i2];
      r2.has(s2) || (r2.add(s2), t3(s2, n2, r2));
    }
  }(t2, e2, /* @__PURE__ */ new Set()), e2;
}
function Wt() {
  return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope;
}
function Kt(t2, e2) {
  Ht[t2] = e2;
}
function jt(t2) {
  t2 in Ht || (Ht[t2] = function(t3) {
    if (1 !== t3 && 2 !== t3) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
    var e3 = function(t4) {
      if ("undefined" != typeof OffscreenCanvas && 2 === t4) return new OffscreenCanvas(300, 150);
      if ("undefined" != typeof document) return document.createElement("canvas");
      throw new Error("Cannot create a canvas in this context");
    }(t3);
    if (e3.addEventListener("webglcontextlost", function(e4) {
      e4.preventDefault(), delete Ht[t3];
    }, false), 1 === t3) return e3.getContext("webgl", qt) || e3.getContext("experimental-webgl", qt);
    return e3.getContext("webgl2", qt);
  }(t2));
  var e2 = Ht[t2];
  return e2.isContextLost() ? (delete Ht[t2], jt(t2)) : (e2.disable(e2.DEPTH_TEST), e2.disable(e2.STENCIL_TEST), e2.disable(e2.BLEND), e2.disable(e2.DITHER), e2.disable(e2.POLYGON_OFFSET_FILL), e2.disable(e2.SAMPLE_COVERAGE), e2.enable(e2.SCISSOR_TEST), e2.enable(e2.CULL_FACE), e2.cullFace(e2.BACK), Ht[t2]);
}
function Xt(t2, e2) {
  return [e2, t2];
}
function Yt(t2) {
  var e2 = k(t2);
  return T(Math.ceil(e2 / 4));
}
function $t(t2, e2) {
  return [Math.max(1, Math.ceil(e2 / 2)), Math.max(1, Math.ceil(t2 / 2))];
}
function Qt(t2, e2) {
  var n2, r2, o2, a2, s2, u3, c2, l2, h2, f2 = t2;
  return 2 === i().getNumber("WEBGL_VERSION") ? (n2 = f2.R32F, r2 = f2.R16F, o2 = f2.RGBA16F, a2 = f2.RGBA32F, s2 = f2.RED, u3 = 4, c2 = 1, l2 = f2.HALF_FLOAT, h2 = f2.FLOAT) : (n2 = t2.RGBA, r2 = t2.RGBA, o2 = t2.RGBA, a2 = f2.RGBA, s2 = t2.RGBA, u3 = 4, c2 = 4, l2 = null != e2 ? e2.HALF_FLOAT_OES : null, h2 = t2.FLOAT), { internalFormatFloat: n2, internalFormatHalfFloat: r2, internalFormatPackedHalfFloat: o2, internalFormatPackedFloat: a2, textureFormatFloat: s2, downloadTextureFormat: t2.RGBA, downloadUnpackNumChannels: u3, defaultNumChannels: c2, textureTypeHalfFloat: l2, textureTypeFloat: h2 };
}
function Jt(t2, e2, n2) {
  var r2 = n2();
  return e2 && function(t3) {
    var e3 = t3.getError();
    if (e3 !== t3.NO_ERROR) throw new Error("WebGL Error: " + ne(t3, e3));
  }(t2), r2;
}
function ee(t2) {
  return !!(i().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === t2 || Zt < Math.abs(t2) && Math.abs(t2) < te);
}
function ne(t2, e2) {
  switch (e2) {
    case t2.NO_ERROR:
      return "NO_ERROR";
    case t2.INVALID_ENUM:
      return "INVALID_ENUM";
    case t2.INVALID_VALUE:
      return "INVALID_VALUE";
    case t2.INVALID_OPERATION:
      return "INVALID_OPERATION";
    case t2.INVALID_FRAMEBUFFER_OPERATION:
      return "INVALID_FRAMEBUFFER_OPERATION";
    case t2.OUT_OF_MEMORY:
      return "OUT_OF_MEMORY";
    case t2.CONTEXT_LOST_WEBGL:
      return "CONTEXT_LOST_WEBGL";
    default:
      return "Unknown error code " + e2;
  }
}
function re(t2, e2, n2) {
  return ke(t2, e2, function() {
    return t2.getExtension(n2);
  }, 'Extension "' + n2 + '" not supported on this browser.');
}
function oe(t2, e2, n2) {
  var r2 = ke(t2, e2, function() {
    return t2.createShader(t2.VERTEX_SHADER);
  }, "Unable to create vertex WebGLShader.");
  if (Jt(t2, e2, function() {
    return t2.shaderSource(r2, n2);
  }), Jt(t2, e2, function() {
    return t2.compileShader(r2);
  }), false === t2.getShaderParameter(r2, t2.COMPILE_STATUS)) throw console.log(t2.getShaderInfoLog(r2)), new Error("Failed to compile vertex shader.");
  return r2;
}
function ae(t2, e2, n2) {
  var r2 = ke(t2, e2, function() {
    return t2.createShader(t2.FRAGMENT_SHADER);
  }, "Unable to create fragment WebGLShader.");
  if (Jt(t2, e2, function() {
    return t2.shaderSource(r2, n2);
  }), Jt(t2, e2, function() {
    return t2.compileShader(r2);
  }), false === t2.getShaderParameter(r2, t2.COMPILE_STATUS)) throw function(t3, e3) {
    var n3 = ue.exec(e3);
    if (null == n3) return console.log("Couldn't parse line number in error: " + e3), void console.log(t3);
    for (var r3 = +n3[1], o2 = t3.split("\n"), a2 = o2.length.toString().length + 2, i2 = o2.map(function(t4, e4) {
      return N((e4 + 1).toString(), a2) + t4;
    }), s2 = 0, u3 = 0; u3 < i2.length; u3++) s2 = Math.max(i2[u3].length, s2);
    var c2 = i2.slice(0, r3 - 1), l2 = i2.slice(r3 - 1, r3), h2 = i2.slice(r3);
    console.log(c2.join("\n")), console.log(e3.split("\n")[0]), console.log("%c " + N(l2[0], s2), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(h2.join("\n"));
  }(n2, t2.getShaderInfoLog(r2)), new Error("Failed to compile fragment shader.");
  return r2;
}
function ce(t2, e2) {
  return ke(t2, e2, function() {
    return t2.createProgram();
  }, "Unable to create WebGLProgram.");
}
function le(t2, e2, n2) {
  if (Jt(t2, e2, function() {
    return t2.linkProgram(n2);
  }), false === t2.getProgramParameter(n2, t2.LINK_STATUS)) throw console.log(t2.getProgramInfoLog(n2)), new Error("Failed to link vertex and fragment shaders.");
}
function he(t2, e2, n2) {
  if (Jt(t2, e2, function() {
    return t2.validateProgram(n2);
  }), false === t2.getProgramParameter(n2, t2.VALIDATE_STATUS)) throw console.log(t2.getProgramInfoLog(n2)), new Error("Shader program validation failed.");
}
function fe(t2, e2, n2) {
  var r2 = ke(t2, e2, function() {
    return t2.createBuffer();
  }, "Unable to create WebGLBuffer");
  return Jt(t2, e2, function() {
    return t2.bindBuffer(t2.ARRAY_BUFFER, r2);
  }), Jt(t2, e2, function() {
    return t2.bufferData(t2.ARRAY_BUFFER, n2, t2.STATIC_DRAW);
  }), r2;
}
function de(t2, e2, n2) {
  var r2 = ke(t2, e2, function() {
    return t2.createBuffer();
  }, "Unable to create WebGLBuffer");
  return Jt(t2, e2, function() {
    return t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, r2);
  }), Jt(t2, e2, function() {
    return t2.bufferData(t2.ELEMENT_ARRAY_BUFFER, n2, t2.STATIC_DRAW);
  }), r2;
}
function pe(t2, e2) {
  return ke(t2, e2, function() {
    return t2.createTexture();
  }, "Unable to create WebGLTexture.");
}
function ve(t2, e2) {
  var n2 = i().getNumber("WEBGL_MAX_TEXTURE_SIZE");
  if (t2 <= 0 || e2 <= 0) {
    var r2 = "[" + t2 + "x" + e2 + "]";
    throw new Error("Requested texture size " + r2 + " is invalid.");
  }
  if (t2 > n2 || e2 > n2) {
    r2 = "[" + t2 + "x" + e2 + "]";
    throw new Error("Requested texture size " + r2 + " greater than WebGL maximum on this browser / GPU " + ("[" + n2 + "x" + n2 + "]") + ".");
  }
}
function me(t2, e2) {
  return ke(t2, e2, function() {
    return t2.createFramebuffer();
  }, "Unable to create WebGLFramebuffer.");
}
function ge(t2, e2, n2, r2, o2, a2, i2, s2) {
  var u3 = t2.getAttribLocation(n2, r2);
  return -1 !== u3 && (Jt(t2, e2, function() {
    return t2.bindBuffer(t2.ARRAY_BUFFER, o2);
  }), Jt(t2, e2, function() {
    return t2.vertexAttribPointer(u3, a2, t2.FLOAT, false, i2, s2);
  }), Jt(t2, e2, function() {
    return t2.enableVertexAttribArray(u3);
  }), true);
}
function ye(t2, e2, n2, r2) {
  Se(t2, r2), Jt(t2, e2, function() {
    return t2.activeTexture(t2.TEXTURE0 + r2);
  }), Jt(t2, e2, function() {
    return t2.bindTexture(t2.TEXTURE_2D, n2);
  });
}
function xe(t2, e2, n2, r2) {
  return ke(t2, e2, function() {
    return t2.getUniformLocation(n2, r2);
  }, 'uniform "' + r2 + '" not present in program.');
}
function be(t2, e2, n2) {
  return t2.getUniformLocation(e2, n2);
}
function we(t2, e2, n2, r2, o2, a2) {
  Jt(t2, e2, function() {
    return ye(t2, e2, r2, a2);
  }), Jt(t2, e2, function() {
    return t2.uniform1i(o2, a2);
  });
}
function Ce(t2, e2, n2, r2) {
  Jt(t2, e2, function() {
    return t2.bindFramebuffer(t2.FRAMEBUFFER, r2);
  }), Jt(t2, e2, function() {
    return t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, n2, 0);
  });
}
function Ee(t2, e2, n2) {
  Jt(t2, e2, function() {
    return t2.bindFramebuffer(t2.FRAMEBUFFER, n2);
  }), Jt(t2, e2, function() {
    return t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, null, 0);
  });
}
function Re(t2) {
  var e2 = t2.checkFramebufferStatus(t2.FRAMEBUFFER);
  if (e2 !== t2.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + Ie(t2, e2));
}
function Ie(t2, e2) {
  switch (e2) {
    case t2.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    case t2.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    case t2.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
      return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    case t2.FRAMEBUFFER_UNSUPPORTED:
      return "FRAMEBUFFER_UNSUPPORTED";
    default:
      return "unknown error " + e2;
  }
}
function ke(t2, e2, n2, r2) {
  var o2 = Jt(t2, e2, function() {
    return n2();
  });
  if (null == o2) throw new Error(r2);
  return o2;
}
function Se(t2, e2) {
  var n2 = t2.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1, r2 = e2 + t2.TEXTURE0;
  if (r2 < t2.TEXTURE0 || r2 > n2) throw new Error("textureUnit must be in " + ("[gl.TEXTURE0, gl.TEXTURE" + n2 + "]") + ".");
}
function Ae(t2, e2) {
  return void 0 === e2 && (e2 = 2), k(t2.slice(0, t2.length - e2));
}
function De(t2) {
  if (0 === t2.length) throw Error("Cannot get rows and columns of an empty shape array.");
  return [t2.length > 1 ? t2[t2.length - 2] : 1, t2[t2.length - 1]];
}
function Te(t2) {
  var e2 = [1, 1, 1];
  return 0 === t2.length || 1 === t2.length && 1 === t2[0] || (e2 = [Ae(t2)].concat(De(t2))), e2;
}
function Ne(t2, e2) {
  var n2;
  void 0 === e2 && (e2 = false);
  var r2 = i().getNumber("WEBGL_MAX_TEXTURE_SIZE");
  if (e2 && (r2 *= 2, 1 === (t2 = t2.map(function(e3, n3) {
    return n3 >= t2.length - 2 ? b(t2[n3]) : t2[n3];
  })).length && (t2 = [2, t2[0]])), 2 !== t2.length) {
    var o2 = M(t2);
    t2 = o2.newShape;
  }
  var a2 = k(t2);
  if (t2.length <= 1 && a2 <= r2) return [1, a2];
  if (2 === t2.length && t2[0] <= r2 && t2[1] <= r2) return t2;
  if (3 === t2.length && t2[0] * t2[1] <= r2 && t2[2] <= r2) return [t2[0] * t2[1], t2[2]];
  if (3 === t2.length && t2[0] <= r2 && t2[1] * t2[2] <= r2) return [t2[0], t2[1] * t2[2]];
  if (4 === t2.length && t2[0] * t2[1] * t2[2] <= r2 && t2[3] <= r2) return [t2[0] * t2[1] * t2[2], t2[3]];
  if (4 === t2.length && t2[0] <= r2 && t2[1] * t2[2] * t2[3] <= r2) return [t2[0], t2[1] * t2[2] * t2[3]];
  if (e2) {
    var s2 = Ae(t2), u3 = 2, c2 = 2;
    return t2.length && (u3 = (n2 = De(t2))[0], c2 = n2[1]), T(a2 = s2 * (u3 / 2) * (c2 / 2)).map(function(t3) {
      return 2 * t3;
    });
  }
  return T(a2);
}
function Fe(t2) {
  return t2 % 2 == 0;
}
function _e(t2, e2) {
  if (S(t2 = t2.slice(-2), e2 = e2.slice(-2))) return true;
  if (!t2.length || !e2.length) return true;
  if (0 === t2[0] || 0 === t2[1] || 0 === e2[0] || 0 === e2[1]) return true;
  if (t2.length !== e2.length) {
    var n2 = t2.slice(-1)[0], r2 = e2.slice(-1)[0];
    if (n2 === r2) return true;
    if (Fe(n2) && Fe(r2) && (1 === t2[0] || 1 === e2[0])) return true;
  }
  return t2[1] === e2[1] && Fe(t2[0]) && Fe(e2[0]);
}
function Oe(t2) {
  if (null == ie) {
    var e2 = jt(t2);
    ie = e2.getParameter(e2.MAX_TEXTURE_SIZE);
  }
  return ie;
}
function Me(t2) {
  if (null == se) {
    var e2 = jt(t2);
    se = e2.getParameter(e2.MAX_TEXTURE_IMAGE_UNITS);
  }
  return Math.min(16, se);
}
function Be(t2) {
  if (0 === t2) return 0;
  var e2 = jt(t2);
  return Pe(e2, "EXT_disjoint_timer_query_webgl2") && 2 === t2 ? 2 : Pe(e2, "EXT_disjoint_timer_query") ? 1 : 0;
}
function Pe(t2, e2) {
  return null != t2.getExtension(e2);
}
function Le(t2) {
  try {
    if (null != jt(t2)) return true;
  } catch (t3) {
    return false;
  }
  return false;
}
function We(t2) {
  if (0 === t2) return false;
  var e2 = jt(t2);
  if (1 === t2) {
    if (!Pe(e2, "OES_texture_float")) return false;
  } else if (!Pe(e2, "EXT_color_buffer_float")) return false;
  return Ve(e2);
}
function Ue(t2) {
  if (0 === t2) return false;
  var e2 = jt(t2);
  if (1 !== t2) {
    if (Pe(e2, "EXT_color_buffer_float")) return Ve(e2);
    if (Pe(e2, "EXT_color_buffer_half_float")) {
      var n2 = e2.getExtension("EXT_color_buffer_half_float");
      return function(t3, e3) {
        var n3 = Qt(t3, e3), r2 = t3.createTexture();
        t3.bindTexture(t3.TEXTURE_2D, r2);
        t3.texImage2D(t3.TEXTURE_2D, 0, n3.internalFormatHalfFloat, 1, 1, 0, n3.textureFormatFloat, n3.textureTypeHalfFloat, null);
        var o2 = t3.createFramebuffer();
        t3.bindFramebuffer(t3.FRAMEBUFFER, o2), t3.framebufferTexture2D(t3.FRAMEBUFFER, t3.COLOR_ATTACHMENT0, t3.TEXTURE_2D, r2, 0);
        var a2 = t3.checkFramebufferStatus(t3.FRAMEBUFFER) === t3.FRAMEBUFFER_COMPLETE;
        return t3.bindTexture(t3.TEXTURE_2D, null), t3.bindFramebuffer(t3.FRAMEBUFFER, null), t3.deleteTexture(r2), t3.deleteFramebuffer(o2), a2;
      }(e2, n2);
    }
    return false;
  }
  return !!Pe(e2, "OES_texture_float") && (!!Pe(e2, "WEBGL_color_buffer_float") && Ve(e2));
}
function Ve(t2) {
  var e2 = Qt(t2), n2 = t2.createTexture();
  t2.bindTexture(t2.TEXTURE_2D, n2);
  t2.texImage2D(t2.TEXTURE_2D, 0, e2.internalFormatFloat, 1, 1, 0, e2.textureFormatFloat, e2.textureTypeFloat, null);
  var r2 = t2.createFramebuffer();
  t2.bindFramebuffer(t2.FRAMEBUFFER, r2), t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, n2, 0);
  var o2 = t2.checkFramebufferStatus(t2.FRAMEBUFFER) === t2.FRAMEBUFFER_COMPLETE;
  return t2.bindTexture(t2.TEXTURE_2D, null), t2.bindFramebuffer(t2.FRAMEBUFFER, null), t2.deleteTexture(n2), t2.deleteFramebuffer(r2), o2;
}
function ze(t2) {
  return 2 === t2 && null != jt(t2).fenceSync;
}
function Xe(t2) {
  i().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(t2 + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
}
function Ze(t2, e2) {
  return Lt.tidy(t2, e2);
}
function tn(t2) {
  _t(t2).forEach(function(t3) {
    return t3.dispose();
  });
}
function en(t2) {
  return Lt.keep(t2);
}
function dn() {
  for (var t2 = [], e2 = 0; e2 < arguments.length; e2++) t2[e2] = arguments[e2];
  i().getBool("IS_TEST") || console.warn.apply(console, t2);
}
function pn(t2, e2) {
  var n2 = t2;
  if (V(t2)) return "string" === e2 ? [] : [t2.length];
  if (!Array.isArray(t2)) return [];
  for (var r2 = []; Array.isArray(n2) || V(n2) && "string" !== e2; ) r2.push(n2.length), n2 = n2[0];
  return Array.isArray(t2) && i().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && function t3(e3, n3, r3) {
    if (r3 = r3 || [], !Array.isArray(e3) && !V(e3)) return void C(0 === n3.length, function() {
      return "Element arr[" + r3.join("][") + "] is a primitive, but should be an array/TypedArray of " + n3[0] + " elements";
    });
    C(n3.length > 0, function() {
      return "Element arr[" + r3.join("][") + "] should be a primitive, but is an array of " + e3.length + " elements";
    }), C(e3.length === n3[0], function() {
      return "Element arr[" + r3.join("][") + "] should have " + n3[0] + " elements, but has " + e3.length + " elements";
    });
    for (var o2 = n3.slice(1), a2 = 0; a2 < e3.length; ++a2) t3(e3[a2], o2, r3.concat(a2));
  }(t2, r2, []), r2;
}
function vn(t2, e2, n2, r2) {
  if (null != t2 && ("numeric" !== t2 && t2 !== e2 || "numeric" === t2 && "string" === e2)) throw new Error("Argument '" + n2 + "' passed to '" + r2 + "' must be " + t2 + " tensor, but got " + e2 + " tensor");
}
function mn(t2, e2, n2, r2) {
  if (void 0 === r2 && (r2 = "numeric"), t2 instanceof wt) return vn(r2, t2.dtype, e2, n2), t2;
  var o2 = j(t2);
  if ("string" !== o2 && ["bool", "int32", "float32"].indexOf(r2) >= 0 && (o2 = r2), vn(r2, o2, e2, n2), null == t2 || !V(t2) && !Array.isArray(t2) && "number" != typeof t2 && "boolean" != typeof t2 && "string" != typeof t2) {
    var a2 = null == t2 ? "null" : t2.constructor.name;
    throw new Error("Argument '" + e2 + "' passed to '" + n2 + "' must be a Tensor or TensorLike, but got '" + a2 + "'");
  }
  var s2 = pn(t2, o2);
  V(t2) || Array.isArray(t2) || (t2 = [t2]);
  var u3 = "string" !== o2 ? Q(t2, o2, i().getBool("DEBUG")) : I(t2, [], true);
  return Lt.makeTensor(u3, s2, o2);
}
function gn(t2, e2, n2, r2) {
  if (void 0 === r2 && (r2 = "numeric"), !Array.isArray(t2)) throw new Error("Argument " + e2 + " passed to " + n2 + " must be a `Tensor[]` or `TensorLike[]`");
  return t2.map(function(t3, r3) {
    return mn(t3, e2 + "[" + r3 + "]", n2);
  }, r2);
}
function yn(t2, e2) {
  for (var n2 = 0; n2 < t2.length; ++n2) if (t2[t2.length - n2 - 1] !== e2 - 1 - n2) return false;
  return true;
}
function xn(t2, e2, n2) {
  for (var r2 = t2.length + e2.length, o2 = [], a2 = 0, i2 = 0, s2 = 0; s2 < r2; s2++) -1 === n2.indexOf(s2) ? o2.push(t2[a2++]) : o2.push(e2[i2++]);
  return o2;
}
function bn(t2, e2) {
  for (var n2 = [], r2 = t2.length, o2 = 0; o2 < r2; o2++) -1 === e2.indexOf(o2) && n2.push(t2[o2]);
  return [n2, e2.map(function(e3) {
    return t2[e3];
  })];
}
function wn(t2, e2) {
  return xn(t2, e2.map(function(t3) {
    return 1;
  }), e2);
}
function Cn(t2, e2, n2) {
  C(yn(e2, n2), function() {
    return t2 + " supports only inner-most axes for now. Got axes " + e2 + " and rank-" + n2 + " input.";
  });
}
function En(t2, e2) {
  if (yn(t2, e2)) return null;
  for (var n2 = [], r2 = 0; r2 < e2; ++r2) -1 === t2.indexOf(r2) && n2.push(r2);
  return t2.forEach(function(t3) {
    return n2.push(t3);
  }), n2;
}
function Rn(t2) {
  return t2.map(function(t3, e2) {
    return [e2, t3];
  }).sort(function(t3, e2) {
    return t3[1] - e2[1];
  }).map(function(t3) {
    return t3[0];
  });
}
function In(t2, e2) {
  for (var n2 = [], r2 = e2 - t2; r2 < e2; ++r2) n2.push(r2);
  return n2;
}
function kn(t2, e2) {
  var n2 = t2[0].length;
  t2.forEach(function(t3, e3) {
    C(t3.length === n2, function() {
      return "Error in concat" + n2 + "D: rank of tensors[" + e3 + "] must be the same as the rank of the rest (" + n2 + ")";
    });
  }), C(e2 >= 0 && e2 < n2, function() {
    return "Error in concat" + n2 + "D: axis must be between 0 and " + (n2 - 1) + ".";
  });
  var r2 = t2[0];
  t2.forEach(function(t3, o2) {
    for (var a2 = 0; a2 < n2; a2++) C(a2 === e2 || t3[a2] === r2[a2], function() {
      return "Error in concat" + n2 + "D: Shape of tensors[" + o2 + "] (" + t3 + ") does not match the shape of the rest (" + r2 + ") along the non-concatenated axis " + o2 + ".";
    });
  });
}
function Sn(t2, e2) {
  for (var n2 = t2[0].slice(), r2 = 1; r2 < t2.length; r2++) n2[e2] += t2[r2][e2];
  return n2;
}
function An(t2) {
  var e2 = Object.keys(t2);
  if (1 !== e2.length) throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with " + e2.length + " keys.");
  var n2 = e2[0], r2 = t2[n2];
  n2.endsWith("_") && (n2 = n2.substring(0, n2.length - 1));
  var o2 = function() {
    for (var t3 = [], e3 = 0; e3 < arguments.length; e3++) t3[e3] = arguments[e3];
    Lt.startScope(n2);
    try {
      var o3 = r2.apply(void 0, t3);
      return o3 instanceof Promise && console.error("Cannot return a Promise inside of tidy."), Lt.endScope(o3), o3;
    } catch (t4) {
      throw Lt.endScope(null), t4;
    }
  };
  return Object.defineProperty(o2, "name", { value: n2, configurable: true }), o2;
}
function Fn(t2, e2, n2) {
  return _n(t2, e2, pn(t2, n2), n2);
}
function _n(t2, e2, n2, r2) {
  if (null == r2 && (r2 = j(t2)), "complex64" === r2) throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
  if (!V(t2) && !Array.isArray(t2) && "number" != typeof t2 && "boolean" != typeof t2 && "string" != typeof t2) throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
  if (null != e2) {
    nt(e2);
    var o2 = k(e2), a2 = k(n2);
    C(o2 === a2, function() {
      return "Based on the provided shape, [" + e2 + "], the tensor should have " + o2 + " values but has " + a2;
    });
    for (var s2 = 0; s2 < n2.length; ++s2) {
      var u3 = n2[s2], c2 = s2 !== n2.length - 1 || u3 !== k(e2.slice(s2));
      C(n2[s2] === e2[s2] || !c2, function() {
        return "Error creating a new Tensor. Inferred shape (" + n2 + ") does not match the provided shape (" + e2 + "). ";
      });
    }
  }
  return V(t2) || Array.isArray(t2) || (t2 = [t2]), e2 = e2 || n2, t2 = "string" !== r2 ? Q(t2, r2, i().getBool("DEBUG")) : I(t2, [], true), Lt.makeTensor(t2, e2, r2);
}
function On(t2, e2) {
  if ((V(t2) && "string" !== e2 || Array.isArray(t2)) && "complex64" !== e2) throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
  if ("string" === e2 && V(t2) && !(t2 instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
  return _n(t2, [], [], e2);
}
function Mn(t2, e2) {
  R(t2);
  var n2 = pn(t2, e2);
  if (1 !== n2.length) throw new Error("tensor1d() requires values to be a flat/TypedArray");
  return _n(t2, null, n2, e2);
}
function Bn(t2, e2, n2) {
  if (R(t2), null != e2 && 2 !== e2.length) throw new Error("tensor2d() requires shape to have two numbers");
  var r2 = pn(t2, n2);
  if (2 !== r2.length && 1 !== r2.length) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
  if (1 === r2.length && null == e2) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
  return _n(t2, e2, r2, n2);
}
function Pn(t2, e2, n2) {
  if (R(t2), null != e2 && 3 !== e2.length) throw new Error("tensor3d() requires shape to have three numbers");
  var r2 = pn(t2, n2);
  if (3 !== r2.length && 1 !== r2.length) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
  if (1 === r2.length && null == e2) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
  return _n(t2, e2, r2, n2);
}
function Ln(t2, e2, n2) {
  if (R(t2), null != e2 && 4 !== e2.length) throw new Error("tensor4d() requires shape to have four numbers");
  var r2 = pn(t2, n2);
  if (4 !== r2.length && 1 !== r2.length) throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
  if (1 === r2.length && null == e2) throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
  return _n(t2, e2, r2, n2);
}
function Wn(t2, e2, n2) {
  if (R(t2), null != e2 && 5 !== e2.length) throw new Error("tensor5d() requires shape to have five numbers");
  var r2 = pn(t2, n2);
  if (5 !== r2.length && 1 !== r2.length) throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
  if (1 === r2.length && null == e2) throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
  return _n(t2, e2, r2, n2);
}
function Un(t2, e2, n2) {
  if (R(t2), null != e2 && 6 !== e2.length) throw new Error("tensor6d() requires shape to have six numbers");
  var r2 = pn(t2, n2);
  if (6 !== r2.length && 1 !== r2.length) throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
  if (1 === r2.length && null == e2) throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
  return _n(t2, e2 = e2 || r2, r2, n2);
}
function Vn(t2, e2, n2, r2) {
  return void 0 === e2 && (e2 = true), Lt.makeVariable(t2, e2, n2, r2);
}
function zn(t2, e2) {
  if (void 0 === e2 && (e2 = "float32"), "complex64" === e2) {
    var n2 = zn(t2, "float32"), r2 = Gn(t2, "float32");
    return Dn(n2, r2);
  }
  var o2 = Z(k(t2), e2);
  return Lt.makeTensor(o2, t2, e2);
}
function Gn(t2, e2) {
  if (void 0 === e2 && (e2 = "float32"), "complex64" === e2) {
    var n2 = Gn(t2, "float32"), r2 = Gn(t2, "float32");
    return Dn(n2, r2);
  }
  var o2 = tt(k(t2), e2);
  return Lt.makeTensor(o2, t2, e2);
}
function Hn(t2, e2, n2) {
  return Lt.runKernelFunc(function(r2) {
    return r2.fill(t2, e2, n2);
  }, {});
}
function qn(t2, e2, n2) {
  if (n2 <= 0) throw new Error("The number of values should be positive.");
  return Lt.runKernelFunc(function(r2) {
    return r2.linspace(t2, e2, n2);
  }, {});
}
function Kn(t2, e2, n2, r2) {
  if (void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = "float32"), 0 === n2) throw new Error("Cannot have a step of zero");
  if (t2 === e2 || t2 < e2 && n2 < 0 || e2 < t2 && n2 > 1) return Gn([0], r2);
  var o2 = tt(Math.abs(Math.ceil((e2 - t2) / n2)), r2);
  e2 < t2 && 1 === n2 && (n2 = -1), o2[0] = t2;
  for (var a2 = 1; a2 < o2.length; a2++) o2[a2] = o2[a2 - 1] + n2;
  return Mn(o2, r2);
}
function er(t2, e2) {
  return t2(e2 = { exports: {} }, e2.exports), e2.exports;
}
function dr(t2, e2, n2) {
  return void 0 === e2 && (e2 = "float32"), e2 = e2 || "float32", nt(t2), new gt(t2, e2, n2);
}
function pr(t2, e2) {
  void 0 === e2 && (e2 = false), console.log(t2.toString(e2));
}
function zr(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = true);
  var o2 = [];
  if (r2) (o2 = o2.concat(e2.slice(0))).push(t2[0] / n2), o2 = o2.concat(t2.slice(1));
  else {
    o2 = o2.concat(t2[0]);
    for (var a2 = e2.length, i2 = 0; i2 < a2; ++i2) o2 = o2.concat([t2[i2 + 1] / e2[i2], e2[i2]]);
    o2 = o2.concat(t2.slice(a2 + 1));
  }
  return o2;
}
function Gr(t2, e2, n2) {
  void 0 === n2 && (n2 = true);
  var r2 = [];
  if (n2) {
    r2.push(e2);
    for (var o2 = e2 + 1; o2 < t2; ++o2) o2 <= 2 * e2 ? (r2.push(o2), r2.push(o2 - (e2 + 1))) : r2.push(o2);
  } else {
    var a2 = [], i2 = [];
    for (o2 = 1; o2 < t2; ++o2) o2 >= 2 * e2 + 1 || o2 % 2 == 1 ? i2.push(o2) : a2.push(o2);
    r2.push.apply(r2, a2), r2.push(0), r2.push.apply(r2, i2);
  }
  return r2;
}
function Hr(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = true);
  var o2 = [];
  r2 ? o2.push(t2[0] / n2) : o2.push(t2[0] * n2);
  for (var a2 = 1; a2 < t2.length; ++a2) a2 <= e2.length ? r2 ? o2.push(e2[a2 - 1] * t2[a2]) : o2.push(t2[a2] / e2[a2 - 1]) : o2.push(t2[a2]);
  return o2;
}
function qr(t2, e2) {
  for (var n2 = [0], r2 = 0; r2 < e2; ++r2) n2.push(t2[r2][0]);
  return n2;
}
function Kr(t2, e2, n2) {
  for (var r2 = t2.slice(0, 1), o2 = 0; o2 < n2; ++o2) r2.push(t2[o2 + 1] - e2[o2][0] - e2[o2][1]);
  return r2;
}
function jr(t2, e2) {
  if (t2.rank < 1) throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was " + t2.rank + ".");
  if (e2.rank < 1) throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was " + e2.rank + ".");
  if ("int32" !== e2.dtype) throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was " + e2.dtype + ".");
  if (e2.shape[e2.rank - 1] > t2.rank) throw new Error("index innermost dimension length must be <= tensor rank; saw: " + e2.shape[e2.rank - 1] + " vs. " + t2.rank);
  if (0 === t2.size) throw new Error("Requested more than 0 entries, but input is empty. Input shape: " + t2.shape + ".");
  for (var n2 = e2.shape, r2 = n2[n2.length - 1], o2 = 1, a2 = 0; a2 < n2.length - 1; ++a2) o2 *= n2[a2];
  var i2 = t2.shape, s2 = n2.slice();
  s2.pop();
  var u3 = 1;
  for (a2 = r2; a2 < t2.rank; ++a2) u3 *= i2[a2], s2.push(i2[a2]);
  var c2 = $(t2.shape).map(function(t3) {
    return t3 / u3;
  }).concat([1]).slice(0, r2);
  return [s2, o2, u3, c2];
}
function $r(t2) {
  return t2 <= Yr ? t2 : Y(t2, Math.floor(Math.sqrt(t2)));
}
function Qr(t2, e2, n2) {
  var r2 = e2.rank > 1 ? e2.shape[e2.rank - 1] : 1, o2 = e2.rank > 1 ? e2.rank - 1 : 1, a2 = "Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: " + n2.shape + ", indices.shape: " + e2.shape + ", shape: " + t2 + ", sliceDim: " + r2 + ", and batchDim: " + o2 + ".";
  if (n2.rank < o2) throw new Error(a2 + " update.rank < " + o2 + ". ");
  if (t2.length < r2 + (n2.rank - o2)) throw new Error(a2 + " Output shape length < " + (r2 + (n2.rank - o2)));
  if (n2.rank !== o2 + t2.length - r2) throw new Error(a2 + " update.rank != " + (o2 + t2.length - r2));
  for (var i2 = 0; i2 < o2; ++i2) if (n2.shape[i2] !== e2.shape[i2]) throw new Error(a2 + " updates.shape[" + i2 + "] (" + n2.shape[i2] + ") != indices.shape[" + i2 + "] (" + e2.shape[i2] + ").");
  for (i2 = 0; i2 < n2.rank - o2; ++i2) if (n2.shape[i2 + o2] !== t2[i2 + r2]) throw new Error(a2 + " updates.shape[" + (i2 + o2) + "] (" + n2.shape[i2 + o2] + ") != shape[" + (i2 + o2) + "] (" + t2[i2 + o2] + ")");
}
function Jr(t2, e2, n2) {
  if (e2.rank < 1) throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was " + e2.rank + ".");
  if (t2.rank < 1) throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was " + t2.rank + ".");
  if ("int32" !== e2.dtype) throw new Error("The dtype of 'indices' should be int32, but got dtype: " + e2.dtype);
  if (n2.length < 1) throw new Error("Output rank must be greater or equal to 1, but got shape: " + n2);
  if (0 === n2.length) {
    if (0 === e2.size) throw new Error("Indices specified for empty output. indices shape: " + e2.shape);
    if (0 === t2.size) throw new Error("Updates specified for empty output. updates shape: " + t2.shape);
  }
  Qr(n2, e2, t2);
}
function Zr(t2, e2, n2) {
  for (var r2 = e2.shape.length, o2 = r2 > 1 ? e2.shape[r2 - 1] : 1, a2 = n2.length, i2 = 1, s2 = o2; s2 < a2; ++s2) i2 *= n2[s2];
  var u3 = o2 < 1 ? 1 : o2;
  return { sliceRank: o2, numUpdates: k(e2.shape) / u3, sliceSize: i2, strides: $(n2.slice(0, o2)).concat([1]), outputSize: k(n2) };
}
function eo(t2, e2, n2) {
  C(t2.rank === e2.length, function() {
    return "Error in slice" + t2.rank + "D: Length of begin " + e2 + " must match the rank of the array (" + t2.rank + ").";
  }), C(t2.rank === n2.length, function() {
    return "Error in slice" + t2.rank + "D: Length of size " + n2 + " must match the rank of the array (" + t2.rank + ").";
  });
  for (var r2 = function(r3) {
    C(e2[r3] + n2[r3] <= t2.shape[r3], function() {
      return "Error in slice" + t2.rank + "D: begin[" + r3 + "] + size[" + r3 + "] (" + (e2[r3] + n2[r3]) + ") would overflow input.shape[" + r3 + "] (" + t2.shape[r3] + ")";
    });
  }, o2 = 0; o2 < t2.rank; ++o2) r2(o2);
}
function no(t2) {
  for (var e2 = [], n2 = 0; t2 > 0; ) 1 & t2 && e2.push(n2), t2 /= 2, n2++;
  return e2;
}
function ro(t2, e2, n2) {
  for (var r2 = [], o2 = 0; o2 < t2.length; o2++) r2[o2] = Math.ceil((e2[o2] - t2[o2]) / n2[o2]);
  return r2;
}
function oo(t2, e2, n2, r2, o2) {
  var a2 = e2[o2], i2 = n2[o2] || 1;
  (t2 & 1 << o2 || null == a2) && (a2 = i2 > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
  var s2 = r2[o2];
  return a2 < 0 && (a2 += s2), a2 = x(0, a2, s2 - 1);
}
function ao(t2, e2, n2, r2, o2) {
  var a2 = e2[o2], i2 = n2[o2] || 1;
  (t2 & 1 << o2 || null == a2) && (a2 = i2 > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
  var s2 = r2[o2];
  return a2 < 0 && (a2 += s2), a2 = i2 > 0 ? x(0, a2, s2) : x(-1, a2, s2 - 1);
}
function io(t2, e2, n2) {
  for (var r2 = n2.length, o2 = 0; o2 < n2.length; o2++) if (n2[o2] > 1) {
    r2 = o2;
    break;
  }
  for (o2 = r2 + 1; o2 < n2.length; o2++) if (e2[o2] > 0 || n2[o2] !== t2[o2]) return false;
  return true;
}
function so(t2, e2) {
  for (var n2 = t2.length > 0 ? t2[t2.length - 1] : 1, r2 = 0; r2 < t2.length - 1; r2++) n2 += t2[r2] * e2[r2];
  return n2;
}
function po(t2, e2) {
  C(X(t2), function() {
    return "The f passed in variableGrads(f) must be a function";
  }), C(null == e2 || Array.isArray(e2) && e2.every(function(t3) {
    return t3 instanceof St;
  }), function() {
    return "The varList passed in variableGrads(f, varList) must be an array of variables";
  });
  var n2 = null != e2;
  if (!n2) for (var r2 in e2 = [], Lt.registeredVariables) e2.push(Lt.registeredVariables[r2]);
  var o2 = n2 ? e2.filter(function(t3) {
    return !t3.trainable;
  }) : null, a2 = e2.length;
  C((e2 = e2.filter(function(t3) {
    return t3.trainable;
  })).length > 0, function() {
    return "variableGrads() expects at least one of the input variables to be trainable, but none of the " + a2 + " variables is trainable.";
  });
  var i2 = Lt.gradients(t2, e2, null, true), s2 = i2.value, u3 = i2.grads;
  C(u3.some(function(t3) {
    return null != t3;
  }), function() {
    return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().";
  }), C(0 === s2.rank, function() {
    return "The f passed in variableGrads(f) must return a scalar, but it returned a rank-" + s2.rank + " tensor";
  });
  var c2 = {};
  return e2.forEach(function(t3, e3) {
    null != u3[e3] && (c2[t3.name] = u3[e3]);
  }), null != o2 && o2.forEach(function(t3) {
    return c2[t3.name] = null;
  }), { value: s2, grads: c2 };
}
function vo(t2) {
  return Lt.customGrad(t2);
}
function wo(t2) {
  throw new Error("'" + t2 + "' not yet implemented or not found in the registry. Did you forget to import the kernel?");
}
function Co(t2, e2) {
  for (var n2 = t2.length, r2 = [], o2 = 0; o2 < n2; o2++) {
    var a2 = n2 - 1 - o2, i2 = t2[a2] || 1;
    (e2[e2.length - 1 - o2] || 1) > 1 && 1 === i2 && r2.unshift(a2);
  }
  return r2;
}
function Eo(t2, e2) {
  for (var n2 = [], r2 = 0; r2 < e2.length; r2++) {
    var o2 = t2[t2.length - r2 - 1], a2 = e2.length - r2 - 1, i2 = e2[a2];
    (null == o2 || 1 === o2 && i2 > 1) && n2.unshift(a2);
  }
  return n2;
}
function Ro(t2, e2) {
  for (var n2 = [], r2 = Math.max(t2.length, e2.length), o2 = 0; o2 < r2; o2++) {
    var a2 = t2[t2.length - o2 - 1];
    null == a2 && (a2 = 1);
    var i2 = e2[e2.length - o2 - 1];
    if (null == i2 && (i2 = 1), 1 === a2) n2.unshift(i2);
    else if (1 === i2) n2.unshift(a2);
    else {
      if (a2 !== i2) throw Error("Operands could not be broadcast together with shapes " + t2 + " and " + e2 + ".");
      n2.unshift(a2);
    }
  }
  return n2;
}
function Io(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === i2 && (i2 = "channelsLast");
  var s2, u3 = To(e2), c2 = u3[0], l2 = u3[1];
  if ("channelsLast" === i2) s2 = [c2, l2, t2[3], t2[3]];
  else {
    if ("channelsFirst" !== i2) throw new Error("Unknown dataFormat " + i2);
    s2 = [c2, l2, t2[1], t2[1]];
  }
  return So(t2, s2, n2, r2, o2, a2, false, i2);
}
function ko(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === i2 && (i2 = "NDHWC");
  var s2, u3, c2 = No(e2), l2 = c2[0], h2 = c2[1], f2 = c2[2];
  if ("NDHWC" === i2) u3 = "channelsLast", s2 = [l2, h2, f2, t2[4], t2[4]];
  else {
    if ("NCDHW" !== i2) throw new Error("Unknown dataFormat " + i2);
    u3 = "channelsFirst", s2 = [l2, h2, f2, t2[1], t2[1]];
  }
  return Ao(t2, s2, n2, r2, o2, false, u3, a2);
}
function So(t2, e2, n2, r2, o2, a2, i2, s2) {
  void 0 === i2 && (i2 = false), void 0 === s2 && (s2 = "channelsLast");
  var u3 = [-1, -1, -1, -1], c2 = u3[0], l2 = u3[1], h2 = u3[2], f2 = u3[3];
  if ("channelsLast" === s2) c2 = t2[0], l2 = t2[1], h2 = t2[2], f2 = t2[3];
  else {
    if ("channelsFirst" !== s2) throw new Error("Unknown dataFormat " + s2);
    c2 = t2[0], f2 = t2[1], l2 = t2[2], h2 = t2[3];
  }
  var d2, p2 = e2[0], v = e2[1], m = e2[3], g2 = To(n2), y2 = g2[0], x2 = g2[1], b2 = To(r2), w2 = b2[0], E2 = b2[1], R2 = Fo(p2, w2), I2 = Fo(v, E2), k2 = function(t3, e3, n3, r3, o3, a3, i3, s3) {
    var u4, c3, l3;
    if ("number" == typeof t3) {
      u4 = { top: t3, bottom: t3, left: t3, right: t3, type: 0 === t3 ? "VALID" : "NUMBER" };
      var h3 = function(t4, e4, n4, r4, o4) {
        null == r4 && (r4 = Do(t4, e4, n4));
        var a4 = t4[0], i4 = t4[1], s4 = _o((a4 - e4 + 2 * r4) / n4 + 1, o4);
        C(A(s4), function() {
          return "The output # of rows (" + s4 + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var u5 = _o((i4 - e4 + 2 * r4) / n4 + 1, o4);
        return C(A(u5), function() {
          return "The output # of columns (" + u5 + ") must be an integer. Change the stride and/or zero pad parameters";
        }), [s4, u5];
      }([e3, n3], a3, r3, t3, s3);
      c3 = h3[0], l3 = h3[1];
    } else if ("same" === t3) {
      c3 = Math.ceil(e3 / r3), l3 = Math.ceil(n3 / o3);
      var f3 = Math.max(0, (c3 - 1) * r3 + a3 - e3), d3 = Math.max(0, (l3 - 1) * o3 + i3 - n3), p3 = Math.floor(f3 / 2), v2 = f3 - p3, m2 = Math.floor(d3 / 2);
      u4 = { top: p3, bottom: v2, left: m2, right: d3 - m2, type: "SAME" };
    } else {
      if ("valid" !== t3) throw Error("Unknown padding parameter: " + t3);
      u4 = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" }, c3 = Math.ceil((e3 - a3 + 1) / r3), l3 = Math.ceil((n3 - i3 + 1) / o3);
    }
    return { padInfo: u4, outHeight: c3, outWidth: l3 };
  }(o2, l2, h2, y2, x2, R2, I2, a2), S2 = k2.padInfo, D2 = k2.outHeight, T2 = k2.outWidth, N2 = i2 ? m * f2 : m;
  return "channelsFirst" === s2 ? d2 = [c2, N2, D2, T2] : "channelsLast" === s2 && (d2 = [c2, D2, T2, N2]), { batchSize: c2, dataFormat: s2, inHeight: l2, inWidth: h2, inChannels: f2, outHeight: D2, outWidth: T2, outChannels: N2, padInfo: S2, strideHeight: y2, strideWidth: x2, filterHeight: p2, filterWidth: v, effectiveFilterHeight: R2, effectiveFilterWidth: I2, dilationHeight: w2, dilationWidth: E2, inShape: t2, outShape: d2, filterShape: e2 };
}
function Ao(t2, e2, n2, r2, o2, a2, i2, s2) {
  void 0 === a2 && (a2 = false), void 0 === i2 && (i2 = "channelsLast");
  var u3 = [-1, -1, -1, -1, -1], c2 = u3[0], l2 = u3[1], h2 = u3[2], f2 = u3[3], d2 = u3[4];
  if ("channelsLast" === i2) c2 = t2[0], l2 = t2[1], h2 = t2[2], f2 = t2[3], d2 = t2[4];
  else {
    if ("channelsFirst" !== i2) throw new Error("Unknown dataFormat " + i2);
    c2 = t2[0], d2 = t2[1], l2 = t2[2], h2 = t2[3], f2 = t2[4];
  }
  var p2, v = e2[0], m = e2[1], g2 = e2[2], y2 = e2[4], x2 = No(n2), b2 = x2[0], w2 = x2[1], E2 = x2[2], R2 = No(r2), I2 = R2[0], k2 = R2[1], S2 = R2[2], D2 = Fo(v, I2), T2 = Fo(m, k2), N2 = Fo(g2, S2), F2 = function(t3, e3, n3, r3, o3, a3, i3, s3, u4, c3, l3) {
    var h3, f3, d3, p3;
    if ("number" == typeof t3) {
      h3 = { top: t3, bottom: t3, left: t3, right: t3, front: t3, back: t3, type: 0 === t3 ? "VALID" : "NUMBER" };
      var v2 = function(t4, e4, n4, r4, o4, a4) {
        null == o4 && (o4 = Do(t4, e4, r4));
        var i4 = t4[0], s4 = t4[1], u5 = t4[2], c4 = _o((i4 - e4 + 2 * o4) / r4 + 1, a4);
        C(A(c4), function() {
          return "The output # of depths (" + c4 + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var l4 = _o((s4 - e4 + 2 * o4) / r4 + 1, a4);
        C(A(l4), function() {
          return "The output # of rows (" + l4 + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var h4 = _o((u5 - e4 + 2 * o4) / r4 + 1, a4);
        return C(A(h4), function() {
          return "The output # of columns (" + h4 + ") must be an integer. Change the stride and/or zero pad parameters";
        }), [c4, l4, h4, n4];
      }([e3, n3, r3, 1], s3, 1, o3, t3, l3);
      f3 = v2[0], d3 = v2[1], p3 = v2[2];
    } else if ("same" === t3) {
      f3 = Math.ceil(e3 / o3), d3 = Math.ceil(n3 / a3), p3 = Math.ceil(r3 / i3);
      var m2 = (f3 - 1) * o3 + s3 - e3, g3 = (d3 - 1) * a3 + u4 - n3, y3 = (p3 - 1) * i3 + c3 - r3, x3 = Math.floor(m2 / 2), b3 = m2 - x3, w3 = Math.floor(g3 / 2), E3 = g3 - w3, R3 = Math.floor(y3 / 2);
      h3 = { top: w3, bottom: E3, left: R3, right: y3 - R3, front: x3, back: b3, type: "SAME" };
    } else {
      if ("valid" !== t3) throw Error("Unknown padding parameter: " + t3);
      h3 = { top: 0, bottom: 0, left: 0, right: 0, front: 0, back: 0, type: "VALID" }, f3 = Math.ceil((e3 - s3 + 1) / o3), d3 = Math.ceil((n3 - u4 + 1) / a3), p3 = Math.ceil((r3 - c3 + 1) / i3);
    }
    return { padInfo: h3, outDepth: f3, outHeight: d3, outWidth: p3 };
  }(o2, l2, h2, f2, b2, w2, E2, D2, T2, N2, s2), _2 = F2.padInfo, O2 = F2.outDepth, M2 = F2.outHeight, B2 = F2.outWidth, P2 = a2 ? y2 * d2 : y2;
  return "channelsFirst" === i2 ? p2 = [c2, P2, O2, M2, B2] : "channelsLast" === i2 && (p2 = [c2, O2, M2, B2, P2]), { batchSize: c2, dataFormat: i2, inDepth: l2, inHeight: h2, inWidth: f2, inChannels: d2, outDepth: O2, outHeight: M2, outWidth: B2, outChannels: P2, padInfo: _2, strideDepth: b2, strideHeight: w2, strideWidth: E2, filterDepth: v, filterHeight: m, filterWidth: g2, effectiveFilterDepth: D2, effectiveFilterHeight: T2, effectiveFilterWidth: N2, dilationDepth: I2, dilationHeight: k2, dilationWidth: S2, inShape: t2, outShape: p2, filterShape: e2 };
}
function Do(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = 1);
  var o2 = Fo(e2, r2);
  return Math.floor((t2[0] * (n2 - 1) - n2 + o2) / 2);
}
function To(t2) {
  return "number" == typeof t2 ? [t2, t2, t2] : 2 === t2.length ? [t2[0], t2[1], 1] : t2;
}
function No(t2) {
  return "number" == typeof t2 ? [t2, t2, t2] : t2;
}
function Fo(t2, e2) {
  return e2 <= 1 ? t2 : t2 + (t2 - 1) * (e2 - 1);
}
function _o(t2, e2) {
  if (!e2) return t2;
  switch (e2) {
    case "round":
      return Math.round(t2);
    case "ceil":
      return Math.ceil(t2);
    case "floor":
      return Math.floor(t2);
    default:
      throw new Error("Unknown roundingMode " + e2);
  }
}
function Oo(t2) {
  var e2 = To(t2), n2 = e2[0], r2 = e2[1], o2 = e2[2];
  return 1 === n2 && 1 === r2 && 1 === o2;
}
function Mo(t2, e2) {
  return Oo(t2) || Oo(e2);
}
function Bo(t2) {
  if ("NHWC" === t2) return "channelsLast";
  if ("NCHW" === t2) return "channelsFirst";
  throw new Error("Unknown dataFormat " + t2);
}
function Po(t2, e2, n2) {
  if ("complex64" === e2) {
    if ("complex64" === t2.dtype) return t2.clone();
    var r2 = Gn(t2.shape), o2 = t2.toFloat(), a2 = n2.complex(o2, r2);
    return r2.dispose(), o2.dispose(), a2;
  }
  if (!U(t2.dtype, e2)) return Lt.makeTensorFromDataId(t2.dataId, t2.shape, e2);
  if ("complex64" === t2.dtype) {
    var i2 = n2.real(t2);
    a2 = i2.cast(e2);
    return i2.dispose(), a2;
  }
  if ("int32" === e2) return n2.int(t2);
  if ("bool" === e2) {
    var s2 = On(0, t2.dtype);
    a2 = n2.notEqual(t2, s2);
    return s2.dispose(), a2;
  }
  throw new Error("Error in Cast: failed to cast " + t2.dtype + " to " + e2);
}
function Lo(t2, e2) {
  return Lt.makeTensorFromDataId(t2.dataId, e2, t2.dtype);
}
function Wo(t2, e2, n2) {
  var r2 = (e2 - t2) / (n2 - 1), o2 = tt(n2, "float32");
  o2[0] = t2;
  for (var a2 = 1; a2 < o2.length; a2++) o2[a2] = o2[a2 - 1] + r2;
  return Mn(o2, "float32");
}
function Vo(t2, e2) {
  if (t2.length !== e2.length) throw new Error("Cannot merge real and imag arrays of different lengths. real:" + t2.length + ", imag: " + e2.length + ".");
  for (var n2 = new Float32Array(2 * t2.length), r2 = 0; r2 < n2.length; r2 += 2) n2[r2] = t2[r2 / 2], n2[r2 + 1] = e2[r2 / 2];
  return n2;
}
function zo(t2, e2) {
  return { real: t2[2 * e2], imag: t2[2 * e2 + 1] };
}
function Go(t2, e2, n2, r2) {
  t2[2 * r2] = e2, t2[2 * r2 + 1] = n2;
}
function Ho(t2, e2, n2) {
  var r2 = (n2 ? 2 : -2) * Math.PI * (t2 / e2);
  return { real: Math.cos(r2), imag: Math.sin(r2) };
}
function qo(t2, e2, n2) {
  var r2 = function(t3, e3, n3) {
    return function(t4, e4, n4) {
      var r3 = 0, o3 = t4.length, a2 = 0, i2 = false;
      for (; r3 < o3; ) {
        var s2 = n4(e4, t4[a2 = r3 + (o3 - r3 >>> 1)]);
        s2 > 0 ? r3 = a2 + 1 : (o3 = a2, i2 = !s2);
      }
      return i2 ? r3 : -r3 - 1;
    }(t3, e3, n3 || Ko);
  }(t2, e2, n2), o2 = r2 < 0 ? -(r2 + 1) : r2;
  t2.splice(o2, 0, e2);
}
function Ko(t2, e2) {
  return t2 > e2 ? 1 : t2 < e2 ? -1 : 0;
}
function jo(t2, e2, n2, r2, o2) {
  return Yo(t2, e2, n2, r2, o2, 0).selectedIndices;
}
function Xo(t2, e2, n2, r2, o2, a2) {
  var i2 = Yo(t2, e2, n2, r2, o2, a2, true);
  return i2.numValidOutputs.dispose(), { selectedIndices: i2.selectedIndices, selectedScores: i2.selectedScores };
}
function Yo(t2, e2, n2, r2, o2, a2, i2, s2) {
  void 0 === i2 && (i2 = false), void 0 === s2 && (s2 = false);
  for (var u3 = Array.from(e2).map(function(t3, e3) {
    return { score: t3, boxIndex: e3, suppressBeginIndex: 0 };
  }).filter(function(t3) {
    return t3.score > o2;
  }).sort(Jo), c2 = a2 > 0 ? -0.5 / a2 : 0, l2 = [], h2 = []; l2.length < n2 && u3.length > 0; ) {
    var f2 = u3.pop(), d2 = f2.score, p2 = f2.boxIndex, v = f2.suppressBeginIndex;
    if (d2 < o2) break;
    for (var m = false, g2 = l2.length - 1; g2 >= v; --g2) {
      var y2 = $o(t2, p2, l2[g2]);
      if (y2 >= r2) {
        m = true;
        break;
      }
      if (f2.score = f2.score * Qo(r2, c2, y2), f2.score <= o2) break;
    }
    f2.suppressBeginIndex = l2.length, m || (f2.score === d2 ? (l2.push(p2), h2.push(f2.score)) : f2.score > o2 && qo(u3, f2, Jo));
  }
  var x2 = l2.length;
  return s2 && (l2.fill(0, x2), h2.fill(0, x2)), { selectedIndices: Mn(l2, "int32"), selectedScores: Mn(h2, "float32"), numValidOutputs: On(x2, "int32") };
}
function $o(t2, e2, n2) {
  var r2 = t2.subarray(4 * e2, 4 * e2 + 4), o2 = t2.subarray(4 * n2, 4 * n2 + 4), a2 = Math.min(r2[0], r2[2]), i2 = Math.min(r2[1], r2[3]), s2 = Math.max(r2[0], r2[2]), u3 = Math.max(r2[1], r2[3]), c2 = Math.min(o2[0], o2[2]), l2 = Math.min(o2[1], o2[3]), h2 = Math.max(o2[0], o2[2]), f2 = Math.max(o2[1], o2[3]), d2 = (s2 - a2) * (u3 - i2), p2 = (h2 - c2) * (f2 - l2);
  if (d2 <= 0 || p2 <= 0) return 0;
  var v = Math.max(a2, c2), m = Math.max(i2, l2), g2 = Math.min(s2, h2), y2 = Math.min(u3, f2), x2 = Math.max(g2 - v, 0) * Math.max(y2 - m, 0);
  return x2 / (d2 + p2 - x2);
}
function Qo(t2, e2, n2) {
  var r2 = Math.exp(e2 * n2 * n2);
  return n2 <= t2 ? r2 : 0;
}
function Jo(t2, e2) {
  return t2.score - e2.score || t2.score === e2.score && e2.boxIndex - t2.boxIndex;
}
function Zo(t2, e2, n2) {
  var r2 = new Array(t2.rank).fill(0), o2 = t2.shape.slice();
  return e2.map(function(e3) {
    o2[n2] = e3;
    var a2 = t2.slice(r2, o2);
    return r2[n2] += e3, a2;
  });
}
function ta(t2, e2) {
  for (var n2 = new Array(t2.rank), r2 = 0; r2 < n2.length; r2++) n2[r2] = t2.shape[r2] * e2[r2];
  var o2 = dr(n2, t2.dtype);
  for (r2 = 0; r2 < o2.values.length; ++r2) {
    for (var a2 = o2.indexToLoc(r2), i2 = new Array(t2.rank), s2 = 0; s2 < i2.length; s2++) i2[s2] = a2[s2] % t2.shape[s2];
    var u3 = t2.locToIndex(i2);
    o2.values[r2] = t2.values[u3];
  }
  return o2.toTensor();
}
function ea(t2, e2, n2, r2, o2) {
  for (var a2 = e2[e2.length - 1], i2 = [t2.length / a2, a2], s2 = i2[0], u3 = i2[1], c2 = B(n2, s2 * r2), l2 = B("int32", s2 * r2), h2 = 0; h2 < s2; h2++) {
    for (var f2 = h2 * u3, d2 = t2.subarray(f2, f2 + u3), p2 = [], v = 0; v < d2.length; v++) p2.push({ value: d2[v], index: v });
    p2.sort(function(t3, e3) {
      return e3.value - t3.value;
    });
    var m = h2 * r2, g2 = c2.subarray(m, m + r2), y2 = l2.subarray(m, m + r2);
    for (v = 0; v < r2; v++) g2[v] = p2[v].value, y2[v] = p2[v].index;
  }
  var x2 = e2.slice();
  return x2[x2.length - 1] = r2, [Fn(c2, x2, n2), Fn(l2, x2, "int32")];
}
function na(t2, e2) {
  for (var n2 = [], r2 = 0; r2 < e2.length; r2++) e2[r2] && n2.push(r2);
  var o2 = dr(t2, "int32"), a2 = dr([n2.length, t2.length], "int32");
  for (r2 = 0; r2 < n2.length; r2++) {
    var i2 = o2.indexToLoc(n2[r2]), s2 = r2 * t2.length;
    a2.values.set(i2, s2);
  }
  return a2.toTensor();
}
function ia(t2, e2) {
  return ["x", "y", "z", "w", "u", "v"].slice(0, e2).map(function(e3) {
    return t2 + "." + e3;
  });
}
function sa(t2, e2) {
  return 1 === e2 ? [t2] : ia(t2, e2);
}
function ua() {
  var t2, e2, n2, r2, o2, a2, s2, u3, c2, l2;
  return 2 === i().getNumber("WEBGL_VERSION") ? (t2 = "#version 300 es", e2 = "in", n2 = "out", r2 = "in", o2 = "texture", a2 = "outputColor", s2 = "out vec4 outputColor;", u3 = "\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ", c2 = "", l2 = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (t2 = "", e2 = "attribute", n2 = "varying", r2 = "varying", o2 = "texture2D", a2 = "gl_FragColor", s2 = "", u3 = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", c2 = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", l2 = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), { version: t2, attribute: e2, varyingVs: n2, varyingFs: r2, texture2D: o2, output: a2, defineOutput: s2, defineSpecialNaN: u3, defineSpecialInf: c2, defineRound: l2 };
}
function ca(t2, e2, n2) {
  void 0 === n2 && (n2 = "index");
  var r2 = $(e2);
  return r2.map(function(e3, o2) {
    return "int " + t2[o2] + " = " + n2 + " / " + e3 + "; " + (o2 === r2.length - 1 ? "int " + t2[o2 + 1] + " = " + n2 + " - " + t2[o2] + " * " + e3 : "index -= " + t2[o2] + " * " + e3) + ";";
  }).join("");
}
function la(t2) {
  var e2 = $(t2).map(function(t3) {
    return t3.toString();
  });
  return "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * " + e2[0] + " + coords.y * " + e2[1] + " + coords.z;\n  }\n";
}
function fa(t2, e2, n2, r2) {
  var o2 = [];
  t2.forEach(function(t3) {
    var e3 = k(t3.shapeInfo.logicalShape);
    t3.shapeInfo.isUniform ? o2.push("uniform float " + t3.name + (e3 > 1 ? "[" + e3 + "]" : "") + ";") : (o2.push("uniform sampler2D " + t3.name + ";"), o2.push("uniform int offset" + t3.name + ";"));
  });
  var a2, i2, s2 = o2.join("\n"), u3 = t2.map(function(t3) {
    return function(t4, e3, n3) {
      void 0 === n3 && (n3 = false);
      var r3 = "";
      r3 += n3 ? pa(t4) : da(t4);
      var o3 = t4.shapeInfo.logicalShape, a3 = e3.logicalShape;
      o3.length <= a3.length && (r3 += n3 ? function(t5, e4) {
        var n4, r4 = t5.name, o4 = r4.charAt(0).toUpperCase() + r4.slice(1), a4 = "get" + o4 + "AtOutCoords", i3 = t5.shapeInfo.logicalShape.length, s3 = e4.logicalShape.length, u4 = Co(t5.shapeInfo.logicalShape, e4.logicalShape), c3 = wa(s3), l3 = s3 - i3, h3 = ["x", "y", "z", "w", "u", "v"];
        n4 = 0 === i3 ? "" : s3 < 2 && u4.length >= 1 ? "coords = 0;" : u4.map(function(t6) {
          return "coords." + h3[t6 + l3] + " = 0;";
        }).join("\n");
        var f3 = "";
        f3 = s3 < 2 && i3 > 0 ? "coords" : t5.shapeInfo.logicalShape.map(function(t6, e5) {
          return "coords." + h3[e5 + l3];
        }).join(", ");
        var d2 = "return outputValue;", p2 = 1 === k(t5.shapeInfo.logicalShape), v = 1 === k(e4.logicalShape);
        if (1 !== i3 || p2 || v) {
          if (p2 && !v) d2 = 1 === s3 ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";
          else if (u4.length) {
            var m = i3 - 2, g2 = i3 - 1;
            u4.indexOf(m) > -1 && u4.indexOf(g2) > -1 ? d2 = "return vec4(outputValue.x);" : u4.indexOf(m) > -1 ? d2 = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : u4.indexOf(g2) > -1 && (d2 = "return vec4(outputValue.xx, outputValue.zz);");
          }
        } else d2 = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";
        return "\n    vec4 " + a4 + "() {\n      " + c3 + " coords = getOutputCoords();\n      " + n4 + "\n      vec4 outputValue = get" + o4 + "(" + f3 + ");\n      " + d2 + "\n    }\n  ";
      }(t4, e3) : function(t5, e4) {
        var n4 = t5.name, r4 = n4.charAt(0).toUpperCase() + n4.slice(1), o4 = "get" + r4 + "AtOutCoords", a4 = e4.texShape, i3 = t5.shapeInfo.texShape, s3 = t5.shapeInfo.logicalShape.length, u4 = e4.logicalShape.length;
        if (!t5.shapeInfo.isUniform && s3 === u4 && null == t5.shapeInfo.flatOffset && S(i3, a4)) return "\n      float " + o4 + "() {\n        return sampleTexture(" + n4 + ", resultUV);\n      }\n    ";
        var c3, l3 = wa(u4), h3 = Co(t5.shapeInfo.logicalShape, e4.logicalShape), f3 = u4 - s3, d2 = ["x", "y", "z", "w", "u", "v"];
        c3 = 0 === s3 ? "" : u4 < 2 && h3.length >= 1 ? "coords = 0;" : h3.map(function(t6) {
          return "coords." + d2[t6 + f3] + " = 0;";
        }).join("\n");
        var p2 = "";
        p2 = u4 < 2 && s3 > 0 ? "coords" : t5.shapeInfo.logicalShape.map(function(t6, e5) {
          return "coords." + d2[e5 + f3];
        }).join(", ");
        return "\n    float " + o4 + "() {\n      " + l3 + " coords = getOutputCoords();\n      " + c3 + "\n      return get" + r4 + "(" + p2 + ");\n    }\n  ";
      }(t4, e3));
      return r3;
    }(t3, e2, r2);
  }).join("\n"), c2 = e2.texShape, l2 = ua(), h2 = function(t3) {
    return "\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return " + t3.texture2D + "(textureSampler, uv).r;\n    }\n  ";
  }(l2), f2 = function(t3) {
    return t3.version + "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    " + t3.varyingFs + " vec2 resultUV;\n    " + t3.defineOutput + "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    " + t3.defineSpecialNaN + "\n    " + t3.defineSpecialInf + "\n    " + t3.defineRound + "\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    " + va + "\n    " + ma + "\n    " + ga + "\n  ";
  }(l2);
  return e2.isPacked ? (a2 = function(t3, e3) {
    switch (t3.length) {
      case 0:
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
      case 1:
        return function(t4, e4) {
          var n4 = [Math.ceil(e4[0] / 2), Math.ceil(e4[1] / 2)];
          if (1 === n4[0]) return "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * " + n4[1] + ".0);\n      }\n    ";
          if (1 === n4[1]) return "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * " + n4[0] + ".0);\n      }\n    ";
          return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n4[0] + ", " + n4[1] + "));\n      return 2 * (resTexRC.x * " + n4[1] + " + resTexRC.y);\n    }\n  ";
        }(0, e3);
      case 2:
        return function(t4, e4) {
          var n4 = [Math.ceil(e4[0] / 2), Math.ceil(e4[1] / 2)];
          if (S(t4, e4)) return "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(" + n4[0] + ", " + n4[1] + "));\n      }\n    ";
          var r4 = Math.ceil(t4[1] / 2);
          return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n4[0] + ", " + n4[1] + "));\n\n      int index = resTexRC.x * " + n4[1] + " + resTexRC.y;\n      int r = 2 * (index / " + r4 + ");\n      int c = imod(index, " + r4 + ") * 2;\n\n      return ivec2(r, c);\n    }\n  ";
        }(t3, e3);
      case 3:
        return n3 = t3, r3 = e3, o3 = [Math.ceil(r3[0] / 2), Math.ceil(r3[1] / 2)], a3 = Math.ceil(n3[2] / 2), i3 = a3 * Math.ceil(n3[1] / 2), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + o3[0] + ", " + o3[1] + "));\n      int index = resTexRC.x * " + o3[1] + " + resTexRC.y;\n\n      int b = index / " + i3 + ";\n      index -= b * " + i3 + ";\n\n      int r = 2 * (index / " + a3 + ");\n      int c = imod(index, " + a3 + ") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
      default:
        return function(t4, e4) {
          for (var n4 = [Math.ceil(e4[0] / 2), Math.ceil(e4[1] / 2)], r4 = Math.ceil(t4[t4.length - 1] / 2), o4 = r4 * Math.ceil(t4[t4.length - 2] / 2), a4 = o4, i4 = "", s3 = "b, r, c", u4 = 2; u4 < t4.length - 1; u4++) a4 *= t4[t4.length - u4 - 1], i4 = "\n      int b" + u4 + " = index / " + a4 + ";\n      index -= b" + u4 + " * " + a4 + ";\n    " + i4, s3 = "b" + u4 + ", " + s3;
          return "\n    ivec" + t4.length + " getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n4[0] + ", " + n4[1] + "));\n      int index = resTexRC.x * " + n4[1] + " + resTexRC.y;\n\n      " + i4 + "\n\n      int b = index / " + o4 + ";\n      index -= b * " + o4 + ";\n\n      int r = 2 * (index / " + r4 + ");\n      int c = imod(index, " + r4 + ") * 2;\n\n      return ivec" + t4.length + "(" + s3 + ");\n    }\n  ";
        }(t3, e3);
    }
    var n3, r3, o3, a3, i3;
  }(e2.logicalShape, c2), i2 = function(t3) {
    return "\n    void setOutput(vec4 val) {\n      " + t3.output + " = val;\n    }\n  ";
  }(l2)) : (a2 = function(t3, e3) {
    switch (t3.length) {
      case 0:
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
      case 1:
        return function(t4, e4) {
          if (1 === e4[0]) return "\n      int getOutputCoords() {\n        return int(resultUV.x * " + e4[1] + ".0);\n      }\n    ";
          if (1 === e4[1]) return "\n      int getOutputCoords() {\n        return int(resultUV.y * " + e4[0] + ".0);\n      }\n    ";
          return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e4[0] + ", " + e4[1] + "));\n      return resTexRC.x * " + e4[1] + " + resTexRC.y;\n    }\n  ";
        }(0, e3);
      case 2:
        return function(t4, e4) {
          if (S(t4, e4)) return "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + e4[0] + ", " + e4[1] + "));\n      }\n    ";
          if (1 === t4[1]) return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e4[0] + ", " + e4[1] + "));\n        int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";
          if (1 === t4[0]) return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e4[0] + ", " + e4[1] + "));\n        int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";
          return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e4[0] + ", " + e4[1] + "));\n      int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n      int r = index / " + t4[1] + ";\n      int c = index - r * " + t4[1] + ";\n      return ivec2(r, c);\n    }\n  ";
        }(t3, e3);
      case 3:
        return n3 = e3, r3 = ca(["r", "c", "d"], t3), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n3[0] + ", " + n3[1] + "));\n      int index = resTexRC.x * " + n3[1] + " + resTexRC.y;\n      " + r3 + "\n      return ivec3(r, c, d);\n    }\n  ";
      case 4:
        return function(t4, e4) {
          var n4 = ca(["r", "c", "d", "d2"], t4);
          return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e4[0] + ", " + e4[1] + "));\n      int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n      " + n4 + "\n      return ivec4(r, c, d, d2);\n    }\n  ";
        }(t3, e3);
      case 5:
        return function(t4, e4) {
          var n4 = ca(["r", "c", "d", "d2", "d3"], t4);
          return "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(" + e4[0] + ",\n                             " + e4[1] + "));\n\n      int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n\n      " + n4 + "\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ";
        }(t3, e3);
      case 6:
        return function(t4, e4) {
          var n4 = ca(["r", "c", "d", "d2", "d3", "d4"], t4);
          return "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e4[0] + ", " + e4[1] + "));\n      int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n\n      " + n4 + "\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ";
        }(t3, e3);
      default:
        throw new Error(t3.length + "-D output sampling is not yet supported");
    }
    var n3, r3;
  }(e2.logicalShape, c2), i2 = function(t3) {
    return "\n    void setOutput(float val) {\n      " + t3.output + " = vec4(val, 0, 0, 0);\n    }\n  ";
  }(l2)), r2 && (f2 += ya), [f2, h2, i2, s2, a2, u3, n2].join("\n");
}
function da(t2) {
  var e2 = t2.shapeInfo.logicalShape;
  switch (e2.length) {
    case 0:
      return function(t3) {
        var e3 = t3.name, n2 = "get" + e3.charAt(0).toUpperCase() + e3.slice(1);
        if (t3.shapeInfo.isUniform) return "float " + n2 + "() {return " + e3 + ";}";
        var r2 = t3.shapeInfo.texShape, o2 = r2[0], a2 = r2[1];
        if (1 === o2 && 1 === a2) return "\n      float " + n2 + "() {\n        return sampleTexture(" + e3 + ", halfCR);\n      }\n    ";
        var i2 = t3.shapeInfo.texShape, s2 = i2[0], u3 = i2[1], c2 = xa(e3);
        return "\n    float " + n2 + "() {\n      vec2 uv = uvFromFlat(" + s2 + ", " + u3 + ", " + c2 + ");\n      return sampleTexture(" + e3 + ", uv);\n    }\n  ";
      }(t2);
    case 1:
      return function(t3) {
        var e3 = t3.name, n2 = "get" + e3.charAt(0).toUpperCase() + e3.slice(1);
        if (t3.shapeInfo.isUniform) return "\n      float " + n2 + "(int index) {\n        " + ba(t3) + "\n      }\n    ";
        var r2 = t3.shapeInfo.texShape, o2 = r2[0], a2 = r2[1];
        if (1 === a2 && 1 === o2) return "\n      float " + n2 + "(int index) {\n        return sampleTexture(" + e3 + ", halfCR);\n      }\n    ";
        var i2 = xa(e3);
        if (1 === a2) return "\n      float " + n2 + "(int index) {\n        vec2 uv = vec2(0.5, (float(index + " + i2 + ") + 0.5) / " + o2 + ".0);\n        return sampleTexture(" + e3 + ", uv);\n      }\n    ";
        if (1 === o2) return "\n      float " + n2 + "(int index) {\n        vec2 uv = vec2((float(index + " + i2 + ") + 0.5) / " + a2 + ".0, 0.5);\n        return sampleTexture(" + e3 + ", uv);\n      }\n    ";
        return "\n    float " + n2 + "(int index) {\n      vec2 uv = uvFromFlat(" + o2 + ", " + a2 + ", index + " + i2 + ");\n      return sampleTexture(" + e3 + ", uv);\n    }\n  ";
      }(t2);
    case 2:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n2 = t3.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), o2 = t3.shapeInfo.texShape;
        if (null != o2 && S(e3, o2)) {
          var a2 = o2[0], i2 = o2[1];
          return "\n    float " + r2 + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + i2 + ".0, " + a2 + ".0);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
        }
        var s2 = M(e3), u3 = s2.newShape, c2 = s2.keptDims, l2 = u3;
        if (l2.length < e3.length) {
          var h2 = Ca(t3, l2);
          return "\n      " + da(h2) + "\n      float " + r2 + "(int row, int col) {\n        return " + r2 + "(" + Ea(["row", "col"], c2) + ");\n      }\n    ";
        }
        if (t3.shapeInfo.isUniform) return "\n      float " + r2 + "(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(" + e3[1] + ", 1)));\n        " + ba(t3) + "\n      }\n    ";
        var f2 = o2[0], d2 = o2[1], p2 = xa(n2);
        if (1 === d2) return "\n    float " + r2 + "(int row, int col) {\n      float index = dot(vec3(row, col, " + p2 + "), vec3(" + e3[1] + ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / " + f2 + ".0);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
        if (1 === f2) return "\n    float " + r2 + "(int row, int col) {\n      float index = dot(vec3(row, col, " + p2 + "), vec3(" + e3[1] + ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / " + d2 + ".0, 0.5);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
        return "\n  float " + r2 + "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * " + e3[1] + " + col + " + p2 + ";\n    vec2 uv = uvFromFlat(" + f2 + ", " + d2 + ", index);\n    return sampleTexture(" + n2 + ", uv);\n  }\n";
      }(t2);
    case 3:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n2 = t3.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), o2 = e3[1] * e3[2], a2 = e3[2], i2 = M(e3), s2 = i2.newShape, u3 = i2.keptDims, c2 = s2;
        if (c2.length < e3.length) {
          var l2 = Ca(t3, c2);
          return "\n        " + da(l2) + "\n        float " + r2 + "(int row, int col, int depth) {\n          return " + r2 + "(" + Ea(["row", "col", "depth"], u3) + ");\n        }\n      ";
        }
        if (t3.shapeInfo.isUniform) return "\n      float " + r2 + "(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(" + o2 + ", " + a2 + ", 1)));\n        " + ba(t3) + "\n      }\n    ";
        var h2 = t3.shapeInfo.texShape, f2 = h2[0], d2 = h2[1], p2 = t3.shapeInfo.flatOffset;
        if (d2 === o2 && null == p2) return "\n        float " + r2 + "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(" + a2 + ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + d2 + ".0, " + f2 + ".0);\n          return sampleTexture(" + n2 + ", uv);\n        }\n      ";
        if (d2 === a2 && null == p2) return "\n    float " + r2 + "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(" + e3[1] + ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + d2 + ".0, " + f2 + ".0);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
        var v = xa(n2);
        return "\n      float " + r2 + "(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * " + o2 + " + col * " + a2 + " + depth + " + v + ";\n        vec2 uv = uvFromFlat(" + f2 + ", " + d2 + ", index);\n        return sampleTexture(" + n2 + ", uv);\n      }\n  ";
      }(t2);
    case 4:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n2 = t3.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), o2 = e3[3], a2 = e3[2] * o2, i2 = e3[1] * a2, s2 = M(e3), u3 = s2.newShape, c2 = s2.keptDims;
        if (u3.length < e3.length) {
          var l2 = Ca(t3, u3);
          return "\n      " + da(l2) + "\n      float " + r2 + "(int row, int col, int depth, int depth2) {\n        return " + r2 + "(" + Ea(["row", "col", "depth", "depth2"], c2) + ");\n      }\n    ";
        }
        if (t3.shapeInfo.isUniform) return "\n      float " + r2 + "(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(" + i2 + ", " + a2 + ", " + o2 + ", 1)));\n        " + ba(t3) + "\n      }\n    ";
        var h2 = t3.shapeInfo.flatOffset, f2 = t3.shapeInfo.texShape, d2 = f2[0], p2 = f2[1];
        if (p2 === i2 && null == h2) return "\n      float " + r2 + "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(" + a2 + ", " + o2 + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + p2 + ".0, " + d2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
        if (p2 === o2 && null == h2) return "\n      float " + r2 + "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(" + e3[1] * e3[2] + ", " + e3[2] + ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + p2 + ".0, " + d2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
        var v = xa(n2);
        return "\n    float " + r2 + "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + i2 + " + col * " + a2 + " +\n          depth * " + o2 + " + depth2;\n      vec2 uv = uvFromFlat(" + d2 + ", " + p2 + ", index + " + v + ");\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
      }(t2);
    case 5:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n2 = t3.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), o2 = e3[4], a2 = e3[3] * o2, i2 = e3[2] * a2, s2 = e3[1] * i2, u3 = M(e3), c2 = u3.newShape, l2 = u3.keptDims;
        if (c2.length < e3.length) {
          var h2 = Ca(t3, c2);
          return "\n      " + da(h2) + "\n      float " + r2 + "(int row, int col, int depth, int depth2, int depth3) {\n        return " + r2 + "(" + Ea(["row", "col", "depth", "depth2", "depth3"], l2) + ");\n      }\n    ";
        }
        if (t3.shapeInfo.isUniform) return "\n      float " + r2 + "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + s2 + ", " + i2 + ", " + a2 + ", " + o2 + ")) +\n          depth3;\n        " + ba(t3) + "\n      }\n    ";
        var f2 = t3.shapeInfo.flatOffset, d2 = t3.shapeInfo.texShape, p2 = d2[0], v = d2[1];
        if (v === s2 && null == f2) return "\n      float " + r2 + "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(" + i2 + ", " + a2 + ", " + o2 + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + v + ".0, " + p2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
        if (v === o2 && null == f2) return "\n      float " + r2 + "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + e3[1] * e3[2] * e3[3] + ",\n               " + e3[2] * e3[3] + ", " + e3[3] + ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + v + ".0, " + p2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
        var m = xa(n2);
        return "\n    float " + r2 + "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + s2 + " + col * " + i2 + " + depth * " + a2 + " +\n          depth2 * " + o2 + " + depth3 + " + m + ";\n      vec2 uv = uvFromFlat(" + p2 + ", " + v + ", index);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
      }(t2);
    case 6:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n2 = t3.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), o2 = M(e3), a2 = o2.newShape, i2 = o2.keptDims;
        if (a2.length < e3.length) {
          var s2 = Ca(t3, a2);
          return "\n      " + da(s2) + "\n      float " + r2 + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return " + r2 + "(" + Ea(["row", "col", "depth", "depth2", "depth3", "depth4"], i2) + ");\n      }\n    ";
        }
        var u3 = e3[5], c2 = e3[4] * u3, l2 = e3[3] * c2, h2 = e3[2] * l2, f2 = e3[1] * h2;
        if (t3.shapeInfo.isUniform) return "\n      float " + r2 + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + f2 + ", " + h2 + ", " + l2 + ", " + c2 + ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(" + u3 + ", 1)));\n        " + ba(t3) + "\n      }\n    ";
        var d2 = t3.shapeInfo.flatOffset, p2 = t3.shapeInfo.texShape, v = p2[0], m = p2[1];
        if (m === f2 && null == d2) return "\n      float " + r2 + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(" + h2 + ", " + l2 + ", " + c2 + ", " + u3 + ")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + m + ".0, " + v + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
        if (m === u3 && null == d2) return "\n      float " + r2 + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(" + e3[1] * e3[2] * e3[3] * e3[4] + ",\n               " + e3[2] * e3[3] * e3[4] + ",\n               " + e3[3] * e3[4] + ",\n               " + e3[4] + ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + m + ".0, " + v + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
        var g2 = xa(n2);
        return "\n    float " + r2 + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + f2 + " + col * " + h2 + " + depth * " + l2 + " +\n          depth2 * " + c2 + " + depth3 * " + u3 + " + depth4 + " + g2 + ";\n      vec2 uv = uvFromFlat(" + v + ", " + m + ", index);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
      }(t2);
    default:
      throw new Error(e2.length + "-D input sampling is not yet supported");
  }
}
function pa(t2) {
  var e2, n2, r2;
  switch (t2.shapeInfo.logicalShape.length) {
    case 0:
      return e2 = t2.name, n2 = "get" + e2.charAt(0).toUpperCase() + e2.slice(1), r2 = ua(), "\n    vec4 " + n2 + "() {\n      return " + r2.texture2D + "(" + e2 + ", halfCR);\n    }\n  ";
    case 1:
      return function(t3) {
        var e3 = t3.name, n3 = "get" + e3.charAt(0).toUpperCase() + e3.slice(1), r3 = t3.shapeInfo.texShape, o2 = [Math.ceil(r3[0] / 2), Math.ceil(r3[1] / 2)], a2 = ua();
        return "\n    vec4 " + n3 + "(int index) {\n      vec2 uv = packedUVfrom1D(\n        " + o2[0] + ", " + o2[1] + ", index);\n      return " + a2.texture2D + "(" + e3 + ", uv);\n    }\n  ";
      }(t2);
    case 2:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n3 = t3.name, r3 = "get" + n3.charAt(0).toUpperCase() + n3.slice(1), o2 = t3.shapeInfo.texShape, a2 = o2[0], i2 = o2[1], s2 = ua();
        if (null != o2 && S(e3, o2)) return "\n      vec4 " + r3 + "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" + i2 + ".0, " + a2 + ".0);\n\n        return " + s2.texture2D + "(" + n3 + ", uv);\n      }\n    ";
        var u3 = [Math.ceil(o2[0] / 2), Math.ceil(o2[1] / 2)], c2 = Math.ceil(e3[1] / 2);
        return "\n    vec4 " + r3 + "(int row, int col) {\n      vec2 uv = packedUVfrom2D(" + c2 + ", " + u3[0] + ", " + u3[1] + ", row, col);\n      return " + s2.texture2D + "(" + n3 + ", uv);\n    }\n  ";
      }(t2);
    case 3:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n3 = t3.name, r3 = "get" + n3.charAt(0).toUpperCase() + n3.slice(1), o2 = t3.shapeInfo.texShape, a2 = [Math.ceil(o2[0] / 2), Math.ceil(o2[1] / 2)];
        if (1 === e3[0]) {
          var i2 = e3.slice(1), s2 = Ca(t3, i2);
          return "\n        " + pa(s2) + "\n        vec4 " + r3 + "(int b, int row, int col) {\n          return " + r3 + "(" + Ea(["b", "row", "col"], [1, 2]) + ");\n        }\n      ";
        }
        var u3 = a2[0], c2 = a2[1], l2 = Math.ceil(e3[2] / 2), h2 = l2 * Math.ceil(e3[1] / 2), f2 = ua();
        return "\n    vec4 " + r3 + "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        " + u3 + ", " + c2 + ", " + h2 + ", " + l2 + ", b, row, col);\n      return " + f2.texture2D + "(" + n3 + ", uv);\n    }\n  ";
      }(t2);
    default:
      return function(t3) {
        for (var e3 = t3.shapeInfo.logicalShape, n3 = e3.length, r3 = t3.name, o2 = "get" + r3.charAt(0).toUpperCase() + r3.slice(1), a2 = t3.shapeInfo.texShape, i2 = [Math.ceil(a2[0] / 2), Math.ceil(a2[1] / 2)], s2 = i2[0], u3 = i2[1], c2 = Math.ceil(e3[n3 - 1] / 2), l2 = c2 * Math.ceil(e3[n3 - 2] / 2), h2 = "int b, int row, int col", f2 = "b * " + l2 + " + (row / 2) * " + c2 + " + (col / 2)", d2 = 2; d2 < n3 - 1; d2++) h2 = "int b" + d2 + ", " + h2, l2 *= e3[n3 - d2 - 1], f2 = "b" + d2 + " * " + l2 + " + " + f2;
        var p2 = ua();
        return "\n    vec4 " + o2 + "(" + h2 + ") {\n      int index = " + f2 + ";\n      int texR = index / " + u3 + ";\n      int texC = index - texR * " + u3 + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + u3 + ", " + s2 + ");\n      return " + p2.texture2D + "(" + r3 + ", uv);\n    }\n  ";
      }(t2);
  }
}
function xa(t2) {
  return "offset" + t2;
}
function ba(t2) {
  var e2 = t2.name, n2 = k(t2.shapeInfo.logicalShape);
  return n2 < 2 ? "return " + e2 + ";" : "\n    for (int i = 0; i < " + n2 + "; i++) {\n      if (i == index) {\n        return " + e2 + "[i];\n      }\n    }\n  ";
}
function wa(t2) {
  if (t2 <= 1) return "int";
  if (2 === t2) return "ivec2";
  if (3 === t2) return "ivec3";
  if (4 === t2) return "ivec4";
  if (5 === t2) return "ivec5";
  if (6 === t2) return "ivec6";
  throw Error("GPU for rank " + t2 + " is not yet supported");
}
function Ca(t2, e2) {
  var n2 = JSON.parse(JSON.stringify(t2));
  return n2.shapeInfo.logicalShape = e2, n2;
}
function Ea(t2, e2) {
  return e2.map(function(e3) {
    return t2[e3];
  }).join(", ");
}
function Ha(t2, e2, n2) {
  var r2 = t2.indexOf(e2);
  return t2.map(function(t3, e3) {
    return e3 === r2 ? t3 + " - " + n2 : t3;
  }).join();
}
function ri(t2, e2) {
  if (1 === t2) return "" + e2;
  if (2 === t2) return e2 + ".y";
  if (3 === t2) return e2 + ".z";
  if (4 === t2) return e2 + ".w";
  throw Error("Cumulative sum for rank " + t2 + " is not yet supported");
}
function yi(t2, e2) {
  var n2 = ua();
  return oe(t2, e2, n2.version + "\n    precision highp float;\n    " + n2.attribute + " vec3 clipSpacePos;\n    " + n2.attribute + " vec2 uv;\n    " + n2.varyingVs + " vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }");
}
function xi(t2, e2) {
  return fe(t2, e2, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]));
}
function bi(t2, e2) {
  return de(t2, e2, new Uint16Array([0, 1, 2, 2, 1, 3]));
}
function wi(t2, e2, n2, r2, o2, a2, i2) {
  ve(n2, r2);
  var s2 = pe(t2, e2), u3 = t2.TEXTURE_2D;
  return Jt(t2, e2, function() {
    return t2.bindTexture(u3, s2);
  }), Jt(t2, e2, function() {
    return t2.texParameteri(u3, t2.TEXTURE_WRAP_S, t2.CLAMP_TO_EDGE);
  }), Jt(t2, e2, function() {
    return t2.texParameteri(u3, t2.TEXTURE_WRAP_T, t2.CLAMP_TO_EDGE);
  }), Jt(t2, e2, function() {
    return t2.texParameteri(u3, t2.TEXTURE_MIN_FILTER, t2.NEAREST);
  }), Jt(t2, e2, function() {
    return t2.texParameteri(u3, t2.TEXTURE_MAG_FILTER, t2.NEAREST);
  }), Jt(t2, e2, function() {
    return t2.texImage2D(u3, 0, o2, n2, r2, 0, a2, i2, null);
  }), Jt(t2, e2, function() {
    return t2.bindTexture(t2.TEXTURE_2D, null);
  }), s2;
}
function Ci(t2, e2, n2, r2, o2) {
  var a2 = Xt(n2, r2);
  return wi(t2, e2, a2[0], a2[1], o2.internalFormatFloat, o2.textureFormatFloat, t2.FLOAT);
}
function Ei(t2, e2, n2, r2, o2) {
  var a2 = Xt(n2, r2);
  return wi(t2, e2, a2[0], a2[1], o2.internalFormatHalfFloat, o2.textureFormatFloat, o2.textureTypeHalfFloat);
}
function Ri(t2, e2, n2, r2, o2) {
  var a2 = Xt(n2, r2);
  return wi(t2, e2, a2[0], a2[1], t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE);
}
function Ii(t2, e2, n2, r2, o2) {
  var a2 = $t(n2, r2);
  return wi(t2, e2, a2[0], a2[1], o2.internalFormatPackedFloat, t2.RGBA, t2.FLOAT);
}
function ki(t2, e2, n2, r2, o2) {
  var a2 = $t(n2, r2);
  return wi(t2, e2, a2[0], a2[1], o2.internalFormatPackedHalfFloat, t2.RGBA, o2.textureTypeHalfFloat);
}
function Si(t2, e2, n2, r2) {
  return Jt(t2, e2, function() {
    return t2.bindBuffer(t2.ARRAY_BUFFER, r2);
  }), ge(t2, e2, n2, "clipSpacePos", r2, 3, 20, 0) && ge(t2, e2, n2, "uv", r2, 2, 20, 12);
}
function Ai(t2, e2, n2, r2, o2, a2, i2) {
  var s2, u3, c2;
  Jt(t2, e2, function() {
    return t2.bindTexture(t2.TEXTURE_2D, n2);
  }), a2 instanceof Uint8Array ? (s2 = new Uint8Array(r2 * o2 * 4), u3 = t2.UNSIGNED_BYTE, c2 = t2.RGBA) : (s2 = new Float32Array(r2 * o2 * 4), u3 = t2.FLOAT, c2 = i2.internalFormatPackedFloat), s2.set(a2), Jt(t2, e2, function() {
    return t2.texImage2D(t2.TEXTURE_2D, 0, c2, r2, o2, 0, t2.RGBA, u3, s2);
  }), Jt(t2, e2, function() {
    return t2.bindTexture(t2.TEXTURE_2D, null);
  });
}
function Di(t2, e2, n2, r2) {
  Jt(t2, e2, function() {
    return t2.bindTexture(t2.TEXTURE_2D, n2);
  }), r2.data instanceof Uint8Array ? Jt(t2, e2, function() {
    return t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, r2.width, r2.height, 0, t2.RGBA, t2.UNSIGNED_BYTE, r2.data);
  }) : Jt(t2, e2, function() {
    return t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, r2);
  }), Jt(t2, e2, function() {
    return t2.bindTexture(t2.TEXTURE_2D, null);
  });
}
function Ti(t2, e2, n2, r2, o2) {
  var a2 = t2.createBuffer();
  Jt(t2, e2, function() {
    return t2.bindBuffer(t2.PIXEL_PACK_BUFFER, a2);
  });
  var i2 = 16 * n2 * r2;
  return Jt(t2, e2, function() {
    return t2.bufferData(t2.PIXEL_PACK_BUFFER, i2, t2.STREAM_READ);
  }), Jt(t2, e2, function() {
    return t2.readPixels(0, 0, r2, n2, t2.RGBA, t2.FLOAT, 0);
  }), Jt(t2, e2, function() {
    return t2.bindBuffer(t2.PIXEL_PACK_BUFFER, null);
  }), a2;
}
function Ni(t2, e2, n2) {
  var r2 = t2, o2 = new Float32Array(n2);
  return r2.bindBuffer(r2.PIXEL_PACK_BUFFER, e2), r2.getBufferSubData(r2.PIXEL_PACK_BUFFER, 0, o2), r2.bindBuffer(r2.PIXEL_PACK_BUFFER, null), o2;
}
function Fi(t2, e2, n2, r2, o2) {
  var a2 = Xt(n2, r2), i2 = a2[0], s2 = a2[1], u3 = new Uint8Array(n2 * r2 * 4);
  return Jt(t2, e2, function() {
    return t2.readPixels(0, 0, i2, s2, o2.downloadTextureFormat, t2.UNSIGNED_BYTE, u3);
  }), new Float32Array(u3.buffer);
}
function _i(t2, e2, n2, r2, o2, a2, i2, s2) {
  var u3 = t2, c2 = new Float32Array(function(t3, e3) {
    var n3 = $t(t3, e3);
    return n3[0] * n3[1] * 4;
  }(a2, i2));
  return u3.bindBuffer(u3.PIXEL_PACK_BUFFER, e2), u3.getBufferSubData(u3.PIXEL_PACK_BUFFER, 0, c2), u3.bindBuffer(u3.PIXEL_PACK_BUFFER, null), c2;
}
function Oi(t2, e2, n2, r2) {
  var o2 = new Float32Array(n2 * r2 * 4);
  return Jt(t2, e2, function() {
    return t2.readPixels(0, 0, r2, n2, t2.RGBA, t2.FLOAT, o2);
  }), o2;
}
function Pi(t2, e2) {
  if (t2.length !== e2.length) throw Error("Binary was compiled with " + t2.length + " inputs, but was executed with " + e2.length + " inputs");
  t2.forEach(function(t3, n2) {
    var r2 = t3.logicalShape, o2 = e2[n2], a2 = o2.shape;
    if (!S(r2, a2)) throw Error("Binary was compiled with different shapes than the current args. Shapes " + r2 + " and " + a2 + " must match");
    if (!t3.isUniform || !o2.isUniform) {
      var i2 = t3.texShape, s2 = o2.isUniform ? null : o2.texData.texShape;
      if (!S(i2, s2)) throw Error("Binary was compiled with different texture shapes than the current args. Shape " + i2 + " and " + s2 + " must match");
    }
  });
}
function vs(t2, e2) {
  if (t2 === zt.UPLOAD) return Gt.PACKED_2X2_FLOAT32;
  if (t2 === zt.RENDER || null == t2) return function(t3) {
    return i().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? t3 ? Gt.PACKED_2X2_FLOAT32 : Gt.UNPACKED_FLOAT32 : t3 ? Gt.PACKED_2X2_FLOAT16 : Gt.UNPACKED_FLOAT16;
  }(e2);
  if (t2 === zt.DOWNLOAD || t2 === zt.PIXELS) return Gt.PACKED_4X1_UNSIGNED_BYTE;
  throw new Error("Unknown logical texture type " + t2);
}
function ms(t2, e2, n2) {
  return t2[0] + "_" + t2[1] + "_" + e2 + "_" + n2;
}
function Qs(t2, e2) {
  if (void 0 === e2 && (e2 = false), "linear" === t2) return e2 ? Hs : Rs;
  if ("relu" === t2) return e2 ? qs : ks;
  if ("elu" === t2) return e2 ? js : As;
  if ("relu6" === t2) return e2 ? Ks : Ss;
  if ("prelu" === t2) return e2 ? Pa : Ma;
  throw new Error("Activation " + t2 + " has not been implemented for the WebGL backend.");
}
function Pu(t2, e2, n2, r2, o2, a2) {
  var i2, s2, u3 = mn(t2, "x", "batchNorm"), c2 = mn(e2, "mean", "batchNorm"), l2 = mn(n2, "variance", "batchNorm");
  return null != o2 && (i2 = mn(o2, "scale", "batchNorm")), null != r2 && (s2 = mn(r2, "offset", "batchNorm")), C(2 === u3.rank, function() {
    return "Error in batchNorm3D: x must be rank 3 but got rank " + u3.rank + ".";
  }), C(2 === c2.rank || 1 === c2.rank, function() {
    return "Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank " + c2.rank + ".";
  }), C(2 === l2.rank || 1 === l2.rank, function() {
    return "Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank " + l2.rank + ".";
  }), null != i2 && C(2 === i2.rank || 1 === i2.rank, function() {
    return "Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank " + i2.rank + ".";
  }), null != s2 && C(2 === s2.rank || 1 === s2.rank, function() {
    return "Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank " + s2.rank + ".";
  }), Uu(u3, c2, l2, s2, i2, a2);
}
function Lu(t2, e2, n2, r2, o2, a2) {
  var i2, s2, u3 = mn(t2, "x", "batchNorm"), c2 = mn(e2, "mean", "batchNorm"), l2 = mn(n2, "variance", "batchNorm");
  return null != o2 && (i2 = mn(o2, "scale", "batchNorm")), null != r2 && (s2 = mn(r2, "offset", "batchNorm")), C(3 === u3.rank, function() {
    return "Error in batchNorm3D: x must be rank 3 but got rank " + u3.rank + ".";
  }), C(3 === c2.rank || 1 === c2.rank, function() {
    return "Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank " + c2.rank + ".";
  }), C(3 === l2.rank || 1 === l2.rank, function() {
    return "Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank " + l2.rank + ".";
  }), null != i2 && C(3 === i2.rank || 1 === i2.rank, function() {
    return "Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank " + i2.rank + ".";
  }), null != s2 && C(3 === s2.rank || 1 === s2.rank, function() {
    return "Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank " + s2.rank + ".";
  }), Uu(u3, c2, l2, s2, i2, a2);
}
function Wu(t2, e2, n2, r2, o2, a2) {
  var i2, s2, u3 = mn(t2, "x", "batchNorm"), c2 = mn(e2, "mean", "batchNorm"), l2 = mn(n2, "variance", "batchNorm");
  return null != o2 && (i2 = mn(o2, "scale", "batchNorm")), null != r2 && (s2 = mn(r2, "offset", "batchNorm")), C(4 === u3.rank, function() {
    return "Error in batchNorm4D: x must be rank 4 but got rank " + u3.rank + ".";
  }), C(4 === c2.rank || 1 === c2.rank, function() {
    return "Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank " + c2.rank + ".";
  }), C(4 === l2.rank || 1 === l2.rank, function() {
    return "Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank " + l2.rank + ".";
  }), null != i2 && C(4 === i2.rank || 1 === i2.rank, function() {
    return "Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank " + i2.rank + ".";
  }), null != s2 && C(4 === s2.rank || 1 === s2.rank, function() {
    return "Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank " + s2.rank + ".";
  }), Uu(u3, c2, l2, s2, i2, a2);
}
function Uu(t2, e2, n2, r2, o2, a2) {
  null == a2 && (a2 = 1e-3);
  var i2, s2, u3, c2 = mn(t2, "x", "batchNorm"), l2 = mn(e2, "mean", "batchNorm"), h2 = mn(n2, "variance", "batchNorm");
  null != o2 && (i2 = mn(o2, "scale", "batchNorm")), null != r2 && (s2 = mn(r2, "offset", "batchNorm")), C(l2.rank === h2.rank, function() {
    return "Batch normalization gradient requires mean and variance to have equal ranks.";
  }), C(null == s2 || l2.rank === s2.rank, function() {
    return "Batch normalization gradient requires mean and offset to have equal ranks.";
  }), C(null == i2 || l2.rank === i2.rank, function() {
    return "Batch normalization gradient requires mean and scale to have equal ranks.";
  }), u3 = 0 === c2.rank || 1 === c2.rank ? c2.as4D(1, 1, 1, c2.size) : 2 === c2.rank ? c2.as4D(1, 1, c2.shape[0], c2.shape[1]) : 3 === c2.rank ? c2.as4D(1, c2.shape[0], c2.shape[1], c2.shape[2]) : c2;
  var f2 = [c2, l2, h2, i2];
  return Lt.runKernelFunc(function(t3, e3) {
    var n3 = t3.batchNormalization(u3, Vu(l2), Vu(h2), a2, Vu(i2), Vu(s2));
    return e3([c2, l2, h2, i2]), n3;
  }, { x: c2, mean: l2, variance: h2, scale: i2, offset: s2 }, function(t3, e3) {
    var n3 = e3, r3 = n3[0], o3 = n3[1], i3 = n3[2], s3 = n3[3], c3 = null == s3 ? On(1) : s3, l3 = Eo(o3.shape, u3.shape), h3 = [];
    if (1 === o3.rank) {
      for (var f3 = 0; f3 < u3.shape.length - 1; ++f3) h3.push(u3.shape[f3]);
      h3.push(1);
    }
    var d2 = r3.sub(o3), p2 = t3.mul(c3), v = Ru(i3.add(On(a2))), m = v.mul(v).mul(v).mul(On(-0.5));
    return { x: function() {
      return 1 === o3.rank ? t3.mul(Lr(v.as4D(1, 1, 1, o3.shape[0]), h3)).mul(c3).reshape(r3.shape) : t3.mul(v).mul(c3).reshape(r3.shape);
    }, mean: function() {
      var t4 = v.mul(On(-1)).mul(p2);
      return 1 === o3.rank && (t4 = t4.sum(l3)), t4.reshape(o3.shape);
    }, variance: function() {
      var t4 = m.mul(d2).mul(p2);
      return 1 === o3.rank && (t4 = t4.sum(l3)), t4.reshape(o3.shape);
    }, scale: function() {
      var e4 = d2.mul(v), n4 = t3.mul(e4);
      return 1 === o3.rank && (n4 = n4.sum(l3)), n4.reshape(o3.shape);
    }, offset: function() {
      var e4 = t3;
      return 1 === o3.rank && (e4 = e4.sum(l3)), e4.reshape(o3.shape);
    } };
  }, "BatchNormalization", { varianceEpsilon: a2 }, f2).reshape(c2.shape);
}
function Vu(t2) {
  return null == t2 ? null : 0 === t2.rank ? t2.as1D() : 1 === t2.rank ? t2 : 2 === t2.rank ? t2.as4D(1, 1, t2.shape[0], t2.shape[1]) : 3 === t2.rank ? t2.as4D(1, t2.shape[0], t2.shape[1], t2.shape[2]) : t2;
}
function zu() {
  Xe("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon");
}
function Bc(t2, e2) {
  for (var n2 = [], r2 = t2; r2 < e2; ++r2) n2.push(r2);
  return n2;
}
function Pc(t2) {
  for (var e2 = [], n2 = 0; n2 < t2.length; ++n2) for (var r2 = 0; r2 < t2[n2].length; ++r2) e2.push(t2[n2][r2]);
  return e2;
}
function Vc(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === a2 && (a2 = "NHWC"), C(t2.length === e2.rank, function() {
    return "Length of inShape (" + t2.length + ") and rank of dy (" + e2.rank + ") must match";
  });
  var s2 = t2, u3 = e2, c2 = false;
  3 === e2.rank && (c2 = true, u3 = e2.as4D(1, e2.shape[0], e2.shape[1], e2.shape[2]), s2 = [1, t2[0], t2[1], t2[2]]), C(4 === s2.length, function() {
    return "Error in conv2dDerInput: inShape must be length 4, but got length " + s2.length + ".";
  }), C(4 === u3.rank, function() {
    return "Error in conv2dDerInput: dy must be rank 4, but got rank " + u3.rank;
  }), C(4 === n2.rank, function() {
    return "Error in conv2dDerInput: filter must be rank 4, but got rank " + n2.rank;
  });
  var l2 = "NHWC" === a2 ? s2[3] : s2[1], h2 = "NHWC" === a2 ? u3.shape[3] : u3.shape[1];
  C(l2 === n2.shape[2], function() {
    return "Error in conv2dDerInput: depth of input (" + l2 + ") must match input depth for filter " + n2.shape[2] + ".";
  }), C(h2 === n2.shape[3], function() {
    return "Error in conv2dDerInput: depth of output (" + h2 + ") must match output depth for filter " + n2.shape[3] + ".";
  }), null != i2 && C(A(o2), function() {
    return "Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode " + i2 + " but got pad " + o2 + ".";
  });
  var f2 = Bo(a2), d2 = So(s2, n2.shape, r2, 1, o2, i2, false, f2), p2 = Lt.runKernelFunc(function(t3, e3) {
    var r3 = t3.conv2dDerInput(u3, n2, d2);
    return e3([n2, u3]), r3;
  }, { dy4D: u3, filter: n2 }, function(t3, e3) {
    var n3 = e3[0], s3 = e3[1];
    return { dy4D: function() {
      return qc(t3, n3, r2, o2, a2, 1, i2);
    }, filter: function() {
      return jc(t3, s3, n3.shape, r2, o2, a2, i2);
    } };
  });
  return c2 ? p2.as3D(p2.shape[1], p2.shape[2], p2.shape[3]) : p2;
}
function zc(t2) {
  var e2 = function(t3) {
    return "number" == typeof t3 ? [t3, t3, t3] : 2 === t3.length ? [t3[0], t3[1], 1] : t3;
  }(t2), n2 = e2[0], r2 = e2[1], o2 = e2[2];
  return 1 === n2 && 1 === r2 && 1 === o2;
}
function Gc(t2, e2, n2, r2, o2) {
  C(t2.length === e2.rank, function() {
    return "Length of inShape (" + t2.length + ") and rank of dy (" + e2.rank + ") must match";
  });
  var a2 = t2, i2 = e2, s2 = false;
  4 === e2.rank && (s2 = true, i2 = e2.as5D(1, e2.shape[0], e2.shape[1], e2.shape[2], e2.shape[3]), a2 = [1, t2[0], t2[1], t2[2], t2[3]]);
  var u3 = a2[4], c2 = i2.shape[4];
  C(5 === a2.length, function() {
    return "Error in conv3dDerInput: inShape must be length 5, but got length " + a2.length + ".";
  }), C(5 === i2.rank, function() {
    return "Error in conv3dDerInput: dy must be rank 5, but got rank " + i2.rank;
  }), C(5 === n2.rank, function() {
    return "Error in conv3dDerInput: filter must be rank 5, but got rank " + n2.rank;
  }), C(u3 === n2.shape[3], function() {
    return "Error in conv3dDerInput: depth of input (" + u3 + ") must match input depth for filter " + n2.shape[3] + ".";
  }), C(c2 === n2.shape[4], function() {
    return "Error in conv3dDerInput: depth of output (" + c2 + ") must match output depth for filter " + n2.shape[4] + ".";
  });
  var l2 = Ao(a2, n2.shape, r2, 1, o2), h2 = Lt.runKernelFunc(function(t3) {
    return t3.conv3dDerInput(i2, n2, l2);
  }, { dy5D: i2 });
  return s2 ? h2.as4D(h2.shape[1], h2.shape[2], h2.shape[3], h2.shape[4]) : h2;
}
function cl(t2, e2, n2, r2, o2, a2) {
  var i2 = mn(t2, "x", "maxPool"), s2 = i2, u3 = false;
  3 === i2.rank && (u3 = true, s2 = i2.as4D(1, i2.shape[0], i2.shape[1], i2.shape[2])), null == r2 && (r2 = [1, 1]), C(4 === s2.rank, function() {
    return "Error in maxPool: input must be rank 4 but got rank " + s2.rank + ".";
  }), C(Mo(n2, r2), function() {
    return "Error in maxPool: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + r2 + "'";
  }), null != a2 && C(A(o2), function() {
    return "Error in maxPool: pad must be an integer when using, dimRoundingMode " + a2 + " but got pad " + o2 + ".";
  });
  var c2 = Io(s2.shape, e2, n2, r2, o2, a2);
  if (1 === c2.filterWidth && 1 === c2.filterHeight && S(c2.inShape, c2.outShape)) return i2.clone();
  var l2 = [s2], h2 = Lt.runKernelFunc(function(t3, e3) {
    var n3 = t3.maxPool(s2, c2);
    return e3([s2, n3]), n3;
  }, { x: s2 }, function(t3, a3) {
    var i3 = a3[0], s3 = a3[1];
    return { x: function() {
      return function(t4, e3, n3, r3, o3, a4, i4, s4) {
        var u4 = mn(t4, "dy", "maxPoolBackprop"), c3 = mn(e3, "input", "maxPoolBackprop"), l3 = mn(n3, "output", "maxPoolBackprop");
        C(c3.rank === u4.rank, function() {
          return "Rank of input (" + c3.rank + ") does not match rank of dy (" + u4.rank + ")";
        }), null == a4 && (a4 = [1, 1]);
        C(Mo(o3, a4), function() {
          return "Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides " + o3 + " and dilations '" + a4 + "'";
        }), C(4 === u4.rank, function() {
          return "Error in maxPoolBackprop: dy must be rank 4 but got rank " + u4.rank + ".";
        }), C(4 === c3.rank, function() {
          return "Error in maxPoolBackprop: input must be rank 4 but got rank " + c3.rank + ".";
        }), null != s4 && C(A(i4), function() {
          return "Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode " + s4 + " but got pad " + i4 + ".";
        });
        var h3 = Io(c3.shape, r3, o3, a4, i4, s4);
        return Lt.runKernelFunc(function(t5) {
          return t5.maxPoolBackprop(u4, c3, l3, h3);
        }, { $dy: u4, $input: c3 });
      }(t3, i3, s3, e2, n2, r2, o2);
    } };
  }, "MaxPool", c2, l2);
  return u3 ? h2.as3D(h2.shape[1], h2.shape[2], h2.shape[3]) : h2;
}
function ll(t2, e2, n2, r2, o2, a2) {
  var i2 = mn(t2, "x", "avgPool", "float32");
  null == r2 && (r2 = [1, 1]), C(Mo(n2, r2), function() {
    return "Error in avgPool: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + r2 + "'";
  });
  var s2 = i2, u3 = false;
  3 === i2.rank && (u3 = true, s2 = i2.as4D(1, i2.shape[0], i2.shape[1], i2.shape[2])), C(4 === s2.rank, function() {
    return "Error in avgPool: x must be rank 4 but got rank " + s2.rank + ".";
  }), null != a2 && C(A(o2), function() {
    return "Error in avgPool: pad must be an integer when using, dimRoundingMode " + a2 + " but got pad " + o2 + ".";
  });
  var c2 = Io(s2.shape, e2, n2, r2, o2, a2);
  if (1 === c2.filterWidth && 1 === c2.filterHeight && S(c2.inShape, c2.outShape)) return i2.clone();
  var l2 = Lt.runKernelFunc(function(t3) {
    return t3.avgPool(s2, c2);
  }, { x: s2 }, function(t3) {
    return { x: function() {
      return function(t4, e3, n3, r3, o3, a3) {
        var i3 = mn(t4, "dy", "avgPoolBackprop"), s3 = mn(e3, "input", "avgPoolBackprop");
        C(s3.rank === i3.rank, function() {
          return "Rank of input (" + s3.rank + ") does not match rank of dy (" + i3.rank + ")";
        }), null == o3 && (o3 = [1, 1]);
        C(Mo(r3, o3), function() {
          return "Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides " + r3 + " and dilations '" + o3 + "'";
        });
        var u4 = s3, c3 = i3, l3 = false;
        3 === s3.rank && (l3 = true, u4 = s3.as4D(1, s3.shape[0], s3.shape[1], s3.shape[2]), c3 = i3.as4D(1, i3.shape[0], i3.shape[1], i3.shape[2]));
        C(4 === c3.rank, function() {
          return "Error in avgPoolBackprop: dy must be rank 4 but got rank " + c3.rank + ".";
        }), C(4 === u4.rank, function() {
          return "Error in avgPoolBackprop: input must be rank 4 but got rank " + u4.rank + ".";
        });
        var h2 = Io(u4.shape, n3, r3, o3, a3), f2 = Lt.runKernelFunc(function(t5) {
          return t5.avgPoolBackprop(c3, u4, h2);
        }, { dy4D: c3, input4D: u4 });
        if (l3) return f2.as3D(f2.shape[1], f2.shape[2], f2.shape[3]);
        return f2;
      }(t3, s2, e2, n2, r2, o2);
    } };
  }, "AvgPool", c2);
  return l2 = l2.cast(i2.dtype), u3 ? l2.as3D(l2.shape[1], l2.shape[2], l2.shape[3]) : l2;
}
function wl(t2, e2, n2, r2, o2) {
  return e2.rank < n2.rank && (e2 = e2.reshape(wn(e2.shape, r2))), t2.rank < n2.rank && (t2 = t2.reshape(wn(t2.shape, r2))), { x: function() {
    var r3 = t2.mul(n2.equal(e2).cast(t2.dtype));
    return null == o2 ? r3 : r3.transpose(o2);
  } };
}
function rh(t2, e2, n2) {
  for (var r2 = 1 - t2 % 2, o2 = new Float32Array(t2), a2 = 0; a2 < t2; ++a2) {
    var i2 = 2 * Math.PI * a2 / (t2 + r2 - 1);
    o2[a2] = e2 - n2 * Math.cos(i2);
  }
  return Mn(o2, "float32");
}
function wh(t2, e2) {
  return void 0 === e2 && (e2 = false), Lt.tidy(function() {
    if (2 !== t2.shape.length) throw new Error("qr2d() requires a 2D Tensor, but got a " + t2.shape.length + "D Tensor.");
    for (var n2 = t2.shape[0], r2 = t2.shape[1], o2 = Cr(n2), a2 = t2.clone(), i2 = Bn([[1]], [1, 1]), s2 = i2.clone(), u3 = n2 >= r2 ? r2 : n2, c2 = function(t3) {
      var e3, u4 = a2, c3 = s2, l3 = o2;
      e3 = Lt.tidy(function() {
        var e4 = a2.slice([t3, t3], [n2 - t3, 1]), u5 = e4.norm(), c4 = a2.slice([t3, t3], [1, 1]), l4 = Bn([[-1]]).where(c4.greater(0), Bn([[1]])), h2 = c4.sub(l4.mul(u5)), f2 = e4.div(h2);
        s2 = 1 === f2.shape[0] ? i2.clone() : i2.concat(f2.slice([1, 0], [f2.shape[0] - 1, f2.shape[1]]), 0);
        var d2 = l4.matMul(h2).div(u5).neg(), p2 = a2.slice([t3, 0], [n2 - t3, r2]), v = d2.mul(s2);
        if (0 === t3) a2 = p2.sub(v.matMul(s2.transpose().matMul(p2)));
        else {
          var m = p2.sub(v.matMul(s2.transpose().matMul(p2)));
          a2 = a2.slice([0, 0], [t3, r2]).concat(m, 0);
        }
        var g2 = o2.slice([0, t3], [n2, o2.shape[1] - t3]);
        if (0 === t3) o2 = g2.sub(g2.matMul(s2).matMul(v.transpose()));
        else {
          var y2 = g2.sub(g2.matMul(s2).matMul(v.transpose()));
          o2 = o2.slice([0, 0], [n2, t3]).concat(y2, 1);
        }
        return [s2, a2, o2];
      }), s2 = e3[0], a2 = e3[1], o2 = e3[2], tn([u4, c3, l3]);
    }, l2 = 0; l2 < u3; ++l2) c2(l2);
    return !e2 && n2 > r2 && (o2 = o2.slice([0, 0], [n2, r2]), a2 = a2.slice([0, 0], [r2, r2])), [o2, a2];
  });
}
function kh(t2, e2, n2, r2, o2, a2) {
  null == r2 && (r2 = 0.5), null == o2 && (o2 = Number.NEGATIVE_INFINITY), null == a2 && (a2 = 0);
  var i2 = t2.shape[0];
  return n2 = Math.min(n2, i2), C(0 <= r2 && r2 <= 1, function() {
    return "iouThreshold must be in [0, 1], but was '" + r2 + "'";
  }), C(2 === t2.rank, function() {
    return "boxes must be a 2D tensor, but was of rank '" + t2.rank + "'";
  }), C(4 === t2.shape[1], function() {
    return "boxes must have 4 columns, but 2nd dimension was " + t2.shape[1];
  }), C(1 === e2.rank, function() {
    return "scores must be a 1D tensor";
  }), C(e2.shape[0] === i2, function() {
    return "scores has incompatible shape with boxes. Expected " + i2 + ", but was " + e2.shape[0];
  }), C(0 <= a2 && a2 <= 1, function() {
    return "softNmsSigma must be in [0, 1], but was '" + a2 + "'";
  }), { maxOutputSize: n2, iouThreshold: r2, scoreThreshold: o2, softNmsSigma: a2 };
}
function Hh(t2, e2) {
  Array.isArray(t2) || (t2 = [t2]), t2.forEach(function(t3) {
    null != t3 && C("complex64" !== t3.dtype, function() {
      return e2 + " does not support complex64 tensors.";
    });
  });
}
function qh(t2, e2, n2, r2) {
  if ("linear" === n2) return t2.linear(e2);
  if ("relu" === n2) return t2.relu(e2);
  if ("elu" === n2) return t2.elu(e2);
  if ("relu6" === n2) return t2.relu6(e2);
  if ("prelu" === n2) return t2.prelu(e2, r2);
  throw new Error("Activation " + n2 + " has not been implemented for the CPU backend.");
}
function cf(t2, e2) {
  for (var n2 = {}, r2 = 0, o2 = function(e3) {
    var o3 = e3.name, a3 = e3.dtype, i3 = e3.shape, s2 = k(i3), u3 = void 0;
    if ("quantization" in e3) {
      var c2 = e3.quantization;
      if ("uint8" !== c2.dtype && "uint16" !== c2.dtype) throw new Error("Weight " + e3.name + " has unknown quantization dtype " + c2.dtype + ". Supported quantization dtypes are: 'uint8' and 'uint16'.");
      var l2 = sf[c2.dtype], h2 = t2.slice(r2, r2 + s2 * l2), f2 = "uint8" === c2.dtype ? new Uint8Array(h2) : new Uint16Array(h2);
      if ("float32" === a3) u3 = Float32Array.from(f2, function(t3) {
        return t3 * c2.scale + c2.min;
      });
      else {
        if ("int32" !== a3) throw new Error("Unsupported dtype in weight '" + o3 + "': " + a3);
        u3 = Int32Array.from(f2, function(t3) {
          return Math.round(t3 * c2.scale + c2.min);
        });
      }
      r2 += s2 * l2;
    } else if ("string" === a3) {
      var d2 = k(e3.shape);
      u3 = [];
      for (var p2 = 0; p2 < d2; p2++) {
        var v = new Uint32Array(t2.slice(r2, r2 + uf))[0];
        r2 += uf;
        var m = new Uint8Array(t2.slice(r2, r2 + v));
        u3.push(m), r2 += v;
      }
    } else {
      var g2 = sf[a3];
      h2 = t2.slice(r2, r2 + s2 * g2);
      if ("float32" === a3) u3 = new Float32Array(h2);
      else if ("int32" === a3) u3 = new Int32Array(h2);
      else {
        if ("bool" !== a3) throw new Error("Unsupported dtype in weight '" + o3 + "': " + a3);
        u3 = new Uint8Array(h2);
      }
      r2 += s2 * g2;
    }
    n2[o3] = Fn(u3, i3, a3);
  }, a2 = 0, i2 = e2; a2 < i2.length; a2++) {
    o2(i2[a2]);
  }
  return n2;
}
function lf(t2) {
  if (null === t2) throw new Error("Invalid input value: " + JSON.stringify(t2));
  var e2 = 0, n2 = [];
  t2.forEach(function(t3) {
    if (e2 += t3.byteLength, n2.push(t3.byteLength === t3.buffer.byteLength ? t3 : new t3.constructor(t3)), !(t3 instanceof Float32Array || t3 instanceof Int32Array || t3 instanceof Uint8Array)) throw new Error("Unsupported TypedArray subtype: " + t3.constructor.name);
  });
  var r2 = new Uint8Array(e2), o2 = 0;
  return n2.forEach(function(t3) {
    r2.set(new Uint8Array(t3.buffer), o2), o2 += t3.byteLength;
  }), r2.buffer;
}
function ff(t2) {
  return hf ? Buffer.byteLength(t2) : new Blob([t2]).size;
}
function df(t2) {
  var e2 = 0;
  t2.forEach(function(t3) {
    e2 += t3.byteLength;
  });
  var n2 = new Uint8Array(e2), r2 = 0;
  return t2.forEach(function(t3) {
    n2.set(new Uint8Array(t3), r2), r2 += t3.byteLength;
  }), n2.buffer;
}
function pf(t2) {
  for (t2 = t2.trim(); t2.endsWith("/"); ) t2 = t2.slice(0, t2.length - 1);
  var e2 = t2.split("/");
  return e2[e2.length - 1];
}
function vf(t2) {
  if (t2.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
  return { dateSaved: /* @__PURE__ */ new Date(), modelTopologyType: "JSON", modelTopologyBytes: null == t2.modelTopology ? 0 : ff(JSON.stringify(t2.modelTopology)), weightSpecsBytes: null == t2.weightSpecs ? 0 : ff(JSON.stringify(t2.weightSpecs)), weightDataBytes: null == t2.weightData ? 0 : t2.weightData.byteLength };
}
function xf(t2) {
  if (-1 === t2.indexOf(gf)) throw new Error("The url string provided does not contain a scheme. Supported schemes are: " + yf.getSchemes().join(","));
  return { scheme: t2.split(gf)[0], path: t2.split(gf)[1] };
}
function bf(t2, e2, o2) {
  return void 0 === o2 && (o2 = false), n(this, void 0, void 0, function() {
    var n2, a2, i2, s2, u3, c2, l2, h2, f2;
    return r(this, function(r2) {
      switch (r2.label) {
        case 0:
          return C(t2 !== e2, function() {
            return "Old path and new path are the same: '" + t2 + "'";
          }), C((n2 = mf.getLoadHandlers(t2)).length > 0, function() {
            return "Copying failed because no load handler is found for source URL " + t2 + ".";
          }), C(n2.length < 2, function() {
            return "Copying failed because more than one (" + n2.length + ") load handlers for source URL " + t2 + ".";
          }), a2 = n2[0], C((i2 = mf.getSaveHandlers(e2)).length > 0, function() {
            return "Copying failed because no save handler is found for destination URL " + e2 + ".";
          }), C(i2.length < 2, function() {
            return "Copying failed because more than one (" + n2.length + ") save handlers for destination URL " + e2 + ".";
          }), s2 = i2[0], u3 = xf(t2).scheme, c2 = xf(t2).path, l2 = u3 === xf(t2).scheme, [4, a2.load()];
        case 1:
          return h2 = r2.sent(), o2 && l2 ? [4, yf.getManager(u3).removeModel(c2)] : [3, 3];
        case 2:
          r2.sent(), r2.label = 3;
        case 3:
          return [4, s2.save(h2)];
        case 4:
          return f2 = r2.sent(), !o2 || l2 ? [3, 6] : [4, yf.getManager(u3).removeModel(c2)];
        case 5:
          r2.sent(), r2.label = 6;
        case 6:
          return [2, f2.modelArtifactsInfo];
      }
    });
  });
}
function Ef() {
  if (!i().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
  var t2 = window || self, e2 = t2.indexedDB || t2.mozIndexedDB || t2.webkitIndexedDB || t2.msIndexedDB || t2.shimIndexedDB;
  if (null == e2) throw new Error("The current browser does not appear to support IndexedDB.");
  return e2;
}
function Rf(t2) {
  var e2 = t2.result;
  e2.createObjectStore(wf, { keyPath: "modelPath" }), e2.createObjectStore(Cf, { keyPath: "modelPath" });
}
function Mf(t2) {
  return { info: [Df, t2, Tf].join(Af), topology: [Df, t2, Nf].join(Af), weightSpecs: [Df, t2, Ff].join(Af), weightData: [Df, t2, _f].join(Af), modelMetadata: [Df, t2, Of].join(Af) };
}
function Bf(t2) {
  var e2 = t2.split(Af);
  if (e2.length < 3) throw new Error("Invalid key format: " + t2);
  return e2.slice(1, e2.length - 1).join(Af);
}
function Gf(t2) {
  return new Promise(function(t3) {
    return setTimeout(t3);
  }).then(t2);
}
function Kf(t2, e2, n2, r2) {
  !function(t3) {
    C(null != t3 && Array.isArray(t3) && t3.length > 0, function() {
      return "promises must be a none empty array";
    });
  }(t2), function(t3, e3) {
    C(t3 >= 0 && t3 <= 1, function() {
      return "Progress fraction must be in range [0, 1], but got startFraction " + t3;
    }), C(e3 >= 0 && e3 <= 1, function() {
      return "Progress fraction must be in range [0, 1], but got endFraction " + e3;
    }), C(e3 >= t3, function() {
      return "startFraction must be no more than endFraction, but got startFraction " + t3 + " and endFraction " + e3;
    });
  }(n2 = null == n2 ? 0 : n2, r2 = null == r2 ? 1 : r2);
  var o2 = 0;
  return Promise.all(t2.map(function(a2) {
    return a2.then(function(a3) {
      var i2 = n2 + ++o2 / t2.length * (r2 - n2);
      return e2(i2), a3;
    }), a2;
  }));
}
function jf(t2, e2) {
  return n(this, void 0, void 0, function() {
    var n2, o2, a2, s2, u3, c2, l2, h2, f2;
    return r(this, function(r2) {
      switch (r2.label) {
        case 0:
          return null == e2 && (e2 = {}), n2 = null == e2.fetchFunc ? i().platform.fetch : e2.fetchFunc, o2 = t2.map(function(t3) {
            return n2(t3, e2.requestInit, { isBinary: true });
          }), a2 = 0, s2 = 0.5, null != e2.onProgress ? [3, 2] : [4, Promise.all(o2)];
        case 1:
          return u3 = r2.sent(), [3, 4];
        case 2:
          return [4, Kf(o2, e2.onProgress, a2, s2)];
        case 3:
          u3 = r2.sent(), r2.label = 4;
        case 4:
          return c2 = u3.map(function(t3) {
            return t3.arrayBuffer();
          }), l2 = 0.5, h2 = 1, null != e2.onProgress ? [3, 6] : [4, Promise.all(c2)];
        case 5:
          return f2 = r2.sent(), [3, 8];
        case 6:
          return [4, Kf(c2, e2.onProgress, l2, h2)];
        case 7:
          f2 = r2.sent(), r2.label = 8;
        case 8:
          return [2, f2];
      }
    });
  });
}
function Xf(t2) {
  var e2 = this;
  return function(o2, a2, i2) {
    return void 0 === a2 && (a2 = ""), n(e2, void 0, void 0, function() {
      var e3, n2, s2, u3, c2, l2, h2, f2, d2, p2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (e3 = o2.map(function() {
              return false;
            }), n2 = {}, s2 = null != i2 ? i2.map(function() {
              return false;
            }) : [], u3 = [], o2.forEach(function(t3, r3) {
              var o3 = 0;
              t3.weights.forEach(function(t4) {
                var a3 = "quantization" in t4 ? t4.quantization.dtype : t4.dtype, c3 = sf[a3] * k(t4.shape), l3 = function() {
                  e3[r3] = true, null == n2[r3] && (n2[r3] = []), n2[r3].push({ manifestEntry: t4, groupOffset: o3, sizeBytes: c3 });
                };
                null != i2 ? i2.forEach(function(e4, n3) {
                  e4 === t4.name && (l3(), s2[n3] = true);
                }) : l3(), u3.push(t4.name), o3 += c3;
              });
            }), !s2.every(function(t3) {
              return t3;
            })) throw c2 = i2.filter(function(t3, e4) {
              return !s2[e4];
            }), new Error("Could not find weights in manifest with names: " + c2.join(", ") + ". \nManifest JSON has weights with names: " + u3.join(", ") + ".");
            return l2 = e3.reduce(function(t3, e4, n3) {
              return e4 && t3.push(n3), t3;
            }, []), h2 = [], l2.forEach(function(t3) {
              o2[t3].paths.forEach(function(t4) {
                var e4 = a2 + (a2.endsWith("/") ? "" : "/") + t4;
                h2.push(e4);
              });
            }), [4, t2(h2)];
          case 1:
            return f2 = r2.sent(), d2 = {}, p2 = 0, l2.forEach(function(t3) {
              for (var e4 = o2[t3].paths.length, r3 = 0, a3 = 0; a3 < e4; a3++) r3 += f2[p2 + a3].byteLength;
              for (var i3 = new ArrayBuffer(r3), s3 = new Uint8Array(i3), u4 = 0, c3 = 0; c3 < e4; c3++) {
                var l3 = new Uint8Array(f2[p2 + c3]);
                s3.set(l3, u4), u4 += l3.byteLength;
              }
              n2[t3].forEach(function(t4) {
                var e5 = cf(i3.slice(t4.groupOffset, t4.groupOffset + t4.sizeBytes), [t4.manifestEntry]);
                for (var n3 in e5) d2[n3] = e5[n3];
              }), p2 += e4;
            }), [2, d2];
        }
      });
    });
  };
}
function $f(t2) {
  return null != t2.match(Yf.URL_SCHEME_REGEX);
}
function Jf(t2, e2) {
  return new Yf(t2, e2);
}
function cd(t2) {
  C(null != t2.className, function() {
    return "Class being registered does not have the static className property defined.";
  }), C("string" == typeof t2.className, function() {
    return "className is required to be a string, but got type " + typeof t2.className;
  }), C(t2.className.length > 0, function() {
    return "Class being registered has an empty-string as its className, which is disallowed.";
  }), ud.register(t2);
}
function dd() {
  return 32 === Lt.backend.floatPrecision() ? hd : fd;
}
function pd(t2, e2, n2) {
  var r2 = true;
  if ((V(t2) || V(e2)) && (r2 = false), V(t2) && V(e2) && (r2 = true), r2) {
    var o2 = t2.constructor.name, a2 = e2.constructor.name;
    if (o2 !== a2) throw new Error("Arrays are of different type. Actual: " + o2 + ". Expected: " + a2);
  }
  if (Array.isArray(t2) && Array.isArray(e2)) {
    var i2 = pn(t2), s2 = pn(e2);
    if (!S(i2, s2)) throw new Error("Arrays have different shapes. Actual: [" + i2 + "]. Expected: [" + s2 + "]");
  }
  var u3 = V(t2) ? t2 : I(t2), c2 = V(e2) ? e2 : I(e2);
  if (u3.length !== c2.length) throw new Error("Arrays have different lengths actual: " + u3.length + " vs expected: " + c2.length + ".\nActual:   " + u3 + ".\nExpected: " + c2 + ".");
  for (var l2 = 0; l2 < c2.length; ++l2) {
    var h2 = u3[l2], f2 = c2[l2];
    if (!n2(h2, f2)) throw new Error("Arrays differ: actual[" + l2 + "] = " + h2 + ", expected[" + l2 + "] = " + f2 + ".\nActual:   " + u3 + ".\nExpected: " + c2 + ".");
  }
}
function vd(t2, e2, n2) {
  return !isFinite(t2) && !isFinite(e2) || !(isNaN(t2) || isNaN(e2) || Math.abs(t2 - e2) > n2);
}
var t, o, s, u2, c, st, ut, ct, lt, ht, ft, gt, yt, xt, bt, wt, Ct, Et, Rt, It, kt, St, At, Ot, Mt, Bt, Pt, Lt, Ut, Vt, zt, Gt, Ht, qt, Zt, te, ie, se, ue, Ge, He, Dn, Tn, Nn, jn, Xn, Yn, $n, Qn, Jn, Zn, tr, nr, rr, or, ar, ir, sr, ur, cr, lr, hr, fr, vr, mr, gr, yr, xr, br, wr, Cr, Er, Rr, Ir, kr, Sr, Ar, Dr, Tr, Nr, Fr, _r, Or, Mr, Br, Pr, Lr, Wr, Ur, Vr, Xr, Yr, to, uo, go, yo, xo, bo, Uo, ra, oa, aa, ha, va, ma, ga, ya, Ra, Ia, ka, Sa, Aa, Da, Ta, Na, Fa, _a, Oa, Ma, Ba, Pa, La, Wa, Ua, Va, za, Ga, qa, Ka, ja, Xa, Ya, $a, Qa, Ja, Za, ti, ei, ni, oi, ai, ii, si, ui, ci, li, hi, fi, di, pi, vi, mi, gi, Mi, Bi, Li, Wi, Ui, Vi, zi, Gi, Hi, qi, Ki, ji, Xi, Yi, $i, Qi, Ji, Zi, ts, es, ns, rs, os, as, is, ss, us, cs, ls, hs, fs, ds, ps, gs, ys, xs, bs, ws, Cs, Es, Rs, Is, ks, Ss, As, Ds, Ts, Ns, Fs, _s, Os, Ms, Bs, Ps, Ls, Ws, Us, Vs, zs, Gs, Hs, qs, Ks, js, Xs, Ys, $s, Js, Zs, tu, eu, nu, ru, ou, au, iu, su, uu, cu, lu, hu, fu, du, pu, vu, mu, gu, yu, xu, bu, wu, Cu, Eu, Ru, Iu, ku, Su, Au, Du, Tu, Nu, Fu, _u, Ou, Mu, Bu, Gu, Hu, qu, Ku, ju, Xu, Yu, $u, Qu, Ju, Zu, tc, ec, nc, rc, oc, ac, ic, sc, uc, cc, lc, hc, fc, dc, pc, vc, mc, gc, yc, xc, bc, wc, Cc, Ec, Rc, Ic, kc, Sc, Ac, Dc, Tc, Nc, Fc, _c, Oc, Mc, Lc, Wc, Uc, Hc, qc, Kc, jc, Xc, Yc, $c, Qc, Jc, Zc, tl, el, nl, rl, ol, al, il, sl, ul, hl, fl, dl, pl, vl, ml, gl, yl, xl, bl, Cl, El, Rl, Il, kl, Sl, Al, Dl, Tl, Nl, Fl, _l, Ol, Ml, Bl, Pl, Ll, Wl, Ul, Vl, zl, Gl, Hl, ql, Kl, jl, Xl, Yl, $l, Ql, Jl, Zl, th, eh, nh, oh, ah, ih, sh, uh, ch, lh, hh, fh, dh, ph, vh, mh, gh, yh, xh, bh, Ch, Eh, Rh, Ih, Sh, Ah, Dh, Th, Nh, Fh, _h, Oh, Mh, Bh, Ph, Lh, Wh, Uh, Vh, zh, Gh, Kh, jh, Xh, Yh, $h, Qh, Jh, Zh, tf, ef, nf, rf, of2, af, sf, uf, hf, mf, gf, yf, wf, Cf, If, kf, Sf, Af, Df, Tf, Nf, Ff, _f, Of, Pf, Lf, Wf, Uf, Vf, zf, Hf, qf, Yf, Qf, Zf, td, ed, nd, rd, od, ad, id, sd, ud, ld, hd, fd, md, yd, xd, bd, wd, Cd, Ed, Rd, Id, kd, Sd, Ad;
var init_tf_core_esm = __esm({
  "node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js"() {
    "use strict";
    t = function(e2, n2) {
      return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t2, e3) {
        t2.__proto__ = e3;
      } || function(t2, e3) {
        for (var n3 in e3) e3.hasOwnProperty(n3) && (t2[n3] = e3[n3]);
      })(e2, n2);
    };
    o = function() {
      function t2(t3) {
        this.global = t3, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.populateURLFlags();
      }
      return t2.prototype.setPlatform = function(t3, e2) {
        null != this.platform && console.warn("Platform " + this.platformName + " has already been set. Overwriting the platform with " + e2 + "."), this.platformName = t3, this.platform = e2;
      }, t2.prototype.registerFlag = function(t3, e2, n2) {
        if (this.flagRegistry[t3] = { evaluationFn: e2, setHook: n2 }, null != this.urlFlags[t3]) {
          var r2 = this.urlFlags[t3];
          console.warn("Setting feature override from URL " + t3 + ": " + r2 + "."), this.set(t3, r2);
        }
      }, t2.prototype.get = function(t3) {
        return t3 in this.flags ? this.flags[t3] : (this.flags[t3] = this.evaluateFlag(t3), this.flags[t3]);
      }, t2.prototype.getNumber = function(t3) {
        return this.get(t3);
      }, t2.prototype.getBool = function(t3) {
        return this.get(t3);
      }, t2.prototype.getFlags = function() {
        return this.flags;
      }, Object.defineProperty(t2.prototype, "features", { get: function() {
        return this.flags;
      }, enumerable: true, configurable: true }), t2.prototype.set = function(t3, e2) {
        if (null == this.flagRegistry[t3]) throw new Error("Cannot set flag " + t3 + " as it has not been registered.");
        this.flags[t3] = e2, null != this.flagRegistry[t3].setHook && this.flagRegistry[t3].setHook(e2);
      }, t2.prototype.evaluateFlag = function(t3) {
        if (null == this.flagRegistry[t3]) throw new Error("Cannot evaluate flag '" + t3 + "': no evaluation function found.");
        return this.flagRegistry[t3].evaluationFn();
      }, t2.prototype.setFlags = function(t3) {
        this.flags = Object.assign({}, t3);
      }, t2.prototype.reset = function() {
        this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
      }, t2.prototype.populateURLFlags = function() {
        var t3 = this;
        if (void 0 !== this.global && void 0 !== this.global.location && void 0 !== this.global.location.search) {
          var e2, n2, r2 = (e2 = this.global.location.search, n2 = {}, e2.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function(t4) {
            for (var e3 = [], r3 = 1; r3 < arguments.length; r3++) e3[r3 - 1] = arguments[r3];
            return a(n2, e3[0], e3[1]), e3.join("=");
          }), n2);
          if ("tfjsflags" in r2) r2.tfjsflags.split(",").forEach(function(e3) {
            var n3 = e3.split(":"), r3 = n3[0], o2 = n3[1];
            t3.urlFlags[r3] = function(t4, e4) {
              if ("true" === (e4 = e4.toLowerCase()) || "false" === e4) return "true" === e4;
              if ("" + +e4 === e4) return +e4;
              throw new Error("Could not parse value flag value " + e4 + " for flag " + t4 + ".");
            }(r3, o2);
          });
        }
      }, t2;
    }();
    s = null;
    u2 = /* @__PURE__ */ new Map();
    c = /* @__PURE__ */ new Map();
    st = Object.freeze({ shuffle: y, clamp: x, nearestLargerEven: b, sum: w, randUniform: function(t2, e2) {
      var n2 = Math.random();
      return e2 * n2 + (1 - n2) * t2;
    }, distSquared: function(t2, e2) {
      for (var n2 = 0, r2 = 0; r2 < t2.length; r2++) {
        var o2 = Number(t2[r2]) - Number(e2[r2]);
        n2 += o2 * o2;
      }
      return n2;
    }, assert: C, assertShapesMatch: E, assertNonNull: R, flatten: I, sizeFromShape: k, isScalarShape: function(t2) {
      return 0 === t2.length;
    }, arraysEqual: S, isInt: A, tanh: D, sizeToSquarishShape: T, createShuffledIndices: function(t2) {
      for (var e2 = new Uint32Array(t2), n2 = 0; n2 < t2; ++n2) e2[n2] = n2;
      return y(e2), e2;
    }, rightPad: N, repeatedTry: F, inferFromImplicitShape: _, parseAxisParam: O, squeezeShape: M, getTypedArrayFromDType: B, getArrayFromDType: P, checkConversionForErrors: L, isValidDtype: W, hasEncodingLoss: U, isTypedArray: V, bytesPerElement: z, bytesFromStringArray: G, isString: H, isBoolean: q, isNumber: K, inferDtype: j, isFunction: X, nearestDivisor: Y, computeStrides: $, toTypedArray: Q, toNestedArray: J, makeOnesTypedArray: Z, makeZerosTypedArray: tt, now: et, assertNonNegativeIntegerDimensions: nt, fetch: function(t2, e2) {
      return i().platform.fetch(t2, e2);
    }, encodeString: rt, decodeString: ot, locToIndex: at, indexToLoc: it });
    ut = function() {
      function t2(t3, e2) {
        this.backendTimer = t3, this.logger = e2, null == e2 && (this.logger = new ct());
      }
      return t2.prototype.profileKernel = function(t3, e2, n2) {
        var r2, o2 = this, a2 = this.backendTimer.time(function() {
          r2 = n2();
        });
        return r2.forEach(function(n3) {
          n3.data().then(function(r3) {
            !function(t4, e3, n4) {
              if ("float32" !== e3) return false;
              for (var r4 = 0; r4 < t4.length; r4++) {
                var o3 = t4[r4];
                if (isNaN(o3) || !isFinite(o3)) return console.warn("Found " + o3 + " in the result of '" + n4 + "'"), true;
              }
            }(r3, n3.dtype, t3), a2.then(function(a3) {
              var i2 = "";
              null != a3.getExtraProfileInfo && (i2 = a3.getExtraProfileInfo()), o2.logger.logKernelProfile(t3, n3, r3, a3.kernelMs, e2, i2);
            });
          });
        }), r2;
      }, t2;
    }();
    ct = function() {
      function t2() {
      }
      return t2.prototype.logKernelProfile = function(t3, e2, n2, r2, o2, a2) {
        var i2 = "number" == typeof r2 ? N(r2 + "ms", 9) : r2.error, s2 = N(t3, 25), u3 = e2.rank, c2 = e2.size, l2 = N(e2.shape.toString(), 14), h2 = "";
        for (var f2 in o2) {
          var d2 = o2[f2].shape || e2.shape, p2 = d2.length;
          h2 += f2 + ": " + p2 + "D " + (p2 > 0 ? d2 : "") + " ";
        }
        console.log("%c" + s2 + "	%c" + i2 + "	%c" + u3 + "D " + l2 + "	%c" + c2 + "	%c" + h2 + "	%c" + a2, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
      }, t2;
    }();
    lt = 20;
    ht = 3;
    ft = 7;
    gt = function() {
      function t2(t3, e2, n2) {
        var r2 = this;
        if (this.dtype = e2, this.shape = t3.slice(), this.size = k(t3), null != n2) {
          var o2 = n2.length;
          C(o2 === this.size, function() {
            return "Length of values '" + o2 + "' does not match the size inferred by the shape '" + r2.size + "'.";
          });
        }
        if ("complex64" === e2) throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
        this.values = n2 || P(e2, this.size), this.strides = $(t3);
      }
      return t2.prototype.set = function(t3) {
        for (var e2 = this, n2 = [], r2 = 1; r2 < arguments.length; r2++) n2[r2 - 1] = arguments[r2];
        0 === n2.length && (n2 = [0]), C(n2.length === this.rank, function() {
          return "The number of provided coordinates (" + n2.length + ") must match the rank (" + e2.rank + ")";
        });
        var o2 = this.locToIndex(n2);
        this.values[o2] = t3;
      }, t2.prototype.get = function() {
        for (var t3 = [], e2 = 0; e2 < arguments.length; e2++) t3[e2] = arguments[e2];
        0 === t3.length && (t3 = [0]);
        for (var n2 = 0, r2 = 0, o2 = t3; r2 < o2.length; r2++) {
          var a2 = o2[r2];
          if (a2 < 0 || a2 >= this.shape[n2]) {
            var i2 = "Requested out of range element at " + t3 + ".   Buffer shape=" + this.shape;
            throw new Error(i2);
          }
          n2++;
        }
        for (var s2 = t3[t3.length - 1], u3 = 0; u3 < t3.length - 1; ++u3) s2 += this.strides[u3] * t3[u3];
        return this.values[s2];
      }, t2.prototype.locToIndex = function(t3) {
        if (0 === this.rank) return 0;
        if (1 === this.rank) return t3[0];
        for (var e2 = t3[t3.length - 1], n2 = 0; n2 < t3.length - 1; ++n2) e2 += this.strides[n2] * t3[n2];
        return e2;
      }, t2.prototype.indexToLoc = function(t3) {
        if (0 === this.rank) return [];
        if (1 === this.rank) return [t3];
        for (var e2 = new Array(this.shape.length), n2 = 0; n2 < e2.length - 1; ++n2) e2[n2] = Math.floor(t3 / this.strides[n2]), t3 -= e2[n2] * this.strides[n2];
        return e2[e2.length - 1] = t3, e2;
      }, Object.defineProperty(t2.prototype, "rank", { get: function() {
        return this.shape.length;
      }, enumerable: true, configurable: true }), t2.prototype.toTensor = function() {
        return yt().makeTensor(this.values, this.shape, this.dtype);
      }, t2;
    }();
    yt = null;
    xt = null;
    bt = null;
    wt = function() {
      function t2(t3, e2, n2, r2) {
        this.kept = false, this.isDisposedInternal = false, this.shape = t3.slice(), this.dtype = e2 || "float32", this.size = k(t3), this.strides = $(t3), this.dataId = n2, this.id = r2, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
      }
      return t2.prototype.flatten = function() {
        return this.throwIfDisposed(), this.as1D();
      }, t2.prototype.asScalar = function() {
        return this.throwIfDisposed(), C(1 === this.size, function() {
          return "The array must have only 1 element.";
        }), this.reshape([]);
      }, t2.prototype.as1D = function() {
        return this.throwIfDisposed(), this.reshape([this.size]);
      }, t2.prototype.as2D = function(t3, e2) {
        return this.throwIfDisposed(), this.reshape([t3, e2]);
      }, t2.prototype.as3D = function(t3, e2, n2) {
        return this.throwIfDisposed(), this.reshape([t3, e2, n2]);
      }, t2.prototype.as4D = function(t3, e2, n2, r2) {
        return this.throwIfDisposed(), this.reshape([t3, e2, n2, r2]);
      }, t2.prototype.as5D = function(t3, e2, n2, r2, o2) {
        return this.throwIfDisposed(), this.reshape([t3, e2, n2, r2, o2]);
      }, t2.prototype.asType = function(t3) {
        return this.throwIfDisposed(), xt.cast(this, t3);
      }, Object.defineProperty(t2.prototype, "rank", { get: function() {
        return this.shape.length;
      }, enumerable: true, configurable: true }), t2.prototype.buffer = function() {
        return n(this, void 0, void 0, function() {
          var t3;
          return r(this, function(e2) {
            switch (e2.label) {
              case 0:
                return [4, this.data()];
              case 1:
                return t3 = e2.sent(), [2, xt.buffer(this.shape, this.dtype, t3)];
            }
          });
        });
      }, t2.prototype.bufferSync = function() {
        return xt.buffer(this.shape, this.dtype, this.dataSync());
      }, t2.prototype.array = function() {
        return n(this, void 0, void 0, function() {
          var t3;
          return r(this, function(e2) {
            switch (e2.label) {
              case 0:
                return [4, this.data()];
              case 1:
                return t3 = e2.sent(), [2, J(this.shape, t3)];
            }
          });
        });
      }, t2.prototype.arraySync = function() {
        return J(this.shape, this.dataSync());
      }, t2.prototype.data = function() {
        return n(this, void 0, void 0, function() {
          var t3, e2;
          return r(this, function(n2) {
            switch (n2.label) {
              case 0:
                return this.throwIfDisposed(), t3 = yt().read(this.dataId), "string" !== this.dtype ? [3, 2] : [4, t3];
              case 1:
                e2 = n2.sent();
                try {
                  return [2, e2.map(function(t4) {
                    return ot(t4);
                  })];
                } catch (t4) {
                  throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
                }
                n2.label = 2;
              case 2:
                return [2, t3];
            }
          });
        });
      }, t2.prototype.dataSync = function() {
        this.throwIfDisposed();
        var t3 = yt().readSync(this.dataId);
        if ("string" === this.dtype) try {
          return t3.map(function(t4) {
            return ot(t4);
          });
        } catch (t4) {
          throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
        }
        return t3;
      }, t2.prototype.bytes = function() {
        return n(this, void 0, void 0, function() {
          var t3;
          return r(this, function(e2) {
            switch (e2.label) {
              case 0:
                return this.throwIfDisposed(), [4, yt().read(this.dataId)];
              case 1:
                return t3 = e2.sent(), "string" === this.dtype ? [2, t3] : [2, new Uint8Array(t3.buffer)];
            }
          });
        });
      }, t2.prototype.dispose = function() {
        this.isDisposed || (yt().disposeTensor(this), this.isDisposedInternal = true);
      }, Object.defineProperty(t2.prototype, "isDisposed", { get: function() {
        return this.isDisposedInternal;
      }, enumerable: true, configurable: true }), t2.prototype.throwIfDisposed = function() {
        if (this.isDisposed) throw new Error("Tensor is disposed.");
      }, t2.prototype.toFloat = function() {
        return this.asType("float32");
      }, t2.prototype.toInt = function() {
        return this.asType("int32");
      }, t2.prototype.toBool = function() {
        return this.asType("bool");
      }, t2.prototype.print = function(t3) {
        return void 0 === t3 && (t3 = false), xt.print(this, t3);
      }, t2.prototype.reshape = function(t3) {
        return this.throwIfDisposed(), xt.reshape(this, t3);
      }, t2.prototype.reshapeAs = function(t3) {
        return this.throwIfDisposed(), this.reshape(t3.shape);
      }, t2.prototype.expandDims = function(t3) {
        return void 0 === t3 && (t3 = 0), xt.expandDims(this, t3);
      }, t2.prototype.cumsum = function(t3, e2, n2) {
        return void 0 === t3 && (t3 = 0), void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = false), xt.cumsum(this, t3, e2, n2);
      }, t2.prototype.squeeze = function(t3) {
        return this.throwIfDisposed(), xt.squeeze(this, t3);
      }, t2.prototype.clone = function() {
        return this.throwIfDisposed(), xt.clone(this);
      }, t2.prototype.oneHot = function(t3, e2, n2) {
        return this.throwIfDisposed(), xt.oneHot(this, t3, e2, n2);
      }, t2.prototype.toString = function(t3) {
        return void 0 === t3 && (t3 = false), dt(this.dataSync(), this.shape, this.dtype, t3);
      }, t2.prototype.tile = function(t3) {
        return this.throwIfDisposed(), xt.tile(this, t3);
      }, t2.prototype.gather = function(t3, e2) {
        return void 0 === e2 && (e2 = 0), this.throwIfDisposed(), xt.gather(this, t3, e2);
      }, t2.prototype.matMul = function(t3, e2, n2) {
        return void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = false), this.throwIfDisposed(), xt.matMul(this, t3, e2, n2);
      }, t2.prototype.dot = function(t3) {
        return this.throwIfDisposed(), xt.dot(this, t3);
      }, t2.prototype.norm = function(t3, e2, n2) {
        return void 0 === t3 && (t3 = "euclidean"), void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false), this.throwIfDisposed(), xt.norm(this, t3, e2, n2);
      }, t2.prototype.slice = function(t3, e2) {
        return this.throwIfDisposed(), xt.slice(this, t3, e2);
      }, t2.prototype.reverse = function(t3) {
        return this.throwIfDisposed(), xt.reverse(this, t3);
      }, t2.prototype.concat = function(e2, n2) {
        return void 0 === n2 && (n2 = 0), this.throwIfDisposed(), e2 instanceof t2 && (e2 = [e2]), xt.concat([this].concat(e2), n2);
      }, t2.prototype.split = function(t3, e2) {
        return void 0 === e2 && (e2 = 0), this.throwIfDisposed(), xt.split(this, t3, e2);
      }, t2.prototype.stack = function(t3, e2) {
        return void 0 === e2 && (e2 = 0), xt.stack([this, t3], e2);
      }, t2.prototype.unstack = function(t3) {
        return void 0 === t3 && (t3 = 0), xt.unstack(this, t3);
      }, t2.prototype.pad = function(t3, e2) {
        return void 0 === e2 && (e2 = 0), xt.pad(this, t3, e2);
      }, t2.prototype.batchNormalization = function(t3, e2, n2, r2, o2) {
        return void 0 === n2 && (n2 = 1e-3), bt("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"), this.batchNorm(t3, e2, o2, r2, n2);
      }, t2.prototype.batchNorm = function(t3, e2, n2, r2, o2) {
        return void 0 === o2 && (o2 = 1e-3), this.throwIfDisposed(), xt.batchNorm(this, t3, e2, n2, r2, o2);
      }, t2.prototype.all = function(t3, e2) {
        return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), xt.all(this, t3, e2);
      }, t2.prototype.any = function(t3, e2) {
        return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), xt.any(this, t3, e2);
      }, t2.prototype.logSumExp = function(t3, e2) {
        return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), xt.logSumExp(this, t3, e2);
      }, t2.prototype.sum = function(t3, e2) {
        return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), xt.sum(this, t3, e2);
      }, t2.prototype.prod = function(t3, e2) {
        return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), xt.prod(this, t3, e2);
      }, t2.prototype.mean = function(t3, e2) {
        return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), xt.mean(this, t3, e2);
      }, t2.prototype.min = function(t3, e2) {
        return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), xt.min(this, t3, e2);
      }, t2.prototype.max = function(t3, e2) {
        return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), xt.max(this, t3, e2);
      }, t2.prototype.argMin = function(t3) {
        return void 0 === t3 && (t3 = null), this.throwIfDisposed(), xt.argMin(this, t3);
      }, t2.prototype.argMax = function(t3) {
        return void 0 === t3 && (t3 = null), this.throwIfDisposed(), xt.argMax(this, t3);
      }, t2.prototype.cast = function(t3) {
        return this.throwIfDisposed(), xt.cast(this, t3);
      }, t2.prototype.add = function(t3) {
        return this.throwIfDisposed(), xt.add(this, t3);
      }, t2.prototype.addStrict = function(t3) {
        return this.throwIfDisposed(), xt.addStrict(this, t3);
      }, t2.prototype.atan2 = function(t3) {
        return this.throwIfDisposed(), xt.atan2(this, t3);
      }, t2.prototype.sub = function(t3) {
        return this.throwIfDisposed(), xt.sub(this, t3);
      }, t2.prototype.subStrict = function(t3) {
        return this.throwIfDisposed(), xt.subStrict(this, t3);
      }, t2.prototype.pow = function(t3) {
        return this.throwIfDisposed(), xt.pow(this, t3);
      }, t2.prototype.powStrict = function(t3) {
        return this.throwIfDisposed(), xt.powStrict(this, t3);
      }, t2.prototype.mul = function(t3) {
        return this.throwIfDisposed(), xt.mul(this, t3);
      }, t2.prototype.mulStrict = function(t3) {
        return this.throwIfDisposed(), xt.mulStrict(this, t3);
      }, t2.prototype.div = function(t3) {
        return this.throwIfDisposed(), xt.div(this, t3);
      }, t2.prototype.divNoNan = function(t3) {
        return this.throwIfDisposed(), xt.divNoNan(this, t3);
      }, t2.prototype.floorDiv = function(t3) {
        return this.throwIfDisposed(), xt.floorDiv(this, t3);
      }, t2.prototype.divStrict = function(t3) {
        return this.throwIfDisposed(), xt.divStrict(this, t3);
      }, t2.prototype.minimum = function(t3) {
        return this.throwIfDisposed(), xt.minimum(this, t3);
      }, t2.prototype.minimumStrict = function(t3) {
        return this.throwIfDisposed(), xt.minimumStrict(this, t3);
      }, t2.prototype.maximum = function(t3) {
        return this.throwIfDisposed(), xt.maximum(this, t3);
      }, t2.prototype.maximumStrict = function(t3) {
        return this.throwIfDisposed(), xt.maximumStrict(this, t3);
      }, t2.prototype.mod = function(t3) {
        return this.throwIfDisposed(), xt.mod(this, t3);
      }, t2.prototype.modStrict = function(t3) {
        return this.throwIfDisposed(), xt.modStrict(this, t3);
      }, t2.prototype.squaredDifferenceStrict = function(t3) {
        return this.throwIfDisposed(), xt.squaredDifferenceStrict(this, t3);
      }, t2.prototype.transpose = function(t3) {
        return this.throwIfDisposed(), xt.transpose(this, t3);
      }, t2.prototype.notEqual = function(t3) {
        return this.throwIfDisposed(), xt.notEqual(this, t3);
      }, t2.prototype.notEqualStrict = function(t3) {
        return this.throwIfDisposed(), xt.notEqualStrict(this, t3);
      }, t2.prototype.less = function(t3) {
        return this.throwIfDisposed(), xt.less(this, t3);
      }, t2.prototype.lessStrict = function(t3) {
        return this.throwIfDisposed(), xt.lessStrict(this, t3);
      }, t2.prototype.equal = function(t3) {
        return this.throwIfDisposed(), xt.equal(this, t3);
      }, t2.prototype.equalStrict = function(t3) {
        return this.throwIfDisposed(), xt.equalStrict(this, t3);
      }, t2.prototype.lessEqual = function(t3) {
        return this.throwIfDisposed(), xt.lessEqual(this, t3);
      }, t2.prototype.lessEqualStrict = function(t3) {
        return this.throwIfDisposed(), xt.lessEqualStrict(this, t3);
      }, t2.prototype.greater = function(t3) {
        return this.throwIfDisposed(), xt.greater(this, t3);
      }, t2.prototype.greaterStrict = function(t3) {
        return this.throwIfDisposed(), xt.greaterStrict(this, t3);
      }, t2.prototype.greaterEqual = function(t3) {
        return this.throwIfDisposed(), xt.greaterEqual(this, t3);
      }, t2.prototype.greaterEqualStrict = function(t3) {
        return this.throwIfDisposed(), xt.greaterEqualStrict(this, t3);
      }, t2.prototype.logicalAnd = function(t3) {
        return this.throwIfDisposed(), xt.logicalAnd(this, t3);
      }, t2.prototype.logicalOr = function(t3) {
        return this.throwIfDisposed(), xt.logicalOr(this, t3);
      }, t2.prototype.logicalNot = function() {
        return this.throwIfDisposed(), xt.logicalNot(this);
      }, t2.prototype.logicalXor = function(t3) {
        return this.throwIfDisposed(), xt.logicalXor(this, t3);
      }, t2.prototype.where = function(t3, e2) {
        return this.throwIfDisposed(), xt.where(t3, this, e2);
      }, t2.prototype.neg = function() {
        return this.throwIfDisposed(), xt.neg(this);
      }, t2.prototype.ceil = function() {
        return this.throwIfDisposed(), xt.ceil(this);
      }, t2.prototype.floor = function() {
        return this.throwIfDisposed(), xt.floor(this);
      }, t2.prototype.sign = function() {
        return this.throwIfDisposed(), xt.sign(this);
      }, t2.prototype.isNaN = function() {
        return this.throwIfDisposed(), xt.isNaN(this);
      }, t2.prototype.isInf = function() {
        return this.throwIfDisposed(), xt.isInf(this);
      }, t2.prototype.isFinite = function() {
        return this.throwIfDisposed(), xt.isFinite(this);
      }, t2.prototype.exp = function() {
        return this.throwIfDisposed(), xt.exp(this);
      }, t2.prototype.expm1 = function() {
        return this.throwIfDisposed(), xt.expm1(this);
      }, t2.prototype.log = function() {
        return this.throwIfDisposed(), xt.log(this);
      }, t2.prototype.log1p = function() {
        return this.throwIfDisposed(), xt.log1p(this);
      }, t2.prototype.sqrt = function() {
        return this.throwIfDisposed(), xt.sqrt(this);
      }, t2.prototype.rsqrt = function() {
        return this.throwIfDisposed(), xt.rsqrt(this);
      }, t2.prototype.square = function() {
        return this.throwIfDisposed(), xt.square(this);
      }, t2.prototype.reciprocal = function() {
        return this.throwIfDisposed(), xt.reciprocal(this);
      }, t2.prototype.abs = function() {
        return this.throwIfDisposed(), xt.abs(this);
      }, t2.prototype.clipByValue = function(t3, e2) {
        return this.throwIfDisposed(), xt.clipByValue(this, t3, e2);
      }, t2.prototype.relu = function() {
        return this.throwIfDisposed(), xt.relu(this);
      }, t2.prototype.relu6 = function() {
        return this.throwIfDisposed(), xt.relu6(this);
      }, t2.prototype.elu = function() {
        return this.throwIfDisposed(), xt.elu(this);
      }, t2.prototype.selu = function() {
        return this.throwIfDisposed(), xt.selu(this);
      }, t2.prototype.leakyRelu = function(t3) {
        return void 0 === t3 && (t3 = 0.2), this.throwIfDisposed(), xt.leakyRelu(this, t3);
      }, t2.prototype.prelu = function(t3) {
        return this.throwIfDisposed(), xt.prelu(this, t3);
      }, t2.prototype.sigmoid = function() {
        return this.throwIfDisposed(), xt.sigmoid(this);
      }, t2.prototype.logSigmoid = function() {
        return this.throwIfDisposed(), xt.logSigmoid(this);
      }, t2.prototype.softplus = function() {
        return this.throwIfDisposed(), xt.softplus(this);
      }, t2.prototype.zerosLike = function() {
        return this.throwIfDisposed(), xt.zerosLike(this);
      }, t2.prototype.onesLike = function() {
        return this.throwIfDisposed(), xt.onesLike(this);
      }, t2.prototype.sin = function() {
        return this.throwIfDisposed(), xt.sin(this);
      }, t2.prototype.cos = function() {
        return this.throwIfDisposed(), xt.cos(this);
      }, t2.prototype.tan = function() {
        return this.throwIfDisposed(), xt.tan(this);
      }, t2.prototype.asin = function() {
        return this.throwIfDisposed(), xt.asin(this);
      }, t2.prototype.acos = function() {
        return this.throwIfDisposed(), xt.acos(this);
      }, t2.prototype.atan = function() {
        return this.throwIfDisposed(), xt.atan(this);
      }, t2.prototype.sinh = function() {
        return this.throwIfDisposed(), xt.sinh(this);
      }, t2.prototype.cosh = function() {
        return this.throwIfDisposed(), xt.cosh(this);
      }, t2.prototype.tanh = function() {
        return this.throwIfDisposed(), xt.tanh(this);
      }, t2.prototype.asinh = function() {
        return this.throwIfDisposed(), xt.asinh(this);
      }, t2.prototype.acosh = function() {
        return this.throwIfDisposed(), xt.acosh(this);
      }, t2.prototype.atanh = function() {
        return this.throwIfDisposed(), xt.atanh(this);
      }, t2.prototype.erf = function() {
        return this.throwIfDisposed(), xt.erf(this);
      }, t2.prototype.round = function() {
        return this.throwIfDisposed(), xt.round(this);
      }, t2.prototype.step = function(t3) {
        return void 0 === t3 && (t3 = 0), this.throwIfDisposed(), xt.step(this, t3);
      }, t2.prototype.softmax = function(t3) {
        return void 0 === t3 && (t3 = -1), this.throwIfDisposed(), xt.softmax(this, t3);
      }, t2.prototype.logSoftmax = function(t3) {
        return void 0 === t3 && (t3 = -1), this.throwIfDisposed(), xt.logSoftmax(this, t3);
      }, t2.prototype.resizeBilinear = function(t3, e2) {
        return void 0 === e2 && (e2 = false), this.throwIfDisposed(), xt.image.resizeBilinear(this, t3, e2);
      }, t2.prototype.resizeNearestNeighbor = function(t3, e2) {
        return void 0 === e2 && (e2 = false), this.throwIfDisposed(), xt.image.resizeNearestNeighbor(this, t3, e2);
      }, t2.prototype.conv1d = function(t3, e2, n2, r2, o2, a2) {
        return void 0 === r2 && (r2 = "NWC"), void 0 === o2 && (o2 = 1), this.throwIfDisposed(), xt.conv1d(this, t3, e2, n2, r2, o2, a2);
      }, t2.prototype.conv2d = function(t3, e2, n2, r2, o2, a2) {
        return void 0 === r2 && (r2 = "NHWC"), void 0 === o2 && (o2 = [1, 1]), this.throwIfDisposed(), xt.conv2d(this, t3, e2, n2, r2, o2, a2);
      }, t2.prototype.conv2dTranspose = function(t3, e2, n2, r2, o2) {
        return this.throwIfDisposed(), xt.conv2dTranspose(this, t3, e2, n2, r2, o2);
      }, t2.prototype.depthwiseConv2D = function(t3, e2, n2, r2, o2, a2) {
        return void 0 === r2 && (r2 = "NHWC"), void 0 === o2 && (o2 = [1, 1]), this.throwIfDisposed(), xt.depthwiseConv2d(this, t3, e2, n2, r2, o2, a2);
      }, t2.prototype.separableConv2d = function(t3, e2, n2, r2, o2, a2) {
        return void 0 === o2 && (o2 = [1, 1]), void 0 === a2 && (a2 = "NHWC"), this.throwIfDisposed(), xt.separableConv2d(this, t3, e2, n2, r2, o2, a2);
      }, t2.prototype.avgPool = function(t3, e2, n2, r2) {
        return this.throwIfDisposed(), xt.avgPool(this, t3, e2, n2, r2);
      }, t2.prototype.maxPool = function(t3, e2, n2, r2) {
        return this.throwIfDisposed(), xt.maxPool(this, t3, e2, n2, r2);
      }, t2.prototype.localResponseNormalization = function(t3, e2, n2, r2) {
        return void 0 === t3 && (t3 = 5), void 0 === e2 && (e2 = 1), void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = 0.5), xt.localResponseNormalization(this, t3, e2, n2, r2);
      }, t2.prototype.pool = function(t3, e2, n2, r2, o2) {
        return this.throwIfDisposed(), xt.pool(this, t3, e2, n2, r2, o2);
      }, t2.prototype.variable = function(t3, e2, n2) {
        return void 0 === t3 && (t3 = true), this.throwIfDisposed(), yt().makeVariable(this, t3, e2, n2);
      }, t2.prototype.unsortedSegmentSum = function(t3, e2) {
        return this.throwIfDisposed(), xt.unsortedSegmentSum(this, t3, e2);
      }, t2.prototype.batchToSpaceND = function(t3, e2) {
        return this.throwIfDisposed(), xt.batchToSpaceND(this, t3, e2);
      }, t2.prototype.spaceToBatchND = function(t3, e2) {
        return this.throwIfDisposed(), xt.spaceToBatchND(this, t3, e2);
      }, t2.prototype.topk = function(t3, e2) {
        return void 0 === t3 && (t3 = 1), void 0 === e2 && (e2 = true), this.throwIfDisposed(), xt.topk(this, t3, e2);
      }, t2.prototype.stridedSlice = function(t3, e2, n2, r2, o2, a2, i2, s2) {
        return void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = 0), void 0 === a2 && (a2 = 0), void 0 === i2 && (i2 = 0), void 0 === s2 && (s2 = 0), this.throwIfDisposed(), xt.stridedSlice(this, t3, e2, n2, r2, o2, a2, i2, s2);
      }, t2.prototype.depthToSpace = function(t3, e2) {
        return this.throwIfDisposed(), xt.depthToSpace(this, t3, e2);
      }, t2.prototype.fft = function() {
        return this.throwIfDisposed(), xt.spectral.fft(this);
      }, t2.prototype.ifft = function() {
        return this.throwIfDisposed(), xt.spectral.ifft(this);
      }, t2.prototype.rfft = function() {
        return this.throwIfDisposed(), xt.spectral.rfft(this);
      }, t2.prototype.irfft = function() {
        return this.throwIfDisposed(), xt.spectral.irfft(this);
      }, t2;
    }();
    Object.defineProperty(wt, Symbol.hasInstance, { value: function(t2) {
      return !!t2 && null != t2.dataId && null != t2.shape && null != t2.dtype;
    } });
    St = function(t2) {
      function n2(e2, n3, r2, o2) {
        var a2 = t2.call(this, e2.shape, e2.dtype, e2.dataId, o2) || this;
        return a2.trainable = n3, a2.name = r2, a2;
      }
      return e(n2, t2), n2.prototype.assign = function(t3) {
        if (t3.dtype !== this.dtype) throw new Error("dtype of the new value (" + t3.dtype + ") and previous value (" + this.dtype + ") must match");
        if (!S(t3.shape, this.shape)) throw new Error("shape of the new value (" + t3.shape + ") and previous value (" + this.shape + ") must match");
        yt().disposeTensor(this), this.dataId = t3.dataId, yt().incRef(this, null);
      }, n2.prototype.dispose = function() {
        yt().disposeVariable(this), this.isDisposedInternal = true;
      }, n2;
    }(wt);
    Object.defineProperty(St, Symbol.hasInstance, { value: function(t2) {
      return t2 instanceof wt && null != t2.assign && t2.assign instanceof Function;
    } }), function(t2) {
      t2.R0 = "R0", t2.R1 = "R1", t2.R2 = "R2", t2.R3 = "R3", t2.R4 = "R4", t2.R5 = "R5", t2.R6 = "R6";
    }(Ct || (Ct = {})), function(t2) {
      t2.float32 = "float32", t2.int32 = "int32", t2.bool = "int32", t2.complex64 = "complex64";
    }(Et || (Et = {})), function(t2) {
      t2.float32 = "float32", t2.int32 = "int32", t2.bool = "bool", t2.complex64 = "complex64";
    }(Rt || (Rt = {})), function(t2) {
      t2.float32 = "float32", t2.int32 = "float32", t2.bool = "float32", t2.complex64 = "complex64";
    }(It || (It = {})), function(t2) {
      t2.float32 = "complex64", t2.int32 = "complex64", t2.bool = "complex64", t2.complex64 = "complex64";
    }(kt || (kt = {}));
    At = { float32: It, int32: Et, bool: Rt, complex64: kt };
    Mt = Object.freeze({ makeTypesMatch: Nt, assertTypesMatch: Ft, isTensorInList: function(t2, e2) {
      return e2.some(function(e3) {
        return e3.id === t2.id;
      });
    }, getTensorsInContainer: _t });
    Bt = function() {
      function t2() {
        this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = /* @__PURE__ */ new WeakMap(), this.profiling = false, this.activeProfile = { newBytes: 0, newTensors: 0, peakBytes: 0, kernels: [], result: null };
      }
      return t2.prototype.dispose = function() {
        for (var t3 in this.registeredVariables) this.registeredVariables[t3].dispose();
      }, t2;
    }();
    Pt = function() {
      function t2(t3) {
        this.ENV = t3, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new Bt();
      }
      return t2.prototype.ready = function() {
        return n(this, void 0, void 0, function() {
          var t3, e2, n2;
          return r(this, function(r2) {
            switch (r2.label) {
              case 0:
                if (null != this.pendingBackendInit) return [2, this.pendingBackendInit.then(function() {
                })];
                if (null != this.backendInstance) return [2];
                t3 = this.getSortedBackends(), e2 = 0, r2.label = 1;
              case 1:
                return e2 < t3.length ? (n2 = t3[e2], [4, this.initializeBackend(n2).success]) : [3, 5];
              case 2:
                return r2.sent() ? [4, this.setBackend(n2)] : [3, 4];
              case 3:
                return r2.sent(), [2];
              case 4:
                return e2++, [3, 1];
              case 5:
                throw new Error("Could not initialize any backends, all backend initializations failed.");
            }
          });
        });
      }, Object.defineProperty(t2.prototype, "backend", { get: function() {
        if (null != this.pendingBackendInit) throw new Error("Backend '" + this.backendName + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
        if (null == this.backendInstance) {
          var t3 = this.initializeBackendsAndReturnBest(), e2 = t3.name;
          if (t3.asyncInit) throw new Error("The highest priority backend '" + e2 + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
          this.setBackend(e2);
        }
        return this.backendInstance;
      }, enumerable: true, configurable: true }), t2.prototype.backendNames = function() {
        return Object.keys(this.registryFactory);
      }, t2.prototype.findBackend = function(t3) {
        if (!(t3 in this.registry)) {
          if (!(t3 in this.registryFactory)) return null;
          if (this.initializeBackend(t3).asyncInit) return null;
        }
        return this.registry[t3];
      }, t2.prototype.findBackendFactory = function(t3) {
        return t3 in this.registryFactory ? this.registryFactory[t3].factory : null;
      }, t2.prototype.registerBackend = function(t3, e2, n2) {
        return void 0 === n2 && (n2 = 1), t3 in this.registryFactory ? (console.warn(t3 + " backend was already registered. Reusing existing backend factory."), false) : (this.registryFactory[t3] = { factory: e2, priority: n2 }, true);
      }, t2.prototype.setBackend = function(t3) {
        return n(this, void 0, void 0, function() {
          var e2, n2, o2;
          return r(this, function(r2) {
            switch (r2.label) {
              case 0:
                if (null == this.registryFactory[t3]) throw new Error("Backend name '" + t3 + "' not found in registry");
                return this.backendName = t3, null != this.registry[t3] ? [3, 4] : (this.backendInstance = null, e2 = this.initializeBackend(t3), n2 = e2.success, e2.asyncInit ? [4, n2] : [3, 2]);
              case 1:
                return o2 = r2.sent(), [3, 3];
              case 2:
                o2 = n2, r2.label = 3;
              case 3:
                if (!o2) return [2, false];
                r2.label = 4;
              case 4:
                return this.backendInstance = this.registry[t3], this.setupRegisteredKernels(), this.profiler = new ut(this.backendInstance), [2, true];
            }
          });
        });
      }, t2.prototype.setupRegisteredKernels = function() {
        var t3 = this;
        f(this.backendName).forEach(function(e2) {
          null != e2.setupFunc && e2.setupFunc(t3.backendInstance);
        });
      }, t2.prototype.disposeRegisteredKernels = function(t3) {
        var e2 = this;
        f(t3).forEach(function(n2) {
          null != n2.disposeFunc && n2.disposeFunc(e2.registry[t3]);
        });
      }, t2.prototype.initializeBackend = function(t3) {
        var e2 = this, n2 = this.registryFactory[t3];
        if (null == n2) throw new Error("Cannot initialize backend " + t3 + ", no registration found.");
        try {
          var r2 = n2.factory();
          if (Promise.resolve(r2) === r2) {
            var o2 = ++this.pendingBackendInitId, a2 = r2.then(function(n3) {
              return !(o2 < e2.pendingBackendInitId) && (e2.registry[t3] = n3, e2.pendingBackendInit = null, true);
            }).catch(function(n3) {
              return !(o2 < e2.pendingBackendInitId) && (e2.pendingBackendInit = null, console.warn("Initialization of backend " + t3 + " failed"), console.warn(n3.stack || n3.message), false);
            });
            return this.pendingBackendInit = a2, { success: a2, asyncInit: true };
          }
          return this.registry[t3] = r2, { success: true, asyncInit: false };
        } catch (e3) {
          return console.warn("Initialization of backend " + t3 + " failed"), console.warn(e3.stack || e3.message), { success: false, asyncInit: false };
        }
      }, t2.prototype.removeBackend = function(t3) {
        if (!(t3 in this.registryFactory)) throw new Error(t3 + " backend not found in registry");
        this.backendName === t3 && null != this.pendingBackendInit && this.pendingBackendInitId++, t3 in this.registry && (this.disposeRegisteredKernels(t3), this.registry[t3].dispose(), delete this.registry[t3]), delete this.registryFactory[t3], this.backendName === t3 && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
      }, t2.prototype.getSortedBackends = function() {
        var t3 = this;
        if (0 === Object.keys(this.registryFactory).length) throw new Error("No backend found in registry.");
        return Object.keys(this.registryFactory).sort(function(e2, n2) {
          return t3.registryFactory[n2].priority - t3.registryFactory[e2].priority;
        });
      }, t2.prototype.initializeBackendsAndReturnBest = function() {
        for (var t3 = this.getSortedBackends(), e2 = 0; e2 < t3.length; e2++) {
          var n2 = t3[e2], r2 = this.initializeBackend(n2), o2 = r2.success, a2 = r2.asyncInit;
          if (a2 || o2) return { name: n2, asyncInit: a2 };
        }
        throw new Error("Could not initialize any backends, all backend initializations failed.");
      }, t2.prototype.moveData = function(t3, e2) {
        var n2 = this.state.tensorInfo.get(e2), r2 = n2.backend, o2 = this.readSync(e2);
        r2.disposeData(e2), n2.backend = t3, t3.move(e2, o2, n2.shape, n2.dtype), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
      }, t2.prototype.tidy = function(t3, e2) {
        var n2, r2 = this, o2 = null;
        if (null == e2) {
          if ("function" != typeof t3) throw new Error("Please provide a function to tidy()");
          e2 = t3;
        } else {
          if ("string" != typeof t3 && !(t3 instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
          if ("function" != typeof e2) throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
          o2 = t3;
        }
        return this.scopedRun(function() {
          return r2.startScope(o2);
        }, function() {
          return r2.endScope(n2);
        }, function() {
          return (n2 = e2()) instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n2;
        });
      }, t2.prototype.scopedRun = function(t3, e2, n2) {
        t3();
        try {
          var r2 = n2();
          return e2(), r2;
        } catch (t4) {
          throw e2(), t4;
        }
      }, t2.prototype.nextTensorId = function() {
        return t2.nextTensorId++;
      }, t2.prototype.nextVariableId = function() {
        return t2.nextVariableId++;
      }, t2.prototype.clone = function(t3) {
        var e2 = this.makeTensorFromDataId(t3.dataId, t3.shape, t3.dtype), n2 = { x: t3 };
        return this.addTapeNode(this.state.activeScope.name, n2, [e2], function(t4) {
          return { x: function() {
            return t4.toFloat();
          } };
        }, []), e2;
      }, t2.prototype.runKernel = function(t3, e2, n2, r2, o2) {
        return this.runKernelFunc(null, e2, null, t3, n2, r2, o2);
      }, t2.prototype.shouldCheckForMemLeaks = function() {
        return this.ENV.getBool("IS_TEST");
      }, t2.prototype.checkKernelForMemLeak = function(t3, e2, n2) {
        var r2 = this.backend.numDataIds(), o2 = 0;
        n2.forEach(function(t4) {
          o2 += "complex64" === t4.dtype ? 3 : 1;
        });
        var a2 = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1], i2 = r2 - e2 - o2 - a2;
        if (i2 > 0) throw new Error("Backend '" + this.backendName + "' has an internal memory leak (" + i2 + " data ids) after running '" + t3 + "'");
      }, t2.prototype.runKernelFunc = function(t3, e2, n2, r2, o2, a2, i2) {
        var s2, u3 = this;
        void 0 === a2 && (a2 = []), void 0 === i2 && (i2 = []);
        var c2 = [], h2 = this.isTapeOn();
        null == r2 && (r2 = null != this.state.activeScope ? this.state.activeScope.name : "");
        var f2, d2 = function(t4) {
          h2 && (c2 = t4.map(function(t5) {
            return u3.keep(u3.clone(t5));
          }));
        }, p2 = this.state.numBytes, v = this.state.numTensors;
        this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
        var m, g2 = l(r2, this.backendName);
        return f2 = null != g2 ? function() {
          var t4 = u3.backend.numDataIds();
          m = g2.kernelFunc({ inputs: e2, attrs: o2, backend: u3.backend });
          var n3 = Array.isArray(m) ? m : [m];
          u3.shouldCheckForMemLeaks() && u3.checkKernelForMemLeak(r2, t4, n3);
          var s3 = n3.map(function(t5) {
            var e3 = t5.dataId, n4 = t5.shape, r3 = t5.dtype;
            return u3.makeTensorFromDataId(e3, n4, r3);
          }), c3 = s3.filter(function(t5, e3) {
            return i2[e3];
          });
          return d2((a2 || []).slice().concat(c3)), s3;
        } : function() {
          var e3 = u3.backend.numDataIds();
          m = u3.tidy(function() {
            return t3(u3.backend, d2);
          });
          var n3 = Array.isArray(m) ? m : [m];
          return u3.shouldCheckForMemLeaks() && u3.checkKernelForMemLeak(r2, e3, n3), n3;
        }, this.scopedRun(function() {
          return u3.state.kernelDepth++;
        }, function() {
          return u3.state.kernelDepth--;
        }, function() {
          s2 = u3.ENV.getBool("DEBUG") ? u3.profiler.profileKernel(r2, e2, function() {
            return f2();
          }) : f2();
        }), h2 && this.addTapeNode(r2, e2, s2, n2, c2), this.state.profiling && this.state.activeProfile.kernels.push({ name: r2, bytesAdded: this.state.numBytes - p2, totalBytesSnapshot: this.state.numBytes, tensorsAdded: this.state.numTensors - v, totalTensorsSnapshot: this.state.numTensors, inputShapes: Object.keys(e2).map(function(t4) {
          return e2[t4].shape;
        }), outputShapes: s2.map(function(t4) {
          return t4.shape;
        }) }), Array.isArray(m) ? s2 : s2[0];
      }, t2.prototype.makeTensor = function(t3, e2, n2, r2) {
        if (null == t3) throw new Error("Values passed to engine.makeTensor() are null");
        n2 = n2 || "float32", r2 = r2 || this.backend;
        var o2 = t3;
        "string" === n2 && H(t3[0]) && (o2 = t3.map(function(t4) {
          return rt(t4);
        }));
        var a2 = r2.write(o2, e2, n2), i2 = new wt(e2, n2, a2, this.nextTensorId());
        if (this.incRef(i2, r2), "string" === n2) {
          var s2 = this.state.tensorInfo.get(a2), u3 = G(o2);
          this.state.numBytes += u3 - s2.bytes, s2.bytes = u3;
        }
        return i2;
      }, t2.prototype.makeTensorFromDataId = function(t3, e2, n2, r2) {
        var o2 = new wt(e2, n2 = n2 || "float32", t3, this.nextTensorId());
        return this.incRef(o2, r2), o2;
      }, t2.prototype.makeVariable = function(t3, e2, n2, r2) {
        void 0 === e2 && (e2 = true), n2 = n2 || this.nextVariableId().toString(), null != r2 && r2 !== t3.dtype && (t3 = t3.asType(r2));
        var o2 = new St(t3, e2, n2, this.nextTensorId());
        if (null != this.state.registeredVariables[o2.name]) throw new Error("Variable with name " + o2.name + " was already registered");
        return this.state.registeredVariables[o2.name] = o2, this.incRef(o2, this.backend), o2;
      }, t2.prototype.incRef = function(t3, e2) {
        var n2 = this.state.tensorInfo.has(t3.dataId) ? this.state.tensorInfo.get(t3.dataId).refCount : 0;
        if (this.state.numTensors++, "string" === t3.dtype && this.state.numStringTensors++, 0 === n2) {
          this.state.numDataBuffers++;
          var r2 = 0;
          "complex64" !== t3.dtype && "string" !== t3.dtype && (r2 = t3.size * z(t3.dtype)), this.state.tensorInfo.set(t3.dataId, { backend: e2 || this.backend, dtype: t3.dtype, shape: t3.shape, bytes: r2, refCount: 0 }), this.state.numBytes += r2;
        }
        this.state.tensorInfo.get(t3.dataId).refCount++, t3 instanceof St || this.track(t3);
      }, t2.prototype.disposeTensor = function(t3) {
        if (this.state.tensorInfo.has(t3.dataId)) {
          this.state.numTensors--, "string" === t3.dtype && this.state.numStringTensors--;
          var e2 = this.state.tensorInfo.get(t3.dataId);
          e2.refCount <= 1 ? ("complex64" !== t3.dtype && (this.state.numBytes -= e2.bytes), this.state.numDataBuffers--, e2.backend.disposeData(t3.dataId), this.state.tensorInfo.delete(t3.dataId)) : this.state.tensorInfo.get(t3.dataId).refCount--;
        }
      }, t2.prototype.disposeVariables = function() {
        for (var t3 in this.state.registeredVariables) {
          var e2 = this.state.registeredVariables[t3];
          this.disposeVariable(e2);
        }
      }, t2.prototype.disposeVariable = function(t3) {
        this.disposeTensor(t3), null != this.state.registeredVariables[t3.name] && delete this.state.registeredVariables[t3.name];
      }, t2.prototype.memory = function() {
        var t3 = this.backend.memory();
        return t3.numTensors = this.state.numTensors, t3.numDataBuffers = this.state.numDataBuffers, t3.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (t3.unreliable = true, null == t3.reasons && (t3.reasons = []), t3.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), t3;
      }, t2.prototype.profile = function(t3) {
        return n(this, void 0, void 0, function() {
          var e2, n2;
          return r(this, function(r2) {
            return this.state.profiling = true, e2 = this.state.numBytes, n2 = this.state.numTensors, this.state.activeProfile.kernels = [], this.state.activeProfile.result = t3(), this.state.profiling = false, this.state.activeProfile.peakBytes = Math.max.apply(Math, this.state.activeProfile.kernels.map(function(t4) {
              return t4.totalBytesSnapshot;
            })), this.state.activeProfile.newBytes = this.state.numBytes - e2, this.state.activeProfile.newTensors = this.state.numTensors - n2, [2, this.state.activeProfile];
          });
        });
      }, t2.prototype.isTapeOn = function() {
        return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth;
      }, t2.prototype.addTapeNode = function(t3, e2, n2, r2, o2) {
        var a2 = this, i2 = { id: this.state.nextTapeNodeId++, kernelName: t3, inputs: e2, outputs: n2, saved: o2 }, s2 = h(t3);
        null != s2 && (r2 = s2.gradFunc), null != r2 && (i2.gradient = function(t4) {
          return t4 = t4.map(function(t5, e3) {
            if (null == t5) {
              var r3 = n2[e3], o3 = tt(r3.size, r3.dtype);
              return a2.makeTensor(o3, r3.shape, r3.dtype);
            }
            return t5;
          }), r2(t4.length > 1 ? t4 : t4[0], o2);
        }), this.state.activeTape.push(i2);
      }, t2.prototype.keep = function(t3) {
        return t3.kept = true, t3;
      }, t2.prototype.startTape = function() {
        0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++;
      }, t2.prototype.endTape = function() {
        this.state.gradientDepth--;
      }, t2.prototype.startScope = function(t3) {
        var e2 = { track: [], name: "unnamed scope", id: this.state.nextScopeId++ };
        t3 && (e2.name = t3), this.state.scopeStack.push(e2), this.state.activeScope = e2;
      }, t2.prototype.endScope = function(t3) {
        for (var e2 = this, n2 = _t(t3), r2 = new Set(n2.map(function(t4) {
          return t4.id;
        })), o2 = 0; o2 < this.state.activeScope.track.length; o2++) {
          var a2 = this.state.activeScope.track[o2];
          a2.kept || r2.has(a2.id) || a2.dispose();
        }
        var i2 = this.state.scopeStack.pop();
        this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], n2.forEach(function(t4) {
          t4.kept || t4.scopeId !== i2.id || e2.track(t4);
        });
      }, t2.prototype.gradients = function(t3, e2, n2, r2) {
        var o2 = this;
        if (void 0 === r2 && (r2 = false), C(e2.length > 0, function() {
          return "gradients() received an empty list of xs.";
        }), null != n2 && "float32" !== n2.dtype) throw new Error("dy must have 'float32' dtype, but has '" + n2.dtype + "'");
        var a2 = this.scopedRun(function() {
          return o2.startTape();
        }, function() {
          return o2.endTape();
        }, function() {
          return o2.tidy("forward", t3);
        });
        C(a2 instanceof wt, function() {
          return "The result y returned by f() must be a tensor.";
        });
        var i2 = function(t4, e3, n3) {
          for (var r3 = {}, o3 = {}, a3 = 0; a3 < e3.length; a3++) r3[e3[a3].id] = true;
          for (a3 = 0; a3 < t4.length; a3++) {
            var i3 = (p2 = t4[a3]).inputs;
            for (var s2 in i3) {
              for (var u3 = i3[s2], c2 = false, l2 = 0; l2 < e3.length; l2++) if (r3[u3.id]) {
                p2.outputs.forEach(function(t5) {
                  return r3[t5.id] = true;
                }), c2 = true, o3[p2.id] = true;
                break;
              }
              if (c2) break;
            }
          }
          var h2 = {};
          h2[n3.id] = true;
          var f2 = {};
          for (a3 = t4.length - 1; a3 >= 0; a3--) for (i3 = (p2 = t4[a3]).inputs, l2 = 0; l2 < p2.outputs.length; l2++) if (h2[p2.outputs[l2].id]) {
            for (var s2 in i3) h2[i3[s2].id] = true, f2[p2.id] = true;
            break;
          }
          var d2 = [];
          for (a3 = 0; a3 < t4.length; a3++) {
            var p2;
            if (o3[(p2 = t4[a3]).id] && f2[p2.id]) {
              var v = {};
              for (var s2 in p2.inputs) {
                var m = p2.inputs[s2];
                r3[m.id] && (v[s2] = m);
              }
              var g2 = Object.assign({}, p2);
              g2.inputs = v, g2.outputs = p2.outputs, d2.push(g2);
            }
          }
          return d2;
        }(this.state.activeTape, e2, a2);
        if (!r2 && 0 === i2.length && e2.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
        return this.tidy("backward", function() {
          var t4, r3, s2 = {};
          s2[a2.id] = null == n2 ? (t4 = a2.shape, r3 = Z(k(t4), "float32"), Lt.makeTensor(r3, t4, "float32")) : n2, function(t5, e3, n3) {
            for (var r4 = function(r5) {
              var o4 = e3[r5], a3 = [];
              if (o4.outputs.forEach(function(e4) {
                var n4 = t5[e4.id];
                null != n4 ? a3.push(n4) : a3.push(null);
              }), null == o4.gradient) throw new Error("Cannot compute gradient: gradient function not found for " + o4.kernelName + ".");
              var i3 = o4.gradient(a3), s3 = function(e4) {
                if (!(e4 in i3)) throw new Error("Cannot backprop through input " + e4 + ". Available gradients found: " + Object.keys(i3) + ".");
                var r6 = n3(function() {
                  return i3[e4]();
                });
                if ("float32" !== r6.dtype) throw new Error("Error in gradient for op " + o4.kernelName + ". The gradient of input " + e4 + " must have 'float32' dtype, but has '" + r6.dtype + "'");
                var a4 = o4.inputs[e4];
                if (!S(r6.shape, a4.shape)) throw new Error("Error in gradient for op " + o4.kernelName + ". The gradient of input '" + e4 + "' has shape '" + r6.shape + "', which does not match the shape of the input '" + a4.shape + "'");
                if (null == t5[a4.id]) t5[a4.id] = r6;
                else {
                  var s4 = t5[a4.id];
                  t5[a4.id] = s4.add(r6), s4.dispose();
                }
              };
              for (var u4 in o4.inputs) s3(u4);
            }, o3 = e3.length - 1; o3 >= 0; o3--) r4(o3);
          }(s2, i2, function(t5) {
            return o2.tidy(t5);
          });
          var u3 = e2.map(function(t5) {
            return s2[t5.id];
          });
          return 0 === o2.state.gradientDepth && (o2.state.activeTape.forEach(function(t5) {
            for (var e3 = 0, n3 = t5.saved; e3 < n3.length; e3++) {
              n3[e3].dispose();
            }
          }), o2.state.activeTape = null), { value: a2, grads: u3 };
        });
      }, t2.prototype.customGrad = function(t3) {
        var e2 = this;
        return C(X(t3), function() {
          return "The f passed in customGrad(f) must be a function.";
        }), function() {
          for (var n2, r2 = [], o2 = 0; o2 < arguments.length; o2++) r2[o2] = arguments[o2];
          C(r2.every(function(t4) {
            return t4 instanceof wt;
          }), function() {
            return "The args passed in customGrad(f)(x1, x2,...) must all be tensors";
          });
          var a2 = {};
          return r2.forEach(function(t4, e3) {
            a2[e3] = t4;
          }), e2.runKernelFunc(function(e3, o3) {
            return C((n2 = t3.apply(void 0, r2.concat([o3]))).value instanceof wt, function() {
              return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor";
            }), C(X(n2.gradFunc), function() {
              return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.";
            }), n2.value;
          }, a2, function(t4, e3) {
            var o3 = n2.gradFunc(t4, e3), a3 = Array.isArray(o3) ? o3 : [o3];
            C(a3.length === r2.length, function() {
              return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).";
            }), C(a3.every(function(t5) {
              return t5 instanceof wt;
            }), function() {
              return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.";
            });
            var i2 = {};
            return a3.forEach(function(t5, e4) {
              i2[e4] = function() {
                return t5;
              };
            }), i2;
          });
        };
      }, t2.prototype.readSync = function(t3) {
        return this.state.tensorInfo.get(t3).backend.readSync(t3);
      }, t2.prototype.read = function(t3) {
        return this.state.tensorInfo.get(t3).backend.read(t3);
      }, t2.prototype.time = function(t3) {
        return n(this, void 0, void 0, function() {
          var e2, n2;
          return r(this, function(r2) {
            switch (r2.label) {
              case 0:
                return e2 = et(), [4, this.backend.time(t3)];
              case 1:
                return (n2 = r2.sent()).wallMs = et() - e2, [2, n2];
            }
          });
        });
      }, t2.prototype.track = function(t3) {
        return null != this.state.activeScope && (t3.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(t3)), t3;
      }, Object.defineProperty(t2.prototype, "registeredVariables", { get: function() {
        return this.state.registeredVariables;
      }, enumerable: true, configurable: true }), t2.prototype.reset = function() {
        for (var t3 in this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new Bt(), this.registry) this.disposeRegisteredKernels(t3), this.registry[t3].dispose(), delete this.registry[t3];
        this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
      }, t2.nextTensorId = 0, t2.nextVariableId = 0, t2;
    }();
    Lt = function() {
      var t2 = function() {
        if (null == Ot) {
          var t3 = void 0;
          if ("undefined" != typeof window) t3 = window;
          else if ("undefined" != typeof global) t3 = global;
          else if ("undefined" != typeof process) t3 = process;
          else {
            if ("undefined" == typeof self) throw new Error("Could not find a global object");
            t3 = self;
          }
          Ot = t3;
        }
        return Ot;
      }();
      if (null == t2._tfengine) {
        var e2 = new o(t2);
        t2._tfengine = new Pt(e2);
      }
      return function(t3) {
        s = t3;
      }(t2._tfengine.ENV), yt = function() {
        return t2._tfengine;
      }, t2._tfengine;
    }();
    Ut = i();
    Ut.registerFlag("DEBUG", function() {
      return false;
    }, function(t2) {
      t2 && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
    }), Ut.registerFlag("IS_BROWSER", function() {
      return Wt();
    }), Ut.registerFlag("IS_NODE", function() {
      return "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node;
    }), Ut.registerFlag("IS_CHROME", function() {
      return "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
    }), Ut.registerFlag("PROD", function() {
      return false;
    }), Ut.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", function() {
      return Ut.getBool("DEBUG");
    }), Ut.registerFlag("DEPRECATION_WARNINGS_ENABLED", function() {
      return true;
    }), Ut.registerFlag("IS_TEST", function() {
      return false;
    });
    Ht = {};
    qt = { alpha: false, antialias: false, premultipliedAlpha: false, preserveDrawingBuffer: false, depth: false, stencil: false, failIfMajorPerformanceCaveat: true };
    !function(t2) {
      t2[t2.DENSE = 0] = "DENSE", t2[t2.SHARED_BATCH = 1] = "SHARED_BATCH";
    }(Vt || (Vt = {})), function(t2) {
      t2[t2.RENDER = 0] = "RENDER", t2[t2.UPLOAD = 1] = "UPLOAD", t2[t2.PIXELS = 2] = "PIXELS", t2[t2.DOWNLOAD = 3] = "DOWNLOAD";
    }(zt || (zt = {})), function(t2) {
      t2[t2.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", t2[t2.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", t2[t2.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", t2[t2.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", t2[t2.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
    }(Gt || (Gt = {}));
    Zt = 596e-10;
    te = 65504;
    ue = /ERROR: [0-9]+:([0-9]+):/g;
    Ge = Object.freeze({ callAndCheck: Jt, canBeRepresented: ee, getWebGLErrorMessage: ne, getExtensionOrThrow: re, createVertexShader: oe, createFragmentShader: ae, createProgram: ce, linkProgram: le, validateProgram: he, createStaticVertexBuffer: fe, createStaticIndexBuffer: de, getNumChannels: function() {
      return 2 === i().getNumber("WEBGL_VERSION") ? 1 : 4;
    }, createTexture: pe, validateTextureSize: ve, createFramebuffer: me, bindVertexBufferToProgramAttribute: ge, bindTextureUnit: ye, unbindTextureUnit: function(t2, e2, n2) {
      Se(t2, n2), Jt(t2, e2, function() {
        return t2.activeTexture(t2.TEXTURE0 + n2);
      }), Jt(t2, e2, function() {
        return t2.bindTexture(t2.TEXTURE_2D, null);
      });
    }, getProgramUniformLocationOrThrow: xe, getProgramUniformLocation: be, bindTextureToProgramUniformSampler: we, bindCanvasToFramebuffer: function(t2, e2) {
      Jt(t2, e2, function() {
        return t2.bindFramebuffer(t2.FRAMEBUFFER, null);
      }), Jt(t2, e2, function() {
        return t2.viewport(0, 0, t2.canvas.width, t2.canvas.height);
      }), Jt(t2, e2, function() {
        return t2.scissor(0, 0, t2.canvas.width, t2.canvas.height);
      });
    }, bindColorTextureToFramebuffer: Ce, unbindColorTextureFromFramebuffer: Ee, validateFramebuffer: Re, getFramebufferErrorMessage: Ie, getBatchDim: Ae, getRowsCols: De, getShapeAs3D: Te, getTextureShapeFromLogicalShape: Ne, isReshapeFree: _e, getWebGLMaxTextureSize: Oe, resetMaxTextureSize: function() {
      ie = null;
    }, resetMaxTexturesInShader: function() {
      se = null;
    }, getMaxTexturesInShader: Me, getWebGLDisjointQueryTimerVersion: Be, hasExtension: Pe, isWebGLVersionEnabled: Le, isCapableOfRenderingToFloatTexture: We, isDownloadFloatTextureEnabled: Ue, isWebGLFenceEnabled: ze });
    He = i();
    He.registerFlag("HAS_WEBGL", function() {
      return He.getNumber("WEBGL_VERSION") > 0;
    }), He.registerFlag("WEBGL_VERSION", function() {
      return Le(2) ? 2 : Le(1) ? 1 : 0;
    }), He.registerFlag("WEBGL_BUFFER_SUPPORTED", function() {
      return 2 === He.get("WEBGL_VERSION");
    }), He.registerFlag("WEBGL_CPU_FORWARD", function() {
      return true;
    }), He.registerFlag("WEBGL_FORCE_F16_TEXTURES", function() {
      return false;
    }), He.registerFlag("WEBGL_PACK", function() {
      return He.getBool("HAS_WEBGL");
    }), He.registerFlag("WEBGL_PACK_NORMALIZATION", function() {
      return He.getBool("WEBGL_PACK");
    }), He.registerFlag("WEBGL_PACK_CLIP", function() {
      return He.getBool("WEBGL_PACK");
    }), He.registerFlag("WEBGL_PACK_DEPTHWISECONV", function() {
      return false;
    }), He.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", function() {
      return He.getBool("WEBGL_PACK");
    }), He.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", function() {
      return He.getBool("WEBGL_PACK");
    }), He.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", function() {
      return He.getBool("WEBGL_PACK");
    }), He.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", function() {
      return He.getBool("WEBGL_PACK");
    }), He.registerFlag("WEBGL_PACK_REDUCE", function() {
      return He.getBool("WEBGL_PACK");
    }), He.registerFlag("WEBGL_LAZILY_UNPACK", function() {
      return He.getBool("WEBGL_PACK");
    }), He.registerFlag("WEBGL_CONV_IM2COL", function() {
      return He.getBool("WEBGL_PACK");
    }), He.registerFlag("WEBGL_MAX_TEXTURE_SIZE", function() {
      return Oe(He.getNumber("WEBGL_VERSION"));
    }), He.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", function() {
      return Me(He.getNumber("WEBGL_VERSION"));
    }), He.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", function() {
      var t2 = He.getNumber("WEBGL_VERSION");
      return 0 === t2 ? 0 : Be(t2);
    }), He.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", function() {
      return He.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && (t2 = navigator.userAgent || navigator.vendor || window.opera, !(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t2) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t2.substr(0, 4))));
      var t2;
    }), He.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", function() {
      return We(He.getNumber("WEBGL_VERSION"));
    }), He.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", function() {
      return !He.getBool("WEBGL_FORCE_F16_TEXTURES") && He.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
    }), He.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", function() {
      return Ue(He.getNumber("WEBGL_VERSION"));
    }), He.registerFlag("WEBGL_FENCE_API_ENABLED", function() {
      return ze(He.getNumber("WEBGL_VERSION"));
    }), He.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", function() {
      return He.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0;
    }), bt = Xe;
    Dn = An({ complex_: function(t2, e2) {
      var n2 = mn(t2, "real", "complex"), r2 = mn(e2, "imag", "complex");
      return E(n2.shape, r2.shape, "real and imag shapes, " + n2.shape + " and " + r2.shape + ", must match in call to tf.complex()."), Lt.runKernelFunc(function(t3) {
        return t3.complex(n2, r2);
      }, { $real: n2, $imag: r2 });
    } });
    Tn = An({ real_: function(t2) {
      var e2 = mn(t2, "input", "real");
      return Lt.runKernelFunc(function(t3) {
        return t3.real(e2);
      }, { $input: e2 });
    } });
    Nn = An({ imag_: function(t2) {
      var e2 = mn(t2, "input", "imag");
      return Lt.runKernelFunc(function(t3) {
        return t3.imag(e2);
      }, { $input: e2 });
    } });
    jn = An({ onesLike_: function(t2) {
      var e2 = mn(t2, "x", "onesLike");
      if ("complex64" === e2.dtype) {
        var n2 = jn(Tn(e2)), r2 = Xn(Nn(e2));
        return Dn(n2, r2);
      }
      return Lt.runKernelFunc(function(t3) {
        return t3.onesLike(e2);
      }, { $x: e2 }, function(t3, e3) {
        return { $x: function() {
          return Xn(t3);
        } };
      });
    } });
    Xn = An({ zerosLike_: function(t2) {
      var e2 = mn(t2, "x", "zerosLike");
      return Lt.runKernelFunc(function(t3) {
        return t3.zerosLike(e2);
      }, { $x: e2 }, function(t3, e3) {
        return { $x: function() {
          return Xn(t3);
        } };
      });
    } });
    Yn = An({ concat_: function(t2, e2) {
      void 0 === e2 && (e2 = 0), C(t2.length >= 1, function() {
        return "Pass at least one tensor to concat";
      });
      var n2 = gn(t2, "tensors", "concat");
      "complex64" === n2[0].dtype && n2.forEach(function(t3) {
        if ("complex64" !== t3.dtype) throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype " + t3.dtype + ". ");
      }), e2 = O(e2, n2[0].shape)[0];
      var r2 = Sn(n2.map(function(t3) {
        return t3.shape;
      }), e2);
      if (0 === k(r2)) return Fn([], r2);
      if (1 === (n2 = n2.filter(function(t3) {
        return t3.size > 0;
      })).length) return n2[0];
      var o2 = n2.map(function(t3) {
        return t3.shape;
      });
      kn(o2, e2);
      var a2 = n2, i2 = { axis: e2 };
      return Lt.runKernelFunc(function(t3) {
        return t3.concat(n2, e2);
      }, a2, function(t3) {
        var n3 = o2.map(function(t4) {
          return t4[e2];
        });
        return tr(t3, n3, e2).map(function(t4) {
          return function() {
            return t4;
          };
        });
      }, "Concat", i2);
    } });
    $n = An({ concat1d_: function(t2) {
      return Yn(t2, 0);
    } });
    Qn = An({ concat2d_: function(t2, e2) {
      return Yn(t2, e2);
    } });
    Jn = An({ concat3d_: function(t2, e2) {
      return Yn(t2, e2);
    } });
    Zn = An({ concat4d_: function(t2, e2) {
      return Yn(t2, e2);
    } });
    tr = An({ split_: function(t2, e2, n2) {
      void 0 === n2 && (n2 = 0);
      var r2, o2 = mn(t2, "x", "split");
      return n2 = O(n2, o2.shape)[0], "number" == typeof e2 ? (C(o2.shape[n2] % e2 == 0, function() {
        return "Number of splits must evenly divide the axis.";
      }), r2 = new Array(e2).fill(o2.shape[n2] / e2)) : (C(o2.shape[n2] === e2.reduce(function(t3, e3) {
        return t3 + e3;
      }), function() {
        return "The sum of sizes must match the size of the axis dimension.";
      }), r2 = e2), Lt.runKernelFunc(function(t3) {
        return t3.split(o2, r2, n2);
      }, { $x: o2 }, function(t3) {
        return { $x: function() {
          return Yn(t3, n2);
        } };
      });
    } });
    nr = er(function(t2) {
      !function(t3, e2, n2) {
        function r2(t4) {
          var e3, n3 = this, r3 = (e3 = 4022871197, function(t5) {
            t5 = t5.toString();
            for (var n4 = 0; n4 < t5.length; n4++) {
              var r4 = 0.02519603282416938 * (e3 += t5.charCodeAt(n4));
              r4 -= e3 = r4 >>> 0, e3 = (r4 *= e3) >>> 0, e3 += 4294967296 * (r4 -= e3);
            }
            return 23283064365386963e-26 * (e3 >>> 0);
          });
          n3.next = function() {
            var t5 = 2091639 * n3.s0 + 23283064365386963e-26 * n3.c;
            return n3.s0 = n3.s1, n3.s1 = n3.s2, n3.s2 = t5 - (n3.c = 0 | t5);
          }, n3.c = 1, n3.s0 = r3(" "), n3.s1 = r3(" "), n3.s2 = r3(" "), n3.s0 -= r3(t4), n3.s0 < 0 && (n3.s0 += 1), n3.s1 -= r3(t4), n3.s1 < 0 && (n3.s1 += 1), n3.s2 -= r3(t4), n3.s2 < 0 && (n3.s2 += 1), r3 = null;
        }
        function o2(t4, e3) {
          return e3.c = t4.c, e3.s0 = t4.s0, e3.s1 = t4.s1, e3.s2 = t4.s2, e3;
        }
        function a2(t4, e3) {
          var n3 = new r2(t4), a3 = e3 && e3.state, i2 = n3.next;
          return i2.int32 = function() {
            return 4294967296 * n3.next() | 0;
          }, i2.double = function() {
            return i2() + 11102230246251565e-32 * (2097152 * i2() | 0);
          }, i2.quick = i2, a3 && ("object" == typeof a3 && o2(a3, n3), i2.state = function() {
            return o2(n3, {});
          }), i2;
        }
        e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
          return a2;
        }) : this.alea = a2;
      }(0, t2, false);
    });
    rr = er(function(t2) {
      !function(t3, e2, n2) {
        function r2(t4) {
          var e3 = this, n3 = "";
          e3.x = 0, e3.y = 0, e3.z = 0, e3.w = 0, e3.next = function() {
            var t5 = e3.x ^ e3.x << 11;
            return e3.x = e3.y, e3.y = e3.z, e3.z = e3.w, e3.w ^= e3.w >>> 19 ^ t5 ^ t5 >>> 8;
          }, t4 === (0 | t4) ? e3.x = t4 : n3 += t4;
          for (var r3 = 0; r3 < n3.length + 64; r3++) e3.x ^= 0 | n3.charCodeAt(r3), e3.next();
        }
        function o2(t4, e3) {
          return e3.x = t4.x, e3.y = t4.y, e3.z = t4.z, e3.w = t4.w, e3;
        }
        function a2(t4, e3) {
          var n3 = new r2(t4), a3 = e3 && e3.state, i2 = function() {
            return (n3.next() >>> 0) / 4294967296;
          };
          return i2.double = function() {
            do {
              var t5 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
            } while (0 === t5);
            return t5;
          }, i2.int32 = n3.next, i2.quick = i2, a3 && ("object" == typeof a3 && o2(a3, n3), i2.state = function() {
            return o2(n3, {});
          }), i2;
        }
        e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
          return a2;
        }) : this.xor128 = a2;
      }(0, t2, false);
    });
    or = er(function(t2) {
      !function(t3, e2, n2) {
        function r2(t4) {
          var e3 = this, n3 = "";
          e3.next = function() {
            var t5 = e3.x ^ e3.x >>> 2;
            return e3.x = e3.y, e3.y = e3.z, e3.z = e3.w, e3.w = e3.v, (e3.d = e3.d + 362437 | 0) + (e3.v = e3.v ^ e3.v << 4 ^ t5 ^ t5 << 1) | 0;
          }, e3.x = 0, e3.y = 0, e3.z = 0, e3.w = 0, e3.v = 0, t4 === (0 | t4) ? e3.x = t4 : n3 += t4;
          for (var r3 = 0; r3 < n3.length + 64; r3++) e3.x ^= 0 | n3.charCodeAt(r3), r3 == n3.length && (e3.d = e3.x << 10 ^ e3.x >>> 4), e3.next();
        }
        function o2(t4, e3) {
          return e3.x = t4.x, e3.y = t4.y, e3.z = t4.z, e3.w = t4.w, e3.v = t4.v, e3.d = t4.d, e3;
        }
        function a2(t4, e3) {
          var n3 = new r2(t4), a3 = e3 && e3.state, i2 = function() {
            return (n3.next() >>> 0) / 4294967296;
          };
          return i2.double = function() {
            do {
              var t5 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
            } while (0 === t5);
            return t5;
          }, i2.int32 = n3.next, i2.quick = i2, a3 && ("object" == typeof a3 && o2(a3, n3), i2.state = function() {
            return o2(n3, {});
          }), i2;
        }
        e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
          return a2;
        }) : this.xorwow = a2;
      }(0, t2, false);
    });
    ar = er(function(t2) {
      !function(t3, e2, n2) {
        function r2(t4) {
          var e3 = this;
          e3.next = function() {
            var t5, n3, r3 = e3.x, o3 = e3.i;
            return t5 = r3[o3], n3 = (t5 ^= t5 >>> 7) ^ t5 << 24, n3 ^= (t5 = r3[o3 + 1 & 7]) ^ t5 >>> 10, n3 ^= (t5 = r3[o3 + 3 & 7]) ^ t5 >>> 3, n3 ^= (t5 = r3[o3 + 4 & 7]) ^ t5 << 7, t5 = r3[o3 + 7 & 7], n3 ^= (t5 ^= t5 << 13) ^ t5 << 9, r3[o3] = n3, e3.i = o3 + 1 & 7, n3;
          }, function(t5, e4) {
            var n3, r3 = [];
            if (e4 === (0 | e4)) r3[0] = e4;
            else for (e4 = "" + e4, n3 = 0; n3 < e4.length; ++n3) r3[7 & n3] = r3[7 & n3] << 15 ^ e4.charCodeAt(n3) + r3[n3 + 1 & 7] << 13;
            for (; r3.length < 8; ) r3.push(0);
            for (n3 = 0; n3 < 8 && 0 === r3[n3]; ++n3) ;
            for (8 == n3 ? r3[7] = -1 : r3[n3], t5.x = r3, t5.i = 0, n3 = 256; n3 > 0; --n3) t5.next();
          }(e3, t4);
        }
        function o2(t4, e3) {
          return e3.x = t4.x.slice(), e3.i = t4.i, e3;
        }
        function a2(t4, e3) {
          null == t4 && (t4 = +/* @__PURE__ */ new Date());
          var n3 = new r2(t4), a3 = e3 && e3.state, i2 = function() {
            return (n3.next() >>> 0) / 4294967296;
          };
          return i2.double = function() {
            do {
              var t5 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
            } while (0 === t5);
            return t5;
          }, i2.int32 = n3.next, i2.quick = i2, a3 && (a3.x && o2(a3, n3), i2.state = function() {
            return o2(n3, {});
          }), i2;
        }
        e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
          return a2;
        }) : this.xorshift7 = a2;
      }(0, t2, false);
    });
    ir = er(function(t2) {
      !function(t3, e2, n2) {
        function r2(t4) {
          var e3 = this;
          e3.next = function() {
            var t5, n3, r3 = e3.w, o3 = e3.X, a3 = e3.i;
            return e3.w = r3 = r3 + 1640531527 | 0, n3 = o3[a3 + 34 & 127], t5 = o3[a3 = a3 + 1 & 127], n3 ^= n3 << 13, t5 ^= t5 << 17, n3 ^= n3 >>> 15, t5 ^= t5 >>> 12, n3 = o3[a3] = n3 ^ t5, e3.i = a3, n3 + (r3 ^ r3 >>> 16) | 0;
          }, function(t5, e4) {
            var n3, r3, o3, a3, i2, s2 = [], u3 = 128;
            for (e4 === (0 | e4) ? (r3 = e4, e4 = null) : (e4 += "\0", r3 = 0, u3 = Math.max(u3, e4.length)), o3 = 0, a3 = -32; a3 < u3; ++a3) e4 && (r3 ^= e4.charCodeAt((a3 + 32) % e4.length)), 0 === a3 && (i2 = r3), r3 ^= r3 << 10, r3 ^= r3 >>> 15, r3 ^= r3 << 4, r3 ^= r3 >>> 13, a3 >= 0 && (i2 = i2 + 1640531527 | 0, o3 = 0 == (n3 = s2[127 & a3] ^= r3 + i2) ? o3 + 1 : 0);
            for (o3 >= 128 && (s2[127 & (e4 && e4.length || 0)] = -1), o3 = 127, a3 = 512; a3 > 0; --a3) r3 = s2[o3 + 34 & 127], n3 = s2[o3 = o3 + 1 & 127], r3 ^= r3 << 13, n3 ^= n3 << 17, r3 ^= r3 >>> 15, n3 ^= n3 >>> 12, s2[o3] = r3 ^ n3;
            t5.w = i2, t5.X = s2, t5.i = o3;
          }(e3, t4);
        }
        function o2(t4, e3) {
          return e3.i = t4.i, e3.w = t4.w, e3.X = t4.X.slice(), e3;
        }
        function a2(t4, e3) {
          null == t4 && (t4 = +/* @__PURE__ */ new Date());
          var n3 = new r2(t4), a3 = e3 && e3.state, i2 = function() {
            return (n3.next() >>> 0) / 4294967296;
          };
          return i2.double = function() {
            do {
              var t5 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
            } while (0 === t5);
            return t5;
          }, i2.int32 = n3.next, i2.quick = i2, a3 && (a3.X && o2(a3, n3), i2.state = function() {
            return o2(n3, {});
          }), i2;
        }
        e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
          return a2;
        }) : this.xor4096 = a2;
      }(0, t2, false);
    });
    sr = er(function(t2) {
      !function(t3, e2, n2) {
        function r2(t4) {
          var e3 = this, n3 = "";
          e3.next = function() {
            var t5 = e3.b, n4 = e3.c, r4 = e3.d, o3 = e3.a;
            return t5 = t5 << 25 ^ t5 >>> 7 ^ n4, n4 = n4 - r4 | 0, r4 = r4 << 24 ^ r4 >>> 8 ^ o3, o3 = o3 - t5 | 0, e3.b = t5 = t5 << 20 ^ t5 >>> 12 ^ n4, e3.c = n4 = n4 - r4 | 0, e3.d = r4 << 16 ^ n4 >>> 16 ^ o3, e3.a = o3 - t5 | 0;
          }, e3.a = 0, e3.b = 0, e3.c = -1640531527, e3.d = 1367130551, t4 === Math.floor(t4) ? (e3.a = t4 / 4294967296 | 0, e3.b = 0 | t4) : n3 += t4;
          for (var r3 = 0; r3 < n3.length + 20; r3++) e3.b ^= 0 | n3.charCodeAt(r3), e3.next();
        }
        function o2(t4, e3) {
          return e3.a = t4.a, e3.b = t4.b, e3.c = t4.c, e3.d = t4.d, e3;
        }
        function a2(t4, e3) {
          var n3 = new r2(t4), a3 = e3 && e3.state, i2 = function() {
            return (n3.next() >>> 0) / 4294967296;
          };
          return i2.double = function() {
            do {
              var t5 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
            } while (0 === t5);
            return t5;
          }, i2.int32 = n3.next, i2.quick = i2, a3 && ("object" == typeof a3 && o2(a3, n3), i2.state = function() {
            return o2(n3, {});
          }), i2;
        }
        e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
          return a2;
        }) : this.tychei = a2;
      }(0, t2, false);
    });
    ur = er(function(t2) {
      !function(e2, n2) {
        var r2, o2 = this, a2 = 256, i2 = 6, s2 = "random", u3 = n2.pow(a2, i2), c2 = n2.pow(2, 52), l2 = 2 * c2, h2 = a2 - 1;
        function f2(t3, h3, f3) {
          var g2 = [], y2 = v(function t4(e3, n3) {
            var r3, o3 = [], a3 = typeof e3;
            if (n3 && "object" == a3) for (r3 in e3) try {
              o3.push(t4(e3[r3], n3 - 1));
            } catch (t5) {
            }
            return o3.length ? o3 : "string" == a3 ? e3 : e3 + "\0";
          }((h3 = 1 == h3 ? { entropy: true } : h3 || {}).entropy ? [t3, m(e2)] : null == t3 ? function() {
            try {
              var t4;
              return r2 && (t4 = r2.randomBytes) ? t4 = t4(a2) : (t4 = new Uint8Array(a2), (o2.crypto || o2.msCrypto).getRandomValues(t4)), m(t4);
            } catch (t5) {
              var n3 = o2.navigator, i3 = n3 && n3.plugins;
              return [+/* @__PURE__ */ new Date(), o2, i3, o2.screen, m(e2)];
            }
          }() : t3, 3), g2), x2 = new d2(g2), b2 = function() {
            for (var t4 = x2.g(i2), e3 = u3, n3 = 0; t4 < c2; ) t4 = (t4 + n3) * a2, e3 *= a2, n3 = x2.g(1);
            for (; t4 >= l2; ) t4 /= 2, e3 /= 2, n3 >>>= 1;
            return (t4 + n3) / e3;
          };
          return b2.int32 = function() {
            return 0 | x2.g(4);
          }, b2.quick = function() {
            return x2.g(4) / 4294967296;
          }, b2.double = b2, v(m(x2.S), e2), (h3.pass || f3 || function(t4, e3, r3, o3) {
            return o3 && (o3.S && p2(o3, x2), t4.state = function() {
              return p2(x2, {});
            }), r3 ? (n2[s2] = t4, e3) : t4;
          })(b2, y2, "global" in h3 ? h3.global : this == n2, h3.state);
        }
        function d2(t3) {
          var e3, n3 = t3.length, r3 = this, o3 = 0, i3 = r3.i = r3.j = 0, s3 = r3.S = [];
          for (n3 || (t3 = [n3++]); o3 < a2; ) s3[o3] = o3++;
          for (o3 = 0; o3 < a2; o3++) s3[o3] = s3[i3 = h2 & i3 + t3[o3 % n3] + (e3 = s3[o3])], s3[i3] = e3;
          (r3.g = function(t4) {
            for (var e4, n4 = 0, o4 = r3.i, i4 = r3.j, s4 = r3.S; t4--; ) e4 = s4[o4 = h2 & o4 + 1], n4 = n4 * a2 + s4[h2 & (s4[o4] = s4[i4 = h2 & i4 + e4]) + (s4[i4] = e4)];
            return r3.i = o4, r3.j = i4, n4;
          })(a2);
        }
        function p2(t3, e3) {
          return e3.i = t3.i, e3.j = t3.j, e3.S = t3.S.slice(), e3;
        }
        function v(t3, e3) {
          for (var n3, r3 = t3 + "", o3 = 0; o3 < r3.length; ) e3[h2 & o3] = h2 & (n3 ^= 19 * e3[h2 & o3]) + r3.charCodeAt(o3++);
          return m(e3);
        }
        function m(t3) {
          return String.fromCharCode.apply(0, t3);
        }
        if (n2["seed" + s2] = f2, v(n2.random(), e2), t2.exports) {
          t2.exports = f2;
          try {
            r2 = require_crypto();
          } catch (t3) {
          }
        }
      }([], Math);
    });
    ur.alea = nr, ur.xor128 = rr, ur.xorwow = or, ur.xorshift7 = ar, ur.xor4096 = ir, ur.tychei = sr;
    cr = ur.alea;
    lr = function() {
      function t2(t3, e2, n2, r2, o2) {
        this.mean = t3, this.stdDev = e2, this.dtype = n2, this.nextVal = NaN, this.truncated = r2, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
        var a2 = o2 || Math.random();
        this.random = cr(a2.toString());
      }
      return t2.prototype.nextValue = function() {
        if (!isNaN(this.nextVal)) {
          var t3 = this.nextVal;
          return this.nextVal = NaN, t3;
        }
        for (var e2, n2, r2 = false; !r2; ) {
          var o2 = void 0, a2 = void 0, i2 = void 0;
          do {
            i2 = (o2 = 2 * this.random() - 1) * o2 + (a2 = 2 * this.random() - 1) * a2;
          } while (i2 >= 1 || 0 === i2);
          var s2 = Math.sqrt(-2 * Math.log(i2) / i2);
          e2 = this.mean + this.stdDev * o2 * s2, n2 = this.mean + this.stdDev * a2 * s2, this.truncated && !this.isValidTruncated(e2) || (r2 = true);
        }
        return this.truncated && !this.isValidTruncated(n2) || (this.nextVal = this.convertValue(n2)), this.convertValue(e2);
      }, t2.prototype.convertValue = function(t3) {
        return null == this.dtype || "float32" === this.dtype ? t3 : Math.round(t3);
      }, t2.prototype.isValidTruncated = function(t3) {
        return t3 <= this.upper && t3 >= this.lower;
      }, t2;
    }();
    hr = function() {
      function t2(t3, e2, n2, r2) {
        this.alpha = t3, this.beta = 1 / e2, this.dtype = n2;
        var o2 = r2 || Math.random();
        this.randu = cr(o2.toString()), this.randn = new lr(0, 1, n2, false, this.randu()), this.d = t3 < 1 ? t3 + 2 / 3 : t3 - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);
      }
      return t2.prototype.nextValue = function() {
        for (var t3, e2, n2, r2, o2, a2; ; ) {
          do {
            r2 = this.randn.nextValue(), a2 = 1 + this.c * r2;
          } while (a2 <= 0);
          if (a2 *= a2 * a2, e2 = 1 - 0.331 * (t3 = r2 * r2) * t3, n2 = 0.5 * t3 + this.d * (1 - a2 + Math.log(a2)), (o2 = this.randu()) < e2 || Math.log(o2) < n2) break;
        }
        return a2 = 1 / this.beta * this.d * a2, this.alpha < 1 && (a2 *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(a2);
      }, t2.prototype.convertValue = function(t3) {
        return "float32" === this.dtype ? t3 : Math.round(t3);
      }, t2;
    }();
    fr = function() {
      function t2(t3, e2, n2, r2) {
        var o2 = this;
        if (void 0 === t3 && (t3 = 0), void 0 === e2 && (e2 = 1), this.canReturnFloat = function() {
          return null == o2.dtype || "float32" === o2.dtype;
        }, this.min = t3, this.range = e2 - t3, this.dtype = n2, null == r2 && (r2 = Math.random()), "number" == typeof r2 && (r2 = r2.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error("The difference between " + t3 + " - " + e2 + " <= 1 and dtype is not float");
        this.random = cr(r2);
      }
      return t2.prototype.convertValue = function(t3) {
        return this.canReturnFloat() ? t3 : Math.round(t3);
      }, t2.prototype.nextValue = function() {
        return this.convertValue(this.min + this.range * this.random());
      }, t2;
    }();
    vr = An({ batchToSpaceND_: function(t2, e2, n2) {
      var r2 = mn(t2, "x", "batchToSpaceND"), o2 = e2.reduce(function(t3, e3) {
        return t3 * e3;
      });
      return C(r2.rank >= 1 + e2.length, function() {
        return "input rank is " + r2.rank + " but should be > than blockShape.length " + e2.length;
      }), C(n2.length === e2.length, function() {
        return "crops.length is " + n2.length + " but should be equal to blockShape.length  " + e2.length;
      }), C(r2.shape[0] % o2 == 0, function() {
        return "input tensor batch is " + r2.shape[0] + " but is not divisible by the product of the elements of blockShape " + e2.join(" * ") + " === " + o2;
      }), Lt.runKernelFunc(function(t3) {
        return t3.batchToSpaceND(r2, e2, n2);
      }, { $x: r2 }, function(t3) {
        return { $x: function() {
          return t3.spaceToBatchND(e2, n2);
        } };
      });
    } });
    mr = An({ broadcastTo_: function(t2, e2) {
      var n2 = mn(t2, "broadcastTo", "x"), r2 = n2.shape;
      if (e2.some(function(t3) {
        return !(t3 > 0) || t3 % 1 != 0;
      })) throw new Error("broadcastTo(): Invalid broadcast shape [" + e2 + "].");
      if (e2.length < n2.rank) throw new Error("broadcastTo(): shape.length=" + e2.length + " < input.rank=" + n2.rank + ".");
      if (e2.length > n2.rank) {
        for (var o2 = n2.shape.slice(); o2.length < e2.length; ) o2.unshift(1);
        n2 = n2.reshape(o2);
      }
      for (var a2 = Array.from(e2), i2 = e2.length - 1; i2 >= 0; i2--) if (n2.shape[i2] === e2[i2]) a2[i2] = 1;
      else if (1 !== n2.shape[i2]) throw new Error("broadcastTo(): [" + r2 + "] cannot be broadcast to [" + e2 + "].");
      var s2 = a2.map(function(t3, e3) {
        return t3 > 1 ? e3 : -1;
      }).filter(function(t3) {
        return t3 >= 0;
      });
      return 0 === s2.length ? n2.clone() : Lt.runKernelFunc(function(t3) {
        return t3.tile(n2, a2);
      }, { input: n2 }, function(t3) {
        return { input: function() {
          return t3.sum(s2, true);
        } };
      });
    } });
    gr = An({ cast_: function(t2, e2) {
      var n2 = mn(t2, "x", "cast");
      if (!W(e2)) throw new Error("Failed to cast to unknown dtype " + e2);
      if ("string" === e2 && "string" !== n2.dtype || "string" !== e2 && "string" === n2.dtype) throw new Error("Only strings can be casted to strings");
      var r2 = { dtype: e2 };
      return Lt.runKernelFunc(function(t3) {
        return t3.cast(n2, e2);
      }, { x: n2 }, function(t3) {
        return { x: function() {
          return t3.clone();
        } };
      }, "Cast", r2);
    } });
    yr = An({ clone_: function(t2) {
      var e2 = mn(t2, "x", "clone", null);
      return Lt.runKernelFunc(function() {
        return Lt.makeTensorFromDataId(e2.dataId, e2.shape, e2.dtype);
      }, { $x: e2 }, function(t3) {
        return { $x: function() {
          return t3.toFloat();
        } };
      });
    } });
    xr = An({ cumsum_: function(t2, e2, n2, r2) {
      void 0 === e2 && (e2 = 0), void 0 === n2 && (n2 = false), void 0 === r2 && (r2 = false);
      var o2 = mn(t2, "x", "cumsum"), a2 = En([e2 |= 0], o2.rank), i2 = o2;
      null != a2 && (i2 = o2.transpose(a2));
      var s2 = In(1, o2.rank)[0], u3 = Lt.runKernelFunc(function(t3) {
        return t3.cumsum(i2, s2, n2, r2);
      }, { permutedX: i2 }, function(t3) {
        return { permutedX: function() {
          return t3.cumsum(e2, n2, !r2);
        } };
      });
      return null != a2 && (u3 = u3.transpose(a2)), u3;
    } });
    br = An({ depthToSpace_: function(t2, e2, n2) {
      void 0 === n2 && (n2 = "NHWC");
      var r2 = mn(t2, "x", "depthToSpace"), o2 = "NHWC" === n2 ? r2.shape[1] : r2.shape[2], a2 = "NHWC" === n2 ? r2.shape[2] : r2.shape[3], i2 = "NHWC" === n2 ? r2.shape[3] : r2.shape[1];
      return C(o2 * e2 >= 0, function() {
        return "Negative dimension size caused by overflow when multiplying\n      " + o2 + " and " + e2 + "  for depthToSpace with input shape\n      " + r2.shape;
      }), C(a2 * e2 >= 0, function() {
        return "Negative dimension size caused by overflow when multiplying\n      " + a2 + " and " + e2 + " for depthToSpace with input shape\n          " + r2.shape;
      }), C(i2 % (e2 * e2) == 0, function() {
        return "Dimension size must be evenly divisible by " + e2 * e2 + " but is " + i2 + " for depthToSpace with input shape " + r2.shape;
      }), Lt.runKernelFunc(function(t3) {
        return t3.depthToSpace(r2, e2, n2);
      }, { $x: r2 });
    } });
    wr = An({ expandDims_: function(t2, e2) {
      void 0 === e2 && (e2 = 0);
      var n2 = mn(t2, "x", "expandDims", null);
      C(e2 <= n2.rank, function() {
        return "Axis must be <= rank of the tensor";
      });
      var r2 = n2.shape.slice();
      return e2 < 0 && (C(-(n2.rank + 1) <= e2, function() {
        return "Axis must be in the interval [" + -(n2.rank + 1) + ", " + n2.rank + "]";
      }), e2 = n2.rank + e2 + 1), r2.splice(e2, 0, 1), Or(n2, r2);
    } });
    Cr = An({ eye_: function(t2, e2, n2, r2) {
      void 0 === r2 && (r2 = "float32"), null == e2 && (e2 = t2);
      for (var o2 = dr([t2, e2], r2), a2 = t2 <= e2 ? t2 : e2, i2 = 0; i2 < a2; ++i2) o2.set(1, i2, i2);
      var s2 = o2.toTensor().as2D(t2, e2);
      if (null == n2) return s2;
      if (1 === n2.length) return Lr(wr(s2, 0), [n2[0], 1, 1]);
      if (2 === n2.length) return Lr(wr(wr(s2, 0), 0), [n2[0], n2[1], 1, 1]);
      if (3 === n2.length) return Lr(wr(wr(wr(s2, 0), 0), 0), [n2[0], n2[1], n2[2], 1, 1]);
      throw new Error("eye() currently supports only 1D and 2D batchShapes, but received " + n2.length + "D.");
    } });
    Er = An({ multinomial_: function(t2, e2, n2, r2) {
      void 0 === r2 && (r2 = false);
      var o2 = mn(t2, "logits", "multinomial"), a2 = o2.size, i2 = o2.rank;
      if (a2 < 2) throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + a2 + ".");
      if (i2 > 2) throw new Error("Rank of probabilities must be 1 or 2, but is " + i2);
      n2 = n2 || Math.random();
      var s2 = 1 === i2 ? o2.as2D(1, -1) : o2, u3 = Lt.runKernelFunc(function(t3) {
        return t3.multinomial(s2, r2, e2, n2);
      }, { logits2D: s2 });
      return 1 === i2 ? u3.as1D() : u3;
    } });
    Rr = An({ oneHot_: function(t2, e2, n2, r2) {
      if (void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = 0), e2 < 2) throw new Error("Error in oneHot: depth must be >=2, but it is " + e2);
      var o2 = mn(t2, "indices", "oneHot", "int32"), a2 = o2.shape.concat([e2]);
      return o2 = o2.flatten(), Lt.runKernelFunc(function(t3) {
        return t3.oneHot(o2, e2, n2, r2);
      }, { $indices: o2 }, function(t3) {
        return { $indices: function() {
          return Gn(o2.shape, "float32");
        } };
      }).reshape(a2);
    } });
    Ir = An({ pad_: function(t2, e2, n2) {
      void 0 === n2 && (n2 = 0);
      var r2 = mn(t2, "x", "pad");
      if (0 === r2.rank) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
      var o2 = { paddings: e2, constantValue: n2 };
      return Lt.runKernelFunc(function(t3) {
        return t3.pad(r2, e2, n2);
      }, { x: r2 }, function(t3) {
        var n3 = e2.map(function(t4) {
          return t4[0];
        });
        return { x: function() {
          return t3.slice(n3, r2.shape);
        } };
      }, "PadV2", o2);
    } });
    kr = An({ pad1d_: function(t2, e2, n2) {
      return void 0 === n2 && (n2 = 0), C(2 === e2.length, function() {
        return "Invalid number of paddings. Must be length of 2.";
      }), Ir(t2, [e2], n2);
    } });
    Sr = An({ pad2d_: function(t2, e2, n2) {
      return void 0 === n2 && (n2 = 0), C(2 === e2.length && 2 === e2[0].length && 2 === e2[1].length, function() {
        return "Invalid number of paddings. Must be length of 2 each.";
      }), Ir(t2, e2, n2);
    } });
    Ar = An({ pad3d_: function(t2, e2, n2) {
      return void 0 === n2 && (n2 = 0), C(3 === e2.length && 2 === e2[0].length && 2 === e2[1].length && 2 === e2[2].length, function() {
        return "Invalid number of paddings. Must be length of 2 each.";
      }), Ir(t2, e2, n2);
    } });
    Dr = An({ pad4d_: function(t2, e2, n2) {
      return void 0 === n2 && (n2 = 0), C(4 === e2.length && 2 === e2[0].length && 2 === e2[1].length && 2 === e2[2].length && 2 === e2[3].length, function() {
        return "Invalid number of paddings. Must be length of 2 each.";
      }), Ir(t2, e2, n2);
    } });
    Tr = An({ rand_: function(t2, e2, n2) {
      var r2 = k(t2), o2 = null;
      if (null == n2 || "float32" === n2) o2 = new Float32Array(r2);
      else if ("int32" === n2) o2 = new Int32Array(r2);
      else {
        if ("bool" !== n2) throw new Error("Unknown data type " + n2);
        o2 = new Uint8Array(r2);
      }
      for (var a2 = 0; a2 < r2; a2++) o2[a2] = e2();
      return Lt.makeTensor(o2, t2, n2);
    } });
    Nr = An({ randomNormal_: function(t2, e2, n2, r2, o2) {
      if (void 0 === e2 && (e2 = 0), void 0 === n2 && (n2 = 1), null != r2 && "bool" === r2) throw new Error("Unsupported data type " + r2);
      for (var a2 = new lr(e2, n2, r2, false, o2), i2 = dr(t2, r2), s2 = 0; s2 < i2.values.length; s2++) i2.values[s2] = a2.nextValue();
      return i2.toTensor();
    } });
    Fr = An({ randomGamma_: function(t2, e2, n2, r2, o2) {
      if (void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = "float32"), null == n2 && (n2 = 1), null == r2 && (r2 = "float32"), "float32" !== r2 && "int32" !== r2) throw new Error("Unsupported data type " + r2);
      for (var a2 = new hr(e2, n2, r2, o2), i2 = dr(t2, r2), s2 = 0; s2 < i2.values.length; s2++) i2.values[s2] = a2.nextValue();
      return i2.toTensor();
    } });
    _r = An({ randomUniform_: function(t2, e2, n2, r2, o2) {
      void 0 === e2 && (e2 = 0), void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = "float32");
      for (var a2 = dr(t2, r2), i2 = new fr(e2, n2, null, o2), s2 = 0; s2 < a2.values.length; s2++) a2.values[s2] = i2.nextValue();
      return a2.toTensor();
    } });
    Or = An({ reshape_: function(t2, e2) {
      var n2 = mn(t2, "x", "reshape", null);
      e2 = _(e2, n2.size), C(n2.size === k(e2), function() {
        return "new shape and old shape must have the same number of elements.";
      });
      var r2 = { shape: e2 };
      return Lt.runKernelFunc(function(t3) {
        return t3.reshape(n2, e2);
      }, { x: n2 }, function(t3) {
        return { x: function() {
          return t3.reshape(n2.shape);
        } };
      }, "Reshape", r2);
    } });
    Mr = An({ spaceToBatchND_: function(t2, e2, n2) {
      var r2 = mn(t2, "x", "spaceToBatchND");
      return C(r2.rank >= 1 + e2.length, function() {
        return "input rank " + r2.rank + " should be > than [blockShape] " + e2.length;
      }), C(n2.length === e2.length, function() {
        return "paddings.shape[0] " + n2.length + " must be equal to [blockShape] " + e2.length;
      }), C(r2.shape.reduce(function(t3, r3, o2) {
        return o2 > 0 && o2 <= e2.length ? t3 && (r3 + n2[o2 - 1][0] + n2[o2 - 1][1]) % e2[o2 - 1] == 0 : t3;
      }, true), function() {
        return "input spatial dimensions " + r2.shape.slice(1) + " with paddings " + n2.toString() + " must be divisible by blockShapes " + e2.toString();
      }), Lt.runKernelFunc(function(t3) {
        return t3.spaceToBatchND(r2, e2, n2);
      }, { $x: r2 }, function(t3) {
        return { $x: function() {
          return t3.batchToSpaceND(e2, n2);
        } };
      });
    } });
    Br = An({ squeeze_: function(t2, e2) {
      var n2 = mn(t2, "x", "squeeze");
      return Or(n2, M(n2.shape, e2).newShape);
    } });
    Pr = An({ stack_: function(t2, e2) {
      void 0 === e2 && (e2 = 0);
      var n2 = gn(t2, "tensors", "stack");
      if (C(n2.length >= 1, function() {
        return "Pass at least one tensor to tf.stack";
      }), 1 === n2.length) return n2[0].expandDims(e2);
      var r2 = n2[0].rank, o2 = n2[0].shape, a2 = n2[0].dtype;
      C(e2 <= r2, function() {
        return "Axis must be <= rank of the tensor";
      }), n2.forEach(function(t3) {
        E(o2, t3.shape, "All tensors passed to stack must have matching shapes");
      }), n2.forEach(function(t3) {
        C(a2 === t3.dtype, function() {
          return "All tensors passed to stack must have matching dtypes";
        });
      });
      var i2 = n2.map(function(t3) {
        return t3.expandDims(e2);
      });
      return Yn(i2, e2);
    } });
    Lr = An({ tile_: function(t2, e2) {
      var n2 = mn(t2, "x", "tile", null);
      C(n2.rank === e2.length, function() {
        return "Error in transpose: rank of input " + n2.rank + " must match length of reps " + e2 + ".";
      });
      var r2 = [n2], o2 = { reps: e2 };
      return Lt.runKernelFunc(function(t3, r3) {
        var o3 = t3.tile(n2, e2);
        return r3([n2]), o3;
      }, { x: n2 }, function(t3, n3) {
        var r3 = n3[0];
        return { x: function() {
          var n4 = Xn(r3);
          if (1 === r3.rank) for (var o3 = 0; o3 < e2[0]; ++o3) n4 = n4.add(t3.slice([o3 * r3.shape[0]], [r3.shape[0]]));
          else if (2 === r3.rank) for (o3 = 0; o3 < e2[0]; ++o3) for (var a2 = 0; a2 < e2[1]; ++a2) n4 = n4.add(t3.slice([o3 * r3.shape[0], a2 * r3.shape[1]], [r3.shape[0], r3.shape[1]]));
          else if (3 === r3.rank) for (o3 = 0; o3 < e2[0]; ++o3) for (a2 = 0; a2 < e2[1]; ++a2) for (var i2 = 0; i2 < e2[2]; ++i2) n4 = n4.add(t3.slice([o3 * r3.shape[0], a2 * r3.shape[1], i2 * r3.shape[2]], [r3.shape[0], r3.shape[1], r3.shape[2]]));
          else {
            if (4 !== r3.rank) throw new Error("Gradient for tile operation is not implemented for rank-" + r3.rank + " tensors yet.");
            for (o3 = 0; o3 < e2[0]; ++o3) for (a2 = 0; a2 < e2[1]; ++a2) for (i2 = 0; i2 < e2[2]; ++i2) for (var s2 = 0; s2 < e2[3]; ++s2) n4 = n4.add(t3.slice([o3 * r3.shape[0], a2 * r3.shape[1], i2 * r3.shape[2], s2 * r3.shape[3]], [r3.shape[0], r3.shape[1], r3.shape[2], r3.shape[3]]));
          }
          return n4;
        } };
      }, "Tile", o2, r2);
    } });
    Wr = An({ truncatedNormal_: function(t2, e2, n2, r2, o2) {
      if (void 0 === e2 && (e2 = 0), void 0 === n2 && (n2 = 1), null != r2 && "bool" === r2) throw new Error("Unsupported data type " + r2);
      for (var a2 = new lr(e2, n2, r2, true, o2), i2 = dr(t2, r2), s2 = 0; s2 < i2.values.length; s2++) i2.values[s2] = a2.nextValue();
      return i2.toTensor();
    } });
    Ur = An({ unstack_: function(t2, e2) {
      void 0 === e2 && (e2 = 0), e2 = e2 || 0;
      var n2 = mn(t2, "x", "unstack");
      C(e2 >= -n2.shape.length && e2 < n2.shape.length, function() {
        return "Axis = " + e2 + " is not in [-" + n2.shape.length + ", " + n2.shape.length + ")";
      }), e2 < 0 && (e2 += n2.shape.length);
      var r2 = { axis: e2 };
      return Lt.runKernelFunc(function(t3) {
        return t3.unstack(n2, e2);
      }, { x: n2 }, function(t3) {
        return { x: function() {
          return Pr(t3, e2);
        } };
      }, "Unpack", r2);
    } });
    Vr = function(t2, e2) {
      return n(this, void 0, void 0, function() {
        var n2, o2, a2, i2, s2, u3, c2, l2, h2, f2;
        return r(this, function(r2) {
          switch (r2.label) {
            case 0:
              return n2 = mn(t2, "x", "setdiff1d"), o2 = mn(e2, "y", "setdiff1d"), C(n2.dtype === o2.dtype, function() {
                return "x and y should have the same dtype, but got x (" + n2.dtype + ") and y (" + o2.dtype + ").";
              }), C(1 === n2.rank, function() {
                return "x should be 1D tensor, but got x (" + n2.shape + ").";
              }), C(1 === o2.rank, function() {
                return "y should be 1D tensor, but got y (" + o2.shape + ").";
              }), [4, n2.data()];
            case 1:
              return a2 = r2.sent(), [4, o2.data()];
            case 2:
              for (i2 = r2.sent(), s2 = new Set(i2), u3 = 0, h2 = 0; h2 < a2.length; h2++) s2.has(a2[h2]) || u3++;
              for (c2 = new gt([u3], n2.dtype), l2 = new gt([u3], "int32"), h2 = 0, f2 = 0; h2 < a2.length; h2++) s2.has(a2[h2]) || (c2.values[f2] = a2[h2], l2.values[f2] = h2, f2++);
              return [2, [c2.toTensor(), l2.toTensor()]];
          }
        });
      });
    };
    Xr = Object.freeze({ prepareAndValidate: jr });
    Yr = 30;
    to = Object.freeze({ validateUpdateShape: Qr, validateInput: Jr, calculateShapes: Zr });
    uo = Object.freeze({ assertParamsValid: eo, maskToAxes: no, computeOutShape: ro, startForAxis: oo, stopForAxis: ao, isSliceContinous: io, computeFlatOffset: so });
    go = An({ softmax_: function(t2, e2) {
      void 0 === e2 && (e2 = -1);
      var n2 = mn(t2, "logits", "softmax", "float32");
      if (-1 === e2 && (e2 = n2.rank - 1), e2 !== n2.rank - 1) throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank " + n2.rank + " and dim was " + e2);
      return Lt.runKernelFunc(function(t3, r2) {
        var o2 = t3.softmax(n2, e2);
        return r2([o2]), o2;
      }, { logits: n2 }, function(t3, n3) {
        var r2 = n3[0], o2 = t3.mul(r2);
        return { logits: function() {
          return o2.sub(o2.sum([e2], true).mul(r2));
        } };
      }, "Softmax", { dim: e2 }, [], [true]);
    } });
    yo = An({ logSoftmax_: function(t2, e2) {
      void 0 === e2 && (e2 = -1);
      var n2 = mn(t2, "logits", "logSoftmax");
      if (-1 === e2 && (e2 = n2.rank - 1), e2 !== n2.rank - 1) throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank " + n2.rank + " and axis was " + e2);
      return vo(function(t3, n3) {
        var r2 = t3.max(e2, true), o2 = t3.sub(r2), a2 = o2.toFloat().sub(o2.exp().sum(e2, true).log());
        n3([a2]);
        return { value: a2, gradFunc: function(t4, n4) {
          var r3 = n4[0].exp();
          return t4.sub(t4.sum(e2, true).mul(r3));
        } };
      })(n2);
    } });
    xo = function() {
      function t2(t3, e2) {
        this.backend = t3, this.dataMover = e2, this.data = /* @__PURE__ */ new WeakMap(), this.dataIdsCount = 0;
      }
      return t2.prototype.get = function(t3) {
        return this.data.has(t3) || this.dataMover.moveData(this.backend, t3), this.data.get(t3);
      }, t2.prototype.set = function(t3, e2) {
        this.dataIdsCount++, this.data.set(t3, e2);
      }, t2.prototype.has = function(t3) {
        return this.data.has(t3);
      }, t2.prototype.delete = function(t3) {
        return this.dataIdsCount--, this.data.delete(t3);
      }, t2.prototype.numDataIds = function() {
        return this.dataIdsCount;
      }, t2;
    }();
    bo = function() {
      function t2() {
      }
      return t2.prototype.time = function(t3) {
        return wo("time");
      }, t2.prototype.read = function(t3) {
        return wo("read");
      }, t2.prototype.readSync = function(t3) {
        return wo("readSync");
      }, t2.prototype.numDataIds = function() {
        return wo("numDataIds");
      }, t2.prototype.disposeData = function(t3) {
        return wo("disposeData");
      }, t2.prototype.write = function(t3, e2, n2) {
        return wo("write");
      }, t2.prototype.move = function(t3, e2, n2, r2) {
        return wo("move");
      }, t2.prototype.memory = function() {
        return wo("memory");
      }, t2.prototype.floatPrecision = function() {
        return wo("floatPrecision");
      }, t2.prototype.epsilon = function() {
        return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
      }, t2.prototype.batchMatMul = function(t3, e2, n2, r2) {
        return wo("batchMatMul");
      }, t2.prototype.fusedBatchMatMul = function(t3) {
        t3.a, t3.b, t3.transposeA, t3.transposeB, t3.bias, t3.activation, t3.preluActivationWeights;
        return wo("fusedBatchMatMul");
      }, t2.prototype.slice = function(t3, e2, n2) {
        return wo("slice");
      }, t2.prototype.stridedSlice = function(t3, e2, n2, r2) {
        return wo("stridedSlice");
      }, t2.prototype.unstack = function(t3, e2) {
        return wo("unstack");
      }, t2.prototype.reverse = function(t3, e2) {
        return wo("reverse");
      }, t2.prototype.concat = function(t3, e2) {
        return wo("concat");
      }, t2.prototype.neg = function(t3) {
        return wo("neg");
      }, t2.prototype.add = function(t3, e2) {
        return wo("add");
      }, t2.prototype.addN = function(t3) {
        return wo("addN");
      }, t2.prototype.subtract = function(t3, e2) {
        return wo("subtract");
      }, t2.prototype.multiply = function(t3, e2) {
        return wo("multiply");
      }, t2.prototype.realDivide = function(t3, e2) {
        return wo("realDivide");
      }, t2.prototype.floorDiv = function(t3, e2) {
        return wo("floorDiv");
      }, t2.prototype.sum = function(t3, e2) {
        return wo("sum");
      }, t2.prototype.prod = function(t3, e2) {
        return wo("prod");
      }, t2.prototype.unsortedSegmentSum = function(t3, e2, n2) {
        return wo("unsortedSegmentSum");
      }, t2.prototype.argMin = function(t3, e2) {
        return wo("argMin");
      }, t2.prototype.argMax = function(t3, e2) {
        return wo("argMax");
      }, t2.prototype.equal = function(t3, e2) {
        return wo("equal");
      }, t2.prototype.notEqual = function(t3, e2) {
        return wo("notEqual");
      }, t2.prototype.less = function(t3, e2) {
        return wo("less");
      }, t2.prototype.lessEqual = function(t3, e2) {
        return wo("lessEqual");
      }, t2.prototype.greater = function(t3, e2) {
        return wo("greater");
      }, t2.prototype.greaterEqual = function(t3, e2) {
        return wo("greaterEqual");
      }, t2.prototype.logicalNot = function(t3) {
        return wo("logicalNot");
      }, t2.prototype.logicalAnd = function(t3, e2) {
        return wo("logicalAnd");
      }, t2.prototype.logicalOr = function(t3, e2) {
        return wo("logicalOr");
      }, t2.prototype.where = function(t3) {
        return wo("where");
      }, t2.prototype.select = function(t3, e2, n2) {
        return wo("select");
      }, t2.prototype.topk = function(t3, e2, n2) {
        return wo("topk");
      }, t2.prototype.min = function(t3, e2) {
        return wo("min");
      }, t2.prototype.minimum = function(t3, e2) {
        return wo("minimum");
      }, t2.prototype.mod = function(t3, e2) {
        return wo("mod");
      }, t2.prototype.max = function(t3, e2) {
        return wo("max");
      }, t2.prototype.maximum = function(t3, e2) {
        return wo("maximum");
      }, t2.prototype.all = function(t3, e2) {
        return wo("all");
      }, t2.prototype.any = function(t3, e2) {
        return wo("any");
      }, t2.prototype.squaredDifference = function(t3, e2) {
        return wo("squaredDifference");
      }, t2.prototype.ceil = function(t3) {
        return wo("ceil");
      }, t2.prototype.floor = function(t3) {
        return wo("floor");
      }, t2.prototype.round = function(t3) {
        return wo("round");
      }, t2.prototype.sign = function(t3) {
        return wo("sign");
      }, t2.prototype.isNaN = function(t3) {
        return wo("isNaN");
      }, t2.prototype.isInf = function(t3) {
        return wo("isInf");
      }, t2.prototype.isFinite = function(t3) {
        return wo("isFinite");
      }, t2.prototype.pow = function(t3, e2) {
        return wo("pow");
      }, t2.prototype.exp = function(t3) {
        return wo("exp");
      }, t2.prototype.expm1 = function(t3) {
        return wo("expm1");
      }, t2.prototype.softmax = function(t3, e2) {
        return wo("softmax");
      }, t2.prototype.log = function(t3) {
        return wo("log");
      }, t2.prototype.log1p = function(t3) {
        return wo("log1p");
      }, t2.prototype.sqrt = function(t3) {
        return wo("sqrt");
      }, t2.prototype.rsqrt = function(t3) {
        return wo("rsqrt");
      }, t2.prototype.square = function(t3) {
        return wo("square");
      }, t2.prototype.reciprocal = function(t3) {
        return wo("reciprocal");
      }, t2.prototype.relu = function(t3) {
        return wo("relu");
      }, t2.prototype.relu6 = function(t3) {
        return wo("relu6");
      }, t2.prototype.prelu = function(t3, e2) {
        return wo("prelu");
      }, t2.prototype.elu = function(t3) {
        return wo("elu");
      }, t2.prototype.eluDer = function(t3, e2) {
        return wo("eluDer");
      }, t2.prototype.selu = function(t3) {
        return wo("selu");
      }, t2.prototype.int = function(t3) {
        return wo("int");
      }, t2.prototype.clip = function(t3, e2, n2) {
        return wo("clip");
      }, t2.prototype.abs = function(t3) {
        return wo("abs");
      }, t2.prototype.complexAbs = function(t3) {
        return wo("complexAbs");
      }, t2.prototype.sigmoid = function(t3) {
        return wo("sigmoid");
      }, t2.prototype.softplus = function(t3) {
        return wo("softplus");
      }, t2.prototype.sin = function(t3) {
        return wo("sin");
      }, t2.prototype.cos = function(t3) {
        return wo("cos");
      }, t2.prototype.tan = function(t3) {
        return wo("tan");
      }, t2.prototype.asin = function(t3) {
        return wo("asin");
      }, t2.prototype.acos = function(t3) {
        return wo("acos");
      }, t2.prototype.atan = function(t3) {
        return wo("atan");
      }, t2.prototype.atan2 = function(t3, e2) {
        return wo("atan2");
      }, t2.prototype.sinh = function(t3) {
        return wo("sinh");
      }, t2.prototype.cosh = function(t3) {
        return wo("cosh");
      }, t2.prototype.tanh = function(t3) {
        return wo("tanh");
      }, t2.prototype.asinh = function(t3) {
        return wo("asinh");
      }, t2.prototype.acosh = function(t3) {
        return wo("acosh");
      }, t2.prototype.atanh = function(t3) {
        return wo("atanh");
      }, t2.prototype.erf = function(t3) {
        return wo("erf");
      }, t2.prototype.step = function(t3, e2) {
        return wo("step");
      }, t2.prototype.fusedConv2d = function(t3) {
        t3.input, t3.filter, t3.convInfo, t3.bias, t3.activation, t3.preluActivationWeights;
        return wo("fusedConv2d");
      }, t2.prototype.conv2d = function(t3, e2, n2) {
        return wo("conv2d");
      }, t2.prototype.conv2dDerInput = function(t3, e2, n2) {
        return wo("conv2dDerInput");
      }, t2.prototype.conv2dDerFilter = function(t3, e2, n2) {
        return wo("conv2dDerFilter");
      }, t2.prototype.fusedDepthwiseConv2D = function(t3) {
        t3.input, t3.filter, t3.convInfo, t3.bias, t3.activation, t3.preluActivationWeights;
        return wo("fusedDepthwiseConv2D");
      }, t2.prototype.depthwiseConv2D = function(t3, e2, n2) {
        return wo("depthwiseConv2D");
      }, t2.prototype.depthwiseConv2DDerInput = function(t3, e2, n2) {
        return wo("depthwiseConv2DDerInput");
      }, t2.prototype.depthwiseConv2DDerFilter = function(t3, e2, n2) {
        return wo("depthwiseConv2DDerFilter");
      }, t2.prototype.conv3d = function(t3, e2, n2) {
        return wo("conv3d");
      }, t2.prototype.conv3dDerInput = function(t3, e2, n2) {
        return wo("conv3dDerInput");
      }, t2.prototype.conv3dDerFilter = function(t3, e2, n2) {
        return wo("conv3dDerFilter");
      }, t2.prototype.maxPool = function(t3, e2) {
        return wo("maxPool");
      }, t2.prototype.maxPoolBackprop = function(t3, e2, n2, r2) {
        return wo("maxPoolBackprop");
      }, t2.prototype.avgPool = function(t3, e2) {
        return wo("avgPool");
      }, t2.prototype.avgPoolBackprop = function(t3, e2, n2) {
        return wo("avgPoolBackprop");
      }, t2.prototype.avgPool3d = function(t3, e2) {
        return wo("avgPool3d");
      }, t2.prototype.avgPool3dBackprop = function(t3, e2, n2) {
        return wo("avgPool3dBackprop");
      }, t2.prototype.maxPool3d = function(t3, e2) {
        return wo("maxPool3d");
      }, t2.prototype.maxPool3dBackprop = function(t3, e2, n2, r2) {
        return wo("maxPool3dBackprop");
      }, t2.prototype.reshape = function(t3, e2) {
        return wo("reshape");
      }, t2.prototype.cast = function(t3, e2) {
        return wo("cast");
      }, t2.prototype.tile = function(t3, e2) {
        return wo("tile");
      }, t2.prototype.pad = function(t3, e2, n2) {
        return wo("pad");
      }, t2.prototype.transpose = function(t3, e2) {
        return wo("transpose");
      }, t2.prototype.gather = function(t3, e2, n2) {
        return wo("gather");
      }, t2.prototype.gatherND = function(t3, e2) {
        return wo("gatherND");
      }, t2.prototype.scatterND = function(t3, e2, n2) {
        return wo("scatterND");
      }, t2.prototype.batchToSpaceND = function(t3, e2, n2) {
        return wo("batchToSpaceND");
      }, t2.prototype.spaceToBatchND = function(t3, e2, n2) {
        return wo("spaceToBatchND");
      }, t2.prototype.resizeBilinear = function(t3, e2, n2, r2) {
        return wo("resizeBilinear");
      }, t2.prototype.resizeBilinearBackprop = function(t3, e2, n2) {
        return wo("resizeBilinearBackprop");
      }, t2.prototype.resizeNearestNeighbor = function(t3, e2, n2, r2) {
        return wo("resizeNearestNeighbor");
      }, t2.prototype.resizeNearestNeighborBackprop = function(t3, e2, n2) {
        return wo("resizeNearestNeighborBackprop");
      }, t2.prototype.batchNormalization = function(t3, e2, n2, r2, o2, a2) {
        return wo("batchNormalization");
      }, t2.prototype.localResponseNormalization4D = function(t3, e2, n2, r2, o2) {
        return wo("localResponseNormalization4D");
      }, t2.prototype.LRNGrad = function(t3, e2, n2, r2, o2, a2, i2) {
        return wo("LRNGrad");
      }, t2.prototype.multinomial = function(t3, e2, n2, r2) {
        return wo("multinomial");
      }, t2.prototype.oneHot = function(t3, e2, n2, r2) {
        return wo("oneHot");
      }, t2.prototype.cumsum = function(t3, e2, n2, r2) {
        return wo("cumsum");
      }, t2.prototype.nonMaxSuppression = function(t3, e2, n2, r2, o2) {
        return wo("nonMaxSuppression");
      }, t2.prototype.fft = function(t3) {
        return wo("fft");
      }, t2.prototype.ifft = function(t3) {
        return wo("ifft");
      }, t2.prototype.complex = function(t3, e2) {
        return wo("complex");
      }, t2.prototype.real = function(t3) {
        return wo("real");
      }, t2.prototype.imag = function(t3) {
        return wo("imag");
      }, t2.prototype.cropAndResize = function(t3, e2, n2, r2, o2, a2) {
        return wo("cropAndResize");
      }, t2.prototype.depthToSpace = function(t3, e2, n2) {
        return wo("depthToSpace");
      }, t2.prototype.split = function(t3, e2, n2) {
        return wo("split");
      }, t2.prototype.sparseToDense = function(t3, e2, n2, r2) {
        return wo("sparseToDense");
      }, t2.prototype.diag = function(t3) {
        return wo("diag");
      }, t2.prototype.fill = function(t3, e2, n2) {
        return wo("fill");
      }, t2.prototype.onesLike = function(t3) {
        return wo("onesLike");
      }, t2.prototype.zerosLike = function(t3) {
        return wo("zerosLike");
      }, t2.prototype.linspace = function(t3, e2, n2) {
        return wo("linspace");
      }, t2.prototype.dispose = function() {
        return wo("dispose");
      }, t2;
    }();
    Uo = Object.freeze({ castTensor: Po, reshapeTensor: Lo, linspaceImpl: Wo, upcastType: Dt, axesAreInnerMostDims: yn, combineLocations: xn, computeOutAndReduceShapes: bn, expandShapeToKeepDim: wn, assertAxesAreInnerMostDims: Cn, getAxesPermutation: En, getUndoAxesPermutation: Rn, getInnerMostAxes: In, getBroadcastDims: Co, getReductionAxes: Eo, assertAndGetBroadcastShape: Ro, assertParamsConsistent: kn, computeOutShape: Sn, computePool2DInfo: Io, computePool3DInfo: ko, computeConv2DInfo: So, computeConv3DInfo: Ao, computeDefaultPad: Do, tupleValuesAreOne: Oo, eitherStridesOrDilationsAreOne: Mo, convertConv2DDataFormat: Bo, PARALLELIZE_THRESHOLD: Yr, computeOptimalWindowSize: $r });
    ra = function(t2, e2) {
      this.outputShape = [], this.outputShape = t2, this.variableNames = e2.map(function(t3, e3) {
        return "T" + e3;
      });
      var n2 = [];
      this.variableNames.forEach(function(t3) {
        n2.push("float v" + t3 + " = get" + t3 + "AtOutCoords();");
      });
      var r2 = this.variableNames.map(function(t3) {
        return "v" + t3;
      }).join(" + ");
      this.userCode = "\n      void main() {\n        " + n2.join("\n        ") + "\n\n        float result = " + r2 + ";\n        setOutput(result);\n      }\n    ";
    };
    oa = function(t2, e2) {
      this.outputShape = [], this.packedInputs = true, this.packedOutput = true, this.outputShape = t2, this.variableNames = e2.map(function(t3, e3) {
        return "T" + e3;
      });
      var n2 = [];
      this.variableNames.forEach(function(t3) {
        n2.push("vec4 v" + t3 + " = get" + t3 + "AtOutCoords();");
      });
      var r2 = this.variableNames.map(function(t3) {
        return "v" + t3;
      }).join(" + ");
      this.userCode = "\n      void main() {\n        " + n2.join("\n        ") + "\n\n        vec4 result = " + r2 + ";\n        setOutput(result);\n      }\n    ";
    };
    aa = function(t2, e2, n2) {
      this.variableNames = ["A"];
      var r2 = t2.windowSize, o2 = t2.batchSize, a2 = t2.inSize, i2 = Math.ceil(a2 / r2);
      n2 || this.variableNames.push("bestIndicesA"), this.outputShape = [o2, i2];
      var s2 = "max" === e2 ? ">" : "<", u3 = n2 ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
      this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + r2 + ";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < " + r2 + "; i++) {\n          int inIdx = " + u3 + ";\n          float candidate = getA(batch, inIdx);\n          if (candidate " + s2 + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ";
    };
    ha = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";
    va = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
    ma = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
    ga = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
    ya = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";
    Ra = function(t2, e2, n2, r2) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, C(t2.length > 2, function() {
        return "Packed arg" + (n2.charAt(0).toUpperCase() + n2.slice(1)) + " supports only inputs with rank above 2.";
      });
      var o2 = t2[t2.length - 1], a2 = Math.ceil(o2 / e2);
      this.outputShape = t2.slice(0, -1), a2 > 1 && this.outputShape.push(a2), r2 || this.variableNames.push("bestIndicesA");
      var i2, s2, u3 = this.outputShape, c2 = u3.length, l2 = wa(c2), h2 = sa("coords", c2);
      if (1 === a2) {
        var f2 = wa(s2 = c2 + 1);
        i2 = "\n        " + f2 + " sourceLocR = " + f2 + "(" + h2.join() + ", 0);\n        ++" + h2[c2 - 1] + ";\n        " + f2 + " sourceLocG = " + f2 + "(" + h2.join() + ", 0);\n        ++" + h2[c2 - 2] + ";\n        " + f2 + " sourceLocA = " + f2 + "(" + h2.join() + ", 0);\n        --" + h2[c2 - 1] + ";\n        " + f2 + " sourceLocB = " + f2 + "(" + h2.join() + ", 0);\n        --" + h2[c2 - 2] + ";";
      } else s2 = c2, i2 = "\n        " + l2 + " sourceLocR = coords;\n        ++" + h2[c2 - 1] + ";\n        " + l2 + " sourceLocG = coords;\n        ++" + h2[c2 - 2] + ";\n        " + l2 + " sourceLocA = coords;\n        --" + h2[c2 - 1] + ";\n        " + l2 + " sourceLocB = coords;\n        --" + h2[c2 - 2] + ";";
      var d2 = ["x", "y", "z", "w", "u", "v"].slice(0, s2), p2 = "." + d2[s2 - 1], v = d2.map(function(t3) {
        return "int " + t3;
      }), m = sa("sourceLocR", s2 - 1).concat("inIdx.r"), g2 = sa("sourceLocG", s2 - 1).concat("inIdx.g"), y2 = sa("sourceLocB", s2 - 1).concat("inIdx.b"), x2 = sa("sourceLocA", s2 - 1).concat("inIdx.a"), b2 = "max" === n2 ? "greaterThan" : "lessThan", w2 = r2 ? "" : "\n          inIdx = round(vec4(getBestIndicesAChannel(" + m.join() + "),\n                             getBestIndicesAChannel(" + g2.join() + "),\n                             getBestIndicesAChannel(" + y2.join() + "),\n                             getBestIndicesAChannel(" + x2.join() + ")));", E2 = "vec4(\n            getAChannel(" + m.join() + "),\n            hasNextCol ? getAChannel(" + g2.join() + ") : 0.,\n            hasNextRow ? getAChannel(" + y2.join() + ") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(" + x2.join() + ") : 0.)", R2 = r2 ? "" : "\n      float getBestIndicesAChannel(" + v.join() + ") {\n        return getChannel(getBestIndicesA(" + d2.join() + "),\n                                          vec2(" + d2.slice(-2).join() + "));\n      }";
      this.userCode = "\n      float getAChannel(" + v.join() + ") {\n        return getChannel(getA(" + d2.join() + "),\n                               vec2(" + d2.slice(-2).join() + "));\n      }\n      " + R2 + "\n      void main() {\n        " + l2 + " coords = getOutputCoords();\n        bool hasNextCol = " + h2[c2 - 1] + " < " + (u3[c2 - 1] - 1) + ";\n        bool hasNextRow = " + h2[c2 - 2] + " < " + (u3[c2 - 2] - 1) + ";\n        " + i2 + "\n        ivec4 srcIdx = ivec4(sourceLocR" + p2 + ", sourceLocG" + p2 + ",\n          sourceLocB" + p2 + ", sourceLocA" + p2 + ") * " + e2 + ";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = " + E2 + ";\n\n        for (int i = 0; i < " + e2 + "; i++) {\n          inIdx = srcIdx;\n          " + w2 + "\n          vec4 candidate = " + E2 + ";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(" + b2 + "(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ";
    };
    Ia = function(t2) {
      this.variableNames = ["dy"], this.outputShape = t2.inShape;
      var e2 = t2.filterHeight, n2 = t2.filterWidth, r2 = t2.strideHeight, o2 = t2.strideWidth, a2 = t2.dilationHeight, i2 = t2.dilationWidth, s2 = t2.effectiveFilterHeight, u3 = t2.effectiveFilterWidth, c2 = s2 - 1 - t2.padInfo.top, l2 = u3 - 1 - t2.padInfo.left, h2 = 1 / (e2 * n2);
      this.userCode = "\n      const ivec2 pads = ivec2(" + c2 + ", " + l2 + ");\n      const float avgMultiplier = float(" + h2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + s2 + ";\n            wR += " + a2 + ") {\n          float dyR = float(dyRCorner + wR) / " + r2 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + u3 + ";\n            wC+= " + i2 + ") {\n            float dyC = float(dyCCorner + wC) / " + o2 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
    ka = function(t2) {
      this.variableNames = ["dy"], this.outputShape = t2.inShape;
      var e2 = t2.filterDepth, n2 = t2.filterHeight, r2 = t2.filterWidth, o2 = t2.strideDepth, a2 = t2.strideHeight, i2 = t2.strideWidth, s2 = t2.dilationDepth, u3 = t2.dilationHeight, c2 = t2.dilationWidth, l2 = t2.effectiveFilterDepth, h2 = t2.effectiveFilterHeight, f2 = t2.effectiveFilterWidth, d2 = l2 - 1 - t2.padInfo.front, p2 = h2 - 1 - t2.padInfo.top, v = f2 - 1 - t2.padInfo.left, m = 1 / (e2 * n2 * r2);
      this.userCode = "\n      const ivec3 pads = ivec3(" + d2 + ", " + p2 + ", " + v + ");\n      const float avgMultiplier = float(" + m + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + l2 + ";\n            wD += " + s2 + ") {\n          float dyD = float(dyDCorner + wD) / " + o2 + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t2.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + h2 + ";\n              wR += " + u3 + ") {\n            float dyR = float(dyRCorner + wR) / " + a2 + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + f2 + ";\n                wC += " + c2 + ") {\n              float dyC = float(dyCCorner + wC) / " + i2 + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
    Sa = function(t2, e2, n2, r2, o2, a2) {
      this.outputShape = [], this.variableNames = ["x", "mean", "variance"], Ro(t2, e2), Ro(t2, n2);
      var i2 = "0.0";
      null != r2 && (Ro(t2, r2), this.variableNames.push("offset"), i2 = "getOffsetAtOutCoords()");
      var s2 = "1.0";
      null != o2 && (Ro(t2, o2), this.variableNames.push("scale"), s2 = "getScaleAtOutCoords()"), this.outputShape = t2, this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + i2 + ";\n        float scale = " + s2 + ";\n        float inv = scale * inversesqrt(variance + float(" + a2 + "));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ";
    };
    Aa = function(t2, e2, n2, r2, o2, a2) {
      this.packedInputs = true, this.packedOutput = true, this.variableNames = ["x", "mean", "variance"], Ro(t2, e2), Ro(t2, n2);
      var i2 = "vec4(0.0)";
      null != r2 && (Ro(t2, r2), this.variableNames.push("offset"), i2 = "getOffsetAtOutCoords()");
      var s2 = "vec4(1.0)";
      null != o2 && (Ro(t2, o2), this.variableNames.push("scale"), s2 = "getScaleAtOutCoords()"), this.outputShape = t2, this.userCode = "\n      void main() {\n        vec4 offset = " + i2 + ";\n        vec4 scale = " + s2 + ";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(" + a2 + "));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ";
    };
    Da = "return areal * breal - aimag * bimag;";
    Ta = "return areal * bimag + aimag * breal;";
    Na = function(t2, e2, n2) {
      this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = Ro(e2, n2), this.userCode = "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        " + t2 + "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ";
    };
    Fa = "return a + b;";
    _a = "return a - b;";
    Oa = "return a * b;";
    Ma = "return (a < 0.) ? b * a : a;";
    Ba = function(t2, e2, n2) {
      this.variableNames = ["A", "B"], this.outputShape = Ro(e2, n2), this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + t2 + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ";
    };
    Pa = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
    La = function(t2, e2, n2, r2) {
      void 0 === r2 && (r2 = false), this.variableNames = ["A", "B"], this.supportsBroadcasting = true, this.packedInputs = true, this.packedOutput = true, this.outputShape = Ro(e2, n2);
      var o2 = this.outputShape.length, a2 = "";
      if (r2) if (0 === o2 || 1 === k(this.outputShape)) a2 = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";
      else if (a2 = "\n          " + wa(o2) + " coords = getOutputCoords();\n        ", 1 === o2) a2 += "\n            result.y = (coords + 1) >= " + this.outputShape[0] + " ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";
      else {
        var i2 = sa("coords", o2);
        a2 += "\n            bool nextRowOutOfBounds =\n              (" + i2[o2 - 2] + " + 1) >= " + this.outputShape[o2 - 2] + ";\n            bool nextColOutOfBounds =\n              (" + i2[o2 - 1] + " + 1) >= " + this.outputShape[o2 - 1] + ";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ";
      }
      this.userCode = "\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        " + t2 + "\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        " + a2 + "\n\n        setOutput(result);\n      }\n    ";
    };
    Wa = function() {
      function t2(t3) {
        this.variableNames = ["A"], this.outputShape = t3, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    ";
      }
      return t2.prototype.getCustomSetupFunc = function(t3, e2) {
        var n2 = this;
        return function(r2, o2) {
          null == n2.minLoc && (n2.minLoc = r2.getUniformLocationNoThrow(o2, "minVal"), n2.maxLoc = r2.getUniformLocationNoThrow(o2, "maxVal")), r2.gl.uniform1f(n2.minLoc, t3), r2.gl.uniform1f(n2.maxLoc, e2);
        };
      }, t2;
    }();
    Ua = function() {
      function t2(t3) {
        this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t3, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    ";
      }
      return t2.prototype.getCustomSetupFunc = function(t3, e2) {
        var n2 = this;
        return function(r2, o2) {
          null == n2.minLoc && (n2.minLoc = r2.getUniformLocationNoThrow(o2, "minVal"), n2.maxLoc = r2.getUniformLocationNoThrow(o2, "maxVal")), r2.gl.uniform1f(n2.minLoc, t3), r2.gl.uniform1f(n2.maxLoc, e2);
        };
      }, t2;
    }();
    Va = function(t2) {
      this.variableNames = ["real", "imag"], this.outputShape = t2, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    ";
    };
    za = function(t2) {
      this.outputShape = [], this.outputShape = Sn(t2, 1), this.variableNames = t2.map(function(t3, e3) {
        return "T" + e3;
      });
      var e2 = new Array(t2.length - 1);
      e2[0] = t2[0][1];
      for (var n2 = 1; n2 < e2.length; n2++) e2[n2] = e2[n2 - 1] + t2[n2][1];
      var r2 = ["if (yC < " + e2[0] + ") setOutput(getT0(yR, yC));"];
      for (n2 = 1; n2 < e2.length; n2++) {
        var o2 = e2[n2 - 1];
        r2.push("else if (yC < " + e2[n2] + ") setOutput(getT" + n2 + "(yR, yC-" + o2 + "));");
      }
      var a2 = e2.length, i2 = e2[e2.length - 1];
      r2.push("else setOutput(getT" + a2 + "(yR, yC-" + i2 + "));"), this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        " + r2.join("\n        ") + "\n      }\n    ";
    };
    Ga = function(t2, e2) {
      this.packedInputs = true, this.packedOutput = true, this.outputShape = [], this.outputShape = Sn(t2, e2);
      var n2 = this.outputShape, r2 = n2.length, o2 = wa(r2), a2 = sa("coords", r2), i2 = ["x", "y", "z", "w", "u", "v"].slice(0, r2);
      this.variableNames = t2.map(function(t3, e3) {
        return "T" + e3;
      });
      var s2 = new Array(t2.length - 1);
      s2[0] = t2[0][e2];
      for (var u3 = 1; u3 < s2.length; u3++) s2[u3] = s2[u3 - 1] + t2[u3][e2];
      var c2 = i2[e2], l2 = i2.slice(-2), h2 = i2.join(), f2 = "if (" + c2 + " < " + s2[0] + ") {\n        return getChannel(\n            getT0(" + h2 + "), vec2(" + l2.join() + "));\n        }";
      for (u3 = 1; u3 < s2.length; u3++) {
        var d2 = s2[u3 - 1];
        f2 += "\n        if (" + c2 + " < " + s2[u3] + "  && " + c2 + " >= " + s2[u3 - 1] + ") {\n          return getChannel(\n            getT" + u3 + "(" + Ha(i2, c2, d2) + "),\n            vec2(" + Ha(l2, c2, d2) + "));\n        }";
      }
      var p2 = s2.length, v = s2[s2.length - 1];
      f2 += "\n        return getChannel(\n          getT" + p2 + "(" + Ha(i2, c2, v) + "),\n          vec2(" + Ha(l2, c2, v) + "));", this.userCode = "\n      float getValue(" + i2.map(function(t3) {
        return "int " + t3;
      }) + ") {\n        " + f2 + "\n      }\n\n      void main() {\n        " + o2 + " coords = getOutputCoords();\n        vec4 result = vec4(getValue(" + a2 + "), 0., 0., 0.);\n\n        " + a2[r2 - 1] + " = " + a2[r2 - 1] + " + 1;\n        if (" + a2[r2 - 1] + " < " + n2[r2 - 1] + ") {\n          result.g = getValue(" + a2 + ");\n        }\n\n        " + a2[r2 - 2] + " = " + a2[r2 - 2] + " + 1;\n        if (" + a2[r2 - 2] + " < " + n2[r2 - 2] + ") {\n          result.a = getValue(" + a2 + ");\n        }\n\n        " + a2[r2 - 1] + " = " + a2[r2 - 1] + " - 1;\n        if (" + a2[r2 - 2] + " < " + n2[r2 - 2] + " &&\n            " + a2[r2 - 1] + " < " + n2[r2 - 1] + ") {\n          result.b = getValue(" + a2 + ");\n        }\n        setOutput(result);\n      }\n    ";
    };
    qa = function(t2) {
      this.variableNames = ["x", "dy"], this.outputShape = t2.filterShape;
      var e2 = t2.strideHeight, n2 = t2.strideWidth, r2 = t2.padInfo.top, o2 = t2.padInfo.left, a2 = "channelsLast" === t2.dataFormat;
      this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t2.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t2.outHeight + "; yR++) {\n            int xR = wR + yR * " + e2 + " - " + r2 + ";\n\n            if (xR < 0 || xR >= " + t2.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t2.outWidth + "; yC++) {\n              int xC = wC + yC * " + n2 + " - " + o2 + ";\n\n              if (xC < 0 || xC >= " + t2.inWidth + ") {\n                continue;\n              }\n\n              if (" + a2 + ") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
    Ka = function(t2) {
      this.variableNames = ["dy", "W"], this.outputShape = t2.inShape;
      var e2 = t2.filterHeight, n2 = t2.filterWidth, r2 = t2.strideHeight, o2 = t2.strideWidth, a2 = "channelsLast" === t2.dataFormat, i2 = e2 - 1 - t2.padInfo.top, s2 = n2 - 1 - t2.padInfo.left, u3 = a2 ? 1 : 2, c2 = a2 ? 2 : 3, l2 = a2 ? 3 : 1;
      this.userCode = "\n      const ivec2 pads = ivec2(" + i2 + ", " + s2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[" + l2 + "];\n\n        ivec2 dyCorner = ivec2(coords[" + u3 + "], coords[" + c2 + "]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + e2 + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r2 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e2 + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n2 + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + o2 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n2 + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + t2.outChannels + "; d2++) {\n\n              if (" + a2 + ") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
    ja = function(t2) {
      this.variableNames = ["x", "dy"], this.outputShape = t2.filterShape;
      var e2 = t2.strideDepth, n2 = t2.strideHeight, r2 = t2.strideWidth, o2 = t2.padInfo.front, a2 = t2.padInfo.top, i2 = t2.padInfo.left;
      this.userCode = "\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t2.batchSize + "; b++) {\n          for (int yF = 0; yF < " + t2.outDepth + "; yF++) {\n            int xF = wF + yF * " + e2 + " - " + o2 + ";\n\n            if (xF < 0 || xF >= " + t2.inDepth + ") {\n              continue;\n            }\n\n            for (int yR = 0; yR < " + t2.outHeight + "; yR++) {\n              int xR = wR + yR * " + n2 + " - " + a2 + ";\n\n              if (xR < 0 || xR >= " + t2.inHeight + ") {\n                continue;\n              }\n\n              for (int yC = 0; yC < " + t2.outWidth + "; yC++) {\n                int xC = wC + yC * " + r2 + " - " + i2 + ";\n\n                if (xC < 0 || xC >= " + t2.inWidth + ") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
    Xa = function(t2) {
      this.variableNames = ["dy", "W"], this.outputShape = t2.inShape;
      var e2 = t2.filterDepth, n2 = t2.filterHeight, r2 = t2.filterWidth, o2 = t2.strideDepth, a2 = t2.strideHeight, i2 = t2.strideWidth, s2 = e2 - 1 - t2.padInfo.front, u3 = n2 - 1 - t2.padInfo.top, c2 = r2 - 1 - t2.padInfo.left;
      this.userCode = "\n      const ivec3 pads = ivec3(" + s2 + ", " + u3 + ", " + c2 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + e2 + "; wF++) {\n          float dyF = float(dyFCorner + wF) / " + o2 + ".0;\n\n          if (dyF < 0.0 || dyF >= " + t2.outDepth + ".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = " + e2 + " - 1 - wF;\n\n          for (int wR = 0; wR < " + n2 + "; wR++) {\n            float dyR = float(dyRCorner + wR) / " + a2 + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = " + n2 + " - 1 - wR;\n\n            for (int wC = 0; wC < " + r2 + "; wC++) {\n              float dyC = float(dyCCorner + wC) / " + i2 + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = " + r2 + " - 1 - wC;\n\n              for (int d2 = 0; d2 < " + t2.outChannels + "; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
    Ya = function(t2) {
      this.variableNames = ["x", "dy"], this.outputShape = t2.filterShape;
      var e2 = t2.strideHeight, n2 = t2.strideWidth, r2 = t2.padInfo.top, o2 = t2.padInfo.left, a2 = t2.outChannels / t2.inChannels;
      this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * " + a2 + " + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < " + t2.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t2.outHeight + "; yR++) {\n            int xR = wR + yR * " + e2 + " - " + r2 + ";\n\n            if (xR < 0 || xR >= " + t2.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t2.outWidth + "; yC++) {\n              int xC = wC + yC * " + n2 + " - " + o2 + ";\n\n              if (xC < 0 || xC >= " + t2.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
    $a = function(t2) {
      this.variableNames = ["dy", "W"], this.outputShape = t2.inShape;
      var e2 = t2.filterHeight, n2 = t2.filterWidth, r2 = t2.strideHeight, o2 = t2.strideWidth, a2 = e2 - 1 - t2.padInfo.top, i2 = n2 - 1 - t2.padInfo.left, s2 = t2.outChannels / t2.inChannels;
      this.userCode = "\n      const ivec2 pads = ivec2(" + a2 + ", " + i2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < " + e2 + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r2 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e2 + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n2 + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + o2 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n2 + " - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < " + s2 + "; dm++) {\n              int d2 = d1 * " + s2 + " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
    Qa = function(t2, e2, n2, r2) {
      void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = null), void 0 === r2 && (r2 = false), this.variableNames = ["x", "W"], this.outputShape = t2.outShape;
      var o2 = t2.padInfo.top, a2 = t2.padInfo.left, i2 = t2.strideHeight, s2 = t2.strideWidth, u3 = t2.dilationHeight, c2 = t2.dilationWidth, l2 = t2.filterHeight, h2 = t2.filterWidth, f2 = 4 * Math.floor(t2.inChannels / 4), d2 = t2.inChannels % 4, p2 = "channelsLast" === t2.dataFormat, v = p2 ? 1 : 2, m = p2 ? 2 : 3, g2 = p2 ? 3 : 1, y2 = "", x2 = "";
      n2 && (y2 = r2 ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n2 + "\n        }" : "\n          float activation(float x) {\n            " + n2 + "\n          }\n        ", x2 = "result = activation(result);");
      var b2 = e2 ? "result += getBiasAtOutCoords();" : "";
      e2 && this.variableNames.push("bias"), r2 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + y2 + "\n\n      const ivec2 strides = ivec2(" + i2 + ", " + s2 + ");\n      const ivec2 pads = ivec2(" + o2 + ", " + a2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[" + g2 + "];\n\n        ivec2 xRCCorner =\n            ivec2(coords[" + v + "], coords[" + m + "]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + l2 + "; wR++) {\n          int xR = xRCorner + wR * " + u3 + ";\n\n          if (xR < 0 || xR >= " + t2.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + h2 + "; wC++) {\n            int xC = xCCorner + wC * " + c2 + ";\n\n            if (xC < 0 || xC >= " + t2.inWidth + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + f2 + "; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (" + p2 + ") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (" + (1 === d2) + ") {\n\n              if (" + p2 + ") {\n                dotProd +=\n                    getX(batch, xR, xC, " + f2 + ") *\n                    getW(wR, wC, " + f2 + ", d2);\n              } else {\n                dotProd +=\n                    getX(batch, " + f2 + ", xR, xC) *\n                    getW(wR, wC, " + f2 + ", d2);\n              }\n\n            } else if (" + (2 === d2) + ") {\n              vec2 wValues = vec2(\n                getW(wR, wC, " + f2 + ", d2),\n                getW(wR, wC, " + f2 + " + 1, d2)\n              );\n\n              if (" + p2 + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, " + f2 + "),\n                  getX(batch, xR, xC, " + f2 + " + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, " + f2 + ", xR, xC),\n                  getX(batch, " + f2 + " + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (" + (3 === d2) + ") {\n              vec3 wValues = vec3(\n                getW(wR, wC, " + f2 + ", d2),\n                getW(wR, wC, " + f2 + " + 1, d2),\n                getW(wR, wC, " + f2 + " + 2, d2)\n              );\n\n              if (" + p2 + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, " + f2 + "),\n                  getX(batch, xR, xC, " + f2 + " + 1),\n                  getX(batch, xR, xC, " + f2 + " + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, " + f2 + ", xR, xC),\n                  getX(batch, " + f2 + " + 1, xR, xC),\n                  getX(batch, " + f2 + " + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        " + b2 + "\n        " + x2 + "\n        setOutput(result);\n      }\n    ";
    };
    Ja = function(t2) {
      this.variableNames = ["x", "W"], this.outputShape = t2.outShape;
      var e2 = t2.padInfo.front, n2 = t2.padInfo.top, r2 = t2.padInfo.left, o2 = t2.strideDepth, a2 = t2.strideHeight, i2 = t2.strideWidth, s2 = t2.dilationDepth, u3 = t2.dilationHeight, c2 = t2.dilationWidth, l2 = t2.filterDepth, h2 = t2.filterHeight, f2 = t2.filterWidth, d2 = 4 * Math.floor(t2.inChannels / 4), p2 = t2.inChannels % 4;
      this.userCode = "\n      const ivec3 strides = ivec3(" + o2 + ", " + a2 + ", " + i2 + ");\n      const ivec3 pads = ivec3(" + e2 + ", " + n2 + ", " + r2 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + l2 + "; wF++) {\n          int xF = xFCorner + wF * " + s2 + ";\n\n          if (xF < 0 || xF >= " + t2.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h2 + "; wR++) {\n            int xR = xRCorner + wR * " + u3 + ";\n\n            if (xR < 0 || xR >= " + t2.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + f2 + "; wC++) {\n              int xC = xCCorner + wC * " + c2 + ";\n\n              if (xC < 0 || xC >= " + t2.inWidth + ") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < " + d2 + "; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (" + (1 === p2) + ") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, " + d2 + ") *\n                  getW(wF, wR, wC, " + d2 + ", d2);\n              } else if (" + (2 === p2) + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, " + d2 + "),\n                  getX(batch, xF, xR, xC, " + d2 + " + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, " + d2 + ", d2),\n                  getW(wF, wR, wC, " + d2 + " + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (" + (3 === p2) + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, " + d2 + "),\n                  getX(batch, xF, xR, xC, " + d2 + " + 1),\n                  getX(batch, xF, xR, xC, " + d2 + " + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, " + d2 + ", d2),\n                  getW(wF, wR, wC, " + d2 + " + 1, d2),\n                  getW(wF, wR, wC, " + d2 + " + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
    Za = function(t2, e2, n2, r2) {
      void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = null), void 0 === r2 && (r2 = false), this.variableNames = ["x", "W"], this.outputShape = t2.outShape;
      var o2 = t2.inHeight, a2 = t2.inWidth, i2 = t2.padInfo.top, s2 = t2.padInfo.left, u3 = t2.strideHeight, c2 = t2.strideWidth, l2 = t2.dilationHeight, h2 = t2.dilationWidth, f2 = t2.filterHeight, d2 = t2.filterWidth, p2 = t2.outChannels / t2.inChannels, v = "", m = "";
      n2 && (v = r2 ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n2 + "\n        }" : "\n          float activation(float x) {\n            " + n2 + "\n          }\n        ", m = "result = activation(result);");
      var g2 = e2 ? "result += getBiasAtOutCoords();" : "";
      e2 && this.variableNames.push("bias"), r2 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + v + "\n\n      const ivec2 strides = ivec2(" + u3 + ", " + c2 + ");\n      const ivec2 pads = ivec2(" + i2 + ", " + s2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + p2 + ";\n        int q = d2 - d1 * " + p2 + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + f2 + "; wR++) {\n          int xR = xRCorner + wR * " + l2 + ";\n\n          if (xR < 0 || xR >= " + o2 + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + d2 + "; wC++) {\n            int xC = xCCorner + wC * " + h2 + ";\n\n            if (xC < 0 || xC >= " + a2 + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        " + g2 + "\n        " + m + "\n        setOutput(result);\n      }\n    ";
    };
    ti = function(t2, e2, n2, r2) {
      void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = null), void 0 === r2 && (r2 = false), this.variableNames = ["x", "W"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t2.outShape;
      for (var o2 = t2.inHeight, a2 = t2.inWidth, i2 = t2.padInfo.top, s2 = t2.padInfo.left, u3 = t2.strideHeight, c2 = t2.strideWidth, l2 = t2.dilationHeight, h2 = t2.dilationWidth, f2 = t2.filterHeight, d2 = t2.filterWidth, p2 = d2, v = "int xR; int xC; int xCOffset;", m = 0; m < f2; m++) for (var g2 = 0; g2 < d2; g2++) v += "\n          vec4 xTexelR" + m + "C" + 2 * g2 + " = vec4(0.);\n          vec4 wR" + m + "C" + g2 + " = vec4(0.);\n          vec4 xR" + m + "C" + g2 + " = vec4(0.);";
      for (m = 0; m < f2; m++) for (var y2 = 0; y2 < p2; y2++) {
        if (v += "\n          xR = xRCorner + " + m * l2 + ";\n          xC = xCCorner + " + (g2 = 2 * y2) * h2 + ";\n        ", 1 === c2) {
          if (g2 < d2 && (v += s2 % 2 == 1 ? "\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < " + o2 + " && xCOffset >= 0 && xCOffset < " + a2 + ") {\n                  xTexelR" + m + "C" + g2 + " = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= " + a2 + ") {\n                    xTexelR" + m + "C" + g2 + ".zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR" + m + "C" + g2 + " = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < " + o2 + " && xCOffset >= 0 && xCOffset < " + a2 + ") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= " + a2 + ") {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR" + m + "C" + g2 + " = vec4(previous.zw, xTexelR" + m + "C" + g2 + ".xy);\n                } else {\n                  xR" + m + "C" + g2 + " = vec4(0, 0, xTexelR" + m + "C" + g2 + ".xy);\n                }\n              " : "\n                if(xR >= 0 && xR < " + o2 + " && xC >= 0 && xC < " + a2 + ") {\n                  xTexelR" + m + "C" + g2 + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + m + "C" + g2 + " = vec4(0.);\n                }\n\n                xR" + m + "C" + g2 + " = xTexelR" + m + "C" + g2 + ";\n              ", g2 + 1 < d2)) {
            var x2 = s2 % 2 == 0 ? b(h2) : h2;
            h2 % 2 == 0 && s2 % 2 == 1 || h2 % 2 != 0 && s2 % 2 != 1 ? (v += "\n                  xCOffset = xC + " + s2 % 2 + " + " + x2 + ";\n\n                  if(xR >= 0 && xR < " + o2 + " &&\n                    xCOffset >= 0 && xCOffset < " + a2 + ") {\n                    xTexelR" + m + "C" + (g2 + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n                ", h2 > 1 && (v += "\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < " + o2 + " &&\n                      xCOffset >= 0 && xCOffset < " + a2 + ") {\n                      xTexelR" + m + "C" + g2 + " = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR" + m + "C" + g2 + " = vec4(0.);\n                    }\n                  "), v += "\n                  xR" + m + "C" + (g2 + 1) + " = vec4(\n                    xTexelR" + m + "C" + g2 + ".zw, xTexelR" + m + "C" + (g2 + 2) + ".xy);\n                ") : v += "\n                  xCOffset = xC + " + x2 + ";\n\n                  if(xR >= 0 && xR < " + o2 + " &&\n                    xCOffset >= 0 && xCOffset < " + a2 + ") {\n                    xTexelR" + m + "C" + (g2 + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR" + m + "C" + (g2 + 1) + " = xTexelR" + m + "C" + (g2 + 2) + ";\n                ";
          }
        } else g2 < d2 && (v += "\n              if(xR >= 0 && xR < " + o2 + ") {\n            ", s2 % 2 == 1 ? (v += "\n                xCOffset = xC + 1 - " + c2 + ";\n                if(xCOffset >= 0 && xCOffset < " + a2 + ") {\n                  xTexelR" + m + "C" + g2 + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + m + "C" + g2 + " = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < " + a2 + ") {\n                  xTexelR" + m + "C" + (g2 + 2) + " = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR" + m + "C" + (g2 + 2) + " = vec4(0.);\n                }\n\n                xR" + m + "C" + g2 + " = vec4(\n                  xTexelR" + m + "C" + g2 + ".zw, xTexelR" + m + "C" + (g2 + 2) + ".zw);\n              ", g2 + 1 < d2 && (v += "\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + " + c2 + ";\n                  if(xCOffset >= 0 && xCOffset < " + a2 + ") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR" + m + "C" + (g2 + 1) + " = vec4(xTexelR" + m + "C" + (g2 + 2) + ".xy, final.xy);\n                ")) : (v += "\n                if(xC >= 0 && xC < " + a2 + ") {\n                  xTexelR" + m + "C" + g2 + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + m + "C" + g2 + " = vec4(0.);\n                }\n\n                xCOffset = xC + " + c2 + ";\n                if(xCOffset >= 0 && xCOffset < " + a2 + ") {\n                  xTexelR" + m + "C" + (g2 + 2) + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + m + "C" + (g2 + 2) + " = vec4(0.);\n                }\n\n                xR" + m + "C" + g2 + " = vec4(\n                  xTexelR" + m + "C" + g2 + ".xy, xTexelR" + m + "C" + (g2 + 2) + ".xy);\n              ", g2 + 1 < d2 && (v += "\n                  xR" + m + "C" + (g2 + 1) + " = vec4(\n                    xTexelR" + m + "C" + g2 + ".zw, xTexelR" + m + "C" + (g2 + 2) + ".zw);\n                ")), v += "}");
        g2 < d2 && (v += "\n            vec4 wTexelR" + m + "C" + g2 + " = getW(" + m + ", " + g2 + ", d1, q);\n            wR" + m + "C" + g2 + " = vec4(wTexelR" + m + "C" + g2 + ".xz, wTexelR" + m + "C" + g2 + ".xz);\n          ", g2 + 1 < d2 && (v += "\n              vec4 wTexelR" + m + "C" + (g2 + 1) + " = getW(" + m + ", " + (g2 + 1) + ", d1, q);\n              wR" + m + "C" + (g2 + 1) + " =\n                vec4(wTexelR" + m + "C" + (g2 + 1) + ".xz, wTexelR" + m + "C" + (g2 + 1) + ".xz);"));
      }
      for (m = 0; m < f2; m++) for (g2 = 0; g2 < d2; g2++) v += "dotProd += xR" + m + "C" + g2 + " * wR" + m + "C" + g2 + ";";
      var w2 = "", C2 = "";
      n2 && (w2 = r2 ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + n2 + "\n        }" : "vec4 activation(vec4 x) {\n          " + n2 + "\n        }", C2 = "result = activation(result);");
      var E2 = e2 ? "result += getBiasAtOutCoords();" : "";
      e2 && this.variableNames.push("bias"), r2 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + w2 + "\n\n      const ivec2 strides = ivec2(" + u3 + ", " + c2 + ");\n      const ivec2 pads = ivec2(" + i2 + ", " + s2 + ");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        " + v + "\n\n        vec4 result = dotProd;\n        " + E2 + "\n        " + C2 + "\n        setOutput(result);\n      }\n    ";
    };
    ei = function(t2, e2, n2, r2, o2) {
      this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
      var a2 = t2[0], i2 = t2[1], s2 = t2[2], u3 = t2[3], c2 = e2[0], l2 = n2[0], h2 = n2[1];
      this.outputShape = [c2, l2, h2, u3];
      var f2 = "bilinear" === r2 ? 1 : 0, d2 = [i2 - 1 + ".0", s2 - 1 + ".0"], p2 = d2[0], v = d2[1], m = l2 > 1 ? ["" + (i2 - 1) / (l2 - 1), "(y2-y1) * height_ratio", "y1*" + p2 + " + float(y)*(height_scale)"] : ["0.0", "0.0", "0.5 * (y1+y2) * " + p2], g2 = m[0], y2 = m[1], x2 = m[2], b2 = h2 > 1 ? ["" + (s2 - 1) / (h2 - 1), "(x2-x1) * width_ratio", "x1*" + v + " + float(x)*(width_scale)"] : ["0.0", "0.0", "0.5 * (x1+x2) * " + v], w2 = b2[0], C2 = b2[1], E2 = b2[2];
      this.userCode = "\n      const float height_ratio = float(" + g2 + ");\n      const float width_ratio = float(" + w2 + ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= " + a2 + ") {\n          return;\n        }\n\n        float height_scale = " + y2 + ";\n        float width_scale = " + C2 + ";\n\n        float in_y = " + x2 + ";\n        if( in_y < 0.0 || in_y > " + p2 + " ) {\n          setOutput(float(" + o2 + "));\n          return;\n        }\n        float in_x = " + E2 + ";\n        if( in_x < 0.0 || in_x > " + v + " ) {\n          setOutput(float(" + o2 + "));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(" + f2 + " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ";
    };
    ni = function(t2, e2, n2) {
      this.variableNames = ["x"], this.outputShape = t2;
      var r2 = t2.length, o2 = t2[t2.length - 1], a2 = n2 ? "<" : ">";
      this.userCode = "\n      int getIndex(int i) {\n        " + (n2 ? "return " + o2 + " -i - 1;" : "return i;") + "\n      }\n\n      void main() {\n        " + wa(r2) + " coords = getOutputCoords();\n        int end = " + ri(r2, "coords") + ";\n        float val = 0.0;\n        for (int i = " + o2 + " - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx " + a2 + " end) {\n            continue;\n          }\n          if (idx == end && " + e2 + ") {\n            continue;\n          }\n          " + ri(r2, "coords") + " = idx;\n          val += getX(" + function(t3, e3) {
        if (1 === t3) return "" + e3;
        if (2 === t3) return e3 + ".x, " + e3 + ".y";
        if (3 === t3) return e3 + ".x, " + e3 + ".y, " + e3 + ".z";
        if (4 === t3) return e3 + ".x, " + e3 + ".y, " + e3 + ".z, " + e3 + ".w";
        throw Error("Cumulative sum for rank " + t3 + " is not yet supported");
      }(r2, "coords") + ");\n        }\n        setOutput(val);\n      }\n    ";
    };
    oi = function(t2) {
      this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.outPackingScheme = Vt.DENSE;
      var e2 = Yt(t2), n2 = ua();
      this.outputShape = t2, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + ca(["r", "c", "d"], t2) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e2[0] + ", " + e2[1] + "));\n        int index = 4 * (resTexRC.x * " + e2[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        " + n2.output + " = result;\n      }\n    ";
    };
    ai = function(t2) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outPackingScheme = Vt.DENSE;
      var e2 = Yt(t2), n2 = ua();
      this.outputShape = t2, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + ca(["r", "c", "d"], t2) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e2[0] + ", " + e2[1] + "));\n        int index = 4 * (resTexRC.x * " + e2[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        " + n2.output + " = result;\n      }\n    ";
    };
    ii = function() {
      function t2(t3, e2, n2) {
        this.variableNames = ["x"], this.outputShape = [], this.outputShape = t3, this.blockSize = e2, this.dataFormat = n2, this.userCode = "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = " + this.getHeightCoordString() + ";\n      int w = " + this.getWidthCoordString() + ";\n      int d = " + this.getDepthCoordString() + ";\n\n      int in_h = h / " + e2 + ";\n      int offset_h = imod(h, " + e2 + ");\n      int in_w = w / " + e2 + ";\n      int offset_w = imod(w, " + e2 + ");\n      int offset_d = (offset_h * " + e2 + " + offset_w) *\n        " + this.getOutputDepthSize() + ";\n      int in_d = d + offset_d;\n\n      float result = " + this.getInputSamplingString() + ";\n      setOutput(result);\n    }\n  ";
      }
      return t2.prototype.getHeightCoordString = function() {
        return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]";
      }, t2.prototype.getWidthCoordString = function() {
        return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]";
      }, t2.prototype.getDepthCoordString = function() {
        return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]";
      }, t2.prototype.getOutputDepthSize = function() {
        return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1];
      }, t2.prototype.getInputSamplingString = function() {
        return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
      }, t2;
    }();
    si = function(t2) {
      this.variableNames = ["X"], this.outputShape = [t2, t2], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    ";
    };
    ui = function(t2) {
      this.variableNames = ["A"], this.outTexUsage = zt.DOWNLOAD;
      var e2 = ua();
      this.outputShape = t2, this.userCode = "\n      " + ha + "\n\n      void main() {\n        float x = getAAtOutCoords();\n        " + e2.output + " = encode_float(x);\n      }\n    ";
    };
    ci = function(t2) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = false, this.outTexUsage = zt.DOWNLOAD;
      var e2 = ua();
      this.outputShape = t2, this.userCode = "\n      " + ha + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        " + e2.output + " = encode_float(x);\n      }\n    ";
    };
    li = function(t2, e2, n2) {
      void 0 === n2 && (n2 = false), this.variableNames = ["A"];
      var r2 = ua(), o2 = e2[0], a2 = e2[1];
      this.outputShape = t2;
      var i2 = "result";
      n2 && (i2 = "floor(result * 255. + 0.5)"), this.userCode = "\n      " + la(t2) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / " + a2 + ";\n        int c = imod(flatIndex, " + a2 + ");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(" + a2 + ".0, " + o2 + ".0);\n        vec4 values = " + r2.texture2D + "(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        " + r2.output + " = vec4(" + i2 + ", 0., 0., 0.);\n      }\n    ";
    };
    hi = function(t2, e2, n2) {
      void 0 === n2 && (n2 = false), this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true;
      var r2 = ua(), o2 = e2[0], a2 = e2[1];
      this.outputShape = t2;
      var i2 = "", s2 = "result";
      n2 && (s2 = "floor(result * 255. + 0.5)");
      for (var u3 = 0; u3 <= 1; u3++) for (var c2 = 0; c2 <= 1; c2++) {
        var l2 = 2 * u3 + c2;
        i2 += "\n          localCoords = coords;\n          if(localCoords[2] + " + c2 + " < " + t2[2] + ") {\n            localCoords[2] += " + c2 + ";\n            if(localCoords[1] + " + u3 + " < " + t2[1] + ") {\n              localCoords[1] += " + u3 + ";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / " + a2 + ";\n              c = imod(flatIndex, " + a2 + ");\n              uv = (vec2(c, r) + halfCR) / vec2(" + a2 + ".0, " + o2 + ".0);\n              values = " + r2.texture2D + "(A, uv);\n\n              if(offset == 0) {\n                result[" + l2 + "] = values[0];\n              } else if(offset == 1) {\n                result[" + l2 + "] = values[1];\n              } else if(offset == 2) {\n                result[" + l2 + "] = values[2];\n              } else {\n                result[" + l2 + "] = values[3];\n              }\n            }\n          }\n        ";
      }
      this.userCode = "\n      " + la(t2) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        " + i2 + "\n\n        " + r2.output + " = " + s2 + ";\n      }\n    ";
    };
    fi = "return real * expR - imag * expI;";
    di = "return real * expI + imag * expR;";
    pi = function(t2, e2, n2) {
      this.variableNames = ["real", "imag"];
      var r2 = e2[1];
      this.outputShape = e2;
      var o2 = n2 ? "2.0 * " + Math.PI : "-2.0 * " + Math.PI, a2 = n2 ? r2 + ".0" : "1.0";
      this.userCode = "\n      const float exponentMultiplier = " + o2 + ";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        " + t2 + "\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(" + r2 + ");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < " + r2 + "; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / " + a2 + ";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ";
    };
    vi = function() {
      function t2(t3, e2) {
        this.outputShape = [], this.variableNames = ["x"], this.outputShape = t3, this.userCode = "\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    ";
      }
      return t2.prototype.getCustomSetupFunc = function(t3) {
        var e2 = this;
        return function(n2, r2) {
          null == e2.valueLoc && (e2.valueLoc = n2.getUniformLocationNoThrow(r2, "value")), n2.gl.uniform1f(e2.valueLoc, t3);
        };
      }, t2;
    }();
    mi = function(t2, e2, n2) {
      this.variableNames = ["A", "indices"];
      var r2 = t2.slice();
      r2[n2] = e2, this.outputShape = r2, this.rank = r2.length;
      var o2 = wa(this.rank), a2 = function(t3, e3) {
        var n3 = t3.length;
        if (n3 > 4) throw Error("Gather for rank " + n3 + " is not yet supported");
        if (1 === n3) return "int(getIndices(resRC))";
        for (var r3 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], o3 = [], a3 = 0; a3 < t3.length; a3++) a3 === e3 ? o3.push("int(getIndices(" + r3[a3] + "))") : o3.push("" + r3[a3]);
        return o3.join();
      }(t2, n2);
      this.userCode = "\n      void main() {\n        " + o2 + " resRC = getOutputCoords();\n        setOutput(getA(" + a2 + "));\n      }\n    ";
    };
    gi = function(t2, e2, n2) {
      this.sliceDim = t2, this.strides = e2, this.variableNames = ["x", "indices"], this.outputShape = n2;
      var r2 = wa(e2.length), o2 = wa(n2.length), a2 = this.sliceDim > 1 ? "strides[j]" : "strides";
      this.userCode = "\n        " + r2 + " strides = " + r2 + "(" + this.strides + ");\n         void main() {\n          " + o2 + " coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < " + this.sliceDim + "; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * " + a2 + ";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      ";
    };
    Mi = Object.freeze({ createVertexShader: yi, createVertexBuffer: xi, createIndexBuffer: bi, createFloat32MatrixTexture: Ci, createFloat16MatrixTexture: Ei, createUnsignedBytesMatrixTexture: Ri, createPackedMatrixTexture: Ii, createFloat16PackedMatrixTexture: ki, bindVertexProgramAttributeStreams: Si, uploadDenseMatrixToTexture: Ai, uploadPixelDataToTexture: Di, createBufferFromOutputTexture: Ti, downloadFloat32MatrixFromBuffer: Ni, downloadByteEncodedFloatMatrixFromOutputTexture: Fi, downloadPackedMatrixFromBuffer: _i, downloadMatrixFromPackedOutputTexture: Oi });
    Bi = function() {
      function t2(t3) {
        this.outputTexture = null, this.program = null, this.disposed = false, this.vertexAttrsAreBound = false, this.itemsToPoll = [];
        var e2 = i().getNumber("WEBGL_VERSION");
        null != t3 ? (this.gl = t3, Kt(e2, t3)) : this.gl = jt(e2);
        var n2 = "WEBGL_color_buffer_float";
        if (1 === i().getNumber("WEBGL_VERSION")) {
          if (this.textureFloatExtension = re(this.gl, this.debug, "OES_texture_float"), Pe(this.gl, "OES_texture_half_float")) this.textureHalfFloatExtension = re(this.gl, this.debug, "OES_texture_half_float");
          else if (i().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
          if (this.colorBufferFloatExtension = this.gl.getExtension(n2), Pe(this.gl, "EXT_color_buffer_half_float")) this.colorBufferHalfFloatExtension = re(this.gl, this.debug, "EXT_color_buffer_half_float");
          else if (i().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
        } else if (n2 = "EXT_color_buffer_float", Pe(this.gl, n2)) this.colorBufferFloatExtension = this.gl.getExtension(n2);
        else {
          if (!Pe(this.gl, "EXT_color_buffer_half_float")) throw new Error("GL context does not support color renderable floats");
          this.colorBufferHalfFloatExtension = this.gl.getExtension("EXT_color_buffer_half_float");
        }
        this.vertexBuffer = xi(this.gl, this.debug), this.indexBuffer = bi(this.gl, this.debug), this.framebuffer = me(this.gl, this.debug), this.textureConfig = Qt(this.gl, this.textureHalfFloatExtension);
      }
      return Object.defineProperty(t2.prototype, "debug", { get: function() {
        return i().getBool("DEBUG");
      }, enumerable: true, configurable: true }), t2.prototype.dispose = function() {
        var t3 = this;
        if (!this.disposed) {
          null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
          var e2 = this.gl;
          Jt(e2, this.debug, function() {
            return e2.finish();
          }), Jt(e2, this.debug, function() {
            return e2.bindFramebuffer(e2.FRAMEBUFFER, null);
          }), Jt(e2, this.debug, function() {
            return e2.deleteFramebuffer(t3.framebuffer);
          }), Jt(e2, this.debug, function() {
            return e2.bindBuffer(e2.ARRAY_BUFFER, null);
          }), Jt(e2, this.debug, function() {
            return e2.bindBuffer(e2.ELEMENT_ARRAY_BUFFER, null);
          }), Jt(e2, this.debug, function() {
            return e2.deleteBuffer(t3.indexBuffer);
          }), this.disposed = true;
        }
      }, t2.prototype.createFloat32MatrixTexture = function(t3, e2) {
        return this.throwIfDisposed(), Ci(this.gl, this.debug, t3, e2, this.textureConfig);
      }, t2.prototype.createFloat16MatrixTexture = function(t3, e2) {
        return this.throwIfDisposed(), Ei(this.gl, this.debug, t3, e2, this.textureConfig);
      }, t2.prototype.createUnsignedBytesMatrixTexture = function(t3, e2) {
        return this.throwIfDisposed(), Ri(this.gl, this.debug, t3, e2, this.textureConfig);
      }, t2.prototype.uploadPixelDataToTexture = function(t3, e2) {
        this.throwIfDisposed(), Di(this.gl, this.debug, t3, e2);
      }, t2.prototype.uploadDenseMatrixToTexture = function(t3, e2, n2, r2) {
        this.throwIfDisposed(), Ai(this.gl, this.debug, t3, e2, n2, r2, this.textureConfig);
      }, t2.prototype.createFloat16PackedMatrixTexture = function(t3, e2) {
        return this.throwIfDisposed(), ki(this.gl, this.debug, t3, e2, this.textureConfig);
      }, t2.prototype.createPackedMatrixTexture = function(t3, e2) {
        return this.throwIfDisposed(), Ii(this.gl, this.debug, t3, e2, this.textureConfig);
      }, t2.prototype.deleteMatrixTexture = function(t3) {
        var e2 = this;
        this.throwIfDisposed(), this.outputTexture === t3 && (Ee(this.gl, this.debug, this.framebuffer), this.outputTexture = null), Jt(this.gl, this.debug, function() {
          return e2.gl.deleteTexture(t3);
        });
      }, t2.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function(t3, e2, n2) {
        var r2 = this;
        return this.downloadMatrixDriver(t3, function() {
          return Fi(r2.gl, r2.debug, e2, n2, r2.textureConfig);
        });
      }, t2.prototype.downloadPackedMatrixFromBuffer = function(t3, e2, n2, r2, o2, a2) {
        return _i(this.gl, t3, 0, 0, 0, o2, a2, this.textureConfig);
      }, t2.prototype.downloadFloat32MatrixFromBuffer = function(t3, e2) {
        return Ni(this.gl, t3, e2);
      }, t2.prototype.createBufferFromTexture = function(t3, e2, n2) {
        this.bindTextureToFrameBuffer(t3);
        var r2 = Ti(this.gl, this.debug, e2, n2, this.textureConfig);
        return this.unbindTextureToFrameBuffer(), r2;
      }, t2.prototype.createAndWaitForFence = function() {
        var t3 = this.createFence(this.gl);
        return this.pollFence(t3);
      }, t2.prototype.createFence = function(t3) {
        var e2, n2, r2 = this;
        if (i().getBool("WEBGL_FENCE_API_ENABLED")) {
          var o2 = t3, a2 = o2.fenceSync(o2.SYNC_GPU_COMMANDS_COMPLETE, 0);
          t3.flush(), n2 = function() {
            var t4 = o2.clientWaitSync(a2, 0, 0);
            return t4 === o2.ALREADY_SIGNALED || t4 === o2.CONDITION_SATISFIED;
          }, e2 = a2;
        } else i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (e2 = this.beginQuery(), this.endQuery(), n2 = function() {
          return r2.isQueryAvailable(e2, i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
        }) : n2 = function() {
          return true;
        };
        return { query: e2, isFencePassed: n2 };
      }, t2.prototype.downloadMatrixFromPackedTexture = function(t3, e2, n2) {
        var r2 = this;
        return this.downloadMatrixDriver(t3, function() {
          return Oi(r2.gl, r2.debug, e2, n2);
        });
      }, t2.prototype.createProgram = function(t3) {
        this.throwIfDisposed();
        var e2 = this.gl, n2 = ae(e2, this.debug, t3), r2 = yi(e2, this.debug), o2 = ce(e2, this.debug);
        return Jt(e2, this.debug, function() {
          return e2.attachShader(o2, r2);
        }), Jt(e2, this.debug, function() {
          return e2.attachShader(o2, n2);
        }), le(e2, this.debug, o2), this.debug && he(e2, this.debug, o2), this.vertexAttrsAreBound || (this.setProgram(o2), this.vertexAttrsAreBound = Si(e2, this.debug, this.program, this.vertexBuffer)), o2;
      }, t2.prototype.deleteProgram = function(t3) {
        var e2 = this;
        this.throwIfDisposed(), t3 === this.program && (this.program = null), null != t3 && Jt(this.gl, this.debug, function() {
          return e2.gl.deleteProgram(t3);
        });
      }, t2.prototype.setProgram = function(t3) {
        var e2 = this;
        this.throwIfDisposed(), this.program = t3, null != this.program && this.debug && he(this.gl, this.debug, this.program), Jt(this.gl, this.debug, function() {
          return e2.gl.useProgram(t3);
        });
      }, t2.prototype.getUniformLocation = function(t3, e2, n2) {
        return void 0 === n2 && (n2 = true), this.throwIfDisposed(), n2 ? xe(this.gl, this.debug, t3, e2) : be(this.gl, t3, e2);
      }, t2.prototype.getAttributeLocation = function(t3, e2) {
        var n2 = this;
        return this.throwIfDisposed(), Jt(this.gl, this.debug, function() {
          return n2.gl.getAttribLocation(t3, e2);
        });
      }, t2.prototype.getUniformLocationNoThrow = function(t3, e2) {
        return this.throwIfDisposed(), this.gl.getUniformLocation(t3, e2);
      }, t2.prototype.setInputMatrixTexture = function(t3, e2, n2) {
        this.throwIfDisposed(), this.throwIfNoProgram(), we(this.gl, this.debug, this.program, t3, e2, n2);
      }, t2.prototype.setOutputMatrixTexture = function(t3, e2, n2) {
        this.setOutputMatrixTextureDriver(t3, n2, e2);
      }, t2.prototype.setOutputPackedMatrixTexture = function(t3, e2, n2) {
        this.throwIfDisposed();
        var r2 = $t(e2, n2), o2 = r2[0], a2 = r2[1];
        this.setOutputMatrixTextureDriver(t3, o2, a2);
      }, t2.prototype.setOutputMatrixWriteRegion = function(t3, e2, n2, r2) {
        this.setOutputMatrixWriteRegionDriver(n2, t3, r2, e2);
      }, t2.prototype.setOutputPackedMatrixWriteRegion = function(t3, e2, n2, r2) {
        throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
      }, t2.prototype.debugValidate = function() {
        null != this.program && he(this.gl, this.debug, this.program), Re(this.gl);
      }, t2.prototype.executeProgram = function() {
        this.throwIfDisposed(), this.throwIfNoProgram();
        var t3 = this.gl;
        this.debug && this.debugValidate(), Jt(t3, this.debug, function() {
          return t3.drawElements(t3.TRIANGLES, 6, t3.UNSIGNED_SHORT, 0);
        });
      }, t2.prototype.blockUntilAllProgramsCompleted = function() {
        var t3 = this;
        this.throwIfDisposed(), Jt(this.gl, this.debug, function() {
          return t3.gl.finish();
        });
      }, t2.prototype.getQueryTimerExtension = function() {
        return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = re(this.gl, this.debug, 2 === i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
      }, t2.prototype.getQueryTimerExtensionWebGL2 = function() {
        return this.getQueryTimerExtension();
      }, t2.prototype.getQueryTimerExtensionWebGL1 = function() {
        return this.getQueryTimerExtension();
      }, t2.prototype.beginQuery = function() {
        if (2 === i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
          var t3 = this.gl, e2 = this.getQueryTimerExtensionWebGL2(), n2 = t3.createQuery();
          return t3.beginQuery(e2.TIME_ELAPSED_EXT, n2), n2;
        }
        var r2 = this.getQueryTimerExtensionWebGL1(), o2 = r2.createQueryEXT();
        return r2.beginQueryEXT(r2.TIME_ELAPSED_EXT, o2), o2;
      }, t2.prototype.endQuery = function() {
        if (2 !== i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
          var t3 = this.getQueryTimerExtensionWebGL1();
          t3.endQueryEXT(t3.TIME_ELAPSED_EXT);
        } else {
          var e2 = this.gl, n2 = this.getQueryTimerExtensionWebGL2();
          e2.endQuery(n2.TIME_ELAPSED_EXT);
        }
      }, t2.prototype.waitForQueryAndGetTime = function(t3) {
        return n(this, void 0, void 0, function() {
          var e2 = this;
          return r(this, function(n2) {
            switch (n2.label) {
              case 0:
                return [4, F(function() {
                  return e2.disposed || e2.isQueryAvailable(t3, i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
                })];
              case 1:
                return n2.sent(), [2, this.getQueryTime(t3, i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))];
            }
          });
        });
      }, t2.prototype.getQueryTime = function(t3, e2) {
        if (0 === e2) return null;
        if (2 === e2) {
          var n2 = this.gl;
          return n2.getQueryParameter(t3, n2.QUERY_RESULT) / 1e6;
        }
        var r2 = this.getQueryTimerExtensionWebGL1();
        return r2.getQueryObjectEXT(t3, r2.QUERY_RESULT_EXT) / 1e6;
      }, t2.prototype.isQueryAvailable = function(t3, e2) {
        if (0 === e2) return true;
        if (2 === e2) {
          var n2 = this.gl, r2 = this.getQueryTimerExtensionWebGL2(), o2 = n2.getQueryParameter(t3, n2.QUERY_RESULT_AVAILABLE);
          return null == this.disjoint && (this.disjoint = this.gl.getParameter(r2.GPU_DISJOINT_EXT)), o2 && !this.disjoint;
        }
        o2 = (r2 = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t3, r2.QUERY_RESULT_AVAILABLE_EXT);
        return null == this.disjoint && (this.disjoint = this.gl.getParameter(r2.GPU_DISJOINT_EXT)), o2 && !this.disjoint;
      }, t2.prototype.pollFence = function(t3) {
        var e2 = this;
        return new Promise(function(n2) {
          e2.addItemToPoll(function() {
            return t3.isFencePassed();
          }, function() {
            return n2();
          });
        });
      }, t2.prototype.pollItems = function() {
        for (var t3 = function(t4) {
          for (var e3 = 0; e3 < t4.length; ++e3) {
            if (!t4[e3]()) break;
          }
          return e3 - 1;
        }(this.itemsToPoll.map(function(t4) {
          return t4.isDoneFn;
        })), e2 = 0; e2 <= t3; ++e2) {
          (0, this.itemsToPoll[e2].resolveFn)();
        }
        this.itemsToPoll = this.itemsToPoll.slice(t3 + 1);
      }, t2.prototype.addItemToPoll = function(t3, e2) {
        var n2 = this;
        this.itemsToPoll.push({ isDoneFn: t3, resolveFn: e2 }), this.itemsToPoll.length > 1 || F(function() {
          return n2.pollItems(), 0 === n2.itemsToPoll.length;
        });
      }, t2.prototype.bindTextureToFrameBuffer = function(t3) {
        this.throwIfDisposed(), Ce(this.gl, this.debug, t3, this.framebuffer), this.debug && Re(this.gl);
      }, t2.prototype.unbindTextureToFrameBuffer = function() {
        null != this.outputTexture ? (Ce(this.gl, this.debug, this.outputTexture, this.framebuffer), this.debug && Re(this.gl)) : Ee(this.gl, this.debug, this.framebuffer);
      }, t2.prototype.downloadMatrixDriver = function(t3, e2) {
        this.bindTextureToFrameBuffer(t3);
        var n2 = e2();
        return this.unbindTextureToFrameBuffer(), n2;
      }, t2.prototype.setOutputMatrixTextureDriver = function(t3, e2, n2) {
        this.throwIfDisposed();
        var r2 = this.gl;
        Ce(r2, this.debug, t3, this.framebuffer), this.debug && Re(r2), this.outputTexture = t3, Jt(r2, this.debug, function() {
          return r2.viewport(0, 0, e2, n2);
        }), Jt(r2, this.debug, function() {
          return r2.scissor(0, 0, e2, n2);
        });
      }, t2.prototype.setOutputMatrixWriteRegionDriver = function(t3, e2, n2, r2) {
        var o2 = this;
        this.throwIfDisposed(), Jt(this.gl, this.debug, function() {
          return o2.gl.scissor(t3, e2, n2, r2);
        });
      }, t2.prototype.throwIfDisposed = function() {
        if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.");
      }, t2.prototype.throwIfNoProgram = function() {
        if (null == this.program) throw new Error("No GPU program is currently set.");
      }, t2;
    }();
    Li = function(t2, e2, n2) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t2;
      for (var r2 = n2.filterWidth, o2 = n2.inChannels, a2 = n2.strideWidth, i2 = n2.strideHeight, s2 = n2.padInfo, u3 = n2.outWidth, c2 = n2.dilationWidth, l2 = n2.dilationHeight, h2 = n2.dataFormat, f2 = s2.left, d2 = s2.top, p2 = o2 * r2, v = ua(), m = "channelsLast" === h2, g2 = m ? 0 : 1, y2 = m ? 1 : 2, x2 = "", b2 = 0; b2 <= 1; b2++) for (var w2 = 0; w2 <= 1; w2++) x2 += "\n          blockIndex = rc.y + " + w2 + ";\n          pos = rc.x + " + b2 + ";\n\n          if(blockIndex < " + t2[1] + " && pos < " + t2[0] + ") {\n            offsetY = int(blockIndex / (" + u3 + ")) * " + i2 + " - " + d2 + ";\n            d0 = offsetY + " + l2 + " * (pos / " + p2 + ");\n\n            if(d0 < " + e2[g2] + " && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), " + u3 + ".) * " + a2 + ". - " + f2 + ".);\n              d1 = offsetX + " + c2 + " * (int(mod(float(pos), " + p2 + ".) / " + o2 + ".));\n\n              if(d1 < " + e2[y2] + " && d1 >= 0) {\n\n                ch = int(mod(float(pos), " + o2 + ".));\n\n                if (" + m + ") {\n                  innerDims = vec2(d1, ch);\n                  result[" + (2 * b2 + w2) + "] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[" + (2 * b2 + w2) + "] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";
      this.userCode = "\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        " + x2 + "\n\n        " + v.output + " = result;\n      }\n    ";
    };
    Wi = function(t2, e2, n2, r2, o2) {
      this.variableNames = ["x"], this.outputShape = [];
      var a2, i2 = e2, s2 = t2[3] - 1;
      this.outputShape = t2;
      var u3 = "float(" + n2 + ") + float(" + r2 + ") * sum";
      a2 = 0.5 === o2 ? "inversesqrt(" + u3 + ")" : 1 === o2 ? "1.0/(" + u3 + ")" : "exp(log(" + u3 + ") * float(-" + o2 + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -" + i2 + "; j <= " + i2 + "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  " + s2 + ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * " + a2 + ";\n        setOutput(val);\n      }\n    ";
    };
    Ui = function(t2, e2, n2, r2, o2) {
      this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = t2, this.depth = t2[3], this.depthRadius = e2, this.bias = n2, this.alpha = r2, this.beta = o2, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < " + this.depth + "; ++d) {\n          int depthBegin = int(max(0.0, float(d - " + e2 + ")));\n          int depthEnd = int(min(float(" + this.depth + "),\n              float(d + " + e2 + " + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = " + this.depth + ";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(" + r2 + ") * norm + float(" + n2 + ");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(" + r2 + ")\n                * float(" + o2 + ")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * " + o2 + ");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ";
    };
    Vi = function(t2, e2, n2, r2, o2) {
      this.variableNames = ["x"], this.outputShape = [], this.packedInputs = true, this.packedOutput = true;
      var a2, i2 = e2, s2 = t2[3] - 1;
      this.outputShape = t2;
      var u3 = "float(" + n2 + ") + float(" + r2 + ") * sum";
      a2 = 0.5 === o2 ? "inversesqrt(" + u3 + ")" : 1 === o2 ? "1.0/(" + u3 + ")" : "exp(log(" + u3 + ") * float(-" + o2 + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < " + this.outputShape[3] + ";\n        bool hasNextRow = c < " + this.outputShape[2] + ";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - " + i2 + ";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - " + i2 + "; j <= " + i2 + "; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(" + s2 + "));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * " + a2 + ";\n        setOutput(result);\n      }\n    ";
    };
    zi = function(t2) {
      this.variableNames = ["dy", "maxPos"], this.outputShape = t2.inShape;
      var e2 = t2.strideHeight, n2 = t2.strideWidth, r2 = t2.dilationHeight, o2 = t2.effectiveFilterHeight, a2 = t2.effectiveFilterWidth, i2 = o2 - 1 - t2.padInfo.top, s2 = a2 - 1 - t2.padInfo.left, u3 = o2 * a2 - 1;
      this.userCode = "\n      const ivec2 pads = ivec2(" + i2 + ", " + s2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + o2 + ";\n          wR += " + r2 + ") {\n          float dyR = float(dyRCorner + wR) / " + e2 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + a2 + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + n2 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " + u3 + " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + a2 + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
    Gi = function(t2) {
      this.variableNames = ["dy", "maxPos"], this.outputShape = t2.inShape;
      var e2 = t2.strideDepth, n2 = t2.strideHeight, r2 = t2.strideWidth, o2 = t2.dilationDepth, a2 = t2.dilationHeight, i2 = t2.dilationWidth, s2 = t2.effectiveFilterDepth, u3 = t2.effectiveFilterHeight, c2 = t2.effectiveFilterWidth, l2 = s2 - 1 - t2.padInfo.front, h2 = u3 - 1 - t2.padInfo.top, f2 = c2 - 1 - t2.padInfo.left, d2 = s2 * u3 * c2 - 1;
      this.userCode = "\n      const ivec3 pads = ivec3(" + l2 + ", " + h2 + ", " + f2 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + s2 + ";\n           wD += " + o2 + ") {\n          float dyD = float(dyDCorner + wD) / " + e2 + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t2.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + u3 + ";\n              wR += " + a2 + ") {\n            float dyR = float(dyRCorner + wR) / " + n2 + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + c2 + ";\n                wC += " + i2 + ") {\n              float dyC = float(dyCCorner + wC) / " + r2 + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = " + d2 + " -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * " + u3 + " * " + c2 + " +\n                  wR * " + c2 + " + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    };
    Hi = function(t2, e2, n2, r2, o2, a2, i2) {
      void 0 === n2 && (n2 = false), void 0 === r2 && (r2 = false), void 0 === o2 && (o2 = false), void 0 === a2 && (a2 = null), void 0 === i2 && (i2 = false), this.variableNames = ["matrixA", "matrixB"], this.packedInputs = true, this.packedOutput = true, this.outputShape = e2;
      var s2 = n2 ? t2[1] : t2[2], u3 = Math.ceil(s2 / 2), c2 = n2 ? "i * 2, rc.y" : "rc.y, i * 2", l2 = r2 ? "rc.z, i * 2" : "i * 2, rc.z", h2 = n2 ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"], f2 = r2 ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"], d2 = "", p2 = "";
      a2 && (d2 = i2 ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + a2 + "\n        }" : "vec4 activation(vec4 x) {\n          " + a2 + "\n        }", p2 = "result = activation(result);");
      var v = o2 ? "result += getBiasAtOutCoords();" : "";
      o2 && this.variableNames.push("bias"), i2 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + d2 + "\n\n      const float sharedDimension = " + u3 + ".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < " + u3 + "; i++) {\n          vec4 a = getMatrixA(rc.x, " + c2 + ");\n          vec4 b = getMatrixB(rc.x, " + l2 + ");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (" + h2[0] + " * " + f2[0] + ");\n          result += (" + h2[1] + " * " + f2[1] + ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        " + v + "\n\n        " + p2 + "\n\n        setOutput(result);\n      }\n    ";
    };
    qi = function() {
      function t2(t3, e2, n2) {
        this.variableNames = ["probs"], this.outputShape = [t3, n2], this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (e2 - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (e2 - 1) + "));\n      }\n    ";
      }
      return t2.prototype.getCustomSetupFunc = function(t3) {
        var e2 = this;
        return function(n2, r2) {
          null == e2.seedLoc && (e2.seedLoc = n2.getUniformLocation(r2, "seed")), n2.gl.uniform1f(e2.seedLoc, t3);
        };
      }, t2;
    }();
    Ki = function(t2, e2, n2, r2) {
      this.variableNames = ["indices"], this.outputShape = [t2, e2], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + r2 + "), float(" + n2 + "),\n                      float(index == coords.y)));\n      }\n    ";
    };
    ji = function(t2) {
      this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.outputShape = t2;
      var e2 = t2.length;
      if (0 === e2) this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";
      else {
        var n2 = sa("rc", e2), r2 = wa(e2), o2 = function(t3, e3, n3) {
          if (1 === t3) return "rc > " + e3[0];
          for (var r3 = "", o3 = t3 - 2; o3 < t3; o3++) r3 += n3[o3] + " >= " + e3[o3], o3 < t3 - 1 && (r3 += "||");
          return r3;
        }(e2, t2, n2), a2 = function(t3, e3, n3, r3) {
          if (1 === t3) return "";
          var o3 = r3.slice(-2);
          return "\n    int r = " + o3[0] + ";\n    int c = " + o3[1] + ";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= " + e3 + ";\n    bool rEdge = rp1 >= " + n3 + ";\n  ";
        }(e2, t2[t2.length - 1], t2[t2.length - 2], n2), i2 = function(t3, e3) {
          var n3 = t3.length, r3 = function(t4, e4) {
            for (var n4 = [], r4 = 0; r4 <= 1; r4++) for (var o3 = 0; o3 <= 1; o3++) {
              for (var a3 = (0 === r4 ? "r" : "rp1") + ", " + (0 === o3 ? "c" : "cp1"), i3 = 2; i3 < t4; i3++) a3 = e4[e4.length - 1 - i3] + "," + a3;
              n4.push(a3);
            }
            return n4;
          }(n3, e3);
          return 1 === n3 ? "getA(rc),\n            rc + 1 >= " + t3[0] + " ? 0. : getA(rc + 1),\n            0, 0" : "getA(" + r3[0] + "),\n          cEdge ? 0. : getA(" + r3[1] + "),\n          rEdge ? 0. : getA(" + r3[2] + "),\n          rEdge || cEdge ? 0. : getA(" + r3[3] + ")";
        }(t2, n2);
        this.userCode = "\n        void main() {\n          " + r2 + " rc = getOutputCoords();\n\n          if(" + o2 + ") {\n            setOutput(vec4(0));\n          } else {\n            " + a2 + "\n\n            setOutput(vec4(" + i2 + "));\n          }\n        }\n      ";
      }
    };
    Xi = function(t2, e2, n2) {
      this.variableNames = ["x"], this.outputShape = e2.map(function(e3, n3) {
        return e3[0] + t2[n3] + e3[1];
      });
      var r2 = t2.length, o2 = wa(r2), a2 = e2.map(function(t3) {
        return t3[0];
      }).join(","), i2 = e2.map(function(e3, n3) {
        return e3[0] + t2[n3];
      }).join(","), s2 = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, r2);
      this.userCode = 1 !== r2 ? "\n      " + o2 + " start = " + o2 + "(" + a2 + ");\n      " + o2 + " end = " + o2 + "(" + i2 + ");\n\n      void main() {\n        " + o2 + " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(" + n2 + "));\n        } else {\n          " + o2 + " coords = outC - start;\n          setOutput(getX(" + s2 + "));\n        }\n      }\n    " : "\n        int start = " + a2 + ";\n        int end = " + i2 + ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(" + n2 + "));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ";
    };
    Yi = function(t2, e2, n2) {
      this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true, this.outputShape = e2.map(function(e3, n3) {
        return e3[0] + t2[n3] + e3[1];
      });
      for (var r2 = t2.length, o2 = wa(r2), a2 = e2.map(function(t3) {
        return t3[0];
      }).join(","), i2 = e2.map(function(e3, n3) {
        return e3[0] + t2[n3];
      }).join(","), s2 = sa("rc", r2), u3 = sa("source", r2), c2 = s2[r2 - 1] + " < " + this.outputShape[r2 - 1], l2 = 1 === r2 ? "source" : "vec2(" + u3.slice(-2).join() + ")", h2 = [o2 + " rc = outputLoc;", s2[r2 - 1] + " += 1;\n       if(" + c2 + ") {\n      ", 1 === r2 ? "" : "}\n       rc = outputLoc;\n       " + s2[r2 - 2] + " += 1;\n       if(" + s2[r2 - 2] + " < " + this.outputShape[r2 - 2] + ") {", 1 === r2 ? "" : "  " + s2[r2 - 1] + " += 1;\n         if(" + c2 + ") {"], f2 = 1 === r2 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", d2 = "", p2 = 0, v = 1 === r2 ? 2 : 4; p2 < v; p2++) d2 += "\n        " + h2[p2] + "\n        if (" + f2 + ") {\n          result[" + p2 + "] = float(" + n2 + ");\n        } else {\n          " + o2 + " source = rc - start;\n          result[" + p2 + "] = getChannel(getX(" + u3.join() + "), " + l2 + ");\n        }\n      ";
      d2 += 1 === r2 ? "} " : "}}", this.userCode = "\n      const " + o2 + " start = " + o2 + "(" + a2 + ");\n      const " + o2 + " end = " + o2 + "(" + i2 + ");\n\n      void main() {\n        " + o2 + " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        " + d2 + "\n        setOutput(result);\n      }\n    ";
    };
    $i = function(t2, e2, n2) {
      if (this.variableNames = ["x"], "avg" === e2 && n2) throw new Error("Cannot compute positions for average pool.");
      var r2 = t2.filterWidth, o2 = t2.strideHeight, a2 = t2.strideWidth, i2 = t2.dilationHeight, s2 = t2.dilationWidth, u3 = t2.effectiveFilterHeight, c2 = t2.effectiveFilterWidth, l2 = t2.padInfo.top, h2 = t2.padInfo.left;
      this.outputShape = t2.outShape;
      var f2 = "avg" === e2, d2 = "0.0";
      if (f2 || (d2 = "-1.0 / 1e-20"), n2) this.userCode = "\n        const ivec2 strides = ivec2(" + o2 + ", " + a2 + ");\n        const ivec2 pads = ivec2(" + l2 + ", " + h2 + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + u3 + ";\n              wR += " + i2 + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t2.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + c2 + ";\n                wC += " + s2 + ") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + t2.inWidth + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + c2 + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
      else {
        var p2 = e2 + "(" + e2 + "(" + e2 + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
        "avg" === e2 && (p2 = "avgValue / count");
        var v = 4 * Math.floor(r2 / 4), m = r2 % 4, g2 = "\n      if (" + f2 + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
        this.userCode = "\n      const ivec2 strides = ivec2(" + o2 + ", " + a2 + ");\n      const ivec2 pads = ivec2(" + l2 + ", " + h2 + ");\n      const float initializationValue = " + d2 + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + t2.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + d2 + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < " + u3 + ";\n            wR += " + i2 + ") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + t2.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + v + "; wC += 4) {\n            int xC = xCCorner + wC * " + s2 + ";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s2 + ", d),\n              getValue(batch, xR, xC + 2 * " + s2 + ", d),\n              getValue(batch, xR, xC + 3 * " + s2 + ", d)\n            );\n\n            " + g2 + "\n          }\n\n          int xC = xCCorner + " + v + ";\n          if (" + (1 === m) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            " + g2 + "\n          } else if (" + (2 === m) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s2 + ", d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + g2 + "\n          } else if (" + (3 === m) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s2 + ", d),\n              getValue(batch, xR, xC + 2 * " + s2 + ", d),\n              initializationValue\n            );\n\n            " + g2 + "\n          }\n        }\n        setOutput(" + p2 + ");\n      }\n    ";
      }
    };
    Qi = function(t2, e2, n2) {
      if (this.variableNames = ["x"], "avg" === e2 && n2) throw new Error("Cannot compute positions for average pool.");
      var r2 = t2.filterWidth, o2 = t2.strideDepth, a2 = t2.strideHeight, i2 = t2.strideWidth, s2 = t2.dilationDepth, u3 = t2.dilationHeight, c2 = t2.dilationWidth, l2 = t2.effectiveFilterDepth, h2 = t2.effectiveFilterHeight, f2 = t2.effectiveFilterWidth, d2 = t2.padInfo.front, p2 = t2.padInfo.top, v = t2.padInfo.left;
      this.outputShape = t2.outShape;
      var m = "avg" === e2, g2 = "0.0";
      if (m || (g2 = "-1.0 / 1e-20"), n2) this.userCode = "\n        const ivec3 strides =\n            ivec3(" + o2 + ", " + a2 + ", " + i2 + ");\n        const ivec3 pads = ivec3(" + d2 + ", " + p2 + ", " + v + ");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < " + l2 + ";\n              wD += " + s2 + ") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= " + t2.inDepth + ") {\n              continue;\n            }\n\n            for (int wR = 0; wR < " + h2 + ";\n                wR += " + u3 + ") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= " + t2.inHeight + ") {\n                continue;\n              }\n\n              for (int wC = 0; wC < " + f2 + ";\n                  wC += " + c2 + ") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= " + t2.inWidth + ") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition =\n                      wD * " + h2 + " * " + f2 + " +\n                      wR * " + f2 + " + wC;;\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
      else {
        var y2 = e2 + "(" + e2 + "(" + e2 + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
        "avg" === e2 && (y2 = "avgValue / count");
        var x2 = 4 * Math.floor(r2 / 4), b2 = r2 % 4, w2 = "\n      if (" + m + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
        this.userCode = "\n      const ivec3 strides =\n        ivec3(" + o2 + ", " + a2 + ", " + i2 + ");\n      const ivec3 pads = ivec3(" + d2 + ", " + p2 + ", " + v + ");\n      const float initializationValue = " + g2 + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= " + t2.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + g2 + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < " + l2 + ";\n            wD += " + s2 + ") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= " + t2.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h2 + ";\n            wR += " + u3 + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t2.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + x2 + "; wC += 4) {\n              int xC = xCCorner + wC * " + c2 + ";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c2 + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + c2 + ", ch),\n                getValue(batch, xD, xR, xC + 3 * " + c2 + ", ch)\n              );\n\n              " + w2 + "\n            }\n\n            int xC = xCCorner + " + x2 + ";\n            if (" + (1 === b2) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              " + w2 + "\n            } else if (" + (2 === b2) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c2 + ", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              " + w2 + "\n            } else if (" + (3 === b2) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c2 + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + c2 + ", ch),\n                initializationValue\n              );\n\n              " + w2 + "\n            }\n          }\n          setOutput(" + y2 + ");\n        }\n      }\n    ";
      }
    };
    Ji = function(t2, e2) {
      this.variableNames = ["x"];
      var n2 = t2.windowSize, r2 = t2.batchSize, o2 = t2.inSize, a2 = Math.ceil(o2 / n2);
      this.outputShape = [r2, a2];
      var i2 = "0.0", s2 = "";
      "prod" === e2 ? i2 = "1.0" : "min" === e2 ? (i2 = "1.0 / 1e-20", s2 = "min") : "max" === e2 && (i2 = "-1.0 / 1e-20", s2 = "max");
      var u3 = e2 + "(" + e2 + "(" + e2 + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
      "sum" === e2 ? u3 = "sumValue" : "prod" === e2 ? u3 = "prodValue" : "all" === e2 ? u3 = "allValue" : "any" === e2 && (u3 = "anyValue");
      var c2 = 4 * Math.floor(n2 / 4), l2 = n2 % 4, h2 = "\n      if (" + ("sum" === e2) + ") {\n        sumValue += dot(values, ones);\n      } else if (" + ("prod" === e2) + ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = " + s2 + "(values, minMaxValue);\n      }\n    ", f2 = "vec4";
      "all" === e2 ? (i2 = "1.0", h2 = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", f2 = "bvec4") : "any" === e2 && (i2 = "0.0", h2 = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", f2 = "bvec4");
      var d2 = "";
      o2 % n2 > 0 && (d2 = "\n        if (inIdx < 0 || inIdx >= " + o2 + ") {\n          return initializationValue;\n        }\n      "), this.userCode = "\n      const float initializationValue = " + i2 + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + d2 + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + n2 + ";\n\n        vec4 minMaxValue = vec4(" + i2 + ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < " + c2 + "; i += 4) {\n          int inIdx = inOffset + i;\n          " + f2 + " values = " + f2 + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + h2 + "\n        }\n\n        int inIdx = inOffset + " + c2 + ";\n        if (" + (1 === l2) + ") {\n          " + f2 + " values = " + f2 + "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          " + h2 + "\n        } else if (" + (2 === l2) + ") {\n          " + f2 + " values = " + f2 + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          " + h2 + "\n        } else if (" + (3 === l2) + ") {\n          " + f2 + " values = " + f2 + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          " + h2 + "\n        }\n        setOutput(" + u3 + ");\n      }\n    ";
    };
    Zi = function(t2, e2) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t2;
      for (var n2 = "", r2 = 0; r2 < 4; r2++) {
        var o2 = "thisRC = rc;";
        r2 % 2 == 1 && (o2 += "thisRC.z += 1;"), r2 > 1 && (o2 += "thisRC.y += 1;"), n2 += "\n        " + o2 + "\n        " + (r2 > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "") + "\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[" + r2 + "] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        " + (r2 > 0 ? "}" : "") + "\n      ";
      }
      this.userCode = "\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      " + ca(["r", "c", "d"], e2) + "\n      return ivec3(r, c, d);\n    }\n  \n      " + la(t2) + "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = " + t2[1] + ";\n        int cols = " + t2[2] + ";\n\n        " + n2 + "\n\n        setOutput(result);\n      }\n    ";
    };
    ts = function(t2, e2, n2) {
      this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e2.shape;
      var r2 = e2.shape, o2 = r2[1], a2 = r2[2], i2 = t2.shape, s2 = i2[1], u3 = i2[2], c2 = [n2 && s2 > 1 ? o2 - 1 : o2, n2 && u3 > 1 ? a2 - 1 : a2], l2 = [n2 && s2 > 1 ? s2 - 1 : s2, n2 && u3 > 1 ? u3 - 1 : u3], h2 = c2[0] / l2[0], f2 = c2[1] / l2[1], d2 = 1 / h2, p2 = 1 / f2, v = 2 * Math.ceil(d2) + 2, m = 2 * Math.ceil(p2) + 2;
      this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h2 + ");\n        const float widthScale = float(" + f2 + ");\n\n        const float invHeightScale = float(" + d2 + ");\n        const float invWidthScale = float(" + p2 + ");\n\n        const int winHeight = int(" + v + ");\n        const int winWidth = int(" + m + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + s2 + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + u3 + ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), " + (o2 - 1) + ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), " + (a2 - 1) + ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
    };
    es = function(t2, e2, n2, r2) {
      this.variableNames = ["A"], this.outputShape = [];
      var o2 = t2[0], a2 = t2[1], i2 = t2[2], s2 = t2[3];
      this.outputShape = [o2, e2, n2, s2];
      var u3 = [r2 && e2 > 1 ? a2 - 1 : a2, r2 && n2 > 1 ? i2 - 1 : i2], c2 = [r2 && e2 > 1 ? e2 - 1 : e2, r2 && n2 > 1 ? n2 - 1 : n2];
      this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + u3[0] / c2[0] + ",\n          " + u3[1] / c2[1] + ");\n      const vec2 inputShapeRC = vec2(" + a2 + ".0, " + i2 + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";
    };
    ns = function(t2, e2, n2, r2) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = [];
      var o2 = t2[0], a2 = t2[1], i2 = t2[2], s2 = t2[3];
      this.outputShape = [o2, e2, n2, s2];
      var u3 = [r2 && e2 > 1 ? a2 - 1 : a2, r2 && n2 > 1 ? i2 - 1 : i2], c2 = [r2 && e2 > 1 ? e2 - 1 : e2, r2 && n2 > 1 ? n2 - 1 : n2];
      this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          " + u3[0] / c2[0] + ",\n          " + u3[1] / c2[1] + ",\n          " + u3[1] / c2[1] + ");\n      const vec3 inputShapeRC = vec3(" + a2 + ".0, " + i2 + ".0,\n                                     " + i2 + ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < " + (s2 - 1) + ";\n        bool hasNextRow = coords.z < " + (n2 - 1) + ";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ";
    };
    rs = function(t2, e2, n2) {
      this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e2.shape;
      var r2 = e2.shape, o2 = r2[1], a2 = r2[2], i2 = t2.shape, s2 = i2[1], u3 = i2[2], c2 = [n2 && s2 > 1 ? o2 - 1 : o2, n2 && u3 > 1 ? a2 - 1 : a2], l2 = [n2 && s2 > 1 ? s2 - 1 : s2, n2 && u3 > 1 ? u3 - 1 : u3], h2 = c2[0] / l2[0], f2 = c2[1] / l2[1], d2 = 1 / h2, p2 = 1 / f2, v = 2 * Math.ceil(d2) + 2, m = 2 * Math.ceil(p2) + 2;
      this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h2 + ");\n        const float widthScale = float(" + f2 + ");\n\n        const float invHeightScale = float(" + d2 + ");\n        const float invWidthScale = float(" + p2 + ");\n\n        const int winHeight = int(" + v + ");\n        const int winWidth = int(" + m + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + s2 + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + u3 + ") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(" + c2[0] + ") *\n                (float(dyR) / float(" + l2[0] + "));\n\n            float sourceFracCol =\n                float(" + c2[1] + ") *\n                  (float(dyC) / float(" + l2[1] + "));\n\n            int sourceNearestRow = int(min(\n                float(int(" + o2 + ") - 1),\n                " + n2 + " ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(" + a2 + ") - 1),\n                " + n2 + " ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
    };
    os = function(t2, e2, n2, r2) {
      this.variableNames = ["A"], this.outputShape = [];
      var o2 = t2[0], a2 = t2[1], i2 = t2[2], s2 = t2[3];
      this.outputShape = [o2, e2, n2, s2];
      var u3 = [r2 && e2 > 1 ? a2 - 1 : a2, r2 && n2 > 1 ? i2 - 1 : i2], c2 = [r2 && e2 > 1 ? e2 - 1 : e2, r2 && n2 > 1 ? n2 - 1 : n2], l2 = r2 ? "0.5" : "0.0";
      this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + u3[0] / c2[0] + ",\n          " + u3[1] / c2[1] + ");\n      const vec2 inputShapeRC = vec2(" + a2 + ".0, " + i2 + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + " + l2 + ")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ";
    };
    as = function(t2, e2) {
      this.variableNames = ["x"];
      var n2 = t2.length;
      if (n2 > 4) throw new Error("WebGL backend: Reverse of rank-" + n2 + " tensor is not yet supported");
      if (this.outputShape = t2, 1 !== n2) {
        var r2 = t2.map(function(n3, r3) {
          return function(n4) {
            return -1 !== e2.indexOf(n4) && 1 !== t2[n4] ? t2[n4] + " - coords[" + n4 + "] - 1" : "coords[" + n4 + "]";
          }(r3);
        }).join(","), o2 = wa(n2);
        this.userCode = "\n      void main() {\n        " + o2 + " coords = getOutputCoords();\n        setOutput(getX(" + r2 + "));\n      }\n    ";
      } else this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(" + t2[0] + " - coord - 1));\n        }\n      ";
    };
    is = function(t2, e2) {
      this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true;
      var n2 = t2.length;
      if (n2 > 4) throw new Error("WebGL backend: Reverse of rank-" + n2 + " tensor is not yet supported");
      this.outputShape = t2;
      var r2 = sa("rc", n2), o2 = r2[n2 - 1] + " + 1 < " + this.outputShape[n2 - 1], a2 = r2[n2 - 2] + " + 1 < " + this.outputShape[n2 - 2], i2 = wa(n2);
      function s2(n3) {
        var r3 = t2.map(function(r4, o3) {
          return function(n4, r5) {
            return -1 !== e2.indexOf(n4) && 1 !== t2[n4] ? t2[n4] + " - " + r5[n4] + " - 1" : "" + r5[n4];
          }(o3, n3);
        });
        return "getChannel(getX(" + r3.join(",") + "), vec2(" + r3.slice(-2).join(",") + "))";
      }
      this.userCode = 1 === n2 ? "\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(" + t2[0] + " - rc - 1),\n            " + t2[0] + " - rc - 1);\n          if(" + o2 + "){\n              result.g = getChannel(getX(" + t2[0] + " - (rc  + 1) - 1),\n                " + t2[0] + " - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      " : "\n        void main() {\n          " + i2 + " rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = " + function(t3) {
        return s2(t3);
      }(r2.slice()) + ";\n          if(" + o2 + "){\n            result.g = " + function(t3) {
        return t3[n2 - 1] = "(" + t3[n2 - 1] + " + 1)", s2(t3);
      }(r2.slice()) + ";\n          }\n          if(" + a2 + ") {\n            result.b = " + function(t3) {
        return t3[n2 - 2] = "(" + t3[n2 - 2] + " + 1)", s2(t3);
      }(r2.slice()) + ";\n            if(" + o2 + ") {\n              result.a = " + function(t3) {
        return t3[n2 - 1] = "(" + t3[n2 - 1] + " + 1)", t3[n2 - 2] = "(" + t3[n2 - 2] + " + 1)", s2(t3);
      }(r2.slice()) + ";\n            }\n          }\n          setOutput(result);\n        }\n    ";
    };
    ss = function(t2, e2, n2, r2, o2, a2, i2) {
      void 0 === i2 && (i2 = true), this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = a2;
      var s2 = wa(o2.length), u3 = wa(a2.length), c2 = "";
      1 === n2 ? c2 = "i" : 2 === n2 && (c2 = "i, j");
      var l2 = "getIndices(" + c2 + ")", h2 = "";
      1 === r2 ? h2 = "i" : 2 === r2 && (h2 = "i, coords[1]");
      var f2 = "getUpdates(" + h2 + ")", d2 = e2 > 1 ? "strides[j]" : "strides";
      this.userCode = "\n        " + s2 + " strides = " + s2 + "(" + o2 + ");\n\n        void main() {\n          " + u3 + " coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < " + t2 + "; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < " + e2 + "; j++) {\n              int index = round(" + l2 + ");\n              flattenedIndex += index * " + d2 + ";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += " + f2 + ";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      ";
    };
    us = function(t2, e2) {
      this.variableNames = ["x", "segmentIds"];
      var n2 = t2.windowSize, r2 = t2.batchSize, o2 = t2.inSize, a2 = t2.numSegments, i2 = a2 * Math.ceil(o2 / n2);
      this.outputShape = [r2, i2];
      var s2 = 4 * Math.floor(n2 / 4), u3 = n2 % 4, c2 = "\n        sumValue += dot(values, segFilter);\n    ", l2 = "";
      o2 % n2 > 0 && (l2 = "\n        if (inIdx < 0 || inIdx >= " + o2 + ") {\n          return initializationValue;\n        }\n      ");
      var h2 = "";
      o2 % n2 > 0 && (h2 = "\n        if (inIdx < 0 || inIdx >= " + o2 + ") {\n          return -1.0;\n        }\n      "), this.userCode = "\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        " + l2 + "\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        " + h2 + "\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          " + a2 + ")) * float(" + n2 + "));\n        int currentSeg = int(mod(float(outIdx), float(" + a2 + ")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + s2 + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          " + c2 + "\n        }\n\n        int inIdx = inOffset + " + s2 + ";\n        if (" + (1 === u3) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          " + c2 + "\n        } else if (" + (2 === u3) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          " + c2 + "\n        } else if (" + (3 === u3) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          " + c2 + "\n        }\n        setOutput(sumValue);\n      }\n    ";
    };
    cs = function(t2, e2, n2) {
      var r2, o2;
      if (this.variableNames = ["c", "a", "b"], this.outputShape = e2, n2 > 4) throw Error("Where for rank " + n2 + " is not yet supported");
      if (1 === n2) o2 = "resRC", r2 = "resRC";
      else {
        for (var a2 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], i2 = [], s2 = [], u3 = 0; u3 < e2.length; u3++) s2.push("" + a2[u3]), u3 < t2 && i2.push("" + a2[u3]);
        r2 = i2.join(), o2 = s2.join();
      }
      var c2 = wa(n2);
      this.userCode = "\n      void main() {\n        " + c2 + " resRC = getOutputCoords();\n        float cVal = getC(" + r2 + ");\n        if (cVal >= 1.0) {\n          setOutput(getA(" + o2 + "));\n        } else {\n          setOutput(getB(" + o2 + "));\n        }\n      }\n    ";
    };
    ls = function() {
      function t2(t3) {
        this.variableNames = ["source"], this.outputShape = t3, this.rank = t3.length;
        var e2, n2 = wa(this.rank), r2 = "uniform int start[" + this.rank + "];", o2 = function(t4) {
          if (1 === t4) return "sourceLoc";
          if (t4 <= 6) return hs.slice(0, t4).map(function(t5) {
            return "sourceLoc." + t5;
          }).join(",");
          throw Error("Slicing for rank " + t4 + " is not yet supported");
        }(this.rank);
        e2 = "\n        " + n2 + " sourceLoc;\n        " + n2 + " coords = getOutputCoords();\n        " + t3.map(function(t4, e3) {
          return "sourceLoc." + hs[e3] + " = start[" + e3 + "] + coords." + hs[e3] + ";";
        }).join("\n") + "\n      ", this.userCode = "\n      " + r2 + "\n      void main() {\n        " + e2 + "\n        setOutput(getSource(" + o2 + "));\n      }\n    ";
      }
      return t2.prototype.getCustomSetupFunc = function(t3) {
        var e2 = this;
        if (t3.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t3.length + ")");
        return function(n2, r2) {
          null == e2.startLoc && (e2.startLoc = n2.getUniformLocationNoThrow(r2, "start"), null == e2.startLoc) || n2.gl.uniform1iv(e2.startLoc, t3);
        };
      }, t2;
    }();
    hs = ["x", "y", "z", "w", "u", "v"];
    fs = function() {
      function t2(t3) {
        this.variableNames = ["source"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t3, this.rank = t3.length;
        var e2 = wa(this.rank), n2 = sa("coords", this.rank), r2 = sa("sourceLoc", this.rank), o2 = 1 === this.rank ? "sourceLoc" : "vec2(" + r2.slice(-2).join() + ")", a2 = "getChannel(getSource(" + r2.join() + "), " + o2 + ")", i2 = "\n      result.x = " + a2 + ";\n      if (++" + n2[this.rank - 1] + " < " + t3[this.rank - 1] + ") {\n        ++" + r2[this.rank - 1] + ";\n        result.y = " + a2 + ";\n        --" + r2[this.rank - 1] + ";\n      }\n    ", s2 = 1 === this.rank ? "" : "\n      --" + n2[this.rank - 1] + ";\n      if (++" + n2[this.rank - 2] + " < " + t3[this.rank - 2] + ") {\n        ++" + r2[this.rank - 2] + ";\n        result.z = " + a2 + ";\n        if (++" + n2[this.rank - 1] + " < " + t3[this.rank - 1] + ") {\n          ++" + r2[this.rank - 1] + ";\n          result.w = " + a2 + ";\n        }\n      }\n    ", u3 = this.rank <= 4 ? "sourceLoc = coords +\n            " + e2 + "(" + t3.map(function(t4, e3) {
          return "start[" + e3 + "]";
        }).join() + ");" : t3.map(function(t4, e3) {
          return r2[e3] + " = " + n2[e3] + " + start[" + e3 + "];";
        }).join("\n");
        this.userCode = "\n      uniform int start[" + this.rank + "];\n      void main() {\n        " + e2 + " coords = getOutputCoords();\n        " + e2 + " sourceLoc;\n        " + u3 + "\n        vec4 result = vec4(0.);\n        " + i2 + "\n        " + s2 + "\n        setOutput(result);\n      }\n    ";
      }
      return t2.prototype.getCustomSetupFunc = function(t3) {
        var e2 = this;
        if (t3.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t3.length + ")");
        return function(n2, r2) {
          null == e2.startLoc && (e2.startLoc = n2.getUniformLocationNoThrow(r2, "start"), null == e2.startLoc) || n2.gl.uniform1iv(e2.startLoc, t3);
        };
      }, t2;
    }();
    ds = function(t2, e2, n2) {
      this.variableNames = ["x"], this.outputShape = n2;
      var r2 = n2.length, o2 = wa(n2.length), a2 = wa(n2.length), i2 = "";
      if (1 === r2) i2 = "coords * strides + begin";
      else {
        var s2 = 0;
        i2 = n2.map(function(t3, e3) {
          return s2++, 1 === n2.length ? "coords * strides[" + e3 + "] + begin[" + e3 + "]" : "coords[" + (s2 - 1) + "] * strides[" + e3 + "] + begin[" + e3 + "]";
        }).join(",");
      }
      this.userCode = "\n      " + o2 + " begin = " + o2 + "(" + t2 + ");\n      " + o2 + " strides = " + o2 + "(" + e2 + ");\n\n      void main() {\n        " + a2 + " coords = getOutputCoords();\n        setOutput(getX(" + i2 + "));\n      }\n    ";
    };
    ps = function() {
      function t2(t3) {
        this.gpgpu = t3, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = {}, this.logEnabled = false, this.usedTextures = {};
      }
      return t2.prototype.acquireTexture = function(t3, e2, n2) {
        var r2, o2 = vs(e2, n2), a2 = ms(t3, o2, n2);
        if (a2 in this.freeTextures || (this.freeTextures[a2] = []), a2 in this.usedTextures || (this.usedTextures[a2] = []), this.freeTextures[a2].length > 0) {
          this.numFreeTextures--, this.numUsedTextures++, this.log();
          var i2 = this.freeTextures[a2].shift();
          return this.usedTextures[a2].push(i2), i2;
        }
        return this.numUsedTextures++, this.log(), o2 === Gt.PACKED_2X2_FLOAT32 ? r2 = this.gpgpu.createPackedMatrixTexture(t3[0], t3[1]) : o2 === Gt.PACKED_2X2_FLOAT16 ? r2 = this.gpgpu.createFloat16PackedMatrixTexture(t3[0], t3[1]) : o2 === Gt.UNPACKED_FLOAT32 ? r2 = this.gpgpu.createFloat32MatrixTexture(t3[0], t3[1]) : o2 === Gt.UNPACKED_FLOAT16 ? r2 = this.gpgpu.createFloat16MatrixTexture(t3[0], t3[1]) : o2 === Gt.PACKED_4X1_UNSIGNED_BYTE && (r2 = this.gpgpu.createUnsignedBytesMatrixTexture(t3[0], t3[1])), this.usedTextures[a2].push(r2), r2;
      }, t2.prototype.releaseTexture = function(t3, e2, n2, r2) {
        if (null != this.freeTextures) {
          var o2 = ms(e2, vs(n2, r2), r2);
          o2 in this.freeTextures || (this.freeTextures[o2] = []), this.freeTextures[o2].push(t3), this.numFreeTextures++, this.numUsedTextures--;
          var a2 = this.usedTextures[o2], i2 = a2.indexOf(t3);
          if (i2 < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
          a2.splice(i2, 1), this.log();
        }
      }, t2.prototype.log = function() {
        if (this.logEnabled) {
          var t3 = this.numFreeTextures + this.numUsedTextures;
          console.log("Free/Used", this.numFreeTextures + " / " + this.numUsedTextures, "(" + t3 + ")");
        }
      }, t2.prototype.getNumUsedTextures = function() {
        return this.numUsedTextures;
      }, t2.prototype.getNumFreeTextures = function() {
        return this.numFreeTextures;
      }, t2.prototype.dispose = function() {
        var t3 = this;
        if (null != this.freeTextures) {
          for (var e2 in this.freeTextures) this.freeTextures[e2].forEach(function(e3) {
            t3.gpgpu.deleteMatrixTexture(e3);
          });
          for (var e2 in this.usedTextures) this.usedTextures[e2].forEach(function(e3) {
            t3.gpgpu.deleteMatrixTexture(e3);
          });
          this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0;
        }
      }, t2;
    }();
    gs = function(t2, e2) {
      this.variableNames = ["A"];
      for (var n2 = new Array(t2.length), r2 = 0; r2 < n2.length; r2++) n2[r2] = t2[r2] * e2[r2];
      this.outputShape = n2, this.rank = n2.length;
      var o2 = wa(this.rank), a2 = function(t3) {
        var e3 = t3.length;
        if (e3 > 5) throw Error("Tile for rank " + e3 + " is not yet supported");
        if (1 === e3) return "imod(resRC, " + t3[0] + ")";
        for (var n3 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], r3 = [], o3 = 0; o3 < t3.length; o3++) r3.push("imod(" + n3[o3] + ", " + t3[o3] + ")");
        return r3.join();
      }(t2);
      this.userCode = "\n      void main() {\n        " + o2 + " resRC = getOutputCoords();\n        setOutput(getA(" + a2 + "));\n      }\n    ";
    };
    ys = function(t2, e2) {
      this.variableNames = ["A"];
      for (var n2 = new Array(t2.length), r2 = 0; r2 < n2.length; r2++) n2[r2] = t2[e2[r2]];
      this.outputShape = n2, this.rank = n2.length;
      var o2 = wa(this.rank), a2 = function(t3) {
        var e3 = t3.length;
        if (e3 > 6) throw Error("Transpose for rank " + e3 + " is not yet supported");
        for (var n3 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], r3 = new Array(e3), o3 = 0; o3 < t3.length; o3++) r3[t3[o3]] = n3[o3];
        return r3.join();
      }(e2);
      this.userCode = "\n    void main() {\n      " + o2 + " resRC = getOutputCoords();\n      setOutput(getA(" + a2 + "));\n    }\n    ";
    };
    xs = function(t2, e2) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true;
      for (var n2 = new Array(t2.length), r2 = 0; r2 < n2.length; r2++) n2[r2] = t2[e2[r2]];
      if (this.outputShape = n2, this.rank = n2.length, this.rank > 6) throw Error("Packed transpose for rank " + this.rank + " is not yet supported.");
      var o2 = wa(this.rank), a2 = ia("rc", this.rank), i2 = new Array(this.rank);
      for (r2 = 0; r2 < e2.length; r2++) i2[e2[r2]] = a2[r2];
      var s2 = "vec2(" + i2.slice(-2).join() + ")", u3 = "++" + a2[this.rank - 1] + " < " + n2[this.rank - 1], c2 = "getChannel(getA(" + i2.join() + "), " + s2 + ")";
      this.userCode = "\n    void main() {\n      " + o2 + " rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = " + c2 + ";\n      if(" + u3 + ") {\n        result[1] = " + c2 + ";\n      }\n      --" + a2[this.rank - 1] + ";\n      if(++" + a2[this.rank - 2] + " < " + n2[this.rank - 2] + ") {\n        result[2] = " + c2 + ";\n        if(" + u3 + ") {\n          result[3] = " + c2 + ";\n        }\n      }\n      setOutput(result);\n    }\n    ";
    };
    bs = 1.7580993408473768;
    ws = 1.0507009873554805;
    Cs = function(t2, e2) {
      this.variableNames = ["A"], this.outputShape = t2, this.userCode = "\n      float unaryOperation(float x) {\n        " + e2 + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
    };
    Es = "if (isnan(x)) return x;";
    Rs = "return x;";
    Is = "return abs(x);";
    ks = Es + "\n  return (x < 0.0) ? 0.0 : x;\n";
    Ss = Es + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";
    As = "return (x >= 0.0) ? x : (exp(x) - 1.0);";
    Ds = "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = " + bs + ";\n  float scale = " + ws + ";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";
    Ts = "return -x;";
    Ns = "return ceil(x);";
    Fs = "return floor(x);";
    _s = "return exp(x);";
    Os = "return exp(x) - 1.0;";
    Ms = Es + "\n  return sin(x);\n";
    Bs = Es + "\n  return cos(x);\n";
    Ps = Es + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n";
    Ls = Es + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n";
    Ws = Es + "\n  return atan(x);\n";
    Us = Es + "return log(x + sqrt(x * x + 1.0));";
    Vs = Es + "\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));";
    zs = Es + "\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;";
    Gs = "return x;";
    Hs = "return x;";
    qs = "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";
    Ks = "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";
    js = "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n";
    Xs = function(t2, e2) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t2, this.userCode = "\n      vec4 unaryOperation(vec4 x) {\n        " + e2 + "\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
    };
    Ys = function(t2) {
      this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = false, this.outputShape = t2;
      var e2 = t2.length, n2 = sa("rc", e2), r2 = wa(e2), o2 = function(t3, e3) {
        if (1 === t3) return "rc";
        for (var n3 = "", r3 = 0; r3 < t3; r3++) n3 += e3[r3], r3 < t3 - 1 && (n3 += ",");
        return n3;
      }(e2, n2), a2 = n2.slice(-2), i2 = e2 <= 1 ? "rc" : "vec2(" + a2.join(",") + ")";
      this.userCode = "\n      void main() {\n        " + r2 + " rc = getOutputCoords();\n        vec4 packedInput = getA(" + o2 + ");\n\n        setOutput(getChannel(packedInput, " + i2 + "));\n      }\n    ";
    };
    $s = {};
    Js = 600;
    Zs = function(t2) {
      function o2(e2) {
        var n2, r2 = t2.call(this) || this;
        if (r2.pendingRead = /* @__PURE__ */ new WeakMap(), r2.pendingDisposal = /* @__PURE__ */ new WeakSet(), r2.dataRefCount = /* @__PURE__ */ new WeakMap(), r2.numBytesInGPU = 0, r2.uploadWaitMs = 0, r2.downloadWaitMs = 0, r2.warnedAboutMemory = false, r2.pendingDeletes = 0, r2.disposed = false, !i().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");
        if (null == e2) {
          var o3 = jt(i().getNumber("WEBGL_VERSION"));
          r2.binaryCache = (n2 = i().getNumber("WEBGL_VERSION")) in $s ? $s[n2] : ($s[n2] = {}, $s[n2]), r2.gpgpu = new Bi(o3), r2.canvas = o3.canvas, r2.gpgpuCreatedLocally = true;
        } else r2.gpgpu = e2, r2.binaryCache = {}, r2.gpgpuCreatedLocally = false, r2.canvas = e2.gl.canvas;
        return r2.textureManager = new ps(r2.gpgpu), r2.numMBBeforeWarning = null == i().global.screen ? 1024 : i().global.screen.height * i().global.screen.width * window.devicePixelRatio * Js / 1024 / 1024, r2.texData = new xo(r2, Lt), r2;
      }
      return e(o2, t2), o2.prototype.numDataIds = function() {
        return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes;
      }, o2.prototype.write = function(t3, e2, n2) {
        if (i().getBool("DEBUG") && this.checkNumericalProblems(t3), "complex64" === n2 && null != t3) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
        var r2 = {};
        return this.texData.set(r2, { shape: e2, dtype: n2, values: t3, usage: zt.UPLOAD }), r2;
      }, o2.prototype.move = function(t3, e2, n2, r2) {
        if (i().getBool("DEBUG") && this.checkNumericalProblems(e2), "complex64" === r2) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
        this.texData.set(t3, { shape: n2, dtype: r2, values: e2, usage: zt.UPLOAD });
      }, o2.prototype.readSync = function(t3) {
        var e2 = this.texData.get(t3), n2 = e2.values, r2 = e2.dtype, o3 = e2.complexTensors, a2 = e2.slice, i2 = e2.shape, s2 = e2.isPacked;
        if (null != a2) {
          var u3 = void 0;
          u3 = s2 ? new Xs(i2, Gs) : new Cs(i2, Gs);
          var c2 = this.runWebGLProgram(u3, [{ dataId: t3, shape: i2, dtype: r2 }], r2), l2 = this.readSync(c2.dataId);
          return this.disposeData(c2.dataId), l2;
        }
        if (null != n2) return this.convertAndCacheOnCPU(t3);
        if ("string" === r2) return n2;
        var h2, f2, d2 = null != this.activeTimers;
        (d2 && (h2 = et()), "complex64" === r2) ? f2 = Vo(o3.real.dataSync(), o3.imag.dataSync()) : f2 = this.getValuesFromTexture(t3);
        return d2 && (this.downloadWaitMs += et() - h2), this.convertAndCacheOnCPU(t3, f2);
      }, o2.prototype.read = function(t3) {
        return n(this, void 0, void 0, function() {
          var e2, n2, o3, a2, s2, u3, c2, l2, h2, f2, d2, p2, v, m, g2, y2, x2, b2, w2, C2, E2, R2;
          return r(this, function(r2) {
            switch (r2.label) {
              case 0:
                if (this.pendingRead.has(t3)) return e2 = this.pendingRead.get(t3), [2, new Promise(function(t4) {
                  return e2.push(t4);
                })];
                if (n2 = this.texData.get(t3), o3 = n2.values, a2 = n2.shape, s2 = n2.slice, u3 = n2.dtype, c2 = n2.complexTensors, l2 = n2.isPacked, null != s2) return h2 = void 0, h2 = l2 ? new Xs(a2, Gs) : new Cs(a2, Gs), f2 = this.runWebGLProgram(h2, [{ dataId: t3, shape: a2, dtype: u3 }], u3), d2 = this.read(f2.dataId), this.disposeData(f2.dataId), [2, d2];
                if (null != o3) return [2, this.convertAndCacheOnCPU(t3)];
                if (!i().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && 2 === i().getNumber("WEBGL_VERSION")) throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
                return p2 = null, "complex64" !== u3 && i().get("WEBGL_BUFFER_SUPPORTED") && (v = this.decode(t3), m = this.texData.get(v.dataId), p2 = (R2 = this.gpgpu).createBufferFromTexture.apply(R2, [m.texture].concat(Yt(a2)))), this.pendingRead.set(t3, []), "complex64" === u3 ? [3, 2] : [4, this.gpgpu.createAndWaitForFence()];
              case 1:
                r2.sent(), r2.label = 2;
              case 2:
                return "complex64" !== u3 ? [3, 4] : [4, Promise.all([c2.real.data(), c2.imag.data()])];
              case 3:
                return y2 = r2.sent(), x2 = y2[0], b2 = y2[1], g2 = Vo(x2, b2), [3, 5];
              case 4:
                null == p2 ? g2 = this.getValuesFromTexture(t3) : (w2 = k(a2), g2 = this.gpgpu.downloadFloat32MatrixFromBuffer(p2, w2)), r2.label = 5;
              case 5:
                return null != v && this.disposeData(v.dataId), C2 = this.convertAndCacheOnCPU(t3, g2), E2 = this.pendingRead.get(t3), this.pendingRead.delete(t3), E2.forEach(function(t4) {
                  return t4(C2);
                }), this.pendingDisposal.has(t3) && (this.pendingDisposal.delete(t3), this.disposeData(t3), this.pendingDeletes--), [2, C2];
            }
          });
        });
      }, o2.prototype.checkNumericalProblems = function(t3) {
        if (null != t3) for (var e2 = 0; e2 < t3.length; e2++) {
          var n2 = t3[e2];
          if (!ee(n2)) {
            if (i().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) throw Error("The value " + n2 + " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");
            throw Error("The value " + n2 + " cannot be represented on this device.");
          }
        }
      }, o2.prototype.getValuesFromTexture = function(t3) {
        var e2, n2 = this.texData.get(t3), r2 = n2.shape, o3 = n2.dtype, a2 = n2.isPacked, s2 = k(r2);
        if (i().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
          var u3 = this.decode(t3), c2 = this.texData.get(u3.dataId), l2 = (e2 = this.gpgpu).downloadMatrixFromPackedTexture.apply(e2, [c2.texture].concat(Yt(r2))).subarray(0, s2);
          return this.disposeData(u3.dataId), l2;
        }
        var h2 = i().getBool("WEBGL_PACK") && true === a2, f2 = h2 ? Te(r2) : r2, d2 = h2 ? new ci(f2) : new ui(f2), p2 = this.runWebGLProgram(d2, [{ shape: f2, dtype: o3, dataId: t3 }], "float32"), v = this.texData.get(p2.dataId), m = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(v.texture, v.texShape[0], v.texShape[1]).subarray(0, s2);
        return this.disposeData(p2.dataId), m;
      }, o2.prototype.time = function(t3) {
        return n(this, void 0, void 0, function() {
          var e2, n2, o3, a2, s2, u3, c2;
          return r(this, function(r2) {
            switch (r2.label) {
              case 0:
                return e2 = this.activeTimers, n2 = [], o3 = false, null == this.programTimersStack ? (this.programTimersStack = n2, o3 = true) : this.activeTimers.push(n2), this.activeTimers = n2, t3(), a2 = I(this.activeTimers.map(function(t4) {
                  return t4.query;
                })).filter(function(t4) {
                  return null != t4;
                }), s2 = I(this.activeTimers.map(function(t4) {
                  return t4.name;
                })).filter(function(t4) {
                  return null != t4;
                }), this.activeTimers = e2, o3 && (this.programTimersStack = null), u3 = { uploadWaitMs: this.uploadWaitMs, downloadWaitMs: this.downloadWaitMs, kernelMs: null, wallMs: null }, i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? [4, Promise.all(a2)] : [3, 2];
              case 1:
                return c2 = r2.sent(), u3.kernelMs = w(c2), u3.getExtraProfileInfo = function() {
                  return c2.map(function(t4, e3) {
                    return { name: s2[e3], ms: t4 };
                  }).map(function(t4) {
                    return t4.name + ": " + t4.ms;
                  }).join(", ");
                }, [3, 3];
              case 2:
                u3.kernelMs = { error: "WebGL query timers are not supported in this environment." }, r2.label = 3;
              case 3:
                return this.uploadWaitMs = 0, this.downloadWaitMs = 0, [2, u3];
            }
          });
        });
      }, o2.prototype.memory = function() {
        return { unreliable: false, numBytesInGPU: this.numBytesInGPU };
      }, o2.prototype.startTimer = function() {
        return i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : { startMs: et(), endMs: null };
      }, o2.prototype.endTimer = function(t3) {
        return i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), t3) : (t3.endMs = et(), t3);
      }, o2.prototype.getQueryTime = function(t3) {
        return n(this, void 0, void 0, function() {
          var e2;
          return r(this, function(n2) {
            return i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? [2, this.gpgpu.waitForQueryAndGetTime(t3)] : [2, (e2 = t3).endMs - e2.startMs];
          });
        });
      }, o2.prototype.disposeData = function(t3) {
        if (!this.pendingDisposal.has(t3)) {
          if (this.pendingRead.has(t3)) return this.pendingDisposal.add(t3), void this.pendingDeletes++;
          if (this.texData.has(t3)) {
            this.releaseGPUData(t3);
            var e2 = this.texData.get(t3).complexTensors;
            null != e2 && (e2.real.dispose(), e2.imag.dispose()), this.texData.delete(t3);
          }
        }
      }, o2.prototype.releaseGPUData = function(t3) {
        var e2 = this.texData.get(t3), n2 = e2.texture, r2 = e2.dtype, o3 = e2.texShape, a2 = e2.usage, i2 = e2.isPacked, s2 = e2.slice, u3 = s2 && s2.origDataId || t3, c2 = this.dataRefCount.get(u3);
        c2 > 1 ? this.dataRefCount.set(u3, c2 - 1) : (this.dataRefCount.delete(u3), null != n2 && (this.numBytesInGPU -= this.computeBytes(o3, r2), this.textureManager.releaseTexture(n2, o3, a2, i2)));
        var l2 = this.texData.get(t3);
        l2.texture = null, l2.texShape = null, l2.isPacked = false, l2.slice = null;
      }, o2.prototype.getTexture = function(t3) {
        return this.uploadToGPU(t3), this.texData.get(t3).texture;
      }, o2.prototype.getDataInfo = function(t3) {
        return this.texData.get(t3);
      }, o2.prototype.getCPUBackend = function() {
        return i().getBool("WEBGL_CPU_FORWARD") ? (null == this.cpuBackend && (this.cpuBackend = Lt.findBackend("cpu")), this.cpuBackend) : null;
      }, o2.prototype.shouldExecuteOnCPU = function(t3, e2) {
        var n2 = this;
        return void 0 === e2 && (e2 = 128), null != this.getCPUBackend() && t3.every(function(t4) {
          return null == n2.texData.get(t4.dataId).texture && t4.size < e2;
        });
      }, o2.prototype.getGPGPUContext = function() {
        return this.gpgpu;
      }, o2.prototype.complex = function(t3, e2) {
        var n2 = this.makeOutput(t3.shape, "complex64");
        return this.texData.get(n2.dataId).complexTensors = { real: Lt.keep(t3.clone()), imag: Lt.keep(e2.clone()) }, n2;
      }, o2.prototype.real = function(t3) {
        return this.texData.get(t3.dataId).complexTensors.real.clone();
      }, o2.prototype.imag = function(t3) {
        return this.texData.get(t3.dataId).complexTensors.imag.clone();
      }, o2.prototype.slice = function(t3, e2, n2) {
        if (this.shouldExecuteOnCPU([t3])) return this.cpuBackend.slice(t3, e2, n2);
        if (0 === k(n2)) return Fn([], n2, t3.dtype);
        var r2 = this.texData.get(t3.dataId).isPacked, o3 = io(t3.shape, e2, n2);
        if (r2 || !o3) {
          var a2 = i().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new fs(n2) : new ls(n2), s2 = a2.getCustomSetupFunc(e2);
          return this.compileAndRun(a2, [t3], null, s2);
        }
        return this.uploadToGPU(t3.dataId), this.shallowSlice(t3, e2, n2);
      }, o2.prototype.shallowSlice = function(t3, e2, n2) {
        var r2 = this.texData.get(t3.dataId), o3 = this.makeOutput(n2, t3.dtype), a2 = this.texData.get(o3.dataId);
        Object.assign(a2, r2), a2.shape = n2, a2.dtype = t3.dtype;
        var i2 = so(e2, t3.strides);
        r2.slice && (i2 += r2.slice.flatOffset), a2.slice = { flatOffset: i2, origDataId: r2.slice && r2.slice.origDataId || t3.dataId };
        var s2 = this.dataRefCount.get(a2.slice.origDataId) || 1;
        return this.dataRefCount.set(a2.slice.origDataId, s2 + 1), o3;
      }, o2.prototype.stridedSlice = function(t3, e2, n2, r2) {
        if (this.shouldExecuteOnCPU([t3])) return this.cpuBackend.stridedSlice(t3, e2, n2, r2);
        var o3 = ro(e2, n2, r2);
        if (o3.some(function(t4) {
          return 0 === t4;
        })) return Fn([], o3);
        var a2 = new ds(e2, r2, o3);
        return this.compileAndRun(a2, [t3]);
      }, o2.prototype.reverse = function(t3, e2) {
        var n2 = i().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new is(t3.shape, e2) : new as(t3.shape, e2);
        return this.compileAndRun(n2, [t3]);
      }, o2.prototype.concat = function(t3, e2) {
        if ("complex64" === t3[0].dtype) {
          var n2 = t3.map(function(t4) {
            return Tn(t4);
          }), r2 = t3.map(function(t4) {
            return Nn(t4);
          });
          return Dn(this.concat(n2, e2), this.concat(r2, e2));
        }
        if (this.shouldExecuteOnCPU(t3)) return this.cpuBackend.concat(t3, e2);
        if (1 === t3.length) return t3[0];
        if (t3.length > i().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
          var o3 = Math.floor(t3.length / 2), a2 = this.concat(t3.slice(0, o3), e2), s2 = this.concat(t3.slice(o3), e2);
          return this.concat([a2, s2], e2);
        }
        if (i().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && t3[0].rank > 1) {
          var u3 = new Ga(t3.map(function(t4) {
            return t4.shape;
          }), e2);
          return this.compileAndRun(u3, t3);
        }
        var c2 = Sn(t3.map(function(t4) {
          return t4.shape;
        }), e2), l2 = t3.map(function(t4) {
          return t4.as2D(-1, k(t4.shape.slice(e2)));
        }), h2 = new za(l2.map(function(t4) {
          return t4.shape;
        }));
        return this.compileAndRun(h2, l2).reshape(c2);
      }, o2.prototype.neg = function(t3) {
        if (this.shouldExecuteOnCPU([t3])) return this.cpuBackend.neg(t3);
        if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t3, Ts, t3.dtype);
        var e2 = new Cs(t3.shape, Ts);
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.batchMatMul = function(t3, e2, n2, r2) {
        var o3 = n2 ? t3.shape[2] : t3.shape[1], a2 = r2 ? e2.shape[1] : e2.shape[2], i2 = n2 ? t3.shape[1] : t3.shape[2], s2 = t3.shape[0];
        if ((1 === o3 || 1 === a2) && i2 > 1e3) {
          n2 && (t3 = t3.transpose([0, 2, 1])), r2 && (e2 = e2.transpose([0, 2, 1]));
          var u3 = 1 === a2 ? t3 : t3.as3D(s2, i2, 1), c2 = 1 === a2 ? 2 : 1, l2 = 1 === a2 ? e2.as3D(s2, 1, i2) : e2;
          return this.multiply(u3, l2).sum(c2, true);
        }
        var h2 = Dt(t3.dtype, e2.dtype), f2 = new Hi(t3.shape, [s2, o3, a2], n2, r2);
        return this.compileAndRun(f2, [t3, e2], h2);
      }, o2.prototype.fusedBatchMatMul = function(t3) {
        var e2 = t3.a, n2 = t3.b, r2 = t3.transposeA, o3 = t3.transposeB, a2 = t3.bias, i2 = t3.activation, s2 = t3.preluActivationWeights, u3 = r2 ? e2.shape[2] : e2.shape[1], c2 = o3 ? n2.shape[1] : n2.shape[2], l2 = e2.shape[0], h2 = Dt(e2.dtype, n2.dtype), f2 = null != a2, d2 = null != s2, p2 = i2 ? Qs(i2, true) : null, v = new Hi(e2.shape, [l2, u3, c2], r2, o3, f2, p2, d2), m = [e2, n2];
        return a2 && m.push(a2), s2 && m.push(s2), this.compileAndRun(v, m, h2);
      }, o2.prototype.multiply = function(t3, e2) {
        if ("complex64" === t3.dtype) {
          var n2 = this.texData.get(t3.dataId), r2 = this.texData.get(e2.dataId), o3 = new Na(Da, t3.shape, e2.shape), a2 = new Na(Ta, t3.shape, e2.shape), s2 = [this.makeComplexComponentTensorInfo(t3, n2.complexTensors.real), this.makeComplexComponentTensorInfo(t3, n2.complexTensors.imag), this.makeComplexComponentTensorInfo(e2, r2.complexTensors.real), this.makeComplexComponentTensorInfo(e2, r2.complexTensors.imag)], u3 = this.compileAndRun(o3, s2), c2 = this.compileAndRun(a2, s2), l2 = this.complex(u3, c2);
          return u3.dispose(), c2.dispose(), l2;
        }
        if (this.shouldExecuteOnCPU([t3, e2])) return this.cpuBackend.multiply(t3, e2);
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t3, e2, Oa, t3.dtype);
        var h2 = new Ba(Oa, t3.shape, e2.shape);
        return this.compileAndRun(h2, [t3, e2], t3.dtype);
      }, o2.prototype.batchNormalization = function(t3, e2, n2, r2, o3, a2) {
        var s2 = [t3, e2, n2], u3 = null;
        null != a2 && (u3 = a2.shape, s2.push(a2));
        var c2 = null;
        if (null != o3 && (c2 = o3.shape, s2.push(o3)), i().getBool("WEBGL_PACK_NORMALIZATION")) {
          var l2 = new Aa(t3.shape, e2.shape, n2.shape, u3, c2, r2);
          return this.compileAndRun(l2, s2);
        }
        var h2 = new Sa(t3.shape, e2.shape, n2.shape, u3, c2, r2);
        return this.compileAndRun(h2, s2);
      }, o2.prototype.localResponseNormalization4D = function(t3, e2, n2, r2, o3) {
        var a2 = i().getBool("WEBGL_PACK_NORMALIZATION") ? new Vi(t3.shape, e2, n2, r2, o3) : new Wi(t3.shape, e2, n2, r2, o3);
        return this.compileAndRun(a2, [t3]);
      }, o2.prototype.LRNGrad = function(t3, e2, n2, r2, o3, a2, i2) {
        var s2 = new Ui(e2.shape, r2, o3, a2, i2);
        return this.compileAndRun(s2, [e2, n2, t3]);
      }, o2.prototype.tile = function(t3, e2) {
        if ("string" === t3.dtype) {
          var n2 = this.readSync(t3.dataId).map(function(t4) {
            return ot(t4);
          });
          return ta(dr(t3.shape, t3.dtype, n2), e2);
        }
        var r2 = new gs(t3.shape, e2);
        return this.compileAndRun(r2, [t3]);
      }, o2.prototype.pad = function(t3, e2, n2) {
        var r2 = i().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Yi(t3.shape, e2, n2) : new Xi(t3.shape, e2, n2);
        return this.compileAndRun(r2, [t3]);
      }, o2.prototype.transpose = function(t3, e2) {
        if (this.shouldExecuteOnCPU([t3])) return this.cpuBackend.transpose(t3, e2);
        var n2 = i().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new xs(t3.shape, e2) : new ys(t3.shape, e2);
        return this.compileAndRun(n2, [t3]);
      }, o2.prototype.gather = function(t3, e2, n2) {
        if (this.shouldExecuteOnCPU([t3, e2])) return this.cpuBackend.gather(t3, e2, n2);
        var r2 = new mi(t3.shape, e2.size, n2);
        return this.compileAndRun(r2, [t3, e2]);
      }, o2.prototype.batchToSpaceND = function(t3, e2, n2) {
        C(t3.rank <= 4, function() {
          return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet";
        });
        var r2 = e2.reduce(function(t4, e3) {
          return t4 * e3;
        }), o3 = zr(t3.shape, e2, r2), a2 = Gr(o3.length, e2.length), i2 = Hr(t3.shape, e2, r2), s2 = qr(n2, e2.length), u3 = Kr(i2, n2, e2.length);
        return t3.reshape(o3).transpose(a2).reshape(i2).slice(s2, u3);
      }, o2.prototype.spaceToBatchND = function(t3, e2, n2) {
        C(t3.rank <= 4, function() {
          return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet";
        });
        var r2 = e2.reduce(function(t4, e3) {
          return t4 * e3;
        }), o3 = [[0, 0]];
        o3.push.apply(o3, n2);
        for (var a2 = 1 + e2.length; a2 < t3.shape.length; ++a2) o3.push([0, 0]);
        var i2 = t3.pad(o3), s2 = zr(i2.shape, e2, r2, false), u3 = Gr(s2.length, e2.length, false), c2 = Hr(i2.shape, e2, r2, false);
        return i2.reshape(s2).transpose(u3).reshape(c2);
      }, o2.prototype.reduce = function(t3, e2, n2) {
        var r2 = t3.shape[0], o3 = t3.shape[1], a2 = $r(o3), i2 = new Ji({ windowSize: a2, inSize: o3, batchSize: r2 }, e2), s2 = this.compileAndRun(i2, [t3], n2);
        return 1 === s2.shape[1] ? s2 : this.reduce(s2, e2, n2);
      }, o2.prototype.argReduce = function(t3, e2, n2) {
        void 0 === n2 && (n2 = null);
        var r2 = t3.shape[0], o3 = t3.shape[1];
        null != n2 && (r2 = n2.shape[0], o3 = n2.shape[1]);
        var a2 = $r(o3), i2 = new aa({ windowSize: a2, inSize: o3, batchSize: r2 }, e2, null == n2), s2 = [t3];
        null != n2 && s2.push(n2);
        var u3 = this.compileAndRun(i2, s2, "int32");
        return 1 === u3.shape[1] ? u3 : this.argReduce(t3, e2, u3);
      }, o2.prototype.argReducePacked = function(t3, e2, n2) {
        void 0 === n2 && (n2 = null);
        var r2 = null != n2 ? n2.shape : t3.shape, o3 = $r(r2[r2.length - 1]), a2 = new Ra(r2, o3, e2, null == n2), i2 = null == n2 ? [t3] : [t3, n2], s2 = this.compileAndRun(a2, i2, "int32");
        return s2.rank === t3.rank ? this.argReducePacked(t3, e2, s2) : s2;
      }, o2.prototype.sum = function(t3, e2) {
        Cn("sum", e2, t3.rank);
        var n2 = bn(t3.shape, e2), r2 = n2[0], o3 = k(n2[1]), a2 = t3.as2D(-1, o3), i2 = Tt(t3.dtype);
        return this.reduce(a2, "sum", i2).reshape(r2);
      }, o2.prototype.prod = function(t3, e2) {
        if (this.shouldExecuteOnCPU([t3])) return this.cpuBackend.prod(t3, e2);
        var n2 = bn(t3.shape, e2), r2 = n2[0], o3 = k(n2[1]), a2 = t3.as2D(-1, o3), i2 = Tt(t3.dtype);
        return this.reduce(a2, "prod", i2).reshape(r2);
      }, o2.prototype.unsortedSegmentSum = function(t3, e2, n2) {
        var r2 = 0, o3 = En([r2], t3.rank), a2 = t3;
        null != o3 && (a2 = t3.transpose(o3), r2 = In(1, t3.rank)[0]);
        var i2 = function(t4, e3, n3) {
          for (var r3 = [], o4 = t4.length, a3 = 0; a3 < o4; a3++) a3 !== e3 ? r3.push(t4[a3]) : r3.push(n3);
          return r3;
        }(a2.shape, r2, n2), s2 = k([a2.shape[r2]]), u3 = a2.as2D(-1, s2), c2 = Tt(t3.dtype), l2 = this.segOpCompute(u3, "unsortedSegmentSum", e2, c2, n2).reshape(i2);
        return null != o3 && (l2 = l2.transpose(Rn(o3))), l2;
      }, o2.prototype.segOpCompute = function(t3, e2, n2, r2, o3) {
        var a2 = t3.shape[0], i2 = t3.shape[1], s2 = function(t4, e3) {
          var n3, r3 = false;
          for (t4 <= Yr ? (n3 = t4, r3 = true) : n3 = Y(t4, Math.floor(Math.sqrt(t4))); !r3; ) n3 > e3 || n3 === t4 ? r3 = true : n3 = Y(t4, n3 + 1);
          return n3;
        }(i2, o3), u3 = new us({ windowSize: s2, inSize: i2, batchSize: a2, numSegments: o3 }, e2), c2 = this.compileAndRun(u3, [t3, n2], r2);
        return c2.shape[1] === o3 ? c2 : (n2 = Kn(0, o3).tile([i2 / s2]), this.segOpCompute(c2, e2, n2, r2, o3));
      }, o2.prototype.argMinMaxReduce = function(t3, e2, n2) {
        var r2 = [e2];
        if (Cn("arg" + n2.charAt(0).toUpperCase() + n2.slice(1), r2, t3.rank), !i().getBool("WEBGL_PACK_REDUCE") || t3.rank <= 2) {
          var o3 = bn(t3.shape, r2), a2 = o3[0], s2 = k(o3[1]), u3 = t3.as2D(-1, s2);
          return this.argReduce(u3, n2).reshape(a2);
        }
        return this.argReducePacked(t3, n2);
      }, o2.prototype.argMin = function(t3, e2) {
        return this.argMinMaxReduce(t3, e2, "min");
      }, o2.prototype.argMax = function(t3, e2) {
        return this.argMinMaxReduce(t3, e2, "max");
      }, o2.prototype.cumsum = function(t3, e2, n2, r2) {
        if (e2 !== t3.rank - 1) throw new Error("WebGL cumsum shader expects an inner-most axis=" + (t3.rank - 1) + " but got axis=" + e2);
        var o3 = new ni(t3.shape, n2, r2);
        return this.compileAndRun(o3, [t3]);
      }, o2.prototype.equal = function(t3, e2) {
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t3, e2, "\n  return vec4(equal(a, b));\n", "bool");
        var n2 = new Ba("return float(a == b);", t3.shape, e2.shape);
        return this.compileAndRun(n2, [t3, e2], "bool");
      }, o2.prototype.notEqual = function(t3, e2) {
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t3, e2, "\n  return vec4(notEqual(a, b));\n", "bool");
        var n2 = new Ba("return float(a != b);", t3.shape, e2.shape);
        return this.compileAndRun(n2, [t3, e2], "bool");
      }, o2.prototype.less = function(t3, e2) {
        if (this.shouldExecuteOnCPU([t3, e2])) return this.cpuBackend.less(t3, e2);
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t3, e2, "\n  return vec4(lessThan(a, b));\n", "bool");
        var n2 = new Ba("return float(a < b);", t3.shape, e2.shape);
        return this.compileAndRun(n2, [t3, e2], "bool");
      }, o2.prototype.lessEqual = function(t3, e2) {
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t3, e2, "\n  return vec4(lessThanEqual(a, b));\n", "bool");
        var n2 = new Ba("return float(a <= b);", t3.shape, e2.shape);
        return this.compileAndRun(n2, [t3, e2], "bool");
      }, o2.prototype.greater = function(t3, e2) {
        if (this.shouldExecuteOnCPU([t3, e2])) return this.cpuBackend.greater(t3, e2);
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t3, e2, "\n  return vec4(greaterThan(a, b));\n", "bool");
        var n2 = new Ba("return float(a > b);", t3.shape, e2.shape);
        return this.compileAndRun(n2, [t3, e2], "bool");
      }, o2.prototype.greaterEqual = function(t3, e2) {
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t3, e2, "\n  return vec4(greaterThanEqual(a, b));\n", "bool");
        var n2 = new Ba("return float(a >= b);", t3.shape, e2.shape);
        return this.compileAndRun(n2, [t3, e2], "bool");
      }, o2.prototype.logicalNot = function(t3) {
        var e2 = new Cs(t3.shape, "return float(!(x >= 1.0));");
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.logicalAnd = function(t3, e2) {
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t3, e2, "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n", "bool");
        var n2 = new Ba("return float(a >= 1.0 && b >= 1.0);", t3.shape, e2.shape);
        return this.compileAndRun(n2, [t3, e2], "bool");
      }, o2.prototype.logicalOr = function(t3, e2) {
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t3, e2, "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n", "bool");
        var n2 = new Ba("return float(a >= 1.0 || b >= 1.0);", t3.shape, e2.shape);
        return this.compileAndRun(n2, [t3, e2], "bool");
      }, o2.prototype.select = function(t3, e2, n2) {
        var r2 = new cs(t3.rank, e2.shape, e2.rank);
        return this.compileAndRun(r2, [t3, e2, n2], Dt(e2.dtype, n2.dtype));
      }, o2.prototype.where = function(t3) {
        dn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
        var e2 = t3.dataSync();
        return na(t3.shape, e2);
      }, o2.prototype.topk = function(t3, e2, n2) {
        return ea(t3.dataSync(), t3.shape, t3.dtype, e2);
      }, o2.prototype.min = function(t3, e2) {
        Cn("min", e2, t3.rank);
        var n2 = bn(t3.shape, e2), r2 = n2[0], o3 = k(n2[1]), a2 = t3.as2D(-1, o3);
        return this.reduce(a2, "min", a2.dtype).reshape(r2);
      }, o2.prototype.minimum = function(t3, e2) {
        if (this.shouldExecuteOnCPU([t3, e2])) return this.cpuBackend.minimum(t3, e2);
        var n2 = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t3.shape, e2.shape) : new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n", t3.shape, e2.shape);
        return this.compileAndRun(n2, [t3, e2]);
      }, o2.prototype.mod = function(t3, e2) {
        var n2 = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t3.shape, e2.shape) : new Ba("if (b == 0.0) return NAN;\n  return mod(a, b);", t3.shape, e2.shape);
        return this.compileAndRun(n2, [t3, e2]);
      }, o2.prototype.max = function(t3, e2) {
        if (this.shouldExecuteOnCPU([t3])) return this.cpuBackend.max(t3, e2);
        Cn("max", e2, t3.rank);
        var n2 = bn(t3.shape, e2), r2 = n2[0], o3 = k(n2[1]), a2 = t3.as2D(-1, o3);
        return this.reduce(a2, "max", a2.dtype).reshape(r2);
      }, o2.prototype.maximum = function(t3, e2) {
        if (this.shouldExecuteOnCPU([t3, e2])) return this.cpuBackend.maximum(t3, e2);
        var n2 = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t3.shape, e2.shape) : new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n", t3.shape, e2.shape);
        return this.compileAndRun(n2, [t3, e2]);
      }, o2.prototype.all = function(t3, e2) {
        Cn("all", e2, t3.rank);
        var n2 = bn(t3.shape, e2), r2 = n2[0], o3 = k(n2[1]), a2 = t3.as2D(-1, o3);
        return this.reduce(a2, "all", a2.dtype).reshape(r2);
      }, o2.prototype.any = function(t3, e2) {
        Cn("any", e2, t3.rank);
        var n2 = bn(t3.shape, e2), r2 = n2[0], o3 = k(n2[1]), a2 = t3.as2D(-1, o3);
        return this.reduce(a2, "any", a2.dtype).reshape(r2);
      }, o2.prototype.realDivide = function(t3, e2) {
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
          return this.packedBinaryOp(t3, e2, "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n", "float32", true);
        }
        var n2 = new Ba("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;", t3.shape, e2.shape);
        return this.compileAndRun(n2, [t3, e2], "float32");
      }, o2.prototype.floorDiv = function(t3, e2) {
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t3, e2, "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n", "int32");
        var n2 = new Ba("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n", t3.shape, e2.shape);
        return this.compileAndRun(n2, [t3, e2], "int32");
      }, o2.prototype.add = function(t3, e2) {
        if ("complex64" === t3.dtype && "complex64" === e2.dtype) return this.complexSeparableBinaryOp(t3, e2, Fa);
        if (this.shouldExecuteOnCPU([t3, e2])) return this.cpuBackend.add(t3, e2);
        var n2 = Dt(t3.dtype, e2.dtype);
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t3, e2, Fa, n2);
        var r2 = new Ba(Fa, t3.shape, e2.shape);
        return this.compileAndRun(r2, [t3, e2], n2);
      }, o2.prototype.packedUnaryOp = function(t3, e2, n2) {
        var r2 = new Xs(t3.shape, e2);
        return this.compileAndRun(r2, [t3], n2);
      }, o2.prototype.packedBinaryOp = function(t3, e2, n2, r2, o3) {
        void 0 === o3 && (o3 = false);
        var a2 = new La(n2, t3.shape, e2.shape, o3);
        return this.compileAndRun(a2, [t3, e2], r2);
      }, o2.prototype.complexSeparableBinaryOp = function(t3, e2, n2) {
        var r2 = this, o3 = this.texData.get(t3.dataId), a2 = this.texData.get(e2.dataId), i2 = [[o3.complexTensors.real, a2.complexTensors.real], [o3.complexTensors.imag, a2.complexTensors.imag]].map(function(o4) {
          var a3 = o4[0], i3 = o4[1], s3 = r2.makeComplexComponentTensorInfo(t3, a3), u4 = r2.makeComplexComponentTensorInfo(e2, i3), c3 = new Ba(n2, t3.shape, e2.shape);
          return r2.compileAndRun(c3, [s3, u4], Dt(a3.dtype, i3.dtype));
        }), s2 = i2[0], u3 = i2[1], c2 = this.complex(s2, u3);
        return s2.dispose(), u3.dispose(), c2;
      }, o2.prototype.makeComplexComponentTensorInfo = function(t3, e2) {
        return { dataId: e2.dataId, dtype: e2.dtype, shape: t3.shape };
      }, o2.prototype.addN = function(t3) {
        if (1 === t3.length) return t3[0];
        if (t3.length > i().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
          var e2 = Math.floor(t3.length / 2), n2 = this.addN(t3.slice(0, e2)), r2 = this.addN(t3.slice(e2));
          return this.addN([n2, r2]);
        }
        var o3 = t3.map(function(t4) {
          return t4.dtype;
        }).reduce(function(t4, e3) {
          return Dt(t4, e3);
        }), a2 = t3.map(function(t4) {
          return t4.shape;
        }), s2 = i().getBool("WEBGL_PACK") ? new oa(t3[0].shape, a2) : new ra(t3[0].shape, a2);
        return this.compileAndRun(s2, t3, o3);
      }, o2.prototype.subtract = function(t3, e2) {
        if ("complex64" === t3.dtype && "complex64" === e2.dtype) return this.complexSeparableBinaryOp(t3, e2, _a);
        if (this.shouldExecuteOnCPU([t3, e2])) return this.cpuBackend.subtract(t3, e2);
        var n2 = Dt(t3.dtype, e2.dtype);
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t3, e2, _a, t3.dtype);
        var r2 = new Ba(_a, t3.shape, e2.shape);
        return this.compileAndRun(r2, [t3, e2], n2);
      }, o2.prototype.pow = function(t3, e2) {
        var n2 = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t3.shape, e2.shape) : new Ba("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n", t3.shape, e2.shape), r2 = Dt(t3.dtype, e2.dtype);
        return this.compileAndRun(n2, [t3, e2], r2);
      }, o2.prototype.ceil = function(t3) {
        if (this.shouldExecuteOnCPU([t3])) return this.cpuBackend.ceil(t3);
        if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t3, Ns, t3.dtype);
        var e2 = new Cs(t3.shape, Ns);
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.floor = function(t3) {
        if (this.shouldExecuteOnCPU([t3])) return this.cpuBackend.floor(t3);
        if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t3, Fs, t3.dtype);
        var e2 = new Cs(t3.shape, Fs);
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.sign = function(t3) {
        var e2 = new Cs(t3.shape, "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.isNaN = function(t3) {
        var e2 = new Cs(t3.shape, "return float(isnan(x));");
        return this.compileAndRun(e2, [t3], "bool");
      }, o2.prototype.isInf = function(t3) {
        var e2 = new Cs(t3.shape, "return float(isinf(x));");
        return this.compileAndRun(e2, [t3], "bool");
      }, o2.prototype.isFinite = function(t3) {
        var e2 = new Cs(t3.shape, "return float(!isnan(x) && !isinf(x));");
        return this.compileAndRun(e2, [t3], "bool");
      }, o2.prototype.round = function(t3) {
        var e2 = new Cs(t3.shape, "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.exp = function(t3) {
        if (this.shouldExecuteOnCPU([t3])) return this.cpuBackend.exp(t3);
        if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t3, _s, t3.dtype);
        var e2 = new Cs(t3.shape, _s);
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.expm1 = function(t3) {
        if (this.shouldExecuteOnCPU([t3])) return this.cpuBackend.expm1(t3);
        if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t3, Os, t3.dtype);
        var e2 = new Cs(t3.shape, Os);
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.softmax = function(t3, e2) {
        var n2 = O([e2], t3.shape), r2 = this.max(t3, n2), o3 = wn(r2.shape, n2), a2 = this.subtract(t3, r2.reshape(o3)), i2 = this.exp(a2), s2 = this.sum(i2, n2).reshape(o3);
        return this.realDivide(i2, s2);
      }, o2.prototype.log = function(t3) {
        if (this.shouldExecuteOnCPU([t3])) return this.cpuBackend.log(t3);
        if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t3, "\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n", t3.dtype);
        var e2 = new Cs(t3.shape, "if (x < 0.0) return NAN;\n  return log(x);");
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.log1p = function(t3) {
        var e2 = new Cs(t3.shape, "return log(1.0 + x);");
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.sqrt = function(t3) {
        var e2 = new Cs(t3.shape, "return sqrt(x);");
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.rsqrt = function(t3) {
        if (this.shouldExecuteOnCPU([t3])) return this.cpuBackend.rsqrt(t3);
        var e2 = new Cs(t3.shape, "return inversesqrt(x);");
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.reciprocal = function(t3) {
        var e2 = new Cs(t3.shape, "return 1.0 / x;");
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.relu = function(t3) {
        var e2;
        return e2 = i().getBool("WEBGL_PACK") ? new Xs(t3.shape, qs) : new Cs(t3.shape, ks), this.compileAndRun(e2, [t3]);
      }, o2.prototype.relu6 = function(t3) {
        var e2;
        return e2 = i().getBool("WEBGL_PACK") ? new Xs(t3.shape, Ks) : new Cs(t3.shape, Ss), this.compileAndRun(e2, [t3]);
      }, o2.prototype.prelu = function(t3, e2) {
        var n2 = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La(Pa, t3.shape, e2.shape) : new Ba(Ma, t3.shape, e2.shape);
        return this.compileAndRun(n2, [t3, e2]);
      }, o2.prototype.elu = function(t3) {
        if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t3, js, t3.dtype);
        var e2 = new Cs(t3.shape, As);
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.eluDer = function(t3, e2) {
        var n2 = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", t3.shape, e2.shape) : new Ba("return (b >= 1.0) ? a : a * (b + 1.0);", t3.shape, e2.shape);
        return this.compileAndRun(n2, [t3, e2]);
      }, o2.prototype.selu = function(t3) {
        var e2 = new Cs(t3.shape, Ds);
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.int = function(t3) {
        var e2 = new Cs(t3.shape, "return float(int(x));");
        return this.compileAndRun(e2, [t3], "int32");
      }, o2.prototype.clip = function(t3, e2, n2) {
        var r2, o3 = (r2 = i().getBool("WEBGL_PACK_CLIP") ? new Ua(t3.shape) : new Wa(t3.shape)).getCustomSetupFunc(e2, n2);
        return this.compileAndRun(r2, [t3], null, o3);
      }, o2.prototype.abs = function(t3) {
        if (this.shouldExecuteOnCPU([t3])) return this.cpuBackend.abs(t3);
        if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t3, Is, t3.dtype);
        var e2 = new Cs(t3.shape, Is);
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.complexAbs = function(t3) {
        var e2 = this.texData.get(t3.dataId), n2 = new Va(t3.shape), r2 = [this.makeComplexComponentTensorInfo(t3, e2.complexTensors.real), this.makeComplexComponentTensorInfo(t3, e2.complexTensors.imag)];
        return this.compileAndRun(n2, r2);
      }, o2.prototype.sigmoid = function(t3) {
        var e2 = new Cs(t3.shape, "return 1.0 / (1.0 + exp(-1.0 * x));");
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.softplus = function(t3) {
        var e2 = new Cs(t3.shape, "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.sin = function(t3) {
        var e2 = new Cs(t3.shape, Ms);
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.cos = function(t3) {
        var e2 = new Cs(t3.shape, Bs);
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.tan = function(t3) {
        var e2 = new Cs(t3.shape, "return tan(x);");
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.asin = function(t3) {
        var e2 = new Cs(t3.shape, Ps);
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.acos = function(t3) {
        var e2 = new Cs(t3.shape, Ls);
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.atan = function(t3) {
        var e2 = new Cs(t3.shape, Ws);
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.atan2 = function(t3, e2) {
        var n2 = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t3.shape, e2.shape) : new Ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n", t3.shape, e2.shape);
        return this.compileAndRun(n2, [t3, e2]);
      }, o2.prototype.sinh = function(t3) {
        var e2 = new Cs(t3.shape, "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.cosh = function(t3) {
        var e2 = new Cs(t3.shape, "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.tanh = function(t3) {
        var e2 = new Cs(t3.shape, "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.asinh = function(t3) {
        var e2 = new Cs(t3.shape, Us);
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.acosh = function(t3) {
        var e2 = new Cs(t3.shape, Vs);
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.atanh = function(t3) {
        var e2 = new Cs(t3.shape, zs);
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.erf = function(t3) {
        var e2 = new Cs(t3.shape, '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n');
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.step = function(t3, e2) {
        var n2 = new Cs(t3.shape, function(t4) {
          return void 0 === t4 && (t4 = 0), Es + "\n    return x > 0.0 ? 1.0 : float(" + t4 + ");\n  ";
        }(e2));
        return this.compileAndRun(n2, [t3]);
      }, o2.prototype.conv2dByMatMul = function(t3, e2, n2, r2, o3, a2) {
        var s2 = t3.shape, u3 = this.texData.get(t3.dataId), c2 = n2.inChannels, l2 = s2[0] * s2[1] * s2[2], h2 = n2.outChannels, f2 = "channelsLast" === n2.dataFormat, d2 = (1 === l2 || 1 === h2) && c2 > 1e3, p2 = s2[2] % 2 != 0 && !!u3.isPacked;
        if (d2 || !i().getBool("WEBGL_LAZILY_UNPACK") || !i().getBool("WEBGL_PACK_BINARY_OPERATIONS") || !p2) {
          var v = f2 ? s2[0] * s2[1] * s2[2] : s2[0] * s2[2] * s2[3], m = this.reshape(t3, [1, v, n2.inChannels]), g2 = this.reshape(e2, [1, n2.inChannels, n2.outChannels]);
          return this.reshape(this.fusedBatchMatMul({ a: m, b: g2, transposeA: false, transposeB: false, bias: r2, activation: o3, preluActivationWeights: a2 }), n2.outShape);
        }
        var y2 = f2 ? s2[0] * s2[1] * (s2[2] + 1) : s2[0] * s2[2] * (s2[3] + 1), x2 = { dataId: t3.dataId, shape: [1, y2, n2.inChannels], dtype: t3.dtype }, b2 = u3.shape;
        u3.shape = u3.shape.slice(), u3.shape[u3.shape.length - 2]++, C(_e(u3.shape, x2.shape), function() {
          return "packed reshape " + u3.shape + " to " + x2.shape + " isn't free";
        });
        var w2 = this.reshape(e2, [1, n2.inChannels, n2.outChannels]), E2 = this.fusedBatchMatMul({ a: x2, b: w2, transposeA: false, transposeB: false, bias: r2, activation: o3, preluActivationWeights: a2 }), R2 = this.texData.get(E2.dataId);
        return C(R2.isPacked, function() {
          return "batchMatMul result is expected to be packed";
        }), u3.shape = b2, R2.shape = n2.outShape, Lt.makeTensorFromDataId(E2.dataId, n2.outShape, E2.dtype);
      }, o2.prototype.conv2dWithIm2Row = function(t3, e2, n2, r2, o3, a2) {
        var i2 = n2.filterWidth, s2 = n2.filterHeight, u3 = n2.inChannels, c2 = n2.outWidth, l2 = n2.outHeight, h2 = "channelsLast" === n2.dataFormat, f2 = i2 * s2 * u3, d2 = l2 * c2, p2 = [f2, d2], v = t3.squeeze([0]), m = e2.reshape([1, f2, -1]), g2 = new Li(p2, v.shape, n2), y2 = this.compileAndRun(g2, [v]).reshape([1, p2[0], p2[1]]), x2 = null != r2, b2 = null != a2, w2 = o3 ? Qs(o3, true) : null, C2 = new Hi(y2.shape, [1, d2, n2.outChannels], true, false, x2, w2, b2), E2 = [y2, m];
        r2 && E2.push(r2), b2 && E2.push(a2);
        var R2 = this.compileAndRun(C2, E2);
        return h2 ? R2.reshape([1, l2, c2, n2.outChannels]) : R2.reshape([1, n2.outChannels, l2, c2]);
      }, o2.prototype.fusedConv2d = function(t3) {
        var e2 = t3.input, n2 = t3.filter, r2 = t3.convInfo, o3 = t3.bias, a2 = t3.activation, s2 = t3.preluActivationWeights;
        if (1 === r2.filterHeight && 1 === r2.filterWidth && 1 === r2.dilationHeight && 1 === r2.dilationWidth && 1 === r2.strideHeight && 1 === r2.strideWidth && ("SAME" === r2.padInfo.type || "VALID" === r2.padInfo.type)) return this.conv2dByMatMul(e2, n2, r2, o3, a2, s2);
        if (i().getBool("WEBGL_CONV_IM2COL") && 1 === e2.shape[0]) return this.conv2dWithIm2Row(e2, n2, r2, o3, a2, s2);
        var u3 = null != o3, c2 = null != s2, l2 = a2 ? Qs(a2, false) : null, h2 = new Qa(r2, u3, l2, c2), f2 = [e2, n2];
        return o3 && f2.push(o3), s2 && f2.push(s2), this.compileAndRun(h2, f2);
      }, o2.prototype.conv2d = function(t3, e2, n2) {
        if (1 === n2.filterHeight && 1 === n2.filterWidth && 1 === n2.dilationHeight && 1 === n2.dilationWidth && 1 === n2.strideHeight && 1 === n2.strideWidth && ("SAME" === n2.padInfo.type || "VALID" === n2.padInfo.type)) return this.conv2dByMatMul(t3, e2, n2);
        if (i().getBool("WEBGL_CONV_IM2COL") && 1 === t3.shape[0]) return this.conv2dWithIm2Row(t3, e2, n2);
        var r2 = new Qa(n2);
        return this.compileAndRun(r2, [t3, e2]);
      }, o2.prototype.conv2dDerInput = function(t3, e2, n2) {
        var r2 = new Ka(n2);
        return this.compileAndRun(r2, [t3, e2]);
      }, o2.prototype.conv2dDerFilter = function(t3, e2, n2) {
        var r2 = new qa(n2);
        return this.compileAndRun(r2, [t3, e2]);
      }, o2.prototype.fusedDepthwiseConv2D = function(t3) {
        var e2, n2 = t3.input, r2 = t3.filter, o3 = t3.convInfo, a2 = t3.bias, s2 = t3.activation, u3 = t3.preluActivationWeights, c2 = i().getBool("WEBGL_PACK_DEPTHWISECONV") && o3.strideWidth <= 2 && o3.outChannels / o3.inChannels == 1, l2 = s2 ? Qs(s2, c2) : null, h2 = [n2, r2], f2 = null != a2, d2 = null != u3;
        return f2 && h2.push(a2), d2 && h2.push(u3), c2 ? (e2 = new ti(o3, f2, l2, d2), this.compileAndRun(e2, h2)) : (e2 = new Za(o3, f2, l2, d2), this.compileAndRun(e2, h2));
      }, o2.prototype.depthwiseConv2D = function(t3, e2, n2) {
        var r2;
        return i().getBool("WEBGL_PACK_DEPTHWISECONV") && n2.strideWidth <= 2 && n2.outChannels / n2.inChannels == 1 ? (r2 = new ti(n2), this.compileAndRun(r2, [t3, e2])) : (r2 = new Za(n2), this.compileAndRun(r2, [t3, e2]));
      }, o2.prototype.depthwiseConv2DDerInput = function(t3, e2, n2) {
        var r2 = new $a(n2);
        return this.compileAndRun(r2, [t3, e2]);
      }, o2.prototype.depthwiseConv2DDerFilter = function(t3, e2, n2) {
        var r2 = new Ya(n2);
        return this.compileAndRun(r2, [t3, e2]);
      }, o2.prototype.conv3d = function(t3, e2, n2) {
        var r2 = new Ja(n2);
        return this.compileAndRun(r2, [t3, e2]);
      }, o2.prototype.conv3dDerInput = function(t3, e2, n2) {
        var r2 = new Xa(n2);
        return this.compileAndRun(r2, [t3, e2]);
      }, o2.prototype.conv3dDerFilter = function(t3, e2, n2) {
        var r2 = new ja(n2);
        return this.compileAndRun(r2, [t3, e2]);
      }, o2.prototype.maxPool = function(t3, e2) {
        var n2 = new $i(e2, "max", false);
        return this.compileAndRun(n2, [t3]);
      }, o2.prototype.avgPool = function(t3, e2) {
        var n2 = new $i(e2, "avg", false);
        return this.compileAndRun(n2, [t3], "float32");
      }, o2.prototype.maxPoolBackprop = function(t3, e2, n2, r2) {
        var o3 = new $i(r2, "max", true), a2 = this.compileAndRun(o3, [e2]), i2 = new zi(r2), s2 = this.compileAndRun(i2, [t3, a2], e2.dtype);
        return a2.dispose(), s2;
      }, o2.prototype.avgPoolBackprop = function(t3, e2, n2) {
        var r2 = new Ia(n2);
        return this.compileAndRun(r2, [t3], e2.dtype);
      }, o2.prototype.cast = function(t3, e2) {
        return Po(t3, e2, this);
      }, o2.prototype.unstack = function(t3, e2) {
        for (var n2 = t3.shape[e2], r2 = new Array(t3.rank - 1), o3 = 0, a2 = 0; a2 < t3.rank; a2++) a2 !== e2 && (r2[o3++] = t3.shape[a2]);
        var i2 = new Array(t3.rank).fill(0), s2 = t3.shape.slice();
        s2[e2] = 1;
        var u3 = new Array(n2);
        for (a2 = 0; a2 < u3.length; a2++) i2[e2] = a2, u3[a2] = this.slice(t3, i2, s2).reshape(r2);
        return u3;
      }, o2.prototype.avgPool3d = function(t3, e2) {
        var n2 = new Qi(e2, "avg", false);
        return this.compileAndRun(n2, [t3], "float32");
      }, o2.prototype.avgPool3dBackprop = function(t3, e2, n2) {
        var r2 = new ka(n2);
        return this.compileAndRun(r2, [t3], e2.dtype);
      }, o2.prototype.maxPool3d = function(t3, e2) {
        var n2 = new Qi(e2, "max", false);
        return this.compileAndRun(n2, [t3], "float32");
      }, o2.prototype.maxPool3dBackprop = function(t3, e2, n2, r2) {
        var o3 = new Qi(r2, "max", true), a2 = this.compileAndRun(o3, [e2]), i2 = new Gi(r2), s2 = this.compileAndRun(i2, [t3, a2], e2.dtype);
        return a2.dispose(), s2;
      }, o2.prototype.reshape = function(t3, e2) {
        var n2 = this.texData.get(t3.dataId);
        if (n2.isPacked && !_e(t3.shape, e2) && (null === n2.texture || !_e(n2.shape, e2))) {
          var r2 = this.packedReshape(t3, e2);
          return Lt.makeTensorFromDataId(r2.dataId, r2.shape, r2.dtype);
        }
        return Lo(t3, e2);
      }, o2.prototype.resizeBilinear = function(t3, e2, n2, r2) {
        var o3 = i().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new ns(t3.shape, e2, n2, r2) : new es(t3.shape, e2, n2, r2);
        return this.compileAndRun(o3, [t3], "float32");
      }, o2.prototype.resizeBilinearBackprop = function(t3, e2, n2) {
        var r2 = new ts(t3, e2, n2);
        return this.compileAndRun(r2, [t3]);
      }, o2.prototype.resizeNearestNeighbor = function(t3, e2, n2, r2) {
        var o3 = new os(t3.shape, e2, n2, r2);
        return this.compileAndRun(o3, [t3]);
      }, o2.prototype.resizeNearestNeighborBackprop = function(t3, e2, n2) {
        var r2 = new rs(t3, e2, n2);
        return this.compileAndRun(r2, [t3]);
      }, o2.prototype.multinomial = function(t3, e2, n2, r2) {
        var o3 = e2 ? t3 : go(t3), a2 = o3.shape[0], i2 = o3.shape[1], s2 = new qi(a2, i2, n2), u3 = s2.getCustomSetupFunc(r2);
        return this.compileAndRun(s2, [o3], "int32", u3);
      }, o2.prototype.oneHot = function(t3, e2, n2, r2) {
        var o3 = new Ki(t3.size, e2, n2, r2);
        return this.compileAndRun(o3, [t3]);
      }, o2.prototype.diag = function(t3) {
        var e2 = new si(t3.size);
        return this.compileAndRun(e2, [t3]);
      }, o2.prototype.nonMaxSuppression = function(t3, e2, n2, r2, o3) {
        return dn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"), jo(t3.dataSync(), e2.dataSync(), n2, r2, o3);
      }, o2.prototype.cropAndResize = function(t3, e2, n2, r2, o3, a2) {
        var i2 = new ei(t3.shape, e2.shape, r2, o3, a2);
        return this.compileAndRun(i2, [t3, e2, n2], "float32");
      }, o2.prototype.depthToSpace = function(t3, e2, n2) {
        C(e2 > 1, function() {
          return "blockSize should be > 1 for depthToSpace, but was: " + e2;
        });
        var r2 = t3.shape[0], o3 = "NHWC" === n2 ? t3.shape[1] : t3.shape[2], a2 = "NHWC" === n2 ? t3.shape[2] : t3.shape[3], i2 = "NHWC" === n2 ? t3.shape[3] : t3.shape[1], s2 = o3 * e2, u3 = a2 * e2, c2 = i2 / (e2 * e2), l2 = new ii("NHWC" === n2 ? [r2, s2, u3, c2] : [r2, c2, s2, u3], e2, n2);
        return this.compileAndRun(l2, [t3]);
      }, o2.prototype.split = function(t3, e2, n2) {
        return Zo(t3, e2, n2);
      }, o2.prototype.scatterND = function(t3, e2, n2) {
        var r2 = Zr(0, t3, n2), o3 = r2.sliceRank, a2 = r2.numUpdates, i2 = r2.sliceSize, s2 = r2.strides, u3 = r2.outputSize, c2 = [u3 / i2, i2], l2 = t3.reshape([a2, o3]), h2 = e2.reshape([a2, i2]);
        if (0 === u3) return Lo(Fn([]), n2);
        var f2 = On(0), d2 = new ss(a2, o3, l2.rank, h2.rank, s2, c2);
        return this.compileAndRun(d2, [h2, l2, f2]).reshape(n2);
      }, o2.prototype.sparseToDense = function(t3, e2, n2, r2) {
        var o3 = Zr(0, t3, n2), a2 = o3.sliceRank, i2 = o3.numUpdates, s2 = o3.strides, u3 = o3.outputSize, c2 = new ss(i2, a2, t3.rank, e2.rank, s2, [u3, 1], false);
        return this.compileAndRun(c2, [e2, t3, r2]).reshape(n2);
      }, o2.prototype.fft = function(t3) {
        return this.fftImpl(t3, false);
      }, o2.prototype.ifft = function(t3) {
        return this.fftImpl(t3, true);
      }, o2.prototype.fftImpl = function(t3, e2) {
        var n2 = this.texData.get(t3.dataId), r2 = new pi(fi, t3.shape, e2), o3 = new pi(di, t3.shape, e2), a2 = [this.makeComplexComponentTensorInfo(t3, n2.complexTensors.real), this.makeComplexComponentTensorInfo(t3, n2.complexTensors.imag)], i2 = this.compileAndRun(r2, a2), s2 = this.compileAndRun(o3, a2), u3 = this.complex(i2, s2).as2D(t3.shape[0], t3.shape[1]);
        return i2.dispose(), s2.dispose(), u3;
      }, o2.prototype.gatherND = function(t3, e2) {
        var n2 = e2.shape, r2 = n2[n2.length - 1], o3 = jr(t3, e2), a2 = o3[0], i2 = o3[1], s2 = o3[2], u3 = o3[3], c2 = e2.reshape([i2, r2]), l2 = t3.reshape([t3.size / s2, s2]), h2 = new gi(r2, u3, [i2, s2]);
        return this.compileAndRun(h2, [l2, c2]).reshape(a2);
      }, o2.prototype.fill = function(t3, e2, n2) {
        if ("string" === (n2 = n2 || j(e2))) {
          var r2 = P(n2, k(t3));
          return r2.fill(e2), Lt.makeTensor(r2, t3, n2, this);
        }
        var o3 = new vi(t3, e2), a2 = o3.getCustomSetupFunc(e2);
        return this.compileAndRun(o3, [], n2, a2);
      }, o2.prototype.onesLike = function(t3) {
        if ("string" === t3.dtype) throw new Error("onesLike is not supported under string dtype");
        return this.fill(t3.shape, 1, t3.dtype);
      }, o2.prototype.zerosLike = function(t3) {
        return this.fill(t3.shape, "string" === t3.dtype ? "" : 0, t3.dtype);
      }, o2.prototype.linspace = function(t3, e2, n2) {
        return Wo(t3, e2, n2);
      }, o2.prototype.makeTensorInfo = function(t3, e2) {
        var n2 = this.write(null, t3, e2);
        return this.texData.get(n2).usage = null, { dataId: n2, shape: t3, dtype: e2 };
      }, o2.prototype.makeOutput = function(t3, e2) {
        var n2 = this.makeTensorInfo(t3, e2).dataId;
        return Lt.makeTensorFromDataId(n2, t3, e2, this);
      }, o2.prototype.unpackTensor = function(t3) {
        var e2 = new Ys(t3.shape);
        return this.runWebGLProgram(e2, [t3], t3.dtype);
      }, o2.prototype.packTensor = function(t3) {
        var e2 = new ji(t3.shape);
        return this.runWebGLProgram(e2, [t3], t3.dtype, null, true);
      }, o2.prototype.packedReshape = function(t3, e2) {
        var n2 = [Ae(t3.shape)].concat(De(t3.shape)), r2 = { dtype: t3.dtype, shape: n2, dataId: t3.dataId }, o3 = [Ae(e2)].concat(De(e2)), a2 = new Zi(o3, n2), i2 = this.runWebGLProgram(a2, [r2], t3.dtype, null, true);
        return { dataId: i2.dataId, shape: e2, dtype: i2.dtype };
      }, o2.prototype.decode = function(t3) {
        var e2, n2 = this.texData.get(t3), r2 = n2.isPacked, o3 = n2.shape, a2 = n2.dtype, i2 = Te(o3);
        e2 = r2 ? new ai(i2) : new oi(i2);
        return { dtype: a2, shape: o3, dataId: this.runWebGLProgram(e2, [{ shape: i2, dtype: a2, dataId: t3 }], a2, null, true).dataId };
      }, o2.prototype.runWebGLProgram = function(t3, e2, n2, r2, o3) {
        var a2 = this;
        void 0 === o3 && (o3 = false);
        var s2 = this.makeTensorInfo(t3.outputShape, n2), u3 = this.texData.get(s2.dataId);
        if (t3.packedOutput && (u3.isPacked = true), t3.outPackingScheme === Vt.DENSE) {
          var c2 = Yt(t3.outputShape);
          u3.texShape = c2.map(function(t4) {
            return 2 * t4;
          });
        }
        if (null != t3.outTexUsage && (u3.usage = t3.outTexUsage), 0 === k(s2.shape)) return u3.values = B(s2.dtype, 0), s2;
        var l2 = [], h2 = e2.map(function(e3) {
          if ("complex64" === e3.dtype) throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
          var n3 = a2.texData.get(e3.dataId);
          if (null == n3.texture) {
            if (!t3.packedInputs && k(e3.shape) <= i().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return { shape: e3.shape, texData: null, isUniform: true, uniformValues: n3.values };
            t3.packedInputs && (n3.isPacked = true, n3.shape = e3.shape);
          } else if (!!n3.isPacked != !!t3.packedInputs) e3 = n3.isPacked ? a2.unpackTensor(e3) : a2.packTensor(e3), l2.push(e3), n3 = a2.texData.get(e3.dataId);
          else if (n3.isPacked && !_e(n3.shape, e3.shape)) {
            var r3 = e3, o4 = e3.shape;
            e3.shape = n3.shape, e3 = a2.packedReshape(e3, o4), l2.push(e3), n3 = a2.texData.get(e3.dataId), r3.shape = o4;
          }
          return a2.uploadToGPU(e3.dataId), { shape: e3.shape, texData: n3, isUniform: false };
        });
        this.uploadToGPU(s2.dataId);
        var f2, d2 = { shape: s2.shape, texData: u3, isUniform: false }, p2 = function(t4, e3, n3) {
          var r3 = "";
          e3.concat(n3).forEach(function(t5) {
            var e4 = null != t5.texData && null != t5.texData.slice && t5.texData.slice.flatOffset > 0, n4 = t5.isUniform ? "uniform" : t5.texData.texShape;
            r3 += t5.shape + "_" + n4 + "_" + e4;
          });
          var o4 = t4.userCode, a3 = t4.constructor.name;
          return a3 += "_" + r3 + "_" + o4;
        }(t3, h2, d2), v = this.getAndSaveBinary(p2, function() {
          return function(t4, e3, n3, r3) {
            var o4 = e3.userCode, a3 = n3.map(function(t5, n4) {
              var r4 = { logicalShape: t5.shape, texShape: t5.isUniform ? null : t5.texData.texShape, isUniform: t5.isUniform, isPacked: !t5.isUniform && t5.texData.isPacked, flatOffset: null };
              return null != t5.texData && null != t5.texData.slice && t5.texData.slice.flatOffset > 0 && (r4.flatOffset = t5.texData.slice.flatOffset), { name: e3.variableNames[n4], shapeInfo: r4 };
            }), s3 = a3.map(function(t5) {
              return t5.shapeInfo;
            }), u4 = { logicalShape: r3.shape, texShape: r3.texData.texShape, isUniform: false, isPacked: r3.texData.isPacked, flatOffset: null }, c3 = fa(a3, u4, o4, e3.packedInputs), l3 = t4.createProgram(c3), h3 = null, f3 = t4.getUniformLocation(l3, "NAN", false);
            1 === i().getNumber("WEBGL_VERSION") && (h3 = t4.getUniformLocation(l3, "INFINITY", false));
            for (var d3 = {}, p3 = 0; p3 < e3.variableNames.length; p3++) {
              var v2 = e3.variableNames[p3];
              d3[v2] = t4.getUniformLocation(l3, v2, false), d3["offset" + v2] = t4.getUniformLocation(l3, "offset" + v2, false);
            }
            return { program: e3, source: c3, webGLProgram: l3, uniformLocations: d3, inShapeInfos: s3, outShapeInfo: u4, infLoc: h3, nanLoc: f3 };
          }(a2.gpgpu, t3, h2, d2);
        }), m = null != this.activeTimers;
        if (m && (f2 = this.startTimer()), function(t4, e3, n3, r3, o4) {
          Pi(e3.inShapeInfos, n3), Pi([e3.outShapeInfo], [r3]);
          var a3 = r3.texData.texture, s3 = r3.texData.texShape;
          r3.texData.isPacked ? t4.setOutputPackedMatrixTexture(a3, s3[0], s3[1]) : t4.setOutputMatrixTexture(a3, s3[0], s3[1]), t4.setProgram(e3.webGLProgram), 1 === i().getNumber("WEBGL_VERSION") && null !== e3.infLoc && t4.gl.uniform1f(e3.infLoc, 1 / 0), null !== e3.nanLoc && t4.gl.uniform1f(e3.nanLoc, NaN), n3.forEach(function(n4, r4) {
            var o5 = e3.program.variableNames[r4], a4 = e3.uniformLocations[o5], i2 = e3.uniformLocations["offset" + o5];
            if (null != a4) if (n4.isUniform) if (k(n4.shape) < 2) t4.gl.uniform1f(a4, n4.uniformValues[0]);
            else {
              var s4 = n4.uniformValues;
              s4 instanceof Float32Array || (s4 = new Float32Array(s4)), t4.gl.uniform1fv(a4, s4);
            }
            else null != n4.texData.slice && null != i2 && t4.gl.uniform1i(i2, n4.texData.slice.flatOffset), t4.setInputMatrixTexture(n4.texData.texture, a4, r4);
          }), null != o4 && o4(t4, e3.webGLProgram), t4.executeProgram();
        }(this.gpgpu, v, h2, d2, r2), l2.forEach(function(t4) {
          return a2.disposeData(t4.dataId);
        }), m && (f2 = this.endTimer(f2), this.activeTimers.push({ name: t3.constructor.name, query: this.getQueryTime(f2) })), !i().getBool("WEBGL_LAZILY_UNPACK") && u3.isPacked && false === o3) {
          var g2 = this.unpackTensor(s2);
          return this.disposeData(s2.dataId), g2;
        }
        return s2;
      }, o2.prototype.compileAndRun = function(t3, e2, n2, r2, o3) {
        void 0 === o3 && (o3 = false), n2 = n2 || e2[0].dtype;
        var a2 = this.runWebGLProgram(t3, e2, n2, r2, o3);
        return Lt.makeTensorFromDataId(a2.dataId, a2.shape, a2.dtype);
      }, o2.prototype.getAndSaveBinary = function(t3, e2) {
        return t3 in this.binaryCache || (this.binaryCache[t3] = e2()), this.binaryCache[t3];
      }, o2.prototype.getTextureManager = function() {
        return this.textureManager;
      }, o2.prototype.dispose = function() {
        var t3 = this;
        if (!this.disposed) {
          if (!i().getBool("IS_TEST")) Object.keys(this.binaryCache).forEach(function(e2) {
            t3.gpgpu.deleteProgram(t3.binaryCache[e2].webGLProgram), delete t3.binaryCache[e2];
          });
          this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = true;
        }
      }, o2.prototype.floatPrecision = function() {
        var t3 = this;
        return null == this.floatPrecisionValue && (this.floatPrecisionValue = Ze(function() {
          if (!i().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
            var e2 = i().getBool("DEBUG");
            i().set("DEBUG", false);
            var n2 = t3.abs(On(1e-8)).dataSync()[0];
            if (i().set("DEBUG", e2), n2 > 0) return 32;
          }
          return 16;
        })), this.floatPrecisionValue;
      }, o2.prototype.epsilon = function() {
        return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
      }, o2.prototype.uploadToGPU = function(t3) {
        var e2, n2 = this.texData.get(t3), r2 = n2.shape, o3 = n2.dtype, a2 = n2.values, i2 = n2.texture, s2 = n2.usage, u3 = n2.isPacked;
        if (null == i2) {
          var c2, l2 = null != this.activeTimers;
          l2 && (c2 = et());
          var h2 = n2.texShape;
          if (null == h2 && (h2 = Ne(r2, u3), n2.texShape = h2), null != a2) {
            var f2 = Te(r2), d2 = void 0, p2 = h2[1], v = h2[0], m = a2 instanceof Uint8Array;
            u3 ? (p2 = (e2 = $t(h2[0], h2[1]))[0], v = e2[1], d2 = new hi(f2, [v, p2], m)) : d2 = new li(f2, [v, p2], m);
            var g2 = this.makeTensorInfo([v, p2], o3);
            this.texData.get(g2.dataId).usage = m ? zt.PIXELS : zt.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(g2.dataId), p2, v, a2);
            var y2 = this.runWebGLProgram(d2, [g2], o3, null, true), x2 = this.texData.get(y2.dataId);
            n2.texture = x2.texture, n2.texShape = x2.texShape, n2.isPacked = x2.isPacked, n2.usage = x2.usage, this.disposeData(g2.dataId), this.texData.delete(y2.dataId), n2.values = null, l2 && (this.uploadWaitMs += et() - c2);
          } else {
            var b2 = this.acquireTexture(h2, s2, o3, u3);
            n2.texture = b2;
          }
        }
      }, o2.prototype.convertAndCacheOnCPU = function(t3, e2) {
        var n2 = this.texData.get(t3), r2 = n2.dtype;
        return this.releaseGPUData(t3), null != e2 && (n2.values = function(t4, e3) {
          if ("float32" === e3 || "complex64" === e3) return t4;
          if ("int32" === e3 || "bool" === e3) {
            for (var n3 = "int32" === e3 ? new Int32Array(t4.length) : new Uint8Array(t4.length), r3 = 0; r3 < n3.length; ++r3) n3[r3] = Math.round(t4[r3]);
            return n3;
          }
          throw new Error("Unknown dtype " + e3);
        }(e2, r2)), n2.values;
      }, o2.prototype.acquireTexture = function(t3, e2, n2, r2) {
        if (this.numBytesInGPU += this.computeBytes(t3, n2), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
          var o3 = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
          this.warnedAboutMemory = true, console.warn("High memory usage in GPU: " + o3 + " MB, most likely due to a memory leak");
        }
        return this.textureManager.acquireTexture(t3, e2, r2);
      }, o2.prototype.computeBytes = function(t3, e2) {
        return t3[0] * t3[1] * z(e2);
      }, o2;
    }(bo);
    Wt() && Lt.registerBackend("webgl", function() {
      return new Zs();
    }, 2);
    tu = An({ square_: function(t2) {
      var e2 = mn(t2, "x", "square"), n2 = [e2];
      return Lt.runKernelFunc(function(t3, n3) {
        return n3([e2]), t3.square(e2);
      }, { x: e2 }, null, "Square", {}, n2, []);
    } });
    eu = "SquaredDifference";
    nu = An({ squaredDifference_: function(t2, e2) {
      var n2, r2 = mn(t2, "a", "squaredDifference"), o2 = mn(e2, "b", "squaredDifference");
      n2 = Nt(r2, o2), r2 = n2[0], o2 = n2[1], Ro(r2.shape, o2.shape);
      var a2 = { a: r2, b: o2 }, i2 = [r2, o2];
      return Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.squaredDifference(r2, o2);
        return e3([r2, o2]), n3;
      }, a2, function(t3, e3) {
        var n3 = e3[0], r3 = e3[1], o3 = On(2);
        return { a: function() {
          return t3.mul(n3.sub(r3).mul(o3));
        }, b: function() {
          return t3.mul(r3.sub(n3).mul(o3));
        } };
      }, eu, {}, i2, []);
    } });
    ru = An({ abs_: function(t2) {
      var e2 = mn(t2, "x", "abs");
      return "complex64" === e2.dtype ? Lt.runKernelFunc(function(t3) {
        return t3.complexAbs(e2);
      }, { $x: e2 }) : Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.abs(e2);
        return n2([e2]), r2;
      }, { x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { x: function() {
          return t3.mul(n2.toFloat().step(-1));
        } };
      }, "Abs");
    } });
    ou = An({ acos_: function(t2) {
      var e2 = mn(t2, "x", "acos");
      return Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.acos(e2);
        return n2([e2]), r2;
      }, { $x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { $x: function() {
          return t3.divStrict(On(1).sub(n2.toFloat().square()).sqrt()).neg();
        } };
      });
    } });
    au = An({ acosh_: function(t2) {
      var e2 = mn(t2, "x", "acosh");
      return Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.acosh(e2);
        return n2([e2]), r2;
      }, { $x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { $x: function() {
          return t3.divStrict(n2.toFloat().square().sub(1).sqrt());
        } };
      });
    } });
    iu = An({ asin_: function(t2) {
      var e2 = mn(t2, "x", "asin");
      return Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.asin(e2);
        return n2([e2]), r2;
      }, { $x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { $x: function() {
          return t3.divStrict(On(1).sub(n2.toFloat().square()).sqrt());
        } };
      });
    } });
    su = An({ asinh_: function(t2) {
      var e2 = mn(t2, "x", "asinh");
      return Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.asinh(e2);
        return n2([e2]), r2;
      }, { $x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { $x: function() {
          return t3.divStrict(On(1).add(n2.toFloat().square()).sqrt());
        } };
      });
    } });
    uu = An({ atan_: function(t2) {
      var e2 = mn(t2, "x", "atan");
      return Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.atan(e2);
        return n2([e2]), r2;
      }, { $x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { $x: function() {
          return t3.div(n2.toFloat().square().add(1));
        } };
      });
    } });
    cu = An({ atanh_: function(t2) {
      var e2 = mn(t2, "x", "atanh");
      return Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.atanh(e2);
        return n2([e2]), r2;
      }, { $x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { $x: function() {
          return t3.div(On(1).sub(n2.toFloat().square()));
        } };
      });
    } });
    lu = An({ ceil_: function(t2) {
      var e2 = mn(t2, "x", "ceil");
      return Lt.runKernelFunc(function(t3) {
        return t3.ceil(e2);
      }, { $x: e2 }, function(t3) {
        return { $x: function() {
          return Xn(t3);
        } };
      });
    } });
    hu = An({ clipByValue_: function(t2, e2, n2) {
      var r2 = mn(t2, "x", "clipByValue");
      C(e2 <= n2, function() {
        return "Error in clip: min (" + e2 + ") must be less than or equal to max (" + n2 + ").";
      });
      var o2 = [r2], a2 = { min: e2, max: n2 };
      return Lt.runKernelFunc(function(t3, o3) {
        var a3 = t3.clip(r2, e2, n2);
        return o3([r2]), a3;
      }, { x: r2 }, function(t3, r3) {
        var o3 = r3[0];
        return { x: function() {
          return t3.where(o3.greaterEqual(e2).logicalAnd(o3.lessEqual(n2)), Xn(t3));
        } };
      }, "ClipByValue", a2, o2);
    } });
    fu = An({ cos_: function(t2) {
      var e2 = mn(t2, "x", "cos"), n2 = [e2];
      return Lt.runKernelFunc(function(t3, n3) {
        var r2 = t3.cos(e2);
        return n3([e2]), r2;
      }, { x: e2 }, function(t3, e3) {
        var n3 = e3[0];
        return { x: function() {
          return n3.toFloat().sin().neg().mul(t3);
        } };
      }, "Cos", {}, n2);
    } });
    du = An({ cosh_: function(t2) {
      var e2 = mn(t2, "x", "cosh");
      return Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.cosh(e2);
        return n2([e2]), r2;
      }, { $x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { $x: function() {
          return n2.toFloat().sinh().mulStrict(t3);
        } };
      });
    } });
    pu = An({ erf_: function(t2) {
      var e2 = mn(t2, "x", "erf");
      return C("int32" === e2.dtype || "float32" === e2.dtype, function() {
        return "Input dtype must be `int32` or `float32`.";
      }), "int32" === e2.dtype && (e2 = e2.toFloat()), Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.erf(e2);
        return n2([e2]), r2;
      }, { $x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { $x: function() {
          return t3.mul(n2.square().neg().exp().mul(2 / Math.sqrt(Math.PI)));
        } };
      });
    } });
    vu = An({ exp_: function(t2) {
      var e2 = mn(t2, "x", "exp");
      return Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.exp(e2);
        return n2([r2]), r2;
      }, { x: e2 }, function(t3, e3) {
        return { x: function() {
          return t3.mulStrict(e3[0]);
        } };
      }, "Exp", {}, [], [true]);
    } });
    mu = An({ expm1_: function(t2) {
      var e2 = mn(t2, "x", "expm1");
      return Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.expm1(e2);
        return n2([e2]), r2;
      }, { $x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { $x: function() {
          return t3.mul(n2.exp());
        } };
      });
    } });
    gu = An({ floor_: function(t2) {
      var e2 = mn(t2, "x", "floor");
      return Lt.runKernelFunc(function(t3) {
        return t3.floor(e2);
      }, { $x: e2 }, function(t3) {
        return { $x: function() {
          return Xn(t3);
        } };
      });
    } });
    yu = An({ log_: function(t2) {
      var e2 = mn(t2, "x", "log"), n2 = [e2];
      return Lt.runKernelFunc(function(t3, n3) {
        var r2 = t3.log(e2);
        return n3([e2]), r2;
      }, { x: e2 }, function(t3, e3) {
        var n3 = e3[0];
        return { x: function() {
          return t3.div(n3.toFloat());
        } };
      }, "Log", {}, n2);
    } });
    xu = An({ log1p_: function(t2) {
      var e2 = mn(t2, "x", "log1p");
      return Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.log1p(e2);
        return n2([e2]), r2;
      }, { $x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { $x: function() {
          return t3.div(n2.add(1));
        } };
      });
    } });
    bu = An({ logSigmoid_: function(t2) {
      var e2 = mn(t2, "x", "logSigmoid");
      return Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.softplus(e2.neg()).neg();
        return n2([e2]), r2;
      }, { $x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { $x: function() {
          return t3.mul(n2.neg().sigmoid());
        } };
      });
    } });
    wu = An({ neg_: function(t2) {
      var e2 = mn(t2, "x", "neg"), n2 = [e2];
      return Lt.runKernelFunc(function(t3) {
        return t3.neg(e2);
      }, { x: e2 }, function(t3) {
        return { x: function() {
          return t3.neg();
        } };
      }, "Neg", {}, n2);
    } });
    Cu = An({ reciprocal_: function(t2) {
      var e2 = mn(t2, "x", "reciprocal");
      return Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.reciprocal(e2);
        return n2([e2]), r2;
      }, { $x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { $x: function() {
          return t3.div(n2.square().neg());
        } };
      });
    } });
    Eu = An({ round_: function(t2) {
      var e2 = mn(t2, "x", "round");
      return Lt.runKernelFunc(function(t3) {
        return t3.round(e2);
      }, { $x: e2 }, function(t3) {
        return { $x: function() {
          return Xn(t3);
        } };
      });
    } });
    Ru = An({ rsqrt_: function(t2) {
      var e2 = mn(t2, "x", "rsqrt"), n2 = [e2];
      return Lt.runKernelFunc(function(t3, n3) {
        var r2 = t3.rsqrt(e2);
        return n3([e2]), r2;
      }, { x: e2 }, function(t3, e3) {
        var n3 = e3[0];
        return { x: function() {
          return t3.div(n3.pow(1.5).mul(2)).neg();
        } };
      }, "Rsqrt", {}, n2);
    } });
    Iu = An({ sigmoid_: function(t2) {
      var e2 = mn(t2, "x", "sigmoid");
      return Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.sigmoid(e2);
        return n2([r2]), r2;
      }, { x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { x: function() {
          return t3.mul(n2.mul(On(1).sub(n2)));
        } };
      }, "Sigmoid");
    } });
    ku = An({ sign_: function(t2) {
      var e2 = mn(t2, "x", "sign");
      return Lt.runKernelFunc(function(t3) {
        return t3.sign(e2);
      }, { $x: e2 }, function(t3) {
        return { $x: function() {
          return Xn(t3);
        } };
      });
    } });
    Su = An({ isNaN_: function(t2) {
      var e2 = mn(t2, "x", "isNaN");
      return Lt.runKernelFunc(function(t3) {
        return t3.isNaN(e2);
      }, { $x: e2 }, function(t3) {
        return { $x: function() {
          return Xn(t3);
        } };
      });
    } });
    Au = An({ isInf_: function(t2) {
      var e2 = mn(t2, "x", "isInf");
      return Lt.runKernelFunc(function(t3) {
        return t3.isInf(e2);
      }, { $x: e2 }, function(t3) {
        return { $x: function() {
          return Xn(t3);
        } };
      });
    } });
    Du = An({ isFinite_: function(t2) {
      var e2 = mn(t2, "x", "isFinite");
      return Lt.runKernelFunc(function(t3) {
        return t3.isFinite(e2);
      }, { $x: e2 }, function(t3) {
        return { $x: function() {
          return Xn(t3);
        } };
      });
    } });
    Tu = An({ sin_: function(t2) {
      var e2 = mn(t2, "x", "sin"), n2 = [e2];
      return Lt.runKernelFunc(function(t3, n3) {
        var r2 = t3.sin(e2);
        return n3([e2]), r2;
      }, { x: e2 }, function(t3, e3) {
        var n3 = e3[0];
        return { x: function() {
          return n3.toFloat().cos().mul(t3);
        } };
      }, "Sin", {}, n2);
    } });
    Nu = An({ sinh_: function(t2) {
      var e2 = mn(t2, "x", "sinh");
      return Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.sinh(e2);
        return n2([e2]), r2;
      }, { $x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { $x: function() {
          return n2.toFloat().cosh().mulStrict(t3);
        } };
      });
    } });
    Fu = An({ softplus_: function(t2) {
      var e2 = mn(t2, "x", "softplus");
      return Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.softplus(e2);
        return n2([e2]), r2;
      }, { $x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { $x: function() {
          return t3.mul(n2.sigmoid());
        } };
      });
    } });
    _u = An({ sqrt_: function(t2) {
      var e2 = mn(t2, "x", "sqrt");
      return Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.sqrt(e2);
        return n2([e2]), r2;
      }, { $x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { $x: function() {
          return t3.div(n2.toFloat().sqrt().mul(2));
        } };
      });
    } });
    Ou = An({ step_: function(t2, e2) {
      void 0 === e2 && (e2 = 0);
      var n2 = mn(t2, "x", "step");
      return Lt.runKernelFunc(function(t3) {
        return t3.step(n2, e2);
      }, { $x: n2 }, function(t3) {
        return { $x: function() {
          return Xn(t3);
        } };
      });
    } });
    Mu = An({ tan_: function(t2) {
      var e2 = mn(t2, "x", "tan");
      return Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.tan(e2);
        return n2([e2]), r2;
      }, { $x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { $x: function() {
          return t3.div(n2.cos().square());
        } };
      });
    } });
    Bu = An({ tanh_: function(t2) {
      var e2 = mn(t2, "x", "tanh");
      return Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.tanh(e2);
        return n2([r2]), r2;
      }, { x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { x: function() {
          return On(1).sub(n2.square()).mulStrict(t3);
        } };
      }, "Tanh", {}, null, [true]);
    } });
    Gu = An({ batchNormalization2d_: function(t2, e2, n2, r2, o2, a2) {
      return void 0 === r2 && (r2 = 1e-3), zu(), Pu(t2, e2, n2, a2, o2, r2);
    } });
    Hu = An({ batchNormalization3d_: function(t2, e2, n2, r2, o2, a2) {
      return void 0 === r2 && (r2 = 1e-3), zu(), Lu(t2, e2, n2, a2, o2, r2);
    } });
    qu = An({ batchNormalization4d_: function(t2, e2, n2, r2, o2, a2) {
      return void 0 === r2 && (r2 = 1e-3), zu(), Wu(t2, e2, n2, a2, o2, r2);
    } });
    Ku = An({ batchNormalization_: function(t2, e2, n2, r2, o2, a2) {
      return void 0 === r2 && (r2 = 1e-3), zu(), Uu(t2, e2, n2, a2, o2, r2);
    } });
    ju = An({ batchNorm_: Uu });
    Xu = An({ batchNorm2d_: Pu });
    Yu = An({ batchNorm3d_: Lu });
    $u = An({ batchNorm4d_: Wu });
    Qu = An({ logicalAnd_: function(t2, e2) {
      var n2 = mn(t2, "a", "logicalAnd", "bool"), r2 = mn(e2, "b", "logicalAnd", "bool");
      return Ro(n2.shape, r2.shape), Lt.runKernelFunc(function(t3) {
        return t3.logicalAnd(n2, r2);
      }, { a: n2, b: r2 }, null, "LogicalAnd");
    } });
    Ju = An({ logicalNot_: function(t2) {
      var e2 = mn(t2, "x", "logicalNot", "bool");
      return Lt.runKernelFunc(function(t3) {
        return t3.logicalNot(e2);
      }, { $x: e2 });
    } });
    Zu = An({ logicalOr_: function(t2, e2) {
      var n2 = mn(t2, "a", "logicalOr", "bool"), r2 = mn(e2, "b", "logicalOr", "bool");
      return Ro(n2.shape, r2.shape), Lt.runKernelFunc(function(t3) {
        return t3.logicalOr(n2, r2);
      }, { $a: n2, $b: r2 });
    } });
    tc = An({ logicalXor_: function(t2, e2) {
      var n2 = mn(t2, "a", "logicalXor", "bool"), r2 = mn(e2, "b", "logicalXor", "bool");
      return Ro(n2.shape, r2.shape), Zu(t2, e2).logicalAnd(Qu(t2, e2).logicalNot());
    } });
    ec = An({ where_: function(t2, e2, n2) {
      var r2 = mn(e2, "a", "where"), o2 = mn(n2, "b", "where"), a2 = mn(t2, "condition", "where", "bool");
      return E(r2.shape, o2.shape, "Error in where: "), 1 === a2.rank ? C(a2.shape[0] === r2.shape[0], function() {
        return "The first dimension of `a` must match the size of `condition`.";
      }) : E(a2.shape, o2.shape, "Error in where: "), Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.select(a2, r2, o2);
        return e3([a2]), n3;
      }, { $condition: a2, $a: r2, $b: o2 }, function(t3, e3) {
        var n3 = e3[0];
        return { $condition: function() {
          return Xn(n3).toFloat();
        }, $a: function() {
          return t3.mul(n3.cast(t3.dtype));
        }, $b: function() {
          return t3.mul(n3.logicalNot().cast(t3.dtype));
        } };
      });
    } });
    nc = function(t2) {
      return n(this, void 0, void 0, function() {
        var e2, n2, o2;
        return r(this, function(r2) {
          switch (r2.label) {
            case 0:
              return [4, (e2 = mn(t2, "condition", "whereAsync", "bool")).data()];
            case 1:
              return n2 = r2.sent(), o2 = na(e2.shape, n2), t2 !== e2 && e2.dispose(), [2, o2];
          }
        });
      });
    };
    rc = An({ add_: function(t2, e2) {
      var n2, r2 = mn(t2, "a", "add"), o2 = mn(e2, "b", "add");
      n2 = Nt(r2, o2), r2 = n2[0], o2 = n2[1];
      var a2 = Ro(r2.shape, o2.shape);
      return Lt.runKernelFunc(function(t3) {
        return t3.add(r2, o2);
      }, { a: r2, b: o2 }, function(t3) {
        return { a: function() {
          var e3 = t3, n3 = Eo(r2.shape, a2);
          return n3.length > 0 && (e3 = e3.sum(n3)), e3.reshape(r2.shape);
        }, b: function() {
          var e3 = t3, n3 = Eo(o2.shape, a2);
          return n3.length > 0 && (e3 = e3.sum(n3)), e3.reshape(o2.shape);
        } };
      }, "Add");
    } });
    oc = An({ addN_: function(t2) {
      C(Array.isArray(t2), function() {
        return "The argument passed to tf.addN() must be a list of tensors";
      }), C(t2.length >= 1, function() {
        return "Must pass at least one tensor to tf.addN(), but got " + t2.length;
      });
      var e2 = t2.map(function(t3, e3) {
        return mn(t3, "tensors" + e3, "addN");
      }), n2 = e2[0];
      e2.forEach(function(t3) {
        if (t3.dtype !== n2.dtype) throw new Error("All tensors passed to tf.addN() must have the same dtype");
      }), e2.forEach(function(t3) {
        if (!S(t3.shape, n2.shape)) throw new Error("All tensors passed to tf.addN() must have the same shape");
      });
      var r2 = e2;
      return Lt.runKernelFunc(function(t3) {
        return t3.addN(e2);
      }, r2, function(t3) {
        var n3 = {};
        return e2.forEach(function(e3, r3) {
          n3[r3] = function() {
            return t3.clone();
          };
        }), n3;
      }, "AddN");
    } });
    ac = An({ addStrict_: function(t2, e2) {
      var n2 = mn(t2, "a", "addStrict"), r2 = mn(e2, "b", "addStrict");
      return E(n2.shape, r2.shape, "Error in addStrict: "), n2.add(r2);
    } });
    ic = An({ atan2_: function(t2, e2) {
      var n2, r2 = mn(t2, "a", "atan2"), o2 = mn(e2, "b", "atan2");
      n2 = Nt(r2, o2), r2 = n2[0], o2 = n2[1];
      var a2 = Ro(r2.shape, o2.shape);
      return Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.atan2(r2, o2);
        return e3([r2, o2]), n3;
      }, { $a: r2, $b: o2 }, function(t3, e3) {
        var n3 = e3[0], r3 = e3[1];
        return { $a: function() {
          var e4 = rc(n3.square(), r3.square()), o3 = t3.mul(r3.div(e4)), i2 = Eo(n3.shape, a2);
          return i2.length > 0 && (o3 = o3.sum(i2)), o3.reshape(n3.shape);
        }, $b: function() {
          var e4 = rc(n3.square(), r3.square()), o3 = wu(t3.mul(n3.div(e4))), i2 = Eo(r3.shape, a2);
          return i2.length > 0 && (o3 = o3.sum(i2)), o3.reshape(r3.shape);
        } };
      });
    } });
    sc = An({ div_: function(t2, e2) {
      var n2, r2 = mn(t2, "a", "div"), o2 = mn(e2, "b", "div");
      if (n2 = Nt(r2, o2), r2 = n2[0], o2 = n2[1], "int32" === r2.dtype && "int32" === o2.dtype) return lc(r2, o2);
      var a2 = Ro(r2.shape, o2.shape);
      return Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.realDivide(r2, o2);
        return e3([r2, o2]), n3;
      }, { a: r2, b: o2 }, function(t3, e3) {
        var n3 = e3[0], r3 = e3[1];
        return { a: function() {
          var e4 = t3.div(r3.toFloat()), o3 = Eo(n3.shape, a2);
          return o3.length > 0 ? e4.sum(o3).reshape(n3.shape) : e4;
        }, b: function() {
          var e4 = t3.mul(n3.toFloat()), o3 = Eo(r3.shape, a2);
          o3.length > 0 && (e4 = e4.sum(o3).reshape(r3.shape));
          var i2 = r3.square();
          return e4.div(i2.toFloat()).neg();
        } };
      }, "Div");
    } });
    uc = An({ divNoNan_: function(t2, e2) {
      var n2, r2 = mn(t2, "a", "div"), o2 = mn(e2, "b", "div");
      r2 = (n2 = Nt(r2, o2))[0], o2 = n2[1];
      var a2 = sc(r2, o2), i2 = Xn(a2), s2 = o2.equal(i2);
      return ec(s2, i2, a2);
    } });
    cc = An({ divStrict_: function(t2, e2) {
      var n2 = mn(t2, "a", "div"), r2 = mn(e2, "b", "div");
      return E(n2.shape, r2.shape, "Error in divideStrict: "), n2.div(r2);
    } });
    lc = An({ floorDiv_: function(t2, e2) {
      var n2, r2 = mn(t2, "a", "floorDiv"), o2 = mn(e2, "b", "floorDiv");
      n2 = Nt(r2, o2), r2 = n2[0], o2 = n2[1];
      var a2 = Ro(r2.shape, o2.shape);
      return Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.floorDiv(r2, o2);
        return e3([r2, o2]), n3;
      }, { a: r2, b: o2 }, function(t3, e3) {
        var n3 = e3[0], r3 = e3[1];
        return { a: function() {
          var e4 = t3.div(r3.toFloat()), o3 = Eo(n3.shape, a2);
          return o3.length > 0 ? e4.sum(o3).reshape(n3.shape) : e4;
        }, b: function() {
          var e4 = t3.mul(n3.toFloat()), o3 = Eo(r3.shape, a2);
          o3.length > 0 && (e4 = e4.sum(o3).reshape(r3.shape));
          var i2 = r3.square();
          return e4.div(i2.toFloat()).neg();
        } };
      }, "FloorDiv");
    } });
    hc = An({ maximum_: function(t2, e2) {
      var n2, r2 = mn(t2, "a", "maximum"), o2 = mn(e2, "b", "maximum");
      return n2 = Nt(r2, o2), r2 = n2[0], o2 = n2[1], "bool" === r2.dtype && (r2 = r2.toInt(), o2 = o2.toInt()), Ro(r2.shape, o2.shape), Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.maximum(r2, o2);
        return e3([r2, o2]), n3;
      }, { a: r2, b: o2 }, function(t3, e3) {
        var n3 = e3[0], r3 = e3[1];
        return { a: function() {
          return t3.mul(n3.greaterEqual(r3).toFloat());
        }, b: function() {
          return t3.mul(n3.less(r3).toFloat());
        } };
      }, "Maximum");
    } });
    fc = An({ maximumStrict_: function(t2, e2) {
      var n2 = mn(t2, "a", "maximumStrict"), r2 = mn(e2, "b", "maximumStrict");
      return E(n2.shape, r2.shape, "Error in maximumStrict: "), n2.maximum(r2);
    } });
    dc = An({ minimum_: function(t2, e2) {
      var n2, r2 = mn(t2, "a", "minimum"), o2 = mn(e2, "b", "minimum");
      return n2 = Nt(r2, o2), r2 = n2[0], o2 = n2[1], "bool" === r2.dtype && (r2 = r2.toInt(), o2 = o2.toInt()), Ro(r2.shape, o2.shape), Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.minimum(r2, o2);
        return e3([r2, o2]), n3;
      }, { a: r2, b: o2 }, function(t3, e3) {
        var n3 = e3[0], r3 = e3[1];
        return { a: function() {
          return t3.mul(n3.lessEqual(r3).toFloat());
        }, b: function() {
          return t3.mul(n3.greater(r3).toFloat());
        } };
      }, "Minimum");
    } });
    pc = An({ minimumStrict_: function(t2, e2) {
      var n2 = mn(t2, "a", "minimumStrict"), r2 = mn(e2, "b", "minimumStrict");
      return E(n2.shape, r2.shape, "Error in minimumStrict: "), n2.minimum(r2);
    } });
    vc = An({ mod_: function(t2, e2) {
      var n2, r2 = mn(t2, "a", "mod"), o2 = mn(e2, "b", "mod");
      n2 = Nt(r2, o2), r2 = n2[0], o2 = n2[1];
      var a2 = Ro(r2.shape, o2.shape);
      return Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.mod(r2, o2);
        return e3([r2, o2]), n3;
      }, { $a: r2, $b: o2 }, function(t3, e3) {
        var n3 = e3[0], r3 = e3[1];
        return { $a: function() {
          var e4 = Eo(n3.shape, a2);
          return e4.length > 0 ? t3.sum(e4).reshape(n3.shape) : t3;
        }, $b: function() {
          var e4 = t3.mul(n3.div(r3).floor().neg()), o3 = Eo(r3.shape, a2);
          return o3.length > 0 ? e4.sum(o3).reshape(r3.shape) : e4;
        } };
      });
    } });
    mc = An({ modStrict_: function(t2, e2) {
      var n2 = mn(t2, "a", "modStrict"), r2 = mn(e2, "b", "modStrict");
      return E(n2.shape, r2.shape, "Error in modStrict: "), n2.mod(r2);
    } });
    gc = An({ mul_: function(t2, e2) {
      var n2, r2 = mn(t2, "a", "mul"), o2 = mn(e2, "b", "mul");
      n2 = Nt(r2, o2), r2 = n2[0], o2 = n2[1];
      var a2 = Ro(r2.shape, o2.shape);
      return Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.multiply(r2, o2);
        return e3([r2, o2]), n3;
      }, { a: r2, b: o2 }, function(t3, e3) {
        var n3 = e3[0], r3 = e3[1];
        return { a: function() {
          var e4 = t3.mul(r3.toFloat()), o3 = Eo(n3.shape, a2);
          return o3.length > 0 ? e4.sum(o3).reshape(n3.shape) : e4;
        }, b: function() {
          var e4 = t3.mul(n3.toFloat()), o3 = Eo(r3.shape, a2);
          return o3.length > 0 ? e4.sum(o3).reshape(r3.shape) : e4;
        } };
      }, "Mul");
    } });
    yc = An({ mulStrict_: function(t2, e2) {
      var n2 = mn(t2, "a", "mul"), r2 = mn(e2, "b", "mul");
      return E(n2.shape, r2.shape, "Error in multiplyStrict: "), n2.mul(r2);
    } });
    xc = An({ pow_: function(t2, e2) {
      var n2, r2 = mn(t2, "base", "pow"), o2 = mn(e2, "exp", "pow");
      n2 = Nt(r2, o2), r2 = n2[0], o2 = n2[1];
      var a2 = Ro(r2.shape, o2.shape), i2 = [r2, o2];
      return Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.pow(r2, o2);
        return e3([r2, o2, n3]), n3;
      }, { a: r2, b: o2 }, function(t3, e3) {
        var n3 = e3[0], r3 = e3[1], o3 = e3[2];
        return { a: function() {
          var e4 = r3.toFloat(), o4 = t3.mul(e4.mul(n3.pow(e4.sub(On(1))))), i3 = Eo(n3.shape, a2);
          return i3.length > 0 && (o4 = o4.sum(i3)), o4.reshape(n3.shape);
        }, b: function() {
          var e4 = n3.greater(0), i3 = n3.log().where(e4, Xn(n3)), s2 = t3.mul(o3.mul(i3)), u3 = Eo(r3.shape, a2);
          return u3.length > 0 && (s2 = s2.sum(u3)), s2.reshape(r3.shape);
        } };
      }, "Pow", {}, i2, [true]);
    } });
    bc = An({ powStrict_: function(t2, e2) {
      return E(t2.shape, e2.shape, "Error in powStrict: "), t2.pow(e2);
    } });
    wc = An({ squaredDifferenceStrict_: function(t2, e2) {
      var n2 = mn(t2, "a", "squaredDifferenceStrict"), r2 = mn(e2, "b", "squaredDifferenceStrict");
      return E(n2.shape, r2.shape, "Error in squaredDifferenceStrict: "), n2.squaredDifference(r2);
    } });
    Cc = An({ sub_: function(t2, e2) {
      var n2, r2 = mn(t2, "a", "sub"), o2 = mn(e2, "b", "sub");
      n2 = Nt(r2, o2), r2 = n2[0], o2 = n2[1];
      var a2 = Ro(r2.shape, o2.shape);
      return Lt.runKernelFunc(function(t3) {
        return t3.subtract(r2, o2);
      }, { a: r2, b: o2 }, function(t3) {
        return { a: function() {
          var e3 = t3, n3 = Eo(r2.shape, a2);
          return n3.length > 0 && (e3 = e3.sum(n3)), e3.reshape(r2.shape);
        }, b: function() {
          var e3 = t3, n3 = Eo(o2.shape, a2);
          return n3.length > 0 && (e3 = e3.sum(n3)), e3.neg().reshape(o2.shape);
        } };
      }, "Sub");
    } });
    Ec = An({ subStrict_: function(t2, e2) {
      var n2 = mn(t2, "a", "subStrict"), r2 = mn(e2, "b", "subStrict");
      return E(n2.shape, r2.shape, "Error in subStrict: "), n2.sub(r2);
    } });
    Rc = An({ equal_: function(t2, e2) {
      var n2, r2 = mn(t2, "a", "equal"), o2 = mn(e2, "b", "equal");
      return n2 = Nt(r2, o2), r2 = n2[0], o2 = n2[1], Ro(r2.shape, o2.shape), Lt.runKernelFunc(function(t3) {
        return t3.equal(r2, o2);
      }, { $a: r2, $b: o2 });
    } });
    Ic = An({ equalStrict_: function(t2, e2) {
      var n2 = mn(t2, "a", "equalStrict"), r2 = mn(e2, "b", "equalStrict");
      return E(n2.shape, r2.shape, "Error in equalStrict: "), n2.equal(r2);
    } });
    kc = An({ greater_: function(t2, e2) {
      var n2, r2 = mn(t2, "a", "greater"), o2 = mn(e2, "b", "greater");
      return n2 = Nt(r2, o2), r2 = n2[0], o2 = n2[1], Ro(r2.shape, o2.shape), Lt.runKernelFunc(function(t3) {
        return t3.greater(r2, o2);
      }, { a: r2, b: o2 }, null, "Greater");
    } });
    Sc = An({ greaterEqual_: function(t2, e2) {
      var n2, r2 = mn(t2, "a", "greaterEqual"), o2 = mn(e2, "b", "greaterEqual");
      return n2 = Nt(r2, o2), r2 = n2[0], o2 = n2[1], Ro(r2.shape, o2.shape), Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.greaterEqual(r2, o2);
        return e3([r2, o2]), n3;
      }, { a: r2, b: o2 }, function(t3, e3) {
        var n3 = e3[0], r3 = e3[1];
        return { a: function() {
          return Xn(n3);
        }, b: function() {
          return Xn(r3);
        } };
      }, "GreaterEqual");
    } });
    Ac = An({ greaterEqualStrict_: function(t2, e2) {
      var n2 = mn(t2, "a", "greaterEqualStrict"), r2 = mn(e2, "b", "greaterEqualStrict");
      return E(n2.shape, r2.shape, "Error in greaterEqualStrict: "), n2.greaterEqual(r2);
    } });
    Dc = An({ greaterStrict_: function(t2, e2) {
      var n2 = mn(t2, "a", "greaterStrict"), r2 = mn(e2, "b", "greaterStrict");
      return E(n2.shape, r2.shape, "Error in greaterStrict: "), n2.greater(r2);
    } });
    Tc = An({ less_: function(t2, e2) {
      var n2, r2 = mn(t2, "a", "less"), o2 = mn(e2, "b", "less");
      return n2 = Nt(r2, o2), r2 = n2[0], o2 = n2[1], Ro(r2.shape, o2.shape), Lt.runKernelFunc(function(t3) {
        return t3.less(r2, o2);
      }, { a: r2, b: o2 }, null, "Less");
    } });
    Nc = An({ lessEqual_: function(t2, e2) {
      var n2, r2 = mn(t2, "a", "lessEqual"), o2 = mn(e2, "b", "lessEqual");
      return n2 = Nt(r2, o2), r2 = n2[0], o2 = n2[1], Ro(r2.shape, o2.shape), Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.lessEqual(r2, o2);
        return e3([r2, o2]), n3;
      }, { a: r2, b: o2 }, null, "LessEqual");
    } });
    Fc = An({ lessEqualStrict_: function(t2, e2) {
      var n2 = mn(t2, "a", "lessEqualStrict"), r2 = mn(e2, "b", "lessEqualStrict");
      return E(n2.shape, r2.shape, "Error in lessEqualStrict: "), n2.lessEqual(r2);
    } });
    _c = An({ lessStrict_: function(t2, e2) {
      var n2 = mn(t2, "a", "lessStrict"), r2 = mn(e2, "b", "lessStrict");
      return E(n2.shape, r2.shape, "Error in lessStrict: "), n2.less(r2);
    } });
    Oc = An({ notEqual_: function(t2, e2) {
      var n2, r2 = mn(t2, "a", "notEqual"), o2 = mn(e2, "b", "notEqual");
      return n2 = Nt(r2, o2), r2 = n2[0], o2 = n2[1], Ro(r2.shape, o2.shape), Lt.runKernelFunc(function(t3) {
        return t3.notEqual(r2, o2);
      }, { a: r2, b: o2 }, null, "NotEqual");
    } });
    Mc = An({ notEqualStrict_: function(t2, e2) {
      var n2 = mn(t2, "a", "notEqualStrict"), r2 = mn(e2, "b", "notEqualStrict");
      return E(n2.shape, r2.shape, "Error in notEqualStrict: "), n2.notEqual(r2);
    } });
    Lc = An({ gather_: function(t2, e2, n2) {
      void 0 === n2 && (n2 = 0);
      var r2 = mn(t2, "x", "gather"), o2 = mn(e2, "indices", "gather", "int32");
      n2 = O(n2, r2.shape)[0];
      var a2 = function(t3, e3, n3) {
        for (var r3 = t3.shape[n3], o3 = [], a3 = 1, i2 = 1, s2 = 0; s2 < n3; s2++) o3.push(t3.shape[s2]), a3 *= t3.shape[s2];
        for (s2 = 0; s2 < e3.rank; s2++) o3.push(e3.shape[s2]);
        for (s2 = n3 + 1; s2 < t3.rank; s2++) o3.push(t3.shape[s2]), i2 *= t3.shape[s2];
        return { batchSize: a3, sliceSize: i2, dimSize: r3, outputShape: o3 };
      }(r2, o2, n2);
      return Lt.runKernelFunc(function(t3, e3) {
        var a3 = t3.gather(r2, o2.flatten(), n2);
        return e3([o2]), a3;
      }, { x: r2, indices: o2 }, function(t3, e3) {
        var o3 = e3[0];
        return { x: function() {
          var e4 = r2.shape, a3 = o3.size, i2 = e4.slice(0, n2), s2 = i2.length, u3 = e4.slice(n2, e4.length).slice(1), c2 = u3.length, l2 = Bc(0, s2), h2 = Bc(s2 + 1, s2 + 1 + c2), f2 = Pc([i2, [a3], u3]), d2 = t3.reshape(f2), p2 = o3.reshape([a3]), v = Pc([[s2], l2, h2]), m = d2.transpose(v), g2 = Wc(m, p2, r2.shape[n2]), y2 = Rn(v);
          return g2 = g2.transpose(y2);
        }, indices: function() {
          return o3;
        } };
      }, "Gather", { axis: n2 }).reshape(a2.outputShape);
    } });
    Wc = An({ unsortedSegmentSum_: function(t2, e2, n2) {
      var r2 = mn(t2, "x", "unsortedSegmentSum"), o2 = mn(e2, "segmentIds", "unsortedSegmentSum", "int32");
      return C(A(n2), function() {
        return "numSegments must be of dtype int";
      }), Lt.runKernelFunc(function(t3, e3) {
        var a2 = t3.unsortedSegmentSum(r2, o2, n2);
        return e3([o2]), a2;
      }, { $x: r2 }, function(t3, e3) {
        var n3 = e3[0];
        return { $x: function() {
          return function(t4, e4) {
            for (var n4 = hc(e4, Xn(e4)), r3 = Lc(t4, n4), o3 = Sc(e4, On(0, "int32")), a2 = r3.rank - o3.rank, i2 = 0; i2 < a2; ++i2) o3 = wr(o3, i2 + 1);
            o3 = Qu(o3, zn(r3.shape, "bool"));
            var s2 = Xn(r3);
            return ec(o3, r3, s2);
          }(t3, n3);
        } };
      });
    } });
    Uc = function(t2, e2, o2) {
      return n(this, void 0, void 0, function() {
        var n2, a2, i2, s2, u3, c2, l2, h2, f2, d2, p2, v, m;
        return r(this, function(r2) {
          switch (r2.label) {
            case 0:
              for (n2 = mn(t2, "tensor", "boolMask"), a2 = mn(e2, "mask", "boolMask", "bool"), i2 = null == o2 ? 0 : o2, s2 = a2.rank, u3 = n2.shape, C(s2 > 0, function() {
                return "mask cannot be scalar";
              }), E(u3.slice(i2, i2 + s2), a2.shape, "mask's shape must match the first K dimensions of tensor's shape,"), c2 = 1, l2 = i2; l2 < i2 + s2; l2++) c2 *= u3[l2];
              return h2 = u3.slice(0, i2).concat([c2], u3.slice(i2 + s2)), f2 = n2.reshape(h2), d2 = a2.reshape([-1]), [4, nc(d2)];
            case 1:
              return p2 = r2.sent(), v = p2.squeeze([1]), m = Lc(f2, v, i2), t2 !== n2 && n2.dispose(), e2 !== a2 && a2.dispose(), v.dispose(), f2.dispose(), d2.dispose(), p2.dispose(), [2, m];
          }
        });
      });
    };
    Hc = An({ conv1d_: function(t2, e2, n2, r2, o2, a2, i2) {
      void 0 === o2 && (o2 = "NWC"), void 0 === a2 && (a2 = 1);
      var s2 = mn(t2, "x", "conv1d"), u3 = mn(e2, "filter", "conv1d"), c2 = s2, l2 = false;
      2 === s2.rank && (l2 = true, c2 = s2.as3D(1, s2.shape[0], s2.shape[1])), C(3 === c2.rank, function() {
        return "Error in conv1d: input must be rank 3, but got rank " + c2.rank + ".";
      }), C(3 === u3.rank, function() {
        return "Error in conv1d: filter must be rank 3, but got rank " + u3.rank + ".";
      }), null != i2 && C(A(r2), function() {
        return "Error in conv1d: pad must be an integer when using, dimRoundingMode " + i2 + " but got pad " + r2 + ".";
      }), C(c2.shape[2] === u3.shape[1], function() {
        return "Error in conv1d: depth of input (" + c2.shape[2] + ") must match input depth for filter " + u3.shape[1] + ".";
      }), C(Mo(n2, a2), function() {
        return "Error in conv1D: Either stride or dilation must be 1. Got stride " + n2 + " and dilation '" + a2 + "'";
      }), C("NWC" === o2, function() {
        return "Error in conv1d: got dataFormat of " + o2 + " but only NWC is currently supported.";
      });
      var h2 = u3.as4D(1, u3.shape[0], u3.shape[1], u3.shape[2]), f2 = c2.as4D(c2.shape[0], 1, c2.shape[1], c2.shape[2]), d2 = qc(f2, h2, [1, n2], r2, "NHWC", [1, a2], i2);
      return l2 ? d2.as2D(d2.shape[2], d2.shape[3]) : d2.as3D(d2.shape[0], d2.shape[2], d2.shape[3]);
    } });
    qc = An({ conv2d_: function(t2, e2, n2, r2, o2, a2, i2) {
      void 0 === o2 && (o2 = "NHWC"), void 0 === a2 && (a2 = [1, 1]);
      var s2 = mn(t2, "x", "conv2d"), u3 = mn(e2, "filter", "conv2d"), c2 = s2, l2 = false;
      3 === s2.rank && (l2 = true, c2 = s2.as4D(1, s2.shape[0], s2.shape[1], s2.shape[2])), C(4 === c2.rank, function() {
        return "Error in conv2d: input must be rank 4, but got rank " + c2.rank + ".";
      }), C(4 === u3.rank, function() {
        return "Error in conv2d: filter must be rank 4, but got rank " + u3.rank + ".";
      }), null != i2 && C(A(r2), function() {
        return "Error in conv2d: pad must be an integer when using, dimRoundingMode " + i2 + " but got pad " + r2 + ".";
      });
      var h2 = "NHWC" === o2 ? c2.shape[3] : c2.shape[1];
      C(h2 === u3.shape[2], function() {
        return "Error in conv2d: depth of input (" + h2 + ") must match input depth for filter " + u3.shape[2] + ".";
      }), C(Mo(n2, a2), function() {
        return "Error in conv2D: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + a2 + "'";
      });
      var f2 = Bo(o2), d2 = So(c2.shape, u3.shape, n2, a2, r2, i2, false, f2), p2 = [u3, c2], v = Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.conv2d(c2, u3, d2);
        return e3([u3, c2]), n3;
      }, { x: c2, filter: u3 }, function(t3, e3) {
        var i3 = e3, s3 = i3[0], u4 = i3[1];
        return C(Oo(a2), function() {
          return "Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + a2 + "'";
        }), { x: function() {
          return Xc(u4.shape, t3, s3, n2, r2, o2);
        }, filter: function() {
          return jc(u4, t3, s3.shape, n2, r2, o2);
        } };
      }, "Conv2D", d2, p2);
      return l2 ? v.as3D(v.shape[1], v.shape[2], v.shape[3]) : v;
    } });
    Kc = An({ conv3d_: function(t2, e2, n2, r2, o2, a2) {
      void 0 === o2 && (o2 = "NDHWC"), void 0 === a2 && (a2 = [1, 1, 1]);
      var i2 = mn(t2, "x", "conv3d"), s2 = mn(e2, "filter", "conv3d"), u3 = i2, c2 = false;
      4 === i2.rank && (c2 = true, u3 = i2.as5D(1, i2.shape[0], i2.shape[1], i2.shape[2], i2.shape[3])), C(5 === u3.rank, function() {
        return "Error in conv3d: input must be rank 5, but got rank " + u3.rank + ".";
      }), C(5 === s2.rank, function() {
        return "Error in conv3d: filter must be rank 5, but got rank " + s2.rank + ".";
      }), C(u3.shape[4] === s2.shape[3], function() {
        return "Error in conv3d: depth of input (" + u3.shape[4] + ") must match input depth for filter " + s2.shape[3] + ".";
      }), C(function(t3, e3) {
        return zc(t3) || zc(e3);
      }(n2, a2), function() {
        return "Error in conv3D: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + a2 + "'";
      }), C("NDHWC" === o2, function() {
        return "Error in conv3d: got dataFormat of " + o2 + " but only NDHWC is currently supported.";
      });
      var l2 = Ao(u3.shape, s2.shape, n2, a2, r2), h2 = Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.conv3d(u3, s2, l2);
        return e3([u3, s2]), n3;
      }, { x: u3, $filter: s2 }, function(t3, e3) {
        C(zc(a2), function() {
          return "Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + a2 + "'";
        });
        var o3 = e3[0], i3 = e3[1];
        return { x: function() {
          return Gc(o3.shape, t3, i3, n2, r2);
        }, $filter: function() {
          return function(t4, e4, n3, r3, o4) {
            var a3 = t4;
            4 === t4.rank && (a3 = t4.as5D(1, t4.shape[0], t4.shape[1], t4.shape[2], t4.shape[3]));
            var i4 = e4;
            4 === i4.rank && (i4 = e4.as5D(1, e4.shape[0], e4.shape[1], e4.shape[2], e4.shape[3]));
            C(5 === a3.rank, function() {
              return "Error in conv3dDerFilter: input must be rank 5, but got shape " + a3.shape + ".";
            }), C(5 === i4.rank, function() {
              return "Error in conv3dDerFilter: dy must be rank 5, but got shape " + i4.shape + ".";
            }), C(5 === n3.length, function() {
              return "Error in conv3dDerFilter: filterShape must be length 5, but got " + n3 + ".";
            }), C(a3.shape[4] === n3[3], function() {
              return "Error in conv3dDerFilter: depth of input " + a3.shape[4] + ") must match input depth in filter (" + n3[3] + ".";
            }), C(i4.shape[4] === n3[4], function() {
              return "Error in conv3dDerFilter: depth of dy (" + i4.shape[4] + ") must match output depth for filter (" + n3[4] + ").";
            });
            var s3 = Ao(a3.shape, n3, r3, 1, o4);
            return Lt.runKernelFunc(function(t5) {
              return t5.conv3dDerFilter(a3, i4, s3);
            }, { x5D: a3, dy5D: i4 });
          }(o3, t3, i3.shape, n2, r2);
        } };
      });
      return c2 ? h2.as4D(h2.shape[1], h2.shape[2], h2.shape[3], h2.shape[4]) : h2;
    } });
    jc = An({ conv2dDerFilter_: function(t2, e2, n2, r2, o2, a2, i2) {
      void 0 === a2 && (a2 = "NHWC");
      var s2 = t2;
      3 === t2.rank && (s2 = t2.as4D(1, t2.shape[0], t2.shape[1], t2.shape[2]));
      var u3 = e2;
      3 === u3.rank && (u3 = e2.as4D(1, e2.shape[0], e2.shape[1], e2.shape[2])), C(4 === s2.rank, function() {
        return "Error in conv2dDerFilter: input must be rank 4, but got shape " + s2.shape + ".";
      }), C(4 === u3.rank, function() {
        return "Error in conv2dDerFilter: dy must be rank 4, but got shape " + u3.shape + ".";
      }), C(4 === n2.length, function() {
        return "Error in conv2dDerFilter: filterShape must be length 4, but got " + n2 + ".";
      });
      var c2 = "NHWC" === a2 ? s2.shape[3] : s2.shape[1], l2 = "NHWC" === a2 ? u3.shape[3] : u3.shape[1];
      C(c2 === n2[2], function() {
        return "Error in conv2dDerFilter: depth of input " + c2 + ") must match input depth in filter (" + n2[2] + ".";
      }), C(l2 === n2[3], function() {
        return "Error in conv2dDerFilter: depth of dy (" + l2 + ") must match output depth for filter (" + n2[3] + ").";
      }), null != i2 && C(A(o2), function() {
        return "Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode " + i2 + " but got pad " + o2 + ".";
      });
      var h2 = Bo(a2), f2 = So(s2.shape, n2, r2, 1, o2, i2, false, h2);
      return Lt.runKernelFunc(function(t3) {
        return t3.conv2dDerFilter(s2, u3, f2);
      }, { x4D: s2, dy4D: u3 });
    } });
    Xc = An({ conv2dDerInput_: Vc });
    Yc = An({ depthwiseConv2d_: function(t2, e2, n2, r2, o2, a2, i2) {
      void 0 === o2 && (o2 = "NHWC"), void 0 === a2 && (a2 = [1, 1]);
      var s2 = mn(t2, "x", "depthwiseConv2d"), u3 = mn(e2, "filter", "depthwiseConv2d"), c2 = s2, l2 = false;
      3 === s2.rank && (l2 = true, c2 = s2.as4D(1, s2.shape[0], s2.shape[1], s2.shape[2])), C(4 === c2.rank, function() {
        return "Error in depthwiseConv2d: input must be rank 4, but got rank " + c2.rank + ".";
      }), C(4 === u3.rank, function() {
        return "Error in depthwiseConv2d: filter must be rank 4, but got rank " + u3.rank + ".";
      }), C(c2.shape[3] === u3.shape[2], function() {
        return "Error in depthwiseConv2d: number of input channels (" + c2.shape[3] + ") must match the inChannels dimension in filter " + u3.shape[2] + ".";
      }), null == a2 && (a2 = [1, 1]), C(Mo(n2, a2), function() {
        return "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + a2 + "'";
      }), null != i2 && C(A(r2), function() {
        return "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode " + i2 + " but got pad " + r2 + ".";
      });
      var h2 = So(c2.shape, u3.shape, n2, a2, r2, i2, true), f2 = [c2, u3], d2 = Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.depthwiseConv2D(c2, u3, h2);
        return e3([c2, u3]), n3;
      }, { x: c2, filter: u3 }, function(t3, e3) {
        C(Oo(a2), function() {
          return "Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + a2 + "'";
        });
        var n3 = e3[0], r3 = e3[1];
        return { x: function() {
          return $c(n3.shape, t3, r3, h2);
        }, filter: function() {
          return Qc(n3, t3, r3.shape, h2);
        } };
      }, "DepthwiseConv2dNative", h2, f2);
      return l2 ? d2.as3D(d2.shape[1], d2.shape[2], d2.shape[3]) : d2;
    } });
    $c = An({ depthwiseConv2dDerInput_: function(t2, e2, n2, r2) {
      var o2 = e2, a2 = false;
      3 === e2.rank && (a2 = true, o2 = e2.as4D(1, e2.shape[0], e2.shape[1], e2.shape[2]));
      var i2 = Lt.runKernelFunc(function(t3) {
        return t3.depthwiseConv2DDerInput(o2, n2, r2);
      }, { dy4D: o2 });
      return a2 ? i2.as3D(i2.shape[1], i2.shape[2], i2.shape[3]) : i2;
    } });
    Qc = An({ depthwiseConv2dDerFilter_: function(t2, e2, n2, r2) {
      var o2 = t2;
      3 === t2.rank && (o2 = t2.as4D(1, t2.shape[0], t2.shape[1], t2.shape[2]));
      var a2 = e2;
      return 3 === a2.rank && (a2 = e2.as4D(1, e2.shape[0], e2.shape[1], e2.shape[2])), Lt.runKernelFunc(function(t3) {
        return t3.depthwiseConv2DDerFilter(o2, a2, r2);
      }, { x4D: o2, dy4D: a2 });
    } });
    Jc = An({ separableConv2d_: function(t2, e2, n2, r2, o2, a2, i2) {
      void 0 === a2 && (a2 = [1, 1]), void 0 === i2 && (i2 = "NHWC");
      var s2 = mn(t2, "x", "separableConv2d"), u3 = mn(e2, "depthwiseFilter", "separableConv2d"), c2 = mn(n2, "pointwiseFilter", "separableConv2d"), l2 = s2, h2 = false;
      if (3 === s2.rank && (h2 = true, l2 = s2.as4D(1, s2.shape[0], s2.shape[1], s2.shape[2])), "NCHW" === i2) throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
      C(4 === l2.rank, function() {
        return "Error in separableConv2d: input must be rank 4, but got rank " + l2.rank + ".";
      }), C(4 === u3.rank, function() {
        return "Error in separableConv2d: depthwise filter must be rank 4, but got rank " + u3.rank + ".";
      }), C(4 === c2.rank, function() {
        return "Error in separableConv2d: pointwise filter must be rank 4, but got rank " + u3.rank + ".";
      }), C(1 === c2.shape[0], function() {
        return "Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got " + c2.shape[0] + ".";
      }), C(1 === c2.shape[1], function() {
        return "Error in separableConv2d: the second dimension of pointwise filter must be 1, but got " + c2.shape[1] + ".";
      });
      var f2 = u3.shape[2], d2 = u3.shape[3];
      C(c2.shape[2] === f2 * d2, function() {
        return "Error in separableConv2d: the third dimension of pointwise filter must be " + f2 * d2 + ", but got " + c2.shape[2] + ".";
      });
      var p2 = Yc(l2, u3, r2, o2, i2, a2), v = qc(p2, c2, 1, "valid", i2);
      return h2 ? v.as3D(v.shape[1], v.shape[2], v.shape[3]) : v;
    } });
    Zc = An({ conv2dTranspose_: function(t2, e2, n2, r2, o2, a2) {
      return Vc(n2, mn(t2, "x", "conv2dTranspose"), mn(e2, "filter", "conv2dTranspose"), r2, o2, "NHWC", a2);
    } });
    tl = An({ conv3dTranspose_: function(t2, e2, n2, r2, o2) {
      return Gc(n2, mn(t2, "x", "conv3dTranspose"), mn(e2, "filter", "conv3dTranspose"), r2, o2);
    } });
    el = An({ matMul_: function(t2, e2, n2, r2) {
      var o2;
      void 0 === n2 && (n2 = false), void 0 === r2 && (r2 = false);
      var a2 = mn(t2, "a", "matMul"), i2 = mn(e2, "b", "matMul");
      o2 = Nt(a2, i2), a2 = o2[0], i2 = o2[1];
      var s2 = n2 ? a2.shape[a2.rank - 2] : a2.shape[a2.rank - 1], u3 = r2 ? i2.shape[i2.rank - 1] : i2.shape[i2.rank - 2], c2 = n2 ? a2.shape[a2.rank - 1] : a2.shape[a2.rank - 2], l2 = r2 ? i2.shape[i2.rank - 2] : i2.shape[i2.rank - 1], h2 = a2.shape.slice(0, -2), f2 = i2.shape.slice(0, -2), d2 = k(h2), p2 = k(f2);
      C(a2.rank >= 2 && i2.rank >= 2 && a2.rank === i2.rank, function() {
        return "Error in matMul: inputs must have the same rank of at least 2, got ranks " + a2.rank + " and " + i2.rank + ".";
      }), C(S(h2, f2), function() {
        return "Error in matMul: outer dimensions (" + h2 + ") and (" + f2 + ") of Tensors with shapes " + a2.shape + " and " + i2.shape + " must match.";
      }), C(s2 === u3, function() {
        return "Error in matMul: inner shapes (" + s2 + ") and (" + u3 + ") of Tensors with shapes " + a2.shape + " and " + i2.shape + " and transposeA=" + n2 + " and transposeB=" + r2 + " must match.";
      });
      var v = a2.shape.slice(0, -2).concat([c2, l2]), m = n2 ? a2.as3D(d2, s2, c2) : a2.as3D(d2, c2, s2), g2 = r2 ? i2.as3D(p2, l2, u3) : i2.as3D(p2, u3, l2), y2 = { transposeA: n2, transposeB: r2 };
      return Lt.runKernelFunc(function(t3, e3) {
        var o3 = t3.batchMatMul(m, g2, n2, r2);
        return e3([m, g2]), o3;
      }, { a: m, b: g2 }, function(t3, e3) {
        var o3 = e3, a3 = o3[0], i3 = o3[1];
        return n2 || r2 ? !n2 && r2 ? { a: function() {
          return t3.matMul(i3, false, false);
        }, b: function() {
          return t3.matMul(a3, true, false);
        } } : n2 && !r2 ? { a: function() {
          return i3.matMul(t3, false, true);
        }, b: function() {
          return a3.matMul(t3, false, false);
        } } : { a: function() {
          return i3.matMul(t3, true, true);
        }, b: function() {
          return t3.matMul(a3, true, true);
        } } : { a: function() {
          return t3.matMul(i3, false, true);
        }, b: function() {
          return a3.matMul(t3, true, false);
        } };
      }, "BatchMatMul", y2).reshape(v);
    } });
    nl = An({ dot_: function(t2, e2) {
      var n2 = mn(t2, "t1", "dot"), r2 = mn(e2, "t2", "dot");
      C(!(1 !== n2.rank && 2 !== n2.rank || 1 !== r2.rank && 2 !== r2.rank), function() {
        return "Error in dot: inputs must all be rank 1 or 2, but got ranks " + n2.rank + " and " + r2.rank + ".";
      });
      var o2 = 1 === n2.rank ? n2.size : n2.shape[1], a2 = 1 === r2.rank ? r2.size : r2.shape[0];
      return C(o2 === a2, function() {
        return "Error in dot: inner dimensions of inputs must match, but got " + o2 + " and " + a2 + ".";
      }), 1 === n2.rank && 1 === r2.rank ? n2.as2D(1, -1).matMul(r2.as2D(-1, 1)).asScalar() : 1 === n2.rank && 2 === r2.rank ? n2.as2D(1, -1).matMul(r2.as2D(r2.shape[0], r2.shape[1])).as1D() : 2 === n2.rank && 1 === r2.rank ? n2.matMul(r2.as2D(-1, 1)).as1D() : n2.matMul(r2.as2D(r2.shape[0], r2.shape[1]));
    } });
    rl = An({ outerProduct_: function(t2, e2) {
      var n2 = mn(t2, "v1", "outerProduct"), r2 = mn(e2, "v2", "outerProduct");
      return C(1 === n2.rank && 1 === r2.rank, function() {
        return "Error in outerProduct: inputs must be rank 1, but got ranks " + n2.rank + " and " + r2.rank + ".";
      }), n2.as2D(-1, 1).matMul(r2.as2D(1, -1));
    } });
    ol = An({ reverse_: function(t2, e2) {
      var n2 = mn(t2, "x", "reverse");
      if (0 === n2.rank) return n2.clone();
      var r2 = O(e2, n2.shape);
      return Lt.runKernelFunc(function(t3) {
        return t3.reverse(n2, r2);
      }, { $x: n2 }, function(t3) {
        return { $x: function() {
          return t3.reverse(r2);
        } };
      }).reshapeAs(n2);
    } });
    al = An({ reverse1d_: function(t2) {
      var e2 = mn(t2, "x", "reverse");
      return C(1 === e2.rank, function() {
        return "Error in reverse1D: x must be rank 1 but got rank " + e2.rank + ".";
      }), ol(e2, 0);
    } });
    il = An({ reverse2d_: function(t2, e2) {
      var n2 = mn(t2, "x", "reverse");
      return C(2 === n2.rank, function() {
        return "Error in reverse2D: x must be rank 2 but got rank " + n2.rank + ".";
      }), ol(n2, e2);
    } });
    sl = An({ reverse3d_: function(t2, e2) {
      var n2 = mn(t2, "x", "reverse");
      return C(3 === n2.rank, function() {
        return "Error in reverse3D: x must be rank 3 but got rank " + n2.rank + ".";
      }), ol(n2, e2);
    } });
    ul = An({ reverse4d_: function(t2, e2) {
      var n2 = mn(t2, "x", "reverse");
      return C(4 === n2.rank, function() {
        return "Error in reverse4D: x must be rank 4 but got rank " + n2.rank + ".";
      }), ol(n2, e2);
    } });
    hl = An({ maxPool_: function(t2, e2, n2, r2, o2) {
      return cl(t2, e2, n2, 1, r2, o2);
    } });
    fl = An({ avgPool_: function(t2, e2, n2, r2, o2) {
      return ll(t2, e2, n2, 1, r2, o2);
    } });
    dl = An({ pool_: function(t2, e2, n2, r2, o2, a2) {
      null == o2 && (o2 = [1, 1]), null == a2 && (a2 = 1), 0 === r2 && (r2 = "valid");
      var i2 = mn(t2, "x", "maxPool"), s2 = i2, u3 = false;
      3 === i2.rank && (u3 = true, s2 = i2.as4D(1, i2.shape[0], i2.shape[1], i2.shape[2])), C(Mo(a2, o2), function() {
        return "Error in pool: Either strides or dilations must be 1. Got strides " + a2 + " and dilations '" + o2 + "'";
      });
      var c2, l2 = Io(s2.shape, e2, a2, o2, r2), h2 = [l2.dilationHeight, l2.dilationWidth];
      c2 = "same" === r2 ? function(t3, e3) {
        var n3 = t3.map(function(t4, n4) {
          return t4 + (t4 - 1) * (e3[n4] - 1);
        }).map(function(t4) {
          return t4 - 1;
        }), r3 = n3.map(function(t4) {
          return Math.floor(t4 / 2);
        }), o3 = n3.map(function(t4, e4) {
          return t4 - r3[e4];
        });
        return n3.map(function(t4, e4) {
          return [r3[e4], o3[e4]];
        });
      }([l2.filterHeight, l2.filterWidth], h2) : [[0, 0], [0, 0]];
      var f2 = 1 === h2[0] && 1 === h2[1], d2 = function(t3, e3, n3) {
        var r3 = n3.map(function(t4) {
          return t4[0];
        }), o3 = n3.map(function(t4) {
          return t4[1];
        }), a3 = t3.concat(r3, o3), i3 = e3.map(function(t4, e4) {
          return (t4 - a3[e4] % t4) % t4;
        }), s3 = o3.map(function(t4, e4) {
          return t4 + i3[e4];
        }), u4 = e3.map(function(t4, e4) {
          return [r3[e4], s3[e4]];
        }), c3 = e3.map(function(t4, e4) {
          return [0, i3[e4]];
        });
        return [u4, c3];
      }([l2.inHeight, l2.inWidth], h2, c2), p2 = d2[0], v = d2[1], m = f2 ? r2 : "valid", g2 = f2 ? s2 : Mr(s2, h2, p2), y2 = ("avg" === n2 ? function() {
        return ll(g2, e2, a2, 1, m);
      } : function() {
        return cl(g2, e2, a2, 1, m);
      })(), x2 = f2 ? y2 : vr(y2, h2, v);
      return u3 ? x2.as3D(x2.shape[1], x2.shape[2], x2.shape[3]) : x2;
    } });
    pl = An({ maxPool3d_: function(t2, e2, n2, r2, o2, a2, i2) {
      void 0 === a2 && (a2 = "NDHWC");
      var s2 = mn(t2, "x", "maxPool3d"), u3 = s2, c2 = false;
      4 === s2.rank && (c2 = true, u3 = s2.as5D(1, s2.shape[0], s2.shape[1], s2.shape[2], s2.shape[3])), null == i2 && (i2 = [1, 1, 1]), C(5 === u3.rank, function() {
        return "Error in maxPool3d: x must be rank 5 but got rank " + u3.rank + ".";
      }), C("NDHWC" === a2, function() {
        return "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of " + a2;
      }), C(Mo(n2, i2), function() {
        return "Error in maxPool3d: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + i2 + "'";
      }), null != o2 && C(A(r2), function() {
        return "Error in maxPool3d: pad must be an integer when using, dimRoundingMode " + o2 + " but got pad " + r2 + ".";
      });
      var l2 = ko(u3.shape, e2, n2, i2, r2, o2, a2), h2 = Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.maxPool3d(u3, l2);
        return e3([u3, n3]), n3;
      }, { x: u3 }, function(t3, a3) {
        var s3 = a3[0], u4 = a3[1];
        return { x: function() {
          return function(t4, e3, n3, r3, o3, a4, i3, s4) {
            var u5 = mn(t4, "dy", "maxPool3dBackprop"), c3 = mn(e3, "input", "maxPool3dBackprop"), l3 = mn(n3, "output", "maxPool3dBackprop"), h3 = u5, f2 = c3, d2 = l3, p2 = false;
            4 === c3.rank && (p2 = true, h3 = u5.as5D(1, u5.shape[0], u5.shape[1], u5.shape[2], u5.shape[3]), f2 = c3.as5D(1, c3.shape[0], c3.shape[1], c3.shape[2], c3.shape[3]), d2 = l3.as5D(1, l3.shape[0], l3.shape[1], l3.shape[2], l3.shape[3]));
            C(5 === h3.rank, function() {
              return "Error in maxPool3dBackprop: dy must be rank 5 but got rank " + h3.rank + ".";
            }), C(5 === f2.rank, function() {
              return "Error in maxPool3dBackprop: input must be rank 5 but got rank " + f2.rank + ".";
            }), C(5 === d2.rank, function() {
              return "Error in maxPool3dBackprop: output must be rank 5 but got rank " + d2.rank + ".";
            }), null == a4 && (a4 = [1, 1, 1]);
            C(Mo(o3, a4), function() {
              return "Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides " + o3 + " and dilations '" + a4 + "'";
            }), null != s4 && C(A(i3), function() {
              return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + s4 + " but got pad " + i3 + ".";
            });
            var v = ko(f2.shape, r3, o3, a4, i3, s4), m = Lt.runKernelFunc(function(t5) {
              return t5.maxPool3dBackprop(h3, f2, d2, v);
            }, { dy5D: h3, input5D: f2 });
            if (p2) return m.as4D(m.shape[1], m.shape[2], m.shape[3], m.shape[4]);
            return m;
          }(t3, s3, u4, e2, n2, i2, r2, o2);
        } };
      });
      return c2 ? h2.as4D(h2.shape[1], h2.shape[2], h2.shape[3], h2.shape[4]) : h2;
    } });
    vl = An({ avgPool3d_: function(t2, e2, n2, r2, o2, a2, i2) {
      void 0 === a2 && (a2 = "NDHWC");
      var s2 = mn(t2, "x", "avgPool3d", "float32"), u3 = s2, c2 = false;
      4 === s2.rank && (c2 = true, u3 = s2.as5D(1, s2.shape[0], s2.shape[1], s2.shape[2], s2.shape[3])), null == i2 && (i2 = [1, 1, 1]), C(5 === u3.rank, function() {
        return "Error in avgPool3d: x must be rank 5 but got rank " + u3.rank + ".";
      }), C("NDHWC" === a2, function() {
        return "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of " + a2;
      }), C(Mo(n2, i2), function() {
        return "Error in avgPool3d: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + i2 + "'";
      }), null != o2 && C(A(r2), function() {
        return "Error in avgPool3d: pad must be an integer when using, dimRoundingMode " + o2 + " but got pad " + r2 + ".";
      });
      var l2 = ko(u3.shape, e2, n2, i2, r2, o2, a2), h2 = Lt.runKernelFunc(function(t3) {
        return t3.avgPool3d(u3, l2);
      }, { x: u3 }, function(t3) {
        return { x: function() {
          return function(t4, e3, n3, r3, o3, a3, i3) {
            var s3 = mn(t4, "dy", "avgPool3dBackprop"), u4 = mn(e3, "input", "avgPool3dBackprop"), c3 = s3, l3 = u4, h3 = false;
            4 === u4.rank && (h3 = true, c3 = s3.as5D(1, s3.shape[0], s3.shape[1], s3.shape[2], s3.shape[3]), l3 = u4.as5D(1, u4.shape[0], u4.shape[1], u4.shape[2], u4.shape[3]));
            C(5 === c3.rank, function() {
              return "Error in avgPool3dBackprop: dy must be rank 5 but got rank " + c3.rank + ".";
            }), C(5 === l3.rank, function() {
              return "Error in avgPool3dBackprop: input must be rank 5 but got rank " + l3.rank + ".";
            }), null == o3 && (o3 = [1, 1, 1]);
            C(Mo(r3, o3), function() {
              return "Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides " + r3 + " and dilations '" + o3 + "'";
            }), null != i3 && C(A(a3), function() {
              return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + i3 + " but got pad " + a3 + ".";
            });
            var f2 = ko(l3.shape, n3, r3, o3, a3, i3), d2 = Lt.runKernelFunc(function(t5) {
              return t5.avgPool3dBackprop(c3, l3, f2);
            }, { dy5D: c3, input5D: l3 });
            if (h3) return d2.as4D(d2.shape[1], d2.shape[2], d2.shape[3], d2.shape[4]);
            return d2;
          }(t3, u3, e2, n2, i2, r2, o2);
        } };
      });
      return h2 = h2.cast(u3.dtype), c2 ? h2.as4D(h2.shape[1], h2.shape[2], h2.shape[3], h2.shape[4]) : h2;
    } });
    ml = An({ slice_: function(t2, e2, n2) {
      var r2, o2, a2 = mn(t2, "x", "slice");
      if (0 === a2.rank) throw new Error("Slicing scalar is not possible");
      (r2 = "number" == typeof e2 ? [e2].concat(new Array(a2.rank - 1).fill(0)) : e2.length < a2.rank ? e2.concat(new Array(a2.rank - e2.length).fill(0)) : e2.slice()).forEach(function(t3) {
        C(-1 !== t3, function() {
          return "slice() does not support negative begin indexing.";
        });
      }), o2 = (o2 = null == n2 ? new Array(a2.rank).fill(-1) : "number" == typeof n2 ? [n2].concat(new Array(a2.rank - 1).fill(-1)) : n2.length < a2.rank ? n2.concat(new Array(a2.rank - n2.length).fill(-1)) : n2).map(function(t3, e3) {
        return t3 >= 0 ? t3 : (C(-1 === t3, function() {
          return "Negative size values should be exactly -1 but got " + t3 + " for the slice() size at index " + e3 + ".";
        }), a2.shape[e3] - r2[e3]);
      }), eo(a2, r2, o2);
      var i2 = a2.shape, s2 = { begin: r2, size: o2 };
      return Lt.runKernelFunc(function(t3) {
        return t3.slice(a2, r2, o2);
      }, { x: a2 }, function(t3) {
        for (var e3 = [], n3 = 0; n3 < t3.rank; n3++) e3.push([r2[n3], i2[n3] - r2[n3] - o2[n3]]);
        return { x: function() {
          return t3.pad(e3);
        } };
      }, "Slice", s2);
    } });
    gl = An({ slice1d_: function(t2, e2, n2) {
      var r2 = mn(t2, "x", "slice1d");
      return C(1 === r2.rank, function() {
        return "slice1d expects a rank-1 tensor, but got a rank-" + r2.rank + " tensor";
      }), ml(r2, [e2], [n2]);
    } });
    yl = An({ slice2d_: function(t2, e2, n2) {
      var r2 = mn(t2, "x", "slice2d");
      return C(2 === r2.rank, function() {
        return "slice2d expects a rank-2 tensor, but got a rank-" + r2.rank + " tensor";
      }), ml(r2, e2, n2);
    } });
    xl = An({ slice3d_: function(t2, e2, n2) {
      var r2 = mn(t2, "x", "slice3d");
      return C(3 === r2.rank, function() {
        return "slice3d expects a rank-3 tensor, but got a rank-" + r2.rank + " tensor";
      }), ml(r2, e2, n2);
    } });
    bl = An({ slice4d_: function(t2, e2, n2) {
      var r2 = mn(t2, "x", "slice4d");
      return C(4 === r2.rank, function() {
        return "slice4d expects a rank-4 tensor, but got a rank-" + r2.rank + " tensor";
      }), ml(r2, e2, n2);
    } });
    Cl = An({ all_: function(t2, e2, n2) {
      void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
      var r2 = mn(t2, "x", "all", "bool"), o2 = O(e2, r2.shape), a2 = o2, i2 = En(a2, r2.rank);
      null != i2 && (r2 = r2.transpose(i2), a2 = In(a2.length, r2.rank));
      var s2 = Lt.runKernelFunc(function(t3) {
        return t3.all(r2, a2);
      }, { $x: r2 });
      if (n2) {
        var u3 = wn(s2.shape, o2);
        return s2.reshape(u3);
      }
      return s2;
    } });
    El = An({ any_: function(t2, e2, n2) {
      void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
      var r2 = mn(t2, "x", "any", "bool"), o2 = O(e2, r2.shape), a2 = o2, i2 = En(a2, r2.rank);
      null != i2 && (r2 = r2.transpose(i2), a2 = In(a2.length, r2.rank));
      var s2 = Lt.runKernelFunc(function(t3) {
        return t3.any(r2, a2);
      }, { $x: r2 });
      if (n2) {
        var u3 = wn(s2.shape, o2);
        return s2.reshape(u3);
      }
      return s2;
    } });
    Rl = An({ argMax_: function(t2, e2) {
      void 0 === e2 && (e2 = 0);
      var n2 = mn(t2, "x", "argMax");
      null == e2 && (e2 = 0);
      var r2 = O(e2, n2.shape), o2 = En(r2, n2.rank);
      null != o2 && (n2 = n2.transpose(o2), r2 = In(r2.length, n2.rank));
      var a2 = { axis: r2[0] }, i2 = [n2];
      return Lt.runKernelFunc(function(t3, e3) {
        var o3 = t3.argMax(n2, r2[0]);
        return e3([n2]), o3;
      }, { x: n2 }, function(t3, e3) {
        var n3 = e3[0];
        return { x: function() {
          return Xn(n3);
        } };
      }, "ArgMax", a2, i2);
    } });
    Il = An({ argMin_: function(t2, e2) {
      void 0 === e2 && (e2 = 0);
      var n2 = mn(t2, "x", "argMin");
      null == e2 && (e2 = 0);
      var r2 = O(e2, n2.shape), o2 = En(r2, n2.rank);
      return null != o2 && (n2 = n2.transpose(o2), r2 = In(r2.length, n2.rank)), Lt.runKernelFunc(function(t3, e3) {
        var o3 = t3.argMin(n2, r2[0]);
        return e3([n2]), o3;
      }, { $x: n2 }, function(t3, e3) {
        var n3 = e3[0];
        return { $x: function() {
          return Xn(n3);
        } };
      });
    } });
    kl = An({ logSumExp_: function(t2, e2, n2) {
      void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
      var r2 = mn(t2, "x", "logSumExp"), o2 = O(e2, r2.shape), a2 = r2.max(o2, true), i2 = r2.sub(a2).exp().sum(o2).log(), s2 = a2.reshape(i2.shape).add(i2);
      if (n2) {
        var u3 = wn(s2.shape, o2);
        return s2.reshape(u3);
      }
      return s2;
    } });
    Sl = An({ max_: function(t2, e2, n2) {
      void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
      var r2 = mn(t2, "x", "max"), o2 = r2, a2 = O(e2, r2.shape), i2 = a2, s2 = En(i2, r2.rank);
      null != s2 && (r2 = r2.transpose(s2), i2 = In(i2.length, r2.rank));
      var u3 = [r2], c2 = Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.max(r2, i2);
        return e3([o2, n3]), n3;
      }, { x: r2 }, function(t3, e3) {
        return wl(t3, e3[1], e3[0], a2, s2);
      }, "Max", { axes: i2 }, u3, [true]);
      if (n2) {
        var l2 = wn(c2.shape, a2);
        c2 = c2.reshape(l2);
      }
      return c2;
    } });
    Al = An({ mean_: function(t2, e2, n2) {
      void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
      var r2 = mn(t2, "x", "mean"), o2 = O(e2, r2.shape), a2 = k(bn(r2.shape, o2)[1]);
      return vo(function(t3) {
        var r3 = On(a2);
        return { value: (r3.dtype === t3.dtype ? t3 : t3.cast(r3.dtype)).div(r3).sum(e2, n2), gradFunc: function(e3) {
          var n3 = t3.shape.slice();
          return o2.forEach(function(t4) {
            n3[t4] = 1;
          }), e3.reshape(n3).mul(zn(t3.shape, "float32")).div(a2);
        } };
      })(r2);
    } });
    Dl = An({ min_: function(t2, e2, n2) {
      void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
      var r2 = mn(t2, "x", "min"), o2 = r2, a2 = O(e2, r2.shape), i2 = a2, s2 = En(i2, r2.rank);
      null != s2 && (r2 = r2.transpose(s2), i2 = In(i2.length, r2.rank));
      var u3 = [r2], c2 = Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.min(r2, i2);
        return e3([o2, n3]), n3;
      }, { x: r2 }, function(t3, e3) {
        return wl(t3, e3[1], e3[0], a2, s2);
      }, "Min", { axes: i2 }, u3, [true]);
      if (n2) {
        var l2 = wn(c2.shape, a2);
        c2 = c2.reshape(l2);
      }
      return c2;
    } });
    Tl = An({ moments_: function(t2, e2, n2) {
      void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
      var r2 = O(e2, (t2 = mn(t2, "x", "moments")).shape), o2 = t2.mean(r2, n2), a2 = o2.shape;
      n2 || (a2 = wn(o2.shape, r2));
      var i2 = t2.toFloat().sub(o2.reshape(a2)).square();
      return { mean: o2, variance: i2.mean(r2, n2) };
    } });
    Nl = An({ sum_: function(t2, e2, n2) {
      void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
      var r2 = mn(t2, "x", "sum");
      "bool" === r2.dtype && (r2 = r2.toInt());
      var o2 = O(e2, r2.shape);
      return vo(function(t3) {
        var e3 = En(o2, t3.rank), r3 = o2, a2 = t3;
        null != e3 && (a2 = t3.transpose(e3), r3 = In(r3.length, t3.rank));
        var i2 = function(e4) {
          var n3 = t3.shape.slice();
          return o2.forEach(function(t4) {
            n3[t4] = 1;
          }), e4.reshape(n3).mul(zn(t3.shape, "float32"));
        }, s2 = { axes: r3 }, u3 = Lt.runKernelFunc(function(t4) {
          return t4.sum(a2, r3);
        }, { x: a2 }, function(t4) {
          return { x: function() {
            return i2(t4);
          } };
        }, "Sum", s2);
        if (n2) {
          var c2 = wn(u3.shape, o2);
          u3 = u3.reshape(c2);
        }
        return { value: u3, gradFunc: i2 };
      })(r2);
    } });
    Fl = An({ prod_: function(t2, e2, n2) {
      void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
      var r2 = mn(t2, "x", "prod");
      "bool" === r2.dtype && (r2 = r2.toInt());
      var o2 = O(e2, r2.shape), a2 = En(o2, r2.rank), i2 = o2, s2 = r2;
      null != a2 && (s2 = r2.transpose(a2), i2 = In(i2.length, r2.rank));
      var u3 = Lt.runKernelFunc(function(t3) {
        return t3.prod(s2, i2);
      }, { permutedX: s2 });
      if (n2) {
        var c2 = wn(u3.shape, o2);
        u3 = u3.reshape(c2);
      }
      return u3;
    } });
    _l = An({ elu_: function(t2) {
      var e2 = mn(t2, "x", "elu");
      return Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.elu(e2);
        return n2([r2]), r2;
      }, { $x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { $x: function() {
          return Lt.runKernelFunc(function(e4) {
            return e4.eluDer(t3, n2);
          }, { dy: t3, y: n2 });
        } };
      });
    } });
    Ol = An({ leakyRelu_: function(t2, e2) {
      void 0 === e2 && (e2 = 0.2);
      var n2 = mn(t2, "x", "leakyRelu");
      return hc(On(e2).mul(n2), n2);
    } });
    Ml = An({ prelu_: function(t2, e2) {
      var n2 = mn(t2, "x", "prelu"), r2 = mn(e2, "alpha", "prelu");
      return Lt.runKernelFunc(function(t3, e3) {
        var o2 = t3.prelu(n2, r2);
        return e3([n2, r2]), o2;
      }, { x: n2, alpha: r2 }, function(t3, e3) {
        var n3 = e3[0], r3 = e3[1], o2 = n3.greater(0);
        return { x: function() {
          return ec(o2, t3, t3.mul(r3));
        }, alpha: function() {
          var e4 = ec(o2, Xn(t3), t3.mul(n3)), a2 = Eo(r3.shape, t3.shape);
          return a2.length > 0 && (e4 = e4.sum(a2)), e4.reshape(r3.shape);
        } };
      }, "Prelu");
    } });
    Bl = An({ relu_: function(t2) {
      var e2 = mn(t2, "x", "relu");
      return "bool" === e2.dtype ? e2.toInt() : Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.relu(e2);
        return n2([e2]), r2;
      }, { x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { x: function() {
          return t3.mulStrict(n2.step().toFloat());
        } };
      }, "Relu");
    } });
    Pl = An({ relu6_: function(t2) {
      var e2 = mn(t2, "x", "relu6");
      return "bool" === e2.dtype ? e2.toInt() : Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.relu6(e2);
        return n2([e2]), r2;
      }, { x: e2 }, function(t3, e3) {
        var n2 = e3[0], r2 = n2.lessEqual(6).mul(n2.step());
        return { x: function() {
          return t3.mulStrict(r2.toFloat());
        } };
      }, "Relu6");
    } });
    Ll = An({ selu_: function(t2) {
      var e2 = mn(t2, "x", "selu");
      return Lt.runKernelFunc(function(t3, n2) {
        var r2 = t3.selu(e2);
        return n2([e2]), r2;
      }, { $x: e2 }, function(t3, e3) {
        var n2 = e3[0];
        return { $x: function() {
          var e4 = n2.greater(On(0)), r2 = On(bs), o2 = On(ws), a2 = t3.mul(o2), i2 = t3.mul(r2).mul(n2.toFloat().exp());
          return ec(e4, a2, i2);
        } };
      });
    } });
    Wl = An({ transpose_: function(t2, e2) {
      var n2 = mn(t2, "x", "transpose");
      if (null == e2 && (e2 = n2.shape.map(function(t3, e3) {
        return e3;
      }).reverse()), C(n2.rank === e2.length, function() {
        return "Error in transpose: rank of input " + n2.rank + " must match length of perm " + e2 + ".";
      }), e2.forEach(function(t3) {
        C(t3 >= 0 && t3 < n2.rank, function() {
          return "All entries in 'perm' must be between 0 and " + (n2.rank - 1) + " but got " + e2;
        });
      }), n2.rank <= 1) return n2.clone();
      var r2 = { perm: e2 };
      return Lt.runKernelFunc(function(t3) {
        return t3.transpose(n2, e2);
      }, { x: n2 }, function(t3) {
        var n3 = Rn(e2);
        return { x: function() {
          return t3.transpose(n3);
        } };
      }, "Transpose", r2);
    } });
    Ul = An({ localResponseNormalization_: function(t2, e2, n2, r2, o2) {
      void 0 === e2 && (e2 = 5), void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = 1), void 0 === o2 && (o2 = 0.5);
      var a2 = mn(t2, "x", "localResponseNormalization");
      C(4 === a2.rank || 3 === a2.rank, function() {
        return "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " + a2.rank + ".";
      }), C(A(e2), function() {
        return "Error in localResponseNormalization: depthRadius must be an integer but got depthRadius " + e2 + ".";
      });
      var i2 = a2, s2 = false;
      3 === a2.rank && (s2 = true, i2 = a2.as4D(1, a2.shape[0], a2.shape[1], a2.shape[2]));
      var u3 = Lt.runKernelFunc(function(t3, a3) {
        var s3 = t3.localResponseNormalization4D(i2, e2, n2, r2, o2);
        return a3([i2, s3]), s3;
      }, { x4D: i2 }, function(t3, a3) {
        var i3 = a3[0], s3 = a3[1];
        return { x4D: function() {
          return Lt.runKernelFunc(function(a4) {
            return a4.LRNGrad(t3, i3, s3, e2, n2, r2, o2);
          }, {});
        } };
      });
      return s2 ? u3.as3D(u3.shape[1], u3.shape[2], u3.shape[3]) : u3;
    } });
    Vl = An({ norm_: function(t2, e2, n2, r2) {
      void 0 === e2 && (e2 = "euclidean"), void 0 === n2 && (n2 = null), void 0 === r2 && (r2 = false);
      var o2 = function t3(e3, n3, r3) {
        void 0 === r3 && (r3 = null);
        if (0 === e3.rank) return e3.abs();
        if (1 !== e3.rank && null === r3) return t3(e3.reshape([-1]), n3, r3);
        if (1 === e3.rank || "number" == typeof r3 || Array.isArray(r3) && 1 === r3.length) {
          if (1 === n3) return e3.abs().sum(r3);
          if (n3 === 1 / 0) return e3.abs().max(r3);
          if (n3 === -1 / 0) return e3.abs().min(r3);
          if ("euclidean" === n3 || 2 === n3) return e3.abs().pow(On(2, "int32")).sum(r3).sqrt();
          throw new Error("Error in norm: invalid ord value: " + n3);
        }
        if (Array.isArray(r3) && 2 === r3.length) {
          if (1 === n3) return e3.abs().sum(r3[0]).max(r3[1] - 1);
          if (n3 === 1 / 0) return e3.abs().sum(r3[1]).max(r3[0]);
          if (n3 === -1 / 0) return e3.abs().sum(r3[1]).min(r3[0]);
          if ("fro" === n3 || "euclidean" === n3) return e3.square().sum(r3).sqrt();
          throw new Error("Error in norm: invalid ord value: " + n3);
        }
        throw new Error("Error in norm: invalid axis: " + r3);
      }(t2 = mn(t2, "x", "norm"), e2, n2), a2 = o2.shape;
      if (r2) {
        var i2 = O(n2, t2.shape);
        a2 = wn(o2.shape, i2);
      }
      return o2.reshape(a2);
    } });
    zl = An({ basicLSTMCell_: function(t2, e2, n2, r2, o2, a2) {
      var i2 = mn(t2, "forgetBias", "basicLSTMCell"), s2 = mn(e2, "lstmKernel", "basicLSTMCell"), u3 = mn(n2, "lstmBias", "basicLSTMCell"), c2 = mn(r2, "data", "basicLSTMCell"), l2 = mn(o2, "c", "basicLSTMCell"), h2 = mn(a2, "h", "basicLSTMCell"), f2 = c2.concat(h2, 1).matMul(s2).add(u3), d2 = f2.shape[0], p2 = f2.shape[1] / 4, v = [d2, p2], m = f2.slice([0, 0], v), g2 = f2.slice([0, p2], v), y2 = f2.slice([0, 2 * p2], v), x2 = f2.slice([0, 3 * p2], v), b2 = m.sigmoid().mulStrict(g2.tanh()).addStrict(l2.mulStrict(i2.add(y2).sigmoid())), w2 = b2.tanh().mulStrict(x2.sigmoid());
      return [b2, w2];
    } });
    Gl = An({ multiRNNCell_: function(t2, e2, n2, r2) {
      for (var o2 = mn(e2, "data", "multiRNNCell"), a2 = gn(n2, "c", "multiRNNCell"), i2 = gn(r2, "h", "multiRNNCell"), s2 = o2, u3 = [], c2 = 0; c2 < t2.length; c2++) {
        var l2 = t2[c2](s2, a2[c2], i2[c2]);
        u3.push(l2[0]), u3.push(l2[1]), s2 = l2[1];
      }
      var h2 = [], f2 = [];
      for (c2 = 0; c2 < u3.length; c2 += 2) h2.push(u3[c2]), f2.push(u3[c2 + 1]);
      return [h2, f2];
    } });
    Hl = An({ movingAverage_: function(t2, e2, n2, r2, o2) {
      void 0 === o2 && (o2 = true);
      var a2 = mn(t2, "v", "movingAverage"), i2 = mn(e2, "x", "movingAverage"), s2 = mn(n2, "decay", "movingAverage");
      Ft(a2, i2), C(S(a2.shape, i2.shape), function() {
        return "Shape mismatch in v and x";
      });
      var u3 = On(1), c2 = u3.sub(s2), l2 = i2.sub(a2).mul(c2);
      if (o2) {
        C(null != r2, function() {
          return "When using zeroDebias: true, step is required.";
        });
        var h2 = mn(r2, "step", "movingAverage");
        l2 = l2.div(u3.sub(xc(s2, h2)));
      }
      return a2.add(l2);
    } });
    ql = An({ stridedSlice_: function(t2, e2, n2, r2, o2, a2, i2, s2, u3) {
      if (void 0 === o2 && (o2 = 0), void 0 === a2 && (a2 = 0), void 0 === i2 && (i2 = 0), void 0 === s2 && (s2 = 0), void 0 === u3 && (u3 = 0), null == r2 && (r2 = new Array(e2.length)), 0 !== i2) throw new Error("ellipsis mask is not yet supported");
      var c2 = mn(t2, "x", "stridedSlice"), l2 = no(s2), h2 = c2.shape.slice();
      l2.forEach(function(t3) {
        e2[t3] = 0, n2[t3] = 1, h2.splice(t3, 0, 1);
      }), c2 = c2.reshape(h2);
      for (var f2 = 0; f2 < c2.rank; f2++) e2[f2] = oo(o2, e2, r2, c2.shape, f2), n2[f2] = ao(a2, n2, r2, c2.shape, f2), r2[f2] = r2[f2] || 1;
      var d2 = no(u3);
      d2.forEach(function(t3) {
        n2[t3] = e2[t3] + 1, r2[t3] = 1;
      });
      var p2 = ro(e2, n2, r2), v = p2.filter(function(t3, e3) {
        return -1 === d2.indexOf(e3);
      });
      return r2.every(function(t3) {
        return 1 === t3;
      }) ? ml(c2, e2, p2).reshape(v) : Lt.runKernelFunc(function(t3) {
        return t3.stridedSlice(c2, e2, n2, r2);
      }, { $x: c2 }).reshape(v);
    } });
    Kl = An({ topk_: function(t2, e2, n2) {
      void 0 === e2 && (e2 = 1), void 0 === n2 && (n2 = true);
      var r2 = mn(t2, "x", "topk");
      if (0 === r2.rank) throw new Error("topk() expects the input to be of rank 1 or higher");
      var o2 = r2.shape[r2.shape.length - 1];
      if (e2 > o2) throw new Error("'k' passed to topk() must be <= the last dimension (" + o2 + ") but got " + e2);
      var a2 = Lt.runKernelFunc(function(t3) {
        return t3.topk(r2, e2, n2);
      }, { $x: r2 });
      return { values: a2[0], indices: a2[1] };
    } });
    jl = An({ scatterND_: function(t2, e2, n2) {
      var r2 = mn(t2, "indices", "scatterND", "int32"), o2 = mn(e2, "updates", "scatterND");
      return Jr(o2, r2, n2), Lt.runKernelFunc(function(t3) {
        return t3.scatterND(r2, o2, n2);
      }, { indices: r2, updates: o2 }, null, "ScatterNd", { shape: n2 });
    } });
    Xl = An({ fft_: function(t2) {
      C("complex64" === t2.dtype, function() {
        return "The dtype for tf.spectral.fft() must be complex64 but got " + t2.dtype + ".";
      });
      var e2 = t2.shape[t2.shape.length - 1], n2 = t2.size / e2, r2 = t2.as2D(n2, e2);
      return Lt.runKernelFunc(function(t3) {
        return t3.fft(r2);
      }, { input: t2 }).reshape(t2.shape);
    } });
    Yl = An({ ifft_: function(t2) {
      C("complex64" === t2.dtype, function() {
        return "The dtype for tf.spectral.ifft() must be complex64 but got " + t2.dtype + ".";
      });
      var e2 = t2.shape[t2.shape.length - 1], n2 = t2.size / e2, r2 = t2.as2D(n2, e2);
      return Lt.runKernelFunc(function(t3) {
        return t3.ifft(r2);
      }, { input: t2 }).reshape(t2.shape);
    } });
    $l = An({ rfft_: function(t2, e2) {
      C("float32" === t2.dtype, function() {
        return "The dtype for rfft() must be real value but got " + t2.dtype;
      });
      var n2, r2 = t2.shape[t2.shape.length - 1], o2 = t2.size / r2;
      if (null != e2 && e2 < r2) {
        var a2 = t2.shape.map(function(t3) {
          return 0;
        }), i2 = t2.shape.map(function(t3) {
          return t3;
        });
        i2[t2.shape.length - 1] = e2, n2 = t2.slice(a2, i2), r2 = e2;
      } else if (null != e2 && e2 > r2) {
        var s2 = t2.shape.map(function(t3) {
          return t3;
        });
        s2[t2.shape.length - 1] = e2 - r2, n2 = t2.concat(Gn(s2), t2.shape.length - 1), r2 = e2;
      } else n2 = t2;
      var u3 = n2.zerosLike(), c2 = Dn(n2, u3).as2D(o2, r2), l2 = Xl(c2), h2 = Math.floor(r2 / 2) + 1, f2 = Tn(l2), d2 = Nn(l2), p2 = f2.split([h2, r2 - h2], f2.shape.length - 1), v = d2.split([h2, r2 - h2], d2.shape.length - 1), m = n2.shape.slice();
      return m[n2.shape.length - 1] = h2, Dn(p2[0], v[0]).reshape(m);
    } });
    Ql = An({ irfft_: function(t2) {
      var e2 = t2.shape[t2.shape.length - 1], n2 = t2.size / e2;
      if (e2 <= 2) {
        var r2 = t2.as2D(n2, e2), o2 = Yl(r2);
        return Tn(o2);
      }
      var a2 = [n2, 2 * (e2 - 1)], i2 = Tn(t2).as2D(n2, e2), s2 = Nn(t2).as2D(n2, e2), u3 = i2.slice([0, 1], [n2, e2 - 2]).reverse(1), c2 = s2.slice([0, 1], [n2, e2 - 2]).reverse(1).mul(On(-1)), l2 = i2.concat(u3, 1), h2 = s2.concat(c2, 1);
      return r2 = Dn(l2, h2).as2D(a2[0], a2[1]), o2 = Yl(r2), Tn(o2);
    } });
    Jl = Object.freeze({ fft: Xl, ifft: Yl, rfft: $l, irfft: Ql });
    Zl = An({ sparseToDense_: function(t2, e2, n2, r2) {
      void 0 === r2 && (r2 = 0);
      var o2 = mn(t2, "sparseIndices", "sparseToDense", "int32"), a2 = mn(e2, "sparseValues", "sparseToDense"), i2 = mn(r2, "defaultValue", "sparseToDense", a2.dtype);
      return function(t3, e3, n3, r3) {
        if ("int32" !== t3.dtype) throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was " + t3.dtype + ".");
        if (t3.rank > 2) throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape " + t3.shape + ".");
        var o3 = t3.rank > 0 ? t3.shape[0] : 1, a3 = t3.rank > 1 ? t3.shape[1] : 1;
        if (n3.length !== a3) throw new Error("outputShape has incorrect number of elements:, " + n3.length + ", should be: " + a3 + ".");
        var i3 = e3.size;
        if (0 !== e3.rank && (1 !== e3.rank || i3 !== o3)) throw new Error("sparseValues has incorrect shape " + e3.shape + ", should be [] or [" + o3 + "]");
        if (e3.dtype !== r3.dtype) throw new Error("sparseValues.dtype must match defaultValues.dtype");
      }(o2, a2, n2, i2), Lt.runKernelFunc(function(t3) {
        return t3.sparseToDense(o2, a2, n2, i2);
      }, { $sparseIndices: o2, $sparseValues: a2, $defaultValue: i2 });
    } });
    th = An({ gatherND_: function(t2, e2) {
      var n2 = mn(e2, "indices", "gatherND", "int32"), r2 = mn(t2, "x", "gatherND");
      return Lt.runKernelFunc(function(t3) {
        return t3.gatherND(r2, n2);
      }, { x: r2, indices: n2 }, null, "GatherNd");
    } });
    eh = An({ diag_: function(t2) {
      var e2 = mn(t2, "x", "diag").flatten(), n2 = t2.shape.concat(t2.shape);
      return Lt.runKernelFunc(function(t3) {
        return t3.diag(e2);
      }, { $x: e2 }).reshape(n2);
    } });
    nh = An({ dropout_: function(t2, e2, n2, r2) {
      var o2 = mn(t2, "x", "dropout");
      if (C("float32" === o2.dtype, function() {
        return "x has to be a floating point tensor since it's going to be scaled, but got a " + o2.dtype + " tensor instead.";
      }), C(e2 >= 0 && e2 < 1, function() {
        return "rate must be a float in the range [0, 1), but got " + e2 + ".";
      }), 0 === e2) return t2 instanceof wt ? o2.clone() : o2;
      var a2 = function(t3, e3) {
        if (null == e3) return t3.shape.slice();
        if (S(t3.shape, e3)) return e3;
        if (t3.shape.length === e3.length) {
          for (var n3 = [], r3 = 0; r3 < t3.shape.length; r3++) null == e3[r3] && null != t3.shape[r3] ? n3.push(t3.shape[r3]) : n3.push(e3[r3]);
          return n3;
        }
        return e3;
      }(o2, n2), i2 = 1 - e2, s2 = _r(a2, 0, 1, "float32", r2).add(i2).floor().div(i2);
      return o2.mul(s2);
    } });
    oh = An({ hannWindow_: function(t2) {
      return rh(t2, 0.5, 0.5);
    } });
    ah = An({ hammingWindow_: function(t2) {
      return rh(t2, 0.54, 0.46);
    } });
    ih = An({ frame_: function(t2, e2, n2, r2, o2) {
      void 0 === r2 && (r2 = false), void 0 === o2 && (o2 = 0);
      for (var a2 = 0, i2 = []; a2 + e2 <= t2.size; ) i2.push(ml(t2, a2, e2)), a2 += n2;
      if (r2) for (; a2 < t2.size; ) {
        var s2 = a2 + e2 - t2.size, u3 = Yn([ml(t2, a2, e2 - s2), Hn([s2], o2)]);
        i2.push(u3), a2 += n2;
      }
      return 0 === i2.length ? Bn([], [0, e2]) : Yn(i2).as2D(i2.length, e2);
    } });
    sh = An({ stft_: function(t2, e2, n2, r2, o2) {
      var a2;
      void 0 === o2 && (o2 = oh), null == r2 && (a2 = e2, r2 = Math.floor(Math.pow(2, Math.ceil(Math.log(a2) / Math.log(2)))));
      for (var i2 = ih(t2, e2, n2), s2 = gc(i2, o2(e2)), u3 = [], c2 = 0; c2 < i2.shape[0]; c2++) u3.push($l(s2.slice([c2, 0], [1, e2]), r2));
      return Yn(u3);
    } });
    uh = Object.freeze({ hannWindow: oh, hammingWindow: ah, frame: ih, stft: sh });
    lh = function(t2, e2, o2) {
      return void 0 === o2 && (o2 = 1), n(this, void 0, void 0, function() {
        var n2, a2, i2, s2, u3, c2, l2, h2, f2, d2, p2, v, m, g2;
        return r(this, function(r2) {
          switch (r2.label) {
            case 0:
              return n2 = mn(t2, "predictions", "inTopK"), a2 = mn(e2, "targets", "inTopK"), C(n2.rank > 1, function() {
                return "inTopK() expects the predictions to be of rank 2 or higher, but got " + n2.rank;
              }), C(n2.rank - 1 === a2.rank, function() {
                return "predictions rank should be 1 larger than targets rank, but got predictions rank " + n2.rank + " and targets rank " + a2.rank;
              }), E(n2.shape.slice(0, n2.shape.length - 1), a2.shape, "predictions's shape should be align with the targets' shape, except the last dimension."), i2 = n2.shape[n2.shape.length - 1], C(o2 > 0 && o2 <= i2, function() {
                return "'k' passed to inTopK() must be > 0 && <= the predictions last dimension (" + i2 + "), but got " + o2;
              }), [4, n2.data()];
            case 1:
              return s2 = r2.sent(), [4, a2.data()];
            case 2:
              for (u3 = r2.sent(), c2 = [s2.length / i2, i2], h2 = c2[1], f2 = B("bool", l2 = c2[0]), d2 = 0; d2 < l2; d2++) {
                for (p2 = d2 * h2, v = s2.subarray(p2, p2 + h2), m = [], g2 = 0; g2 < v.length; g2++) m.push({ value: v[g2], index: g2 });
                for (m.sort(function(t3, e3) {
                  return e3.value - t3.value;
                }), f2[d2] = 0, g2 = 0; g2 < o2; g2++) if (m[g2].index === u3[d2]) {
                  f2[d2] = 1;
                  break;
                }
              }
              return t2 !== n2 && n2.dispose(), e2 !== a2 && a2.dispose(), [2, Fn(f2, a2.shape, "bool")];
          }
        });
      });
    };
    !function(t2) {
      t2[t2.NONE = 0] = "NONE", t2[t2.MEAN = 1] = "MEAN", t2[t2.SUM = 2] = "SUM", t2[t2.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
    }(ch || (ch = {}));
    hh = An({ absoluteDifference_: function(t2, e2, n2, r2) {
      void 0 === r2 && (r2 = ch.SUM_BY_NONZERO_WEIGHTS);
      var o2 = mn(t2, "labels", "absoluteDifference"), a2 = mn(e2, "predictions", "absoluteDifference"), i2 = null;
      null != n2 && (i2 = mn(n2, "weights", "absoluteDifference")), E(o2.shape, a2.shape, "Error in absoluteDifference: ");
      var s2 = o2.sub(a2).abs();
      return fh(s2, i2, r2);
    } });
    fh = An({ computeWeightedLoss_: function(t2, e2, n2) {
      void 0 === n2 && (n2 = ch.SUM_BY_NONZERO_WEIGHTS);
      var r2 = mn(t2, "losses", "computeWeightedLoss"), o2 = null;
      null != e2 && (o2 = mn(e2, "weights", "computeWeightedLoss"));
      var a2 = null == o2 ? r2 : r2.mul(o2);
      if (n2 === ch.NONE) return a2;
      if (n2 === ch.SUM) return a2.sum();
      if (n2 === ch.MEAN) {
        if (null == o2) return a2.mean();
        var i2 = r2.size / o2.size, s2 = a2.sum().div(o2.sum());
        return i2 > 1 ? s2.div(On(i2)) : s2;
      }
      if (n2 === ch.SUM_BY_NONZERO_WEIGHTS) {
        if (null == o2) return a2.sum().div(On(r2.size));
        var u3 = o2.mul(zn(r2.shape)).notEqual(On(0)).sum().toFloat();
        return a2.sum().div(u3);
      }
      throw Error("Unknown reduction: " + n2);
    } });
    dh = An({ cosineDistance_: function(t2, e2, n2, r2, o2) {
      void 0 === o2 && (o2 = ch.SUM_BY_NONZERO_WEIGHTS);
      var a2 = mn(t2, "labels", "cosineDistance"), i2 = mn(e2, "predictions", "cosineDistance"), s2 = null;
      null != r2 && (s2 = mn(r2, "weights", "cosineDistance")), E(a2.shape, i2.shape, "Error in cosineDistance: ");
      var u3 = On(1).sub(a2.mul(i2).sum(n2, true));
      return fh(u3, s2, o2);
    } });
    ph = An({ hingeLoss_: function(t2, e2, n2, r2) {
      void 0 === r2 && (r2 = ch.SUM_BY_NONZERO_WEIGHTS);
      var o2 = mn(t2, "labels", "hingeLoss"), a2 = mn(e2, "predictions", "hingeLoss"), i2 = null;
      null != n2 && (i2 = mn(n2, "weights", "hingeLoss")), E(o2.shape, a2.shape, "Error in hingeLoss: ");
      var s2 = On(1);
      o2 = On(2).mul(o2).sub(s2);
      var u3 = s2.sub(o2.mul(a2)).relu();
      return fh(u3, i2, r2);
    } });
    vh = An({ huberLoss_: function(t2, e2, n2, r2, o2) {
      void 0 === r2 && (r2 = 1), void 0 === o2 && (o2 = ch.SUM_BY_NONZERO_WEIGHTS);
      var a2 = mn(t2, "labels", "huberLoss"), i2 = mn(e2, "predictions", "huberLoss"), s2 = null;
      null != n2 && (s2 = mn(n2, "weights", "huberLoss")), E(a2.shape, i2.shape, "Error in huberLoss: ");
      var u3 = On(r2), c2 = i2.sub(a2).abs(), l2 = dc(c2, u3), h2 = c2.sub(l2), f2 = On(0.5).mul(l2.square()).add(u3.mul(h2));
      return fh(f2, s2, o2);
    } });
    mh = An({ logLoss_: function(t2, e2, n2, r2, o2) {
      void 0 === r2 && (r2 = 1e-7), void 0 === o2 && (o2 = ch.SUM_BY_NONZERO_WEIGHTS);
      var a2 = mn(t2, "labels", "logLoss"), i2 = mn(e2, "predictions", "logLoss"), s2 = null;
      null != n2 && (s2 = mn(n2, "weights", "logLoss")), E(a2.shape, i2.shape, "Error in logLoss: ");
      var u3 = On(1), c2 = On(r2), l2 = a2.mul(i2.add(c2).log()).neg().sub(u3.sub(a2).mul(u3.sub(i2).add(c2).log()));
      return fh(l2, s2, o2);
    } });
    gh = An({ meanSquaredError_: function(t2, e2, n2, r2) {
      void 0 === r2 && (r2 = ch.SUM_BY_NONZERO_WEIGHTS);
      var o2 = mn(t2, "labels", "meanSquaredError"), a2 = mn(e2, "predictions", "meanSquaredError"), i2 = null;
      null != n2 && (i2 = mn(n2, "weights", "meanSquaredError")), E(o2.shape, a2.shape, "Error in meanSquaredError: ");
      var s2 = o2.squaredDifference(a2);
      return fh(s2, i2, r2);
    } });
    yh = An({ sigmoidCrossEntropy_: function(t2, e2, n2, r2, o2) {
      void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = ch.SUM_BY_NONZERO_WEIGHTS);
      var a2 = mn(t2, "multiClassLabels", "sigmoidCrossEntropy"), i2 = mn(e2, "logits", "sigmoidCrossEntropy"), s2 = null;
      if (null != n2 && (s2 = mn(n2, "weights", "sigmoidCrossEntropy")), E(a2.shape, i2.shape, "Error in sigmoidCrossEntropy: "), r2 > 0) {
        var u3 = On(r2), c2 = On(1), l2 = On(0.5);
        a2 = a2.mul(c2.sub(u3)).add(l2.mul(u3));
      }
      var h2 = function(t3, e3) {
        var n3 = mn(t3, "labels", "sigmoidCrossEntropyWithLogits"), r3 = mn(e3, "logits", "sigmoidCrossEntropyWithLogits");
        E(n3.shape, r3.shape, "Error in sigmoidCrossEntropyWithLogits: ");
        var o3 = r3.relu(), a3 = r3.mul(n3), i3 = r3.abs().neg().exp().log1p();
        return o3.sub(a3).add(i3);
      }(a2, i2);
      return fh(h2, s2, o2);
    } });
    xh = An({ softmaxCrossEntropy_: function(t2, e2, n2, r2, o2) {
      void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = ch.SUM_BY_NONZERO_WEIGHTS);
      var a2 = mn(t2, "onehotLabels", "softmaxCrossEntropy"), i2 = mn(e2, "logits", "softmaxCrossEntropy"), s2 = null;
      if (null != n2 && (s2 = mn(n2, "weights", "softmaxCrossEntropy")), E(a2.shape, i2.shape, "Error in softmaxCrossEntropy: "), r2 > 0) {
        var u3 = On(r2), c2 = On(1), l2 = On(a2.shape[1]);
        a2 = a2.mul(c2.sub(u3)).add(u3.div(l2));
      }
      var h2 = function(t3, e3, n3) {
        if (void 0 === n3 && (n3 = -1), -1 === n3 && (n3 = e3.rank - 1), n3 !== e3.rank - 1) throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank " + e3.rank + " and dim was " + n3);
        return vo(function(t4, e4, r3) {
          var o3 = e4.logSumExp([n3], true), a3 = e4.toFloat().sub(o3);
          r3([t4, a3]);
          return { value: a3.mul(t4).neg().sum([n3]), gradFunc: function(t5, e5) {
            var r4 = e5[0], o4 = e5[1], a4 = wn(t5.shape, [n3]);
            return [t5.reshape(a4).mul(r4.toFloat().sub(o4.exp())), t5.reshape(a4).mul(o4.exp().sub(r4.toFloat()))];
          } };
        })(t3, e3);
      }(a2, i2);
      return fh(h2, s2, o2);
    } });
    bh = Object.freeze({ get Reduction() {
      return ch;
    }, absoluteDifference: hh, computeWeightedLoss: fh, cosineDistance: dh, hingeLoss: ph, huberLoss: vh, logLoss: mh, meanSquaredError: gh, sigmoidCrossEntropy: yh, softmaxCrossEntropy: xh });
    Ch = An({ bandPart_: function(t2, e2, n2) {
      if (e2 % 1 != 0) throw new Error("bandPart(): numLower must be an integer, got " + e2 + ".");
      if (n2 % 1 != 0) throw new Error("bandPart(): numUpper must be an integer, got " + n2 + ".");
      var r2 = mn(t2, "a", "bandPart");
      if (r2.rank < 2) throw new Error("bandPart(): Rank must be at least 2, got " + r2.rank + ".");
      var o2 = r2.shape, a2 = r2.shape.slice(-2), i2 = a2[0], s2 = a2[1];
      if (!(e2 <= i2)) throw new Error("bandPart(): numLower (" + e2 + ") must not be greater than the number of rows (" + i2 + ").");
      if (!(n2 <= s2)) throw new Error("bandPart(): numUpper (" + n2 + ") must not be greater than the number of columns (" + s2 + ").");
      e2 < 0 && (e2 = i2), n2 < 0 && (n2 = s2);
      var u3 = Kn(0, i2, 1, "int32").reshape([-1, 1]), c2 = Kn(0, s2, 1, "int32"), l2 = Cc(u3, c2), h2 = Qu(l2.lessEqual(On(+e2, "int32")), l2.greaterEqual(On(-n2, "int32"))), f2 = Gn([i2, s2], r2.dtype);
      return Pr(Ur(r2.reshape([-1, i2, s2])).map(function(t3) {
        return ec(h2, t3, f2);
      })).reshape(o2);
    } });
    Eh = An({ gramSchmidt_: function(t2) {
      var e2;
      if (Array.isArray(t2)) {
        e2 = false, C(null != t2 && t2.length > 0, function() {
          return "Gram-Schmidt process: input must not be null, undefined, or empty";
        });
        for (var n2 = t2[0].shape[0], r2 = function(e3) {
          C(t2[e3].shape[0] === n2, function() {
            return "Gram-Schmidt: Non-unique lengths found in the input vectors: (" + t2[e3].shape[0] + " vs. " + n2 + ")";
          });
        }, o2 = 1; o2 < t2.length; ++o2) r2(o2);
      } else e2 = true, t2 = tr(t2, t2.shape[0], 0).map(function(t3) {
        return Br(t3, [0]);
      });
      C(t2.length <= t2[0].shape[0], function() {
        return "Gram-Schmidt: Number of vectors (" + t2.length + ") exceeds number of dimensions (" + t2[0].shape[0] + ").";
      });
      var a2 = [], i2 = t2, s2 = function(t3) {
        a2.push(Lt.tidy(function() {
          var e3 = i2[t3];
          if (t3 > 0) for (var n3 = 0; n3 < t3; ++n3) {
            var r3 = Nl(a2[n3].mulStrict(e3)).mul(a2[n3]);
            e3 = e3.sub(r3);
          }
          return e3.div(Vl(e3, "euclidean"));
        }));
      };
      for (o2 = 0; o2 < t2.length; ++o2) s2(o2);
      return e2 ? Pr(a2, 0) : a2;
    } });
    Rh = An({ qr_: function(t2, e2) {
      if (void 0 === e2 && (e2 = false), t2.rank < 2) throw new Error("qr() requires input tensor to have a rank >= 2, but got rank " + t2.rank);
      if (2 === t2.rank) return wh(t2, e2);
      var n2 = t2.shape.slice(0, t2.shape.length - 2).reduce(function(t3, e3) {
        return t3 * e3;
      }), r2 = Ur(t2.reshape([n2, t2.shape[t2.shape.length - 2], t2.shape[t2.shape.length - 1]]), 0), o2 = [], a2 = [];
      return r2.forEach(function(t3) {
        var n3 = wh(t3, e2), r3 = n3[0], i2 = n3[1];
        o2.push(r3), a2.push(i2);
      }), [Pr(o2, 0).reshape(t2.shape), Pr(a2, 0).reshape(t2.shape)];
    } });
    Ih = Object.freeze({ bandPart: Ch, gramSchmidt: Eh, qr: Rh });
    Sh = An({ resizeBilinear_: function(t2, e2, n2) {
      void 0 === n2 && (n2 = false);
      var r2 = mn(t2, "images", "resizeBilinear");
      C(3 === r2.rank || 4 === r2.rank, function() {
        return "Error in resizeBilinear: x must be rank 3 or 4, but got rank " + r2.rank + ".";
      }), C(2 === e2.length, function() {
        return "Error in resizeBilinear: new shape must 2D, but got shape " + e2 + ".";
      });
      var o2 = r2, a2 = false;
      3 === r2.rank && (a2 = true, o2 = r2.as4D(1, r2.shape[0], r2.shape[1], r2.shape[2]));
      var i2 = e2[0], s2 = e2[1], u3 = Lt.runKernelFunc(function(t3, e3) {
        return e3([o2]), t3.resizeBilinear(o2, i2, s2, n2);
      }, { x: o2 }, function(t3, e3) {
        return { x: function() {
          return Lt.runKernelFunc(function(r3) {
            return r3.resizeBilinearBackprop(t3, e3[0], n2);
          }, {});
        } };
      }, "ResizeBilinear", { alignCorners: n2, newHeight: i2, newWidth: s2 });
      return a2 ? u3.as3D(u3.shape[1], u3.shape[2], u3.shape[3]) : u3;
    } });
    Ah = An({ resizeNearestNeighbor_: function(t2, e2, n2) {
      void 0 === n2 && (n2 = false);
      var r2 = mn(t2, "images", "resizeNearestNeighbor");
      C(3 === r2.rank || 4 === r2.rank, function() {
        return "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank " + r2.rank + ".";
      }), C(2 === e2.length, function() {
        return "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + e2 + ".";
      }), C("float32" === r2.dtype || "int32" === r2.dtype, function() {
        return "`images` must have `int32` or `float32` as dtype";
      });
      var o2 = r2, a2 = false;
      3 === r2.rank && (a2 = true, o2 = r2.as4D(1, r2.shape[0], r2.shape[1], r2.shape[2]));
      var i2 = e2[0], s2 = e2[1], u3 = Lt.runKernelFunc(function(t3, e3) {
        return e3([o2]), t3.resizeNearestNeighbor(o2, i2, s2, n2);
      }, { batchImages: o2 }, function(t3, e3) {
        return { batchImages: function() {
          return Lt.runKernelFunc(function(r3) {
            return r3.resizeNearestNeighborBackprop(t3, e3[0], n2);
          }, {});
        } };
      });
      return a2 ? u3.as3D(u3.shape[1], u3.shape[2], u3.shape[3]) : u3;
    } });
    Dh = An({ nonMaxSuppression_: function(t2, e2, n2, r2, o2) {
      void 0 === r2 && (r2 = 0.5), void 0 === o2 && (o2 = Number.NEGATIVE_INFINITY);
      var a2 = mn(t2, "boxes", "nonMaxSuppression"), i2 = mn(e2, "scores", "nonMaxSuppression"), s2 = kh(a2, i2, n2, r2, o2);
      n2 = s2.maxOutputSize, r2 = s2.iouThreshold, o2 = s2.scoreThreshold;
      var u3 = { maxOutputSize: n2, iouThreshold: r2, scoreThreshold: o2 };
      return Lt.runKernelFunc(function(t3) {
        return t3.nonMaxSuppression(a2, i2, n2, r2, o2);
      }, { boxes: a2, scores: i2 }, null, "NonMaxSuppressionV3", u3);
    } });
    Th = function(t2, e2, o2, a2, i2) {
      return void 0 === a2 && (a2 = 0.5), void 0 === i2 && (i2 = Number.NEGATIVE_INFINITY), n(this, void 0, void 0, function() {
        var n2, s2, u3, c2, l2, h2, f2;
        return r(this, function(r2) {
          switch (r2.label) {
            case 0:
              return n2 = mn(t2, "boxes", "nonMaxSuppressionAsync"), s2 = mn(e2, "scores", "nonMaxSuppressionAsync"), u3 = kh(n2, s2, o2, a2, i2), o2 = u3.maxOutputSize, a2 = u3.iouThreshold, i2 = u3.scoreThreshold, [4, Promise.all([n2.data(), s2.data()])];
            case 1:
              return c2 = r2.sent(), l2 = c2[0], h2 = c2[1], f2 = jo(l2, h2, o2, a2, i2), n2 !== t2 && n2.dispose(), s2 !== e2 && s2.dispose(), [2, f2];
          }
        });
      });
    };
    Nh = An({ nonMaxSuppressionWithScore_: function(t2, e2, n2, r2, o2, a2) {
      void 0 === r2 && (r2 = 0.5), void 0 === o2 && (o2 = Number.NEGATIVE_INFINITY), void 0 === a2 && (a2 = 0);
      var i2 = mn(t2, "boxes", "nonMaxSuppression"), s2 = mn(e2, "scores", "nonMaxSuppression"), u3 = kh(i2, s2, n2, r2, o2, a2), c2 = { maxOutputSize: n2 = u3.maxOutputSize, iouThreshold: r2 = u3.iouThreshold, scoreThreshold: o2 = u3.scoreThreshold, softNmsSigma: a2 = u3.softNmsSigma }, l2 = Lt.runKernel("NonMaxSuppressionV5", { boxes: i2, scores: s2 }, c2);
      return { selectedIndices: l2[0], selectedScores: l2[1] };
    } });
    Fh = function(t2, e2, o2, a2, i2, s2) {
      return void 0 === a2 && (a2 = 0.5), void 0 === i2 && (i2 = Number.NEGATIVE_INFINITY), void 0 === s2 && (s2 = 0), n(this, void 0, void 0, function() {
        var n2, u3, c2, l2, h2, f2, d2;
        return r(this, function(r2) {
          switch (r2.label) {
            case 0:
              return n2 = mn(t2, "boxes", "nonMaxSuppressionAsync"), u3 = mn(e2, "scores", "nonMaxSuppressionAsync"), c2 = kh(n2, u3, o2, a2, i2, s2), o2 = c2.maxOutputSize, a2 = c2.iouThreshold, i2 = c2.scoreThreshold, s2 = c2.softNmsSigma, [4, Promise.all([n2.data(), u3.data()])];
            case 1:
              return l2 = r2.sent(), h2 = l2[0], f2 = l2[1], d2 = Xo(h2, f2, o2, a2, i2, s2), n2 !== t2 && n2.dispose(), u3 !== e2 && u3.dispose(), [2, d2];
          }
        });
      });
    };
    _h = An({ cropAndResize_: function(t2, e2, n2, r2, o2, a2) {
      var i2 = mn(t2, "image", "cropAndResize"), s2 = mn(e2, "boxes", "cropAndResize", "float32"), u3 = mn(n2, "boxInd", "cropAndResize", "int32");
      o2 = o2 || "bilinear", a2 = a2 || 0;
      var c2 = s2.shape[0];
      return C(4 === i2.rank, function() {
        return "Error in cropAndResize: image must be rank 4,but got rank " + i2.rank + ".";
      }), C(2 === s2.rank && 4 === s2.shape[1], function() {
        return "Error in cropAndResize: boxes must be have size [" + c2 + ",4] but had shape " + s2.shape + ".";
      }), C(1 === u3.rank && u3.shape[0] === c2, function() {
        return "Error in cropAndResize: boxInd must be have size [" + c2 + "] but had shape " + s2.shape + ".";
      }), C(2 === r2.length, function() {
        return "Error in cropAndResize: cropSize must be of length 2, but got length " + r2.length + ".";
      }), C(r2[0] >= 1 && r2[1] >= 1, function() {
        return "cropSize must be atleast [1,1], but was " + r2;
      }), C("bilinear" === o2 || "nearest" === o2, function() {
        return "method must be bilinear or nearest, but was " + o2;
      }), Lt.runKernelFunc(function(t3, e3) {
        return t3.cropAndResize(i2, s2, u3, r2, o2, a2);
      }, { images: i2, boxes: s2, boxInd: u3 }, null, "CropAndResize", { method: o2, extrapolationValue: a2, cropSize: r2 });
    } });
    Oh = Object.freeze({ resizeBilinear: Sh, resizeNearestNeighbor: Ah, nonMaxSuppression: Dh, nonMaxSuppressionAsync: Th, nonMaxSuppressionWithScore: Nh, nonMaxSuppressionWithScoreAsync: Fh, cropAndResize: _h });
    Mh = function(t2, e2) {
      return !(t2 > 0) || "linear" === e2;
    };
    Bh = function(t2, e2, n2) {
      if (null == n2 || "linear" === n2) return t2;
      if ("relu" === n2) return t2.mul(e2.step());
      throw new Error("Gradient for activation " + n2 + " has not been implemented yet.");
    };
    Ph = function(t2, e2) {
      var n2 = e2, r2 = Eo(t2.shape, e2.shape);
      return r2.length > 0 && (n2 = n2.sum(r2)), n2.reshape(t2.shape);
    };
    Lh = function(t2, e2, n2) {
      if ("linear" === e2) return t2;
      if ("relu" === e2) return Bl(t2);
      if ("elu" === e2) return _l(t2);
      if ("relu6" === e2) return Pl(t2);
      if ("prelu" === e2) return Ml(t2, n2);
      throw new Error("Unknown fused activation " + e2 + ".");
    };
    Wh = An({ fusedMatMul_: function(t2) {
      var e2, n2 = t2.a, r2 = t2.b, o2 = t2.transposeA, a2 = void 0 !== o2 && o2, i2 = t2.transposeB, s2 = void 0 !== i2 && i2, u3 = t2.bias, c2 = t2.activation, l2 = void 0 === c2 ? "linear" : c2, h2 = t2.preluActivationWeights;
      if (false === Mh(Lt.state.gradientDepth, l2)) {
        var f2 = el(n2, r2, a2, s2);
        return null != u3 && (f2 = rc(f2, u3)), Lh(f2, l2, h2);
      }
      var d2 = mn(n2, "a", "fused matMul"), p2 = mn(r2, "b", "fused matMul");
      e2 = Nt(d2, p2), d2 = e2[0], p2 = e2[1];
      var v = a2 ? d2.shape[d2.rank - 2] : d2.shape[d2.rank - 1], m = s2 ? p2.shape[p2.rank - 1] : p2.shape[p2.rank - 2], g2 = a2 ? d2.shape[d2.rank - 1] : d2.shape[d2.rank - 2], y2 = s2 ? p2.shape[p2.rank - 2] : p2.shape[p2.rank - 1], x2 = d2.shape.slice(0, -2), b2 = p2.shape.slice(0, -2), w2 = k(x2), E2 = k(b2);
      C(d2.rank >= 2 && p2.rank >= 2 && d2.rank === p2.rank, function() {
        return "Error in fused matMul: inputs must have the same rank of at least 2, got ranks " + d2.rank + " and " + p2.rank + ".";
      }), C(S(x2, b2), function() {
        return "Error in fused matMul: outer dimensions (" + x2 + ") and (" + b2 + ") of Tensors with shapes " + d2.shape + " and " + p2.shape + " must match.";
      }), C(v === m, function() {
        return "Error in fused matMul: inner shapes (" + v + ") and (" + m + ") of Tensors with shapes " + d2.shape + " and " + p2.shape + " and transposeA=" + a2 + " and transposeB=" + s2 + " must match.";
      });
      var R2, I2, A2 = d2.shape.slice(0, -2).concat([g2, y2]), D2 = a2 ? d2.as3D(w2, v, g2) : d2.as3D(w2, g2, v), T2 = s2 ? p2.as3D(E2, y2, m) : p2.as3D(E2, m, y2);
      null != u3 && Ro(A2, (R2 = Nt(R2 = mn(u3, "bias", "fused matMul"), d2)[0]).shape), null != h2 && (I2 = mn(h2, "prelu weights", "fused matMul"));
      var N2 = { a: D2, b: T2 };
      null != u3 && (N2.bias = R2), null != h2 && (N2.preluActivationWeights = I2);
      var F2 = [D2, T2];
      return Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.fusedBatchMatMul({ a: D2, b: T2, transposeA: a2, transposeB: s2, bias: R2, activation: l2, preluActivationWeights: I2 });
        return e3([D2, T2, n3]), n3;
      }, N2, function(t3, e3) {
        var n3 = e3[0], r3 = e3[1], o3 = e3[2], i3 = Bh(t3, o3, l2), c3 = {};
        return null != u3 && (c3 = { bias: function() {
          return Ph(R2, i3);
        } }), a2 || s2 ? !a2 && s2 ? Object.assign({ a: function() {
          return i3.matMul(r3, false, false);
        }, b: function() {
          return i3.matMul(n3, true, false);
        } }, c3) : a2 && !s2 ? Object.assign({ a: function() {
          return r3.matMul(i3, false, true);
        }, b: function() {
          return n3.matMul(i3, false, false);
        } }, c3) : Object.assign({ a: function() {
          return r3.matMul(i3, true, true);
        }, b: function() {
          return i3.matMul(n3, true, true);
        } }, c3) : Object.assign({ a: function() {
          return i3.matMul(r3, false, true);
        }, b: function() {
          return n3.matMul(i3, true, false);
        } }, c3);
      }, "_FusedMatMul", { transposeA: a2, transposeB: s2, activation: l2 }, F2, [true]).reshape(A2);
    } });
    Uh = An({ fusedConv2d_: function(t2) {
      var e2 = t2.x, n2 = t2.filter, r2 = t2.strides, o2 = t2.pad, a2 = t2.dataFormat, i2 = void 0 === a2 ? "NHWC" : a2, s2 = t2.dilations, u3 = void 0 === s2 ? [1, 1] : s2, c2 = t2.dimRoundingMode, l2 = t2.bias, h2 = t2.activation, f2 = void 0 === h2 ? "linear" : h2, d2 = t2.preluActivationWeights;
      if (f2 = f2 || "linear", false === Mh(Lt.state.gradientDepth, f2)) {
        var p2 = qc(e2, n2, r2, o2, i2, u3, c2);
        return null != l2 && (p2 = rc(p2, l2)), Lh(p2, f2, d2);
      }
      var v = mn(e2, "x", "conv2d"), m = mn(n2, "filter", "conv2d"), g2 = v, y2 = false;
      3 === v.rank && (y2 = true, g2 = v.as4D(1, v.shape[0], v.shape[1], v.shape[2])), C(4 === g2.rank, function() {
        return "Error in fused conv2d: input must be rank 4, but got rank " + g2.rank + ".";
      }), C(4 === m.rank, function() {
        return "Error in fused conv2d: filter must be rank 4, but got rank " + m.rank + ".";
      }), null != c2 && C(A(o2), function() {
        return "Error in fused conv2d: pad must be an integer when using, dimRoundingMode " + c2 + " but got pad " + o2 + ".";
      }), C(g2.shape[3] === m.shape[2], function() {
        return "Error in conv2d: depth of input (" + g2.shape[3] + ") must match input depth for filter " + m.shape[2] + ".";
      }), C(Mo(r2, u3), function() {
        return "Error in conv2D: Either strides or dilations must be 1. Got strides " + r2 + " and dilations '" + u3 + "'";
      }), C("NHWC" === i2, function() {
        return "Error in conv2d: got dataFormat of " + i2 + " but only NHWC is currently supported.";
      });
      var x2, b2, w2 = So(g2.shape, m.shape, r2, u3, o2, c2);
      null != l2 && (x2 = Nt(x2 = mn(l2, "bias", "fused conv2d"), v)[0], Ro(w2.outShape, x2.shape)), null != d2 && (b2 = mn(d2, "prelu weights", "fused conv2d"));
      var E2 = { x: g2, filter: m };
      null != l2 && (E2.bias = x2), null != d2 && (E2.preluActivationWeights = b2);
      var R2 = [m, g2], I2 = Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.fusedConv2d({ input: g2, filter: m, convInfo: w2, bias: x2, activation: f2, preluActivationWeights: b2 });
        return e3([m, g2, n3]), n3;
      }, E2, function(t3, e3) {
        var n3 = e3, a3 = n3[0], i3 = n3[1], s3 = n3[2], c3 = Bh(t3, s3, f2);
        C(Oo(u3), function() {
          return "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + u3 + "'";
        });
        var h3 = {};
        return null != l2 && (h3 = { bias: function() {
          return Ph(x2, c3);
        } }), Object.assign({ x: function() {
          return Xc(i3.shape, c3, a3, r2, o2);
        }, filter: function() {
          return jc(i3, c3, a3.shape, r2, o2);
        } }, h3);
      }, "FusedConv2D", { convInfo: w2, activation: f2 }, R2, [true]);
      return y2 ? I2.as3D(I2.shape[1], I2.shape[2], I2.shape[3]) : I2;
    } });
    Vh = An({ fusedDepthwiseConv2d_: function(t2) {
      var e2 = t2.x, n2 = t2.filter, r2 = t2.strides, o2 = t2.pad, a2 = t2.dataFormat, i2 = void 0 === a2 ? "NHWC" : a2, s2 = t2.dilations, u3 = void 0 === s2 ? [1, 1] : s2, c2 = t2.dimRoundingMode, l2 = t2.bias, h2 = t2.activation, f2 = void 0 === h2 ? "linear" : h2, d2 = t2.preluActivationWeights;
      if (false === Mh(Lt.state.gradientDepth, f2)) {
        var p2 = Yc(e2, n2, r2, o2, i2, u3, c2);
        return null != l2 && (p2 = rc(p2, l2)), Lh(p2, f2, d2);
      }
      var v = mn(e2, "x", "depthwiseConv2d"), m = mn(n2, "filter", "depthwiseConv2d"), g2 = v, y2 = false;
      3 === v.rank && (y2 = true, g2 = v.as4D(1, v.shape[0], v.shape[1], v.shape[2])), C(4 === g2.rank, function() {
        return "Error in fused depthwiseConv2d: input must be rank 4, but got rank " + g2.rank + ".";
      }), C(4 === m.rank, function() {
        return "Error in fused depthwiseConv2d: filter must be rank 4, but got rank " + m.rank + ".";
      }), C(g2.shape[3] === m.shape[2], function() {
        return "Error in fused depthwiseConv2d: number of input channels (" + g2.shape[3] + ") must match the inChannels dimension in filter " + m.shape[2] + ".";
      }), null == u3 && (u3 = [1, 1]), C(Mo(r2, u3), function() {
        return "Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides " + r2 + " and dilations '" + u3 + "'";
      }), null != c2 && C(A(o2), function() {
        return "Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode " + c2 + " but got pad " + o2 + ".";
      });
      var x2, b2, w2 = So(g2.shape, m.shape, r2, u3, o2, c2, true);
      null != l2 && (x2 = Nt(x2 = mn(l2, "bias", "fused conv2d"), v)[0], Ro(w2.outShape, x2.shape)), null != d2 && (b2 = mn(d2, "prelu weights", "fused depthwiseConv2d"));
      var E2 = { x: g2, filter: m };
      null != l2 && (E2.bias = x2), null != d2 && (E2.preluActivationWeights = b2);
      var R2 = [m, g2], I2 = Lt.runKernelFunc(function(t3, e3) {
        var n3 = t3.fusedDepthwiseConv2D({ input: g2, filter: m, convInfo: w2, bias: x2, activation: f2, preluActivationWeights: b2 });
        return e3([m, g2, n3]), n3;
      }, E2, function(t3, e3) {
        C(Oo(u3), function() {
          return "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + u3 + "'";
        });
        var n3 = e3[0], r3 = e3[1], o3 = e3[2], a3 = Bh(t3, o3, f2), i3 = {};
        return null != l2 && (i3 = { bias: function() {
          return Ph(x2, a3);
        } }), Object.assign({ x: function() {
          return $c(r3.shape, a3, n3, w2);
        }, filter: function() {
          return Qc(r3, a3, n3.shape, w2);
        } }, i3);
      }, "FusedDepthwiseConv2D", { convInfo: w2, activation: f2 }, R2, [true]);
      return y2 ? I2.as3D(I2.shape[1], I2.shape[2], I2.shape[3]) : I2;
    } });
    zh = Object.freeze({ matMul: Wh, conv2d: Uh, depthwiseConv2d: Vh });
    Gh = Object.freeze({ image: Oh, linalg: Ih, losses: bh, spectral: Jl, fused: zh, signal: uh, square: tu, squaredDifference: nu, conv1d: Hc, conv2d: qc, conv3d: Kc, depthwiseConv2d: Yc, separableConv2d: Jc, conv2dTranspose: Zc, conv3dTranspose: tl, op: An, batchNormalization2d: Gu, batchNormalization3d: Hu, batchNormalization4d: qu, batchNormalization: Ku, batchNorm: ju, batchNorm2d: Xu, batchNorm3d: Yu, batchNorm4d: $u, booleanMaskAsync: Uc, complex: Dn, real: Tn, imag: Nn, concat: Yn, concat1d: $n, concat2d: Qn, concat3d: Jn, concat4d: Zn, split: tr, matMul: el, dot: nl, outerProduct: rl, reverse: ol, reverse1d: al, reverse2d: il, reverse3d: sl, reverse4d: ul, maxPool: hl, avgPool: fl, pool: dl, maxPool3d: pl, avgPool3d: vl, slice: ml, slice1d: gl, slice2d: yl, slice3d: xl, slice4d: bl, abs: ru, acos: ou, acosh: au, asin: iu, asinh: su, atan: uu, atanh: cu, ceil: lu, clipByValue: hu, cos: fu, cosh: du, erf: pu, exp: vu, expm1: mu, floor: gu, log: yu, log1p: xu, logSigmoid: bu, neg: wu, reciprocal: Cu, round: Eu, rsqrt: Ru, sigmoid: Iu, sign: ku, isNaN: Su, isInf: Au, isFinite: Du, sin: Tu, sinh: Nu, softplus: Fu, sqrt: _u, step: Ou, tan: Mu, tanh: Bu, all: Cl, any: El, argMax: Rl, argMin: Il, logSumExp: kl, max: Sl, mean: Al, min: Dl, moments: Tl, sum: Nl, prod: Fl, equal: Rc, equalStrict: Ic, greater: kc, greaterEqual: Sc, greaterEqualStrict: Ac, greaterStrict: Dc, less: Tc, lessEqual: Nc, lessEqualStrict: Fc, lessStrict: _c, notEqual: Oc, notEqualStrict: Mc, add: rc, addN: oc, addStrict: ac, atan2: ic, div: sc, divNoNan: uc, divStrict: cc, floorDiv: lc, maximum: hc, maximumStrict: fc, minimum: dc, minimumStrict: pc, mod: vc, modStrict: mc, mul: gc, mulStrict: yc, pow: xc, powStrict: bc, squaredDifferenceStrict: wc, sub: Cc, subStrict: Ec, elu: _l, leakyRelu: Ol, prelu: Ml, relu: Bl, relu6: Pl, selu: Ll, logicalAnd: Qu, logicalNot: Ju, logicalOr: Zu, logicalXor: tc, where: ec, whereAsync: nc, buffer: dr, print: pr, batchToSpaceND: vr, broadcastTo: mr, cast: gr, clone: yr, cumsum: xr, depthToSpace: br, expandDims: wr, eye: Cr, multinomial: Er, oneHot: Rr, pad: Ir, pad1d: kr, pad2d: Sr, pad3d: Ar, pad4d: Dr, rand: Tr, randomNormal: Nr, randomGamma: Fr, randomUniform: _r, reshape: Or, spaceToBatchND: Mr, squeeze: Br, stack: Pr, tile: Lr, truncatedNormal: Wr, unstack: Ur, setdiff1dAsync: Vr, fill: Hn, linspace: qn, ones: zn, range: Kn, scalar: On, tensor: Fn, tensor1d: Mn, tensor2d: Bn, tensor3d: Pn, tensor4d: Ln, tensor5d: Wn, tensor6d: Un, variable: Vn, zeros: Gn, onesLike: jn, zerosLike: Xn, transpose: Wl, softmax: go, logSoftmax: yo, localResponseNormalization: Ul, norm: Vl, gather: Lc, unsortedSegmentSum: Wc, basicLSTMCell: zl, multiRNNCell: Gl, movingAverage: Hl, stridedSlice: ql, topk: Kl, scatterND: jl, fft: Xl, ifft: Yl, rfft: $l, irfft: Ql, sparseToDense: Zl, gatherND: th, diag: eh, dropout: nh, hannWindow: oh, hammingWindow: ah, frame: ih, stft: sh, inTopKAsync: lh });
    Kh = function(t2) {
      function o2() {
        var e2 = t2.call(this) || this;
        return e2.blockSize = 48, e2.firstUse = true, e2.data = new xo(e2, Lt), e2;
      }
      return e(o2, t2), o2.prototype.write = function(t3, e2, n2) {
        this.firstUse && (this.firstUse = false, i().get("IS_NODE") && dn("\n============================\nHi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));
        var r2 = {};
        return this.data.set(r2, { values: t3, dtype: n2 }), r2;
      }, o2.prototype.move = function(t3, e2, n2, r2) {
        this.data.set(t3, { values: e2, dtype: r2 });
      }, o2.prototype.numDataIds = function() {
        return this.data.numDataIds();
      }, o2.prototype.read = function(t3) {
        return n(this, void 0, void 0, function() {
          return r(this, function(e2) {
            return [2, this.readSync(t3)];
          });
        });
      }, o2.prototype.readSync = function(t3) {
        var e2 = this.data.get(t3), n2 = e2.dtype, r2 = e2.complexTensors;
        return "complex64" === n2 ? Vo(this.readSync(r2.real.dataId), this.readSync(r2.imag.dataId)) : this.data.get(t3).values;
      }, o2.prototype.bufferSync = function(t3) {
        var e2 = this.readSync(t3.dataId), n2 = e2;
        if ("string" === t3.dtype) try {
          n2 = e2.map(function(t4) {
            return ot(t4);
          });
        } catch (t4) {
          throw new Error("Failed to decode encoded string bytes into utf-8");
        }
        return dr(t3.shape, t3.dtype, n2);
      }, o2.prototype.makeOutput = function(t3, e2, n2) {
        var r2 = this.write(t3, e2, n2);
        return Lt.makeTensorFromDataId(r2, e2, n2, this);
      }, o2.prototype.disposeData = function(t3) {
        if (this.data.has(t3)) {
          var e2 = this.data.get(t3).complexTensors;
          null != e2 && (e2.real.dispose(), e2.imag.dispose()), this.data.delete(t3);
        }
      }, o2.prototype.time = function(t3) {
        return n(this, void 0, void 0, function() {
          var e2;
          return r(this, function(n2) {
            return e2 = et(), t3(), [2, { kernelMs: et() - e2 }];
          });
        });
      }, o2.prototype.memory = function() {
        return { unreliable: true, reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."] };
      }, o2.prototype.complex = function(t3, e2) {
        var n2 = this.makeOutput(null, t3.shape, "complex64");
        return this.data.get(n2.dataId).complexTensors = { real: Lt.keep(t3.clone()), imag: Lt.keep(e2.clone()) }, n2;
      }, o2.prototype.real = function(t3) {
        return this.data.get(t3.dataId).complexTensors.real.clone();
      }, o2.prototype.imag = function(t3) {
        return this.data.get(t3.dataId).complexTensors.imag.clone();
      }, o2.prototype.slice = function(t3, e2, n2) {
        if (Hh(t3, "slice"), io(t3.shape, e2, n2)) {
          var r2 = so(e2, t3.strides), o3 = k(n2);
          return Fn(this.readSync(t3.dataId).subarray(r2, r2 + o3), n2, t3.dtype);
        }
        for (var a2 = dr(n2, t3.dtype), i2 = this.bufferSync(t3), s2 = 0; s2 < a2.size; ++s2) {
          var u3 = a2.indexToLoc(s2).map(function(t4, n3) {
            return t4 + e2[n3];
          });
          a2.values[s2] = i2.get.apply(i2, u3);
        }
        return a2.toTensor();
      }, o2.prototype.stridedSlice = function(t3, e2, n2, r2) {
        Hh(t3, "stridedSlice");
        var o3 = ro(e2, n2, r2);
        if (o3.some(function(t4) {
          return 0 === t4;
        })) return Fn([], o3);
        for (var a2 = dr(o3, t3.dtype), i2 = this.bufferSync(t3), s2 = 0; s2 < a2.size; s2++) {
          for (var u3 = a2.indexToLoc(s2), c2 = new Array(u3.length), l2 = 0; l2 < c2.length; l2++) c2[l2] = u3[l2] * r2[l2] + e2[l2];
          a2.set.apply(a2, [i2.get.apply(i2, c2)].concat(u3));
        }
        return a2.toTensor();
      }, o2.prototype.diag = function(t3) {
        for (var e2 = this.readSync(t3.dataId), n2 = dr([t3.size, t3.size], t3.dtype), r2 = n2.values, o3 = 0; o3 < e2.length; o3++) r2[o3 * t3.size + o3] = e2[o3];
        return n2.toTensor();
      }, o2.prototype.unstack = function(t3, e2) {
        for (var n2 = t3.shape[e2], r2 = new Array(t3.rank - 1), o3 = 0, a2 = 0; a2 < t3.rank; a2++) a2 !== e2 && (r2[o3++] = t3.shape[a2]);
        var i2 = new Array(t3.rank).fill(0), s2 = t3.shape.slice();
        s2[e2] = 1;
        var u3 = new Array(n2);
        for (a2 = 0; a2 < u3.length; a2++) i2[e2] = a2, u3[a2] = this.slice(t3, i2, s2).reshape(r2);
        return u3;
      }, o2.prototype.reverse = function(t3, e2) {
        Hh(t3, "reverse");
        for (var n2 = dr(t3.shape, t3.dtype), r2 = this.bufferSync(t3), o3 = function(o4) {
          var a3 = n2.indexToLoc(o4), i2 = a3.slice();
          e2.forEach(function(e3) {
            return i2[e3] = t3.shape[e3] - 1 - i2[e3];
          }), n2.set.apply(n2, [r2.get.apply(r2, i2)].concat(a3));
        }, a2 = 0; a2 < n2.size; a2++) o3(a2);
        return n2.toTensor();
      }, o2.prototype.concat = function(t3, e2) {
        var n2 = this;
        if ("complex64" === t3[0].dtype) {
          var r2 = t3.map(function(t4) {
            return Tn(t4);
          }), o3 = t3.map(function(t4) {
            return Nn(t4);
          });
          return Dn(this.concat(r2, e2), this.concat(o3, e2));
        }
        var a2 = t3.map(function(t4) {
          var n3 = k(t4.shape.slice(e2));
          return t4.as2D(-1, n3);
        }), i2 = Sn(a2.map(function(t4) {
          return t4.shape;
        }), 1), s2 = dr(i2, t3[0].dtype).values;
        if (1 === a2[0].shape[0]) {
          var u3 = 0;
          a2.forEach(function(t4) {
            s2.set(n2.readSync(t4.dataId), u3), u3 += t4.size;
          });
        } else {
          var c2 = 0;
          a2.forEach(function(t4) {
            for (var e3 = n2.readSync(t4.dataId), r3 = 0, o4 = 0; o4 < t4.shape[0]; ++o4) for (var a3 = o4 * i2[1] + c2, u4 = 0; u4 < t4.shape[1]; ++u4) s2[a3 + u4] = e3[r3++];
            c2 += t4.shape[1];
          });
        }
        var l2 = Sn(t3.map(function(t4) {
          return t4.shape;
        }), e2);
        return Fn(s2, l2, t3[0].dtype);
      }, o2.prototype.neg = function(t3) {
        return Hh(t3, "neg"), this.multiply(On(-1), t3);
      }, o2.prototype.add = function(t3, e2) {
        return "complex64" === t3.dtype || "complex64" === e2.dtype ? this.broadcastedBinaryComplexOp(t3.cast("complex64"), e2.cast("complex64"), function(t4, e3, n2, r2) {
          return { real: t4 + n2, imag: e3 + r2 };
        }) : this.broadcastedBinaryOp(t3, e2, Dt(t3.dtype, e2.dtype), function(t4, e3) {
          return t4 + e3;
        });
      }, o2.prototype.addN = function(t3) {
        var e2 = this;
        Hh(t3, "addN");
        for (var n2 = t3.map(function(t4) {
          return e2.readSync(t4.dataId);
        }), r2 = dr(t3[0].shape, t3[0].dtype), o3 = r2.values, a2 = 0; a2 < t3.length; a2++) for (var i2 = n2[a2], s2 = 0; s2 < o3.length; s2++) o3[s2] += i2[s2];
        return r2.toTensor();
      }, o2.prototype.softmax = function(t3, e2) {
        var n2 = O([e2], t3.shape), r2 = this.max(t3, n2), o3 = wn(r2.shape, n2), a2 = this.subtract(t3, r2.reshape(o3)), i2 = this.exp(a2), s2 = this.sum(i2, n2).reshape(o3);
        return this.realDivide(i2, s2);
      }, o2.prototype.subtract = function(t3, e2) {
        return "complex64" === t3.dtype || "complex64" === e2.dtype ? this.broadcastedBinaryComplexOp(t3.cast("complex64"), e2.cast("complex64"), function(t4, e3, n2, r2) {
          return { real: t4 - n2, imag: e3 - r2 };
        }) : this.broadcastedBinaryOp(t3, e2, Dt(t3.dtype, e2.dtype), function(t4, e3) {
          return t4 - e3;
        });
      }, o2.prototype.pow = function(t3, e2) {
        return Hh([t3, e2], "pow"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
          return Math.pow(t4, e3);
        });
      }, o2.prototype.batchMatMul = function(t3, e2, n2, r2) {
        Hh([t3, e2], "matMul");
        for (var o3 = n2 ? t3.shape[1] : t3.shape[2], a2 = n2 ? t3.shape[2] : t3.shape[1], i2 = r2 ? e2.shape[1] : e2.shape[2], s2 = t3.shape[0], u3 = this.readSync(t3.dataId), c2 = this.readSync(e2.dataId), l2 = n2 ? [t3.strides[0], 1, t3.strides[1]] : [t3.strides[0], t3.strides[1], 1], h2 = l2[0], f2 = l2[1], d2 = l2[2], p2 = r2 ? [1, e2.strides[1], e2.strides[0]] : [e2.strides[1], 1, e2.strides[0]], v = p2[0], m = p2[1], g2 = p2[2], y2 = a2 * i2, x2 = dr([s2, a2, i2], t3.dtype), b2 = x2.values, w2 = this.blockSize, C2 = 0; C2 < s2; C2++) for (var E2 = 0; E2 < a2; E2 += w2) for (var R2 = 0; R2 < i2; R2 += w2) for (var I2 = 0; I2 < o3; I2 += w2) for (var k2 = Math.min(E2 + w2, a2), S2 = Math.min(R2 + w2, i2), A2 = Math.min(I2 + w2, o3), D2 = E2; D2 < k2; D2++) for (var T2 = R2; T2 < S2; T2++) {
          for (var N2 = 0, F2 = I2; F2 < A2; F2++) N2 += u3[C2 * h2 + D2 * f2 + F2 * d2] * c2[F2 * v + T2 * m + C2 * g2];
          b2[C2 * y2 + (D2 * i2 + T2)] += N2;
        }
        return x2.toTensor();
      }, o2.prototype.fusedBatchMatMul = function(t3) {
        var e2 = t3.a, n2 = t3.b, r2 = t3.transposeA, o3 = t3.transposeB, a2 = t3.bias, i2 = t3.activation, s2 = t3.preluActivationWeights, u3 = this.batchMatMul(e2, n2, r2, o3);
        return a2 && (u3 = this.add(u3, a2)), i2 && (u3 = qh(this, u3, i2, s2)), u3;
      }, o2.prototype.multiply = function(t3, e2) {
        return "complex64" === t3.dtype || "complex64" === e2.dtype ? this.broadcastedBinaryComplexOp(t3.cast("complex64"), e2.cast("complex64"), function(t4, e3, n2, r2) {
          return { real: t4 * n2 - e3 * r2, imag: t4 * r2 + e3 * n2 };
        }) : this.broadcastedBinaryOp(t3, e2, Dt(t3.dtype, e2.dtype), function(t4, e3) {
          return t4 * e3;
        });
      }, o2.prototype.realDivide = function(t3, e2) {
        Hh([t3, e2], "realDivide");
        return this.broadcastedBinaryOp(t3, e2, "float32", function(t4, e3) {
          return t4 / e3;
        });
      }, o2.prototype.floorDiv = function(t3, e2) {
        Hh([t3, e2], "floorDiv");
        return this.broadcastedBinaryOp(t3, e2, "int32", function(t4, e3) {
          return Math.floor(t4 / e3);
        });
      }, o2.prototype.sum = function(t3, e2) {
        Hh(t3, "sum"), Cn("sum", e2, t3.rank);
        for (var n2 = bn(t3.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Gn(r2, Dt(t3.dtype, "int32")), i2 = k(o3), s2 = this.readSync(a2.dataId), u3 = this.readSync(t3.dataId), c2 = 0; c2 < s2.length; ++c2) {
          for (var l2 = c2 * i2, h2 = 0, f2 = 0; f2 < i2; ++f2) h2 += u3[l2 + f2];
          s2[c2] = h2;
        }
        return a2;
      }, o2.prototype.prod = function(t3, e2) {
        Hh(t3, "sum");
        for (var n2 = bn(t3.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Gn(r2, Dt(t3.dtype, "int32")), i2 = k(o3), s2 = this.readSync(a2.dataId), u3 = this.readSync(t3.dataId), c2 = 0; c2 < s2.length; ++c2) {
          for (var l2 = c2 * i2, h2 = 1, f2 = 0; f2 < i2; ++f2) h2 *= u3[l2 + f2];
          s2[c2] = h2;
        }
        return a2;
      }, o2.prototype.unsortedSegmentSum = function(t3, e2, n2) {
        Hh(t3, "unsortedSegmentSum");
        for (var r2 = [], o3 = t3.rank - e2.rank, a2 = 0; a2 < o3; ++a2) e2 = e2.expandDims(a2 + 1);
        for (a2 = 0; a2 < n2; ++a2) {
          var i2 = On(a2, "int32"), s2 = Rc(i2, e2).asType("float32").mul(t3).sum(0);
          r2.push(s2);
        }
        return Pr(r2);
      }, o2.prototype.argMin = function(t3, e2) {
        Hh(t3, "argMin");
        var n2 = [e2];
        Cn("argMin", n2, t3.rank);
        for (var r2 = bn(t3.shape, n2), o3 = r2[0], a2 = r2[1], i2 = Gn(o3, "int32"), s2 = k(a2), u3 = this.readSync(i2.dataId), c2 = this.readSync(t3.dataId), l2 = 0; l2 < u3.length; ++l2) {
          for (var h2 = l2 * s2, f2 = c2[h2], d2 = 0, p2 = 0; p2 < s2; ++p2) {
            var v = c2[h2 + p2];
            v < f2 && (f2 = v, d2 = p2);
          }
          u3[l2] = d2;
        }
        return i2;
      }, o2.prototype.argMax = function(t3, e2) {
        Hh(t3, "argMax");
        var n2 = [e2];
        Cn("argMax", n2, t3.rank);
        for (var r2 = bn(t3.shape, n2), o3 = r2[0], a2 = r2[1], i2 = Gn(o3, "int32"), s2 = k(a2), u3 = this.readSync(i2.dataId), c2 = this.readSync(t3.dataId), l2 = 0; l2 < u3.length; ++l2) {
          for (var h2 = l2 * s2, f2 = c2[h2], d2 = 0, p2 = 0; p2 < s2; ++p2) {
            var v = c2[h2 + p2];
            v > f2 && (f2 = v, d2 = p2);
          }
          u3[l2] = d2;
        }
        return i2;
      }, o2.prototype.cumsum = function(t3, e2, n2, r2) {
        if (Hh(t3, "cumsum"), e2 !== t3.rank - 1) throw new Error("backend.cumsum in CPU expects an inner-most axis=" + (t3.rank - 1) + " but got axis=" + e2);
        for (var o3 = Dt(t3.dtype, "int32"), a2 = Gn(t3.shape, o3), i2 = this.readSync(a2.dataId), s2 = this.readSync(t3.dataId), u3 = t3.shape[t3.rank - 1], c2 = r2 ? function(t4, e3) {
          return t4 + u3 - e3 - 1;
        } : function(t4, e3) {
          return t4 + e3;
        }, l2 = 0; l2 < s2.length; l2 += u3) for (var h2 = 0; h2 < u3; h2++) {
          var f2 = c2(l2, h2);
          if (0 === h2) i2[f2] = n2 ? 0 : s2[f2];
          else {
            var d2 = c2(l2, h2 - 1);
            i2[f2] = n2 ? s2[d2] + i2[d2] : s2[f2] + i2[d2];
          }
        }
        return a2;
      }, o2.prototype.equal = function(t3, e2) {
        return Hh([t3, e2], "equal"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
          return t4 === e3 ? 1 : 0;
        });
      }, o2.prototype.notEqual = function(t3, e2) {
        return Hh([t3, e2], "notEqual"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
          return t4 !== e3 ? 1 : 0;
        });
      }, o2.prototype.less = function(t3, e2) {
        return Hh([t3, e2], "less"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
          return t4 < e3 ? 1 : 0;
        });
      }, o2.prototype.lessEqual = function(t3, e2) {
        return Hh([t3, e2], "lessEqual"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
          return t4 <= e3 ? 1 : 0;
        });
      }, o2.prototype.greater = function(t3, e2) {
        return Hh([t3, e2], "greater"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
          return t4 > e3 ? 1 : 0;
        });
      }, o2.prototype.greaterEqual = function(t3, e2) {
        return Hh([t3, e2], "greaterEqual"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
          return t4 >= e3 ? 1 : 0;
        });
      }, o2.prototype.logicalNot = function(t3) {
        Hh(t3, "logicalNot");
        for (var e2 = this.readSync(t3.dataId), n2 = new Uint8Array(e2.length), r2 = 0; r2 < e2.length; ++r2) n2[r2] = e2[r2] ? 0 : 1;
        return this.makeOutput(n2, t3.shape, "bool");
      }, o2.prototype.logicalAnd = function(t3, e2) {
        return Hh([t3, e2], "logicalAnd"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
          return t4 && e3;
        });
      }, o2.prototype.logicalOr = function(t3, e2) {
        return Hh([t3, e2], "logicalOr"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
          return t4 || e3;
        });
      }, o2.prototype.select = function(t3, e2, n2) {
        Hh([t3, e2, n2], "select");
        for (var r2 = this.readSync(t3.dataId), o3 = this.readSync(e2.dataId), a2 = this.readSync(n2.dataId), i2 = Gn(e2.shape, Dt(e2.dtype, n2.dtype)), s2 = this.readSync(i2.dataId), u3 = 0, c2 = 0 === t3.rank || t3.rank > 1 || 1 === e2.rank ? 1 : k(e2.shape.slice(1)), l2 = 0; l2 < r2.length; l2++) for (var h2 = 0; h2 < c2; h2++) 1 === r2[l2] ? s2[u3++] = o3[l2] : s2[u3++] = a2[l2];
        return i2;
      }, o2.prototype.where = function(t3) {
        Hh([t3], "where");
        var e2 = this.readSync(t3.dataId);
        return na(t3.shape, e2);
      }, o2.prototype.topk = function(t3, e2, n2) {
        return Hh(t3, "topk"), ea(this.readSync(t3.dataId), t3.shape, t3.dtype, e2);
      }, o2.prototype.min = function(t3, e2) {
        Hh(t3, "min"), Cn("min", e2, t3.rank);
        for (var n2 = bn(t3.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Gn(r2, t3.dtype), i2 = k(o3), s2 = this.readSync(a2.dataId), u3 = this.readSync(t3.dataId), c2 = 0; c2 < s2.length; ++c2) {
          for (var l2 = c2 * i2, h2 = u3[l2], f2 = 0; f2 < i2; ++f2) {
            var d2 = u3[l2 + f2];
            d2 < h2 && (h2 = d2);
          }
          s2[c2] = h2;
        }
        return a2;
      }, o2.prototype.minimum = function(t3, e2) {
        return Hh([t3, e2], "minimum"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
          return Math.min(t4, e3);
        });
      }, o2.prototype.mod = function(t3, e2) {
        return Hh([t3, e2], "mod"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
          var n2 = t4 % e3;
          return t4 < 0 && e3 < 0 || t4 >= 0 && e3 >= 0 ? n2 : (n2 + e3) % e3;
        });
      }, o2.prototype.max = function(t3, e2) {
        Hh(t3, "max"), Cn("max", e2, t3.rank);
        for (var n2 = bn(t3.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Gn(r2, t3.dtype), i2 = k(o3), s2 = this.readSync(a2.dataId), u3 = this.readSync(t3.dataId), c2 = 0; c2 < s2.length; ++c2) {
          for (var l2 = c2 * i2, h2 = u3[l2], f2 = 0; f2 < i2; ++f2) {
            var d2 = u3[l2 + f2];
            d2 > h2 && (h2 = d2);
          }
          s2[c2] = h2;
        }
        return a2;
      }, o2.prototype.maximum = function(t3, e2) {
        return Hh([t3, e2], "maximum"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
          return Math.max(t4, e3);
        });
      }, o2.prototype.all = function(t3, e2) {
        Hh(t3, "all"), Cn("all", e2, t3.rank);
        for (var n2 = bn(t3.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Gn(r2, t3.dtype), i2 = k(o3), s2 = this.readSync(a2.dataId), u3 = this.readSync(t3.dataId), c2 = 0; c2 < s2.length; ++c2) {
          for (var l2 = c2 * i2, h2 = u3[l2], f2 = 0; f2 < i2; ++f2) {
            var d2 = u3[l2 + f2];
            h2 = h2 && d2;
          }
          s2[c2] = h2;
        }
        return a2;
      }, o2.prototype.any = function(t3, e2) {
        Hh(t3, "any"), Cn("any", e2, t3.rank);
        for (var n2 = bn(t3.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Gn(r2, t3.dtype), i2 = k(o3), s2 = this.readSync(a2.dataId), u3 = this.readSync(t3.dataId), c2 = 0; c2 < s2.length; ++c2) {
          for (var l2 = c2 * i2, h2 = u3[l2], f2 = 0; f2 < i2; ++f2) {
            var d2 = u3[l2 + f2];
            h2 = h2 || d2;
          }
          s2[c2] = h2;
        }
        return a2;
      }, o2.prototype.squaredDifference = function(t3, e2) {
        return Hh([t3, e2], "squaredDifference"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
          var n2 = t4 - e3;
          return n2 * n2;
        });
      }, o2.prototype.ceil = function(t3) {
        Hh(t3, "ceil");
        for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) n2[r2] = Math.ceil(e2[r2]);
        return this.makeOutput(n2, t3.shape, "float32");
      }, o2.prototype.floor = function(t3) {
        Hh(t3, "floor");
        for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) n2[r2] = Math.floor(e2[r2]);
        return this.makeOutput(n2, t3.shape, "float32");
      }, o2.prototype.sign = function(t3) {
        Hh(t3, "x");
        for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) e2[r2] < 0 ? n2[r2] = -1 : e2[r2] > 0 ? n2[r2] = 1 : n2[r2] = 0;
        return this.makeOutput(n2, t3.shape, "float32");
      }, o2.prototype.isNaN = function(t3) {
        Hh(t3, "x");
        for (var e2 = this.readSync(t3.dataId), n2 = new Uint8Array(e2.length), r2 = 0; r2 < e2.length; ++r2) Number.isNaN(e2[r2]) && (n2[r2] = 1);
        return this.makeOutput(n2, t3.shape, "bool");
      }, o2.prototype.isInf = function(t3) {
        Hh(t3, "x");
        for (var e2 = this.readSync(t3.dataId), n2 = new Uint8Array(e2.length), r2 = 0; r2 < e2.length; ++r2) Math.abs(e2[r2]) === 1 / 0 && (n2[r2] = 1);
        return this.makeOutput(n2, t3.shape, "bool");
      }, o2.prototype.isFinite = function(t3) {
        Hh(t3, "x");
        for (var e2 = this.readSync(t3.dataId), n2 = new Uint8Array(e2.length), r2 = 0; r2 < e2.length; ++r2) Number.isFinite(e2[r2]) && (n2[r2] = 1);
        return this.makeOutput(n2, t3.shape, "bool");
      }, o2.prototype.round = function(t3) {
        Hh(t3, "round");
        for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) {
          var o3 = Math.floor(e2[r2]);
          e2[r2] - o3 < 0.5 ? n2[r2] = Math.floor(e2[r2]) : e2[r2] - o3 > 0.5 ? n2[r2] = Math.ceil(e2[r2]) : n2[r2] = o3 % 2 == 0 ? o3 : o3 + 1;
        }
        return this.makeOutput(n2, t3.shape, "float32");
      }, o2.prototype.exp = function(t3) {
        Hh(t3, "exp");
        for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) n2[r2] = Math.exp(e2[r2]);
        return this.makeOutput(n2, t3.shape, "float32");
      }, o2.prototype.expm1 = function(t3) {
        Hh(t3, "expm1");
        for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) n2[r2] = Math.expm1(e2[r2]);
        return this.makeOutput(n2, t3.shape, "float32");
      }, o2.prototype.log = function(t3) {
        Hh(t3, "log");
        for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) {
          var o3 = e2[r2];
          n2[r2] = Math.log(o3);
        }
        return this.makeOutput(n2, t3.shape, "float32");
      }, o2.prototype.log1p = function(t3) {
        Hh(t3, "log1p");
        for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) {
          var o3 = e2[r2];
          n2[r2] = Math.log1p(o3);
        }
        return this.makeOutput(n2, t3.shape, "float32");
      }, o2.prototype.sqrt = function(t3) {
        Hh(t3, "sqrt");
        for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) {
          var o3 = e2[r2];
          n2[r2] = Math.sqrt(o3);
        }
        return this.makeOutput(n2, t3.shape, "float32");
      }, o2.prototype.rsqrt = function(t3) {
        Hh(t3, "rsqrt");
        for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) {
          var o3 = e2[r2];
          n2[r2] = 1 / Math.sqrt(o3);
        }
        return this.makeOutput(n2, t3.shape, "float32");
      }, o2.prototype.reciprocal = function(t3) {
        Hh(t3, "reciprocal");
        for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) n2[r2] = 1 / e2[r2];
        return this.makeOutput(n2, t3.shape, "float32");
      }, o2.prototype.linear = function(t3) {
        return t3;
      }, o2.prototype.relu = function(t3) {
        Hh(t3, "relu");
        for (var e2 = Gn(t3.shape, t3.dtype), n2 = this.readSync(e2.dataId), r2 = this.readSync(t3.dataId), o3 = 0; o3 < r2.length; ++o3) n2[o3] = Math.max(0, r2[o3]);
        return e2;
      }, o2.prototype.relu6 = function(t3) {
        Hh(t3, "relu");
        for (var e2 = Gn(t3.shape, t3.dtype), n2 = this.readSync(e2.dataId), r2 = this.readSync(t3.dataId), o3 = 0; o3 < r2.length; ++o3) n2[o3] = Math.min(Math.max(0, r2[o3]), 6);
        return e2;
      }, o2.prototype.prelu = function(t3, e2) {
        return Hh([t3, e2], "prelu"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
          return t4 < 0 ? e3 * t4 : t4;
        });
      }, o2.prototype.elu = function(t3) {
        Hh(t3, "elu");
        for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) {
          var o3 = n2[r2];
          e2[r2] = o3 >= 0 ? o3 : Math.exp(o3) - 1;
        }
        return this.makeOutput(e2, t3.shape, "float32");
      }, o2.prototype.eluDer = function(t3, e2) {
        Hh([t3, e2], "eluDer");
        for (var n2 = new Float32Array(e2.size), r2 = this.readSync(e2.dataId), o3 = this.readSync(t3.dataId), a2 = 0; a2 < r2.length; ++a2) {
          var i2 = r2[a2];
          n2[a2] = i2 >= 1 ? o3[a2] : o3[a2] * (i2 + 1);
        }
        return this.makeOutput(n2, e2.shape, "float32");
      }, o2.prototype.selu = function(t3) {
        Hh(t3, "selu");
        for (var e2 = bs, n2 = ws, r2 = new Float32Array(t3.size), o3 = this.readSync(t3.dataId), a2 = 0; a2 < o3.length; ++a2) {
          var i2 = o3[a2];
          r2[a2] = i2 >= 0 ? n2 * i2 : e2 * (Math.exp(i2) - 1);
        }
        return this.makeOutput(r2, t3.shape, "float32");
      }, o2.prototype.clip = function(t3, e2, n2) {
        Hh(t3, "clip");
        for (var r2 = new Float32Array(t3.size), o3 = this.readSync(t3.dataId), a2 = 0; a2 < o3.length; ++a2) {
          var i2 = o3[a2];
          r2[a2] = i2 > n2 ? n2 : i2 < e2 ? e2 : i2;
        }
        return this.makeOutput(r2, t3.shape, "float32");
      }, o2.prototype.abs = function(t3) {
        for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) e2[r2] = Math.abs(n2[r2]);
        return this.makeOutput(e2, t3.shape, "float32");
      }, o2.prototype.complexAbs = function(t3) {
        for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < t3.size; ++r2) {
          var o3 = n2[2 * r2], a2 = n2[2 * r2 + 1];
          e2[r2] = Math.hypot(o3, a2);
        }
        return this.makeOutput(e2, t3.shape, "float32");
      }, o2.prototype.int = function(t3) {
        Hh(t3, "int");
        for (var e2 = new Int32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) e2[r2] = n2[r2];
        return this.makeOutput(e2, t3.shape, "int32");
      }, o2.prototype.sigmoid = function(t3) {
        Hh(t3, "sigmoid");
        for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) e2[r2] = 1 / (1 + Math.exp(-n2[r2]));
        return this.makeOutput(e2, t3.shape, "float32");
      }, o2.prototype.softplus = function(t3) {
        Hh(t3, "softplus");
        for (var e2 = Math.log(11920928955078125e-23) + 2, n2 = new Float32Array(t3.size), r2 = this.readSync(t3.dataId), o3 = 0; o3 < r2.length; ++o3) {
          var a2 = r2[o3] > -e2, i2 = r2[o3] < e2, s2 = Math.exp(r2[o3]), u3 = void 0;
          u3 = i2 ? s2 : a2 ? r2[o3] : Math.log(1 + s2), n2[o3] = u3;
        }
        return this.makeOutput(n2, t3.shape, "float32");
      }, o2.prototype.sin = function(t3) {
        Hh(t3, "sin");
        for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) e2[r2] = Math.sin(n2[r2]);
        return this.makeOutput(e2, t3.shape, "float32");
      }, o2.prototype.cos = function(t3) {
        Hh(t3, "cos");
        for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) e2[r2] = Math.cos(n2[r2]);
        return this.makeOutput(e2, t3.shape, "float32");
      }, o2.prototype.tan = function(t3) {
        Hh(t3, "tan");
        for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) e2[r2] = Math.tan(n2[r2]);
        return this.makeOutput(e2, t3.shape, "float32");
      }, o2.prototype.asin = function(t3) {
        Hh(t3, "asin");
        for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) e2[r2] = Math.asin(n2[r2]);
        return this.makeOutput(e2, t3.shape, "float32");
      }, o2.prototype.acos = function(t3) {
        Hh(t3, "acos");
        for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) e2[r2] = Math.acos(n2[r2]);
        return this.makeOutput(e2, t3.shape, "float32");
      }, o2.prototype.atan = function(t3) {
        Hh(t3, "atan");
        for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) e2[r2] = Math.atan(n2[r2]);
        return this.makeOutput(e2, t3.shape, "float32");
      }, o2.prototype.atan2 = function(t3, e2) {
        return Hh([t3, e2], "atan2"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
          return Math.atan2(t4, e3);
        });
      }, o2.prototype.sinh = function(t3) {
        Hh(t3, "sinh");
        for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) e2[r2] = Math.sinh(n2[r2]);
        return this.makeOutput(e2, t3.shape, "float32");
      }, o2.prototype.cosh = function(t3) {
        Hh(t3, "cosh");
        for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) e2[r2] = Math.cosh(n2[r2]);
        return this.makeOutput(e2, t3.shape, "float32");
      }, o2.prototype.tanh = function(t3) {
        Hh(t3, "tanh");
        for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) e2[r2] = D(n2[r2]);
        return this.makeOutput(e2, t3.shape, "float32");
      }, o2.prototype.asinh = function(t3) {
        Hh(t3, "asinh");
        for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) e2[r2] = Math.asinh(n2[r2]);
        return this.makeOutput(e2, t3.shape, "float32");
      }, o2.prototype.acosh = function(t3) {
        Hh(t3, "acosh");
        for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) e2[r2] = Math.acosh(n2[r2]);
        return this.makeOutput(e2, t3.shape, "float32");
      }, o2.prototype.atanh = function(t3) {
        Hh(t3, "atanh");
        for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) e2[r2] = Math.atanh(n2[r2]);
        return this.makeOutput(e2, t3.shape, "float32");
      }, o2.prototype.erf = function(t3) {
        Hh(t3, "erf");
        for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) {
          var o3 = Math.sign(n2[r2]), a2 = Math.abs(n2[r2]), i2 = 1 / (1 + 0.3275911 * a2);
          e2[r2] = o3 * (1 - ((((1.061405429 * i2 - 1.453152027) * i2 + 1.421413741) * i2 - 0.284496736) * i2 + 0.254829592) * i2 * Math.exp(-a2 * a2));
        }
        return this.makeOutput(e2, t3.shape, "float32");
      }, o2.prototype.step = function(t3, e2) {
        void 0 === e2 && (e2 = 0), Hh(t3, "step");
        for (var n2 = new Float32Array(t3.size), r2 = this.readSync(t3.dataId), o3 = 0; o3 < r2.length; ++o3) {
          var a2 = r2[o3];
          isNaN(a2) ? n2[o3] = NaN : n2[o3] = a2 > 0 ? 1 : e2;
        }
        return this.makeOutput(n2, t3.shape, "float32");
      }, o2.prototype.fusedConv2d = function(t3) {
        var e2 = t3.input, n2 = t3.filter, r2 = t3.convInfo, o3 = t3.bias, a2 = t3.activation, i2 = t3.preluActivationWeights, s2 = this.conv2d(e2, n2, r2);
        return o3 && (s2 = this.add(s2, o3)), a2 && (s2 = qh(this, s2, a2, i2)), s2;
      }, o2.prototype.conv2d = function(t3, e2, n2) {
        Hh([t3, e2], "conv2d");
        for (var r2 = n2.filterHeight, o3 = n2.filterWidth, a2 = n2.dilationHeight, i2 = n2.dilationWidth, s2 = n2.padInfo.left, u3 = n2.padInfo.top, c2 = "channelsLast" === n2.dataFormat, l2 = dr(n2.outShape, t3.dtype), h2 = t3.strides[0], f2 = c2 ? t3.strides[1] : t3.strides[2], d2 = c2 ? t3.strides[2] : 1, p2 = c2 ? 1 : t3.strides[1], v = l2.strides[0], m = c2 ? l2.strides[1] : l2.strides[2], g2 = c2 ? l2.strides[2] : 1, y2 = c2 ? 1 : l2.strides[1], x2 = this.readSync(t3.dataId), b2 = this.readSync(e2.dataId), w2 = l2.values, C2 = 0; C2 < n2.batchSize; ++C2) for (var E2 = C2 * h2, R2 = C2 * v, I2 = 0; I2 < n2.outHeight; ++I2) for (var k2 = R2 + I2 * m, S2 = I2 * n2.strideHeight - u3, A2 = 0; A2 < r2; A2++) {
          var D2 = S2 + A2 * a2;
          if (!(D2 < 0 || D2 >= n2.inHeight)) for (var T2 = A2 * e2.strides[0], N2 = E2 + D2 * f2, F2 = 0; F2 < n2.outWidth; ++F2) for (var _2 = k2 + F2 * g2, O2 = F2 * n2.strideWidth - s2, M2 = 0; M2 < o3; M2++) {
            var B2 = O2 + M2 * i2;
            if (!(B2 < 0 || B2 >= n2.inWidth)) for (var P2 = N2 + B2 * d2, L2 = T2 + M2 * e2.strides[1], W2 = 0; W2 < n2.inChannels; ++W2) {
              for (var U2 = x2[P2 + W2 * p2], V2 = 0; V2 < n2.outChannels; ++V2) w2[_2 + V2 * y2] += U2 * b2[L2 + V2];
              L2 += n2.outChannels;
            }
          }
        }
        return l2.toTensor();
      }, o2.prototype.conv3d = function(t3, e2, n2) {
        for (var r2 = n2.filterDepth, o3 = n2.filterHeight, a2 = n2.filterWidth, i2 = n2.dilationDepth, s2 = n2.dilationHeight, u3 = n2.dilationWidth, c2 = n2.padInfo.front, l2 = n2.padInfo.left, h2 = n2.padInfo.top, f2 = dr(n2.outShape, t3.dtype), d2 = this.readSync(t3.dataId), p2 = this.readSync(e2.dataId), v = f2.values, m = 0; m < n2.batchSize; ++m) for (var g2 = m * t3.strides[0], y2 = m * f2.strides[0], x2 = 0; x2 < n2.outDepth; ++x2) for (var b2 = y2 + x2 * f2.strides[1], w2 = x2 * n2.strideDepth - c2, C2 = 0; C2 < r2; C2++) {
          var E2 = w2 + C2 * i2;
          if (!(E2 < 0 || E2 >= n2.inDepth)) for (var R2 = C2 * e2.strides[0], I2 = g2 + E2 * t3.strides[1], k2 = 0; k2 < n2.outHeight; ++k2) for (var S2 = b2 + k2 * f2.strides[2], A2 = k2 * n2.strideHeight - h2, D2 = 0; D2 < o3; D2++) {
            var T2 = A2 + D2 * s2;
            if (!(T2 < 0 || T2 >= n2.inHeight)) for (var N2 = R2 + D2 * e2.strides[1], F2 = I2 + T2 * t3.strides[2], _2 = 0; _2 < n2.outWidth; ++_2) for (var O2 = S2 + _2 * n2.outChannels, M2 = _2 * n2.strideWidth - l2, B2 = 0; B2 < a2; B2++) {
              var P2 = M2 + B2 * u3;
              if (!(P2 < 0 || P2 >= n2.inWidth)) for (var L2 = N2 + B2 * e2.strides[2], W2 = F2 + P2 * n2.inChannels, U2 = L2, V2 = 0; V2 < n2.inChannels; ++V2) {
                for (var z2 = d2[W2 + V2], G2 = 0; G2 < n2.outChannels; ++G2) v[O2 + G2] += z2 * p2[U2 + G2];
                U2 += n2.outChannels;
              }
            }
          }
        }
        return f2.toTensor();
      }, o2.prototype.conv2dDerInput = function(t3, e2, n2) {
        Hh([t3, e2], "conv2dDerInput");
        for (var r2 = dr(n2.inShape, "float32"), o3 = r2.values, a2 = this.readSync(t3.dataId), i2 = this.readSync(e2.dataId), s2 = e2.strides, u3 = s2[0], c2 = s2[1], l2 = s2[2], h2 = n2.batchSize, f2 = n2.filterHeight, d2 = n2.filterWidth, p2 = n2.inChannels, v = n2.inHeight, m = n2.inWidth, g2 = n2.outChannels, y2 = n2.outHeight, x2 = n2.outWidth, b2 = n2.strideHeight, w2 = n2.strideWidth, C2 = n2.dataFormat, E2 = f2 - 1 - n2.padInfo.top, R2 = d2 - 1 - n2.padInfo.left, I2 = "channelsLast" === C2, k2 = r2.strides[0], S2 = I2 ? r2.strides[1] : r2.strides[2], A2 = I2 ? r2.strides[2] : 1, D2 = I2 ? 1 : r2.strides[1], T2 = t3.strides[0], N2 = I2 ? t3.strides[1] : t3.strides[2], F2 = I2 ? t3.strides[2] : 1, _2 = I2 ? 1 : t3.strides[1], O2 = 0; O2 < h2; ++O2) for (var M2 = 0; M2 < p2; ++M2) for (var B2 = 0; B2 < v; ++B2) for (var P2 = B2 - E2, L2 = Math.max(0, Math.ceil(P2 / b2)), W2 = Math.min(y2, (f2 + P2) / b2), U2 = 0; U2 < m; ++U2) {
          for (var V2 = U2 - R2, z2 = Math.max(0, Math.ceil(V2 / w2)), G2 = Math.min(x2, (d2 + V2) / w2), H2 = 0, q2 = L2; q2 < W2; ++q2) for (var K2 = q2 * b2 - P2, j2 = z2; j2 < G2; ++j2) for (var X2 = T2 * O2 + N2 * q2 + F2 * j2, Y2 = u3 * (f2 - 1 - K2) + c2 * (d2 - 1 - (j2 * w2 - V2)) + l2 * M2, $2 = 0; $2 < g2; ++$2) {
            H2 += a2[X2 + _2 * $2] * i2[Y2 + $2];
          }
          o3[k2 * O2 + S2 * B2 + A2 * U2 + D2 * M2] = H2;
        }
        return r2.toTensor();
      }, o2.prototype.conv3dDerInput = function(t3, e2, n2) {
        for (var r2 = dr(n2.inShape, "float32"), o3 = r2.values, a2 = r2.strides, i2 = a2[0], s2 = a2[1], u3 = a2[2], c2 = a2[3], l2 = this.readSync(t3.dataId), h2 = t3.strides, f2 = h2[0], d2 = h2[1], p2 = h2[2], v = h2[3], m = this.readSync(e2.dataId), g2 = e2.strides, y2 = g2[0], x2 = g2[1], b2 = g2[2], w2 = g2[3], C2 = n2.batchSize, E2 = n2.filterDepth, R2 = n2.filterHeight, I2 = n2.filterWidth, k2 = n2.inChannels, S2 = n2.inDepth, A2 = n2.inHeight, D2 = n2.inWidth, T2 = n2.outChannels, N2 = n2.outDepth, F2 = n2.outHeight, _2 = n2.outWidth, O2 = n2.strideDepth, M2 = n2.strideHeight, B2 = n2.strideWidth, P2 = E2 - 1 - n2.padInfo.front, L2 = R2 - 1 - n2.padInfo.top, W2 = I2 - 1 - n2.padInfo.left, U2 = 0; U2 < C2; ++U2) for (var V2 = 0; V2 < k2; ++V2) for (var z2 = 0; z2 < S2; ++z2) for (var G2 = z2 - P2, H2 = Math.max(0, Math.ceil(G2 / O2)), q2 = Math.min(N2, (E2 + G2) / O2), K2 = 0; K2 < A2; ++K2) for (var j2 = K2 - L2, X2 = Math.max(0, Math.ceil(j2 / M2)), Y2 = Math.min(F2, (R2 + j2) / M2), $2 = 0; $2 < D2; ++$2) {
          for (var Q2 = $2 - W2, J2 = Math.max(0, Math.ceil(Q2 / B2)), Z2 = Math.min(_2, (I2 + Q2) / B2), tt2 = 0, et2 = H2; et2 < q2; ++et2) for (var nt2 = et2 * O2 - G2, rt2 = X2; rt2 < Y2; ++rt2) for (var ot2 = rt2 * M2 - j2, at2 = J2; at2 < Z2; ++at2) for (var it2 = f2 * U2 + d2 * et2 + p2 * rt2 + v * at2, st2 = y2 * (E2 - 1 - nt2) + x2 * (R2 - 1 - ot2) + b2 * (I2 - 1 - (at2 * B2 - Q2)) + w2 * V2, ut2 = 0; ut2 < T2; ++ut2) {
            tt2 += l2[it2 + ut2] * m[st2 + ut2];
          }
          o3[i2 * U2 + s2 * z2 + u3 * K2 + c2 * $2 + V2] = tt2;
        }
        return r2.toTensor();
      }, o2.prototype.conv2dDerFilter = function(t3, e2, n2) {
        Hh([t3, e2], "conv2dDerFilter");
        for (var r2 = n2.strideHeight, o3 = n2.strideWidth, a2 = n2.filterHeight, i2 = n2.filterWidth, s2 = "channelsLast" === n2.dataFormat, u3 = dr(n2.filterShape, "float32"), c2 = n2.padInfo.left, l2 = n2.padInfo.top, h2 = this.bufferSync(t3), f2 = this.bufferSync(e2), d2 = 0; d2 < a2; ++d2) for (var p2 = Math.max(0, Math.ceil((l2 - d2) / r2)), v = Math.min(n2.outHeight, (n2.inHeight + l2 - d2) / r2), m = 0; m < i2; ++m) for (var g2 = Math.max(0, Math.ceil((c2 - m) / o3)), y2 = Math.min(n2.outWidth, (n2.inWidth + c2 - m) / o3), x2 = 0; x2 < n2.inChannels; ++x2) for (var b2 = 0; b2 < n2.outChannels; ++b2) {
          for (var w2 = 0, C2 = 0; C2 < n2.batchSize; ++C2) for (var E2 = p2; E2 < v; ++E2) for (var R2 = d2 + E2 * r2 - l2, I2 = g2; I2 < y2; ++I2) {
            var k2 = m + I2 * o3 - c2;
            w2 += s2 ? h2.get(C2, R2, k2, x2) * f2.get(C2, E2, I2, b2) : h2.get(C2, x2, R2, k2) * f2.get(C2, b2, E2, I2);
          }
          u3.set(w2, d2, m, x2, b2);
        }
        return u3.toTensor();
      }, o2.prototype.conv3dDerFilter = function(t3, e2, n2) {
        for (var r2 = n2.strideDepth, o3 = n2.strideHeight, a2 = n2.strideWidth, i2 = n2.filterDepth, s2 = n2.filterHeight, u3 = n2.filterWidth, c2 = dr(n2.filterShape, "float32"), l2 = c2.values, h2 = c2.strides, f2 = h2[0], d2 = h2[1], p2 = h2[2], v = h2[3], m = this.readSync(e2.dataId), g2 = e2.strides, y2 = g2[0], x2 = g2[1], b2 = g2[2], w2 = g2[3], C2 = this.readSync(t3.dataId), E2 = t3.strides, R2 = E2[0], I2 = E2[1], k2 = E2[2], S2 = E2[3], A2 = n2.padInfo.front, D2 = n2.padInfo.left, T2 = n2.padInfo.top, N2 = 0; N2 < i2; ++N2) for (var F2 = Math.max(0, Math.ceil((A2 - N2) / r2)), _2 = Math.min(n2.outDepth, (n2.inDepth + A2 - N2) / r2), O2 = N2 * f2, M2 = 0; M2 < s2; ++M2) for (var B2 = Math.max(0, Math.ceil((T2 - M2) / o3)), P2 = Math.min(n2.outHeight, (n2.inHeight + T2 - M2) / o3), L2 = M2 * d2 + O2, W2 = 0; W2 < u3; ++W2) for (var U2 = Math.max(0, Math.ceil((D2 - W2) / a2)), V2 = Math.min(n2.outWidth, (n2.inWidth + D2 - W2) / a2), z2 = W2 * p2 + L2, G2 = 0; G2 < n2.inChannels; ++G2) for (var H2 = G2 * v + z2, q2 = 0; q2 < n2.outChannels; ++q2) {
          for (var K2 = 0, j2 = 0; j2 < n2.batchSize; ++j2) for (var X2 = j2 * R2, Y2 = j2 * y2, $2 = F2; $2 < _2; ++$2) for (var Q2 = (N2 + $2 * r2 - A2) * I2 + X2, J2 = $2 * x2 + Y2, Z2 = B2; Z2 < P2; ++Z2) for (var tt2 = (M2 + Z2 * o3 - T2) * k2 + Q2, et2 = Z2 * b2 + J2, nt2 = U2; nt2 < V2; ++nt2) {
            var rt2 = nt2 * w2 + et2;
            K2 += C2[(W2 + nt2 * a2 - D2) * S2 + tt2 + G2] * m[rt2 + q2];
          }
          l2[H2 + q2] = K2;
        }
        return c2.toTensor();
      }, o2.prototype.fusedDepthwiseConv2D = function(t3) {
        var e2 = t3.input, n2 = t3.filter, r2 = t3.convInfo, o3 = t3.bias, a2 = t3.activation, i2 = t3.preluActivationWeights, s2 = this.depthwiseConv2D(e2, n2, r2);
        return o3 && (s2 = this.add(s2, o3)), a2 && (s2 = qh(this, s2, a2, i2)), s2;
      }, o2.prototype.depthwiseConv2D = function(t3, e2, n2) {
        Hh([t3, e2], "depthwiseConv2D");
        for (var r2 = n2.filterHeight, o3 = n2.filterWidth, a2 = n2.dilationHeight, i2 = n2.dilationWidth, s2 = n2.padInfo.left, u3 = n2.padInfo.top, c2 = n2.outChannels / n2.inChannels, l2 = dr(n2.outShape, t3.dtype), h2 = this.readSync(t3.dataId), f2 = this.readSync(e2.dataId), d2 = l2.values, p2 = 0; p2 < n2.batchSize; ++p2) for (var v = p2 * t3.strides[0], m = p2 * l2.strides[0], g2 = 0; g2 < n2.outHeight; ++g2) for (var y2 = m + g2 * l2.strides[1], x2 = g2 * n2.strideHeight - s2, b2 = 0; b2 < r2; ++b2) {
          var w2 = x2 + b2 * a2;
          if (!(w2 < 0 || w2 >= n2.inHeight)) for (var C2 = b2 * e2.strides[0], E2 = v + w2 * t3.strides[1], R2 = 0; R2 < n2.outWidth; ++R2) for (var I2 = y2 + R2 * l2.strides[2], k2 = R2 * n2.strideWidth - u3, S2 = 0; S2 < o3; ++S2) {
            var A2 = k2 + S2 * i2;
            if (!(A2 < 0 || A2 >= n2.inWidth)) for (var D2 = C2 + S2 * e2.strides[1], T2 = E2 + A2 * n2.inChannels, N2 = I2, F2 = D2, _2 = 0; _2 < n2.inChannels; ++_2) {
              for (var O2 = h2[T2 + _2], M2 = 0; M2 < c2; ++M2) d2[N2 + M2] += O2 * f2[F2 + M2];
              N2 += c2, F2 += c2;
            }
          }
        }
        return l2.toTensor();
      }, o2.prototype.depthwiseConv2DDerInput = function(t3, e2, n2) {
        Hh([t3, e2], "depthwiseConv2DDerInput");
        for (var r2 = dr(n2.inShape, "float32"), o3 = r2.values, a2 = r2.strides, i2 = a2[0], s2 = a2[1], u3 = a2[2], c2 = this.readSync(t3.dataId), l2 = t3.strides, h2 = l2[0], f2 = l2[1], d2 = l2[2], p2 = this.readSync(e2.dataId), v = e2.strides, m = v[0], g2 = v[1], y2 = v[2], x2 = n2.batchSize, b2 = n2.filterHeight, w2 = n2.filterWidth, C2 = n2.inChannels, E2 = n2.inHeight, R2 = n2.inWidth, I2 = n2.outChannels, k2 = n2.outHeight, S2 = n2.outWidth, A2 = n2.strideHeight, D2 = n2.strideWidth, T2 = b2 - 1 - n2.padInfo.top, N2 = w2 - 1 - n2.padInfo.left, F2 = I2 / C2, _2 = 0; _2 < x2; ++_2) for (var O2 = 0; O2 < C2; ++O2) for (var M2 = 0; M2 < E2; ++M2) for (var B2 = M2 - T2, P2 = Math.max(0, Math.ceil(B2 / A2)), L2 = Math.min(k2, (b2 + B2) / A2), W2 = 0; W2 < R2; ++W2) {
          for (var U2 = W2 - N2, V2 = Math.max(0, Math.ceil(U2 / D2)), z2 = Math.min(S2, (w2 + U2) / D2), G2 = 0, H2 = P2; H2 < L2; ++H2) for (var q2 = H2 * A2 - B2, K2 = V2; K2 < z2; ++K2) for (var j2 = h2 * _2 + f2 * H2 + d2 * K2, X2 = m * (b2 - 1 - q2) + g2 * (w2 - 1 - (K2 * D2 - U2)) + y2 * O2, Y2 = 0; Y2 < F2; ++Y2) {
            G2 += c2[j2 + (O2 * F2 + Y2)] * p2[X2 + Y2];
          }
          o3[i2 * _2 + s2 * M2 + u3 * W2 + O2] = G2;
        }
        return r2.toTensor();
      }, o2.prototype.depthwiseConv2DDerFilter = function(t3, e2, n2) {
        Hh([t3, e2], "depthwiseConv2DDerFilter");
        for (var r2 = n2.strideHeight, o3 = n2.strideWidth, a2 = n2.filterHeight, i2 = n2.filterWidth, s2 = dr(n2.filterShape, "float32"), u3 = n2.padInfo.left, c2 = n2.padInfo.top, l2 = n2.outChannels / n2.inChannels, h2 = this.bufferSync(t3), f2 = this.bufferSync(e2), d2 = 0; d2 < a2; ++d2) for (var p2 = Math.max(0, Math.ceil((c2 - d2) / r2)), v = Math.min(n2.outHeight, (n2.inHeight + c2 - d2) / r2), m = 0; m < i2; ++m) for (var g2 = Math.max(0, Math.ceil((u3 - m) / o3)), y2 = Math.min(n2.outWidth, (n2.inWidth + u3 - m) / o3), x2 = 0; x2 < n2.outChannels; ++x2) {
          for (var b2 = Math.trunc(x2 / l2), w2 = x2 % l2, C2 = 0, E2 = 0; E2 < n2.batchSize; ++E2) for (var R2 = p2; R2 < v; ++R2) for (var I2 = d2 + R2 * r2 - c2, k2 = g2; k2 < y2; ++k2) {
            var S2 = m + k2 * o3 - u3;
            C2 += h2.get(E2, I2, S2, b2) * f2.get(E2, R2, k2, x2);
          }
          s2.set(C2, d2, m, b2, w2);
        }
        return s2.toTensor();
      }, o2.prototype.tile = function(t3, e2) {
        return Hh(t3, "tile"), ta(this.bufferSync(t3), e2);
      }, o2.prototype.pad = function(t3, e2, n2) {
        Hh(t3, "pad");
        var r2 = e2.map(function(e3, n3) {
          return e3[0] + t3.shape[n3] + e3[1];
        }), o3 = e2.map(function(t4) {
          return t4[0];
        }), a2 = this.bufferSync(t3), i2 = dr(r2, t3.dtype);
        0 !== n2 && i2.values.fill(n2);
        for (var s2 = 0; s2 < t3.size; s2++) {
          var u3 = a2.indexToLoc(s2), c2 = u3.map(function(t4, e3) {
            return t4 + o3[e3];
          });
          i2.set.apply(i2, [a2.get.apply(a2, u3)].concat(c2));
        }
        return i2.toTensor();
      }, o2.prototype.transpose = function(t3, e2) {
        Hh(t3, "transpose");
        for (var n2 = new Array(t3.rank), r2 = 0; r2 < n2.length; r2++) n2[r2] = t3.shape[e2[r2]];
        var o3 = this.readSync(t3.dataId), a2 = dr(n2, t3.dtype), i2 = this.bufferSync(t3);
        for (r2 = 0; r2 < t3.size; ++r2) {
          for (var s2 = i2.indexToLoc(r2), u3 = new Array(s2.length), c2 = 0; c2 < u3.length; c2++) u3[c2] = s2[e2[c2]];
          var l2 = a2.locToIndex(u3);
          a2.values[l2] = o3[r2];
        }
        return a2.toTensor();
      }, o2.prototype.gather = function(t3, e2, n2) {
        Hh([t3, e2], "gather");
        var r2 = t3.shape.slice(), o3 = this.readSync(e2.dataId);
        r2[n2] = o3.length;
        for (var a2 = dr(r2, t3.dtype), i2 = this.bufferSync(t3), s2 = 0; s2 < a2.size; ++s2) {
          var u3 = a2.indexToLoc(s2), c2 = u3.slice();
          c2[n2] = o3[u3[n2]];
          var l2 = i2.locToIndex(c2);
          a2.values[s2] = i2.values[l2];
        }
        return a2.toTensor();
      }, o2.prototype.batchToSpaceND = function(t3, e2, n2) {
        Hh([t3], "batchToSpaceND");
        var r2 = e2.reduce(function(t4, e3) {
          return t4 * e3;
        }), o3 = zr(t3.shape, e2, r2), a2 = Gr(o3.length, e2.length), i2 = Hr(t3.shape, e2, r2), s2 = qr(n2, e2.length), u3 = Kr(i2, n2, e2.length);
        return t3.reshape(o3).transpose(a2).reshape(i2).slice(s2, u3);
      }, o2.prototype.spaceToBatchND = function(t3, e2, n2) {
        Hh([t3], "spaceToBatchND");
        var r2 = e2.reduce(function(t4, e3) {
          return t4 * e3;
        }), o3 = [[0, 0]];
        o3.push.apply(o3, n2);
        for (var a2 = 1 + e2.length; a2 < t3.shape.length; ++a2) o3.push([0, 0]);
        var i2 = t3.pad(o3), s2 = zr(i2.shape, e2, r2, false), u3 = Gr(s2.length, e2.length, false), c2 = Hr(i2.shape, e2, r2, false);
        return i2.reshape(s2).transpose(u3).reshape(c2);
      }, o2.prototype.pool = function(t3, e2, n2) {
        Hh(t3, "pool");
        for (var r2 = e2.strideHeight, o3 = e2.strideWidth, a2 = e2.dilationHeight, i2 = e2.dilationWidth, s2 = e2.effectiveFilterHeight, u3 = e2.effectiveFilterWidth, c2 = e2.padInfo.top, l2 = e2.padInfo.left, h2 = "max" === n2 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, f2 = this.readSync(t3.dataId), d2 = dr(e2.outShape, t3.dtype), p2 = d2.values, v = e2.outShape[1] * e2.outShape[2] * e2.outShape[3], m = e2.outShape[2] * e2.outShape[3], g2 = e2.outShape[3], y2 = 0; y2 < e2.batchSize; ++y2) for (var x2 = y2 * v, b2 = y2 * t3.strides[0], w2 = 0; w2 < e2.inChannels; ++w2) for (var C2 = 0; C2 < e2.outHeight; ++C2) for (var E2 = C2 * r2 - c2, R2 = Math.max(0, E2), I2 = Math.min(e2.inHeight, s2 + E2), k2 = x2 + C2 * m, S2 = 0; S2 < e2.outWidth; ++S2) {
          for (var A2 = S2 * o3 - l2, D2 = Math.max(0, A2), T2 = Math.min(e2.inWidth, u3 + A2), N2 = h2, F2 = 0, _2 = 0, O2 = R2; O2 < I2; O2 += a2) {
            for (var M2 = b2 + O2 * t3.strides[1], B2 = D2; B2 < T2; B2 += i2) {
              var P2 = f2[M2 + B2 * t3.strides[2] + w2];
              "max" === n2 && P2 > N2 ? N2 = P2 : "avg" === n2 && (F2 += P2, _2++);
            }
            if (isNaN(N2)) break;
          }
          p2[k2 + S2 * g2 + w2] = "avg" === n2 ? F2 / _2 : N2;
        }
        return d2.toTensor();
      }, o2.prototype.maxPool = function(t3, e2) {
        return this.pool(t3, e2, "max");
      }, o2.prototype.maxPoolPositions = function(t3, e2) {
        for (var n2 = dr(e2.outShape, "int32"), r2 = e2.strideHeight, o3 = e2.strideWidth, a2 = e2.dilationHeight, i2 = e2.dilationWidth, s2 = e2.effectiveFilterHeight, u3 = e2.effectiveFilterWidth, c2 = e2.padInfo.top, l2 = e2.padInfo.left, h2 = this.bufferSync(t3), f2 = 0; f2 < e2.batchSize; ++f2) for (var d2 = 0; d2 < e2.inChannels; ++d2) for (var p2 = 0; p2 < e2.outHeight; ++p2) {
          for (var v = p2 * r2 - c2, m = v; m < 0; ) m += a2;
          for (var g2 = Math.min(e2.inHeight, s2 + v), y2 = 0; y2 < e2.outWidth; ++y2) {
            for (var x2 = y2 * o3 - l2, b2 = x2; b2 < 0; ) b2 += i2;
            for (var w2 = Math.min(e2.inWidth, u3 + x2), C2 = Number.NEGATIVE_INFINITY, E2 = -1, R2 = m; R2 < g2; R2 += a2) for (var I2 = R2 - v, k2 = b2; k2 < w2; k2 += i2) {
              var S2 = k2 - x2, A2 = h2.get(f2, R2, k2, d2);
              A2 > C2 && (C2 = A2, E2 = I2 * u3 + S2);
            }
            n2.set(E2, f2, p2, y2, d2);
          }
        }
        return n2.toTensor();
      }, o2.prototype.maxPoolBackprop = function(t3, e2, n2, r2) {
        Hh([e2, n2], "maxPoolBackprop");
        for (var o3 = this.maxPoolPositions(e2, r2), a2 = r2.strideHeight, i2 = r2.strideWidth, s2 = r2.dilationHeight, u3 = r2.dilationWidth, c2 = r2.effectiveFilterHeight, l2 = r2.effectiveFilterWidth, h2 = l2 - 1 - r2.padInfo.left, f2 = c2 - 1 - r2.padInfo.top, d2 = dr(e2.shape, "float32"), p2 = this.bufferSync(o3), v = this.bufferSync(t3), m = 0; m < r2.batchSize; ++m) for (var g2 = 0; g2 < r2.inChannels; ++g2) for (var y2 = 0; y2 < r2.inHeight; ++y2) for (var x2 = 0; x2 < r2.inWidth; ++x2) {
          for (var b2 = y2 - f2, w2 = x2 - h2, C2 = 0, E2 = 0; E2 < c2; E2 += s2) {
            var R2 = (b2 + E2) / a2;
            if (!(R2 < 0 || R2 >= r2.outHeight || Math.floor(R2) !== R2)) for (var I2 = 0; I2 < l2; I2 += u3) {
              var k2 = (w2 + I2) / i2;
              if (!(k2 < 0 || k2 >= r2.outWidth || Math.floor(k2) !== k2)) {
                var S2 = c2 * l2 - 1 - p2.get(m, R2, k2, g2) === E2 * l2 + I2 ? 1 : 0;
                if (0 !== S2) C2 += v.get(m, R2, k2, g2) * S2;
              }
            }
          }
          d2.set(C2, m, y2, x2, g2);
        }
        return d2.toTensor();
      }, o2.prototype.avgPoolBackprop = function(t3, e2, n2) {
        Hh([t3, e2], "avgPoolBackprop");
        for (var r2 = n2.strideHeight, o3 = n2.strideWidth, a2 = n2.filterHeight, i2 = n2.filterWidth, s2 = n2.dilationHeight, u3 = n2.dilationWidth, c2 = n2.effectiveFilterHeight, l2 = n2.effectiveFilterWidth, h2 = l2 - 1 - n2.padInfo.left, f2 = c2 - 1 - n2.padInfo.top, d2 = dr(e2.shape, "float32"), p2 = 1 / (a2 * i2), v = this.bufferSync(t3), m = 0; m < n2.batchSize; ++m) for (var g2 = 0; g2 < n2.inChannels; ++g2) for (var y2 = 0; y2 < n2.inHeight; ++y2) for (var x2 = 0; x2 < n2.inWidth; ++x2) {
          for (var b2 = y2 - f2, w2 = x2 - h2, C2 = 0, E2 = 0; E2 < c2; E2 += s2) {
            var R2 = (b2 + E2) / r2;
            if (!(R2 < 0 || R2 >= n2.outHeight || Math.floor(R2) !== R2)) for (var I2 = 0; I2 < l2; I2 += u3) {
              var k2 = (w2 + I2) / o3;
              if (!(k2 < 0 || k2 >= n2.outWidth || Math.floor(k2) !== k2)) C2 += v.get(m, R2, k2, g2);
            }
          }
          d2.set(C2 * p2, m, y2, x2, g2);
        }
        return d2.toTensor();
      }, o2.prototype.pool3d = function(t3, e2, n2) {
        Hh(t3, "pool3d");
        for (var r2 = e2.strideDepth, o3 = e2.strideHeight, a2 = e2.strideWidth, i2 = e2.dilationDepth, s2 = e2.dilationHeight, u3 = e2.dilationWidth, c2 = e2.effectiveFilterDepth, l2 = e2.effectiveFilterHeight, h2 = e2.effectiveFilterWidth, f2 = e2.padInfo.front, d2 = e2.padInfo.top, p2 = e2.padInfo.left, v = "max" === n2 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, m = this.readSync(t3.dataId), g2 = dr(e2.outShape, t3.dtype), y2 = g2.values, x2 = e2.outShape[1] * e2.outShape[2] * e2.outShape[3] * e2.outShape[4], b2 = e2.outShape[2] * e2.outShape[3] * e2.outShape[4], w2 = e2.outShape[3] * e2.outShape[4], C2 = e2.outShape[4], E2 = 0; E2 < e2.batchSize; ++E2) for (var R2 = E2 * x2, I2 = E2 * t3.strides[0], k2 = 0; k2 < e2.inChannels; ++k2) for (var S2 = 0; S2 < e2.outDepth; ++S2) {
          for (var A2 = S2 * r2 - f2, D2 = A2; D2 < 0; ) D2 += i2;
          for (var T2 = Math.min(e2.inDepth, c2 + A2), N2 = R2 + S2 * b2, F2 = 0; F2 < e2.outHeight; ++F2) {
            for (var _2 = F2 * o3 - d2, O2 = _2; O2 < 0; ) O2 += s2;
            for (var M2 = Math.min(e2.inHeight, l2 + _2), B2 = N2 + F2 * w2, P2 = 0; P2 < e2.outWidth; ++P2) {
              for (var L2 = P2 * a2 - p2, W2 = L2; W2 < 0; ) W2 += u3;
              for (var U2 = Math.min(e2.inWidth, h2 + L2), V2 = B2 + P2 * C2, z2 = v, G2 = 0, H2 = 0, q2 = D2; q2 < T2; q2 += i2) {
                for (var K2 = I2 + q2 * t3.strides[1], j2 = O2; j2 < M2; j2 += s2) {
                  for (var X2 = K2 + j2 * t3.strides[2], Y2 = W2; Y2 < U2; Y2 += u3) {
                    var $2 = m[X2 + Y2 * t3.strides[3] + k2];
                    if ("max" === n2 && $2 > z2 ? z2 = $2 : "avg" === n2 && (G2 += $2, H2++), isNaN(z2)) break;
                  }
                  if (isNaN(z2)) break;
                }
                if (isNaN(z2)) break;
              }
              y2[V2 + k2] = "avg" === n2 ? G2 / H2 : z2;
            }
          }
        }
        return g2.toTensor();
      }, o2.prototype.avgPool3d = function(t3, e2) {
        return Hh(t3, "avgPool3d"), this.pool3d(t3, e2, "avg").toFloat();
      }, o2.prototype.avgPool3dBackprop = function(t3, e2, n2) {
        Hh([t3, e2], "avgPool3dBackprop");
        for (var r2 = n2.strideDepth, o3 = n2.strideHeight, a2 = n2.strideWidth, i2 = n2.filterDepth, s2 = n2.filterHeight, u3 = n2.filterWidth, c2 = n2.dilationDepth, l2 = n2.dilationHeight, h2 = n2.dilationWidth, f2 = n2.effectiveFilterDepth, d2 = n2.effectiveFilterHeight, p2 = n2.effectiveFilterWidth, v = f2 - 1 - n2.padInfo.front, m = p2 - 1 - n2.padInfo.left, g2 = d2 - 1 - n2.padInfo.top, y2 = dr(e2.shape, "float32"), x2 = 1 / (i2 * s2 * u3), b2 = this.bufferSync(t3), w2 = 0; w2 < n2.batchSize; ++w2) for (var C2 = 0; C2 < n2.inChannels; ++C2) for (var E2 = 0; E2 < n2.inDepth; ++E2) for (var R2 = 0; R2 < n2.inHeight; ++R2) for (var I2 = 0; I2 < n2.inWidth; ++I2) {
          for (var k2 = E2 - v, S2 = R2 - g2, A2 = I2 - m, D2 = 0, T2 = 0; T2 < f2; T2 += c2) {
            var N2 = (k2 + T2) / r2;
            if (!(N2 < 0 || N2 >= n2.outDepth || Math.floor(N2) !== N2)) for (var F2 = 0; F2 < d2; F2 += l2) {
              var _2 = (S2 + F2) / o3;
              if (!(_2 < 0 || _2 >= n2.outHeight || Math.floor(_2) !== _2)) for (var O2 = 0; O2 < p2; O2 += h2) {
                var M2 = (A2 + O2) / a2;
                if (!(M2 < 0 || M2 >= n2.outWidth || Math.floor(M2) !== M2)) D2 += b2.get(w2, N2, _2, M2, C2);
              }
            }
          }
          y2.set(D2 * x2, w2, E2, R2, I2, C2);
        }
        return y2.toTensor();
      }, o2.prototype.maxPool3d = function(t3, e2) {
        return Hh(t3, "maxPool3d"), this.pool3d(t3, e2, "max").toFloat();
      }, o2.prototype.maxPool3dPositions = function(t3, e2) {
        for (var n2 = dr(e2.outShape, "int32"), r2 = e2.strideDepth, o3 = e2.strideHeight, a2 = e2.strideWidth, i2 = e2.dilationDepth, s2 = e2.dilationHeight, u3 = e2.dilationWidth, c2 = e2.effectiveFilterDepth, l2 = e2.effectiveFilterHeight, h2 = e2.effectiveFilterWidth, f2 = e2.padInfo.front, d2 = e2.padInfo.top, p2 = e2.padInfo.left, v = this.bufferSync(t3), m = 0; m < e2.batchSize; ++m) for (var g2 = 0; g2 < e2.inChannels; ++g2) for (var y2 = 0; y2 < e2.outDepth; ++y2) {
          for (var x2 = y2 * r2 - f2, b2 = x2; b2 < 0; ) b2 += i2;
          for (var w2 = Math.min(e2.inDepth, c2 + x2), C2 = 0; C2 < e2.outHeight; ++C2) {
            for (var E2 = C2 * o3 - d2, R2 = E2; R2 < 0; ) R2 += s2;
            for (var I2 = Math.min(e2.inHeight, l2 + E2), k2 = 0; k2 < e2.outWidth; ++k2) {
              for (var S2 = k2 * a2 - p2, A2 = S2; A2 < 0; ) A2 += u3;
              for (var D2 = Math.min(e2.inWidth, h2 + S2), T2 = Number.NEGATIVE_INFINITY, N2 = -1, F2 = b2; F2 < w2; F2 += i2) for (var _2 = F2 - x2, O2 = R2; O2 < I2; O2 += s2) for (var M2 = O2 - E2, B2 = A2; B2 < D2; B2 += u3) {
                var P2 = B2 - S2, L2 = v.get(m, F2, O2, B2, g2);
                L2 >= T2 && (T2 = L2, N2 = _2 * l2 * h2 + M2 * l2 + P2);
              }
              n2.set(N2, m, y2, C2, k2, g2);
            }
          }
        }
        return n2.toTensor();
      }, o2.prototype.maxPool3dBackprop = function(t3, e2, n2, r2) {
        Hh([e2, n2], "maxPool3dBackprop");
        for (var o3 = this.maxPool3dPositions(e2, r2), a2 = r2.strideDepth, i2 = r2.strideHeight, s2 = r2.strideWidth, u3 = r2.dilationDepth, c2 = r2.dilationHeight, l2 = r2.dilationWidth, h2 = r2.effectiveFilterDepth, f2 = r2.effectiveFilterHeight, d2 = r2.effectiveFilterWidth, p2 = h2 - 1 - r2.padInfo.front, v = d2 - 1 - r2.padInfo.left, m = f2 - 1 - r2.padInfo.top, g2 = dr(e2.shape, "float32"), y2 = this.bufferSync(o3), x2 = this.bufferSync(t3), b2 = 0; b2 < r2.batchSize; ++b2) for (var w2 = 0; w2 < r2.inChannels; ++w2) for (var C2 = 0; C2 < r2.inDepth; ++C2) for (var E2 = 0; E2 < r2.inHeight; ++E2) for (var R2 = 0; R2 < r2.inWidth; ++R2) {
          for (var I2 = C2 - p2, k2 = E2 - m, S2 = R2 - v, A2 = 0, D2 = 0; D2 < h2; D2 += u3) {
            var T2 = (I2 + D2) / a2;
            if (!(T2 < 0 || T2 >= r2.outDepth || Math.floor(T2) !== T2)) for (var N2 = 0; N2 < f2; N2 += c2) {
              var F2 = (k2 + N2) / i2;
              if (!(F2 < 0 || F2 >= r2.outHeight || Math.floor(F2) !== F2)) for (var _2 = 0; _2 < d2; _2 += l2) {
                var O2 = (S2 + _2) / s2;
                if (!(O2 < 0 || O2 >= r2.outWidth || Math.floor(O2) !== O2)) {
                  var M2 = h2 * f2 * d2 - 1 - y2.get(b2, T2, F2, O2, w2) === D2 * f2 * d2 + N2 * d2 + _2 ? 1 : 0;
                  if (0 !== M2) A2 += x2.get(b2, T2, F2, O2, w2) * M2;
                }
              }
            }
          }
          g2.set(A2, b2, C2, E2, R2, w2);
        }
        return g2.toTensor();
      }, o2.prototype.cast = function(t3, e2) {
        return Po(t3, e2, this);
      }, o2.prototype.reshape = function(t3, e2) {
        return Lo(t3, e2);
      }, o2.prototype.avgPool = function(t3, e2) {
        return Hh(t3, "avgPool"), this.pool(t3, e2, "avg").toFloat();
      }, o2.prototype.resizeBilinear = function(t3, e2, n2, r2) {
        Hh(t3, "resizeBilinear");
        for (var o3 = t3.shape, a2 = o3[0], i2 = o3[1], s2 = o3[2], u3 = o3[3], c2 = this.readSync(t3.dataId), l2 = new Float32Array(k([a2, e2, n2, u3])), h2 = [r2 && e2 > 1 ? i2 - 1 : i2, r2 && n2 > 1 ? s2 - 1 : s2], f2 = [r2 && e2 > 1 ? e2 - 1 : e2, r2 && n2 > 1 ? n2 - 1 : n2], d2 = 0, p2 = h2[0] / f2[0], v = h2[1] / f2[1], m = 0; m < a2; m++) for (var g2 = 0; g2 < e2; g2++) for (var y2 = p2 * g2, x2 = Math.floor(y2), b2 = y2 - x2, w2 = Math.min(i2 - 1, Math.ceil(y2)), C2 = m * t3.strides[0] + x2 * t3.strides[1], E2 = m * t3.strides[0] + w2 * t3.strides[1], R2 = 0; R2 < n2; R2++) for (var I2 = v * R2, S2 = Math.floor(I2), A2 = I2 - S2, D2 = Math.min(s2 - 1, Math.ceil(I2)), T2 = C2 + S2 * t3.strides[2], N2 = E2 + S2 * t3.strides[2], F2 = C2 + D2 * t3.strides[2], _2 = E2 + D2 * t3.strides[2], O2 = 0; O2 < u3; O2++) {
          var M2 = c2[T2 + O2], B2 = c2[N2 + O2], P2 = M2 + (c2[F2 + O2] - M2) * A2, L2 = P2 + (B2 + (c2[_2 + O2] - B2) * A2 - P2) * b2;
          l2[d2++] = L2;
        }
        return Fn(l2, [a2, e2, n2, u3]);
      }, o2.prototype.resizeBilinearBackprop = function(t3, e2, n2) {
        Hh([t3, e2], "resizeBilinearBackprop");
        for (var r2 = e2.shape, o3 = r2[0], a2 = r2[1], i2 = r2[2], s2 = r2[3], u3 = t3.shape, c2 = u3[1], l2 = u3[2], h2 = new Float32Array(o3 * a2 * i2 * s2), f2 = [n2 && c2 > 1 ? a2 - 1 : a2, n2 && l2 > 1 ? i2 - 1 : i2], d2 = [n2 && c2 > 1 ? c2 - 1 : c2, n2 && l2 > 1 ? l2 - 1 : l2], p2 = f2[0] / d2[0], v = f2[1] / d2[1], m = this.readSync(t3.dataId), g2 = 0, y2 = 0; y2 < o3; y2++) for (var x2 = y2 * e2.strides[0], b2 = 0; b2 < c2; b2++) for (var w2 = b2 * p2, C2 = Math.floor(w2), E2 = Math.min(Math.ceil(w2), a2 - 1), R2 = x2 + C2 * e2.strides[1], I2 = x2 + E2 * e2.strides[1], k2 = w2 - C2, S2 = 1 - k2, A2 = 0; A2 < l2; A2++) for (var D2 = A2 * v, T2 = Math.floor(D2), N2 = Math.min(Math.ceil(D2), i2 - 1), F2 = D2 - T2, _2 = 1 - F2, O2 = R2 + T2 * e2.strides[2], M2 = R2 + N2 * e2.strides[2], B2 = I2 + T2 * e2.strides[2], P2 = I2 + N2 * e2.strides[2], L2 = S2 * _2, W2 = S2 * F2, U2 = k2 * _2, V2 = k2 * F2, z2 = 0; z2 < s2; z2++) {
          var G2 = m[g2++];
          h2[O2 + z2] += G2 * L2, h2[M2 + z2] += G2 * W2, h2[B2 + z2] += G2 * U2, h2[P2 + z2] += G2 * V2;
        }
        return Ln(h2, [o3, i2, a2, s2], e2.dtype);
      }, o2.prototype.resizeNearestNeighbor = function(t3, e2, n2, r2) {
        Hh(t3, "resizeNearestNeighbor");
        for (var o3 = t3.shape, a2 = o3[0], i2 = o3[1], s2 = o3[2], u3 = o3[3], c2 = this.readSync(t3.dataId), l2 = new Float32Array(a2 * e2 * n2 * u3), h2 = [r2 && e2 > 1 ? i2 - 1 : i2, r2 && n2 > 1 ? s2 - 1 : s2], f2 = [r2 && e2 > 1 ? e2 - 1 : e2, r2 && n2 > 1 ? n2 - 1 : n2], d2 = h2[0] / f2[0], p2 = h2[1] / f2[1], v = 0, m = 0; m < a2; m++) for (var g2 = m * t3.strides[0], y2 = 0; y2 < e2; y2++) for (var x2 = d2 * y2, b2 = g2 + Math.min(i2 - 1, r2 ? Math.round(x2) : Math.floor(x2)) * t3.strides[1], w2 = 0; w2 < n2; w2++) for (var C2 = p2 * w2, E2 = b2 + Math.min(s2 - 1, r2 ? Math.round(C2) : Math.floor(C2)) * t3.strides[2], R2 = 0; R2 < u3; R2++) {
          var I2 = c2[E2 + R2];
          l2[v++] = I2;
        }
        return Fn(l2, [a2, e2, n2, u3], t3.dtype);
      }, o2.prototype.resizeNearestNeighborBackprop = function(t3, e2, n2) {
        Hh([t3, e2], "resizeNearestNeighborBackprop");
        for (var r2 = e2.shape, o3 = r2[0], a2 = r2[1], i2 = r2[2], s2 = r2[3], u3 = t3.shape, c2 = u3[1], l2 = u3[2], h2 = new Float32Array(o3 * a2 * i2 * s2), f2 = this.readSync(t3.dataId), d2 = [n2 && c2 > 1 ? a2 - 1 : a2, n2 && l2 > 1 ? i2 - 1 : i2], p2 = [n2 && c2 > 1 ? c2 - 1 : c2, n2 && l2 > 1 ? l2 - 1 : l2], v = d2[0] / p2[0], m = d2[1] / p2[1], g2 = 1 / v, y2 = 1 / m, x2 = 2 * Math.ceil(g2) + 2, b2 = 2 * Math.ceil(y2) + 2, w2 = 0; w2 < o3; w2++) for (var C2 = w2 * e2.strides[0], E2 = 0; E2 < a2; E2++) for (var R2 = C2 + E2 * e2.strides[1], I2 = Math.floor(E2 * g2), k2 = Math.floor(I2 - x2 / 2), S2 = 0; S2 < i2; S2++) for (var A2 = R2 + S2 * e2.strides[2], D2 = Math.floor(S2 * y2), T2 = Math.floor(D2 - b2 / 2), N2 = 0; N2 < s2; N2++) {
          for (var F2 = 0, _2 = 0; _2 < x2; _2++) {
            var O2 = _2 + k2;
            if (!(O2 < 0 || O2 >= c2)) {
              var M2 = C2 + O2 * t3.strides[1], B2 = O2 * v;
              if (E2 === Math.min(a2 - 1, n2 ? Math.round(B2) : Math.floor(B2))) for (var P2 = 0; P2 < b2; P2++) {
                var L2 = P2 + T2;
                if (!(L2 < 0 || L2 >= l2)) {
                  var W2 = M2 + L2 * t3.strides[2], U2 = L2 * m;
                  S2 === Math.min(i2 - 1, n2 ? Math.round(U2) : Math.floor(U2)) && (F2 += f2[W2 + N2]);
                }
              }
            }
          }
          h2[A2 + N2] = F2;
        }
        return Ln(h2, e2.shape, e2.dtype);
      }, o2.prototype.batchNormalization = function(t3, e2, n2, r2, o3, a2) {
        Hh([t3, e2, n2, o3, a2], "batchNorm");
        for (var i2 = this.readSync(t3.dataId), s2 = this.readSync(e2.dataId), u3 = this.readSync(n2.dataId), c2 = o3 ? this.readSync(o3.dataId) : new Float32Array([1]), l2 = a2 ? this.readSync(a2.dataId) : new Float32Array([0]), h2 = new Float32Array(i2.length), f2 = l2.length, d2 = c2.length, p2 = u3.length, v = s2.length, m = 0, g2 = 0, y2 = 0, x2 = 0, b2 = 0; b2 < i2.length; ++b2) h2[b2] = l2[m++] + (i2[b2] - s2[g2++]) * c2[y2++] / Math.sqrt(u3[x2++] + r2), m >= f2 && (m = 0), g2 >= v && (g2 = 0), y2 >= d2 && (y2 = 0), x2 >= p2 && (x2 = 0);
        return Ln(h2, t3.shape);
      }, o2.prototype.localResponseNormalization4D = function(t3, e2, n2, r2, o3) {
        Hh(t3, "localResponseNormalization4D");
        var a2 = t3.shape[3], i2 = a2 - 1, s2 = this.readSync(t3.dataId), u3 = t3.size, c2 = new Float32Array(u3);
        function l2(t4) {
          for (var n3 = t4 % a2, r3 = t4 - n3 + Math.max(0, n3 - e2), o4 = t4 - n3 + Math.min(n3 + e2, i2), u4 = 0; r3 <= o4; r3++) {
            var c3 = s2[r3];
            u4 += c3 * c3;
          }
          return u4;
        }
        for (var h2 = 0; h2 < u3; h2++) {
          var f2 = l2(h2), d2 = s2[h2] * Math.pow(n2 + r2 * f2, -o3);
          c2[h2] = d2;
        }
        return Ln(c2, t3.shape);
      }, o2.prototype.LRNGrad = function(t3, e2, n2, r2, o3, a2, i2) {
        Hh(t3, "LRNGrad");
        for (var s2 = t3.shape[3], u3 = this.readSync(t3.dataId), c2 = this.readSync(e2.dataId), l2 = this.readSync(n2.dataId), h2 = new Float32Array(t3.size), f2 = t3.size, d2 = 0; d2 < f2; d2++) {
          for (var p2 = d2 % s2, v = d2 - p2 + Math.max(0, p2 - r2), m = d2 - p2 + Math.min(s2, p2 + r2 + 1), g2 = 0, y2 = v; y2 < m; y2++) g2 += Math.pow(c2[y2], 2);
          g2 = a2 * g2 + o3;
          for (y2 = v; y2 < m; y2++) {
            var x2 = -2 * a2 * i2 * c2[y2] * l2[d2] / g2;
            d2 === y2 && (x2 += Math.pow(g2, -i2)), x2 *= u3[d2], h2[y2] += x2;
          }
        }
        return Ln(h2, t3.shape);
      }, o2.prototype.multinomial = function(t3, e2, n2, r2) {
        Hh(t3, "multinomial");
        for (var o3 = e2 ? t3 : go(t3), a2 = o3.shape[0], i2 = o3.shape[1], s2 = Gn([a2, n2], "int32"), u3 = this.readSync(s2.dataId), c2 = this.readSync(o3.dataId), l2 = 0; l2 < a2; ++l2) {
          var h2 = l2 * i2, f2 = new Float32Array(i2 - 1);
          f2[0] = c2[h2];
          for (var d2 = 1; d2 < f2.length; ++d2) f2[d2] = f2[d2 - 1] + c2[h2 + d2];
          for (var p2 = cr(r2.toString()), v = l2 * n2, m = 0; m < n2; ++m) {
            var g2 = p2();
            u3[v + m] = f2.length;
            for (var y2 = 0; y2 < f2.length; y2++) if (g2 < f2[y2]) {
              u3[v + m] = y2;
              break;
            }
          }
        }
        return s2;
      }, o2.prototype.oneHot = function(t3, e2, n2, r2) {
        Hh(t3, "oneHot");
        var o3 = new Float32Array(t3.size * e2);
        o3.fill(r2);
        for (var a2 = this.readSync(t3.dataId), i2 = 0; i2 < t3.size; ++i2) a2[i2] >= 0 && a2[i2] < e2 && (o3[i2 * e2 + a2[i2]] = n2);
        return Bn(o3, [t3.size, e2], "int32");
      }, o2.prototype.nonMaxSuppression = function(t3, e2, n2, r2, o3) {
        return Hh(t3, "nonMaxSuppression"), jo(this.readSync(t3.dataId), this.readSync(e2.dataId), n2, r2, o3);
      }, o2.prototype.fft = function(t3) {
        return this.fftBatch(t3, false);
      }, o2.prototype.ifft = function(t3) {
        return this.fftBatch(t3, true);
      }, o2.prototype.fftBatch = function(t3, e2) {
        for (var n2 = t3.shape[0], r2 = t3.shape[1], o3 = dr(t3.shape, "float32"), a2 = dr(t3.shape, "float32"), i2 = Tn(t3).as2D(n2, r2), s2 = Nn(t3).as2D(n2, r2), u3 = 0; u3 < n2; u3++) for (var c2 = i2.slice([u3, 0], [1, r2]), l2 = s2.slice([u3, 0], [1, r2]), h2 = Dn(c2, l2), f2 = this.readSync(this.fftImpl(h2, e2).dataId), d2 = 0; d2 < r2; d2++) {
          var p2 = zo(f2, d2);
          o3.values[u3 * r2 + d2] = p2.real, a2.values[u3 * r2 + d2] = p2.imag;
        }
        return Dn(o3.toTensor(), a2.toTensor()).as2D(n2, r2);
      }, o2.prototype.fftImpl = function(t3, e2) {
        var n2 = t3.as1D(), r2 = n2.size;
        if (this.isExponentOf2(r2)) {
          var o3 = this.fftRadix2(n2, r2, e2).as2D(t3.shape[0], t3.shape[1]);
          return e2 && (o3 = Dn(Tn(o3).div(On(r2)), Nn(o3).div(On(r2)))), o3;
        }
        var a2 = this.readSync(t3.dataId), i2 = function(t4) {
          for (var e3 = new Float32Array(t4.length / 2), n3 = new Float32Array(t4.length / 2), r3 = 0; r3 < t4.length; r3 += 2) e3[r3 / 2] = t4[r3], n3[r3 / 2] = t4[r3 + 1];
          return { real: e3, imag: n3 };
        }(this.fourierTransformByMatmul(a2, r2, e2));
        return Dn(i2.real, i2.imag).as2D(t3.shape[0], t3.shape[1]);
      }, o2.prototype.isExponentOf2 = function(t3) {
        return 0 == (t3 & t3 - 1);
      }, o2.prototype.fftRadix2 = function(t3, e2, n2) {
        if (1 === e2) return t3;
        var r2 = this.readSync(t3.dataId), o3 = e2 / 2, a2 = function(t4) {
          for (var e3 = Math.ceil(t4.length / 4), n3 = new Float32Array(e3), r3 = new Float32Array(e3), o4 = 0; o4 < t4.length; o4 += 4) n3[Math.floor(o4 / 4)] = t4[o4], r3[Math.floor(o4 / 4)] = t4[o4 + 1];
          return { real: n3, imag: r3 };
        }(r2), i2 = Dn(a2.real, a2.imag).as1D(), s2 = function(t4) {
          for (var e3 = Math.floor(t4.length / 4), n3 = new Float32Array(e3), r3 = new Float32Array(e3), o4 = 2; o4 < t4.length; o4 += 4) n3[Math.floor(o4 / 4)] = t4[o4], r3[Math.floor(o4 / 4)] = t4[o4 + 1];
          return { real: n3, imag: r3 };
        }(r2), u3 = Dn(s2.real, s2.imag).as1D();
        i2 = this.fftRadix2(i2, o3, n2), u3 = this.fftRadix2(u3, o3, n2);
        var c2 = function(t4, e3) {
          for (var n3 = new Float32Array(t4 / 2), r3 = new Float32Array(t4 / 2), o4 = 0; o4 < Math.ceil(t4 / 2); o4++) {
            var a3 = (e3 ? 2 : -2) * Math.PI * (o4 / t4);
            n3[o4] = Math.cos(a3), r3[o4] = Math.sin(a3);
          }
          return { real: n3, imag: r3 };
        }(e2, n2), l2 = Dn(c2.real, c2.imag).mul(u3), h2 = i2.add(l2), f2 = i2.sub(l2), d2 = Tn(h2).concat(Tn(f2)), p2 = Nn(h2).concat(Nn(f2));
        return Dn(d2, p2).as1D();
      }, o2.prototype.fourierTransformByMatmul = function(t3, e2, n2) {
        for (var r2 = new Float32Array(2 * e2), o3 = 0; o3 < e2; o3++) {
          for (var a2 = 0, i2 = 0, s2 = 0; s2 < e2; s2++) {
            var u3 = Ho(o3 * s2, e2, n2), c2 = zo(t3, s2);
            a2 += c2.real * u3.real - c2.imag * u3.imag, i2 += c2.real * u3.imag + c2.imag * u3.real;
          }
          n2 && (a2 /= e2, i2 /= e2), Go(r2, a2, i2, o3);
        }
        return r2;
      }, o2.prototype.depthToSpace = function(t3, e2, n2) {
        C("NHWC" === n2, function() {
          return "Only NHWC dataFormat supported on CPU for depthToSpace. Got " + n2;
        }), C(e2 > 1, function() {
          return "blockSize should be > 1 for depthToSpace, but was: " + e2;
        });
        for (var r2 = t3.shape[0], o3 = t3.shape[1], a2 = t3.shape[2], i2 = t3.shape[3], s2 = o3 * e2, u3 = a2 * e2, c2 = i2 / (e2 * e2), l2 = this.readSync(t3.dataId), h2 = new Float32Array(r2 * s2 * u3 * c2), f2 = 0, d2 = 0; d2 < r2; ++d2) for (var p2 = 0; p2 < s2; ++p2) for (var v = Math.floor(p2 / e2), m = p2 % e2, g2 = 0; g2 < u3; ++g2) for (var y2 = Math.floor(g2 / e2), x2 = (m * e2 + g2 % e2) * c2, b2 = 0; b2 < c2; ++b2) {
          var w2 = b2 + x2 + i2 * (y2 + a2 * (v + o3 * d2));
          h2[f2++] = l2[w2];
        }
        return Ln(h2, [r2, s2, u3, c2]);
      }, o2.prototype.broadcastedBinaryOp = function(t3, e2, n2, r2) {
        var o3 = Ro(t3.shape, e2.shape), a2 = dr(o3, n2), i2 = this.readSync(t3.dataId), s2 = this.readSync(e2.dataId), u3 = Co(t3.shape, o3), c2 = Co(e2.shape, o3), l2 = a2.values;
        if (u3.length + c2.length === 0) for (var h2 = 0; h2 < l2.length; ++h2) l2[h2] = r2(i2[h2 % i2.length], s2[h2 % s2.length]);
        else {
          var f2 = this.bufferSync(t3), d2 = this.bufferSync(e2), p2 = function(n3) {
            var o4 = a2.indexToLoc(n3), h3 = o4.slice(-t3.rank);
            u3.forEach(function(t4) {
              return h3[t4] = 0;
            });
            var p3 = f2.locToIndex(h3), v = o4.slice(-e2.rank);
            c2.forEach(function(t4) {
              return v[t4] = 0;
            });
            var m = d2.locToIndex(v);
            l2[n3] = r2(i2[p3], s2[m]);
          };
          for (h2 = 0; h2 < l2.length; ++h2) p2(h2);
        }
        return a2.toTensor();
      }, o2.prototype.broadcastedBinaryComplexOp = function(t3, e2, n2) {
        var r2 = Ro(t3.shape, e2.shape), o3 = dr(r2, "float32"), a2 = dr(r2, "float32"), i2 = this.readSync(t3.dataId), s2 = this.readSync(e2.dataId), u3 = Co(t3.shape, r2), c2 = Co(e2.shape, r2), l2 = o3.values, h2 = a2.values;
        if (u3.length + c2.length === 0) for (var f2 = 0; f2 < l2.length; f2++) {
          var d2 = f2 % i2.length, p2 = f2 % s2.length, v = n2(i2[2 * d2], i2[2 * d2 + 1], s2[2 * p2], s2[2 * p2 + 1]);
          l2[f2] = v.real, h2[f2] = v.imag;
        }
        else {
          var m = this.bufferSync(this.data.get(t3.dataId).complexTensors.real), g2 = this.bufferSync(this.data.get(e2.dataId).complexTensors.real), y2 = function(r3) {
            var a3 = o3.indexToLoc(r3), f3 = a3.slice(-t3.rank);
            u3.forEach(function(t4) {
              return f3[t4] = 0;
            });
            var d3 = m.locToIndex(f3), p3 = a3.slice(-e2.rank);
            c2.forEach(function(t4) {
              return p3[t4] = 0;
            });
            var v2 = g2.locToIndex(p3), y3 = n2(i2[2 * d3], i2[2 * d3 + 1], s2[2 * v2], s2[2 * v2 + 1]);
            l2[r3] = y3.real, h2[r3] = y3.imag;
          };
          for (f2 = 0; f2 < l2.length; f2++) y2(f2);
        }
        return this.complex(o3.toTensor(), a2.toTensor());
      }, o2.prototype.split = function(t3, e2, n2) {
        return Zo(t3, e2, n2);
      }, o2.prototype.dispose = function() {
      }, o2.prototype.floatPrecision = function() {
        return 32;
      }, o2.prototype.epsilon = function() {
        return 1e-7;
      }, o2.prototype.cropAndResize = function(t3, e2, n2, r2, o3, a2) {
        for (var i2 = t3.shape, s2 = i2[0], u3 = i2[1], c2 = i2[2], l2 = i2[3], h2 = e2.shape[0], f2 = r2[0], d2 = r2[1], p2 = dr([h2, f2, d2, l2], "float32"), v = this.readSync(e2.dataId), m = this.readSync(n2.dataId), g2 = this.readSync(t3.dataId), y2 = t3.strides, x2 = p2.strides, b2 = 0; b2 < h2; b2++) {
          var w2 = 4 * b2, C2 = v[w2], E2 = v[w2 + 1], R2 = v[w2 + 2], I2 = v[w2 + 3], k2 = m[b2];
          if (!(k2 >= s2)) for (var S2 = f2 > 1 ? (R2 - C2) * (u3 - 1) / (f2 - 1) : 0, A2 = d2 > 1 ? (I2 - E2) * (c2 - 1) / (d2 - 1) : 0, D2 = 0; D2 < f2; D2++) {
            var T2 = f2 > 1 ? C2 * (u3 - 1) + D2 * S2 : 0.5 * (C2 + R2) * (u3 - 1);
            if (T2 < 0 || T2 > u3 - 1) for (var N2 = 0; N2 < d2; N2++) for (var F2 = 0; F2 < l2; F2++) {
              var _2 = F2 + N2 * x2[2] + D2 * x2[1] + b2 * x2[0];
              p2.values[_2] = a2;
            }
            else if ("bilinear" === o3) {
              var O2 = Math.floor(T2), M2 = Math.ceil(T2), B2 = T2 - O2;
              for (N2 = 0; N2 < d2; N2++) {
                if ((q2 = d2 > 1 ? E2 * (c2 - 1) + N2 * A2 : 0.5 * (E2 + I2) * (c2 - 1)) < 0 || q2 > c2 - 1) for (F2 = 0; F2 < l2; F2++) {
                  _2 = F2 + N2 * x2[2] + D2 * x2[1] + b2 * x2[0];
                  p2.values[_2] = a2;
                }
                else {
                  var P2 = Math.floor(q2), L2 = Math.ceil(q2), W2 = q2 - P2;
                  for (F2 = 0; F2 < l2; F2++) {
                    var U2 = g2[_2 = F2 + P2 * y2[2] + O2 * y2[1] + k2 * y2[0]], V2 = g2[_2 = F2 + L2 * y2[2] + O2 * y2[1] + k2 * y2[0]], z2 = g2[_2 = F2 + P2 * y2[2] + M2 * y2[1] + k2 * y2[0]], G2 = U2 + (V2 - U2) * W2, H2 = z2 + (g2[_2 = F2 + L2 * y2[2] + M2 * y2[1] + k2 * y2[0]] - z2) * W2;
                    _2 = F2 + N2 * x2[2] + D2 * x2[1] + b2 * x2[0], p2.values[_2] = G2 + (H2 - G2) * B2;
                  }
                }
              }
            } else for (N2 = 0; N2 < d2; ++N2) {
              var q2;
              if ((q2 = d2 > 1 ? E2 * (c2 - 1) + N2 * A2 : 0.5 * (E2 + I2) * (c2 - 1)) < 0 || q2 > c2 - 1) for (F2 = 0; F2 < l2; F2++) {
                _2 = F2 + N2 * x2[2] + D2 * x2[1] + b2 * x2[0];
                p2.values[_2] = a2;
              }
              else {
                var K2 = Math.round(q2), j2 = Math.round(T2);
                for (F2 = 0; F2 < l2; F2++) {
                  var X2 = F2 + K2 * y2[2] + j2 * y2[1] + k2 * y2[0], Y2 = F2 + N2 * x2[2] + D2 * x2[1] + b2 * x2[0];
                  p2.values[Y2] = g2[X2];
                }
              }
            }
          }
        }
        return p2.toTensor();
      }, o2.prototype.sparseToDense = function(t3, e2, n2, r2) {
        var o3 = Zr(0, t3, n2), a2 = o3.sliceRank, i2 = o3.numUpdates, s2 = o3.sliceSize, u3 = o3.strides, c2 = o3.outputSize;
        return this.scatter(t3, e2, n2, c2, s2, i2, a2, u3, r2, false);
      }, o2.prototype.gatherND = function(t3, e2) {
        var n2 = e2.shape, r2 = n2[n2.length - 1], o3 = jr(t3, e2), a2 = o3[0], i2 = o3[1], s2 = o3[2], u3 = o3[3];
        if (0 === i2) return Fn([], a2, t3.dtype);
        for (var c2 = new gt([i2, s2], t3.dtype), l2 = this.readSync(e2.dataId), h2 = this.readSync(t3.dataId), f2 = 0; f2 < i2; f2++) {
          for (var d2 = [], p2 = 0, v = 0; v < r2; v++) {
            var m = l2[f2 * r2 + v];
            p2 += m * u3[v], d2.push(m);
          }
          if (p2 < 0 || p2 >= t3.size / s2) throw new Error("Invalid indices: " + d2 + " does not index into " + t3.shape);
          for (var g2 = 0; g2 < s2; g2++) c2.values[f2 * s2 + g2] = h2[p2 * s2 + g2];
        }
        return c2.toTensor().reshape(a2);
      }, o2.prototype.scatterND = function(t3, e2, n2) {
        var r2 = Zr(0, t3, n2), o3 = r2.sliceRank, a2 = r2.numUpdates, i2 = r2.sliceSize, s2 = r2.strides, u3 = r2.outputSize, c2 = On(0);
        return this.scatter(t3, e2, n2, u3, i2, a2, o3, s2, c2, true);
      }, o2.prototype.fill = function(t3, e2, n2) {
        var r2 = P(n2 = n2 || j(e2), k(t3));
        return r2.fill(e2), Lt.makeTensor(r2, t3, n2, this);
      }, o2.prototype.onesLike = function(t3) {
        if ("string" === t3.dtype) throw new Error("onesLike is not supported for string tensors");
        return this.fill(t3.shape, 1, t3.dtype);
      }, o2.prototype.zerosLike = function(t3) {
        var e2 = P(t3.dtype, k(t3.shape));
        return this.makeOutput(e2, t3.shape, t3.dtype);
      }, o2.prototype.linspace = function(t3, e2, n2) {
        return Wo(t3, e2, n2);
      }, o2.prototype.scatter = function(t3, e2, n2, r2, o3, a2, i2, s2, u3, c2) {
        var l2 = [r2 / o3, o3], h2 = this.readSync(t3.dataId), f2 = this.readSync(e2.dataId);
        if (0 === r2) return Fn([], n2, e2.dtype);
        var d2 = new gt(l2, e2.dtype);
        d2.values.fill(this.readSync(u3.dataId)[0]);
        for (var p2 = 0; p2 < a2; p2++) {
          for (var v = [], m = 0, g2 = 0; g2 < i2; g2++) {
            var y2 = h2[p2 * i2 + g2];
            v.push(y2), m += y2 * s2[g2];
          }
          if (m < 0 || m >= r2 / o3) throw new Error("Invalid indices: " + v + " does not index into " + n2);
          for (var x2 = 0; x2 < o3; x2++) c2 ? d2.values[m * o3 + x2] += f2[p2 * o3 + x2] : d2.values[m * o3 + x2] = 0 === e2.rank ? f2[0] : f2[p2 * o3 + x2];
        }
        return d2.toTensor().reshape(n2);
      }, o2;
    }(bo);
    Lt.registerBackend("cpu", function() {
      return new Kh();
    }, 1);
    for (jh = 0, Xh = [{ kernelName: "NonMaxSuppressionV5", backendName: "cpu", kernelFunc: function(t2) {
      var e2 = t2.inputs, n2 = t2.backend, r2 = t2.attrs, o2 = e2, a2 = o2.boxes, i2 = o2.scores, s2 = r2, u3 = s2.maxOutputSize, c2 = s2.iouThreshold, l2 = s2.scoreThreshold, h2 = s2.softNmsSigma, f2 = n2;
      Hh(a2, "NonMaxSuppressionWithScore");
      var d2 = Xo(f2.data.get(a2.dataId).values, f2.data.get(i2.dataId).values, u3, c2, l2, h2);
      return [d2.selectedIndices, d2.selectedScores];
    } }, { kernelName: "Square", backendName: "cpu", kernelFunc: function(t2) {
      var e2 = t2.inputs, n2 = t2.backend, r2 = e2.x, o2 = n2;
      Hh(r2, "square");
      for (var a2 = o2.data.get(r2.dataId).values, i2 = new Float32Array(a2.length), s2 = 0; s2 < a2.length; ++s2) {
        var u3 = a2[s2];
        i2[s2] = u3 * u3;
      }
      return { dataId: o2.write(i2, r2.shape, r2.dtype), shape: r2.shape, dtype: r2.dtype };
    } }, { kernelName: eu, backendName: "cpu", kernelFunc: function(t2) {
      var e2 = t2.inputs, n2 = t2.backend, r2 = e2, o2 = r2.a, a2 = r2.b, i2 = n2;
      Hh([o2, a2], eu);
      var s2 = i2.data.get(o2.dataId).values, u3 = i2.data.get(a2.dataId).values, c2 = function(t3, e3, n3, r3, o3, a3) {
        var i3 = Ro(t3, e3), s3 = i3.length, u4 = $(i3), c3 = B(o3, k(i3)), l3 = t3.length, h3 = e3.length, f2 = $(t3), d2 = $(e3), p2 = Co(t3, i3), v = Co(e3, i3);
        if (p2.length + v.length === 0) for (var m = 0; m < c3.length; ++m) c3[m] = a3(n3[m % n3.length], r3[m % r3.length]);
        else {
          var g2 = function(t4) {
            var e4 = it(t4, s3, u4), o4 = e4.slice(-l3);
            p2.forEach(function(t5) {
              return o4[t5] = 0;
            });
            var i4 = at(o4, l3, f2), m2 = e4.slice(-h3);
            v.forEach(function(t5) {
              return m2[t5] = 0;
            });
            var g3 = at(m2, h3, d2);
            c3[t4] = a3(n3[i4], r3[g3]);
          };
          for (m = 0; m < c3.length; ++m) g2(m);
        }
        return [c3, i3];
      }(o2.shape, a2.shape, s2, u3, o2.dtype, function(t3, e3) {
        var n3 = t3 - e3;
        return n3 * n3;
      }), l2 = c2[0], h2 = c2[1];
      return { dataId: i2.write(l2, h2, o2.dtype), shape: h2, dtype: o2.dtype };
    } }]; jh < Xh.length; jh++) {
      d(Xh[jh]);
    }
    $h = function(t2) {
      this.variableNames = ["A"];
      var e2 = ua(), n2 = t2[0], r2 = t2[1];
      this.outputShape = t2, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + r2 + ".0, " + n2 + ".0);\n\n        vec4 values = " + e2.texture2D + "(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ";
    };
    Qh = function(t2) {
      this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true;
      var e2 = ua(), n2 = t2[0], r2 = t2[1];
      this.outputShape = t2, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(" + r2 + ".0, " + n2 + ".0);\n            vec4 values = " + e2.texture2D + "(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        " + e2.output + " = result;\n      }\n    ";
    };
    for (Jh = 0, Zh = [{ kernelName: "FromPixels", backendName: "webgl", kernelFunc: function(t2) {
      var e2 = t2.inputs, n2 = t2.backend, r2 = t2.attrs, o2 = e2.pixels, a2 = r2.numChannels, s2 = "undefined" != typeof HTMLVideoElement && o2 instanceof HTMLVideoElement, u3 = "undefined" != typeof HTMLImageElement && o2 instanceof HTMLImageElement, c2 = s2 ? [o2.videoWidth, o2.videoHeight] : [o2.width, o2.height], l2 = c2[0], h2 = c2[1], f2 = [h2, l2], d2 = [h2, l2, a2];
      (u3 || s2) && (null == Yh && (Yh = document.createElement("canvas").getContext("2d")), Yh.canvas.width = l2, Yh.canvas.height = h2, Yh.drawImage(o2, 0, 0, l2, h2), o2 = Yh.canvas);
      var p2 = n2.makeTensorInfo(f2, "int32");
      n2.texData.get(p2.dataId).usage = zt.PIXELS, n2.gpgpu.uploadPixelDataToTexture(n2.getTexture(p2.dataId), o2);
      var v = i().getBool("WEBGL_PACK") ? new Qh(d2) : new $h(d2), m = n2.runWebGLProgram(v, [p2], "int32");
      return n2.disposeData(p2.dataId), m;
    } }, { kernelName: "NonMaxSuppressionV5", backendName: "webgl", kernelFunc: function(t2) {
      var e2 = t2.inputs, n2 = t2.backend, r2 = t2.attrs;
      dn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
      var o2 = e2, a2 = o2.boxes, i2 = o2.scores, s2 = r2, u3 = s2.maxOutputSize, c2 = s2.iouThreshold, l2 = s2.scoreThreshold, h2 = s2.softNmsSigma, f2 = n2, d2 = Xo(f2.readSync(a2.dataId), f2.readSync(i2.dataId), u3, c2, l2, h2);
      return [d2.selectedIndices, d2.selectedScores];
    } }, { kernelName: "Square", backendName: "webgl", kernelFunc: function(t2) {
      var e2 = t2.inputs, n2 = t2.backend, r2 = e2.x, o2 = n2, a2 = new Cs(r2.shape, "return x * x;");
      return o2.runWebGLProgram(a2, [r2], r2.dtype);
    } }, { kernelName: eu, backendName: "webgl", kernelFunc: function(t2) {
      var e2 = t2.inputs, n2 = t2.backend, r2 = e2, o2 = r2.a, a2 = r2.b, s2 = n2, u3 = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new La("return (a - b) * (a - b);", o2.shape, a2.shape) : new Ba("return (a - b) * (a - b);", o2.shape, a2.shape);
      return s2.compileAndRun(u3, [o2, a2]);
    } }]; Jh < Zh.length; Jh++) {
      d(Zh[Jh]);
    }
    for (tf = 0, ef = [{ kernelName: "Square", gradFunc: function(t2, e2) {
      var n2 = e2[0];
      return { x: function() {
        return t2.mul(n2.toFloat().mul(2));
      } };
    } }, { kernelName: eu, gradFunc: function(t2, e2) {
      var n2 = e2[0], r2 = e2[1], o2 = On(2);
      return { a: function() {
        return gc(t2, gc(o2, Cc(n2, r2)));
      }, b: function() {
        return gc(t2, gc(o2, Cc(r2, n2)));
      } };
    } }]; tf < ef.length; tf++) {
      p(ef[tf]);
    }
    nf = function() {
      function t2() {
      }
      return t2.prototype.fetch = function(t3, e2) {
        return fetch(t3, e2);
      }, t2.prototype.now = function() {
        return performance.now();
      }, t2.prototype.encode = function(t3, e2) {
        if ("utf-8" !== e2 && "utf8" !== e2) throw new Error("Browser's encoder only supports utf-8, but got " + e2);
        return null == this.textEncoder && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(t3);
      }, t2.prototype.decode = function(t3, e2) {
        return new TextDecoder(e2).decode(t3);
      }, t2;
    }();
    i().get("IS_BROWSER") && i().setPlatform("browser", new nf());
    of2 = function() {
      return require_browser();
    };
    af = function() {
      function t2() {
        this.util = require_util(), this.textEncoder = new this.util.TextEncoder();
      }
      return t2.prototype.fetch = function(t3, e2) {
        return null != i().global.fetch ? i().global.fetch(t3, e2) : (null == rf && (rf = of2()), rf(t3, e2));
      }, t2.prototype.now = function() {
        var t3 = process.hrtime();
        return 1e3 * t3[0] + t3[1] / 1e6;
      }, t2.prototype.encode = function(t3, e2) {
        if ("utf-8" !== e2 && "utf8" !== e2) throw new Error("Node built-in encoder only supports utf-8, but got " + e2);
        return this.textEncoder.encode(t3);
      }, t2.prototype.decode = function(t3, e2) {
        return 0 === t3.length ? "" : new this.util.TextDecoder(e2).decode(t3);
      }, t2;
    }();
    i().get("IS_NODE") && i().setPlatform("node", new af());
    sf = { float32: 4, int32: 4, uint16: 2, uint8: 1, bool: 1 };
    uf = 4;
    hf = "undefined" != typeof Buffer && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);
    mf = function() {
      function t2() {
        this.saveRouters = [], this.loadRouters = [];
      }
      return t2.getInstance = function() {
        return null == t2.instance && (t2.instance = new t2()), t2.instance;
      }, t2.registerSaveRouter = function(e2) {
        t2.getInstance().saveRouters.push(e2);
      }, t2.registerLoadRouter = function(e2) {
        t2.getInstance().loadRouters.push(e2);
      }, t2.getSaveHandlers = function(e2) {
        return t2.getHandlers(e2, "save");
      }, t2.getLoadHandlers = function(e2, n2) {
        return t2.getHandlers(e2, "load", n2);
      }, t2.getHandlers = function(e2, n2, r2) {
        var o2 = [];
        return ("load" === n2 ? t2.getInstance().loadRouters : t2.getInstance().saveRouters).forEach(function(t3) {
          var n3 = t3(e2, r2);
          null !== n3 && o2.push(n3);
        }), o2;
      }, t2;
    }();
    gf = "://";
    yf = function() {
      function t2() {
        this.managers = {};
      }
      return t2.getInstance = function() {
        return null == t2.instance && (t2.instance = new t2()), t2.instance;
      }, t2.registerManager = function(e2, n2) {
        C(null != e2, function() {
          return "scheme must not be undefined or null.";
        }), e2.endsWith(gf) && (e2 = e2.slice(0, e2.indexOf(gf))), C(e2.length > 0, function() {
          return "scheme must not be an empty string.";
        });
        var r2 = t2.getInstance();
        C(null == r2.managers[e2], function() {
          return "A model store manager is already registered for scheme '" + e2 + "'.";
        }), r2.managers[e2] = n2;
      }, t2.getManager = function(t3) {
        var e2 = this.getInstance().managers[t3];
        if (null == e2) throw new Error("Cannot find model manager for scheme '" + t3 + "'");
        return e2;
      }, t2.getSchemes = function() {
        return Object.keys(this.getInstance().managers);
      }, t2;
    }();
    wf = "models_store";
    Cf = "model_info_store";
    If = function() {
      function t2(t3) {
        if (this.indexedDB = Ef(), null == t3 || !t3) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
        this.modelPath = t3;
      }
      return t2.prototype.save = function(t3) {
        return n(this, void 0, void 0, function() {
          return r(this, function(e2) {
            if (t3.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
            return [2, this.databaseAction(this.modelPath, t3)];
          });
        });
      }, t2.prototype.load = function() {
        return n(this, void 0, void 0, function() {
          return r(this, function(t3) {
            return [2, this.databaseAction(this.modelPath)];
          });
        });
      }, t2.prototype.databaseAction = function(t3, e2) {
        var n2 = this;
        return new Promise(function(t4, r2) {
          var o2 = n2.indexedDB.open("tensorflowjs", 1);
          o2.onupgradeneeded = function() {
            return Rf(o2);
          }, o2.onsuccess = function() {
            var a2 = o2.result;
            if (null == e2) {
              var i2 = a2.transaction(wf, "readonly"), s2 = i2.objectStore(wf).get(n2.modelPath);
              s2.onsuccess = function() {
                if (null == s2.result) return a2.close(), r2(new Error("Cannot find model with path '" + n2.modelPath + "' in IndexedDB."));
                t4(s2.result.modelArtifacts);
              }, s2.onerror = function(t5) {
                return a2.close(), r2(s2.error);
              }, i2.oncomplete = function() {
                return a2.close();
              };
            } else {
              var u3, c2 = vf(e2), l2 = a2.transaction(Cf, "readwrite"), h2 = l2.objectStore(Cf), f2 = h2.put({ modelPath: n2.modelPath, modelArtifactsInfo: c2 });
              f2.onsuccess = function() {
                var o3 = (u3 = a2.transaction(wf, "readwrite")).objectStore(wf).put({ modelPath: n2.modelPath, modelArtifacts: e2, modelArtifactsInfo: c2 });
                o3.onsuccess = function() {
                  return t4({ modelArtifactsInfo: c2 });
                }, o3.onerror = function(t5) {
                  var e3 = (h2 = l2.objectStore(Cf)).delete(n2.modelPath);
                  e3.onsuccess = function() {
                    return a2.close(), r2(o3.error);
                  }, e3.onerror = function(t6) {
                    return a2.close(), r2(o3.error);
                  };
                };
              }, f2.onerror = function(t5) {
                return a2.close(), r2(f2.error);
              }, l2.oncomplete = function() {
                null == u3 ? a2.close() : u3.oncomplete = function() {
                  return a2.close();
                };
              };
            }
          }, o2.onerror = function(t5) {
            return r2(o2.error);
          };
        });
      }, t2.URL_SCHEME = "indexeddb://", t2;
    }();
    kf = function(t2) {
      return i().getBool("IS_BROWSER") && !Array.isArray(t2) && t2.startsWith(If.URL_SCHEME) ? (e2 = t2.slice(If.URL_SCHEME.length), new If(e2)) : null;
      var e2;
    };
    mf.registerSaveRouter(kf), mf.registerLoadRouter(kf);
    Sf = function() {
      function t2() {
        this.indexedDB = Ef();
      }
      return t2.prototype.listModels = function() {
        return n(this, void 0, void 0, function() {
          var t3 = this;
          return r(this, function(e2) {
            return [2, new Promise(function(e3, n2) {
              var r2 = t3.indexedDB.open("tensorflowjs", 1);
              r2.onupgradeneeded = function() {
                return Rf(r2);
              }, r2.onsuccess = function() {
                var t4 = r2.result, o2 = t4.transaction(Cf, "readonly"), a2 = o2.objectStore(Cf).getAll();
                a2.onsuccess = function() {
                  for (var t5 = {}, n3 = 0, r3 = a2.result; n3 < r3.length; n3++) {
                    var o3 = r3[n3];
                    t5[o3.modelPath] = o3.modelArtifactsInfo;
                  }
                  e3(t5);
                }, a2.onerror = function(e4) {
                  return t4.close(), n2(a2.error);
                }, o2.oncomplete = function() {
                  return t4.close();
                };
              }, r2.onerror = function(t4) {
                return n2(r2.error);
              };
            })];
          });
        });
      }, t2.prototype.removeModel = function(t3) {
        return n(this, void 0, void 0, function() {
          var e2 = this;
          return r(this, function(n2) {
            var r2;
            return t3 = (r2 = t3).startsWith(If.URL_SCHEME) ? r2.slice(If.URL_SCHEME.length) : r2, [2, new Promise(function(n3, r3) {
              var o2 = e2.indexedDB.open("tensorflowjs", 1);
              o2.onupgradeneeded = function() {
                return Rf(o2);
              }, o2.onsuccess = function() {
                var e3, a2 = o2.result, i2 = a2.transaction(Cf, "readwrite"), s2 = i2.objectStore(Cf), u3 = s2.get(t3);
                u3.onsuccess = function() {
                  if (null == u3.result) return a2.close(), r3(new Error("Cannot find model with path '" + t3 + "' in IndexedDB."));
                  var o3 = s2.delete(t3), i3 = function() {
                    var o4 = (e3 = a2.transaction(wf, "readwrite")).objectStore(wf).delete(t3);
                    o4.onsuccess = function() {
                      return n3(u3.result.modelArtifactsInfo);
                    }, o4.onerror = function(t4) {
                      return r3(u3.error);
                    };
                  };
                  o3.onsuccess = i3, o3.onerror = function(t4) {
                    return i3(), a2.close(), r3(u3.error);
                  };
                }, u3.onerror = function(t4) {
                  return a2.close(), r3(u3.error);
                }, i2.oncomplete = function() {
                  null == e3 ? a2.close() : e3.oncomplete = function() {
                    return a2.close();
                  };
                };
              }, o2.onerror = function(t4) {
                return r3(o2.error);
              };
            })];
          });
        });
      }, t2;
    }();
    if (i().getBool("IS_BROWSER")) try {
      yf.registerManager(If.URL_SCHEME, new Sf());
    } catch (t2) {
    }
    Af = "/";
    Df = "tensorflowjs_models";
    Tf = "info";
    Nf = "model_topology";
    Ff = "weight_specs";
    _f = "weight_data";
    Of = "model_metadata";
    Pf = function() {
      function t2(t3) {
        if (!i().getBool("IS_BROWSER") || "undefined" == typeof window || void 0 === window.localStorage) throw new Error("The current environment does not support local storage.");
        if (this.LS = window.localStorage, null == t3 || !t3) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
        this.modelPath = t3, this.keys = Mf(this.modelPath);
      }
      return t2.prototype.save = function(t3) {
        return n(this, void 0, void 0, function() {
          var e2, n2, o2;
          return r(this, function(r2) {
            if (t3.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
            e2 = JSON.stringify(t3.modelTopology), n2 = JSON.stringify(t3.weightSpecs), o2 = vf(t3);
            try {
              return this.LS.setItem(this.keys.info, JSON.stringify(o2)), this.LS.setItem(this.keys.topology, e2), this.LS.setItem(this.keys.weightSpecs, n2), this.LS.setItem(this.keys.weightData, function(t4) {
                if (hf) return Buffer.from(t4).toString("base64");
                for (var e3 = new Uint8Array(t4), n3 = "", r3 = 0, o3 = e3.length; r3 < o3; r3++) n3 += String.fromCharCode(e3[r3]);
                return btoa(n3);
              }(t3.weightData)), this.LS.setItem(this.keys.modelMetadata, JSON.stringify({ format: t3.format, generatedBy: t3.generatedBy, convertedBy: t3.convertedBy, userDefinedMetadata: t3.userDefinedMetadata })), [2, { modelArtifactsInfo: o2 }];
            } catch (t4) {
              throw this.LS.removeItem(this.keys.info), this.LS.removeItem(this.keys.topology), this.LS.removeItem(this.keys.weightSpecs), this.LS.removeItem(this.keys.weightData), this.LS.removeItem(this.keys.modelMetadata), new Error("Failed to save model '" + this.modelPath + "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=" + o2.modelTopologyBytes + ", weightSpecsBytes=" + o2.weightSpecsBytes + ", weightDataBytes=" + o2.weightDataBytes + ".");
            }
            return [2];
          });
        });
      }, t2.prototype.load = function() {
        return n(this, void 0, void 0, function() {
          var t3, e2, n2, o2, a2, i2, s2;
          return r(this, function(r2) {
            if (null == (t3 = JSON.parse(this.LS.getItem(this.keys.info)))) throw new Error("In local storage, there is no model with name '" + this.modelPath + "'");
            if ("JSON" !== t3.modelTopologyType) throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
            if (e2 = {}, null == (n2 = JSON.parse(this.LS.getItem(this.keys.topology)))) throw new Error("In local storage, the topology of model '" + this.modelPath + "' is missing.");
            if (e2.modelTopology = n2, null == (o2 = JSON.parse(this.LS.getItem(this.keys.weightSpecs)))) throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' are missing.");
            if (e2.weightSpecs = o2, null != (a2 = this.LS.getItem(this.keys.modelMetadata)) && (i2 = JSON.parse(a2), e2.format = i2.format, e2.generatedBy = i2.generatedBy, e2.convertedBy = i2.convertedBy, e2.userDefinedMetadata = i2.userDefinedMetadata), null == (s2 = this.LS.getItem(this.keys.weightData))) throw new Error("In local storage, the binary weight values of model '" + this.modelPath + "' are missing.");
            return e2.weightData = function(t4) {
              if (hf) {
                var e3 = Buffer.from(t4, "base64");
                return e3.buffer.slice(e3.byteOffset, e3.byteOffset + e3.byteLength);
              }
              for (var n3 = atob(t4), r3 = new Uint8Array(n3.length), o3 = 0; o3 < n3.length; ++o3) r3.set([n3.charCodeAt(o3)], o3);
              return r3.buffer;
            }(s2), [2, e2];
          });
        });
      }, t2.URL_SCHEME = "localstorage://", t2;
    }();
    Lf = function(t2) {
      return i().getBool("IS_BROWSER") && !Array.isArray(t2) && t2.startsWith(Pf.URL_SCHEME) ? (e2 = t2.slice(Pf.URL_SCHEME.length), new Pf(e2)) : null;
      var e2;
    };
    mf.registerSaveRouter(Lf), mf.registerLoadRouter(Lf);
    Wf = function() {
      function t2() {
        C(i().getBool("IS_BROWSER"), function() {
          return "Current environment is not a web browser";
        }), C("undefined" == typeof window || void 0 !== window.localStorage, function() {
          return "Current browser does not appear to support localStorage";
        }), this.LS = window.localStorage;
      }
      return t2.prototype.listModels = function() {
        return n(this, void 0, void 0, function() {
          var t3, e2, n2, o2, a2, i2;
          return r(this, function(r2) {
            for (t3 = {}, e2 = Df + Af, n2 = Af + Tf, o2 = 0; o2 < this.LS.length; ++o2) (a2 = this.LS.key(o2)).startsWith(e2) && a2.endsWith(n2) && (i2 = Bf(a2), t3[i2] = JSON.parse(this.LS.getItem(a2)));
            return [2, t3];
          });
        });
      }, t2.prototype.removeModel = function(t3) {
        return n(this, void 0, void 0, function() {
          var e2, n2;
          return r(this, function(r2) {
            var o2;
            if (t3 = (o2 = t3).startsWith(Pf.URL_SCHEME) ? o2.slice(Pf.URL_SCHEME.length) : o2, e2 = Mf(t3), null == this.LS.getItem(e2.info)) throw new Error("Cannot find model at path '" + t3 + "'");
            return n2 = JSON.parse(this.LS.getItem(e2.info)), this.LS.removeItem(e2.info), this.LS.removeItem(e2.topology), this.LS.removeItem(e2.weightSpecs), this.LS.removeItem(e2.weightData), [2, n2];
          });
        });
      }, t2;
    }();
    if (i().getBool("IS_BROWSER")) try {
      yf.registerManager(Pf.URL_SCHEME, new Wf());
    } catch (t2) {
    }
    Uf = "model";
    Vf = ".json";
    zf = ".weights.bin";
    Hf = function() {
      function t2(e2) {
        if (!i().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
        e2.startsWith(t2.URL_SCHEME) && (e2 = e2.slice(t2.URL_SCHEME.length)), null != e2 && 0 !== e2.length || (e2 = Uf), this.modelTopologyFileName = e2 + Vf, this.weightDataFileName = e2 + zf;
      }
      return t2.prototype.save = function(t3) {
        return n(this, void 0, void 0, function() {
          var e2, n2, o2, a2, i2, s2;
          return r(this, function(r2) {
            switch (r2.label) {
              case 0:
                if ("undefined" == typeof document) throw new Error("Browser downloads are not supported in this environment since `document` is not present");
                if (e2 = window.URL.createObjectURL(new Blob([t3.weightData], { type: "application/octet-stream" })), !(t3.modelTopology instanceof ArrayBuffer)) return [3, 1];
                throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
              case 1:
                return n2 = [{ paths: ["./" + this.weightDataFileName], weights: t3.weightSpecs }], o2 = { modelTopology: t3.modelTopology, format: t3.format, generatedBy: t3.generatedBy, convertedBy: t3.convertedBy, weightsManifest: n2 }, a2 = window.URL.createObjectURL(new Blob([JSON.stringify(o2)], { type: "application/json" })), (i2 = null == this.jsonAnchor ? document.createElement("a") : this.jsonAnchor).download = this.modelTopologyFileName, i2.href = a2, [4, Gf(function() {
                  return i2.dispatchEvent(new MouseEvent("click"));
                })];
              case 2:
                return r2.sent(), null == t3.weightData ? [3, 4] : ((s2 = null == this.weightDataAnchor ? document.createElement("a") : this.weightDataAnchor).download = this.weightDataFileName, s2.href = e2, [4, Gf(function() {
                  return s2.dispatchEvent(new MouseEvent("click"));
                })]);
              case 3:
                r2.sent(), r2.label = 4;
              case 4:
                return [2, { modelArtifactsInfo: vf(t3) }];
            }
          });
        });
      }, t2.URL_SCHEME = "downloads://", t2;
    }();
    qf = function() {
      function t2(t3) {
        if (null == t3 || t3.length < 1) throw new Error("When calling browserFiles, at least 1 file is required, but received " + t3);
        this.files = t3;
      }
      return t2.prototype.load = function() {
        return n(this, void 0, void 0, function() {
          var t3, e2, n2 = this;
          return r(this, function(r2) {
            return t3 = this.files[0], e2 = this.files.slice(1), [2, new Promise(function(r3, o2) {
              var a2 = new FileReader();
              a2.onload = function(a3) {
                var i2 = JSON.parse(a3.target.result), s2 = i2.modelTopology;
                if (null != s2) {
                  0 === e2.length && r3({ modelTopology: s2 });
                  var u3 = i2.weightsManifest;
                  if (null != u3) {
                    var c2;
                    try {
                      c2 = n2.checkManifestAndWeightFiles(u3, e2);
                    } catch (t4) {
                      return void o2(t4);
                    }
                    var l2 = [], h2 = [], f2 = [];
                    u3.forEach(function(t4) {
                      t4.paths.forEach(function(t5) {
                        h2.push(t5), f2.push(null);
                      }), l2.push.apply(l2, t4.weights);
                    }), u3.forEach(function(t4) {
                      t4.paths.forEach(function(t5) {
                        var e3 = new FileReader();
                        e3.onload = function(e4) {
                          var n3 = e4.target.result, o3 = h2.indexOf(t5);
                          f2[o3] = n3, -1 === f2.indexOf(null) && r3({ modelTopology: s2, weightSpecs: l2, weightData: df(f2), format: i2.format, generatedBy: i2.generatedBy, convertedBy: i2.convertedBy, userDefinedMetadata: i2.userDefinedMetadata });
                        }, e3.onerror = function(e4) {
                          return o2("Failed to weights data from file of path '" + t5 + "'.");
                        }, e3.readAsArrayBuffer(c2[t5]);
                      });
                    });
                  } else o2(new Error("weightManifest field is missing from file " + t3.name));
                } else o2(new Error("modelTopology field is missing from file " + t3.name));
              }, a2.onerror = function(e3) {
                return o2("Failed to read model topology and weights manifest JSON from file '" + t3.name + "'. BrowserFiles supports loading Keras-style tf.Model artifacts only.");
              }, a2.readAsText(t3);
            })];
          });
        });
      }, t2.prototype.checkManifestAndWeightFiles = function(t3, e2) {
        for (var n2 = [], r2 = e2.map(function(t4) {
          return pf(t4.name);
        }), o2 = {}, a2 = 0, i2 = t3; a2 < i2.length; a2++) {
          i2[a2].paths.forEach(function(t4) {
            var a3 = pf(t4);
            if (-1 !== n2.indexOf(a3)) throw new Error("Duplicate file basename found in weights manifest: '" + a3 + "'");
            if (n2.push(a3), -1 === r2.indexOf(a3)) throw new Error("Weight file with basename '" + a3 + "' is not provided.");
            o2[t4] = e2[r2.indexOf(a3)];
          });
        }
        if (n2.length !== e2.length) throw new Error("Mismatch in the number of files in weights manifest (" + n2.length + ") and the number of weight files provided (" + e2.length + ").");
        return o2;
      }, t2;
    }();
    mf.registerSaveRouter(function(t2) {
      return i().getBool("IS_BROWSER") && !Array.isArray(t2) && t2.startsWith(Hf.URL_SCHEME) ? function(t3) {
        void 0 === t3 && (t3 = "model");
        return new Hf(t3);
      }(t2.slice(Hf.URL_SCHEME.length)) : null;
    });
    Yf = function() {
      function t2(t3, e2) {
        if (this.DEFAULT_METHOD = "POST", null == e2 && (e2 = {}), this.weightPathPrefix = e2.weightPathPrefix, this.onProgress = e2.onProgress, null != e2.fetchFunc ? (C("function" == typeof e2.fetchFunc, function() {
          return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)";
        }), this.fetch = e2.fetchFunc) : this.fetch = i().platform.fetch, C(null != t3 && t3.length > 0, function() {
          return "URL path for http must not be null, undefined or empty.";
        }), Array.isArray(t3) && C(2 === t3.length, function() {
          return "URL paths for http must have a length of 2, (actual length is " + t3.length + ").";
        }), this.path = t3, null != e2.requestInit && null != e2.requestInit.body) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
        this.requestInit = e2.requestInit || {};
      }
      return t2.prototype.save = function(t3) {
        return n(this, void 0, void 0, function() {
          var e2, n2, o2, a2;
          return r(this, function(r2) {
            switch (r2.label) {
              case 0:
                if (t3.modelTopology instanceof ArrayBuffer) throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
                return (e2 = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit)).body = new FormData(), n2 = [{ paths: ["./model.weights.bin"], weights: t3.weightSpecs }], o2 = { modelTopology: t3.modelTopology, format: t3.format, generatedBy: t3.generatedBy, convertedBy: t3.convertedBy, userDefinedMetadata: t3.userDefinedMetadata, weightsManifest: n2 }, e2.body.append("model.json", new Blob([JSON.stringify(o2)], { type: "application/json" }), "model.json"), null != t3.weightData && e2.body.append("model.weights.bin", new Blob([t3.weightData], { type: "application/octet-stream" }), "model.weights.bin"), [4, this.fetch(this.path, e2)];
              case 1:
                if ((a2 = r2.sent()).ok) return [2, { modelArtifactsInfo: vf(t3), responses: [a2] }];
                throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + a2.status + ".");
            }
          });
        });
      }, t2.prototype.load = function() {
        return n(this, void 0, void 0, function() {
          var t3, e2, n2, o2, a2, i2, s2, u3, c2, l2, h2, f2;
          return r(this, function(r2) {
            switch (r2.label) {
              case 0:
                return [4, this.fetch(this.path, this.requestInit)];
              case 1:
                if (!(t3 = r2.sent()).ok) throw new Error("Request to " + this.path + " failed with status code " + t3.status + ". Please verify this URL points to the model JSON of the model to load.");
                r2.label = 2;
              case 2:
                return r2.trys.push([2, 4, , 5]), [4, t3.json()];
              case 3:
                return e2 = r2.sent(), [3, 5];
              case 4:
                throw r2.sent(), n2 = "Failed to parse model JSON of response from " + this.path + ".", this.path.endsWith(".pb") ? n2 += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : n2 += " Please make sure the server is serving valid JSON for this request.", new Error(n2);
              case 5:
                if (o2 = e2.modelTopology, a2 = e2.weightsManifest, i2 = e2.generatedBy, s2 = e2.convertedBy, u3 = e2.format, c2 = e2.userDefinedMetadata, null == o2 && null == a2) throw new Error("The JSON from HTTP path " + this.path + " contains neither model topology or manifest for weights.");
                return null == a2 ? [3, 7] : [4, this.loadWeights(a2)];
              case 6:
                f2 = r2.sent(), l2 = f2[0], h2 = f2[1], r2.label = 7;
              case 7:
                return [2, { modelTopology: o2, weightSpecs: l2, weightData: h2, userDefinedMetadata: c2, generatedBy: i2, convertedBy: s2, format: u3 }];
            }
          });
        });
      }, t2.prototype.loadWeights = function(t3) {
        return n(this, void 0, void 0, function() {
          var e2, n2, o2, a2, i2, s2, u3, c2, l2, h2, f2;
          return r(this, function(r2) {
            switch (r2.label) {
              case 0:
                for (e2 = Array.isArray(this.path) ? this.path[1] : this.path, n2 = function(t4) {
                  var e3 = t4.lastIndexOf("/"), n3 = t4.lastIndexOf("?"), r3 = t4.substring(0, e3), o3 = n3 > e3 ? t4.substring(n3) : "";
                  return [r3 + "/", o3];
                }(e2), o2 = n2[0], a2 = n2[1], i2 = this.weightPathPrefix || o2, s2 = [], u3 = 0, c2 = t3; u3 < c2.length; u3++) l2 = c2[u3], s2.push.apply(s2, l2.weights);
                return h2 = [], t3.forEach(function(t4) {
                  t4.paths.forEach(function(t5) {
                    h2.push(i2 + t5 + a2);
                  });
                }), [4, jf(h2, { requestInit: this.requestInit, fetchFunc: this.fetch, onProgress: this.onProgress })];
              case 1:
                return f2 = r2.sent(), [2, [s2, df(f2)]];
            }
          });
        });
      }, t2.URL_SCHEME_REGEX = /^https?:\/\//, t2;
    }();
    Qf = function(t2, e2) {
      if ("undefined" == typeof fetch) return null;
      return (Array.isArray(t2) ? t2.every(function(t3) {
        return $f(t3);
      }) : $f(t2)) ? Jf(t2, { onProgress: e2 }) : null;
    };
    mf.registerSaveRouter(Qf), mf.registerLoadRouter(Qf);
    Zf = function() {
      function t2(t3) {
        this.modelArtifacts = t3;
      }
      return t2.prototype.load = function() {
        return n(this, void 0, void 0, function() {
          return r(this, function(t3) {
            return [2, this.modelArtifacts];
          });
        });
      }, t2;
    }();
    td = function() {
      function t2(t3) {
        this.saveHandler = t3;
      }
      return t2.prototype.save = function(t3) {
        return n(this, void 0, void 0, function() {
          return r(this, function(e2) {
            return [2, this.saveHandler(t3)];
          });
        });
      }, t2;
    }();
    ed = Object.freeze({ browserFiles: function(t2) {
      return new qf(t2);
    }, browserHTTPRequest: function(t2, e2) {
      return Jf(t2, e2);
    }, concatenateArrayBuffers: df, decodeWeights: cf, encodeWeights: function(t2, e2) {
      return n(this, void 0, void 0, function() {
        var o2, a2, i2, s2, u3, c2 = this;
        return r(this, function(l2) {
          switch (l2.label) {
            case 0:
              for (o2 = [], a2 = [], i2 = Array.isArray(t2) ? t2.map(function(t3) {
                return t3.name;
              }) : Object.keys(t2), s2 = function(s3) {
                var u4 = i2[s3], l3 = Array.isArray(t2) ? t2[s3].tensor : t2[u4];
                if ("float32" !== l3.dtype && "int32" !== l3.dtype && "bool" !== l3.dtype && "string" !== l3.dtype) throw new Error("Unsupported dtype in weight '" + u4 + "': " + l3.dtype);
                var h2 = { name: u4, shape: l3.shape, dtype: l3.dtype };
                if ("string" === l3.dtype) {
                  var f2 = new Promise(function(t3) {
                    return n(c2, void 0, void 0, function() {
                      var e3, n2, o3, a3, i3, s4, u5;
                      return r(this, function(r2) {
                        switch (r2.label) {
                          case 0:
                            return [4, l3.bytes()];
                          case 1:
                            for (e3 = r2.sent(), n2 = e3.reduce(function(t4, e4) {
                              return t4 + e4.length;
                            }, 0) + uf * e3.length, o3 = new Uint8Array(n2), a3 = 0, i3 = 0; i3 < e3.length; i3++) s4 = e3[i3], u5 = new Uint8Array(new Uint32Array([s4.length]).buffer), o3.set(u5, a3), a3 += uf, o3.set(s4, a3), a3 += s4.length;
                            return t3(o3), [2];
                        }
                      });
                    });
                  });
                  a2.push(f2);
                } else a2.push(l3.data());
                null != e2 && (h2.group = e2), o2.push(h2);
              }, u3 = 0; u3 < i2.length; ++u3) s2(u3);
              return [4, Promise.all(a2)];
            case 1:
              return [2, { data: lf(l2.sent()), specs: o2 }];
          }
        });
      });
    }, fromMemory: function(t2, e2, n2, r2) {
      return 1 === arguments.length ? null != t2.modelTopology || null != t2.weightSpecs ? new Zf(t2) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Zf({ modelTopology: t2 })) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Zf({ modelTopology: t2, weightSpecs: e2, weightData: n2, trainingConfig: r2 }));
    }, getLoadHandlers: function(t2, e2) {
      return mf.getLoadHandlers(t2, e2);
    }, getModelArtifactsInfoForJSON: vf, getSaveHandlers: function(t2) {
      return mf.getSaveHandlers(t2);
    }, http: Jf, isHTTPScheme: $f, loadWeights: function(t2, e2, o2, a2) {
      return void 0 === e2 && (e2 = ""), n(this, void 0, void 0, function() {
        return r(this, function(n2) {
          return [2, Xf(function(t3) {
            return jf(t3, { requestInit: a2 });
          })(t2, e2, o2)];
        });
      });
    }, registerLoadRouter: function(t2) {
      return mf.registerLoadRouter(t2);
    }, registerSaveRouter: function(t2) {
      return mf.registerSaveRouter(t2);
    }, weightsLoaderFactory: Xf, withSaveHandler: function(t2) {
      return new td(t2);
    }, copyModel: function(t2, e2) {
      return n(this, void 0, void 0, function() {
        return r(this, function(n2) {
          return false, [2, bf(t2, e2, false)];
        });
      });
    }, listModels: function() {
      return n(this, void 0, void 0, function() {
        var t2, e2, n2, o2, a2, i2, s2;
        return r(this, function(r2) {
          switch (r2.label) {
            case 0:
              t2 = yf.getSchemes(), e2 = {}, n2 = 0, o2 = t2, r2.label = 1;
            case 1:
              return n2 < o2.length ? (a2 = o2[n2], [4, yf.getManager(a2).listModels()]) : [3, 4];
            case 2:
              for (s2 in i2 = r2.sent()) e2[a2 + gf + s2] = i2[s2];
              r2.label = 3;
            case 3:
              return n2++, [3, 1];
            case 4:
              return [2, e2];
          }
        });
      });
    }, moveModel: function(t2, e2) {
      return n(this, void 0, void 0, function() {
        return r(this, function(n2) {
          return true, [2, bf(t2, e2, true)];
        });
      });
    }, removeModel: function(t2) {
      return n(this, void 0, void 0, function() {
        var e2;
        return r(this, function(n2) {
          return e2 = xf(t2), [2, yf.getManager(e2.scheme).removeModel(e2.path)];
        });
      });
    } });
    rd = An({ confusionMatrix_: function(t2, e2, n2) {
      var r2 = mn(t2, "labels", "confusionMatrix"), o2 = mn(e2, "predictions", "confusionMatrix");
      C(null == n2 || n2 > 0 && Number.isInteger(n2), function() {
        return "If provided, numClasses must be a positive integer, but got " + n2;
      }), C(1 === r2.rank, function() {
        return "Expected the rank of labels to be 1, but got " + r2.rank;
      }), C(1 === o2.rank, function() {
        return "Expected the rank of predictions to be 1, but got " + o2.rank;
      }), C(r2.shape[0] === o2.shape[0], function() {
        return "Mismatch in the number of examples: " + r2.shape[0] + " vs. " + o2.shape[0] + ". Labels and predictions should have the same number of elements.";
      }), C(n2 > 0 && Number.isInteger(n2), function() {
        return "numClasses is required to be a positive integer, but got " + n2;
      });
      var a2 = Rr(r2.asType("int32"), n2), i2 = Rr(o2.asType("int32"), n2);
      return a2.transpose().matMul(i2).asType("int32");
    } });
    od = Object.freeze({ confusionMatrix: rd });
    ad = An({ fromPixels_: function(t2, e2) {
      if (void 0 === e2 && (e2 = 3), e2 > 4) throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
      if (null == t2) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
      var n2 = false, r2 = false, o2 = false, a2 = false, i2 = false;
      if (t2.data instanceof Uint8Array) n2 = true;
      else if ("undefined" != typeof ImageData && t2 instanceof ImageData) r2 = true;
      else if ("undefined" != typeof HTMLVideoElement && t2 instanceof HTMLVideoElement) o2 = true;
      else if ("undefined" != typeof HTMLImageElement && t2 instanceof HTMLImageElement) a2 = true;
      else {
        if (null == t2.getContext) throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was " + t2.constructor.name);
        i2 = true;
      }
      if (o2) {
        if (o2 && t2.readyState < 2) throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");
      }
      if (null != l("FromPixels", Lt.backendName)) return Lt.runKernel("FromPixels", { pixels: t2 }, { numChannels: e2 });
      var s2, u3, c2 = o2 ? [t2.videoWidth, t2.videoHeight] : [t2.width, t2.height], h2 = c2[0], f2 = c2[1];
      if (i2 ? s2 = t2.getContext("2d").getImageData(0, 0, h2, f2).data : r2 || n2 ? s2 = t2.data : (a2 || o2) && (null == nd && (nd = document.createElement("canvas").getContext("2d")), nd.canvas.width = h2, nd.canvas.height = f2, nd.drawImage(t2, 0, 0, h2, f2), s2 = nd.getImageData(0, 0, h2, f2).data), 4 === e2) u3 = new Int32Array(s2);
      else {
        var d2 = h2 * f2;
        u3 = new Int32Array(d2 * e2);
        for (var p2 = 0; p2 < d2; p2++) for (var v = 0; v < e2; ++v) u3[p2 * e2 + v] = s2[4 * p2 + v];
      }
      return Pn(u3, [f2, h2, e2], "int32");
    } });
    id = Object.freeze({ toPixels: function(t2, e2) {
      return n(this, void 0, void 0, function() {
        var n2, o2, a2, i2, s2, u3, c2, l2, h2, f2, d2, p2, v, m, g2, y2, x2, b2, w2, C2, E2, R2, I2;
        return r(this, function(r2) {
          switch (r2.label) {
            case 0:
              if (n2 = mn(t2, "img", "toPixels"), t2 instanceof wt || (n2 = n2.toInt()), 2 !== n2.rank && 3 !== n2.rank) throw new Error("toPixels only supports rank 2 or 3 tensors, got rank " + n2.rank + ".");
              if (o2 = n2.shape.slice(0, 2), a2 = o2[0], i2 = o2[1], (s2 = 2 === n2.rank ? 1 : n2.shape[2]) > 4 || 2 === s2) throw new Error("toPixels only supports depth of size 1, 3 or 4 but got " + s2);
              return [4, n2.data()];
            case 1:
              return u3 = r2.sent(), c2 = n2.min(), l2 = n2.max(), [4, Promise.all([c2.data(), l2.data()])];
            case 2:
              if (h2 = r2.sent(), f2 = h2[0], d2 = h2[1], p2 = f2[0], v = d2[0], c2.dispose(), l2.dispose(), "float32" === n2.dtype) {
                if (p2 < 0 || v > 1) throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [" + p2 + " - " + v + "].");
              } else {
                if ("int32" !== n2.dtype) throw new Error("Unsupported type for toPixels: " + n2.dtype + ". Please use float32 or int32 tensors.");
                if (p2 < 0 || v > 255) throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [" + p2 + " - " + v + "].");
              }
              for (m = "float32" === n2.dtype ? 255 : 1, g2 = new Uint8ClampedArray(i2 * a2 * 4), y2 = 0; y2 < a2 * i2; ++y2) x2 = void 0, b2 = void 0, w2 = void 0, C2 = void 0, 1 === s2 ? (x2 = u3[y2] * m, b2 = u3[y2] * m, w2 = u3[y2] * m, C2 = 255) : 3 === s2 ? (x2 = u3[3 * y2] * m, b2 = u3[3 * y2 + 1] * m, w2 = u3[3 * y2 + 2] * m, C2 = 255) : 4 === s2 && (x2 = u3[4 * y2] * m, b2 = u3[4 * y2 + 1] * m, w2 = u3[4 * y2 + 2] * m, C2 = u3[4 * y2 + 3] * m), g2[(E2 = 4 * y2) + 0] = Math.round(x2), g2[E2 + 1] = Math.round(b2), g2[E2 + 2] = Math.round(w2), g2[E2 + 3] = Math.round(C2);
              return null != e2 && (e2.width = i2, e2.height = a2, R2 = e2.getContext("2d"), I2 = new ImageData(g2, i2, a2), R2.putImageData(I2, 0, 0)), n2 !== t2 && n2.dispose(), [2, g2];
          }
        });
      });
    }, fromPixels: ad });
    sd = function() {
      function t2() {
      }
      return t2.prototype.getClassName = function() {
        return this.constructor.className;
      }, t2.fromConfig = function(t3, e2) {
        return new t3(e2);
      }, t2;
    }();
    ud = function() {
      function t2() {
        this.classNameMap = {};
      }
      return t2.getMap = function() {
        return null == t2.instance && (t2.instance = new t2()), t2.instance;
      }, t2.register = function(e2) {
        t2.getMap().classNameMap[e2.className] = [e2, e2.fromConfig];
      }, t2;
    }();
    ld = Object.freeze({ Serializable: sd, SerializationMap: ud, registerClass: cd });
    hd = 1e-3;
    fd = 0.1;
    md = Object.freeze({ TEST_EPSILON_FLOAT16: fd, expectArraysClose: function(t2, e2, n2) {
      return null == n2 && (n2 = dd()), pd(t2, e2, function(t3, e3) {
        return vd(t3, e3, n2);
      });
    }, testEpsilon: dd, expectPromiseToFail: function(t2, e2) {
      t2().then(function() {
        return e2.fail();
      }, function() {
        return e2();
      });
    }, expectArraysEqual: function(t2, e2) {
      var n2 = "string" == typeof e2 || "number" == typeof e2 || "boolean" == typeof e2 ? [e2] : e2;
      return H(t2) || H(t2[0]) || H(e2) || H(e2[0]) ? pd(t2, n2, function(t3, e3) {
        return t3 == e3;
      }) : pd(t2, e2, function(t3, e3) {
        return vd(t3, e3, 0);
      });
    }, expectNumbersClose: function(t2, e2, n2) {
      if (null == n2 && (n2 = dd()), !vd(t2, e2, n2)) throw new Error("Numbers differ: actual === " + t2 + ", expected === " + e2);
    }, expectValuesInRange: function(t2, e2, n2) {
      for (var r2 = 0; r2 < t2.length; r2++) if (t2[r2] < e2 || t2[r2] > n2) throw new Error("Value out of range:" + t2[r2] + " low: " + e2 + ", high: " + n2);
    }, expectArrayBuffersEqual: function(t2, e2) {
      expect(new Float32Array(t2)).toEqual(new Float32Array(e2));
    } });
    yd = Object.freeze({ gpgpu_util: Mi, webgl_util: Ge, forceHalfFloat: function() {
      i().set("WEBGL_FORCE_F16_TEXTURES", true);
    }, MathBackendWebGL: Zs, setWebGLContext: Kt, GPGPUContext: Bi });
    xd = function(t2) {
      function o2() {
        return null !== t2 && t2.apply(this, arguments) || this;
      }
      return e(o2, t2), o2.prototype.minimize = function(t3, e2, n2) {
        void 0 === e2 && (e2 = false);
        var r2 = this.computeGradients(t3, n2), o3 = r2.value, a2 = r2.grads;
        if (null != n2) {
          var i2 = n2.map(function(t4) {
            return { name: t4.name, tensor: a2[t4.name] };
          });
          this.applyGradients(i2);
        } else this.applyGradients(a2);
        return tn(a2), e2 ? o3 : (o3.dispose(), null);
      }, Object.defineProperty(o2.prototype, "iterations", { get: function() {
        return null == this.iterations_ && (this.iterations_ = 0), this.iterations_;
      }, enumerable: true, configurable: true }), o2.prototype.incrementIterations = function() {
        this.iterations_ = this.iterations + 1;
      }, o2.prototype.computeGradients = function(t3, e2) {
        return po(t3, e2);
      }, o2.prototype.dispose = function() {
        null != this.iterations_ && tn(this.iterations_);
      }, o2.prototype.saveIterations = function() {
        return n(this, void 0, void 0, function() {
          return r(this, function(t3) {
            return null == this.iterations_ && (this.iterations_ = 0), [2, { name: "iter", tensor: On(this.iterations_, "int32") }];
          });
        });
      }, o2.prototype.getWeights = function() {
        return n(this, void 0, void 0, function() {
          return r(this, function(t3) {
            throw new Error("getWeights() is not implemented for this optimizer yet.");
          });
        });
      }, o2.prototype.setWeights = function(t3) {
        return n(this, void 0, void 0, function() {
          return r(this, function(t4) {
            throw new Error("setWeights() is not implemented for this optimizer class " + this.getClassName());
          });
        });
      }, o2.prototype.extractIterations = function(t3) {
        return n(this, void 0, void 0, function() {
          var e2;
          return r(this, function(n2) {
            switch (n2.label) {
              case 0:
                return e2 = this, [4, t3[0].tensor.data()];
              case 1:
                return e2.iterations_ = n2.sent()[0], [2, t3.slice(1)];
            }
          });
        });
      }, o2;
    }(sd);
    Object.defineProperty(xd, Symbol.hasInstance, { value: function(t2) {
      return null != t2.minimize && null != t2.computeGradients && null != t2.applyGradients;
    } });
    bd = function(t2) {
      function o2(e2, n2, r2) {
        void 0 === r2 && (r2 = null);
        var o3 = t2.call(this) || this;
        return o3.learningRate = e2, o3.rho = n2, o3.epsilon = r2, o3.accumulatedGrads = [], o3.accumulatedUpdates = [], null == r2 && (o3.epsilon = Lt.backend.epsilon()), o3;
      }
      return e(o2, t2), o2.prototype.applyGradients = function(t3) {
        var e2 = this;
        (Array.isArray(t3) ? t3.map(function(t4) {
          return t4.name;
        }) : Object.keys(t3)).forEach(function(n2, r2) {
          var o3 = Lt.registeredVariables[n2];
          null == e2.accumulatedGrads[r2] && (e2.accumulatedGrads[r2] = { originalName: n2 + "/accum_grad", variable: Ze(function() {
            return Xn(o3).variable(false);
          }) }), null == e2.accumulatedUpdates[r2] && (e2.accumulatedUpdates[r2] = { originalName: n2 + "/accum_var", variable: Ze(function() {
            return Xn(o3).variable(false);
          }) });
          var a2 = Array.isArray(t3) ? t3[r2].tensor : t3[n2];
          if (null != a2) {
            var i2 = e2.accumulatedGrads[r2].variable, s2 = e2.accumulatedUpdates[r2].variable;
            Ze(function() {
              var t4 = i2.mul(e2.rho).add(a2.square().mul(1 - e2.rho)), n3 = s2.add(e2.epsilon).sqrt().div(i2.add(e2.epsilon).sqrt()).mul(a2), r3 = s2.mul(e2.rho).add(n3.square().mul(1 - e2.rho));
              i2.assign(t4), s2.assign(r3);
              var u3 = n3.mul(-e2.learningRate).add(o3);
              o3.assign(u3);
            });
          }
        }), this.incrementIterations();
      }, o2.prototype.dispose = function() {
        null != this.accumulatedUpdates && (tn(this.accumulatedGrads.map(function(t3) {
          return t3.variable;
        })), tn(this.accumulatedUpdates.map(function(t3) {
          return t3.variable;
        })));
      }, o2.prototype.getWeights = function() {
        return n(this, void 0, void 0, function() {
          var t3;
          return r(this, function(e2) {
            switch (e2.label) {
              case 0:
                return t3 = this.accumulatedGrads.concat(this.accumulatedUpdates), [4, this.saveIterations()];
              case 1:
                return [2, [e2.sent()].concat(t3.map(function(t4) {
                  return { name: t4.originalName, tensor: t4.variable };
                }))];
            }
          });
        });
      }, o2.prototype.setWeights = function(t3) {
        return n(this, void 0, void 0, function() {
          var e2;
          return r(this, function(n2) {
            switch (n2.label) {
              case 0:
                return [4, this.extractIterations(t3)];
              case 1:
                return t3 = n2.sent(), e2 = t3.length / 2, false, this.accumulatedGrads = t3.slice(0, e2).map(function(t4) {
                  return { originalName: t4.name, variable: t4.tensor.variable(false) };
                }), this.accumulatedUpdates = t3.slice(e2, 2 * e2).map(function(t4) {
                  return { originalName: t4.name, variable: t4.tensor.variable(false) };
                }), [2];
            }
          });
        });
      }, o2.prototype.getConfig = function() {
        return { learningRate: this.learningRate, rho: this.rho, epsilon: this.epsilon };
      }, o2.fromConfig = function(t3, e2) {
        return new t3(e2.learningRate, e2.rho, e2.epsilon);
      }, o2.className = "Adadelta", o2;
    }(xd);
    cd(bd);
    wd = function(t2) {
      function o2(e2, n2) {
        void 0 === n2 && (n2 = 0.1);
        var r2 = t2.call(this) || this;
        return r2.learningRate = e2, r2.initialAccumulatorValue = n2, r2.accumulatedGrads = [], r2;
      }
      return e(o2, t2), o2.prototype.applyGradients = function(t3) {
        var e2 = this;
        (Array.isArray(t3) ? t3.map(function(t4) {
          return t4.name;
        }) : Object.keys(t3)).forEach(function(n2, r2) {
          var o3 = Lt.registeredVariables[n2];
          if (null == e2.accumulatedGrads[r2]) {
            e2.accumulatedGrads[r2] = { originalName: n2 + "/accumulator", variable: Ze(function() {
              return Hn(o3.shape, e2.initialAccumulatorValue).variable(false);
            }) };
          }
          var a2 = Array.isArray(t3) ? t3[r2].tensor : t3[n2];
          if (null != a2) {
            var i2 = e2.accumulatedGrads[r2].variable;
            Ze(function() {
              var t4 = i2.add(a2.square());
              i2.assign(t4);
              var n3 = a2.div(t4.add(Lt.backend.epsilon()).sqrt()).mul(-e2.learningRate).add(o3);
              o3.assign(n3);
            });
          }
        }), this.incrementIterations();
      }, o2.prototype.dispose = function() {
        null != this.accumulatedGrads && tn(this.accumulatedGrads.map(function(t3) {
          return t3.variable;
        }));
      }, o2.prototype.getWeights = function() {
        return n(this, void 0, void 0, function() {
          return r(this, function(t3) {
            switch (t3.label) {
              case 0:
                return [4, this.saveIterations()];
              case 1:
                return [2, [t3.sent()].concat(this.accumulatedGrads.map(function(t4) {
                  return { name: t4.originalName, tensor: t4.variable };
                }))];
            }
          });
        });
      }, o2.prototype.setWeights = function(t3) {
        return n(this, void 0, void 0, function() {
          return r(this, function(e2) {
            switch (e2.label) {
              case 0:
                return [4, this.extractIterations(t3)];
              case 1:
                return t3 = e2.sent(), false, this.accumulatedGrads = t3.map(function(t4) {
                  return { originalName: t4.name, variable: t4.tensor.variable(false) };
                }), [2];
            }
          });
        });
      }, o2.prototype.getConfig = function() {
        return { learningRate: this.learningRate, initialAccumulatorValue: this.initialAccumulatorValue };
      }, o2.fromConfig = function(t3, e2) {
        return new t3(e2.learningRate, e2.initialAccumulatorValue);
      }, o2.className = "Adagrad", o2;
    }(xd);
    cd(wd);
    Cd = function(t2) {
      function o2(e2, n2, r2, o3) {
        void 0 === o3 && (o3 = null);
        var a2 = t2.call(this) || this;
        return a2.learningRate = e2, a2.beta1 = n2, a2.beta2 = r2, a2.epsilon = o3, a2.accumulatedFirstMoment = [], a2.accumulatedSecondMoment = [], Ze(function() {
          a2.accBeta1 = On(n2).variable(), a2.accBeta2 = On(r2).variable();
        }), null == o3 && (a2.epsilon = Lt.backend.epsilon()), a2;
      }
      return e(o2, t2), o2.prototype.applyGradients = function(t3) {
        var e2 = this, n2 = Array.isArray(t3) ? t3.map(function(t4) {
          return t4.name;
        }) : Object.keys(t3);
        Ze(function() {
          var r2 = Cc(1, e2.accBeta1), o3 = Cc(1, e2.accBeta2);
          n2.forEach(function(n3, a2) {
            var i2 = Lt.registeredVariables[n3];
            null == e2.accumulatedFirstMoment[a2] && (e2.accumulatedFirstMoment[a2] = { originalName: n3 + "/m", variable: Ze(function() {
              return Xn(i2).variable(false);
            }) }), null == e2.accumulatedSecondMoment[a2] && (e2.accumulatedSecondMoment[a2] = { originalName: n3 + "/v", variable: Ze(function() {
              return Xn(i2).variable(false);
            }) });
            var s2 = Array.isArray(t3) ? t3[a2].tensor : t3[n3];
            if (null != s2) {
              var u3 = e2.accumulatedFirstMoment[a2].variable, c2 = e2.accumulatedSecondMoment[a2].variable, l2 = u3.mul(e2.beta1).add(s2.mul(1 - e2.beta1)), h2 = c2.mul(e2.beta2).add(s2.square().mul(1 - e2.beta2)), f2 = l2.div(r2), d2 = h2.div(o3);
              u3.assign(l2), c2.assign(h2);
              var p2 = f2.div(d2.sqrt().add(e2.epsilon)).mul(-e2.learningRate).add(i2);
              i2.assign(p2);
            }
          }), e2.accBeta1.assign(e2.accBeta1.mul(e2.beta1)), e2.accBeta2.assign(e2.accBeta2.mul(e2.beta2));
        }), this.incrementIterations();
      }, o2.prototype.dispose = function() {
        this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && tn(this.accumulatedFirstMoment.map(function(t3) {
          return t3.variable;
        })), null != this.accumulatedSecondMoment && tn(this.accumulatedSecondMoment.map(function(t3) {
          return t3.variable;
        }));
      }, o2.prototype.getWeights = function() {
        return n(this, void 0, void 0, function() {
          var t3;
          return r(this, function(e2) {
            switch (e2.label) {
              case 0:
                return t3 = this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment), [4, this.saveIterations()];
              case 1:
                return [2, [e2.sent()].concat(t3.map(function(t4) {
                  return { name: t4.originalName, tensor: t4.variable };
                }))];
            }
          });
        });
      }, o2.prototype.setWeights = function(t3) {
        return n(this, void 0, void 0, function() {
          var e2, n2 = this;
          return r(this, function(r2) {
            switch (r2.label) {
              case 0:
                return [4, this.extractIterations(t3)];
              case 1:
                return t3 = r2.sent(), Ze(function() {
                  n2.accBeta1.assign(xc(n2.beta1, n2.iterations_ + 1)), n2.accBeta2.assign(xc(n2.beta2, n2.iterations_ + 1));
                }), e2 = t3.length / 2, false, this.accumulatedFirstMoment = t3.slice(0, e2).map(function(t4) {
                  return { originalName: t4.name, variable: t4.tensor.variable(false) };
                }), this.accumulatedSecondMoment = t3.slice(e2, 2 * e2).map(function(t4) {
                  return { originalName: t4.name, variable: t4.tensor.variable(false) };
                }), [2];
            }
          });
        });
      }, o2.prototype.getConfig = function() {
        return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon };
      }, o2.fromConfig = function(t3, e2) {
        return new t3(e2.learningRate, e2.beta1, e2.beta2, e2.epsilon);
      }, o2.className = "Adam", o2;
    }(xd);
    cd(Cd);
    Ed = function(t2) {
      function o2(e2, n2, r2, o3, a2) {
        void 0 === o3 && (o3 = null), void 0 === a2 && (a2 = 0);
        var i2 = t2.call(this) || this;
        return i2.learningRate = e2, i2.beta1 = n2, i2.beta2 = r2, i2.epsilon = o3, i2.decay = a2, i2.accumulatedFirstMoment = [], i2.accumulatedWeightedInfNorm = [], Ze(function() {
          i2.iteration = On(0).variable(), i2.accBeta1 = On(n2).variable();
        }), null == o3 && (i2.epsilon = Lt.backend.epsilon()), i2;
      }
      return e(o2, t2), o2.prototype.applyGradients = function(t3) {
        var e2 = this, n2 = Array.isArray(t3) ? t3.map(function(t4) {
          return t4.name;
        }) : Object.keys(t3);
        Ze(function() {
          var r2 = Cc(1, e2.accBeta1), o3 = sc(-e2.learningRate, e2.iteration.mul(e2.decay).add(1));
          n2.forEach(function(n3, a2) {
            var i2 = Lt.registeredVariables[n3];
            null == e2.accumulatedFirstMoment[a2] && (e2.accumulatedFirstMoment[a2] = { originalName: n3 + "/m", variable: Xn(i2).variable(false) }), null == e2.accumulatedWeightedInfNorm[a2] && (e2.accumulatedWeightedInfNorm[a2] = { originalName: n3 + "/v", variable: Xn(i2).variable(false) });
            var s2 = Array.isArray(t3) ? t3[a2].tensor : t3[n3];
            if (null != s2) {
              var u3 = e2.accumulatedFirstMoment[a2].variable, c2 = e2.accumulatedWeightedInfNorm[a2].variable, l2 = u3.mul(e2.beta1).add(s2.mul(1 - e2.beta1)), h2 = c2.mul(e2.beta2), f2 = s2.abs(), d2 = h2.maximum(f2);
              u3.assign(l2), c2.assign(d2);
              var p2 = o3.div(r2).mul(l2.div(d2.add(e2.epsilon))).add(i2);
              i2.assign(p2);
            }
          }), e2.iteration.assign(e2.iteration.add(1)), e2.accBeta1.assign(e2.accBeta1.mul(e2.beta1));
        }), this.incrementIterations();
      }, o2.prototype.dispose = function() {
        this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && tn(this.accumulatedFirstMoment.map(function(t3) {
          return t3.variable;
        })), null != this.accumulatedWeightedInfNorm && tn(this.accumulatedWeightedInfNorm.map(function(t3) {
          return t3.variable;
        }));
      }, o2.prototype.getWeights = function() {
        return n(this, void 0, void 0, function() {
          return r(this, function(t3) {
            throw new Error("getWeights() is not implemented for Adamax yet.");
          });
        });
      }, o2.prototype.setWeights = function(t3) {
        return n(this, void 0, void 0, function() {
          return r(this, function(t4) {
            throw new Error("setWeights() is not implemented for Adamax yet.");
          });
        });
      }, o2.prototype.getConfig = function() {
        return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon, decay: this.decay };
      }, o2.fromConfig = function(t3, e2) {
        return new t3(e2.learningRate, e2.beta1, e2.beta2, e2.epsilon, e2.decay);
      }, o2.className = "Adamax", o2;
    }(xd);
    cd(Ed);
    Rd = function(t2) {
      function o2(e2) {
        var n2 = t2.call(this) || this;
        return n2.learningRate = e2, n2.setLearningRate(e2), n2;
      }
      return e(o2, t2), o2.prototype.applyGradients = function(t3) {
        var e2 = this;
        (Array.isArray(t3) ? t3.map(function(t4) {
          return t4.name;
        }) : Object.keys(t3)).forEach(function(n2, r2) {
          var o3 = Array.isArray(t3) ? t3[r2].tensor : t3[n2];
          if (null != o3) {
            var a2 = Lt.registeredVariables[n2];
            Ze(function() {
              var t4 = e2.c.mul(o3).add(a2);
              a2.assign(t4);
            });
          }
        }), this.incrementIterations();
      }, o2.prototype.setLearningRate = function(t3) {
        this.learningRate = t3, null != this.c && this.c.dispose(), this.c = en(On(-t3));
      }, o2.prototype.dispose = function() {
        this.c.dispose();
      }, o2.prototype.getWeights = function() {
        return n(this, void 0, void 0, function() {
          return r(this, function(t3) {
            switch (t3.label) {
              case 0:
                return [4, this.saveIterations()];
              case 1:
                return [2, [t3.sent()]];
            }
          });
        });
      }, o2.prototype.setWeights = function(t3) {
        return n(this, void 0, void 0, function() {
          return r(this, function(e2) {
            switch (e2.label) {
              case 0:
                return [4, this.extractIterations(t3)];
              case 1:
                if (0 !== (t3 = e2.sent()).length) throw new Error("SGD optimizer does not have settable weights.");
                return [2];
            }
          });
        });
      }, o2.prototype.getConfig = function() {
        return { learningRate: this.learningRate };
      }, o2.fromConfig = function(t3, e2) {
        return new t3(e2.learningRate);
      }, o2.className = "SGD", o2;
    }(xd);
    cd(Rd);
    Id = function(t2) {
      function o2(e2, n2, r2) {
        void 0 === r2 && (r2 = false);
        var o3 = t2.call(this, e2) || this;
        return o3.learningRate = e2, o3.momentum = n2, o3.useNesterov = r2, o3.accumulations = [], o3.m = On(o3.momentum), o3;
      }
      return e(o2, t2), o2.prototype.applyGradients = function(t3) {
        var e2 = this;
        (Array.isArray(t3) ? t3.map(function(t4) {
          return t4.name;
        }) : Object.keys(t3)).forEach(function(n2, r2) {
          var o3 = Lt.registeredVariables[n2];
          if (null == e2.accumulations[r2]) {
            e2.accumulations[r2] = { originalName: n2 + "/momentum", variable: Ze(function() {
              return Xn(o3).variable(false);
            }) };
          }
          var a2 = e2.accumulations[r2].variable, i2 = Array.isArray(t3) ? t3[r2].tensor : t3[n2];
          null != i2 && Ze(function() {
            var t4, n3 = e2.m.mul(a2).add(i2);
            t4 = e2.useNesterov ? e2.c.mul(i2.add(n3.mul(e2.m))).add(o3) : e2.c.mul(n3).add(o3), a2.assign(n3), o3.assign(t4);
          });
        }), this.incrementIterations();
      }, o2.prototype.dispose = function() {
        this.m.dispose(), null != this.accumulations && tn(this.accumulations.map(function(t3) {
          return t3.variable;
        }));
      }, o2.prototype.setMomentum = function(t3) {
        this.momentum = t3;
      }, o2.prototype.getWeights = function() {
        return n(this, void 0, void 0, function() {
          return r(this, function(t3) {
            switch (t3.label) {
              case 0:
                return [4, this.saveIterations()];
              case 1:
                return [2, [t3.sent()].concat(this.accumulations.map(function(t4) {
                  return { name: t4.originalName, tensor: t4.variable };
                }))];
            }
          });
        });
      }, o2.prototype.setWeights = function(t3) {
        return n(this, void 0, void 0, function() {
          return r(this, function(e2) {
            switch (e2.label) {
              case 0:
                return [4, this.extractIterations(t3)];
              case 1:
                return t3 = e2.sent(), false, this.accumulations = t3.map(function(t4) {
                  return { originalName: t4.name, variable: t4.tensor.variable(false) };
                }), [2];
            }
          });
        });
      }, o2.prototype.getConfig = function() {
        return { learningRate: this.learningRate, momentum: this.momentum, useNesterov: this.useNesterov };
      }, o2.fromConfig = function(t3, e2) {
        return new t3(e2.learningRate, e2.momentum, e2.useNesterov);
      }, o2.className = "Momentum", o2;
    }(Rd);
    cd(Id);
    kd = function(t2) {
      function o2(e2, n2, r2, o3, a2) {
        void 0 === n2 && (n2 = 0.9), void 0 === r2 && (r2 = 0), void 0 === o3 && (o3 = null), void 0 === a2 && (a2 = false);
        var i2 = t2.call(this) || this;
        if (i2.learningRate = e2, i2.decay = n2, i2.momentum = r2, i2.epsilon = o3, i2.accumulatedMeanSquares = [], i2.accumulatedMoments = [], i2.accumulatedMeanGrads = [], i2.centered = a2, null == o3 && (i2.epsilon = Lt.backend.epsilon()), null == e2) throw new Error("learningRate for RMSPropOptimizer must be defined.");
        return i2;
      }
      return e(o2, t2), o2.prototype.applyGradients = function(t3) {
        var e2 = this;
        (Array.isArray(t3) ? t3.map(function(t4) {
          return t4.name;
        }) : Object.keys(t3)).forEach(function(n2, r2) {
          var o3 = Lt.registeredVariables[n2];
          null == e2.accumulatedMeanSquares[r2] && (e2.accumulatedMeanSquares[r2] = { originalName: n2 + "/rms", variable: Ze(function() {
            return Xn(o3).variable(false);
          }) }), null == e2.accumulatedMoments[r2] && (e2.accumulatedMoments[r2] = { originalName: n2 + "/momentum", variable: Ze(function() {
            return Xn(o3).variable(false);
          }) }), null == e2.accumulatedMeanGrads[r2] && e2.centered && (e2.accumulatedMeanGrads[r2] = { originalName: n2 + "/mg", variable: Ze(function() {
            return Xn(o3).variable(false);
          }) });
          var a2 = Array.isArray(t3) ? t3[r2].tensor : t3[n2];
          if (null != a2) {
            var i2 = e2.accumulatedMeanSquares[r2].variable, s2 = e2.accumulatedMoments[r2].variable;
            Ze(function() {
              var t4 = i2.mul(e2.decay).add(a2.square().mul(1 - e2.decay));
              if (e2.centered) {
                var n3 = e2.accumulatedMeanGrads[r2].variable, u3 = n3.mul(e2.decay).add(a2.mul(1 - e2.decay)), c2 = s2.mul(e2.momentum).add(a2.mul(e2.learningRate).div(t4.sub(u3.square().add(e2.epsilon)).sqrt()));
                i2.assign(t4), n3.assign(u3), s2.assign(c2);
                var l2 = o3.sub(c2);
                o3.assign(l2);
              } else {
                var h2 = i2.mul(e2.decay).add(a2.square().mul(1 - e2.decay));
                c2 = s2.mul(e2.momentum).add(a2.mul(e2.learningRate).div(h2.add(e2.epsilon).sqrt()));
                i2.assign(h2), s2.assign(c2);
                l2 = o3.sub(c2);
                o3.assign(l2);
              }
            });
          }
        }), this.incrementIterations();
      }, o2.prototype.dispose = function() {
        null != this.accumulatedMeanSquares && tn(this.accumulatedMeanSquares.map(function(t3) {
          return t3.variable;
        })), null != this.accumulatedMeanGrads && this.centered && tn(this.accumulatedMeanGrads.map(function(t3) {
          return t3.variable;
        })), null != this.accumulatedMoments && tn(this.accumulatedMoments.map(function(t3) {
          return t3.variable;
        }));
      }, o2.prototype.getWeights = function() {
        return n(this, void 0, void 0, function() {
          var t3;
          return r(this, function(e2) {
            switch (e2.label) {
              case 0:
                return t3 = this.accumulatedMeanSquares.concat(this.accumulatedMoments), this.centered && t3.push.apply(t3, this.accumulatedMeanGrads), [4, this.saveIterations()];
              case 1:
                return [2, [e2.sent()].concat(t3.map(function(t4) {
                  return { name: t4.originalName, tensor: t4.variable };
                }))];
            }
          });
        });
      }, o2.prototype.setWeights = function(t3) {
        return n(this, void 0, void 0, function() {
          var e2;
          return r(this, function(n2) {
            switch (n2.label) {
              case 0:
                return [4, this.extractIterations(t3)];
              case 1:
                return t3 = n2.sent(), e2 = this.centered ? t3.length / 3 : t3.length / 2, false, this.accumulatedMeanSquares = t3.slice(0, e2).map(function(t4) {
                  return { originalName: t4.name, variable: t4.tensor.variable(false) };
                }), this.accumulatedMoments = t3.slice(e2, 2 * e2).map(function(t4) {
                  return { originalName: t4.name, variable: t4.tensor.variable(false) };
                }), this.centered && (this.accumulatedMeanGrads = t3.slice(2 * e2, 3 * e2).map(function(t4) {
                  return { originalName: t4.name, variable: t4.tensor.variable(false) };
                })), [2];
            }
          });
        });
      }, o2.prototype.getConfig = function() {
        return { learningRate: this.learningRate, decay: this.decay, momentum: this.momentum, epsilon: this.epsilon, centered: this.centered };
      }, o2.fromConfig = function(t3, e2) {
        return new t3(e2.learningRate, e2.decay, e2.momentum, e2.epsilon, e2.centered);
      }, o2.className = "RMSProp", o2;
    }(xd);
    cd(kd);
    Sd = function() {
      function t2() {
      }
      return t2.sgd = function(t3) {
        return new Rd(t3);
      }, t2.momentum = function(t3, e2, n2) {
        return void 0 === n2 && (n2 = false), new Id(t3, e2, n2);
      }, t2.rmsprop = function(t3, e2, n2, r2, o2) {
        return void 0 === e2 && (e2 = 0.9), void 0 === n2 && (n2 = 0), void 0 === r2 && (r2 = null), void 0 === o2 && (o2 = false), new kd(t3, e2, n2, r2, o2);
      }, t2.adam = function(t3, e2, n2, r2) {
        return void 0 === t3 && (t3 = 1e-3), void 0 === e2 && (e2 = 0.9), void 0 === n2 && (n2 = 0.999), void 0 === r2 && (r2 = null), new Cd(t3, e2, n2, r2);
      }, t2.adadelta = function(t3, e2, n2) {
        return void 0 === t3 && (t3 = 1e-3), void 0 === e2 && (e2 = 0.95), void 0 === n2 && (n2 = null), new bd(t3, e2, n2);
      }, t2.adamax = function(t3, e2, n2, r2, o2) {
        return void 0 === t3 && (t3 = 2e-3), void 0 === e2 && (e2 = 0.9), void 0 === n2 && (n2 = 0.999), void 0 === r2 && (r2 = null), void 0 === o2 && (o2 = 0), new Ed(t3, e2, n2, r2, o2);
      }, t2.adagrad = function(t3, e2) {
        return void 0 === e2 && (e2 = 0.1), new wd(t3, e2);
      }, t2;
    }();
    Ad = { sgd: Sd.sgd, momentum: Sd.momentum, adadelta: Sd.adadelta, adagrad: Sd.adagrad, rmsprop: Sd.rmsprop, adamax: Sd.adamax, adam: Sd.adam };
    wt.prototype.squaredDifference = function(t2) {
      return nu(this, t2);
    }, xt = Gh;
  }
});

// node_modules/face-api.js/build/es6/draw/drawContour.js
function drawContour(ctx, points, isClosed) {
  if (isClosed === void 0) {
    isClosed = false;
  }
  ctx.beginPath();
  points.slice(1).forEach(function(_a2, prevIdx) {
    var x2 = _a2.x, y2 = _a2.y;
    var from3 = points[prevIdx];
    ctx.moveTo(from3.x, from3.y);
    ctx.lineTo(x2, y2);
  });
  if (isClosed) {
    var from2 = points[points.length - 1];
    var to2 = points[0];
    if (!from2 || !to2) {
      return;
    }
    ctx.moveTo(from2.x, from2.y);
    ctx.lineTo(to2.x, to2.y);
  }
  ctx.stroke();
}
var init_drawContour = __esm({
  "node_modules/face-api.js/build/es6/draw/drawContour.js"() {
    "use strict";
  }
});

// node_modules/face-api.js/node_modules/tslib/tslib.es6.js
function __extends(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __awaiter2(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (_2) try {
      if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t2[1]) {
            _2.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _2.label < t2[2]) {
            _2.label = t2[2];
            _2.ops.push(op);
            break;
          }
          if (t2[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e2) {
      op = [6, e2];
      y2 = 0;
    } finally {
      f2 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArrays() {
  for (var s2 = 0, i2 = 0, il2 = arguments.length; i2 < il2; i2++) s2 += arguments[i2].length;
  for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il2; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl2 = a2.length; j2 < jl2; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
}
var extendStatics, __assign;
var init_tslib_es62 = __esm({
  "node_modules/face-api.js/node_modules/tslib/tslib.es6.js"() {
    "use strict";
    extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) if (b3.hasOwnProperty(p2)) d3[p2] = b3[p2];
      };
      return extendStatics(d2, b2);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// node_modules/face-api.js/build/es6/classes/Dimensions.js
var Dimensions;
var init_Dimensions = __esm({
  "node_modules/face-api.js/build/es6/classes/Dimensions.js"() {
    "use strict";
    init_utils();
    Dimensions = /** @class */
    function() {
      function Dimensions2(width, height) {
        if (!isValidNumber(width) || !isValidNumber(height)) {
          throw new Error("Dimensions.constructor - expected width and height to be valid numbers, instead have " + JSON.stringify({ width, height }));
        }
        this._width = width;
        this._height = height;
      }
      Object.defineProperty(Dimensions2.prototype, "width", {
        get: function() {
          return this._width;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Dimensions2.prototype, "height", {
        get: function() {
          return this._height;
        },
        enumerable: true,
        configurable: true
      });
      Dimensions2.prototype.reverse = function() {
        return new Dimensions2(1 / this.width, 1 / this.height);
      };
      return Dimensions2;
    }();
  }
});

// node_modules/face-api.js/build/es6/utils/index.js
function isTensor(tensor, dim) {
  return tensor instanceof wt && tensor.shape.length === dim;
}
function isTensor2D(tensor) {
  return isTensor(tensor, 2);
}
function isTensor3D(tensor) {
  return isTensor(tensor, 3);
}
function isTensor4D(tensor) {
  return isTensor(tensor, 4);
}
function isFloat(num) {
  return num % 1 !== 0;
}
function isEven(num) {
  return num % 2 === 0;
}
function round2(num, prec) {
  if (prec === void 0) {
    prec = 2;
  }
  var f2 = Math.pow(10, prec);
  return Math.floor(num * f2) / f2;
}
function isDimensions(obj) {
  return obj && obj.width && obj.height;
}
function computeReshapedDimensions(_a2, inputSize) {
  var width = _a2.width, height = _a2.height;
  var scale2 = inputSize / Math.max(height, width);
  return new Dimensions(Math.round(width * scale2), Math.round(height * scale2));
}
function getCenterPoint(pts) {
  return pts.reduce(function(sum, pt2) {
    return sum.add(pt2);
  }, new Point(0, 0)).div(new Point(pts.length, pts.length));
}
function range(num, start, step) {
  return Array(num).fill(0).map(function(_2, i2) {
    return start + i2 * step;
  });
}
function isValidNumber(num) {
  return !!num && num !== Infinity && num !== -Infinity && !isNaN(num) || num === 0;
}
function isValidProbablitiy(num) {
  return isValidNumber(num) && 0 <= num && num <= 1;
}
var init_utils = __esm({
  "node_modules/face-api.js/build/es6/utils/index.js"() {
    "use strict";
    init_tf_core_esm();
    init_classes();
    init_Dimensions();
  }
});

// node_modules/face-api.js/build/es6/classes/Point.js
var Point;
var init_Point = __esm({
  "node_modules/face-api.js/build/es6/classes/Point.js"() {
    "use strict";
    Point = /** @class */
    function() {
      function Point2(x2, y2) {
        this._x = x2;
        this._y = y2;
      }
      Object.defineProperty(Point2.prototype, "x", {
        get: function() {
          return this._x;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Point2.prototype, "y", {
        get: function() {
          return this._y;
        },
        enumerable: true,
        configurable: true
      });
      Point2.prototype.add = function(pt2) {
        return new Point2(this.x + pt2.x, this.y + pt2.y);
      };
      Point2.prototype.sub = function(pt2) {
        return new Point2(this.x - pt2.x, this.y - pt2.y);
      };
      Point2.prototype.mul = function(pt2) {
        return new Point2(this.x * pt2.x, this.y * pt2.y);
      };
      Point2.prototype.div = function(pt2) {
        return new Point2(this.x / pt2.x, this.y / pt2.y);
      };
      Point2.prototype.abs = function() {
        return new Point2(Math.abs(this.x), Math.abs(this.y));
      };
      Point2.prototype.magnitude = function() {
        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));
      };
      Point2.prototype.floor = function() {
        return new Point2(Math.floor(this.x), Math.floor(this.y));
      };
      return Point2;
    }();
  }
});

// node_modules/face-api.js/build/es6/classes/Box.js
var Box;
var init_Box = __esm({
  "node_modules/face-api.js/build/es6/classes/Box.js"() {
    "use strict";
    init_utils();
    init_Point();
    Box = /** @class */
    function() {
      function Box2(_box, allowNegativeDimensions) {
        if (allowNegativeDimensions === void 0) {
          allowNegativeDimensions = true;
        }
        var box = _box || {};
        var isBbox = [box.left, box.top, box.right, box.bottom].every(isValidNumber);
        var isRect = [box.x, box.y, box.width, box.height].every(isValidNumber);
        if (!isRect && !isBbox) {
          throw new Error("Box.constructor - expected box to be IBoundingBox | IRect, instead have " + JSON.stringify(box));
        }
        var _a2 = isRect ? [box.x, box.y, box.width, box.height] : [box.left, box.top, box.right - box.left, box.bottom - box.top], x2 = _a2[0], y2 = _a2[1], width = _a2[2], height = _a2[3];
        Box2.assertIsValidBox({ x: x2, y: y2, width, height }, "Box.constructor", allowNegativeDimensions);
        this._x = x2;
        this._y = y2;
        this._width = width;
        this._height = height;
      }
      Box2.isRect = function(rect) {
        return !!rect && [rect.x, rect.y, rect.width, rect.height].every(isValidNumber);
      };
      Box2.assertIsValidBox = function(box, callee, allowNegativeDimensions) {
        if (allowNegativeDimensions === void 0) {
          allowNegativeDimensions = false;
        }
        if (!Box2.isRect(box)) {
          throw new Error(callee + " - invalid box: " + JSON.stringify(box) + ", expected object with properties x, y, width, height");
        }
        if (!allowNegativeDimensions && (box.width < 0 || box.height < 0)) {
          throw new Error(callee + " - width (" + box.width + ") and height (" + box.height + ") must be positive numbers");
        }
      };
      Object.defineProperty(Box2.prototype, "x", {
        get: function() {
          return this._x;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Box2.prototype, "y", {
        get: function() {
          return this._y;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Box2.prototype, "width", {
        get: function() {
          return this._width;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Box2.prototype, "height", {
        get: function() {
          return this._height;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Box2.prototype, "left", {
        get: function() {
          return this.x;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Box2.prototype, "top", {
        get: function() {
          return this.y;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Box2.prototype, "right", {
        get: function() {
          return this.x + this.width;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Box2.prototype, "bottom", {
        get: function() {
          return this.y + this.height;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Box2.prototype, "area", {
        get: function() {
          return this.width * this.height;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Box2.prototype, "topLeft", {
        get: function() {
          return new Point(this.left, this.top);
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Box2.prototype, "topRight", {
        get: function() {
          return new Point(this.right, this.top);
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Box2.prototype, "bottomLeft", {
        get: function() {
          return new Point(this.left, this.bottom);
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Box2.prototype, "bottomRight", {
        get: function() {
          return new Point(this.right, this.bottom);
        },
        enumerable: true,
        configurable: true
      });
      Box2.prototype.round = function() {
        var _a2 = [this.x, this.y, this.width, this.height].map(function(val) {
          return Math.round(val);
        }), x2 = _a2[0], y2 = _a2[1], width = _a2[2], height = _a2[3];
        return new Box2({ x: x2, y: y2, width, height });
      };
      Box2.prototype.floor = function() {
        var _a2 = [this.x, this.y, this.width, this.height].map(function(val) {
          return Math.floor(val);
        }), x2 = _a2[0], y2 = _a2[1], width = _a2[2], height = _a2[3];
        return new Box2({ x: x2, y: y2, width, height });
      };
      Box2.prototype.toSquare = function() {
        var _a2 = this, x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
        var diff = Math.abs(width - height);
        if (width < height) {
          x2 -= diff / 2;
          width += diff;
        }
        if (height < width) {
          y2 -= diff / 2;
          height += diff;
        }
        return new Box2({ x: x2, y: y2, width, height });
      };
      Box2.prototype.rescale = function(s2) {
        var scaleX = isDimensions(s2) ? s2.width : s2;
        var scaleY = isDimensions(s2) ? s2.height : s2;
        return new Box2({
          x: this.x * scaleX,
          y: this.y * scaleY,
          width: this.width * scaleX,
          height: this.height * scaleY
        });
      };
      Box2.prototype.pad = function(padX, padY) {
        var _a2 = [
          this.x - padX / 2,
          this.y - padY / 2,
          this.width + padX,
          this.height + padY
        ], x2 = _a2[0], y2 = _a2[1], width = _a2[2], height = _a2[3];
        return new Box2({ x: x2, y: y2, width, height });
      };
      Box2.prototype.clipAtImageBorders = function(imgWidth, imgHeight) {
        var _a2 = this, x2 = _a2.x, y2 = _a2.y, right = _a2.right, bottom = _a2.bottom;
        var clippedX = Math.max(x2, 0);
        var clippedY = Math.max(y2, 0);
        var newWidth = right - clippedX;
        var newHeight = bottom - clippedY;
        var clippedWidth = Math.min(newWidth, imgWidth - clippedX);
        var clippedHeight = Math.min(newHeight, imgHeight - clippedY);
        return new Box2({ x: clippedX, y: clippedY, width: clippedWidth, height: clippedHeight }).floor();
      };
      Box2.prototype.shift = function(sx, sy) {
        var _a2 = this, width = _a2.width, height = _a2.height;
        var x2 = this.x + sx;
        var y2 = this.y + sy;
        return new Box2({ x: x2, y: y2, width, height });
      };
      Box2.prototype.padAtBorders = function(imageHeight, imageWidth) {
        var w2 = this.width + 1;
        var h2 = this.height + 1;
        var dx = 1;
        var dy = 1;
        var edx = w2;
        var edy = h2;
        var x2 = this.left;
        var y2 = this.top;
        var ex = this.right;
        var ey = this.bottom;
        if (ex > imageWidth) {
          edx = -ex + imageWidth + w2;
          ex = imageWidth;
        }
        if (ey > imageHeight) {
          edy = -ey + imageHeight + h2;
          ey = imageHeight;
        }
        if (x2 < 1) {
          edy = 2 - x2;
          x2 = 1;
        }
        if (y2 < 1) {
          edy = 2 - y2;
          y2 = 1;
        }
        return { dy, edy, dx, edx, y: y2, ey, x: x2, ex, w: w2, h: h2 };
      };
      Box2.prototype.calibrate = function(region) {
        return new Box2({
          left: this.left + region.left * this.width,
          top: this.top + region.top * this.height,
          right: this.right + region.right * this.width,
          bottom: this.bottom + region.bottom * this.height
        }).toSquare().round();
      };
      return Box2;
    }();
  }
});

// node_modules/face-api.js/build/es6/classes/BoundingBox.js
var BoundingBox;
var init_BoundingBox = __esm({
  "node_modules/face-api.js/build/es6/classes/BoundingBox.js"() {
    "use strict";
    init_tslib_es62();
    init_Box();
    BoundingBox = /** @class */
    function(_super) {
      __extends(BoundingBox2, _super);
      function BoundingBox2(left, top, right, bottom, allowNegativeDimensions) {
        if (allowNegativeDimensions === void 0) {
          allowNegativeDimensions = false;
        }
        return _super.call(this, { left, top, right, bottom }, allowNegativeDimensions) || this;
      }
      return BoundingBox2;
    }(Box);
  }
});

// node_modules/face-api.js/build/es6/classes/ObjectDetection.js
var ObjectDetection;
var init_ObjectDetection = __esm({
  "node_modules/face-api.js/build/es6/classes/ObjectDetection.js"() {
    "use strict";
    init_Box();
    init_Dimensions();
    ObjectDetection = /** @class */
    function() {
      function ObjectDetection2(score, classScore, className, relativeBox, imageDims) {
        this._imageDims = new Dimensions(imageDims.width, imageDims.height);
        this._score = score;
        this._classScore = classScore;
        this._className = className;
        this._box = new Box(relativeBox).rescale(this._imageDims);
      }
      Object.defineProperty(ObjectDetection2.prototype, "score", {
        get: function() {
          return this._score;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ObjectDetection2.prototype, "classScore", {
        get: function() {
          return this._classScore;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ObjectDetection2.prototype, "className", {
        get: function() {
          return this._className;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ObjectDetection2.prototype, "box", {
        get: function() {
          return this._box;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ObjectDetection2.prototype, "imageDims", {
        get: function() {
          return this._imageDims;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ObjectDetection2.prototype, "imageWidth", {
        get: function() {
          return this.imageDims.width;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ObjectDetection2.prototype, "imageHeight", {
        get: function() {
          return this.imageDims.height;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(ObjectDetection2.prototype, "relativeBox", {
        get: function() {
          return new Box(this._box).rescale(this.imageDims.reverse());
        },
        enumerable: true,
        configurable: true
      });
      ObjectDetection2.prototype.forSize = function(width, height) {
        return new ObjectDetection2(this.score, this.classScore, this.className, this.relativeBox, { width, height });
      };
      return ObjectDetection2;
    }();
  }
});

// node_modules/face-api.js/build/es6/classes/FaceDetection.js
var FaceDetection;
var init_FaceDetection = __esm({
  "node_modules/face-api.js/build/es6/classes/FaceDetection.js"() {
    "use strict";
    init_tslib_es62();
    init_ObjectDetection();
    FaceDetection = /** @class */
    function(_super) {
      __extends(FaceDetection2, _super);
      function FaceDetection2(score, relativeBox, imageDims) {
        return _super.call(this, score, score, "", relativeBox, imageDims) || this;
      }
      FaceDetection2.prototype.forSize = function(width, height) {
        var _a2 = _super.prototype.forSize.call(this, width, height), score = _a2.score, relativeBox = _a2.relativeBox, imageDims = _a2.imageDims;
        return new FaceDetection2(score, relativeBox, imageDims);
      };
      return FaceDetection2;
    }(ObjectDetection);
  }
});

// node_modules/face-api.js/build/es6/ops/iou.js
function iou(box1, box2, isIOU) {
  if (isIOU === void 0) {
    isIOU = true;
  }
  var width = Math.max(0, Math.min(box1.right, box2.right) - Math.max(box1.left, box2.left));
  var height = Math.max(0, Math.min(box1.bottom, box2.bottom) - Math.max(box1.top, box2.top));
  var interSection = width * height;
  return isIOU ? interSection / (box1.area + box2.area - interSection) : interSection / Math.min(box1.area, box2.area);
}
var init_iou = __esm({
  "node_modules/face-api.js/build/es6/ops/iou.js"() {
    "use strict";
  }
});

// node_modules/face-api.js/build/es6/ops/minBbox.js
function minBbox(pts) {
  var xs2 = pts.map(function(pt2) {
    return pt2.x;
  });
  var ys2 = pts.map(function(pt2) {
    return pt2.y;
  });
  var minX = xs2.reduce(function(min, x2) {
    return x2 < min ? x2 : min;
  }, Infinity);
  var minY = ys2.reduce(function(min, y2) {
    return y2 < min ? y2 : min;
  }, Infinity);
  var maxX = xs2.reduce(function(max, x2) {
    return max < x2 ? x2 : max;
  }, 0);
  var maxY = ys2.reduce(function(max, y2) {
    return max < y2 ? y2 : max;
  }, 0);
  return new BoundingBox(minX, minY, maxX, maxY);
}
var init_minBbox = __esm({
  "node_modules/face-api.js/build/es6/ops/minBbox.js"() {
    "use strict";
    init_classes();
  }
});

// node_modules/face-api.js/build/es6/ops/nonMaxSuppression.js
function nonMaxSuppression(boxes, scores, iouThreshold, isIOU) {
  if (isIOU === void 0) {
    isIOU = true;
  }
  var indicesSortedByScore = scores.map(function(score, boxIndex) {
    return { score, boxIndex };
  }).sort(function(c1, c2) {
    return c1.score - c2.score;
  }).map(function(c2) {
    return c2.boxIndex;
  });
  var pick = [];
  var _loop_1 = function() {
    var curr = indicesSortedByScore.pop();
    pick.push(curr);
    var indices = indicesSortedByScore;
    var outputs = [];
    for (var i2 = 0; i2 < indices.length; i2++) {
      var idx = indices[i2];
      var currBox = boxes[curr];
      var idxBox = boxes[idx];
      outputs.push(iou(currBox, idxBox, isIOU));
    }
    indicesSortedByScore = indicesSortedByScore.filter(function(_2, j2) {
      return outputs[j2] <= iouThreshold;
    });
  };
  while (indicesSortedByScore.length > 0) {
    _loop_1();
  }
  return pick;
}
var init_nonMaxSuppression = __esm({
  "node_modules/face-api.js/build/es6/ops/nonMaxSuppression.js"() {
    "use strict";
    init_iou();
  }
});

// node_modules/face-api.js/build/es6/ops/normalize.js
function normalize(x2, meanRgb) {
  return Ze(function() {
    var r2 = meanRgb[0], g2 = meanRgb[1], b2 = meanRgb[2];
    var avg_r = Hn(__spreadArrays(x2.shape.slice(0, 3), [1]), r2);
    var avg_g = Hn(__spreadArrays(x2.shape.slice(0, 3), [1]), g2);
    var avg_b = Hn(__spreadArrays(x2.shape.slice(0, 3), [1]), b2);
    var avg_rgb = Yn([avg_r, avg_g, avg_b], 3);
    return Cc(x2, avg_rgb);
  });
}
var init_normalize = __esm({
  "node_modules/face-api.js/build/es6/ops/normalize.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
  }
});

// node_modules/face-api.js/build/es6/ops/padToSquare.js
function padToSquare(imgTensor, isCenterImage) {
  if (isCenterImage === void 0) {
    isCenterImage = false;
  }
  return Ze(function() {
    var _a2 = imgTensor.shape.slice(1), height = _a2[0], width = _a2[1];
    if (height === width) {
      return imgTensor;
    }
    var dimDiff = Math.abs(height - width);
    var paddingAmount = Math.round(dimDiff * (isCenterImage ? 0.5 : 1));
    var paddingAxis = height > width ? 2 : 1;
    var createPaddingTensor = function(paddingAmount2) {
      var paddingTensorShape = imgTensor.shape.slice();
      paddingTensorShape[paddingAxis] = paddingAmount2;
      return Hn(paddingTensorShape, 0);
    };
    var paddingTensorAppend = createPaddingTensor(paddingAmount);
    var remainingPaddingAmount = dimDiff - paddingTensorAppend.shape[paddingAxis];
    var paddingTensorPrepend = isCenterImage && remainingPaddingAmount ? createPaddingTensor(remainingPaddingAmount) : null;
    var tensorsToStack = [
      paddingTensorPrepend,
      imgTensor,
      paddingTensorAppend
    ].filter(function(t2) {
      return !!t2;
    }).map(function(t2) {
      return t2.toFloat();
    });
    return Yn(tensorsToStack, paddingAxis);
  });
}
var init_padToSquare = __esm({
  "node_modules/face-api.js/build/es6/ops/padToSquare.js"() {
    "use strict";
    init_tf_core_esm();
  }
});

// node_modules/face-api.js/build/es6/ops/shuffleArray.js
var init_shuffleArray = __esm({
  "node_modules/face-api.js/build/es6/ops/shuffleArray.js"() {
    "use strict";
  }
});

// node_modules/face-api.js/build/es6/ops/index.js
function sigmoid(x2) {
  return 1 / (1 + Math.exp(-x2));
}
var init_ops = __esm({
  "node_modules/face-api.js/build/es6/ops/index.js"() {
    "use strict";
    init_iou();
    init_minBbox();
    init_nonMaxSuppression();
    init_normalize();
    init_padToSquare();
    init_shuffleArray();
  }
});

// node_modules/face-api.js/build/es6/classes/Rect.js
var Rect;
var init_Rect = __esm({
  "node_modules/face-api.js/build/es6/classes/Rect.js"() {
    "use strict";
    init_tslib_es62();
    init_Box();
    Rect = /** @class */
    function(_super) {
      __extends(Rect2, _super);
      function Rect2(x2, y2, width, height, allowNegativeDimensions) {
        if (allowNegativeDimensions === void 0) {
          allowNegativeDimensions = false;
        }
        return _super.call(this, { x: x2, y: y2, width, height }, allowNegativeDimensions) || this;
      }
      return Rect2;
    }(Box);
  }
});

// node_modules/face-api.js/build/es6/classes/FaceLandmarks.js
var relX, relY, relScale, FaceLandmarks;
var init_FaceLandmarks = __esm({
  "node_modules/face-api.js/build/es6/classes/FaceLandmarks.js"() {
    "use strict";
    init_ops();
    init_utils();
    init_Box();
    init_Dimensions();
    init_FaceDetection();
    init_Point();
    init_Rect();
    relX = 0.5;
    relY = 0.43;
    relScale = 0.45;
    FaceLandmarks = /** @class */
    function() {
      function FaceLandmarks2(relativeFaceLandmarkPositions, imgDims, shift) {
        if (shift === void 0) {
          shift = new Point(0, 0);
        }
        var width = imgDims.width, height = imgDims.height;
        this._imgDims = new Dimensions(width, height);
        this._shift = shift;
        this._positions = relativeFaceLandmarkPositions.map(function(pt2) {
          return pt2.mul(new Point(width, height)).add(shift);
        });
      }
      Object.defineProperty(FaceLandmarks2.prototype, "shift", {
        get: function() {
          return new Point(this._shift.x, this._shift.y);
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(FaceLandmarks2.prototype, "imageWidth", {
        get: function() {
          return this._imgDims.width;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(FaceLandmarks2.prototype, "imageHeight", {
        get: function() {
          return this._imgDims.height;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(FaceLandmarks2.prototype, "positions", {
        get: function() {
          return this._positions;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(FaceLandmarks2.prototype, "relativePositions", {
        get: function() {
          var _this = this;
          return this._positions.map(function(pt2) {
            return pt2.sub(_this._shift).div(new Point(_this.imageWidth, _this.imageHeight));
          });
        },
        enumerable: true,
        configurable: true
      });
      FaceLandmarks2.prototype.forSize = function(width, height) {
        return new this.constructor(this.relativePositions, { width, height });
      };
      FaceLandmarks2.prototype.shiftBy = function(x2, y2) {
        return new this.constructor(this.relativePositions, this._imgDims, new Point(x2, y2));
      };
      FaceLandmarks2.prototype.shiftByPoint = function(pt2) {
        return this.shiftBy(pt2.x, pt2.y);
      };
      FaceLandmarks2.prototype.align = function(detection, options) {
        if (options === void 0) {
          options = {};
        }
        if (detection) {
          var box = detection instanceof FaceDetection ? detection.box.floor() : new Box(detection);
          return this.shiftBy(box.x, box.y).align(null, options);
        }
        var _a2 = Object.assign({}, { useDlibAlignment: false, minBoxPadding: 0.2 }, options), useDlibAlignment = _a2.useDlibAlignment, minBoxPadding = _a2.minBoxPadding;
        if (useDlibAlignment) {
          return this.alignDlib();
        }
        return this.alignMinBbox(minBoxPadding);
      };
      FaceLandmarks2.prototype.alignDlib = function() {
        var centers = this.getRefPointsForAlignment();
        var leftEyeCenter = centers[0], rightEyeCenter = centers[1], mouthCenter = centers[2];
        var distToMouth = function(pt2) {
          return mouthCenter.sub(pt2).magnitude();
        };
        var eyeToMouthDist = (distToMouth(leftEyeCenter) + distToMouth(rightEyeCenter)) / 2;
        var size = Math.floor(eyeToMouthDist / relScale);
        var refPoint = getCenterPoint(centers);
        var x2 = Math.floor(Math.max(0, refPoint.x - relX * size));
        var y2 = Math.floor(Math.max(0, refPoint.y - relY * size));
        return new Rect(x2, y2, Math.min(size, this.imageWidth + x2), Math.min(size, this.imageHeight + y2));
      };
      FaceLandmarks2.prototype.alignMinBbox = function(padding) {
        var box = minBbox(this.positions);
        return box.pad(box.width * padding, box.height * padding);
      };
      FaceLandmarks2.prototype.getRefPointsForAlignment = function() {
        throw new Error("getRefPointsForAlignment not implemented by base class");
      };
      return FaceLandmarks2;
    }();
  }
});

// node_modules/face-api.js/build/es6/classes/FaceLandmarks5.js
var FaceLandmarks5;
var init_FaceLandmarks5 = __esm({
  "node_modules/face-api.js/build/es6/classes/FaceLandmarks5.js"() {
    "use strict";
    init_tslib_es62();
    init_utils();
    init_FaceLandmarks();
    FaceLandmarks5 = /** @class */
    function(_super) {
      __extends(FaceLandmarks52, _super);
      function FaceLandmarks52() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      FaceLandmarks52.prototype.getRefPointsForAlignment = function() {
        var pts = this.positions;
        return [
          pts[0],
          pts[1],
          getCenterPoint([pts[3], pts[4]])
        ];
      };
      return FaceLandmarks52;
    }(FaceLandmarks);
  }
});

// node_modules/face-api.js/build/es6/classes/FaceLandmarks68.js
var FaceLandmarks68;
var init_FaceLandmarks68 = __esm({
  "node_modules/face-api.js/build/es6/classes/FaceLandmarks68.js"() {
    "use strict";
    init_tslib_es62();
    init_utils();
    init_FaceLandmarks();
    FaceLandmarks68 = /** @class */
    function(_super) {
      __extends(FaceLandmarks682, _super);
      function FaceLandmarks682() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      FaceLandmarks682.prototype.getJawOutline = function() {
        return this.positions.slice(0, 17);
      };
      FaceLandmarks682.prototype.getLeftEyeBrow = function() {
        return this.positions.slice(17, 22);
      };
      FaceLandmarks682.prototype.getRightEyeBrow = function() {
        return this.positions.slice(22, 27);
      };
      FaceLandmarks682.prototype.getNose = function() {
        return this.positions.slice(27, 36);
      };
      FaceLandmarks682.prototype.getLeftEye = function() {
        return this.positions.slice(36, 42);
      };
      FaceLandmarks682.prototype.getRightEye = function() {
        return this.positions.slice(42, 48);
      };
      FaceLandmarks682.prototype.getMouth = function() {
        return this.positions.slice(48, 68);
      };
      FaceLandmarks682.prototype.getRefPointsForAlignment = function() {
        return [
          this.getLeftEye(),
          this.getRightEye(),
          this.getMouth()
        ].map(getCenterPoint);
      };
      return FaceLandmarks682;
    }(FaceLandmarks);
  }
});

// node_modules/face-api.js/build/es6/classes/FaceMatch.js
var FaceMatch;
var init_FaceMatch = __esm({
  "node_modules/face-api.js/build/es6/classes/FaceMatch.js"() {
    "use strict";
    init_utils();
    FaceMatch = /** @class */
    function() {
      function FaceMatch2(label, distance) {
        this._label = label;
        this._distance = distance;
      }
      Object.defineProperty(FaceMatch2.prototype, "label", {
        get: function() {
          return this._label;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(FaceMatch2.prototype, "distance", {
        get: function() {
          return this._distance;
        },
        enumerable: true,
        configurable: true
      });
      FaceMatch2.prototype.toString = function(withDistance) {
        if (withDistance === void 0) {
          withDistance = true;
        }
        return "" + this.label + (withDistance ? " (" + round2(this.distance) + ")" : "");
      };
      return FaceMatch2;
    }();
  }
});

// node_modules/face-api.js/build/es6/classes/LabeledBox.js
var LabeledBox;
var init_LabeledBox = __esm({
  "node_modules/face-api.js/build/es6/classes/LabeledBox.js"() {
    "use strict";
    init_tslib_es62();
    init_utils();
    init_Box();
    LabeledBox = /** @class */
    function(_super) {
      __extends(LabeledBox2, _super);
      function LabeledBox2(box, label) {
        var _this = _super.call(this, box) || this;
        _this._label = label;
        return _this;
      }
      LabeledBox2.assertIsValidLabeledBox = function(box, callee) {
        Box.assertIsValidBox(box, callee);
        if (!isValidNumber(box.label)) {
          throw new Error(callee + " - expected property label (" + box.label + ") to be a number");
        }
      };
      Object.defineProperty(LabeledBox2.prototype, "label", {
        get: function() {
          return this._label;
        },
        enumerable: true,
        configurable: true
      });
      return LabeledBox2;
    }(Box);
  }
});

// node_modules/face-api.js/build/es6/classes/LabeledFaceDescriptors.js
var LabeledFaceDescriptors;
var init_LabeledFaceDescriptors = __esm({
  "node_modules/face-api.js/build/es6/classes/LabeledFaceDescriptors.js"() {
    "use strict";
    LabeledFaceDescriptors = /** @class */
    function() {
      function LabeledFaceDescriptors2(label, descriptors) {
        if (!(typeof label === "string")) {
          throw new Error("LabeledFaceDescriptors - constructor expected label to be a string");
        }
        if (!Array.isArray(descriptors) || descriptors.some(function(desc) {
          return !(desc instanceof Float32Array);
        })) {
          throw new Error("LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array");
        }
        this._label = label;
        this._descriptors = descriptors;
      }
      Object.defineProperty(LabeledFaceDescriptors2.prototype, "label", {
        get: function() {
          return this._label;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(LabeledFaceDescriptors2.prototype, "descriptors", {
        get: function() {
          return this._descriptors;
        },
        enumerable: true,
        configurable: true
      });
      LabeledFaceDescriptors2.prototype.toJSON = function() {
        return {
          label: this.label,
          descriptors: this.descriptors.map(function(d2) {
            return Array.from(d2);
          })
        };
      };
      LabeledFaceDescriptors2.fromJSON = function(json) {
        var descriptors = json.descriptors.map(function(d2) {
          return new Float32Array(d2);
        });
        return new LabeledFaceDescriptors2(json.label, descriptors);
      };
      return LabeledFaceDescriptors2;
    }();
  }
});

// node_modules/face-api.js/build/es6/classes/PredictedBox.js
var PredictedBox;
var init_PredictedBox = __esm({
  "node_modules/face-api.js/build/es6/classes/PredictedBox.js"() {
    "use strict";
    init_tslib_es62();
    init_utils();
    init_LabeledBox();
    PredictedBox = /** @class */
    function(_super) {
      __extends(PredictedBox2, _super);
      function PredictedBox2(box, label, score, classScore) {
        var _this = _super.call(this, box, label) || this;
        _this._score = score;
        _this._classScore = classScore;
        return _this;
      }
      PredictedBox2.assertIsValidPredictedBox = function(box, callee) {
        LabeledBox.assertIsValidLabeledBox(box, callee);
        if (!isValidProbablitiy(box.score) || !isValidProbablitiy(box.classScore)) {
          throw new Error(callee + " - expected properties score (" + box.score + ") and (" + box.classScore + ") to be a number between [0, 1]");
        }
      };
      Object.defineProperty(PredictedBox2.prototype, "score", {
        get: function() {
          return this._score;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(PredictedBox2.prototype, "classScore", {
        get: function() {
          return this._classScore;
        },
        enumerable: true,
        configurable: true
      });
      return PredictedBox2;
    }(LabeledBox);
  }
});

// node_modules/face-api.js/build/es6/classes/index.js
var init_classes = __esm({
  "node_modules/face-api.js/build/es6/classes/index.js"() {
    "use strict";
    init_BoundingBox();
    init_Box();
    init_Dimensions();
    init_FaceDetection();
    init_FaceLandmarks();
    init_FaceLandmarks5();
    init_FaceLandmarks68();
    init_FaceMatch();
    init_LabeledBox();
    init_LabeledFaceDescriptors();
    init_ObjectDetection();
    init_Point();
    init_PredictedBox();
    init_Rect();
  }
});

// node_modules/face-api.js/build/es6/factories/WithFaceDetection.js
function isWithFaceDetection(obj) {
  return obj["detection"] instanceof FaceDetection;
}
function extendWithFaceDetection(sourceObj, detection) {
  var extension = { detection };
  return Object.assign({}, sourceObj, extension);
}
var init_WithFaceDetection = __esm({
  "node_modules/face-api.js/build/es6/factories/WithFaceDetection.js"() {
    "use strict";
    init_FaceDetection();
  }
});

// node_modules/face-api.js/build/es6/env/createBrowserEnv.js
function createBrowserEnv() {
  var fetch2 = window["fetch"] || function() {
    throw new Error("fetch - missing fetch implementation for browser environment");
  };
  var readFile = function() {
    throw new Error("readFile - filesystem not available for browser environment");
  };
  return {
    Canvas: HTMLCanvasElement,
    CanvasRenderingContext2D,
    Image: HTMLImageElement,
    ImageData,
    Video: HTMLVideoElement,
    createCanvasElement: function() {
      return document.createElement("canvas");
    },
    createImageElement: function() {
      return document.createElement("img");
    },
    fetch: fetch2,
    readFile
  };
}
var init_createBrowserEnv = __esm({
  "node_modules/face-api.js/build/es6/env/createBrowserEnv.js"() {
    "use strict";
  }
});

// node_modules/face-api.js/build/es6/env/createFileSystem.js
function createFileSystem(fs2) {
  var requireFsError = "";
  if (!fs2) {
    try {
      fs2 = __require("fs");
    } catch (err) {
      requireFsError = err.toString();
    }
  }
  var readFile = fs2 ? function(filePath) {
    return new Promise(function(res, rej) {
      fs2.readFile(filePath, function(err, buffer) {
        return err ? rej(err) : res(buffer);
      });
    });
  } : function() {
    throw new Error("readFile - failed to require fs in nodejs environment with error: " + requireFsError);
  };
  return {
    readFile
  };
}
var init_createFileSystem = __esm({
  "node_modules/face-api.js/build/es6/env/createFileSystem.js"() {
    "use strict";
  }
});

// node_modules/face-api.js/build/es6/env/createNodejsEnv.js
function createNodejsEnv() {
  var Canvas = global["Canvas"] || global["HTMLCanvasElement"];
  var Image = global["Image"] || global["HTMLImageElement"];
  var createCanvasElement = function() {
    if (Canvas) {
      return new Canvas();
    }
    throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment");
  };
  var createImageElement = function() {
    if (Image) {
      return new Image();
    }
    throw new Error("createImageElement - missing Image implementation for nodejs environment");
  };
  var fetch2 = global["fetch"] || function() {
    throw new Error("fetch - missing fetch implementation for nodejs environment");
  };
  var fileSystem = createFileSystem();
  return __assign({
    Canvas: Canvas || /** @class */
    /* @__PURE__ */ function() {
      function Canvas2() {
      }
      return Canvas2;
    }(),
    CanvasRenderingContext2D: global["CanvasRenderingContext2D"] || /** @class */
    /* @__PURE__ */ function() {
      function class_1() {
      }
      return class_1;
    }(),
    Image: Image || /** @class */
    /* @__PURE__ */ function() {
      function Image2() {
      }
      return Image2;
    }(),
    ImageData: global["ImageData"] || /** @class */
    /* @__PURE__ */ function() {
      function class_2() {
      }
      return class_2;
    }(),
    Video: global["HTMLVideoElement"] || /** @class */
    /* @__PURE__ */ function() {
      function class_3() {
      }
      return class_3;
    }(),
    createCanvasElement,
    createImageElement,
    fetch: fetch2
  }, fileSystem);
}
var init_createNodejsEnv = __esm({
  "node_modules/face-api.js/build/es6/env/createNodejsEnv.js"() {
    "use strict";
    init_tslib_es62();
    init_createFileSystem();
  }
});

// node_modules/face-api.js/build/es6/env/isBrowser.js
function isBrowser() {
  return typeof window === "object" && typeof document !== "undefined" && typeof HTMLImageElement !== "undefined" && typeof HTMLCanvasElement !== "undefined" && typeof HTMLVideoElement !== "undefined" && typeof ImageData !== "undefined" && typeof CanvasRenderingContext2D !== "undefined";
}
var init_isBrowser = __esm({
  "node_modules/face-api.js/build/es6/env/isBrowser.js"() {
    "use strict";
  }
});

// node_modules/face-api.js/build/es6/env/isNodejs.js
function isNodejs() {
  return typeof global === "object" && typeof __require === "function" && typeof module !== "undefined" && typeof process !== "undefined" && !!process.version;
}
var init_isNodejs = __esm({
  "node_modules/face-api.js/build/es6/env/isNodejs.js"() {
    "use strict";
  }
});

// node_modules/face-api.js/build/es6/env/index.js
function getEnv() {
  if (!environment) {
    throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");
  }
  return environment;
}
function setEnv(env2) {
  environment = env2;
}
function initialize() {
  if (isBrowser()) {
    setEnv(createBrowserEnv());
  }
  if (isNodejs()) {
    setEnv(createNodejsEnv());
  }
}
function monkeyPatch(env2) {
  if (!environment) {
    initialize();
  }
  if (!environment) {
    throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");
  }
  var _a2 = env2.Canvas, Canvas = _a2 === void 0 ? environment.Canvas : _a2, _b = env2.Image, Image = _b === void 0 ? environment.Image : _b;
  environment.Canvas = Canvas;
  environment.Image = Image;
  environment.createCanvasElement = env2.createCanvasElement || function() {
    return new Canvas();
  };
  environment.createImageElement = env2.createImageElement || function() {
    return new Image();
  };
  environment.ImageData = env2.ImageData || environment.ImageData;
  environment.Video = env2.Video || environment.Video;
  environment.fetch = env2.fetch || environment.fetch;
  environment.readFile = env2.readFile || environment.readFile;
}
var environment, env;
var init_env = __esm({
  "node_modules/face-api.js/build/es6/env/index.js"() {
    "use strict";
    init_createBrowserEnv();
    init_createFileSystem();
    init_createNodejsEnv();
    init_isBrowser();
    init_isNodejs();
    env = {
      getEnv,
      setEnv,
      initialize,
      createBrowserEnv,
      createFileSystem,
      createNodejsEnv,
      monkeyPatch,
      isBrowser,
      isNodejs
    };
    initialize();
  }
});

// node_modules/face-api.js/build/es6/dom/resolveInput.js
function resolveInput(arg) {
  if (!env.isNodejs() && typeof arg === "string") {
    return document.getElementById(arg);
  }
  return arg;
}
var init_resolveInput = __esm({
  "node_modules/face-api.js/build/es6/dom/resolveInput.js"() {
    "use strict";
    init_env();
  }
});

// node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js
function getContext2dOrThrow(canvasArg) {
  var _a2 = env.getEnv(), Canvas = _a2.Canvas, CanvasRenderingContext2D2 = _a2.CanvasRenderingContext2D;
  if (canvasArg instanceof CanvasRenderingContext2D2) {
    return canvasArg;
  }
  var canvas = resolveInput(canvasArg);
  if (!(canvas instanceof Canvas)) {
    throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");
  }
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    throw new Error("resolveContext2d - canvas 2d context is null");
  }
  return ctx;
}
var init_getContext2dOrThrow = __esm({
  "node_modules/face-api.js/build/es6/dom/getContext2dOrThrow.js"() {
    "use strict";
    init_env();
    init_resolveInput();
  }
});

// node_modules/face-api.js/build/es6/draw/DrawTextField.js
var AnchorPosition, DrawTextFieldOptions, DrawTextField;
var init_DrawTextField = __esm({
  "node_modules/face-api.js/build/es6/draw/DrawTextField.js"() {
    "use strict";
    init_getContext2dOrThrow();
    init_resolveInput();
    (function(AnchorPosition2) {
      AnchorPosition2["TOP_LEFT"] = "TOP_LEFT";
      AnchorPosition2["TOP_RIGHT"] = "TOP_RIGHT";
      AnchorPosition2["BOTTOM_LEFT"] = "BOTTOM_LEFT";
      AnchorPosition2["BOTTOM_RIGHT"] = "BOTTOM_RIGHT";
    })(AnchorPosition || (AnchorPosition = {}));
    DrawTextFieldOptions = /** @class */
    /* @__PURE__ */ function() {
      function DrawTextFieldOptions2(options) {
        if (options === void 0) {
          options = {};
        }
        var anchorPosition = options.anchorPosition, backgroundColor = options.backgroundColor, fontColor = options.fontColor, fontSize = options.fontSize, fontStyle = options.fontStyle, padding = options.padding;
        this.anchorPosition = anchorPosition || AnchorPosition.TOP_LEFT;
        this.backgroundColor = backgroundColor || "rgba(0, 0, 0, 0.5)";
        this.fontColor = fontColor || "rgba(255, 255, 255, 1)";
        this.fontSize = fontSize || 14;
        this.fontStyle = fontStyle || "Georgia";
        this.padding = padding || 4;
      }
      return DrawTextFieldOptions2;
    }();
    DrawTextField = /** @class */
    function() {
      function DrawTextField2(text, anchor, options) {
        if (options === void 0) {
          options = {};
        }
        this.text = typeof text === "string" ? [text] : text instanceof DrawTextField2 ? text.text : text;
        this.anchor = anchor;
        this.options = new DrawTextFieldOptions(options);
      }
      DrawTextField2.prototype.measureWidth = function(ctx) {
        var padding = this.options.padding;
        return this.text.map(function(l2) {
          return ctx.measureText(l2).width;
        }).reduce(function(w0, w1) {
          return w0 < w1 ? w1 : w0;
        }, 0) + 2 * padding;
      };
      DrawTextField2.prototype.measureHeight = function() {
        var _a2 = this.options, fontSize = _a2.fontSize, padding = _a2.padding;
        return this.text.length * fontSize + 2 * padding;
      };
      DrawTextField2.prototype.getUpperLeft = function(ctx, canvasDims) {
        var anchorPosition = this.options.anchorPosition;
        var isShiftLeft = anchorPosition === AnchorPosition.BOTTOM_RIGHT || anchorPosition === AnchorPosition.TOP_RIGHT;
        var isShiftTop = anchorPosition === AnchorPosition.BOTTOM_LEFT || anchorPosition === AnchorPosition.BOTTOM_RIGHT;
        var textFieldWidth = this.measureWidth(ctx);
        var textFieldHeight = this.measureHeight();
        var x2 = isShiftLeft ? this.anchor.x - textFieldWidth : this.anchor.x;
        var y2 = isShiftTop ? this.anchor.y - textFieldHeight : this.anchor.y;
        if (canvasDims) {
          var width = canvasDims.width, height = canvasDims.height;
          var newX = Math.max(Math.min(x2, width - textFieldWidth), 0);
          var newY = Math.max(Math.min(y2, height - textFieldHeight), 0);
          return { x: newX, y: newY };
        }
        return { x: x2, y: y2 };
      };
      DrawTextField2.prototype.draw = function(canvasArg) {
        var canvas = resolveInput(canvasArg);
        var ctx = getContext2dOrThrow(canvas);
        var _a2 = this.options, backgroundColor = _a2.backgroundColor, fontColor = _a2.fontColor, fontSize = _a2.fontSize, fontStyle = _a2.fontStyle, padding = _a2.padding;
        ctx.font = fontSize + "px " + fontStyle;
        var maxTextWidth = this.measureWidth(ctx);
        var textHeight = this.measureHeight();
        ctx.fillStyle = backgroundColor;
        var upperLeft = this.getUpperLeft(ctx, canvas);
        ctx.fillRect(upperLeft.x, upperLeft.y, maxTextWidth, textHeight);
        ctx.fillStyle = fontColor;
        this.text.forEach(function(textLine, i2) {
          var x2 = padding + upperLeft.x;
          var y2 = padding + upperLeft.y + (i2 + 1) * fontSize;
          ctx.fillText(textLine, x2, y2);
        });
      };
      return DrawTextField2;
    }();
  }
});

// node_modules/face-api.js/build/es6/draw/DrawBox.js
var DrawBoxOptions, DrawBox;
var init_DrawBox = __esm({
  "node_modules/face-api.js/build/es6/draw/DrawBox.js"() {
    "use strict";
    init_classes();
    init_getContext2dOrThrow();
    init_DrawTextField();
    DrawBoxOptions = /** @class */
    /* @__PURE__ */ function() {
      function DrawBoxOptions2(options) {
        if (options === void 0) {
          options = {};
        }
        var boxColor = options.boxColor, lineWidth = options.lineWidth, label = options.label, drawLabelOptions = options.drawLabelOptions;
        this.boxColor = boxColor || "rgba(0, 0, 255, 1)";
        this.lineWidth = lineWidth || 2;
        this.label = label;
        var defaultDrawLabelOptions = {
          anchorPosition: AnchorPosition.BOTTOM_LEFT,
          backgroundColor: this.boxColor
        };
        this.drawLabelOptions = new DrawTextFieldOptions(Object.assign({}, defaultDrawLabelOptions, drawLabelOptions));
      }
      return DrawBoxOptions2;
    }();
    DrawBox = /** @class */
    function() {
      function DrawBox2(box, options) {
        if (options === void 0) {
          options = {};
        }
        this.box = new Box(box);
        this.options = new DrawBoxOptions(options);
      }
      DrawBox2.prototype.draw = function(canvasArg) {
        var ctx = getContext2dOrThrow(canvasArg);
        var _a2 = this.options, boxColor = _a2.boxColor, lineWidth = _a2.lineWidth;
        var _b = this.box, x2 = _b.x, y2 = _b.y, width = _b.width, height = _b.height;
        ctx.strokeStyle = boxColor;
        ctx.lineWidth = lineWidth;
        ctx.strokeRect(x2, y2, width, height);
        var label = this.options.label;
        if (label) {
          new DrawTextField([label], { x: x2 - lineWidth / 2, y: y2 }, this.options.drawLabelOptions).draw(canvasArg);
        }
      };
      return DrawBox2;
    }();
  }
});

// node_modules/face-api.js/build/es6/draw/drawDetections.js
function drawDetections(canvasArg, detections) {
  var detectionsArray = Array.isArray(detections) ? detections : [detections];
  detectionsArray.forEach(function(det) {
    var score = det instanceof FaceDetection ? det.score : isWithFaceDetection(det) ? det.detection.score : void 0;
    var box = det instanceof FaceDetection ? det.box : isWithFaceDetection(det) ? det.detection.box : new Box(det);
    var label = score ? "" + round2(score) : void 0;
    new DrawBox(box, { label }).draw(canvasArg);
  });
}
var init_drawDetections = __esm({
  "node_modules/face-api.js/build/es6/draw/drawDetections.js"() {
    "use strict";
    init_classes();
    init_FaceDetection();
    init_WithFaceDetection();
    init_utils();
    init_DrawBox();
  }
});

// node_modules/face-api.js/build/es6/dom/isMediaLoaded.js
function isMediaLoaded(media) {
  var _a2 = env.getEnv(), Image = _a2.Image, Video = _a2.Video;
  return media instanceof Image && media.complete || media instanceof Video && media.readyState >= 3;
}
var init_isMediaLoaded = __esm({
  "node_modules/face-api.js/build/es6/dom/isMediaLoaded.js"() {
    "use strict";
    init_env();
  }
});

// node_modules/face-api.js/build/es6/dom/awaitMediaLoaded.js
function awaitMediaLoaded(media) {
  return new Promise(function(resolve, reject) {
    if (media instanceof env.getEnv().Canvas || isMediaLoaded(media)) {
      return resolve();
    }
    function onLoad(e2) {
      if (!e2.currentTarget)
        return;
      e2.currentTarget.removeEventListener("load", onLoad);
      e2.currentTarget.removeEventListener("error", onError);
      resolve(e2);
    }
    function onError(e2) {
      if (!e2.currentTarget)
        return;
      e2.currentTarget.removeEventListener("load", onLoad);
      e2.currentTarget.removeEventListener("error", onError);
      reject(e2);
    }
    media.addEventListener("load", onLoad);
    media.addEventListener("error", onError);
  });
}
var init_awaitMediaLoaded = __esm({
  "node_modules/face-api.js/build/es6/dom/awaitMediaLoaded.js"() {
    "use strict";
    init_env();
    init_isMediaLoaded();
  }
});

// node_modules/face-api.js/build/es6/dom/bufferToImage.js
var init_bufferToImage = __esm({
  "node_modules/face-api.js/build/es6/dom/bufferToImage.js"() {
    "use strict";
    init_env();
  }
});

// node_modules/face-api.js/build/es6/dom/getMediaDimensions.js
function getMediaDimensions(input2) {
  var _a2 = env.getEnv(), Image = _a2.Image, Video = _a2.Video;
  if (input2 instanceof Image) {
    return new Dimensions(input2.naturalWidth, input2.naturalHeight);
  }
  if (input2 instanceof Video) {
    return new Dimensions(input2.videoWidth, input2.videoHeight);
  }
  return new Dimensions(input2.width, input2.height);
}
var init_getMediaDimensions = __esm({
  "node_modules/face-api.js/build/es6/dom/getMediaDimensions.js"() {
    "use strict";
    init_Dimensions();
    init_env();
  }
});

// node_modules/face-api.js/build/es6/dom/createCanvas.js
function createCanvas(_a2) {
  var width = _a2.width, height = _a2.height;
  var createCanvasElement = env.getEnv().createCanvasElement;
  var canvas = createCanvasElement();
  canvas.width = width;
  canvas.height = height;
  return canvas;
}
function createCanvasFromMedia(media, dims) {
  var ImageData2 = env.getEnv().ImageData;
  if (!(media instanceof ImageData2) && !isMediaLoaded(media)) {
    throw new Error("createCanvasFromMedia - media has not finished loading yet");
  }
  var _a2 = dims || getMediaDimensions(media), width = _a2.width, height = _a2.height;
  var canvas = createCanvas({ width, height });
  if (media instanceof ImageData2) {
    getContext2dOrThrow(canvas).putImageData(media, 0, 0);
  } else {
    getContext2dOrThrow(canvas).drawImage(media, 0, 0, width, height);
  }
  return canvas;
}
var init_createCanvas = __esm({
  "node_modules/face-api.js/build/es6/dom/createCanvas.js"() {
    "use strict";
    init_env();
    init_getContext2dOrThrow();
    init_getMediaDimensions();
    init_isMediaLoaded();
  }
});

// node_modules/face-api.js/build/es6/dom/imageTensorToCanvas.js
function imageTensorToCanvas(imgTensor, canvas) {
  return __awaiter2(this, void 0, void 0, function() {
    var targetCanvas, _a2, height, width, numChannels, imgTensor3D;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          targetCanvas = canvas || env.getEnv().createCanvasElement();
          _a2 = imgTensor.shape.slice(isTensor4D(imgTensor) ? 1 : 0), height = _a2[0], width = _a2[1], numChannels = _a2[2];
          imgTensor3D = Ze(function() {
            return imgTensor.as3D(height, width, numChannels).toInt();
          });
          return [4, id.toPixels(imgTensor3D, targetCanvas)];
        case 1:
          _b.sent();
          imgTensor3D.dispose();
          return [2, targetCanvas];
      }
    });
  });
}
var init_imageTensorToCanvas = __esm({
  "node_modules/face-api.js/build/es6/dom/imageTensorToCanvas.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_env();
    init_utils();
  }
});

// node_modules/face-api.js/build/es6/dom/isMediaElement.js
function isMediaElement(input2) {
  var _a2 = env.getEnv(), Image = _a2.Image, Canvas = _a2.Canvas, Video = _a2.Video;
  return input2 instanceof Image || input2 instanceof Canvas || input2 instanceof Video;
}
var init_isMediaElement = __esm({
  "node_modules/face-api.js/build/es6/dom/isMediaElement.js"() {
    "use strict";
    init_env();
  }
});

// node_modules/face-api.js/build/es6/dom/imageToSquare.js
function imageToSquare(input2, inputSize, centerImage) {
  if (centerImage === void 0) {
    centerImage = false;
  }
  var _a2 = env.getEnv(), Image = _a2.Image, Canvas = _a2.Canvas;
  if (!(input2 instanceof Image || input2 instanceof Canvas)) {
    throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");
  }
  var dims = getMediaDimensions(input2);
  var scale2 = inputSize / Math.max(dims.height, dims.width);
  var width = scale2 * dims.width;
  var height = scale2 * dims.height;
  var targetCanvas = createCanvas({ width: inputSize, height: inputSize });
  var inputCanvas = input2 instanceof Canvas ? input2 : createCanvasFromMedia(input2);
  var offset = Math.abs(width - height) / 2;
  var dx = centerImage && width < height ? offset : 0;
  var dy = centerImage && height < width ? offset : 0;
  getContext2dOrThrow(targetCanvas).drawImage(inputCanvas, dx, dy, width, height);
  return targetCanvas;
}
var init_imageToSquare = __esm({
  "node_modules/face-api.js/build/es6/dom/imageToSquare.js"() {
    "use strict";
    init_env();
    init_createCanvas();
    init_getContext2dOrThrow();
    init_getMediaDimensions();
  }
});

// node_modules/face-api.js/build/es6/dom/NetInput.js
var NetInput;
var init_NetInput = __esm({
  "node_modules/face-api.js/build/es6/dom/NetInput.js"() {
    "use strict";
    init_tf_core_esm();
    init_env();
    init_padToSquare();
    init_utils();
    init_createCanvas();
    init_imageToSquare();
    NetInput = /** @class */
    function() {
      function NetInput2(inputs, treatAsBatchInput) {
        var _this = this;
        if (treatAsBatchInput === void 0) {
          treatAsBatchInput = false;
        }
        this._imageTensors = [];
        this._canvases = [];
        this._treatAsBatchInput = false;
        this._inputDimensions = [];
        if (!Array.isArray(inputs)) {
          throw new Error("NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have " + inputs);
        }
        this._treatAsBatchInput = treatAsBatchInput;
        this._batchSize = inputs.length;
        inputs.forEach(function(input2, idx) {
          if (isTensor3D(input2)) {
            _this._imageTensors[idx] = input2;
            _this._inputDimensions[idx] = input2.shape;
            return;
          }
          if (isTensor4D(input2)) {
            var batchSize = input2.shape[0];
            if (batchSize !== 1) {
              throw new Error("NetInput - tf.Tensor4D with batchSize " + batchSize + " passed, but not supported in input array");
            }
            _this._imageTensors[idx] = input2;
            _this._inputDimensions[idx] = input2.shape.slice(1);
            return;
          }
          var canvas = input2 instanceof env.getEnv().Canvas ? input2 : createCanvasFromMedia(input2);
          _this._canvases[idx] = canvas;
          _this._inputDimensions[idx] = [canvas.height, canvas.width, 3];
        });
      }
      Object.defineProperty(NetInput2.prototype, "imageTensors", {
        get: function() {
          return this._imageTensors;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(NetInput2.prototype, "canvases", {
        get: function() {
          return this._canvases;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(NetInput2.prototype, "isBatchInput", {
        get: function() {
          return this.batchSize > 1 || this._treatAsBatchInput;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(NetInput2.prototype, "batchSize", {
        get: function() {
          return this._batchSize;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(NetInput2.prototype, "inputDimensions", {
        get: function() {
          return this._inputDimensions;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(NetInput2.prototype, "inputSize", {
        get: function() {
          return this._inputSize;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(NetInput2.prototype, "reshapedInputDimensions", {
        get: function() {
          var _this = this;
          return range(this.batchSize, 0, 1).map(function(_2, batchIdx) {
            return _this.getReshapedInputDimensions(batchIdx);
          });
        },
        enumerable: true,
        configurable: true
      });
      NetInput2.prototype.getInput = function(batchIdx) {
        return this.canvases[batchIdx] || this.imageTensors[batchIdx];
      };
      NetInput2.prototype.getInputDimensions = function(batchIdx) {
        return this._inputDimensions[batchIdx];
      };
      NetInput2.prototype.getInputHeight = function(batchIdx) {
        return this._inputDimensions[batchIdx][0];
      };
      NetInput2.prototype.getInputWidth = function(batchIdx) {
        return this._inputDimensions[batchIdx][1];
      };
      NetInput2.prototype.getReshapedInputDimensions = function(batchIdx) {
        if (typeof this.inputSize !== "number") {
          throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");
        }
        var width = this.getInputWidth(batchIdx);
        var height = this.getInputHeight(batchIdx);
        return computeReshapedDimensions({ width, height }, this.inputSize);
      };
      NetInput2.prototype.toBatchTensor = function(inputSize, isCenterInputs) {
        var _this = this;
        if (isCenterInputs === void 0) {
          isCenterInputs = true;
        }
        this._inputSize = inputSize;
        return Ze(function() {
          var inputTensors = range(_this.batchSize, 0, 1).map(function(batchIdx) {
            var input2 = _this.getInput(batchIdx);
            if (input2 instanceof wt) {
              var imgTensor = isTensor4D(input2) ? input2 : input2.expandDims();
              imgTensor = padToSquare(imgTensor, isCenterInputs);
              if (imgTensor.shape[1] !== inputSize || imgTensor.shape[2] !== inputSize) {
                imgTensor = Oh.resizeBilinear(imgTensor, [inputSize, inputSize]);
              }
              return imgTensor.as3D(inputSize, inputSize, 3);
            }
            if (input2 instanceof env.getEnv().Canvas) {
              return id.fromPixels(imageToSquare(input2, inputSize, isCenterInputs));
            }
            throw new Error("toBatchTensor - at batchIdx " + batchIdx + ", expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have " + input2);
          });
          var batchTensor = Pr(inputTensors.map(function(t2) {
            return t2.toFloat();
          })).as4D(_this.batchSize, inputSize, inputSize, 3);
          return batchTensor;
        });
      };
      return NetInput2;
    }();
  }
});

// node_modules/face-api.js/build/es6/dom/toNetInput.js
function toNetInput(inputs) {
  return __awaiter2(this, void 0, void 0, function() {
    var inputArgArray, getIdxHint, inputArray;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          if (inputs instanceof NetInput) {
            return [2, inputs];
          }
          inputArgArray = Array.isArray(inputs) ? inputs : [inputs];
          if (!inputArgArray.length) {
            throw new Error("toNetInput - empty array passed as input");
          }
          getIdxHint = function(idx) {
            return Array.isArray(inputs) ? " at input index " + idx + ":" : "";
          };
          inputArray = inputArgArray.map(resolveInput);
          inputArray.forEach(function(input2, i2) {
            if (!isMediaElement(input2) && !isTensor3D(input2) && !isTensor4D(input2)) {
              if (typeof inputArgArray[i2] === "string") {
                throw new Error("toNetInput -" + getIdxHint(i2) + " string passed, but could not resolve HTMLElement for element id " + inputArgArray[i2]);
              }
              throw new Error("toNetInput -" + getIdxHint(i2) + " expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id");
            }
            if (isTensor4D(input2)) {
              var batchSize = input2.shape[0];
              if (batchSize !== 1) {
                throw new Error("toNetInput -" + getIdxHint(i2) + " tf.Tensor4D with batchSize " + batchSize + " passed, but not supported in input array");
              }
            }
          });
          return [4, Promise.all(inputArray.map(function(input2) {
            return isMediaElement(input2) && awaitMediaLoaded(input2);
          }))];
        case 1:
          _a2.sent();
          return [2, new NetInput(inputArray, Array.isArray(inputs))];
      }
    });
  });
}
var init_toNetInput = __esm({
  "node_modules/face-api.js/build/es6/dom/toNetInput.js"() {
    "use strict";
    init_tslib_es62();
    init_utils();
    init_awaitMediaLoaded();
    init_isMediaElement();
    init_NetInput();
    init_resolveInput();
  }
});

// node_modules/face-api.js/build/es6/dom/extractFaces.js
function extractFaces(input2, detections) {
  return __awaiter2(this, void 0, void 0, function() {
    var Canvas, canvas, netInput, tensorOrCanvas, _a2, ctx, boxes;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          Canvas = env.getEnv().Canvas;
          canvas = input2;
          if (!!(input2 instanceof Canvas)) return [3, 5];
          return [4, toNetInput(input2)];
        case 1:
          netInput = _b.sent();
          if (netInput.batchSize > 1) {
            throw new Error("extractFaces - batchSize > 1 not supported");
          }
          tensorOrCanvas = netInput.getInput(0);
          if (!(tensorOrCanvas instanceof Canvas)) return [3, 2];
          _a2 = tensorOrCanvas;
          return [3, 4];
        case 2:
          return [4, imageTensorToCanvas(tensorOrCanvas)];
        case 3:
          _a2 = _b.sent();
          _b.label = 4;
        case 4:
          canvas = _a2;
          _b.label = 5;
        case 5:
          ctx = getContext2dOrThrow(canvas);
          boxes = detections.map(function(det) {
            return det instanceof FaceDetection ? det.forSize(canvas.width, canvas.height).box.floor() : det;
          }).map(function(box) {
            return box.clipAtImageBorders(canvas.width, canvas.height);
          });
          return [2, boxes.map(function(_a3) {
            var x2 = _a3.x, y2 = _a3.y, width = _a3.width, height = _a3.height;
            var faceImg = createCanvas({ width, height });
            getContext2dOrThrow(faceImg).putImageData(ctx.getImageData(x2, y2, width, height), 0, 0);
            return faceImg;
          })];
      }
    });
  });
}
var init_extractFaces = __esm({
  "node_modules/face-api.js/build/es6/dom/extractFaces.js"() {
    "use strict";
    init_tslib_es62();
    init_FaceDetection();
    init_env();
    init_createCanvas();
    init_getContext2dOrThrow();
    init_imageTensorToCanvas();
    init_toNetInput();
  }
});

// node_modules/face-api.js/build/es6/dom/extractFaceTensors.js
function extractFaceTensors(imageTensor, detections) {
  return __awaiter2(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      if (!isTensor3D(imageTensor) && !isTensor4D(imageTensor)) {
        throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");
      }
      if (isTensor4D(imageTensor) && imageTensor.shape[0] > 1) {
        throw new Error("extractFaceTensors - batchSize > 1 not supported");
      }
      return [2, Ze(function() {
        var _a3 = imageTensor.shape.slice(isTensor4D(imageTensor) ? 1 : 0), imgHeight = _a3[0], imgWidth = _a3[1], numChannels = _a3[2];
        var boxes = detections.map(function(det) {
          return det instanceof FaceDetection ? det.forSize(imgWidth, imgHeight).box : det;
        }).map(function(box) {
          return box.clipAtImageBorders(imgWidth, imgHeight);
        });
        var faceTensors = boxes.map(function(_a4) {
          var x2 = _a4.x, y2 = _a4.y, width = _a4.width, height = _a4.height;
          return xl(imageTensor.as3D(imgHeight, imgWidth, numChannels), [y2, x2, 0], [height, width, numChannels]);
        });
        return faceTensors;
      })];
    });
  });
}
var init_extractFaceTensors = __esm({
  "node_modules/face-api.js/build/es6/dom/extractFaceTensors.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_FaceDetection();
    init_utils();
  }
});

// node_modules/face-api.js/build/es6/dom/fetchOrThrow.js
function fetchOrThrow(url, init) {
  return __awaiter2(this, void 0, void 0, function() {
    var fetch2, res;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          fetch2 = env.getEnv().fetch;
          return [4, fetch2(url, init)];
        case 1:
          res = _a2.sent();
          if (!(res.status < 400)) {
            throw new Error("failed to fetch: (" + res.status + ") " + res.statusText + ", from url: " + res.url);
          }
          return [2, res];
      }
    });
  });
}
var init_fetchOrThrow = __esm({
  "node_modules/face-api.js/build/es6/dom/fetchOrThrow.js"() {
    "use strict";
    init_tslib_es62();
    init_env();
  }
});

// node_modules/face-api.js/build/es6/dom/fetchImage.js
var init_fetchImage = __esm({
  "node_modules/face-api.js/build/es6/dom/fetchImage.js"() {
    "use strict";
    init_bufferToImage();
    init_fetchOrThrow();
  }
});

// node_modules/face-api.js/build/es6/dom/fetchJson.js
function fetchJson(uri) {
  return __awaiter2(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          return [4, fetchOrThrow(uri)];
        case 1:
          return [2, _a2.sent().json()];
      }
    });
  });
}
var init_fetchJson = __esm({
  "node_modules/face-api.js/build/es6/dom/fetchJson.js"() {
    "use strict";
    init_tslib_es62();
    init_fetchOrThrow();
  }
});

// node_modules/face-api.js/build/es6/dom/fetchNetWeights.js
var init_fetchNetWeights = __esm({
  "node_modules/face-api.js/build/es6/dom/fetchNetWeights.js"() {
    "use strict";
    init_fetchOrThrow();
  }
});

// node_modules/face-api.js/build/es6/common/getModelUris.js
function getModelUris(uri, defaultModelName) {
  var defaultManifestFilename = defaultModelName + "-weights_manifest.json";
  if (!uri) {
    return {
      modelBaseUri: "",
      manifestUri: defaultManifestFilename
    };
  }
  if (uri === "/") {
    return {
      modelBaseUri: "/",
      manifestUri: "/" + defaultManifestFilename
    };
  }
  var protocol = uri.startsWith("http://") ? "http://" : uri.startsWith("https://") ? "https://" : "";
  uri = uri.replace(protocol, "");
  var parts = uri.split("/").filter(function(s2) {
    return s2;
  });
  var manifestFile = uri.endsWith(".json") ? parts[parts.length - 1] : defaultManifestFilename;
  var modelBaseUri = protocol + (uri.endsWith(".json") ? parts.slice(0, parts.length - 1) : parts).join("/");
  modelBaseUri = uri.startsWith("/") ? "/" + modelBaseUri : modelBaseUri;
  return {
    modelBaseUri,
    manifestUri: modelBaseUri === "/" ? "/" + manifestFile : modelBaseUri + "/" + manifestFile
  };
}
var init_getModelUris = __esm({
  "node_modules/face-api.js/build/es6/common/getModelUris.js"() {
    "use strict";
  }
});

// node_modules/face-api.js/build/es6/dom/loadWeightMap.js
function loadWeightMap(uri, defaultModelName) {
  return __awaiter2(this, void 0, void 0, function() {
    var _a2, manifestUri, modelBaseUri, manifest;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _a2 = getModelUris(uri, defaultModelName), manifestUri = _a2.manifestUri, modelBaseUri = _a2.modelBaseUri;
          return [4, fetchJson(manifestUri)];
        case 1:
          manifest = _b.sent();
          return [2, ed.loadWeights(manifest, modelBaseUri)];
      }
    });
  });
}
var init_loadWeightMap = __esm({
  "node_modules/face-api.js/build/es6/dom/loadWeightMap.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_getModelUris();
    init_fetchJson();
  }
});

// node_modules/face-api.js/build/es6/dom/matchDimensions.js
var init_matchDimensions = __esm({
  "node_modules/face-api.js/build/es6/dom/matchDimensions.js"() {
    "use strict";
    init_getMediaDimensions();
  }
});

// node_modules/face-api.js/build/es6/dom/index.js
var init_dom = __esm({
  "node_modules/face-api.js/build/es6/dom/index.js"() {
    "use strict";
    init_awaitMediaLoaded();
    init_bufferToImage();
    init_createCanvas();
    init_extractFaces();
    init_extractFaceTensors();
    init_fetchImage();
    init_fetchJson();
    init_fetchNetWeights();
    init_fetchOrThrow();
    init_getContext2dOrThrow();
    init_getMediaDimensions();
    init_imageTensorToCanvas();
    init_imageToSquare();
    init_isMediaElement();
    init_isMediaLoaded();
    init_loadWeightMap();
    init_matchDimensions();
    init_NetInput();
    init_resolveInput();
    init_toNetInput();
  }
});

// node_modules/face-api.js/build/es6/NeuralNetwork.js
var NeuralNetwork;
var init_NeuralNetwork = __esm({
  "node_modules/face-api.js/build/es6/NeuralNetwork.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_getModelUris();
    init_dom();
    init_env();
    NeuralNetwork = /** @class */
    function() {
      function NeuralNetwork2(_name) {
        this._name = _name;
        this._params = void 0;
        this._paramMappings = [];
      }
      Object.defineProperty(NeuralNetwork2.prototype, "params", {
        get: function() {
          return this._params;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(NeuralNetwork2.prototype, "paramMappings", {
        get: function() {
          return this._paramMappings;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(NeuralNetwork2.prototype, "isLoaded", {
        get: function() {
          return !!this.params;
        },
        enumerable: true,
        configurable: true
      });
      NeuralNetwork2.prototype.getParamFromPath = function(paramPath) {
        var _a2 = this.traversePropertyPath(paramPath), obj = _a2.obj, objProp = _a2.objProp;
        return obj[objProp];
      };
      NeuralNetwork2.prototype.reassignParamFromPath = function(paramPath, tensor) {
        var _a2 = this.traversePropertyPath(paramPath), obj = _a2.obj, objProp = _a2.objProp;
        obj[objProp].dispose();
        obj[objProp] = tensor;
      };
      NeuralNetwork2.prototype.getParamList = function() {
        var _this = this;
        return this._paramMappings.map(function(_a2) {
          var paramPath = _a2.paramPath;
          return {
            path: paramPath,
            tensor: _this.getParamFromPath(paramPath)
          };
        });
      };
      NeuralNetwork2.prototype.getTrainableParams = function() {
        return this.getParamList().filter(function(param) {
          return param.tensor instanceof St;
        });
      };
      NeuralNetwork2.prototype.getFrozenParams = function() {
        return this.getParamList().filter(function(param) {
          return !(param.tensor instanceof St);
        });
      };
      NeuralNetwork2.prototype.variable = function() {
        var _this = this;
        this.getFrozenParams().forEach(function(_a2) {
          var path = _a2.path, tensor = _a2.tensor;
          _this.reassignParamFromPath(path, tensor.variable());
        });
      };
      NeuralNetwork2.prototype.freeze = function() {
        var _this = this;
        this.getTrainableParams().forEach(function(_a2) {
          var path = _a2.path, variable = _a2.tensor;
          var tensor = Fn(variable.dataSync());
          variable.dispose();
          _this.reassignParamFromPath(path, tensor);
        });
      };
      NeuralNetwork2.prototype.dispose = function(throwOnRedispose) {
        if (throwOnRedispose === void 0) {
          throwOnRedispose = true;
        }
        this.getParamList().forEach(function(param) {
          if (throwOnRedispose && param.tensor.isDisposed) {
            throw new Error("param tensor has already been disposed for path " + param.path);
          }
          param.tensor.dispose();
        });
        this._params = void 0;
      };
      NeuralNetwork2.prototype.serializeParams = function() {
        return new Float32Array(this.getParamList().map(function(_a2) {
          var tensor = _a2.tensor;
          return Array.from(tensor.dataSync());
        }).reduce(function(flat, arr) {
          return flat.concat(arr);
        }));
      };
      NeuralNetwork2.prototype.load = function(weightsOrUrl) {
        return __awaiter2(this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (weightsOrUrl instanceof Float32Array) {
                  this.extractWeights(weightsOrUrl);
                  return [
                    2
                    /*return*/
                  ];
                }
                return [4, this.loadFromUri(weightsOrUrl)];
              case 1:
                _a2.sent();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      NeuralNetwork2.prototype.loadFromUri = function(uri) {
        return __awaiter2(this, void 0, void 0, function() {
          var weightMap;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (uri && typeof uri !== "string") {
                  throw new Error(this._name + ".loadFromUri - expected model uri");
                }
                return [4, loadWeightMap(uri, this.getDefaultModelName())];
              case 1:
                weightMap = _a2.sent();
                this.loadFromWeightMap(weightMap);
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      NeuralNetwork2.prototype.loadFromDisk = function(filePath) {
        return __awaiter2(this, void 0, void 0, function() {
          var readFile, _a2, manifestUri, modelBaseUri, fetchWeightsFromDisk, loadWeights, manifest, _b, _c6, weightMap;
          return __generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                if (filePath && typeof filePath !== "string") {
                  throw new Error(this._name + ".loadFromDisk - expected model file path");
                }
                readFile = env.getEnv().readFile;
                _a2 = getModelUris(filePath, this.getDefaultModelName()), manifestUri = _a2.manifestUri, modelBaseUri = _a2.modelBaseUri;
                fetchWeightsFromDisk = function(filePaths) {
                  return Promise.all(filePaths.map(function(filePath2) {
                    return readFile(filePath2).then(function(buf) {
                      return buf.buffer;
                    });
                  }));
                };
                loadWeights = ed.weightsLoaderFactory(fetchWeightsFromDisk);
                _c6 = (_b = JSON).parse;
                return [4, readFile(manifestUri)];
              case 1:
                manifest = _c6.apply(_b, [_d.sent().toString()]);
                return [4, loadWeights(manifest, modelBaseUri)];
              case 2:
                weightMap = _d.sent();
                this.loadFromWeightMap(weightMap);
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      NeuralNetwork2.prototype.loadFromWeightMap = function(weightMap) {
        var _a2 = this.extractParamsFromWeigthMap(weightMap), paramMappings = _a2.paramMappings, params = _a2.params;
        this._paramMappings = paramMappings;
        this._params = params;
      };
      NeuralNetwork2.prototype.extractWeights = function(weights) {
        var _a2 = this.extractParams(weights), paramMappings = _a2.paramMappings, params = _a2.params;
        this._paramMappings = paramMappings;
        this._params = params;
      };
      NeuralNetwork2.prototype.traversePropertyPath = function(paramPath) {
        if (!this.params) {
          throw new Error("traversePropertyPath - model has no loaded params");
        }
        var result = paramPath.split("/").reduce(function(res, objProp2) {
          if (!res.nextObj.hasOwnProperty(objProp2)) {
            throw new Error("traversePropertyPath - object does not have property " + objProp2 + ", for path " + paramPath);
          }
          return { obj: res.nextObj, objProp: objProp2, nextObj: res.nextObj[objProp2] };
        }, { nextObj: this.params });
        var obj = result.obj, objProp = result.objProp;
        if (!obj || !objProp || !(obj[objProp] instanceof wt)) {
          throw new Error("traversePropertyPath - parameter is not a tensor, for path " + paramPath);
        }
        return { obj, objProp };
      };
      return NeuralNetwork2;
    }();
  }
});

// node_modules/face-api.js/build/es6/common/depthwiseSeparableConv.js
function depthwiseSeparableConv(x2, params, stride) {
  return Ze(function() {
    var out = Jc(x2, params.depthwise_filter, params.pointwise_filter, stride, "same");
    out = rc(out, params.bias);
    return out;
  });
}
var init_depthwiseSeparableConv = __esm({
  "node_modules/face-api.js/build/es6/common/depthwiseSeparableConv.js"() {
    "use strict";
    init_tf_core_esm();
  }
});

// node_modules/face-api.js/build/es6/faceFeatureExtractor/denseBlock.js
function denseBlock3(x2, denseBlockParams, isFirstLayer) {
  if (isFirstLayer === void 0) {
    isFirstLayer = false;
  }
  return Ze(function() {
    var out1 = Bl(isFirstLayer ? rc(qc(x2, denseBlockParams.conv0.filters, [2, 2], "same"), denseBlockParams.conv0.bias) : depthwiseSeparableConv(x2, denseBlockParams.conv0, [2, 2]));
    var out2 = depthwiseSeparableConv(out1, denseBlockParams.conv1, [1, 1]);
    var in3 = Bl(rc(out1, out2));
    var out3 = depthwiseSeparableConv(in3, denseBlockParams.conv2, [1, 1]);
    return Bl(rc(out1, rc(out2, out3)));
  });
}
function denseBlock4(x2, denseBlockParams, isFirstLayer, isScaleDown) {
  if (isFirstLayer === void 0) {
    isFirstLayer = false;
  }
  if (isScaleDown === void 0) {
    isScaleDown = true;
  }
  return Ze(function() {
    var out1 = Bl(isFirstLayer ? rc(qc(x2, denseBlockParams.conv0.filters, isScaleDown ? [2, 2] : [1, 1], "same"), denseBlockParams.conv0.bias) : depthwiseSeparableConv(x2, denseBlockParams.conv0, isScaleDown ? [2, 2] : [1, 1]));
    var out2 = depthwiseSeparableConv(out1, denseBlockParams.conv1, [1, 1]);
    var in3 = Bl(rc(out1, out2));
    var out3 = depthwiseSeparableConv(in3, denseBlockParams.conv2, [1, 1]);
    var in4 = Bl(rc(out1, rc(out2, out3)));
    var out4 = depthwiseSeparableConv(in4, denseBlockParams.conv3, [1, 1]);
    return Bl(rc(out1, rc(out2, rc(out3, out4))));
  });
}
var init_denseBlock = __esm({
  "node_modules/face-api.js/build/es6/faceFeatureExtractor/denseBlock.js"() {
    "use strict";
    init_tf_core_esm();
    init_depthwiseSeparableConv();
  }
});

// node_modules/face-api.js/build/es6/common/convLayer.js
function convLayer(x2, params, padding, withRelu) {
  if (padding === void 0) {
    padding = "same";
  }
  if (withRelu === void 0) {
    withRelu = false;
  }
  return Ze(function() {
    var out = rc(qc(x2, params.filters, [1, 1], padding), params.bias);
    return withRelu ? Bl(out) : out;
  });
}
var init_convLayer = __esm({
  "node_modules/face-api.js/build/es6/common/convLayer.js"() {
    "use strict";
    init_tf_core_esm();
  }
});

// node_modules/face-api.js/build/es6/common/disposeUnusedWeightTensors.js
function disposeUnusedWeightTensors(weightMap, paramMappings) {
  Object.keys(weightMap).forEach(function(path) {
    if (!paramMappings.some(function(pm) {
      return pm.originalPath === path;
    })) {
      weightMap[path].dispose();
    }
  });
}
var init_disposeUnusedWeightTensors = __esm({
  "node_modules/face-api.js/build/es6/common/disposeUnusedWeightTensors.js"() {
    "use strict";
  }
});

// node_modules/face-api.js/build/es6/common/extractConvParamsFactory.js
function extractConvParamsFactory(extractWeights, paramMappings) {
  return function(channelsIn, channelsOut, filterSize, mappedPrefix) {
    var filters = Ln(extractWeights(channelsIn * channelsOut * filterSize * filterSize), [filterSize, filterSize, channelsIn, channelsOut]);
    var bias = Mn(extractWeights(channelsOut));
    paramMappings.push({ paramPath: mappedPrefix + "/filters" }, { paramPath: mappedPrefix + "/bias" });
    return { filters, bias };
  };
}
var init_extractConvParamsFactory = __esm({
  "node_modules/face-api.js/build/es6/common/extractConvParamsFactory.js"() {
    "use strict";
    init_tf_core_esm();
  }
});

// node_modules/face-api.js/build/es6/common/extractFCParamsFactory.js
function extractFCParamsFactory(extractWeights, paramMappings) {
  return function(channelsIn, channelsOut, mappedPrefix) {
    var fc_weights = Bn(extractWeights(channelsIn * channelsOut), [channelsIn, channelsOut]);
    var fc_bias = Mn(extractWeights(channelsOut));
    paramMappings.push({ paramPath: mappedPrefix + "/weights" }, { paramPath: mappedPrefix + "/bias" });
    return {
      weights: fc_weights,
      bias: fc_bias
    };
  };
}
var init_extractFCParamsFactory = __esm({
  "node_modules/face-api.js/build/es6/common/extractFCParamsFactory.js"() {
    "use strict";
    init_tf_core_esm();
  }
});

// node_modules/face-api.js/build/es6/common/types.js
var SeparableConvParams;
var init_types2 = __esm({
  "node_modules/face-api.js/build/es6/common/types.js"() {
    "use strict";
    SeparableConvParams = /** @class */
    /* @__PURE__ */ function() {
      function SeparableConvParams2(depthwise_filter, pointwise_filter, bias) {
        this.depthwise_filter = depthwise_filter;
        this.pointwise_filter = pointwise_filter;
        this.bias = bias;
      }
      return SeparableConvParams2;
    }();
  }
});

// node_modules/face-api.js/build/es6/common/extractSeparableConvParamsFactory.js
function extractSeparableConvParamsFactory(extractWeights, paramMappings) {
  return function(channelsIn, channelsOut, mappedPrefix) {
    var depthwise_filter = Ln(extractWeights(3 * 3 * channelsIn), [3, 3, channelsIn, 1]);
    var pointwise_filter = Ln(extractWeights(channelsIn * channelsOut), [1, 1, channelsIn, channelsOut]);
    var bias = Mn(extractWeights(channelsOut));
    paramMappings.push({ paramPath: mappedPrefix + "/depthwise_filter" }, { paramPath: mappedPrefix + "/pointwise_filter" }, { paramPath: mappedPrefix + "/bias" });
    return new SeparableConvParams(depthwise_filter, pointwise_filter, bias);
  };
}
function loadSeparableConvParamsFactory(extractWeightEntry) {
  return function(prefix) {
    var depthwise_filter = extractWeightEntry(prefix + "/depthwise_filter", 4);
    var pointwise_filter = extractWeightEntry(prefix + "/pointwise_filter", 4);
    var bias = extractWeightEntry(prefix + "/bias", 1);
    return new SeparableConvParams(depthwise_filter, pointwise_filter, bias);
  };
}
var init_extractSeparableConvParamsFactory = __esm({
  "node_modules/face-api.js/build/es6/common/extractSeparableConvParamsFactory.js"() {
    "use strict";
    init_tf_core_esm();
    init_types2();
  }
});

// node_modules/face-api.js/build/es6/common/extractWeightEntryFactory.js
function extractWeightEntryFactory(weightMap, paramMappings) {
  return function(originalPath, paramRank, mappedPath) {
    var tensor = weightMap[originalPath];
    if (!isTensor(tensor, paramRank)) {
      throw new Error("expected weightMap[" + originalPath + "] to be a Tensor" + paramRank + "D, instead have " + tensor);
    }
    paramMappings.push({ originalPath, paramPath: mappedPath || originalPath });
    return tensor;
  };
}
var init_extractWeightEntryFactory = __esm({
  "node_modules/face-api.js/build/es6/common/extractWeightEntryFactory.js"() {
    "use strict";
    init_utils();
  }
});

// node_modules/face-api.js/build/es6/common/extractWeightsFactory.js
function extractWeightsFactory(weights) {
  var remainingWeights = weights;
  function extractWeights(numWeights) {
    var ret = remainingWeights.slice(0, numWeights);
    remainingWeights = remainingWeights.slice(numWeights);
    return ret;
  }
  function getRemainingWeights() {
    return remainingWeights;
  }
  return {
    extractWeights,
    getRemainingWeights
  };
}
var init_extractWeightsFactory = __esm({
  "node_modules/face-api.js/build/es6/common/extractWeightsFactory.js"() {
    "use strict";
  }
});

// node_modules/face-api.js/build/es6/common/index.js
var init_common2 = __esm({
  "node_modules/face-api.js/build/es6/common/index.js"() {
    "use strict";
    init_convLayer();
    init_depthwiseSeparableConv();
    init_disposeUnusedWeightTensors();
    init_extractConvParamsFactory();
    init_extractFCParamsFactory();
    init_extractSeparableConvParamsFactory();
    init_extractWeightEntryFactory();
    init_extractWeightsFactory();
    init_getModelUris();
    init_types2();
  }
});

// node_modules/face-api.js/build/es6/faceFeatureExtractor/extractorsFactory.js
function extractorsFactory(extractWeights, paramMappings) {
  var extractConvParams = extractConvParamsFactory(extractWeights, paramMappings);
  var extractSeparableConvParams = extractSeparableConvParamsFactory(extractWeights, paramMappings);
  function extractDenseBlock3Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer) {
    if (isFirstLayer === void 0) {
      isFirstLayer = false;
    }
    var conv0 = isFirstLayer ? extractConvParams(channelsIn, channelsOut, 3, mappedPrefix + "/conv0") : extractSeparableConvParams(channelsIn, channelsOut, mappedPrefix + "/conv0");
    var conv1 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + "/conv1");
    var conv22 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + "/conv2");
    return { conv0, conv1, conv2: conv22 };
  }
  function extractDenseBlock4Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer) {
    if (isFirstLayer === void 0) {
      isFirstLayer = false;
    }
    var _a2 = extractDenseBlock3Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer), conv0 = _a2.conv0, conv1 = _a2.conv1, conv22 = _a2.conv2;
    var conv3 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + "/conv3");
    return { conv0, conv1, conv2: conv22, conv3 };
  }
  return {
    extractDenseBlock3Params,
    extractDenseBlock4Params
  };
}
var init_extractorsFactory = __esm({
  "node_modules/face-api.js/build/es6/faceFeatureExtractor/extractorsFactory.js"() {
    "use strict";
    init_common2();
  }
});

// node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParams.js
function extractParams(weights) {
  var paramMappings = [];
  var _a2 = extractWeightsFactory(weights), extractWeights = _a2.extractWeights, getRemainingWeights = _a2.getRemainingWeights;
  var extractDenseBlock4Params = extractorsFactory(extractWeights, paramMappings).extractDenseBlock4Params;
  var dense0 = extractDenseBlock4Params(3, 32, "dense0", true);
  var dense1 = extractDenseBlock4Params(32, 64, "dense1");
  var dense2 = extractDenseBlock4Params(64, 128, "dense2");
  var dense3 = extractDenseBlock4Params(128, 256, "dense3");
  if (getRemainingWeights().length !== 0) {
    throw new Error("weights remaing after extract: " + getRemainingWeights().length);
  }
  return {
    paramMappings,
    params: { dense0, dense1, dense2, dense3 }
  };
}
var init_extractParams = __esm({
  "node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParams.js"() {
    "use strict";
    init_common2();
    init_extractorsFactory();
  }
});

// node_modules/face-api.js/build/es6/common/loadConvParamsFactory.js
function loadConvParamsFactory(extractWeightEntry) {
  return function(prefix) {
    var filters = extractWeightEntry(prefix + "/filters", 4);
    var bias = extractWeightEntry(prefix + "/bias", 1);
    return { filters, bias };
  };
}
var init_loadConvParamsFactory = __esm({
  "node_modules/face-api.js/build/es6/common/loadConvParamsFactory.js"() {
    "use strict";
  }
});

// node_modules/face-api.js/build/es6/faceFeatureExtractor/loadParamsFactory.js
function loadParamsFactory(weightMap, paramMappings) {
  var extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);
  var extractConvParams = loadConvParamsFactory(extractWeightEntry);
  var extractSeparableConvParams = loadSeparableConvParamsFactory(extractWeightEntry);
  function extractDenseBlock3Params(prefix, isFirstLayer) {
    if (isFirstLayer === void 0) {
      isFirstLayer = false;
    }
    var conv0 = isFirstLayer ? extractConvParams(prefix + "/conv0") : extractSeparableConvParams(prefix + "/conv0");
    var conv1 = extractSeparableConvParams(prefix + "/conv1");
    var conv22 = extractSeparableConvParams(prefix + "/conv2");
    return { conv0, conv1, conv2: conv22 };
  }
  function extractDenseBlock4Params(prefix, isFirstLayer) {
    if (isFirstLayer === void 0) {
      isFirstLayer = false;
    }
    var conv0 = isFirstLayer ? extractConvParams(prefix + "/conv0") : extractSeparableConvParams(prefix + "/conv0");
    var conv1 = extractSeparableConvParams(prefix + "/conv1");
    var conv22 = extractSeparableConvParams(prefix + "/conv2");
    var conv3 = extractSeparableConvParams(prefix + "/conv3");
    return { conv0, conv1, conv2: conv22, conv3 };
  }
  return {
    extractDenseBlock3Params,
    extractDenseBlock4Params
  };
}
var init_loadParamsFactory = __esm({
  "node_modules/face-api.js/build/es6/faceFeatureExtractor/loadParamsFactory.js"() {
    "use strict";
    init_common2();
    init_loadConvParamsFactory();
  }
});

// node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsFromWeigthMap.js
function extractParamsFromWeigthMap(weightMap) {
  var paramMappings = [];
  var extractDenseBlock4Params = loadParamsFactory(weightMap, paramMappings).extractDenseBlock4Params;
  var params = {
    dense0: extractDenseBlock4Params("dense0", true),
    dense1: extractDenseBlock4Params("dense1"),
    dense2: extractDenseBlock4Params("dense2"),
    dense3: extractDenseBlock4Params("dense3")
  };
  disposeUnusedWeightTensors(weightMap, paramMappings);
  return { params, paramMappings };
}
var init_extractParamsFromWeigthMap = __esm({
  "node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsFromWeigthMap.js"() {
    "use strict";
    init_common2();
    init_loadParamsFactory();
  }
});

// node_modules/face-api.js/build/es6/faceFeatureExtractor/FaceFeatureExtractor.js
var FaceFeatureExtractor;
var init_FaceFeatureExtractor = __esm({
  "node_modules/face-api.js/build/es6/faceFeatureExtractor/FaceFeatureExtractor.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_dom();
    init_NeuralNetwork();
    init_ops();
    init_denseBlock();
    init_extractParams();
    init_extractParamsFromWeigthMap();
    FaceFeatureExtractor = /** @class */
    function(_super) {
      __extends(FaceFeatureExtractor2, _super);
      function FaceFeatureExtractor2() {
        return _super.call(this, "FaceFeatureExtractor") || this;
      }
      FaceFeatureExtractor2.prototype.forwardInput = function(input2) {
        var params = this.params;
        if (!params) {
          throw new Error("FaceFeatureExtractor - load model before inference");
        }
        return Ze(function() {
          var batchTensor = input2.toBatchTensor(112, true);
          var meanRgb = [122.782, 117.001, 104.298];
          var normalized = normalize(batchTensor, meanRgb).div(On(255));
          var out = denseBlock4(normalized, params.dense0, true);
          out = denseBlock4(out, params.dense1);
          out = denseBlock4(out, params.dense2);
          out = denseBlock4(out, params.dense3);
          out = fl(out, [7, 7], [2, 2], "valid");
          return out;
        });
      };
      FaceFeatureExtractor2.prototype.forward = function(input2) {
        return __awaiter2(this, void 0, void 0, function() {
          var _a2;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _a2 = this.forwardInput;
                return [4, toNetInput(input2)];
              case 1:
                return [2, _a2.apply(this, [_b.sent()])];
            }
          });
        });
      };
      FaceFeatureExtractor2.prototype.getDefaultModelName = function() {
        return "face_feature_extractor_model";
      };
      FaceFeatureExtractor2.prototype.extractParamsFromWeigthMap = function(weightMap) {
        return extractParamsFromWeigthMap(weightMap);
      };
      FaceFeatureExtractor2.prototype.extractParams = function(weights) {
        return extractParams(weights);
      };
      return FaceFeatureExtractor2;
    }(NeuralNetwork);
  }
});

// node_modules/face-api.js/build/es6/common/fullyConnectedLayer.js
function fullyConnectedLayer(x2, params) {
  return Ze(function() {
    return rc(el(x2, params.weights), params.bias);
  });
}
var init_fullyConnectedLayer = __esm({
  "node_modules/face-api.js/build/es6/common/fullyConnectedLayer.js"() {
    "use strict";
    init_tf_core_esm();
  }
});

// node_modules/face-api.js/build/es6/faceProcessor/extractParams.js
function extractParams2(weights, channelsIn, channelsOut) {
  var paramMappings = [];
  var _a2 = extractWeightsFactory(weights), extractWeights = _a2.extractWeights, getRemainingWeights = _a2.getRemainingWeights;
  var extractFCParams = extractFCParamsFactory(extractWeights, paramMappings);
  var fc2 = extractFCParams(channelsIn, channelsOut, "fc");
  if (getRemainingWeights().length !== 0) {
    throw new Error("weights remaing after extract: " + getRemainingWeights().length);
  }
  return {
    paramMappings,
    params: { fc: fc2 }
  };
}
var init_extractParams2 = __esm({
  "node_modules/face-api.js/build/es6/faceProcessor/extractParams.js"() {
    "use strict";
    init_common2();
  }
});

// node_modules/face-api.js/build/es6/faceProcessor/extractParamsFromWeigthMap.js
function extractParamsFromWeigthMap2(weightMap) {
  var paramMappings = [];
  var extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);
  function extractFcParams(prefix) {
    var weights = extractWeightEntry(prefix + "/weights", 2);
    var bias = extractWeightEntry(prefix + "/bias", 1);
    return { weights, bias };
  }
  var params = {
    fc: extractFcParams("fc")
  };
  disposeUnusedWeightTensors(weightMap, paramMappings);
  return { params, paramMappings };
}
var init_extractParamsFromWeigthMap2 = __esm({
  "node_modules/face-api.js/build/es6/faceProcessor/extractParamsFromWeigthMap.js"() {
    "use strict";
    init_common2();
  }
});

// node_modules/face-api.js/build/es6/faceProcessor/util.js
function seperateWeightMaps(weightMap) {
  var featureExtractorMap = {};
  var classifierMap = {};
  Object.keys(weightMap).forEach(function(key) {
    var map2 = key.startsWith("fc") ? classifierMap : featureExtractorMap;
    map2[key] = weightMap[key];
  });
  return { featureExtractorMap, classifierMap };
}
var init_util = __esm({
  "node_modules/face-api.js/build/es6/faceProcessor/util.js"() {
    "use strict";
  }
});

// node_modules/face-api.js/build/es6/faceProcessor/FaceProcessor.js
var FaceProcessor;
var init_FaceProcessor = __esm({
  "node_modules/face-api.js/build/es6/faceProcessor/FaceProcessor.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_fullyConnectedLayer();
    init_dom();
    init_NeuralNetwork();
    init_extractParams2();
    init_extractParamsFromWeigthMap2();
    init_util();
    FaceProcessor = /** @class */
    function(_super) {
      __extends(FaceProcessor2, _super);
      function FaceProcessor2(_name, faceFeatureExtractor) {
        var _this = _super.call(this, _name) || this;
        _this._faceFeatureExtractor = faceFeatureExtractor;
        return _this;
      }
      Object.defineProperty(FaceProcessor2.prototype, "faceFeatureExtractor", {
        get: function() {
          return this._faceFeatureExtractor;
        },
        enumerable: true,
        configurable: true
      });
      FaceProcessor2.prototype.runNet = function(input2) {
        var _this = this;
        var params = this.params;
        if (!params) {
          throw new Error(this._name + " - load model before inference");
        }
        return Ze(function() {
          var bottleneckFeatures = input2 instanceof NetInput ? _this.faceFeatureExtractor.forwardInput(input2) : input2;
          return fullyConnectedLayer(bottleneckFeatures.as2D(bottleneckFeatures.shape[0], -1), params.fc);
        });
      };
      FaceProcessor2.prototype.dispose = function(throwOnRedispose) {
        if (throwOnRedispose === void 0) {
          throwOnRedispose = true;
        }
        this.faceFeatureExtractor.dispose(throwOnRedispose);
        _super.prototype.dispose.call(this, throwOnRedispose);
      };
      FaceProcessor2.prototype.loadClassifierParams = function(weights) {
        var _a2 = this.extractClassifierParams(weights), params = _a2.params, paramMappings = _a2.paramMappings;
        this._params = params;
        this._paramMappings = paramMappings;
      };
      FaceProcessor2.prototype.extractClassifierParams = function(weights) {
        return extractParams2(weights, this.getClassifierChannelsIn(), this.getClassifierChannelsOut());
      };
      FaceProcessor2.prototype.extractParamsFromWeigthMap = function(weightMap) {
        var _a2 = seperateWeightMaps(weightMap), featureExtractorMap = _a2.featureExtractorMap, classifierMap = _a2.classifierMap;
        this.faceFeatureExtractor.loadFromWeightMap(featureExtractorMap);
        return extractParamsFromWeigthMap2(classifierMap);
      };
      FaceProcessor2.prototype.extractParams = function(weights) {
        var cIn = this.getClassifierChannelsIn();
        var cOut = this.getClassifierChannelsOut();
        var classifierWeightSize = cOut * cIn + cOut;
        var featureExtractorWeights = weights.slice(0, weights.length - classifierWeightSize);
        var classifierWeights = weights.slice(weights.length - classifierWeightSize);
        this.faceFeatureExtractor.extractWeights(featureExtractorWeights);
        return this.extractClassifierParams(classifierWeights);
      };
      return FaceProcessor2;
    }(NeuralNetwork);
  }
});

// node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressions.js
var FACE_EXPRESSION_LABELS, FaceExpressions;
var init_FaceExpressions = __esm({
  "node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressions.js"() {
    "use strict";
    FACE_EXPRESSION_LABELS = ["neutral", "happy", "sad", "angry", "fearful", "disgusted", "surprised"];
    FaceExpressions = /** @class */
    function() {
      function FaceExpressions2(probabilities) {
        var _this = this;
        if (probabilities.length !== 7) {
          throw new Error("FaceExpressions.constructor - expected probabilities.length to be 7, have: " + probabilities.length);
        }
        FACE_EXPRESSION_LABELS.forEach(function(expression, idx) {
          _this[expression] = probabilities[idx];
        });
      }
      FaceExpressions2.prototype.asSortedArray = function() {
        var _this = this;
        return FACE_EXPRESSION_LABELS.map(function(expression) {
          return { expression, probability: _this[expression] };
        }).sort(function(e0, e1) {
          return e1.probability - e0.probability;
        });
      };
      return FaceExpressions2;
    }();
  }
});

// node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressionNet.js
var FaceExpressionNet;
var init_FaceExpressionNet = __esm({
  "node_modules/face-api.js/build/es6/faceExpressionNet/FaceExpressionNet.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_dom();
    init_FaceFeatureExtractor();
    init_FaceProcessor();
    init_FaceExpressions();
    FaceExpressionNet = /** @class */
    function(_super) {
      __extends(FaceExpressionNet2, _super);
      function FaceExpressionNet2(faceFeatureExtractor) {
        if (faceFeatureExtractor === void 0) {
          faceFeatureExtractor = new FaceFeatureExtractor();
        }
        return _super.call(this, "FaceExpressionNet", faceFeatureExtractor) || this;
      }
      FaceExpressionNet2.prototype.forwardInput = function(input2) {
        var _this = this;
        return Ze(function() {
          return go(_this.runNet(input2));
        });
      };
      FaceExpressionNet2.prototype.forward = function(input2) {
        return __awaiter2(this, void 0, void 0, function() {
          var _a2;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _a2 = this.forwardInput;
                return [4, toNetInput(input2)];
              case 1:
                return [2, _a2.apply(this, [_b.sent()])];
            }
          });
        });
      };
      FaceExpressionNet2.prototype.predictExpressions = function(input2) {
        return __awaiter2(this, void 0, void 0, function() {
          var netInput, out, probabilitesByBatch, predictionsByBatch;
          var _this = this;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, toNetInput(input2)];
              case 1:
                netInput = _a2.sent();
                return [4, this.forwardInput(netInput)];
              case 2:
                out = _a2.sent();
                return [4, Promise.all(Ur(out).map(function(t2) {
                  return __awaiter2(_this, void 0, void 0, function() {
                    var data;
                    return __generator(this, function(_a3) {
                      switch (_a3.label) {
                        case 0:
                          return [4, t2.data()];
                        case 1:
                          data = _a3.sent();
                          t2.dispose();
                          return [2, data];
                      }
                    });
                  });
                }))];
              case 3:
                probabilitesByBatch = _a2.sent();
                out.dispose();
                predictionsByBatch = probabilitesByBatch.map(function(probabilites) {
                  return new FaceExpressions(probabilites);
                });
                return [2, netInput.isBatchInput ? predictionsByBatch : predictionsByBatch[0]];
            }
          });
        });
      };
      FaceExpressionNet2.prototype.getDefaultModelName = function() {
        return "face_expression_model";
      };
      FaceExpressionNet2.prototype.getClassifierChannelsIn = function() {
        return 256;
      };
      FaceExpressionNet2.prototype.getClassifierChannelsOut = function() {
        return 7;
      };
      return FaceExpressionNet2;
    }(FaceProcessor);
  }
});

// node_modules/face-api.js/build/es6/faceExpressionNet/index.js
var init_faceExpressionNet = __esm({
  "node_modules/face-api.js/build/es6/faceExpressionNet/index.js"() {
    "use strict";
    init_FaceExpressionNet();
    init_FaceExpressions();
  }
});

// node_modules/face-api.js/build/es6/factories/WithFaceExpressions.js
function isWithFaceExpressions(obj) {
  return obj["expressions"] instanceof FaceExpressions;
}
function extendWithFaceExpressions(sourceObj, expressions) {
  var extension = { expressions };
  return Object.assign({}, sourceObj, extension);
}
var init_WithFaceExpressions = __esm({
  "node_modules/face-api.js/build/es6/factories/WithFaceExpressions.js"() {
    "use strict";
    init_FaceExpressions();
  }
});

// node_modules/face-api.js/build/es6/draw/drawFaceExpressions.js
function drawFaceExpressions(canvasArg, faceExpressions, minConfidence, textFieldAnchor) {
  if (minConfidence === void 0) {
    minConfidence = 0.1;
  }
  var faceExpressionsArray = Array.isArray(faceExpressions) ? faceExpressions : [faceExpressions];
  faceExpressionsArray.forEach(function(e2) {
    var expr = e2 instanceof FaceExpressions ? e2 : isWithFaceExpressions(e2) ? e2.expressions : void 0;
    if (!expr) {
      throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");
    }
    var sorted = expr.asSortedArray();
    var resultsToDisplay = sorted.filter(function(expr2) {
      return expr2.probability > minConfidence;
    });
    var anchor = isWithFaceDetection(e2) ? e2.detection.box.bottomLeft : textFieldAnchor || new Point(0, 0);
    var drawTextField = new DrawTextField(resultsToDisplay.map(function(expr2) {
      return expr2.expression + " (" + round2(expr2.probability) + ")";
    }), anchor);
    drawTextField.draw(canvasArg);
  });
}
var init_drawFaceExpressions = __esm({
  "node_modules/face-api.js/build/es6/draw/drawFaceExpressions.js"() {
    "use strict";
    init_classes();
    init_faceExpressionNet();
    init_WithFaceDetection();
    init_WithFaceExpressions();
    init_utils();
    init_DrawTextField();
  }
});

// node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js
function isWithFaceLandmarks(obj) {
  return isWithFaceDetection(obj) && obj["landmarks"] instanceof FaceLandmarks && obj["unshiftedLandmarks"] instanceof FaceLandmarks && obj["alignedRect"] instanceof FaceDetection;
}
function extendWithFaceLandmarks(sourceObj, unshiftedLandmarks) {
  var shift = sourceObj.detection.box;
  var landmarks = unshiftedLandmarks.shiftBy(shift.x, shift.y);
  var rect = landmarks.align();
  var imageDims = sourceObj.detection.imageDims;
  var alignedRect = new FaceDetection(sourceObj.detection.score, rect.rescale(imageDims.reverse()), imageDims);
  var extension = {
    landmarks,
    unshiftedLandmarks,
    alignedRect
  };
  return Object.assign({}, sourceObj, extension);
}
var init_WithFaceLandmarks = __esm({
  "node_modules/face-api.js/build/es6/factories/WithFaceLandmarks.js"() {
    "use strict";
    init_FaceDetection();
    init_FaceLandmarks();
    init_WithFaceDetection();
  }
});

// node_modules/face-api.js/build/es6/draw/DrawFaceLandmarks.js
function drawFaceLandmarks(canvasArg, faceLandmarks) {
  var faceLandmarksArray = Array.isArray(faceLandmarks) ? faceLandmarks : [faceLandmarks];
  faceLandmarksArray.forEach(function(f2) {
    var landmarks = f2 instanceof FaceLandmarks ? f2 : isWithFaceLandmarks(f2) ? f2.landmarks : void 0;
    if (!landmarks) {
      throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");
    }
    new DrawFaceLandmarks(landmarks).draw(canvasArg);
  });
}
var DrawFaceLandmarksOptions, DrawFaceLandmarks;
var init_DrawFaceLandmarks = __esm({
  "node_modules/face-api.js/build/es6/draw/DrawFaceLandmarks.js"() {
    "use strict";
    init_FaceLandmarks();
    init_FaceLandmarks68();
    init_getContext2dOrThrow();
    init_WithFaceLandmarks();
    init_drawContour();
    DrawFaceLandmarksOptions = /** @class */
    /* @__PURE__ */ function() {
      function DrawFaceLandmarksOptions2(options) {
        if (options === void 0) {
          options = {};
        }
        var _a2 = options.drawLines, drawLines = _a2 === void 0 ? true : _a2, _b = options.drawPoints, drawPoints = _b === void 0 ? true : _b, lineWidth = options.lineWidth, lineColor = options.lineColor, pointSize = options.pointSize, pointColor = options.pointColor;
        this.drawLines = drawLines;
        this.drawPoints = drawPoints;
        this.lineWidth = lineWidth || 1;
        this.pointSize = pointSize || 2;
        this.lineColor = lineColor || "rgba(0, 255, 255, 1)";
        this.pointColor = pointColor || "rgba(255, 0, 255, 1)";
      }
      return DrawFaceLandmarksOptions2;
    }();
    DrawFaceLandmarks = /** @class */
    function() {
      function DrawFaceLandmarks2(faceLandmarks, options) {
        if (options === void 0) {
          options = {};
        }
        this.faceLandmarks = faceLandmarks;
        this.options = new DrawFaceLandmarksOptions(options);
      }
      DrawFaceLandmarks2.prototype.draw = function(canvasArg) {
        var ctx = getContext2dOrThrow(canvasArg);
        var _a2 = this.options, drawLines = _a2.drawLines, drawPoints = _a2.drawPoints, lineWidth = _a2.lineWidth, lineColor = _a2.lineColor, pointSize = _a2.pointSize, pointColor = _a2.pointColor;
        if (drawLines && this.faceLandmarks instanceof FaceLandmarks68) {
          ctx.strokeStyle = lineColor;
          ctx.lineWidth = lineWidth;
          drawContour(ctx, this.faceLandmarks.getJawOutline());
          drawContour(ctx, this.faceLandmarks.getLeftEyeBrow());
          drawContour(ctx, this.faceLandmarks.getRightEyeBrow());
          drawContour(ctx, this.faceLandmarks.getNose());
          drawContour(ctx, this.faceLandmarks.getLeftEye(), true);
          drawContour(ctx, this.faceLandmarks.getRightEye(), true);
          drawContour(ctx, this.faceLandmarks.getMouth(), true);
        }
        if (drawPoints) {
          ctx.strokeStyle = pointColor;
          ctx.fillStyle = pointColor;
          var drawPoint = function(pt2) {
            ctx.beginPath();
            ctx.arc(pt2.x, pt2.y, pointSize, 0, 2 * Math.PI);
            ctx.fill();
          };
          this.faceLandmarks.positions.forEach(drawPoint);
        }
      };
      return DrawFaceLandmarks2;
    }();
  }
});

// node_modules/face-api.js/build/es6/draw/index.js
var draw_exports = {};
__export(draw_exports, {
  AnchorPosition: () => AnchorPosition,
  DrawBox: () => DrawBox,
  DrawBoxOptions: () => DrawBoxOptions,
  DrawFaceLandmarks: () => DrawFaceLandmarks,
  DrawFaceLandmarksOptions: () => DrawFaceLandmarksOptions,
  DrawTextField: () => DrawTextField,
  DrawTextFieldOptions: () => DrawTextFieldOptions,
  drawContour: () => drawContour,
  drawDetections: () => drawDetections,
  drawFaceExpressions: () => drawFaceExpressions,
  drawFaceLandmarks: () => drawFaceLandmarks
});
var init_draw = __esm({
  "node_modules/face-api.js/build/es6/draw/index.js"() {
    "use strict";
    init_drawContour();
    init_drawDetections();
    init_drawFaceExpressions();
    init_DrawBox();
    init_DrawFaceLandmarks();
    init_DrawTextField();
  }
});

// node_modules/face-api.js/build/es6/xception/extractParams.js
function extractorsFactory2(extractWeights, paramMappings) {
  var extractConvParams = extractConvParamsFactory(extractWeights, paramMappings);
  var extractSeparableConvParams = extractSeparableConvParamsFactory(extractWeights, paramMappings);
  function extractReductionBlockParams(channelsIn, channelsOut, mappedPrefix) {
    var separable_conv0 = extractSeparableConvParams(channelsIn, channelsOut, mappedPrefix + "/separable_conv0");
    var separable_conv1 = extractSeparableConvParams(channelsOut, channelsOut, mappedPrefix + "/separable_conv1");
    var expansion_conv = extractConvParams(channelsIn, channelsOut, 1, mappedPrefix + "/expansion_conv");
    return { separable_conv0, separable_conv1, expansion_conv };
  }
  function extractMainBlockParams(channels, mappedPrefix) {
    var separable_conv0 = extractSeparableConvParams(channels, channels, mappedPrefix + "/separable_conv0");
    var separable_conv1 = extractSeparableConvParams(channels, channels, mappedPrefix + "/separable_conv1");
    var separable_conv2 = extractSeparableConvParams(channels, channels, mappedPrefix + "/separable_conv2");
    return { separable_conv0, separable_conv1, separable_conv2 };
  }
  return {
    extractConvParams,
    extractSeparableConvParams,
    extractReductionBlockParams,
    extractMainBlockParams
  };
}
function extractParams3(weights, numMainBlocks) {
  var paramMappings = [];
  var _a2 = extractWeightsFactory(weights), extractWeights = _a2.extractWeights, getRemainingWeights = _a2.getRemainingWeights;
  var _b = extractorsFactory2(extractWeights, paramMappings), extractConvParams = _b.extractConvParams, extractSeparableConvParams = _b.extractSeparableConvParams, extractReductionBlockParams = _b.extractReductionBlockParams, extractMainBlockParams = _b.extractMainBlockParams;
  var entry_flow_conv_in = extractConvParams(3, 32, 3, "entry_flow/conv_in");
  var entry_flow_reduction_block_0 = extractReductionBlockParams(32, 64, "entry_flow/reduction_block_0");
  var entry_flow_reduction_block_1 = extractReductionBlockParams(64, 128, "entry_flow/reduction_block_1");
  var entry_flow = {
    conv_in: entry_flow_conv_in,
    reduction_block_0: entry_flow_reduction_block_0,
    reduction_block_1: entry_flow_reduction_block_1
  };
  var middle_flow = {};
  range(numMainBlocks, 0, 1).forEach(function(idx) {
    middle_flow["main_block_" + idx] = extractMainBlockParams(128, "middle_flow/main_block_" + idx);
  });
  var exit_flow_reduction_block = extractReductionBlockParams(128, 256, "exit_flow/reduction_block");
  var exit_flow_separable_conv = extractSeparableConvParams(256, 512, "exit_flow/separable_conv");
  var exit_flow = {
    reduction_block: exit_flow_reduction_block,
    separable_conv: exit_flow_separable_conv
  };
  if (getRemainingWeights().length !== 0) {
    throw new Error("weights remaing after extract: " + getRemainingWeights().length);
  }
  return {
    paramMappings,
    params: { entry_flow, middle_flow, exit_flow }
  };
}
var init_extractParams3 = __esm({
  "node_modules/face-api.js/build/es6/xception/extractParams.js"() {
    "use strict";
    init_common2();
    init_utils();
  }
});

// node_modules/face-api.js/build/es6/xception/extractParamsFromWeigthMap.js
function loadParamsFactory2(weightMap, paramMappings) {
  var extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);
  var extractConvParams = loadConvParamsFactory(extractWeightEntry);
  var extractSeparableConvParams = loadSeparableConvParamsFactory(extractWeightEntry);
  function extractReductionBlockParams(mappedPrefix) {
    var separable_conv0 = extractSeparableConvParams(mappedPrefix + "/separable_conv0");
    var separable_conv1 = extractSeparableConvParams(mappedPrefix + "/separable_conv1");
    var expansion_conv = extractConvParams(mappedPrefix + "/expansion_conv");
    return { separable_conv0, separable_conv1, expansion_conv };
  }
  function extractMainBlockParams(mappedPrefix) {
    var separable_conv0 = extractSeparableConvParams(mappedPrefix + "/separable_conv0");
    var separable_conv1 = extractSeparableConvParams(mappedPrefix + "/separable_conv1");
    var separable_conv2 = extractSeparableConvParams(mappedPrefix + "/separable_conv2");
    return { separable_conv0, separable_conv1, separable_conv2 };
  }
  return {
    extractConvParams,
    extractSeparableConvParams,
    extractReductionBlockParams,
    extractMainBlockParams
  };
}
function extractParamsFromWeigthMap3(weightMap, numMainBlocks) {
  var paramMappings = [];
  var _a2 = loadParamsFactory2(weightMap, paramMappings), extractConvParams = _a2.extractConvParams, extractSeparableConvParams = _a2.extractSeparableConvParams, extractReductionBlockParams = _a2.extractReductionBlockParams, extractMainBlockParams = _a2.extractMainBlockParams;
  var entry_flow_conv_in = extractConvParams("entry_flow/conv_in");
  var entry_flow_reduction_block_0 = extractReductionBlockParams("entry_flow/reduction_block_0");
  var entry_flow_reduction_block_1 = extractReductionBlockParams("entry_flow/reduction_block_1");
  var entry_flow = {
    conv_in: entry_flow_conv_in,
    reduction_block_0: entry_flow_reduction_block_0,
    reduction_block_1: entry_flow_reduction_block_1
  };
  var middle_flow = {};
  range(numMainBlocks, 0, 1).forEach(function(idx) {
    middle_flow["main_block_" + idx] = extractMainBlockParams("middle_flow/main_block_" + idx);
  });
  var exit_flow_reduction_block = extractReductionBlockParams("exit_flow/reduction_block");
  var exit_flow_separable_conv = extractSeparableConvParams("exit_flow/separable_conv");
  var exit_flow = {
    reduction_block: exit_flow_reduction_block,
    separable_conv: exit_flow_separable_conv
  };
  disposeUnusedWeightTensors(weightMap, paramMappings);
  return { params: { entry_flow, middle_flow, exit_flow }, paramMappings };
}
var init_extractParamsFromWeigthMap3 = __esm({
  "node_modules/face-api.js/build/es6/xception/extractParamsFromWeigthMap.js"() {
    "use strict";
    init_common2();
    init_loadConvParamsFactory();
    init_utils();
  }
});

// node_modules/face-api.js/build/es6/xception/TinyXception.js
function conv(x2, params, stride) {
  return rc(qc(x2, params.filters, stride, "same"), params.bias);
}
function reductionBlock(x2, params, isActivateInput) {
  if (isActivateInput === void 0) {
    isActivateInput = true;
  }
  var out = isActivateInput ? Bl(x2) : x2;
  out = depthwiseSeparableConv(out, params.separable_conv0, [1, 1]);
  out = depthwiseSeparableConv(Bl(out), params.separable_conv1, [1, 1]);
  out = hl(out, [3, 3], [2, 2], "same");
  out = rc(out, conv(x2, params.expansion_conv, [2, 2]));
  return out;
}
function mainBlock(x2, params) {
  var out = depthwiseSeparableConv(Bl(x2), params.separable_conv0, [1, 1]);
  out = depthwiseSeparableConv(Bl(out), params.separable_conv1, [1, 1]);
  out = depthwiseSeparableConv(Bl(out), params.separable_conv2, [1, 1]);
  out = rc(out, x2);
  return out;
}
var TinyXception;
var init_TinyXception = __esm({
  "node_modules/face-api.js/build/es6/xception/TinyXception.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_common2();
    init_dom();
    init_NeuralNetwork();
    init_ops();
    init_utils();
    init_extractParams3();
    init_extractParamsFromWeigthMap3();
    TinyXception = /** @class */
    function(_super) {
      __extends(TinyXception2, _super);
      function TinyXception2(numMainBlocks) {
        var _this = _super.call(this, "TinyXception") || this;
        _this._numMainBlocks = numMainBlocks;
        return _this;
      }
      TinyXception2.prototype.forwardInput = function(input2) {
        var _this = this;
        var params = this.params;
        if (!params) {
          throw new Error("TinyXception - load model before inference");
        }
        return Ze(function() {
          var batchTensor = input2.toBatchTensor(112, true);
          var meanRgb = [122.782, 117.001, 104.298];
          var normalized = normalize(batchTensor, meanRgb).div(On(256));
          var out = Bl(conv(normalized, params.entry_flow.conv_in, [2, 2]));
          out = reductionBlock(out, params.entry_flow.reduction_block_0, false);
          out = reductionBlock(out, params.entry_flow.reduction_block_1);
          range(_this._numMainBlocks, 0, 1).forEach(function(idx) {
            out = mainBlock(out, params.middle_flow["main_block_" + idx]);
          });
          out = reductionBlock(out, params.exit_flow.reduction_block);
          out = Bl(depthwiseSeparableConv(out, params.exit_flow.separable_conv, [1, 1]));
          return out;
        });
      };
      TinyXception2.prototype.forward = function(input2) {
        return __awaiter2(this, void 0, void 0, function() {
          var _a2;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _a2 = this.forwardInput;
                return [4, toNetInput(input2)];
              case 1:
                return [2, _a2.apply(this, [_b.sent()])];
            }
          });
        });
      };
      TinyXception2.prototype.getDefaultModelName = function() {
        return "tiny_xception_model";
      };
      TinyXception2.prototype.extractParamsFromWeigthMap = function(weightMap) {
        return extractParamsFromWeigthMap3(weightMap, this._numMainBlocks);
      };
      TinyXception2.prototype.extractParams = function(weights) {
        return extractParams3(weights, this._numMainBlocks);
      };
      return TinyXception2;
    }(NeuralNetwork);
  }
});

// node_modules/face-api.js/build/es6/ageGenderNet/extractParams.js
function extractParams4(weights) {
  var paramMappings = [];
  var _a2 = extractWeightsFactory(weights), extractWeights = _a2.extractWeights, getRemainingWeights = _a2.getRemainingWeights;
  var extractFCParams = extractFCParamsFactory(extractWeights, paramMappings);
  var age = extractFCParams(512, 1, "fc/age");
  var gender = extractFCParams(512, 2, "fc/gender");
  if (getRemainingWeights().length !== 0) {
    throw new Error("weights remaing after extract: " + getRemainingWeights().length);
  }
  return {
    paramMappings,
    params: { fc: { age, gender } }
  };
}
var init_extractParams4 = __esm({
  "node_modules/face-api.js/build/es6/ageGenderNet/extractParams.js"() {
    "use strict";
    init_common2();
  }
});

// node_modules/face-api.js/build/es6/ageGenderNet/extractParamsFromWeigthMap.js
function extractParamsFromWeigthMap4(weightMap) {
  var paramMappings = [];
  var extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);
  function extractFcParams(prefix) {
    var weights = extractWeightEntry(prefix + "/weights", 2);
    var bias = extractWeightEntry(prefix + "/bias", 1);
    return { weights, bias };
  }
  var params = {
    fc: {
      age: extractFcParams("fc/age"),
      gender: extractFcParams("fc/gender")
    }
  };
  disposeUnusedWeightTensors(weightMap, paramMappings);
  return { params, paramMappings };
}
var init_extractParamsFromWeigthMap4 = __esm({
  "node_modules/face-api.js/build/es6/ageGenderNet/extractParamsFromWeigthMap.js"() {
    "use strict";
    init_common2();
  }
});

// node_modules/face-api.js/build/es6/ageGenderNet/types.js
var Gender;
var init_types3 = __esm({
  "node_modules/face-api.js/build/es6/ageGenderNet/types.js"() {
    "use strict";
    (function(Gender2) {
      Gender2["FEMALE"] = "female";
      Gender2["MALE"] = "male";
    })(Gender || (Gender = {}));
  }
});

// node_modules/face-api.js/build/es6/ageGenderNet/AgeGenderNet.js
var AgeGenderNet;
var init_AgeGenderNet = __esm({
  "node_modules/face-api.js/build/es6/ageGenderNet/AgeGenderNet.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_fullyConnectedLayer();
    init_util();
    init_TinyXception();
    init_extractParams4();
    init_extractParamsFromWeigthMap4();
    init_types3();
    init_NeuralNetwork();
    init_dom();
    AgeGenderNet = /** @class */
    function(_super) {
      __extends(AgeGenderNet2, _super);
      function AgeGenderNet2(faceFeatureExtractor) {
        if (faceFeatureExtractor === void 0) {
          faceFeatureExtractor = new TinyXception(2);
        }
        var _this = _super.call(this, "AgeGenderNet") || this;
        _this._faceFeatureExtractor = faceFeatureExtractor;
        return _this;
      }
      Object.defineProperty(AgeGenderNet2.prototype, "faceFeatureExtractor", {
        get: function() {
          return this._faceFeatureExtractor;
        },
        enumerable: true,
        configurable: true
      });
      AgeGenderNet2.prototype.runNet = function(input2) {
        var _this = this;
        var params = this.params;
        if (!params) {
          throw new Error(this._name + " - load model before inference");
        }
        return Ze(function() {
          var bottleneckFeatures = input2 instanceof NetInput ? _this.faceFeatureExtractor.forwardInput(input2) : input2;
          var pooled = fl(bottleneckFeatures, [7, 7], [2, 2], "valid").as2D(bottleneckFeatures.shape[0], -1);
          var age = fullyConnectedLayer(pooled, params.fc.age).as1D();
          var gender = fullyConnectedLayer(pooled, params.fc.gender);
          return { age, gender };
        });
      };
      AgeGenderNet2.prototype.forwardInput = function(input2) {
        var _this = this;
        return Ze(function() {
          var _a2 = _this.runNet(input2), age = _a2.age, gender = _a2.gender;
          return { age, gender: go(gender) };
        });
      };
      AgeGenderNet2.prototype.forward = function(input2) {
        return __awaiter2(this, void 0, void 0, function() {
          var _a2;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _a2 = this.forwardInput;
                return [4, toNetInput(input2)];
              case 1:
                return [2, _a2.apply(this, [_b.sent()])];
            }
          });
        });
      };
      AgeGenderNet2.prototype.predictAgeAndGender = function(input2) {
        return __awaiter2(this, void 0, void 0, function() {
          var netInput, out, ages, genders, ageAndGenderTensors, predictionsByBatch;
          var _this = this;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, toNetInput(input2)];
              case 1:
                netInput = _a2.sent();
                return [4, this.forwardInput(netInput)];
              case 2:
                out = _a2.sent();
                ages = Ur(out.age);
                genders = Ur(out.gender);
                ageAndGenderTensors = ages.map(function(ageTensor, i2) {
                  return {
                    ageTensor,
                    genderTensor: genders[i2]
                  };
                });
                return [4, Promise.all(ageAndGenderTensors.map(function(_a3) {
                  var ageTensor = _a3.ageTensor, genderTensor = _a3.genderTensor;
                  return __awaiter2(_this, void 0, void 0, function() {
                    var age, probMale, isMale, gender, genderProbability;
                    return __generator(this, function(_b) {
                      switch (_b.label) {
                        case 0:
                          return [4, ageTensor.data()];
                        case 1:
                          age = _b.sent()[0];
                          return [4, genderTensor.data()];
                        case 2:
                          probMale = _b.sent()[0];
                          isMale = probMale > 0.5;
                          gender = isMale ? Gender.MALE : Gender.FEMALE;
                          genderProbability = isMale ? probMale : 1 - probMale;
                          ageTensor.dispose();
                          genderTensor.dispose();
                          return [2, { age, gender, genderProbability }];
                      }
                    });
                  });
                }))];
              case 3:
                predictionsByBatch = _a2.sent();
                out.age.dispose();
                out.gender.dispose();
                return [2, netInput.isBatchInput ? predictionsByBatch : predictionsByBatch[0]];
            }
          });
        });
      };
      AgeGenderNet2.prototype.getDefaultModelName = function() {
        return "age_gender_model";
      };
      AgeGenderNet2.prototype.dispose = function(throwOnRedispose) {
        if (throwOnRedispose === void 0) {
          throwOnRedispose = true;
        }
        this.faceFeatureExtractor.dispose(throwOnRedispose);
        _super.prototype.dispose.call(this, throwOnRedispose);
      };
      AgeGenderNet2.prototype.loadClassifierParams = function(weights) {
        var _a2 = this.extractClassifierParams(weights), params = _a2.params, paramMappings = _a2.paramMappings;
        this._params = params;
        this._paramMappings = paramMappings;
      };
      AgeGenderNet2.prototype.extractClassifierParams = function(weights) {
        return extractParams4(weights);
      };
      AgeGenderNet2.prototype.extractParamsFromWeigthMap = function(weightMap) {
        var _a2 = seperateWeightMaps(weightMap), featureExtractorMap = _a2.featureExtractorMap, classifierMap = _a2.classifierMap;
        this.faceFeatureExtractor.loadFromWeightMap(featureExtractorMap);
        return extractParamsFromWeigthMap4(classifierMap);
      };
      AgeGenderNet2.prototype.extractParams = function(weights) {
        var classifierWeightSize = 512 * 1 + 1 + (512 * 2 + 2);
        var featureExtractorWeights = weights.slice(0, weights.length - classifierWeightSize);
        var classifierWeights = weights.slice(weights.length - classifierWeightSize);
        this.faceFeatureExtractor.extractWeights(featureExtractorWeights);
        return this.extractClassifierParams(classifierWeights);
      };
      return AgeGenderNet2;
    }(NeuralNetwork);
  }
});

// node_modules/face-api.js/build/es6/ageGenderNet/index.js
var init_ageGenderNet = __esm({
  "node_modules/face-api.js/build/es6/ageGenderNet/index.js"() {
    "use strict";
    init_AgeGenderNet();
    init_types3();
  }
});

// node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68NetBase.js
var FaceLandmark68NetBase;
var init_FaceLandmark68NetBase = __esm({
  "node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68NetBase.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_classes();
    init_FaceLandmarks68();
    init_dom();
    init_FaceProcessor();
    init_utils();
    FaceLandmark68NetBase = /** @class */
    function(_super) {
      __extends(FaceLandmark68NetBase2, _super);
      function FaceLandmark68NetBase2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      FaceLandmark68NetBase2.prototype.postProcess = function(output, inputSize, originalDimensions) {
        var inputDimensions = originalDimensions.map(function(_a2) {
          var width = _a2.width, height = _a2.height;
          var scale2 = inputSize / Math.max(height, width);
          return {
            width: width * scale2,
            height: height * scale2
          };
        });
        var batchSize = inputDimensions.length;
        return Ze(function() {
          var createInterleavedTensor = function(fillX, fillY) {
            return Pr([
              Hn([68], fillX),
              Hn([68], fillY)
            ], 1).as2D(1, 136).as1D();
          };
          var getPadding = function(batchIdx, cond) {
            var _a2 = inputDimensions[batchIdx], width = _a2.width, height = _a2.height;
            return cond(width, height) ? Math.abs(width - height) / 2 : 0;
          };
          var getPaddingX = function(batchIdx) {
            return getPadding(batchIdx, function(w2, h2) {
              return w2 < h2;
            });
          };
          var getPaddingY = function(batchIdx) {
            return getPadding(batchIdx, function(w2, h2) {
              return h2 < w2;
            });
          };
          var landmarkTensors = output.mul(Hn([batchSize, 136], inputSize)).sub(Pr(Array.from(Array(batchSize), function(_2, batchIdx) {
            return createInterleavedTensor(getPaddingX(batchIdx), getPaddingY(batchIdx));
          }))).div(Pr(Array.from(Array(batchSize), function(_2, batchIdx) {
            return createInterleavedTensor(inputDimensions[batchIdx].width, inputDimensions[batchIdx].height);
          })));
          return landmarkTensors;
        });
      };
      FaceLandmark68NetBase2.prototype.forwardInput = function(input2) {
        var _this = this;
        return Ze(function() {
          var out = _this.runNet(input2);
          return _this.postProcess(out, input2.inputSize, input2.inputDimensions.map(function(_a2) {
            var height = _a2[0], width = _a2[1];
            return { height, width };
          }));
        });
      };
      FaceLandmark68NetBase2.prototype.forward = function(input2) {
        return __awaiter2(this, void 0, void 0, function() {
          var _a2;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _a2 = this.forwardInput;
                return [4, toNetInput(input2)];
              case 1:
                return [2, _a2.apply(this, [_b.sent()])];
            }
          });
        });
      };
      FaceLandmark68NetBase2.prototype.detectLandmarks = function(input2) {
        return __awaiter2(this, void 0, void 0, function() {
          var netInput, landmarkTensors, landmarksForBatch;
          var _this = this;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, toNetInput(input2)];
              case 1:
                netInput = _a2.sent();
                landmarkTensors = Ze(function() {
                  return Ur(_this.forwardInput(netInput));
                });
                return [4, Promise.all(landmarkTensors.map(function(landmarkTensor, batchIdx) {
                  return __awaiter2(_this, void 0, void 0, function() {
                    var landmarksArray, _a3, _b, xCoords, yCoords;
                    return __generator(this, function(_c6) {
                      switch (_c6.label) {
                        case 0:
                          _b = (_a3 = Array).from;
                          return [4, landmarkTensor.data()];
                        case 1:
                          landmarksArray = _b.apply(_a3, [_c6.sent()]);
                          xCoords = landmarksArray.filter(function(_2, i2) {
                            return isEven(i2);
                          });
                          yCoords = landmarksArray.filter(function(_2, i2) {
                            return !isEven(i2);
                          });
                          return [2, new FaceLandmarks68(Array(68).fill(0).map(function(_2, i2) {
                            return new Point(xCoords[i2], yCoords[i2]);
                          }), {
                            height: netInput.getInputHeight(batchIdx),
                            width: netInput.getInputWidth(batchIdx)
                          })];
                      }
                    });
                  });
                }))];
              case 2:
                landmarksForBatch = _a2.sent();
                landmarkTensors.forEach(function(t2) {
                  return t2.dispose();
                });
                return [2, netInput.isBatchInput ? landmarksForBatch : landmarksForBatch[0]];
            }
          });
        });
      };
      FaceLandmark68NetBase2.prototype.getClassifierChannelsOut = function() {
        return 136;
      };
      return FaceLandmark68NetBase2;
    }(FaceProcessor);
  }
});

// node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68Net.js
var FaceLandmark68Net;
var init_FaceLandmark68Net = __esm({
  "node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68Net.js"() {
    "use strict";
    init_tslib_es62();
    init_FaceFeatureExtractor();
    init_FaceLandmark68NetBase();
    FaceLandmark68Net = /** @class */
    function(_super) {
      __extends(FaceLandmark68Net2, _super);
      function FaceLandmark68Net2(faceFeatureExtractor) {
        if (faceFeatureExtractor === void 0) {
          faceFeatureExtractor = new FaceFeatureExtractor();
        }
        return _super.call(this, "FaceLandmark68Net", faceFeatureExtractor) || this;
      }
      FaceLandmark68Net2.prototype.getDefaultModelName = function() {
        return "face_landmark_68_model";
      };
      FaceLandmark68Net2.prototype.getClassifierChannelsIn = function() {
        return 256;
      };
      return FaceLandmark68Net2;
    }(FaceLandmark68NetBase);
  }
});

// node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsFromWeigthMapTiny.js
function extractParamsFromWeigthMapTiny(weightMap) {
  var paramMappings = [];
  var extractDenseBlock3Params = loadParamsFactory(weightMap, paramMappings).extractDenseBlock3Params;
  var params = {
    dense0: extractDenseBlock3Params("dense0", true),
    dense1: extractDenseBlock3Params("dense1"),
    dense2: extractDenseBlock3Params("dense2")
  };
  disposeUnusedWeightTensors(weightMap, paramMappings);
  return { params, paramMappings };
}
var init_extractParamsFromWeigthMapTiny = __esm({
  "node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsFromWeigthMapTiny.js"() {
    "use strict";
    init_common2();
    init_loadParamsFactory();
  }
});

// node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsTiny.js
function extractParamsTiny(weights) {
  var paramMappings = [];
  var _a2 = extractWeightsFactory(weights), extractWeights = _a2.extractWeights, getRemainingWeights = _a2.getRemainingWeights;
  var extractDenseBlock3Params = extractorsFactory(extractWeights, paramMappings).extractDenseBlock3Params;
  var dense0 = extractDenseBlock3Params(3, 32, "dense0", true);
  var dense1 = extractDenseBlock3Params(32, 64, "dense1");
  var dense2 = extractDenseBlock3Params(64, 128, "dense2");
  if (getRemainingWeights().length !== 0) {
    throw new Error("weights remaing after extract: " + getRemainingWeights().length);
  }
  return {
    paramMappings,
    params: { dense0, dense1, dense2 }
  };
}
var init_extractParamsTiny = __esm({
  "node_modules/face-api.js/build/es6/faceFeatureExtractor/extractParamsTiny.js"() {
    "use strict";
    init_common2();
    init_extractorsFactory();
  }
});

// node_modules/face-api.js/build/es6/faceFeatureExtractor/TinyFaceFeatureExtractor.js
var TinyFaceFeatureExtractor;
var init_TinyFaceFeatureExtractor = __esm({
  "node_modules/face-api.js/build/es6/faceFeatureExtractor/TinyFaceFeatureExtractor.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_dom();
    init_NeuralNetwork();
    init_ops();
    init_denseBlock();
    init_extractParamsFromWeigthMapTiny();
    init_extractParamsTiny();
    TinyFaceFeatureExtractor = /** @class */
    function(_super) {
      __extends(TinyFaceFeatureExtractor2, _super);
      function TinyFaceFeatureExtractor2() {
        return _super.call(this, "TinyFaceFeatureExtractor") || this;
      }
      TinyFaceFeatureExtractor2.prototype.forwardInput = function(input2) {
        var params = this.params;
        if (!params) {
          throw new Error("TinyFaceFeatureExtractor - load model before inference");
        }
        return Ze(function() {
          var batchTensor = input2.toBatchTensor(112, true);
          var meanRgb = [122.782, 117.001, 104.298];
          var normalized = normalize(batchTensor, meanRgb).div(On(255));
          var out = denseBlock3(normalized, params.dense0, true);
          out = denseBlock3(out, params.dense1);
          out = denseBlock3(out, params.dense2);
          out = fl(out, [14, 14], [2, 2], "valid");
          return out;
        });
      };
      TinyFaceFeatureExtractor2.prototype.forward = function(input2) {
        return __awaiter2(this, void 0, void 0, function() {
          var _a2;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _a2 = this.forwardInput;
                return [4, toNetInput(input2)];
              case 1:
                return [2, _a2.apply(this, [_b.sent()])];
            }
          });
        });
      };
      TinyFaceFeatureExtractor2.prototype.getDefaultModelName = function() {
        return "face_feature_extractor_tiny_model";
      };
      TinyFaceFeatureExtractor2.prototype.extractParamsFromWeigthMap = function(weightMap) {
        return extractParamsFromWeigthMapTiny(weightMap);
      };
      TinyFaceFeatureExtractor2.prototype.extractParams = function(weights) {
        return extractParamsTiny(weights);
      };
      return TinyFaceFeatureExtractor2;
    }(NeuralNetwork);
  }
});

// node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68TinyNet.js
var FaceLandmark68TinyNet;
var init_FaceLandmark68TinyNet = __esm({
  "node_modules/face-api.js/build/es6/faceLandmarkNet/FaceLandmark68TinyNet.js"() {
    "use strict";
    init_tslib_es62();
    init_TinyFaceFeatureExtractor();
    init_FaceLandmark68NetBase();
    FaceLandmark68TinyNet = /** @class */
    function(_super) {
      __extends(FaceLandmark68TinyNet2, _super);
      function FaceLandmark68TinyNet2(faceFeatureExtractor) {
        if (faceFeatureExtractor === void 0) {
          faceFeatureExtractor = new TinyFaceFeatureExtractor();
        }
        return _super.call(this, "FaceLandmark68TinyNet", faceFeatureExtractor) || this;
      }
      FaceLandmark68TinyNet2.prototype.getDefaultModelName = function() {
        return "face_landmark_68_tiny_model";
      };
      FaceLandmark68TinyNet2.prototype.getClassifierChannelsIn = function() {
        return 128;
      };
      return FaceLandmark68TinyNet2;
    }(FaceLandmark68NetBase);
  }
});

// node_modules/face-api.js/build/es6/faceLandmarkNet/index.js
var FaceLandmarkNet;
var init_faceLandmarkNet = __esm({
  "node_modules/face-api.js/build/es6/faceLandmarkNet/index.js"() {
    "use strict";
    init_tslib_es62();
    init_FaceLandmark68Net();
    init_FaceLandmark68Net();
    init_FaceLandmark68TinyNet();
    FaceLandmarkNet = /** @class */
    function(_super) {
      __extends(FaceLandmarkNet2, _super);
      function FaceLandmarkNet2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return FaceLandmarkNet2;
    }(FaceLandmark68Net);
  }
});

// node_modules/face-api.js/build/es6/faceRecognitionNet/scaleLayer.js
function scale(x2, params) {
  return rc(gc(x2, params.weights), params.biases);
}
var init_scaleLayer = __esm({
  "node_modules/face-api.js/build/es6/faceRecognitionNet/scaleLayer.js"() {
    "use strict";
    init_tf_core_esm();
  }
});

// node_modules/face-api.js/build/es6/faceRecognitionNet/convLayer.js
function convLayer2(x2, params, strides, withRelu, padding) {
  if (padding === void 0) {
    padding = "same";
  }
  var _a2 = params.conv, filters = _a2.filters, bias = _a2.bias;
  var out = qc(x2, filters, strides, padding);
  out = rc(out, bias);
  out = scale(out, params.scale);
  return withRelu ? Bl(out) : out;
}
function conv2(x2, params) {
  return convLayer2(x2, params, [1, 1], true);
}
function convNoRelu(x2, params) {
  return convLayer2(x2, params, [1, 1], false);
}
function convDown(x2, params) {
  return convLayer2(x2, params, [2, 2], true, "valid");
}
var init_convLayer2 = __esm({
  "node_modules/face-api.js/build/es6/faceRecognitionNet/convLayer.js"() {
    "use strict";
    init_tf_core_esm();
    init_scaleLayer();
  }
});

// node_modules/face-api.js/build/es6/faceRecognitionNet/extractParams.js
function extractorsFactory3(extractWeights, paramMappings) {
  function extractFilterValues(numFilterValues, numFilters, filterSize) {
    var weights = extractWeights(numFilterValues);
    var depth = weights.length / (numFilters * filterSize * filterSize);
    if (isFloat(depth)) {
      throw new Error("depth has to be an integer: " + depth + ", weights.length: " + weights.length + ", numFilters: " + numFilters + ", filterSize: " + filterSize);
    }
    return Ze(function() {
      return Wl(Ln(weights, [numFilters, depth, filterSize, filterSize]), [2, 3, 1, 0]);
    });
  }
  function extractConvParams(numFilterValues, numFilters, filterSize, mappedPrefix) {
    var filters = extractFilterValues(numFilterValues, numFilters, filterSize);
    var bias = Mn(extractWeights(numFilters));
    paramMappings.push({ paramPath: mappedPrefix + "/filters" }, { paramPath: mappedPrefix + "/bias" });
    return { filters, bias };
  }
  function extractScaleLayerParams(numWeights, mappedPrefix) {
    var weights = Mn(extractWeights(numWeights));
    var biases = Mn(extractWeights(numWeights));
    paramMappings.push({ paramPath: mappedPrefix + "/weights" }, { paramPath: mappedPrefix + "/biases" });
    return {
      weights,
      biases
    };
  }
  function extractConvLayerParams(numFilterValues, numFilters, filterSize, mappedPrefix) {
    var conv3 = extractConvParams(numFilterValues, numFilters, filterSize, mappedPrefix + "/conv");
    var scale2 = extractScaleLayerParams(numFilters, mappedPrefix + "/scale");
    return { conv: conv3, scale: scale2 };
  }
  function extractResidualLayerParams(numFilterValues, numFilters, filterSize, mappedPrefix, isDown) {
    if (isDown === void 0) {
      isDown = false;
    }
    var conv1 = extractConvLayerParams((isDown ? 0.5 : 1) * numFilterValues, numFilters, filterSize, mappedPrefix + "/conv1");
    var conv22 = extractConvLayerParams(numFilterValues, numFilters, filterSize, mappedPrefix + "/conv2");
    return { conv1, conv2: conv22 };
  }
  return {
    extractConvLayerParams,
    extractResidualLayerParams
  };
}
function extractParams5(weights) {
  var _a2 = extractWeightsFactory(weights), extractWeights = _a2.extractWeights, getRemainingWeights = _a2.getRemainingWeights;
  var paramMappings = [];
  var _b = extractorsFactory3(extractWeights, paramMappings), extractConvLayerParams = _b.extractConvLayerParams, extractResidualLayerParams = _b.extractResidualLayerParams;
  var conv32_down = extractConvLayerParams(4704, 32, 7, "conv32_down");
  var conv32_1 = extractResidualLayerParams(9216, 32, 3, "conv32_1");
  var conv32_2 = extractResidualLayerParams(9216, 32, 3, "conv32_2");
  var conv32_3 = extractResidualLayerParams(9216, 32, 3, "conv32_3");
  var conv64_down = extractResidualLayerParams(36864, 64, 3, "conv64_down", true);
  var conv64_1 = extractResidualLayerParams(36864, 64, 3, "conv64_1");
  var conv64_2 = extractResidualLayerParams(36864, 64, 3, "conv64_2");
  var conv64_3 = extractResidualLayerParams(36864, 64, 3, "conv64_3");
  var conv128_down = extractResidualLayerParams(147456, 128, 3, "conv128_down", true);
  var conv128_1 = extractResidualLayerParams(147456, 128, 3, "conv128_1");
  var conv128_2 = extractResidualLayerParams(147456, 128, 3, "conv128_2");
  var conv256_down = extractResidualLayerParams(589824, 256, 3, "conv256_down", true);
  var conv256_1 = extractResidualLayerParams(589824, 256, 3, "conv256_1");
  var conv256_2 = extractResidualLayerParams(589824, 256, 3, "conv256_2");
  var conv256_down_out = extractResidualLayerParams(589824, 256, 3, "conv256_down_out");
  var fc2 = Ze(function() {
    return Wl(Bn(extractWeights(256 * 128), [128, 256]), [1, 0]);
  });
  paramMappings.push({ paramPath: "fc" });
  if (getRemainingWeights().length !== 0) {
    throw new Error("weights remaing after extract: " + getRemainingWeights().length);
  }
  var params = {
    conv32_down,
    conv32_1,
    conv32_2,
    conv32_3,
    conv64_down,
    conv64_1,
    conv64_2,
    conv64_3,
    conv128_down,
    conv128_1,
    conv128_2,
    conv256_down,
    conv256_1,
    conv256_2,
    conv256_down_out,
    fc: fc2
  };
  return { params, paramMappings };
}
var init_extractParams5 = __esm({
  "node_modules/face-api.js/build/es6/faceRecognitionNet/extractParams.js"() {
    "use strict";
    init_tf_core_esm();
    init_common2();
    init_utils();
  }
});

// node_modules/face-api.js/build/es6/faceRecognitionNet/extractParamsFromWeigthMap.js
function extractorsFactory4(weightMap, paramMappings) {
  var extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);
  function extractScaleLayerParams(prefix) {
    var weights = extractWeightEntry(prefix + "/scale/weights", 1);
    var biases = extractWeightEntry(prefix + "/scale/biases", 1);
    return { weights, biases };
  }
  function extractConvLayerParams(prefix) {
    var filters = extractWeightEntry(prefix + "/conv/filters", 4);
    var bias = extractWeightEntry(prefix + "/conv/bias", 1);
    var scale2 = extractScaleLayerParams(prefix);
    return { conv: { filters, bias }, scale: scale2 };
  }
  function extractResidualLayerParams(prefix) {
    return {
      conv1: extractConvLayerParams(prefix + "/conv1"),
      conv2: extractConvLayerParams(prefix + "/conv2")
    };
  }
  return {
    extractConvLayerParams,
    extractResidualLayerParams
  };
}
function extractParamsFromWeigthMap5(weightMap) {
  var paramMappings = [];
  var _a2 = extractorsFactory4(weightMap, paramMappings), extractConvLayerParams = _a2.extractConvLayerParams, extractResidualLayerParams = _a2.extractResidualLayerParams;
  var conv32_down = extractConvLayerParams("conv32_down");
  var conv32_1 = extractResidualLayerParams("conv32_1");
  var conv32_2 = extractResidualLayerParams("conv32_2");
  var conv32_3 = extractResidualLayerParams("conv32_3");
  var conv64_down = extractResidualLayerParams("conv64_down");
  var conv64_1 = extractResidualLayerParams("conv64_1");
  var conv64_2 = extractResidualLayerParams("conv64_2");
  var conv64_3 = extractResidualLayerParams("conv64_3");
  var conv128_down = extractResidualLayerParams("conv128_down");
  var conv128_1 = extractResidualLayerParams("conv128_1");
  var conv128_2 = extractResidualLayerParams("conv128_2");
  var conv256_down = extractResidualLayerParams("conv256_down");
  var conv256_1 = extractResidualLayerParams("conv256_1");
  var conv256_2 = extractResidualLayerParams("conv256_2");
  var conv256_down_out = extractResidualLayerParams("conv256_down_out");
  var fc2 = weightMap["fc"];
  paramMappings.push({ originalPath: "fc", paramPath: "fc" });
  if (!isTensor2D(fc2)) {
    throw new Error("expected weightMap[fc] to be a Tensor2D, instead have " + fc2);
  }
  var params = {
    conv32_down,
    conv32_1,
    conv32_2,
    conv32_3,
    conv64_down,
    conv64_1,
    conv64_2,
    conv64_3,
    conv128_down,
    conv128_1,
    conv128_2,
    conv256_down,
    conv256_1,
    conv256_2,
    conv256_down_out,
    fc: fc2
  };
  disposeUnusedWeightTensors(weightMap, paramMappings);
  return { params, paramMappings };
}
var init_extractParamsFromWeigthMap5 = __esm({
  "node_modules/face-api.js/build/es6/faceRecognitionNet/extractParamsFromWeigthMap.js"() {
    "use strict";
    init_common2();
    init_utils();
  }
});

// node_modules/face-api.js/build/es6/faceRecognitionNet/residualLayer.js
function residual(x2, params) {
  var out = conv2(x2, params.conv1);
  out = convNoRelu(out, params.conv2);
  out = rc(out, x2);
  out = Bl(out);
  return out;
}
function residualDown(x2, params) {
  var out = convDown(x2, params.conv1);
  out = convNoRelu(out, params.conv2);
  var pooled = fl(x2, 2, 2, "valid");
  var zeros = Gn(pooled.shape);
  var isPad = pooled.shape[3] !== out.shape[3];
  var isAdjustShape = pooled.shape[1] !== out.shape[1] || pooled.shape[2] !== out.shape[2];
  if (isAdjustShape) {
    var padShapeX = __spreadArrays(out.shape);
    padShapeX[1] = 1;
    var zerosW = Gn(padShapeX);
    out = Yn([out, zerosW], 1);
    var padShapeY = __spreadArrays(out.shape);
    padShapeY[2] = 1;
    var zerosH = Gn(padShapeY);
    out = Yn([out, zerosH], 2);
  }
  pooled = isPad ? Yn([pooled, zeros], 3) : pooled;
  out = rc(pooled, out);
  out = Bl(out);
  return out;
}
var init_residualLayer = __esm({
  "node_modules/face-api.js/build/es6/faceRecognitionNet/residualLayer.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_convLayer2();
  }
});

// node_modules/face-api.js/build/es6/faceRecognitionNet/FaceRecognitionNet.js
var FaceRecognitionNet;
var init_FaceRecognitionNet = __esm({
  "node_modules/face-api.js/build/es6/faceRecognitionNet/FaceRecognitionNet.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_dom();
    init_NeuralNetwork();
    init_ops();
    init_convLayer2();
    init_extractParams5();
    init_extractParamsFromWeigthMap5();
    init_residualLayer();
    FaceRecognitionNet = /** @class */
    function(_super) {
      __extends(FaceRecognitionNet2, _super);
      function FaceRecognitionNet2() {
        return _super.call(this, "FaceRecognitionNet") || this;
      }
      FaceRecognitionNet2.prototype.forwardInput = function(input2) {
        var params = this.params;
        if (!params) {
          throw new Error("FaceRecognitionNet - load model before inference");
        }
        return Ze(function() {
          var batchTensor = input2.toBatchTensor(150, true).toFloat();
          var meanRgb = [122.782, 117.001, 104.298];
          var normalized = normalize(batchTensor, meanRgb).div(On(256));
          var out = convDown(normalized, params.conv32_down);
          out = hl(out, 3, 2, "valid");
          out = residual(out, params.conv32_1);
          out = residual(out, params.conv32_2);
          out = residual(out, params.conv32_3);
          out = residualDown(out, params.conv64_down);
          out = residual(out, params.conv64_1);
          out = residual(out, params.conv64_2);
          out = residual(out, params.conv64_3);
          out = residualDown(out, params.conv128_down);
          out = residual(out, params.conv128_1);
          out = residual(out, params.conv128_2);
          out = residualDown(out, params.conv256_down);
          out = residual(out, params.conv256_1);
          out = residual(out, params.conv256_2);
          out = residualDown(out, params.conv256_down_out);
          var globalAvg = out.mean([1, 2]);
          var fullyConnected = el(globalAvg, params.fc);
          return fullyConnected;
        });
      };
      FaceRecognitionNet2.prototype.forward = function(input2) {
        return __awaiter2(this, void 0, void 0, function() {
          var _a2;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _a2 = this.forwardInput;
                return [4, toNetInput(input2)];
              case 1:
                return [2, _a2.apply(this, [_b.sent()])];
            }
          });
        });
      };
      FaceRecognitionNet2.prototype.computeFaceDescriptor = function(input2) {
        return __awaiter2(this, void 0, void 0, function() {
          var netInput, faceDescriptorTensors, faceDescriptorsForBatch;
          var _this = this;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, toNetInput(input2)];
              case 1:
                netInput = _a2.sent();
                faceDescriptorTensors = Ze(function() {
                  return Ur(_this.forwardInput(netInput));
                });
                return [4, Promise.all(faceDescriptorTensors.map(function(t2) {
                  return t2.data();
                }))];
              case 2:
                faceDescriptorsForBatch = _a2.sent();
                faceDescriptorTensors.forEach(function(t2) {
                  return t2.dispose();
                });
                return [2, netInput.isBatchInput ? faceDescriptorsForBatch : faceDescriptorsForBatch[0]];
            }
          });
        });
      };
      FaceRecognitionNet2.prototype.getDefaultModelName = function() {
        return "face_recognition_model";
      };
      FaceRecognitionNet2.prototype.extractParamsFromWeigthMap = function(weightMap) {
        return extractParamsFromWeigthMap5(weightMap);
      };
      FaceRecognitionNet2.prototype.extractParams = function(weights) {
        return extractParams5(weights);
      };
      return FaceRecognitionNet2;
    }(NeuralNetwork);
  }
});

// node_modules/face-api.js/build/es6/faceRecognitionNet/index.js
var init_faceRecognitionNet = __esm({
  "node_modules/face-api.js/build/es6/faceRecognitionNet/index.js"() {
    "use strict";
    init_FaceRecognitionNet();
    init_FaceRecognitionNet();
  }
});

// node_modules/face-api.js/build/es6/factories/WithFaceDescriptor.js
function extendWithFaceDescriptor(sourceObj, descriptor) {
  var extension = { descriptor };
  return Object.assign({}, sourceObj, extension);
}
var init_WithFaceDescriptor = __esm({
  "node_modules/face-api.js/build/es6/factories/WithFaceDescriptor.js"() {
    "use strict";
  }
});

// node_modules/face-api.js/build/es6/factories/WithAge.js
function extendWithAge(sourceObj, age) {
  var extension = { age };
  return Object.assign({}, sourceObj, extension);
}
var init_WithAge = __esm({
  "node_modules/face-api.js/build/es6/factories/WithAge.js"() {
    "use strict";
  }
});

// node_modules/face-api.js/build/es6/factories/WithGender.js
function extendWithGender(sourceObj, gender, genderProbability) {
  var extension = { gender, genderProbability };
  return Object.assign({}, sourceObj, extension);
}
var init_WithGender = __esm({
  "node_modules/face-api.js/build/es6/factories/WithGender.js"() {
    "use strict";
    init_types3();
    init_utils();
  }
});

// node_modules/face-api.js/build/es6/factories/index.js
var init_factories = __esm({
  "node_modules/face-api.js/build/es6/factories/index.js"() {
    "use strict";
    init_WithFaceDescriptor();
    init_WithFaceDetection();
    init_WithFaceExpressions();
    init_WithFaceLandmarks();
    init_WithAge();
    init_WithGender();
  }
});

// node_modules/face-api.js/build/es6/mtcnn/MtcnnOptions.js
var MtcnnOptions;
var init_MtcnnOptions = __esm({
  "node_modules/face-api.js/build/es6/mtcnn/MtcnnOptions.js"() {
    "use strict";
    MtcnnOptions = /** @class */
    function() {
      function MtcnnOptions2(_a2) {
        var _b = _a2 === void 0 ? {} : _a2, minFaceSize = _b.minFaceSize, scaleFactor = _b.scaleFactor, maxNumScales = _b.maxNumScales, scoreThresholds = _b.scoreThresholds, scaleSteps = _b.scaleSteps;
        this._name = "MtcnnOptions";
        this._minFaceSize = minFaceSize || 20;
        this._scaleFactor = scaleFactor || 0.709;
        this._maxNumScales = maxNumScales || 10;
        this._scoreThresholds = scoreThresholds || [0.6, 0.7, 0.7];
        this._scaleSteps = scaleSteps;
        if (typeof this._minFaceSize !== "number" || this._minFaceSize < 0) {
          throw new Error(this._name + " - expected minFaceSize to be a number > 0");
        }
        if (typeof this._scaleFactor !== "number" || this._scaleFactor <= 0 || this._scaleFactor >= 1) {
          throw new Error(this._name + " - expected scaleFactor to be a number between 0 and 1");
        }
        if (typeof this._maxNumScales !== "number" || this._maxNumScales < 0) {
          throw new Error(this._name + " - expected maxNumScales to be a number > 0");
        }
        if (!Array.isArray(this._scoreThresholds) || this._scoreThresholds.length !== 3 || this._scoreThresholds.some(function(th2) {
          return typeof th2 !== "number";
        })) {
          throw new Error(this._name + " - expected scoreThresholds to be an array of numbers of length 3");
        }
        if (this._scaleSteps && (!Array.isArray(this._scaleSteps) || this._scaleSteps.some(function(th2) {
          return typeof th2 !== "number";
        }))) {
          throw new Error(this._name + " - expected scaleSteps to be an array of numbers");
        }
      }
      Object.defineProperty(MtcnnOptions2.prototype, "minFaceSize", {
        get: function() {
          return this._minFaceSize;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(MtcnnOptions2.prototype, "scaleFactor", {
        get: function() {
          return this._scaleFactor;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(MtcnnOptions2.prototype, "maxNumScales", {
        get: function() {
          return this._maxNumScales;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(MtcnnOptions2.prototype, "scoreThresholds", {
        get: function() {
          return this._scoreThresholds;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(MtcnnOptions2.prototype, "scaleSteps", {
        get: function() {
          return this._scaleSteps;
        },
        enumerable: true,
        configurable: true
      });
      return MtcnnOptions2;
    }();
  }
});

// node_modules/face-api.js/build/es6/ssdMobilenetv1/extractParams.js
function extractorsFactory5(extractWeights, paramMappings) {
  function extractDepthwiseConvParams(numChannels, mappedPrefix) {
    var filters = Ln(extractWeights(3 * 3 * numChannels), [3, 3, numChannels, 1]);
    var batch_norm_scale = Mn(extractWeights(numChannels));
    var batch_norm_offset = Mn(extractWeights(numChannels));
    var batch_norm_mean = Mn(extractWeights(numChannels));
    var batch_norm_variance = Mn(extractWeights(numChannels));
    paramMappings.push({ paramPath: mappedPrefix + "/filters" }, { paramPath: mappedPrefix + "/batch_norm_scale" }, { paramPath: mappedPrefix + "/batch_norm_offset" }, { paramPath: mappedPrefix + "/batch_norm_mean" }, { paramPath: mappedPrefix + "/batch_norm_variance" });
    return {
      filters,
      batch_norm_scale,
      batch_norm_offset,
      batch_norm_mean,
      batch_norm_variance
    };
  }
  function extractConvParams(channelsIn, channelsOut, filterSize, mappedPrefix, isPointwiseConv) {
    var filters = Ln(extractWeights(channelsIn * channelsOut * filterSize * filterSize), [filterSize, filterSize, channelsIn, channelsOut]);
    var bias = Mn(extractWeights(channelsOut));
    paramMappings.push({ paramPath: mappedPrefix + "/filters" }, { paramPath: mappedPrefix + "/" + (isPointwiseConv ? "batch_norm_offset" : "bias") });
    return { filters, bias };
  }
  function extractPointwiseConvParams(channelsIn, channelsOut, filterSize, mappedPrefix) {
    var _a2 = extractConvParams(channelsIn, channelsOut, filterSize, mappedPrefix, true), filters = _a2.filters, bias = _a2.bias;
    return {
      filters,
      batch_norm_offset: bias
    };
  }
  function extractConvPairParams(channelsIn, channelsOut, mappedPrefix) {
    var depthwise_conv = extractDepthwiseConvParams(channelsIn, mappedPrefix + "/depthwise_conv");
    var pointwise_conv = extractPointwiseConvParams(channelsIn, channelsOut, 1, mappedPrefix + "/pointwise_conv");
    return { depthwise_conv, pointwise_conv };
  }
  function extractMobilenetV1Params() {
    var conv_0 = extractPointwiseConvParams(3, 32, 3, "mobilenetv1/conv_0");
    var conv_1 = extractConvPairParams(32, 64, "mobilenetv1/conv_1");
    var conv_2 = extractConvPairParams(64, 128, "mobilenetv1/conv_2");
    var conv_3 = extractConvPairParams(128, 128, "mobilenetv1/conv_3");
    var conv_4 = extractConvPairParams(128, 256, "mobilenetv1/conv_4");
    var conv_5 = extractConvPairParams(256, 256, "mobilenetv1/conv_5");
    var conv_6 = extractConvPairParams(256, 512, "mobilenetv1/conv_6");
    var conv_7 = extractConvPairParams(512, 512, "mobilenetv1/conv_7");
    var conv_8 = extractConvPairParams(512, 512, "mobilenetv1/conv_8");
    var conv_9 = extractConvPairParams(512, 512, "mobilenetv1/conv_9");
    var conv_10 = extractConvPairParams(512, 512, "mobilenetv1/conv_10");
    var conv_11 = extractConvPairParams(512, 512, "mobilenetv1/conv_11");
    var conv_12 = extractConvPairParams(512, 1024, "mobilenetv1/conv_12");
    var conv_13 = extractConvPairParams(1024, 1024, "mobilenetv1/conv_13");
    return {
      conv_0,
      conv_1,
      conv_2,
      conv_3,
      conv_4,
      conv_5,
      conv_6,
      conv_7,
      conv_8,
      conv_9,
      conv_10,
      conv_11,
      conv_12,
      conv_13
    };
  }
  function extractPredictionLayerParams() {
    var conv_0 = extractPointwiseConvParams(1024, 256, 1, "prediction_layer/conv_0");
    var conv_1 = extractPointwiseConvParams(256, 512, 3, "prediction_layer/conv_1");
    var conv_2 = extractPointwiseConvParams(512, 128, 1, "prediction_layer/conv_2");
    var conv_3 = extractPointwiseConvParams(128, 256, 3, "prediction_layer/conv_3");
    var conv_4 = extractPointwiseConvParams(256, 128, 1, "prediction_layer/conv_4");
    var conv_5 = extractPointwiseConvParams(128, 256, 3, "prediction_layer/conv_5");
    var conv_6 = extractPointwiseConvParams(256, 64, 1, "prediction_layer/conv_6");
    var conv_7 = extractPointwiseConvParams(64, 128, 3, "prediction_layer/conv_7");
    var box_encoding_0_predictor = extractConvParams(512, 12, 1, "prediction_layer/box_predictor_0/box_encoding_predictor");
    var class_predictor_0 = extractConvParams(512, 9, 1, "prediction_layer/box_predictor_0/class_predictor");
    var box_encoding_1_predictor = extractConvParams(1024, 24, 1, "prediction_layer/box_predictor_1/box_encoding_predictor");
    var class_predictor_1 = extractConvParams(1024, 18, 1, "prediction_layer/box_predictor_1/class_predictor");
    var box_encoding_2_predictor = extractConvParams(512, 24, 1, "prediction_layer/box_predictor_2/box_encoding_predictor");
    var class_predictor_2 = extractConvParams(512, 18, 1, "prediction_layer/box_predictor_2/class_predictor");
    var box_encoding_3_predictor = extractConvParams(256, 24, 1, "prediction_layer/box_predictor_3/box_encoding_predictor");
    var class_predictor_3 = extractConvParams(256, 18, 1, "prediction_layer/box_predictor_3/class_predictor");
    var box_encoding_4_predictor = extractConvParams(256, 24, 1, "prediction_layer/box_predictor_4/box_encoding_predictor");
    var class_predictor_4 = extractConvParams(256, 18, 1, "prediction_layer/box_predictor_4/class_predictor");
    var box_encoding_5_predictor = extractConvParams(128, 24, 1, "prediction_layer/box_predictor_5/box_encoding_predictor");
    var class_predictor_5 = extractConvParams(128, 18, 1, "prediction_layer/box_predictor_5/class_predictor");
    var box_predictor_0 = {
      box_encoding_predictor: box_encoding_0_predictor,
      class_predictor: class_predictor_0
    };
    var box_predictor_1 = {
      box_encoding_predictor: box_encoding_1_predictor,
      class_predictor: class_predictor_1
    };
    var box_predictor_2 = {
      box_encoding_predictor: box_encoding_2_predictor,
      class_predictor: class_predictor_2
    };
    var box_predictor_3 = {
      box_encoding_predictor: box_encoding_3_predictor,
      class_predictor: class_predictor_3
    };
    var box_predictor_4 = {
      box_encoding_predictor: box_encoding_4_predictor,
      class_predictor: class_predictor_4
    };
    var box_predictor_5 = {
      box_encoding_predictor: box_encoding_5_predictor,
      class_predictor: class_predictor_5
    };
    return {
      conv_0,
      conv_1,
      conv_2,
      conv_3,
      conv_4,
      conv_5,
      conv_6,
      conv_7,
      box_predictor_0,
      box_predictor_1,
      box_predictor_2,
      box_predictor_3,
      box_predictor_4,
      box_predictor_5
    };
  }
  return {
    extractMobilenetV1Params,
    extractPredictionLayerParams
  };
}
function extractParams6(weights) {
  var paramMappings = [];
  var _a2 = extractWeightsFactory(weights), extractWeights = _a2.extractWeights, getRemainingWeights = _a2.getRemainingWeights;
  var _b = extractorsFactory5(extractWeights, paramMappings), extractMobilenetV1Params = _b.extractMobilenetV1Params, extractPredictionLayerParams = _b.extractPredictionLayerParams;
  var mobilenetv1 = extractMobilenetV1Params();
  var prediction_layer = extractPredictionLayerParams();
  var extra_dim = Pn(extractWeights(5118 * 4), [1, 5118, 4]);
  var output_layer = {
    extra_dim
  };
  paramMappings.push({ paramPath: "output_layer/extra_dim" });
  if (getRemainingWeights().length !== 0) {
    throw new Error("weights remaing after extract: " + getRemainingWeights().length);
  }
  return {
    params: {
      mobilenetv1,
      prediction_layer,
      output_layer
    },
    paramMappings
  };
}
var init_extractParams6 = __esm({
  "node_modules/face-api.js/build/es6/ssdMobilenetv1/extractParams.js"() {
    "use strict";
    init_tf_core_esm();
    init_common2();
  }
});

// node_modules/face-api.js/build/es6/ssdMobilenetv1/extractParamsFromWeigthMap.js
function extractorsFactory6(weightMap, paramMappings) {
  var extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);
  function extractPointwiseConvParams(prefix, idx, mappedPrefix) {
    var filters = extractWeightEntry(prefix + "/Conv2d_" + idx + "_pointwise/weights", 4, mappedPrefix + "/filters");
    var batch_norm_offset = extractWeightEntry(prefix + "/Conv2d_" + idx + "_pointwise/convolution_bn_offset", 1, mappedPrefix + "/batch_norm_offset");
    return { filters, batch_norm_offset };
  }
  function extractConvPairParams(idx) {
    var mappedPrefix = "mobilenetv1/conv_" + idx;
    var prefixDepthwiseConv = "MobilenetV1/Conv2d_" + idx + "_depthwise";
    var mappedPrefixDepthwiseConv = mappedPrefix + "/depthwise_conv";
    var mappedPrefixPointwiseConv = mappedPrefix + "/pointwise_conv";
    var filters = extractWeightEntry(prefixDepthwiseConv + "/depthwise_weights", 4, mappedPrefixDepthwiseConv + "/filters");
    var batch_norm_scale = extractWeightEntry(prefixDepthwiseConv + "/BatchNorm/gamma", 1, mappedPrefixDepthwiseConv + "/batch_norm_scale");
    var batch_norm_offset = extractWeightEntry(prefixDepthwiseConv + "/BatchNorm/beta", 1, mappedPrefixDepthwiseConv + "/batch_norm_offset");
    var batch_norm_mean = extractWeightEntry(prefixDepthwiseConv + "/BatchNorm/moving_mean", 1, mappedPrefixDepthwiseConv + "/batch_norm_mean");
    var batch_norm_variance = extractWeightEntry(prefixDepthwiseConv + "/BatchNorm/moving_variance", 1, mappedPrefixDepthwiseConv + "/batch_norm_variance");
    return {
      depthwise_conv: {
        filters,
        batch_norm_scale,
        batch_norm_offset,
        batch_norm_mean,
        batch_norm_variance
      },
      pointwise_conv: extractPointwiseConvParams("MobilenetV1", idx, mappedPrefixPointwiseConv)
    };
  }
  function extractMobilenetV1Params() {
    return {
      conv_0: extractPointwiseConvParams("MobilenetV1", 0, "mobilenetv1/conv_0"),
      conv_1: extractConvPairParams(1),
      conv_2: extractConvPairParams(2),
      conv_3: extractConvPairParams(3),
      conv_4: extractConvPairParams(4),
      conv_5: extractConvPairParams(5),
      conv_6: extractConvPairParams(6),
      conv_7: extractConvPairParams(7),
      conv_8: extractConvPairParams(8),
      conv_9: extractConvPairParams(9),
      conv_10: extractConvPairParams(10),
      conv_11: extractConvPairParams(11),
      conv_12: extractConvPairParams(12),
      conv_13: extractConvPairParams(13)
    };
  }
  function extractConvParams(prefix, mappedPrefix) {
    var filters = extractWeightEntry(prefix + "/weights", 4, mappedPrefix + "/filters");
    var bias = extractWeightEntry(prefix + "/biases", 1, mappedPrefix + "/bias");
    return { filters, bias };
  }
  function extractBoxPredictorParams(idx) {
    var box_encoding_predictor = extractConvParams("Prediction/BoxPredictor_" + idx + "/BoxEncodingPredictor", "prediction_layer/box_predictor_" + idx + "/box_encoding_predictor");
    var class_predictor = extractConvParams("Prediction/BoxPredictor_" + idx + "/ClassPredictor", "prediction_layer/box_predictor_" + idx + "/class_predictor");
    return { box_encoding_predictor, class_predictor };
  }
  function extractPredictionLayerParams() {
    return {
      conv_0: extractPointwiseConvParams("Prediction", 0, "prediction_layer/conv_0"),
      conv_1: extractPointwiseConvParams("Prediction", 1, "prediction_layer/conv_1"),
      conv_2: extractPointwiseConvParams("Prediction", 2, "prediction_layer/conv_2"),
      conv_3: extractPointwiseConvParams("Prediction", 3, "prediction_layer/conv_3"),
      conv_4: extractPointwiseConvParams("Prediction", 4, "prediction_layer/conv_4"),
      conv_5: extractPointwiseConvParams("Prediction", 5, "prediction_layer/conv_5"),
      conv_6: extractPointwiseConvParams("Prediction", 6, "prediction_layer/conv_6"),
      conv_7: extractPointwiseConvParams("Prediction", 7, "prediction_layer/conv_7"),
      box_predictor_0: extractBoxPredictorParams(0),
      box_predictor_1: extractBoxPredictorParams(1),
      box_predictor_2: extractBoxPredictorParams(2),
      box_predictor_3: extractBoxPredictorParams(3),
      box_predictor_4: extractBoxPredictorParams(4),
      box_predictor_5: extractBoxPredictorParams(5)
    };
  }
  return {
    extractMobilenetV1Params,
    extractPredictionLayerParams
  };
}
function extractParamsFromWeigthMap6(weightMap) {
  var paramMappings = [];
  var _a2 = extractorsFactory6(weightMap, paramMappings), extractMobilenetV1Params = _a2.extractMobilenetV1Params, extractPredictionLayerParams = _a2.extractPredictionLayerParams;
  var extra_dim = weightMap["Output/extra_dim"];
  paramMappings.push({ originalPath: "Output/extra_dim", paramPath: "output_layer/extra_dim" });
  if (!isTensor3D(extra_dim)) {
    throw new Error("expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have " + extra_dim);
  }
  var params = {
    mobilenetv1: extractMobilenetV1Params(),
    prediction_layer: extractPredictionLayerParams(),
    output_layer: {
      extra_dim
    }
  };
  disposeUnusedWeightTensors(weightMap, paramMappings);
  return { params, paramMappings };
}
var init_extractParamsFromWeigthMap6 = __esm({
  "node_modules/face-api.js/build/es6/ssdMobilenetv1/extractParamsFromWeigthMap.js"() {
    "use strict";
    init_common2();
    init_utils();
  }
});

// node_modules/face-api.js/build/es6/ssdMobilenetv1/pointwiseConvLayer.js
function pointwiseConvLayer(x2, params, strides) {
  return Ze(function() {
    var out = qc(x2, params.filters, strides, "same");
    out = rc(out, params.batch_norm_offset);
    return hu(out, 0, 6);
  });
}
var init_pointwiseConvLayer = __esm({
  "node_modules/face-api.js/build/es6/ssdMobilenetv1/pointwiseConvLayer.js"() {
    "use strict";
    init_tf_core_esm();
  }
});

// node_modules/face-api.js/build/es6/ssdMobilenetv1/mobileNetV1.js
function depthwiseConvLayer(x2, params, strides) {
  return Ze(function() {
    var out = Yc(x2, params.filters, strides, "same");
    out = ju(out, params.batch_norm_mean, params.batch_norm_variance, params.batch_norm_offset, params.batch_norm_scale, epsilon);
    return hu(out, 0, 6);
  });
}
function getStridesForLayerIdx(layerIdx) {
  return [2, 4, 6, 12].some(function(idx) {
    return idx === layerIdx;
  }) ? [2, 2] : [1, 1];
}
function mobileNetV1(x2, params) {
  return Ze(function() {
    var conv11 = null;
    var out = pointwiseConvLayer(x2, params.conv_0, [2, 2]);
    var convPairParams = [
      params.conv_1,
      params.conv_2,
      params.conv_3,
      params.conv_4,
      params.conv_5,
      params.conv_6,
      params.conv_7,
      params.conv_8,
      params.conv_9,
      params.conv_10,
      params.conv_11,
      params.conv_12,
      params.conv_13
    ];
    convPairParams.forEach(function(param, i2) {
      var layerIdx = i2 + 1;
      var depthwiseConvStrides = getStridesForLayerIdx(layerIdx);
      out = depthwiseConvLayer(out, param.depthwise_conv, depthwiseConvStrides);
      out = pointwiseConvLayer(out, param.pointwise_conv, [1, 1]);
      if (layerIdx === 11) {
        conv11 = out;
      }
    });
    if (conv11 === null) {
      throw new Error("mobileNetV1 - output of conv layer 11 is null");
    }
    return {
      out,
      conv11
    };
  });
}
var epsilon;
var init_mobileNetV1 = __esm({
  "node_modules/face-api.js/build/es6/ssdMobilenetv1/mobileNetV1.js"() {
    "use strict";
    init_tf_core_esm();
    init_pointwiseConvLayer();
    epsilon = 0.0010000000474974513;
  }
});

// node_modules/face-api.js/build/es6/ssdMobilenetv1/nonMaxSuppression.js
function nonMaxSuppression2(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
  var numBoxes = boxes.shape[0];
  var outputSize = Math.min(maxOutputSize, numBoxes);
  var candidates = scores.map(function(score, boxIndex) {
    return { score, boxIndex };
  }).filter(function(c2) {
    return c2.score > scoreThreshold;
  }).sort(function(c1, c2) {
    return c2.score - c1.score;
  });
  var suppressFunc = function(x2) {
    return x2 <= iouThreshold ? 1 : 0;
  };
  var selected = [];
  candidates.forEach(function(c2) {
    if (selected.length >= outputSize) {
      return;
    }
    var originalScore = c2.score;
    for (var j2 = selected.length - 1; j2 >= 0; --j2) {
      var iou2 = IOU(boxes, c2.boxIndex, selected[j2]);
      if (iou2 === 0) {
        continue;
      }
      c2.score *= suppressFunc(iou2);
      if (c2.score <= scoreThreshold) {
        break;
      }
    }
    if (originalScore === c2.score) {
      selected.push(c2.boxIndex);
    }
  });
  return selected;
}
function IOU(boxes, i2, j2) {
  var boxesData = boxes.arraySync();
  var yminI = Math.min(boxesData[i2][0], boxesData[i2][2]);
  var xminI = Math.min(boxesData[i2][1], boxesData[i2][3]);
  var ymaxI = Math.max(boxesData[i2][0], boxesData[i2][2]);
  var xmaxI = Math.max(boxesData[i2][1], boxesData[i2][3]);
  var yminJ = Math.min(boxesData[j2][0], boxesData[j2][2]);
  var xminJ = Math.min(boxesData[j2][1], boxesData[j2][3]);
  var ymaxJ = Math.max(boxesData[j2][0], boxesData[j2][2]);
  var xmaxJ = Math.max(boxesData[j2][1], boxesData[j2][3]);
  var areaI = (ymaxI - yminI) * (xmaxI - xminI);
  var areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);
  if (areaI <= 0 || areaJ <= 0) {
    return 0;
  }
  var intersectionYmin = Math.max(yminI, yminJ);
  var intersectionXmin = Math.max(xminI, xminJ);
  var intersectionYmax = Math.min(ymaxI, ymaxJ);
  var intersectionXmax = Math.min(xmaxI, xmaxJ);
  var intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0) * Math.max(intersectionXmax - intersectionXmin, 0);
  return intersectionArea / (areaI + areaJ - intersectionArea);
}
var init_nonMaxSuppression2 = __esm({
  "node_modules/face-api.js/build/es6/ssdMobilenetv1/nonMaxSuppression.js"() {
    "use strict";
  }
});

// node_modules/face-api.js/build/es6/ssdMobilenetv1/outputLayer.js
function getCenterCoordinatesAndSizesLayer(x2) {
  var vec = Ur(Wl(x2, [1, 0]));
  var sizes = [
    Cc(vec[2], vec[0]),
    Cc(vec[3], vec[1])
  ];
  var centers = [
    rc(vec[0], sc(sizes[0], On(2))),
    rc(vec[1], sc(sizes[1], On(2)))
  ];
  return {
    sizes,
    centers
  };
}
function decodeBoxesLayer(x0, x1) {
  var _a2 = getCenterCoordinatesAndSizesLayer(x0), sizes = _a2.sizes, centers = _a2.centers;
  var vec = Ur(Wl(x1, [1, 0]));
  var div0_out = sc(gc(vu(sc(vec[2], On(5))), sizes[0]), On(2));
  var add0_out = rc(gc(sc(vec[0], On(10)), sizes[0]), centers[0]);
  var div1_out = sc(gc(vu(sc(vec[3], On(5))), sizes[1]), On(2));
  var add1_out = rc(gc(sc(vec[1], On(10)), sizes[1]), centers[1]);
  return Wl(Pr([
    Cc(add0_out, div0_out),
    Cc(add1_out, div1_out),
    rc(add0_out, div0_out),
    rc(add1_out, div1_out)
  ]), [1, 0]);
}
function outputLayer(boxPredictions, classPredictions, params) {
  return Ze(function() {
    var batchSize = boxPredictions.shape[0];
    var boxes = decodeBoxesLayer(Or(Lr(params.extra_dim, [batchSize, 1, 1]), [-1, 4]), Or(boxPredictions, [-1, 4]));
    boxes = Or(boxes, [batchSize, boxes.shape[0] / batchSize, 4]);
    var scoresAndClasses = Iu(ml(classPredictions, [0, 0, 1], [-1, -1, -1]));
    var scores = ml(scoresAndClasses, [0, 0, 0], [-1, -1, 1]);
    scores = Or(scores, [batchSize, scores.shape[1]]);
    var boxesByBatch = Ur(boxes);
    var scoresByBatch = Ur(scores);
    return {
      boxes: boxesByBatch,
      scores: scoresByBatch
    };
  });
}
var init_outputLayer = __esm({
  "node_modules/face-api.js/build/es6/ssdMobilenetv1/outputLayer.js"() {
    "use strict";
    init_tf_core_esm();
  }
});

// node_modules/face-api.js/build/es6/ssdMobilenetv1/boxPredictionLayer.js
function boxPredictionLayer(x2, params) {
  return Ze(function() {
    var batchSize = x2.shape[0];
    var boxPredictionEncoding = Or(convLayer(x2, params.box_encoding_predictor), [batchSize, -1, 1, 4]);
    var classPrediction = Or(convLayer(x2, params.class_predictor), [batchSize, -1, 3]);
    return {
      boxPredictionEncoding,
      classPrediction
    };
  });
}
var init_boxPredictionLayer = __esm({
  "node_modules/face-api.js/build/es6/ssdMobilenetv1/boxPredictionLayer.js"() {
    "use strict";
    init_tf_core_esm();
    init_common2();
  }
});

// node_modules/face-api.js/build/es6/ssdMobilenetv1/predictionLayer.js
function predictionLayer(x2, conv11, params) {
  return Ze(function() {
    var conv0 = pointwiseConvLayer(x2, params.conv_0, [1, 1]);
    var conv1 = pointwiseConvLayer(conv0, params.conv_1, [2, 2]);
    var conv22 = pointwiseConvLayer(conv1, params.conv_2, [1, 1]);
    var conv3 = pointwiseConvLayer(conv22, params.conv_3, [2, 2]);
    var conv4 = pointwiseConvLayer(conv3, params.conv_4, [1, 1]);
    var conv5 = pointwiseConvLayer(conv4, params.conv_5, [2, 2]);
    var conv6 = pointwiseConvLayer(conv5, params.conv_6, [1, 1]);
    var conv7 = pointwiseConvLayer(conv6, params.conv_7, [2, 2]);
    var boxPrediction0 = boxPredictionLayer(conv11, params.box_predictor_0);
    var boxPrediction1 = boxPredictionLayer(x2, params.box_predictor_1);
    var boxPrediction2 = boxPredictionLayer(conv1, params.box_predictor_2);
    var boxPrediction3 = boxPredictionLayer(conv3, params.box_predictor_3);
    var boxPrediction4 = boxPredictionLayer(conv5, params.box_predictor_4);
    var boxPrediction5 = boxPredictionLayer(conv7, params.box_predictor_5);
    var boxPredictions = Yn([
      boxPrediction0.boxPredictionEncoding,
      boxPrediction1.boxPredictionEncoding,
      boxPrediction2.boxPredictionEncoding,
      boxPrediction3.boxPredictionEncoding,
      boxPrediction4.boxPredictionEncoding,
      boxPrediction5.boxPredictionEncoding
    ], 1);
    var classPredictions = Yn([
      boxPrediction0.classPrediction,
      boxPrediction1.classPrediction,
      boxPrediction2.classPrediction,
      boxPrediction3.classPrediction,
      boxPrediction4.classPrediction,
      boxPrediction5.classPrediction
    ], 1);
    return {
      boxPredictions,
      classPredictions
    };
  });
}
var init_predictionLayer = __esm({
  "node_modules/face-api.js/build/es6/ssdMobilenetv1/predictionLayer.js"() {
    "use strict";
    init_tf_core_esm();
    init_boxPredictionLayer();
    init_pointwiseConvLayer();
  }
});

// node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1Options.js
var SsdMobilenetv1Options;
var init_SsdMobilenetv1Options = __esm({
  "node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1Options.js"() {
    "use strict";
    SsdMobilenetv1Options = /** @class */
    function() {
      function SsdMobilenetv1Options2(_a2) {
        var _b = _a2 === void 0 ? {} : _a2, minConfidence = _b.minConfidence, maxResults = _b.maxResults;
        this._name = "SsdMobilenetv1Options";
        this._minConfidence = minConfidence || 0.5;
        this._maxResults = maxResults || 100;
        if (typeof this._minConfidence !== "number" || this._minConfidence <= 0 || this._minConfidence >= 1) {
          throw new Error(this._name + " - expected minConfidence to be a number between 0 and 1");
        }
        if (typeof this._maxResults !== "number") {
          throw new Error(this._name + " - expected maxResults to be a number");
        }
      }
      Object.defineProperty(SsdMobilenetv1Options2.prototype, "minConfidence", {
        get: function() {
          return this._minConfidence;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(SsdMobilenetv1Options2.prototype, "maxResults", {
        get: function() {
          return this._maxResults;
        },
        enumerable: true,
        configurable: true
      });
      return SsdMobilenetv1Options2;
    }();
  }
});

// node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1.js
var SsdMobilenetv1;
var init_SsdMobilenetv1 = __esm({
  "node_modules/face-api.js/build/es6/ssdMobilenetv1/SsdMobilenetv1.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_classes();
    init_FaceDetection();
    init_dom();
    init_NeuralNetwork();
    init_extractParams6();
    init_extractParamsFromWeigthMap6();
    init_mobileNetV1();
    init_nonMaxSuppression2();
    init_outputLayer();
    init_predictionLayer();
    init_SsdMobilenetv1Options();
    SsdMobilenetv1 = /** @class */
    function(_super) {
      __extends(SsdMobilenetv12, _super);
      function SsdMobilenetv12() {
        return _super.call(this, "SsdMobilenetv1") || this;
      }
      SsdMobilenetv12.prototype.forwardInput = function(input2) {
        var params = this.params;
        if (!params) {
          throw new Error("SsdMobilenetv1 - load model before inference");
        }
        return Ze(function() {
          var batchTensor = input2.toBatchTensor(512, false).toFloat();
          var x2 = Cc(gc(batchTensor, On(0.007843137718737125)), On(1));
          var features = mobileNetV1(x2, params.mobilenetv1);
          var _a2 = predictionLayer(features.out, features.conv11, params.prediction_layer), boxPredictions = _a2.boxPredictions, classPredictions = _a2.classPredictions;
          return outputLayer(boxPredictions, classPredictions, params.output_layer);
        });
      };
      SsdMobilenetv12.prototype.forward = function(input2) {
        return __awaiter2(this, void 0, void 0, function() {
          var _a2;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _a2 = this.forwardInput;
                return [4, toNetInput(input2)];
              case 1:
                return [2, _a2.apply(this, [_b.sent()])];
            }
          });
        });
      };
      SsdMobilenetv12.prototype.locateFaces = function(input2, options) {
        if (options === void 0) {
          options = {};
        }
        return __awaiter2(this, void 0, void 0, function() {
          var _a2, maxResults, minConfidence, netInput, _b, _boxes, _scores, boxes, scores, i2, scoresData, _c6, _d, iouThreshold, indices, reshapedDims, inputSize, padX, padY, boxesData, results;
          return __generator(this, function(_e2) {
            switch (_e2.label) {
              case 0:
                _a2 = new SsdMobilenetv1Options(options), maxResults = _a2.maxResults, minConfidence = _a2.minConfidence;
                return [4, toNetInput(input2)];
              case 1:
                netInput = _e2.sent();
                _b = this.forwardInput(netInput), _boxes = _b.boxes, _scores = _b.scores;
                boxes = _boxes[0];
                scores = _scores[0];
                for (i2 = 1; i2 < _boxes.length; i2++) {
                  _boxes[i2].dispose();
                  _scores[i2].dispose();
                }
                _d = (_c6 = Array).from;
                return [4, scores.data()];
              case 2:
                scoresData = _d.apply(_c6, [_e2.sent()]);
                iouThreshold = 0.5;
                indices = nonMaxSuppression2(boxes, scoresData, maxResults, iouThreshold, minConfidence);
                reshapedDims = netInput.getReshapedInputDimensions(0);
                inputSize = netInput.inputSize;
                padX = inputSize / reshapedDims.width;
                padY = inputSize / reshapedDims.height;
                boxesData = boxes.arraySync();
                results = indices.map(function(idx) {
                  var _a3 = [
                    Math.max(0, boxesData[idx][0]),
                    Math.min(1, boxesData[idx][2])
                  ].map(function(val) {
                    return val * padY;
                  }), top = _a3[0], bottom = _a3[1];
                  var _b2 = [
                    Math.max(0, boxesData[idx][1]),
                    Math.min(1, boxesData[idx][3])
                  ].map(function(val) {
                    return val * padX;
                  }), left = _b2[0], right = _b2[1];
                  return new FaceDetection(scoresData[idx], new Rect(left, top, right - left, bottom - top), {
                    height: netInput.getInputHeight(0),
                    width: netInput.getInputWidth(0)
                  });
                });
                boxes.dispose();
                scores.dispose();
                return [2, results];
            }
          });
        });
      };
      SsdMobilenetv12.prototype.getDefaultModelName = function() {
        return "ssd_mobilenetv1_model";
      };
      SsdMobilenetv12.prototype.extractParamsFromWeigthMap = function(weightMap) {
        return extractParamsFromWeigthMap6(weightMap);
      };
      SsdMobilenetv12.prototype.extractParams = function(weights) {
        return extractParams6(weights);
      };
      return SsdMobilenetv12;
    }(NeuralNetwork);
  }
});

// node_modules/face-api.js/build/es6/ssdMobilenetv1/index.js
var FaceDetectionNet;
var init_ssdMobilenetv1 = __esm({
  "node_modules/face-api.js/build/es6/ssdMobilenetv1/index.js"() {
    "use strict";
    init_tslib_es62();
    init_SsdMobilenetv1();
    init_SsdMobilenetv1();
    init_SsdMobilenetv1Options();
    FaceDetectionNet = /** @class */
    function(_super) {
      __extends(FaceDetectionNet2, _super);
      function FaceDetectionNet2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return FaceDetectionNet2;
    }(SsdMobilenetv1);
  }
});

// node_modules/face-api.js/build/es6/tinyYolov2/const.js
var IOU_THRESHOLD, BOX_ANCHORS, BOX_ANCHORS_SEPARABLE, MEAN_RGB_SEPARABLE, DEFAULT_MODEL_NAME, DEFAULT_MODEL_NAME_SEPARABLE_CONV;
var init_const = __esm({
  "node_modules/face-api.js/build/es6/tinyYolov2/const.js"() {
    "use strict";
    init_classes();
    IOU_THRESHOLD = 0.4;
    BOX_ANCHORS = [
      new Point(0.738768, 0.874946),
      new Point(2.42204, 2.65704),
      new Point(4.30971, 7.04493),
      new Point(10.246, 4.59428),
      new Point(12.6868, 11.8741)
    ];
    BOX_ANCHORS_SEPARABLE = [
      new Point(1.603231, 2.094468),
      new Point(6.041143, 7.080126),
      new Point(2.882459, 3.518061),
      new Point(4.266906, 5.178857),
      new Point(9.041765, 10.66308)
    ];
    MEAN_RGB_SEPARABLE = [117.001, 114.697, 97.404];
    DEFAULT_MODEL_NAME = "tiny_yolov2_model";
    DEFAULT_MODEL_NAME_SEPARABLE_CONV = "tiny_yolov2_separable_conv_model";
  }
});

// node_modules/face-api.js/build/es6/tinyYolov2/config.js
function validateConfig2(config2) {
  if (!config2) {
    throw new Error("invalid config: " + config2);
  }
  if (typeof config2.withSeparableConvs !== "boolean") {
    throw new Error("config.withSeparableConvs has to be a boolean, have: " + config2.withSeparableConvs);
  }
  if (!isNumber(config2.iouThreshold) || config2.iouThreshold < 0 || config2.iouThreshold > 1) {
    throw new Error("config.iouThreshold has to be a number between [0, 1], have: " + config2.iouThreshold);
  }
  if (!Array.isArray(config2.classes) || !config2.classes.length || !config2.classes.every(function(c2) {
    return typeof c2 === "string";
  })) {
    throw new Error("config.classes has to be an array class names: string[], have: " + JSON.stringify(config2.classes));
  }
  if (!Array.isArray(config2.anchors) || !config2.anchors.length || !config2.anchors.map(function(a2) {
    return a2 || {};
  }).every(function(a2) {
    return isNumber(a2.x) && isNumber(a2.y);
  })) {
    throw new Error("config.anchors has to be an array of { x: number, y: number }, have: " + JSON.stringify(config2.anchors));
  }
  if (config2.meanRgb && (!Array.isArray(config2.meanRgb) || config2.meanRgb.length !== 3 || !config2.meanRgb.every(isNumber))) {
    throw new Error("config.meanRgb has to be an array of shape [number, number, number], have: " + JSON.stringify(config2.meanRgb));
  }
}
var isNumber;
var init_config2 = __esm({
  "node_modules/face-api.js/build/es6/tinyYolov2/config.js"() {
    "use strict";
    isNumber = function(arg) {
      return typeof arg === "number";
    };
  }
});

// node_modules/face-api.js/build/es6/tinyYolov2/leaky.js
function leaky(x2) {
  return Ze(function() {
    var min = gc(x2, On(0.10000000149011612));
    return rc(Bl(Cc(x2, min)), min);
  });
}
var init_leaky = __esm({
  "node_modules/face-api.js/build/es6/tinyYolov2/leaky.js"() {
    "use strict";
    init_tf_core_esm();
  }
});

// node_modules/face-api.js/build/es6/tinyYolov2/convWithBatchNorm.js
function convWithBatchNorm(x2, params) {
  return Ze(function() {
    var out = Ir(x2, [[0, 0], [1, 1], [1, 1], [0, 0]]);
    out = qc(out, params.conv.filters, [1, 1], "valid");
    out = Cc(out, params.bn.sub);
    out = gc(out, params.bn.truediv);
    out = rc(out, params.conv.bias);
    return leaky(out);
  });
}
var init_convWithBatchNorm = __esm({
  "node_modules/face-api.js/build/es6/tinyYolov2/convWithBatchNorm.js"() {
    "use strict";
    init_tf_core_esm();
    init_leaky();
  }
});

// node_modules/face-api.js/build/es6/tinyYolov2/depthwiseSeparableConv.js
function depthwiseSeparableConv2(x2, params) {
  return Ze(function() {
    var out = Ir(x2, [[0, 0], [1, 1], [1, 1], [0, 0]]);
    out = Jc(out, params.depthwise_filter, params.pointwise_filter, [1, 1], "valid");
    out = rc(out, params.bias);
    return leaky(out);
  });
}
var init_depthwiseSeparableConv2 = __esm({
  "node_modules/face-api.js/build/es6/tinyYolov2/depthwiseSeparableConv.js"() {
    "use strict";
    init_tf_core_esm();
    init_leaky();
  }
});

// node_modules/face-api.js/build/es6/tinyYolov2/extractParams.js
function extractorsFactory7(extractWeights, paramMappings) {
  var extractConvParams = extractConvParamsFactory(extractWeights, paramMappings);
  function extractBatchNormParams(size, mappedPrefix) {
    var sub = Mn(extractWeights(size));
    var truediv = Mn(extractWeights(size));
    paramMappings.push({ paramPath: mappedPrefix + "/sub" }, { paramPath: mappedPrefix + "/truediv" });
    return { sub, truediv };
  }
  function extractConvWithBatchNormParams(channelsIn, channelsOut, mappedPrefix) {
    var conv3 = extractConvParams(channelsIn, channelsOut, 3, mappedPrefix + "/conv");
    var bn2 = extractBatchNormParams(channelsOut, mappedPrefix + "/bn");
    return { conv: conv3, bn: bn2 };
  }
  var extractSeparableConvParams = extractSeparableConvParamsFactory(extractWeights, paramMappings);
  return {
    extractConvParams,
    extractConvWithBatchNormParams,
    extractSeparableConvParams
  };
}
function extractParams7(weights, config2, boxEncodingSize, filterSizes) {
  var _a2 = extractWeightsFactory(weights), extractWeights = _a2.extractWeights, getRemainingWeights = _a2.getRemainingWeights;
  var paramMappings = [];
  var _b = extractorsFactory7(extractWeights, paramMappings), extractConvParams = _b.extractConvParams, extractConvWithBatchNormParams = _b.extractConvWithBatchNormParams, extractSeparableConvParams = _b.extractSeparableConvParams;
  var params;
  if (config2.withSeparableConvs) {
    var s0 = filterSizes[0], s1 = filterSizes[1], s2 = filterSizes[2], s3 = filterSizes[3], s4 = filterSizes[4], s5 = filterSizes[5], s6 = filterSizes[6], s7 = filterSizes[7], s8 = filterSizes[8];
    var conv0 = config2.isFirstLayerConv2d ? extractConvParams(s0, s1, 3, "conv0") : extractSeparableConvParams(s0, s1, "conv0");
    var conv1 = extractSeparableConvParams(s1, s2, "conv1");
    var conv22 = extractSeparableConvParams(s2, s3, "conv2");
    var conv3 = extractSeparableConvParams(s3, s4, "conv3");
    var conv4 = extractSeparableConvParams(s4, s5, "conv4");
    var conv5 = extractSeparableConvParams(s5, s6, "conv5");
    var conv6 = s7 ? extractSeparableConvParams(s6, s7, "conv6") : void 0;
    var conv7 = s8 ? extractSeparableConvParams(s7, s8, "conv7") : void 0;
    var conv8 = extractConvParams(s8 || s7 || s6, 5 * boxEncodingSize, 1, "conv8");
    params = { conv0, conv1, conv2: conv22, conv3, conv4, conv5, conv6, conv7, conv8 };
  } else {
    var s0 = filterSizes[0], s1 = filterSizes[1], s2 = filterSizes[2], s3 = filterSizes[3], s4 = filterSizes[4], s5 = filterSizes[5], s6 = filterSizes[6], s7 = filterSizes[7], s8 = filterSizes[8];
    var conv0 = extractConvWithBatchNormParams(s0, s1, "conv0");
    var conv1 = extractConvWithBatchNormParams(s1, s2, "conv1");
    var conv22 = extractConvWithBatchNormParams(s2, s3, "conv2");
    var conv3 = extractConvWithBatchNormParams(s3, s4, "conv3");
    var conv4 = extractConvWithBatchNormParams(s4, s5, "conv4");
    var conv5 = extractConvWithBatchNormParams(s5, s6, "conv5");
    var conv6 = extractConvWithBatchNormParams(s6, s7, "conv6");
    var conv7 = extractConvWithBatchNormParams(s7, s8, "conv7");
    var conv8 = extractConvParams(s8, 5 * boxEncodingSize, 1, "conv8");
    params = { conv0, conv1, conv2: conv22, conv3, conv4, conv5, conv6, conv7, conv8 };
  }
  if (getRemainingWeights().length !== 0) {
    throw new Error("weights remaing after extract: " + getRemainingWeights().length);
  }
  return { params, paramMappings };
}
var init_extractParams7 = __esm({
  "node_modules/face-api.js/build/es6/tinyYolov2/extractParams.js"() {
    "use strict";
    init_tf_core_esm();
    init_common2();
    init_extractSeparableConvParamsFactory();
    init_extractWeightsFactory();
  }
});

// node_modules/face-api.js/build/es6/tinyYolov2/extractParamsFromWeigthMap.js
function extractorsFactory8(weightMap, paramMappings) {
  var extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);
  function extractBatchNormParams(prefix) {
    var sub = extractWeightEntry(prefix + "/sub", 1);
    var truediv = extractWeightEntry(prefix + "/truediv", 1);
    return { sub, truediv };
  }
  function extractConvParams(prefix) {
    var filters = extractWeightEntry(prefix + "/filters", 4);
    var bias = extractWeightEntry(prefix + "/bias", 1);
    return { filters, bias };
  }
  function extractConvWithBatchNormParams(prefix) {
    var conv3 = extractConvParams(prefix + "/conv");
    var bn2 = extractBatchNormParams(prefix + "/bn");
    return { conv: conv3, bn: bn2 };
  }
  var extractSeparableConvParams = loadSeparableConvParamsFactory(extractWeightEntry);
  return {
    extractConvParams,
    extractConvWithBatchNormParams,
    extractSeparableConvParams
  };
}
function extractParamsFromWeigthMap7(weightMap, config2) {
  var paramMappings = [];
  var _a2 = extractorsFactory8(weightMap, paramMappings), extractConvParams = _a2.extractConvParams, extractConvWithBatchNormParams = _a2.extractConvWithBatchNormParams, extractSeparableConvParams = _a2.extractSeparableConvParams;
  var params;
  if (config2.withSeparableConvs) {
    var numFilters = config2.filterSizes && config2.filterSizes.length || 9;
    params = {
      conv0: config2.isFirstLayerConv2d ? extractConvParams("conv0") : extractSeparableConvParams("conv0"),
      conv1: extractSeparableConvParams("conv1"),
      conv2: extractSeparableConvParams("conv2"),
      conv3: extractSeparableConvParams("conv3"),
      conv4: extractSeparableConvParams("conv4"),
      conv5: extractSeparableConvParams("conv5"),
      conv6: numFilters > 7 ? extractSeparableConvParams("conv6") : void 0,
      conv7: numFilters > 8 ? extractSeparableConvParams("conv7") : void 0,
      conv8: extractConvParams("conv8")
    };
  } else {
    params = {
      conv0: extractConvWithBatchNormParams("conv0"),
      conv1: extractConvWithBatchNormParams("conv1"),
      conv2: extractConvWithBatchNormParams("conv2"),
      conv3: extractConvWithBatchNormParams("conv3"),
      conv4: extractConvWithBatchNormParams("conv4"),
      conv5: extractConvWithBatchNormParams("conv5"),
      conv6: extractConvWithBatchNormParams("conv6"),
      conv7: extractConvWithBatchNormParams("conv7"),
      conv8: extractConvParams("conv8")
    };
  }
  disposeUnusedWeightTensors(weightMap, paramMappings);
  return { params, paramMappings };
}
var init_extractParamsFromWeigthMap7 = __esm({
  "node_modules/face-api.js/build/es6/tinyYolov2/extractParamsFromWeigthMap.js"() {
    "use strict";
    init_disposeUnusedWeightTensors();
    init_extractSeparableConvParamsFactory();
    init_extractWeightEntryFactory();
  }
});

// node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Options.js
var TinyYolov2SizeType, TinyYolov2Options;
var init_TinyYolov2Options = __esm({
  "node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Options.js"() {
    "use strict";
    (function(TinyYolov2SizeType2) {
      TinyYolov2SizeType2[TinyYolov2SizeType2["XS"] = 224] = "XS";
      TinyYolov2SizeType2[TinyYolov2SizeType2["SM"] = 320] = "SM";
      TinyYolov2SizeType2[TinyYolov2SizeType2["MD"] = 416] = "MD";
      TinyYolov2SizeType2[TinyYolov2SizeType2["LG"] = 608] = "LG";
    })(TinyYolov2SizeType || (TinyYolov2SizeType = {}));
    TinyYolov2Options = /** @class */
    function() {
      function TinyYolov2Options2(_a2) {
        var _b = _a2 === void 0 ? {} : _a2, inputSize = _b.inputSize, scoreThreshold = _b.scoreThreshold;
        this._name = "TinyYolov2Options";
        this._inputSize = inputSize || 416;
        this._scoreThreshold = scoreThreshold || 0.5;
        if (typeof this._inputSize !== "number" || this._inputSize % 32 !== 0) {
          throw new Error(this._name + " - expected inputSize to be a number divisible by 32");
        }
        if (typeof this._scoreThreshold !== "number" || this._scoreThreshold <= 0 || this._scoreThreshold >= 1) {
          throw new Error(this._name + " - expected scoreThreshold to be a number between 0 and 1");
        }
      }
      Object.defineProperty(TinyYolov2Options2.prototype, "inputSize", {
        get: function() {
          return this._inputSize;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(TinyYolov2Options2.prototype, "scoreThreshold", {
        get: function() {
          return this._scoreThreshold;
        },
        enumerable: true,
        configurable: true
      });
      return TinyYolov2Options2;
    }();
  }
});

// node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Base.js
var TinyYolov2Base;
var init_TinyYolov2Base = __esm({
  "node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2Base.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_BoundingBox();
    init_ObjectDetection();
    init_common2();
    init_dom();
    init_NeuralNetwork();
    init_ops();
    init_nonMaxSuppression();
    init_normalize();
    init_config2();
    init_convWithBatchNorm();
    init_depthwiseSeparableConv2();
    init_extractParams7();
    init_extractParamsFromWeigthMap7();
    init_leaky();
    init_TinyYolov2Options();
    TinyYolov2Base = /** @class */
    function(_super) {
      __extends(TinyYolov2Base2, _super);
      function TinyYolov2Base2(config2) {
        var _this = _super.call(this, "TinyYolov2") || this;
        validateConfig2(config2);
        _this._config = config2;
        return _this;
      }
      Object.defineProperty(TinyYolov2Base2.prototype, "config", {
        get: function() {
          return this._config;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(TinyYolov2Base2.prototype, "withClassScores", {
        get: function() {
          return this.config.withClassScores || this.config.classes.length > 1;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(TinyYolov2Base2.prototype, "boxEncodingSize", {
        get: function() {
          return 5 + (this.withClassScores ? this.config.classes.length : 0);
        },
        enumerable: true,
        configurable: true
      });
      TinyYolov2Base2.prototype.runTinyYolov2 = function(x2, params) {
        var out = convWithBatchNorm(x2, params.conv0);
        out = hl(out, [2, 2], [2, 2], "same");
        out = convWithBatchNorm(out, params.conv1);
        out = hl(out, [2, 2], [2, 2], "same");
        out = convWithBatchNorm(out, params.conv2);
        out = hl(out, [2, 2], [2, 2], "same");
        out = convWithBatchNorm(out, params.conv3);
        out = hl(out, [2, 2], [2, 2], "same");
        out = convWithBatchNorm(out, params.conv4);
        out = hl(out, [2, 2], [2, 2], "same");
        out = convWithBatchNorm(out, params.conv5);
        out = hl(out, [2, 2], [1, 1], "same");
        out = convWithBatchNorm(out, params.conv6);
        out = convWithBatchNorm(out, params.conv7);
        return convLayer(out, params.conv8, "valid", false);
      };
      TinyYolov2Base2.prototype.runMobilenet = function(x2, params) {
        var out = this.config.isFirstLayerConv2d ? leaky(convLayer(x2, params.conv0, "valid", false)) : depthwiseSeparableConv2(x2, params.conv0);
        out = hl(out, [2, 2], [2, 2], "same");
        out = depthwiseSeparableConv2(out, params.conv1);
        out = hl(out, [2, 2], [2, 2], "same");
        out = depthwiseSeparableConv2(out, params.conv2);
        out = hl(out, [2, 2], [2, 2], "same");
        out = depthwiseSeparableConv2(out, params.conv3);
        out = hl(out, [2, 2], [2, 2], "same");
        out = depthwiseSeparableConv2(out, params.conv4);
        out = hl(out, [2, 2], [2, 2], "same");
        out = depthwiseSeparableConv2(out, params.conv5);
        out = hl(out, [2, 2], [1, 1], "same");
        out = params.conv6 ? depthwiseSeparableConv2(out, params.conv6) : out;
        out = params.conv7 ? depthwiseSeparableConv2(out, params.conv7) : out;
        return convLayer(out, params.conv8, "valid", false);
      };
      TinyYolov2Base2.prototype.forwardInput = function(input2, inputSize) {
        var _this = this;
        var params = this.params;
        if (!params) {
          throw new Error("TinyYolov2 - load model before inference");
        }
        return Ze(function() {
          var batchTensor = input2.toBatchTensor(inputSize, false).toFloat();
          batchTensor = _this.config.meanRgb ? normalize(batchTensor, _this.config.meanRgb) : batchTensor;
          batchTensor = batchTensor.div(On(256));
          return _this.config.withSeparableConvs ? _this.runMobilenet(batchTensor, params) : _this.runTinyYolov2(batchTensor, params);
        });
      };
      TinyYolov2Base2.prototype.forward = function(input2, inputSize) {
        return __awaiter2(this, void 0, void 0, function() {
          var _a2;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _a2 = this.forwardInput;
                return [4, toNetInput(input2)];
              case 1:
                return [4, _a2.apply(this, [_b.sent(), inputSize])];
              case 2:
                return [2, _b.sent()];
            }
          });
        });
      };
      TinyYolov2Base2.prototype.detect = function(input2, forwardParams) {
        if (forwardParams === void 0) {
          forwardParams = {};
        }
        return __awaiter2(this, void 0, void 0, function() {
          var _a2, inputSize, scoreThreshold, netInput, out, out0, inputDimensions, results, boxes, scores, classScores, classNames, indices, detections;
          var _this = this;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _a2 = new TinyYolov2Options(forwardParams), inputSize = _a2.inputSize, scoreThreshold = _a2.scoreThreshold;
                return [4, toNetInput(input2)];
              case 1:
                netInput = _b.sent();
                return [4, this.forwardInput(netInput, inputSize)];
              case 2:
                out = _b.sent();
                out0 = Ze(function() {
                  return Ur(out)[0].expandDims();
                });
                inputDimensions = {
                  width: netInput.getInputWidth(0),
                  height: netInput.getInputHeight(0)
                };
                return [4, this.extractBoxes(out0, netInput.getReshapedInputDimensions(0), scoreThreshold)];
              case 3:
                results = _b.sent();
                out.dispose();
                out0.dispose();
                boxes = results.map(function(res) {
                  return res.box;
                });
                scores = results.map(function(res) {
                  return res.score;
                });
                classScores = results.map(function(res) {
                  return res.classScore;
                });
                classNames = results.map(function(res) {
                  return _this.config.classes[res.label];
                });
                indices = nonMaxSuppression(boxes.map(function(box) {
                  return box.rescale(inputSize);
                }), scores, this.config.iouThreshold, true);
                detections = indices.map(function(idx) {
                  return new ObjectDetection(scores[idx], classScores[idx], classNames[idx], boxes[idx], inputDimensions);
                });
                return [2, detections];
            }
          });
        });
      };
      TinyYolov2Base2.prototype.getDefaultModelName = function() {
        return "";
      };
      TinyYolov2Base2.prototype.extractParamsFromWeigthMap = function(weightMap) {
        return extractParamsFromWeigthMap7(weightMap, this.config);
      };
      TinyYolov2Base2.prototype.extractParams = function(weights) {
        var filterSizes = this.config.filterSizes || TinyYolov2Base2.DEFAULT_FILTER_SIZES;
        var numFilters = filterSizes ? filterSizes.length : void 0;
        if (numFilters !== 7 && numFilters !== 8 && numFilters !== 9) {
          throw new Error("TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found " + numFilters + " filterSizes in config");
        }
        return extractParams7(weights, this.config, this.boxEncodingSize, filterSizes);
      };
      TinyYolov2Base2.prototype.extractBoxes = function(outputTensor, inputBlobDimensions, scoreThreshold) {
        return __awaiter2(this, void 0, void 0, function() {
          var width, height, inputSize, correctionFactorX, correctionFactorY, numCells, numBoxes, _a2, boxesTensor, scoresTensor, classScoresTensor, results, scoresData, boxesData, row, col, anchor, score, ctX, ctY, width_1, height_1, x2, y2, pos, _b, classScore, label, _c6;
          var _this = this;
          return __generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                width = inputBlobDimensions.width, height = inputBlobDimensions.height;
                inputSize = Math.max(width, height);
                correctionFactorX = inputSize / width;
                correctionFactorY = inputSize / height;
                numCells = outputTensor.shape[1];
                numBoxes = this.config.anchors.length;
                _a2 = Ze(function() {
                  var reshaped = outputTensor.reshape([numCells, numCells, numBoxes, _this.boxEncodingSize]);
                  var boxes = reshaped.slice([0, 0, 0, 0], [numCells, numCells, numBoxes, 4]);
                  var scores = reshaped.slice([0, 0, 0, 4], [numCells, numCells, numBoxes, 1]);
                  var classScores = _this.withClassScores ? go(reshaped.slice([0, 0, 0, 5], [numCells, numCells, numBoxes, _this.config.classes.length]), 3) : On(0);
                  return [boxes, scores, classScores];
                }), boxesTensor = _a2[0], scoresTensor = _a2[1], classScoresTensor = _a2[2];
                results = [];
                return [4, scoresTensor.array()];
              case 1:
                scoresData = _d.sent();
                return [4, boxesTensor.array()];
              case 2:
                boxesData = _d.sent();
                row = 0;
                _d.label = 3;
              case 3:
                if (!(row < numCells)) return [3, 12];
                col = 0;
                _d.label = 4;
              case 4:
                if (!(col < numCells)) return [3, 11];
                anchor = 0;
                _d.label = 5;
              case 5:
                if (!(anchor < numBoxes)) return [3, 10];
                score = sigmoid(scoresData[row][col][anchor][0]);
                if (!(!scoreThreshold || score > scoreThreshold)) return [3, 9];
                ctX = (col + sigmoid(boxesData[row][col][anchor][0])) / numCells * correctionFactorX;
                ctY = (row + sigmoid(boxesData[row][col][anchor][1])) / numCells * correctionFactorY;
                width_1 = Math.exp(boxesData[row][col][anchor][2]) * this.config.anchors[anchor].x / numCells * correctionFactorX;
                height_1 = Math.exp(boxesData[row][col][anchor][3]) * this.config.anchors[anchor].y / numCells * correctionFactorY;
                x2 = ctX - width_1 / 2;
                y2 = ctY - height_1 / 2;
                pos = { row, col, anchor };
                if (!this.withClassScores) return [3, 7];
                return [4, this.extractPredictedClass(classScoresTensor, pos)];
              case 6:
                _c6 = _d.sent();
                return [3, 8];
              case 7:
                _c6 = { classScore: 1, label: 0 };
                _d.label = 8;
              case 8:
                _b = _c6, classScore = _b.classScore, label = _b.label;
                results.push(__assign({ box: new BoundingBox(x2, y2, x2 + width_1, y2 + height_1), score, classScore: score * classScore, label }, pos));
                _d.label = 9;
              case 9:
                anchor++;
                return [3, 5];
              case 10:
                col++;
                return [3, 4];
              case 11:
                row++;
                return [3, 3];
              case 12:
                boxesTensor.dispose();
                scoresTensor.dispose();
                classScoresTensor.dispose();
                return [2, results];
            }
          });
        });
      };
      TinyYolov2Base2.prototype.extractPredictedClass = function(classesTensor, pos) {
        return __awaiter2(this, void 0, void 0, function() {
          var row, col, anchor, classesData;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                row = pos.row, col = pos.col, anchor = pos.anchor;
                return [4, classesTensor.array()];
              case 1:
                classesData = _a2.sent();
                return [2, Array(this.config.classes.length).fill(0).map(function(_2, i2) {
                  return classesData[row][col][anchor][i2];
                }).map(function(classScore, label) {
                  return {
                    classScore,
                    label
                  };
                }).reduce(function(max, curr) {
                  return max.classScore > curr.classScore ? max : curr;
                })];
            }
          });
        });
      };
      TinyYolov2Base2.DEFAULT_FILTER_SIZES = [
        3,
        16,
        32,
        64,
        128,
        256,
        512,
        1024,
        1024
      ];
      return TinyYolov2Base2;
    }(NeuralNetwork);
  }
});

// node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2.js
var TinyYolov2;
var init_TinyYolov2 = __esm({
  "node_modules/face-api.js/build/es6/tinyYolov2/TinyYolov2.js"() {
    "use strict";
    init_tslib_es62();
    init_classes();
    init_const();
    init_TinyYolov2Base();
    TinyYolov2 = /** @class */
    function(_super) {
      __extends(TinyYolov22, _super);
      function TinyYolov22(withSeparableConvs) {
        if (withSeparableConvs === void 0) {
          withSeparableConvs = true;
        }
        var _this = this;
        var config2 = Object.assign({}, {
          withSeparableConvs,
          iouThreshold: IOU_THRESHOLD,
          classes: ["face"]
        }, withSeparableConvs ? {
          anchors: BOX_ANCHORS_SEPARABLE,
          meanRgb: MEAN_RGB_SEPARABLE
        } : {
          anchors: BOX_ANCHORS,
          withClassScores: true
        });
        _this = _super.call(this, config2) || this;
        return _this;
      }
      Object.defineProperty(TinyYolov22.prototype, "withSeparableConvs", {
        get: function() {
          return this.config.withSeparableConvs;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(TinyYolov22.prototype, "anchors", {
        get: function() {
          return this.config.anchors;
        },
        enumerable: true,
        configurable: true
      });
      TinyYolov22.prototype.locateFaces = function(input2, forwardParams) {
        return __awaiter2(this, void 0, void 0, function() {
          var objectDetections;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.detect(input2, forwardParams)];
              case 1:
                objectDetections = _a2.sent();
                return [2, objectDetections.map(function(det) {
                  return new FaceDetection(det.score, det.relativeBox, { width: det.imageWidth, height: det.imageHeight });
                })];
            }
          });
        });
      };
      TinyYolov22.prototype.getDefaultModelName = function() {
        return this.withSeparableConvs ? DEFAULT_MODEL_NAME_SEPARABLE_CONV : DEFAULT_MODEL_NAME;
      };
      TinyYolov22.prototype.extractParamsFromWeigthMap = function(weightMap) {
        return _super.prototype.extractParamsFromWeigthMap.call(this, weightMap);
      };
      return TinyYolov22;
    }(TinyYolov2Base);
  }
});

// node_modules/face-api.js/build/es6/tinyYolov2/index.js
var init_tinyYolov2 = __esm({
  "node_modules/face-api.js/build/es6/tinyYolov2/index.js"() {
    "use strict";
    init_TinyYolov2();
    init_TinyYolov2Options();
    init_config2();
  }
});

// node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetectorOptions.js
var TinyFaceDetectorOptions;
var init_TinyFaceDetectorOptions = __esm({
  "node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetectorOptions.js"() {
    "use strict";
    init_tslib_es62();
    init_tinyYolov2();
    TinyFaceDetectorOptions = /** @class */
    function(_super) {
      __extends(TinyFaceDetectorOptions2, _super);
      function TinyFaceDetectorOptions2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._name = "TinyFaceDetectorOptions";
        return _this;
      }
      return TinyFaceDetectorOptions2;
    }(TinyYolov2Options);
  }
});

// node_modules/face-api.js/build/es6/globalApi/ComposableTask.js
var ComposableTask;
var init_ComposableTask = __esm({
  "node_modules/face-api.js/build/es6/globalApi/ComposableTask.js"() {
    "use strict";
    init_tslib_es62();
    ComposableTask = /** @class */
    function() {
      function ComposableTask2() {
      }
      ComposableTask2.prototype.then = function(onfulfilled) {
        return __awaiter2(this, void 0, void 0, function() {
          var _a2;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _a2 = onfulfilled;
                return [4, this.run()];
              case 1:
                return [2, _a2.apply(void 0, [_b.sent()])];
            }
          });
        });
      };
      ComposableTask2.prototype.run = function() {
        return __awaiter2(this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            throw new Error("ComposableTask - run is not implemented");
          });
        });
      };
      return ComposableTask2;
    }();
  }
});

// node_modules/face-api.js/build/es6/globalApi/extractFacesAndComputeResults.js
function extractAllFacesAndComputeResults(parentResults, input2, computeResults, extractedFaces, getRectForAlignment) {
  if (getRectForAlignment === void 0) {
    getRectForAlignment = function(_a2) {
      var alignedRect = _a2.alignedRect;
      return alignedRect;
    };
  }
  return __awaiter2(this, void 0, void 0, function() {
    var faceBoxes, faces, _a2, _b, results;
    return __generator(this, function(_c6) {
      switch (_c6.label) {
        case 0:
          faceBoxes = parentResults.map(function(parentResult) {
            return isWithFaceLandmarks(parentResult) ? getRectForAlignment(parentResult) : parentResult.detection;
          });
          _a2 = extractedFaces;
          if (_a2) return [3, 5];
          if (!(input2 instanceof wt)) return [3, 2];
          return [4, extractFaceTensors(input2, faceBoxes)];
        case 1:
          _b = _c6.sent();
          return [3, 4];
        case 2:
          return [4, extractFaces(input2, faceBoxes)];
        case 3:
          _b = _c6.sent();
          _c6.label = 4;
        case 4:
          _a2 = _b;
          _c6.label = 5;
        case 5:
          faces = _a2;
          return [4, computeResults(faces)];
        case 6:
          results = _c6.sent();
          faces.forEach(function(f2) {
            return f2 instanceof wt && f2.dispose();
          });
          return [2, results];
      }
    });
  });
}
function extractSingleFaceAndComputeResult(parentResult, input2, computeResult, extractedFaces, getRectForAlignment) {
  return __awaiter2(this, void 0, void 0, function() {
    var _this = this;
    return __generator(this, function(_a2) {
      return [2, extractAllFacesAndComputeResults([parentResult], input2, function(faces) {
        return __awaiter2(_this, void 0, void 0, function() {
          return __generator(this, function(_a3) {
            return [2, computeResult(faces[0])];
          });
        });
      }, extractedFaces, getRectForAlignment)];
    });
  });
}
var init_extractFacesAndComputeResults = __esm({
  "node_modules/face-api.js/build/es6/globalApi/extractFacesAndComputeResults.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_dom();
    init_WithFaceLandmarks();
  }
});

// node_modules/face-api.js/build/es6/mtcnn/bgrToRgbTensor.js
function bgrToRgbTensor(tensor) {
  return Ze(function() {
    return Pr(Ur(tensor, 3).reverse(), 3);
  });
}
var init_bgrToRgbTensor = __esm({
  "node_modules/face-api.js/build/es6/mtcnn/bgrToRgbTensor.js"() {
    "use strict";
    init_tf_core_esm();
  }
});

// node_modules/face-api.js/build/es6/mtcnn/config.js
var CELL_STRIDE, CELL_SIZE;
var init_config3 = __esm({
  "node_modules/face-api.js/build/es6/mtcnn/config.js"() {
    "use strict";
    CELL_STRIDE = 2;
    CELL_SIZE = 12;
  }
});

// node_modules/face-api.js/build/es6/mtcnn/extractParams.js
function extractorsFactory9(extractWeights, paramMappings) {
  var extractConvParams = extractConvParamsFactory(extractWeights, paramMappings);
  var extractFCParams = extractFCParamsFactory(extractWeights, paramMappings);
  function extractPReluParams(size, paramPath) {
    var alpha = Mn(extractWeights(size));
    paramMappings.push({ paramPath });
    return alpha;
  }
  function extractSharedParams(numFilters, mappedPrefix, isRnet) {
    if (isRnet === void 0) {
      isRnet = false;
    }
    var conv1 = extractConvParams(numFilters[0], numFilters[1], 3, mappedPrefix + "/conv1");
    var prelu1_alpha = extractPReluParams(numFilters[1], mappedPrefix + "/prelu1_alpha");
    var conv22 = extractConvParams(numFilters[1], numFilters[2], 3, mappedPrefix + "/conv2");
    var prelu2_alpha = extractPReluParams(numFilters[2], mappedPrefix + "/prelu2_alpha");
    var conv3 = extractConvParams(numFilters[2], numFilters[3], isRnet ? 2 : 3, mappedPrefix + "/conv3");
    var prelu3_alpha = extractPReluParams(numFilters[3], mappedPrefix + "/prelu3_alpha");
    return { conv1, prelu1_alpha, conv2: conv22, prelu2_alpha, conv3, prelu3_alpha };
  }
  function extractPNetParams() {
    var sharedParams = extractSharedParams([3, 10, 16, 32], "pnet");
    var conv4_1 = extractConvParams(32, 2, 1, "pnet/conv4_1");
    var conv4_2 = extractConvParams(32, 4, 1, "pnet/conv4_2");
    return __assign(__assign({}, sharedParams), { conv4_1, conv4_2 });
  }
  function extractRNetParams() {
    var sharedParams = extractSharedParams([3, 28, 48, 64], "rnet", true);
    var fc1 = extractFCParams(576, 128, "rnet/fc1");
    var prelu4_alpha = extractPReluParams(128, "rnet/prelu4_alpha");
    var fc2_1 = extractFCParams(128, 2, "rnet/fc2_1");
    var fc2_2 = extractFCParams(128, 4, "rnet/fc2_2");
    return __assign(__assign({}, sharedParams), { fc1, prelu4_alpha, fc2_1, fc2_2 });
  }
  function extractONetParams() {
    var sharedParams = extractSharedParams([3, 32, 64, 64], "onet");
    var conv4 = extractConvParams(64, 128, 2, "onet/conv4");
    var prelu4_alpha = extractPReluParams(128, "onet/prelu4_alpha");
    var fc1 = extractFCParams(1152, 256, "onet/fc1");
    var prelu5_alpha = extractPReluParams(256, "onet/prelu5_alpha");
    var fc2_1 = extractFCParams(256, 2, "onet/fc2_1");
    var fc2_2 = extractFCParams(256, 4, "onet/fc2_2");
    var fc2_3 = extractFCParams(256, 10, "onet/fc2_3");
    return __assign(__assign({}, sharedParams), { conv4, prelu4_alpha, fc1, prelu5_alpha, fc2_1, fc2_2, fc2_3 });
  }
  return {
    extractPNetParams,
    extractRNetParams,
    extractONetParams
  };
}
function extractParams8(weights) {
  var _a2 = extractWeightsFactory(weights), extractWeights = _a2.extractWeights, getRemainingWeights = _a2.getRemainingWeights;
  var paramMappings = [];
  var _b = extractorsFactory9(extractWeights, paramMappings), extractPNetParams = _b.extractPNetParams, extractRNetParams = _b.extractRNetParams, extractONetParams = _b.extractONetParams;
  var pnet = extractPNetParams();
  var rnet = extractRNetParams();
  var onet = extractONetParams();
  if (getRemainingWeights().length !== 0) {
    throw new Error("weights remaing after extract: " + getRemainingWeights().length);
  }
  return { params: { pnet, rnet, onet }, paramMappings };
}
var init_extractParams8 = __esm({
  "node_modules/face-api.js/build/es6/mtcnn/extractParams.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_common2();
  }
});

// node_modules/face-api.js/build/es6/mtcnn/extractParamsFromWeigthMap.js
function extractorsFactory10(weightMap, paramMappings) {
  var extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);
  function extractConvParams(prefix) {
    var filters = extractWeightEntry(prefix + "/weights", 4, prefix + "/filters");
    var bias = extractWeightEntry(prefix + "/bias", 1);
    return { filters, bias };
  }
  function extractFCParams(prefix) {
    var weights = extractWeightEntry(prefix + "/weights", 2);
    var bias = extractWeightEntry(prefix + "/bias", 1);
    return { weights, bias };
  }
  function extractPReluParams(paramPath) {
    return extractWeightEntry(paramPath, 1);
  }
  function extractSharedParams(prefix) {
    var conv1 = extractConvParams(prefix + "/conv1");
    var prelu1_alpha = extractPReluParams(prefix + "/prelu1_alpha");
    var conv22 = extractConvParams(prefix + "/conv2");
    var prelu2_alpha = extractPReluParams(prefix + "/prelu2_alpha");
    var conv3 = extractConvParams(prefix + "/conv3");
    var prelu3_alpha = extractPReluParams(prefix + "/prelu3_alpha");
    return { conv1, prelu1_alpha, conv2: conv22, prelu2_alpha, conv3, prelu3_alpha };
  }
  function extractPNetParams() {
    var sharedParams = extractSharedParams("pnet");
    var conv4_1 = extractConvParams("pnet/conv4_1");
    var conv4_2 = extractConvParams("pnet/conv4_2");
    return __assign(__assign({}, sharedParams), { conv4_1, conv4_2 });
  }
  function extractRNetParams() {
    var sharedParams = extractSharedParams("rnet");
    var fc1 = extractFCParams("rnet/fc1");
    var prelu4_alpha = extractPReluParams("rnet/prelu4_alpha");
    var fc2_1 = extractFCParams("rnet/fc2_1");
    var fc2_2 = extractFCParams("rnet/fc2_2");
    return __assign(__assign({}, sharedParams), { fc1, prelu4_alpha, fc2_1, fc2_2 });
  }
  function extractONetParams() {
    var sharedParams = extractSharedParams("onet");
    var conv4 = extractConvParams("onet/conv4");
    var prelu4_alpha = extractPReluParams("onet/prelu4_alpha");
    var fc1 = extractFCParams("onet/fc1");
    var prelu5_alpha = extractPReluParams("onet/prelu5_alpha");
    var fc2_1 = extractFCParams("onet/fc2_1");
    var fc2_2 = extractFCParams("onet/fc2_2");
    var fc2_3 = extractFCParams("onet/fc2_3");
    return __assign(__assign({}, sharedParams), { conv4, prelu4_alpha, fc1, prelu5_alpha, fc2_1, fc2_2, fc2_3 });
  }
  return {
    extractPNetParams,
    extractRNetParams,
    extractONetParams
  };
}
function extractParamsFromWeigthMap8(weightMap) {
  var paramMappings = [];
  var _a2 = extractorsFactory10(weightMap, paramMappings), extractPNetParams = _a2.extractPNetParams, extractRNetParams = _a2.extractRNetParams, extractONetParams = _a2.extractONetParams;
  var pnet = extractPNetParams();
  var rnet = extractRNetParams();
  var onet = extractONetParams();
  disposeUnusedWeightTensors(weightMap, paramMappings);
  return { params: { pnet, rnet, onet }, paramMappings };
}
var init_extractParamsFromWeigthMap8 = __esm({
  "node_modules/face-api.js/build/es6/mtcnn/extractParamsFromWeigthMap.js"() {
    "use strict";
    init_tslib_es62();
    init_common2();
  }
});

// node_modules/face-api.js/build/es6/mtcnn/getSizesForScale.js
function getSizesForScale(scale2, _a2) {
  var height = _a2[0], width = _a2[1];
  return {
    height: Math.floor(height * scale2),
    width: Math.floor(width * scale2)
  };
}
var init_getSizesForScale = __esm({
  "node_modules/face-api.js/build/es6/mtcnn/getSizesForScale.js"() {
    "use strict";
  }
});

// node_modules/face-api.js/build/es6/mtcnn/pyramidDown.js
function pyramidDown(minFaceSize, scaleFactor, dims) {
  var height = dims[0], width = dims[1];
  var m = CELL_SIZE / minFaceSize;
  var scales = [];
  var minLayer = Math.min(height, width) * m;
  var exp = 0;
  while (minLayer >= 12) {
    scales.push(m * Math.pow(scaleFactor, exp));
    minLayer = minLayer * scaleFactor;
    exp += 1;
  }
  return scales;
}
var init_pyramidDown = __esm({
  "node_modules/face-api.js/build/es6/mtcnn/pyramidDown.js"() {
    "use strict";
    init_config3();
  }
});

// node_modules/face-api.js/build/es6/mtcnn/MtcnnBox.js
var MtcnnBox;
var init_MtcnnBox = __esm({
  "node_modules/face-api.js/build/es6/mtcnn/MtcnnBox.js"() {
    "use strict";
    init_tslib_es62();
    init_classes();
    MtcnnBox = /** @class */
    function(_super) {
      __extends(MtcnnBox2, _super);
      function MtcnnBox2(left, top, right, bottom) {
        return _super.call(this, { left, top, right, bottom }, true) || this;
      }
      return MtcnnBox2;
    }(Box);
  }
});

// node_modules/face-api.js/build/es6/mtcnn/normalize.js
function normalize2(x2) {
  return Ze(function() {
    return gc(Cc(x2, On(127.5)), On(78125e-7));
  });
}
var init_normalize2 = __esm({
  "node_modules/face-api.js/build/es6/mtcnn/normalize.js"() {
    "use strict";
    init_tf_core_esm();
  }
});

// node_modules/face-api.js/build/es6/mtcnn/prelu.js
function prelu(x2, alpha) {
  return Ze(function() {
    return rc(Bl(x2), gc(alpha, wu(Bl(wu(x2)))));
  });
}
var init_prelu = __esm({
  "node_modules/face-api.js/build/es6/mtcnn/prelu.js"() {
    "use strict";
    init_tf_core_esm();
  }
});

// node_modules/face-api.js/build/es6/mtcnn/sharedLayers.js
function sharedLayer(x2, params, isPnet) {
  if (isPnet === void 0) {
    isPnet = false;
  }
  return Ze(function() {
    var out = convLayer(x2, params.conv1, "valid");
    out = prelu(out, params.prelu1_alpha);
    out = hl(out, isPnet ? [2, 2] : [3, 3], [2, 2], "same");
    out = convLayer(out, params.conv2, "valid");
    out = prelu(out, params.prelu2_alpha);
    out = isPnet ? out : hl(out, [3, 3], [2, 2], "valid");
    out = convLayer(out, params.conv3, "valid");
    out = prelu(out, params.prelu3_alpha);
    return out;
  });
}
var init_sharedLayers = __esm({
  "node_modules/face-api.js/build/es6/mtcnn/sharedLayers.js"() {
    "use strict";
    init_tf_core_esm();
    init_common2();
    init_prelu();
  }
});

// node_modules/face-api.js/build/es6/mtcnn/PNet.js
function PNet(x2, params) {
  return Ze(function() {
    var out = sharedLayer(x2, params, true);
    var conv3 = convLayer(out, params.conv4_1, "valid");
    var max = wr(Sl(conv3, 3), 3);
    var prob = go(Cc(conv3, max), 3);
    var regions = convLayer(out, params.conv4_2, "valid");
    return { prob, regions };
  });
}
var init_PNet = __esm({
  "node_modules/face-api.js/build/es6/mtcnn/PNet.js"() {
    "use strict";
    init_tf_core_esm();
    init_common2();
    init_sharedLayers();
  }
});

// node_modules/face-api.js/build/es6/mtcnn/stage1.js
function rescaleAndNormalize(x2, scale2) {
  return Ze(function() {
    var _a2 = getSizesForScale(scale2, x2.shape.slice(1)), height = _a2.height, width = _a2.width;
    var resized = Oh.resizeBilinear(x2, [height, width]);
    var normalized = normalize2(resized);
    return Wl(normalized, [0, 2, 1, 3]);
  });
}
function extractBoundingBoxes(scoresTensor, regionsTensor, scale2, scoreThreshold) {
  var indices = [];
  var scoresData = scoresTensor.arraySync();
  for (var y2 = 0; y2 < scoresTensor.shape[0]; y2++) {
    for (var x2 = 0; x2 < scoresTensor.shape[1]; x2++) {
      if (scoresData[y2][x2] >= scoreThreshold) {
        indices.push(new Point(x2, y2));
      }
    }
  }
  var boundingBoxes = indices.map(function(idx) {
    var cell = new BoundingBox(Math.round((idx.y * CELL_STRIDE + 1) / scale2), Math.round((idx.x * CELL_STRIDE + 1) / scale2), Math.round((idx.y * CELL_STRIDE + CELL_SIZE) / scale2), Math.round((idx.x * CELL_STRIDE + CELL_SIZE) / scale2));
    var score = scoresData[idx.y][idx.x];
    var regionsData = regionsTensor.arraySync();
    var region = new MtcnnBox(regionsData[idx.y][idx.x][0], regionsData[idx.y][idx.x][1], regionsData[idx.y][idx.x][2], regionsData[idx.y][idx.x][3]);
    return {
      cell,
      score,
      region
    };
  });
  return boundingBoxes;
}
function stage1(imgTensor, scales, scoreThreshold, params, stats) {
  stats.stage1 = [];
  var pnetOutputs = scales.map(function(scale2) {
    return Ze(function() {
      var statsForScale = { scale: scale2 };
      var resized = rescaleAndNormalize(imgTensor, scale2);
      var ts3 = Date.now();
      var _a2 = PNet(resized, params), prob = _a2.prob, regions = _a2.regions;
      statsForScale.pnet = Date.now() - ts3;
      var scoresTensor = Ur(Ur(prob, 3)[1])[0];
      var regionsTensor = Ur(regions)[0];
      return {
        scoresTensor,
        regionsTensor,
        scale: scale2,
        statsForScale
      };
    });
  });
  var boxesForScale = pnetOutputs.map(function(_a2) {
    var scoresTensor = _a2.scoresTensor, regionsTensor = _a2.regionsTensor, scale2 = _a2.scale, statsForScale = _a2.statsForScale;
    var boundingBoxes = extractBoundingBoxes(scoresTensor, regionsTensor, scale2, scoreThreshold);
    scoresTensor.dispose();
    regionsTensor.dispose();
    if (!boundingBoxes.length) {
      stats.stage1.push(statsForScale);
      return [];
    }
    var ts3 = Date.now();
    var indices2 = nonMaxSuppression(boundingBoxes.map(function(bbox) {
      return bbox.cell;
    }), boundingBoxes.map(function(bbox) {
      return bbox.score;
    }), 0.5);
    statsForScale.nms = Date.now() - ts3;
    statsForScale.numBoxes = indices2.length;
    stats.stage1.push(statsForScale);
    return indices2.map(function(boxIdx) {
      return boundingBoxes[boxIdx];
    });
  });
  var allBoxes = boxesForScale.reduce(function(all, boxes) {
    return all.concat(boxes);
  }, []);
  var finalBoxes = [];
  var finalScores = [];
  if (allBoxes.length > 0) {
    var ts2 = Date.now();
    var indices = nonMaxSuppression(allBoxes.map(function(bbox) {
      return bbox.cell;
    }), allBoxes.map(function(bbox) {
      return bbox.score;
    }), 0.7);
    stats.stage1_nms = Date.now() - ts2;
    finalScores = indices.map(function(idx) {
      return allBoxes[idx].score;
    });
    finalBoxes = indices.map(function(idx) {
      return allBoxes[idx];
    }).map(function(_a2) {
      var cell = _a2.cell, region = _a2.region;
      return new BoundingBox(cell.left + region.left * cell.width, cell.top + region.top * cell.height, cell.right + region.right * cell.width, cell.bottom + region.bottom * cell.height).toSquare().round();
    });
  }
  return {
    boxes: finalBoxes,
    scores: finalScores
  };
}
var init_stage1 = __esm({
  "node_modules/face-api.js/build/es6/mtcnn/stage1.js"() {
    "use strict";
    init_tf_core_esm();
    init_classes();
    init_ops();
    init_config3();
    init_getSizesForScale();
    init_MtcnnBox();
    init_normalize2();
    init_PNet();
  }
});

// node_modules/face-api.js/build/es6/mtcnn/extractImagePatches.js
function extractImagePatches(img, boxes, _a2) {
  var width = _a2.width, height = _a2.height;
  return __awaiter2(this, void 0, void 0, function() {
    var imgCtx, bitmaps, imagePatchesDatas;
    var _this = this;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          imgCtx = getContext2dOrThrow(img);
          return [4, Promise.all(boxes.map(function(box) {
            return __awaiter2(_this, void 0, void 0, function() {
              var _a3, y2, ey, x2, ex, fromX, fromY, imgData;
              return __generator(this, function(_b2) {
                _a3 = box.padAtBorders(img.height, img.width), y2 = _a3.y, ey = _a3.ey, x2 = _a3.x, ex = _a3.ex;
                fromX = x2 - 1;
                fromY = y2 - 1;
                imgData = imgCtx.getImageData(fromX, fromY, ex - fromX, ey - fromY);
                return [2, env.isNodejs() ? createCanvasFromMedia(imgData) : createImageBitmap(imgData)];
              });
            });
          }))];
        case 1:
          bitmaps = _b.sent();
          imagePatchesDatas = [];
          bitmaps.forEach(function(bmp) {
            var patch = createCanvas({ width, height });
            var patchCtx = getContext2dOrThrow(patch);
            patchCtx.drawImage(bmp, 0, 0, width, height);
            var data = patchCtx.getImageData(0, 0, width, height).data;
            var currData = [];
            for (var i2 = 0; i2 < data.length; i2 += 4) {
              currData.push(data[i2 + 2]);
              currData.push(data[i2 + 1]);
              currData.push(data[i2]);
            }
            imagePatchesDatas.push(currData);
          });
          return [2, imagePatchesDatas.map(function(data) {
            var t2 = Ze(function() {
              var imagePatchTensor = Wl(Ln(data, [1, width, height, 3]), [0, 2, 1, 3]).toFloat();
              return normalize2(imagePatchTensor);
            });
            return t2;
          })];
      }
    });
  });
}
var init_extractImagePatches = __esm({
  "node_modules/face-api.js/build/es6/mtcnn/extractImagePatches.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_dom();
    init_env();
    init_normalize2();
  }
});

// node_modules/face-api.js/build/es6/mtcnn/RNet.js
function RNet(x2, params) {
  return Ze(function() {
    var convOut = sharedLayer(x2, params);
    var vectorized = Or(convOut, [convOut.shape[0], params.fc1.weights.shape[0]]);
    var fc1 = fullyConnectedLayer(vectorized, params.fc1);
    var prelu4 = prelu(fc1, params.prelu4_alpha);
    var fc2_1 = fullyConnectedLayer(prelu4, params.fc2_1);
    var max = wr(Sl(fc2_1, 1), 1);
    var prob = go(Cc(fc2_1, max), 1);
    var regions = fullyConnectedLayer(prelu4, params.fc2_2);
    var scores = Ur(prob, 1)[1];
    return { scores, regions };
  });
}
var init_RNet = __esm({
  "node_modules/face-api.js/build/es6/mtcnn/RNet.js"() {
    "use strict";
    init_tf_core_esm();
    init_fullyConnectedLayer();
    init_prelu();
    init_sharedLayers();
  }
});

// node_modules/face-api.js/build/es6/mtcnn/stage2.js
function stage2(img, inputBoxes, scoreThreshold, params, stats) {
  return __awaiter2(this, void 0, void 0, function() {
    var ts2, rnetInputs, rnetOuts, scoresTensor, scores, _a2, _b, indices, filteredBoxes, filteredScores, finalBoxes, finalScores, indicesNms, regions_1;
    return __generator(this, function(_c6) {
      switch (_c6.label) {
        case 0:
          ts2 = Date.now();
          return [4, extractImagePatches(img, inputBoxes, { width: 24, height: 24 })];
        case 1:
          rnetInputs = _c6.sent();
          stats.stage2_extractImagePatches = Date.now() - ts2;
          ts2 = Date.now();
          rnetOuts = rnetInputs.map(function(rnetInput) {
            var out = RNet(rnetInput, params);
            rnetInput.dispose();
            return out;
          });
          stats.stage2_rnet = Date.now() - ts2;
          scoresTensor = rnetOuts.length > 1 ? Yn(rnetOuts.map(function(out) {
            return out.scores;
          })) : rnetOuts[0].scores;
          _b = (_a2 = Array).from;
          return [4, scoresTensor.data()];
        case 2:
          scores = _b.apply(_a2, [_c6.sent()]);
          scoresTensor.dispose();
          indices = scores.map(function(score, idx) {
            return { score, idx };
          }).filter(function(c2) {
            return c2.score > scoreThreshold;
          }).map(function(_a3) {
            var idx = _a3.idx;
            return idx;
          });
          filteredBoxes = indices.map(function(idx) {
            return inputBoxes[idx];
          });
          filteredScores = indices.map(function(idx) {
            return scores[idx];
          });
          finalBoxes = [];
          finalScores = [];
          if (filteredBoxes.length > 0) {
            ts2 = Date.now();
            indicesNms = nonMaxSuppression(filteredBoxes, filteredScores, 0.7);
            stats.stage2_nms = Date.now() - ts2;
            regions_1 = indicesNms.map(function(idx) {
              var regionsData = rnetOuts[indices[idx]].regions.arraySync();
              return new MtcnnBox(regionsData[0][0], regionsData[0][1], regionsData[0][2], regionsData[0][3]);
            });
            finalScores = indicesNms.map(function(idx) {
              return filteredScores[idx];
            });
            finalBoxes = indicesNms.map(function(idx, i2) {
              return filteredBoxes[idx].calibrate(regions_1[i2]);
            });
          }
          rnetOuts.forEach(function(t2) {
            t2.regions.dispose();
            t2.scores.dispose();
          });
          return [2, {
            boxes: finalBoxes,
            scores: finalScores
          }];
      }
    });
  });
}
var init_stage2 = __esm({
  "node_modules/face-api.js/build/es6/mtcnn/stage2.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_ops();
    init_extractImagePatches();
    init_MtcnnBox();
    init_RNet();
  }
});

// node_modules/face-api.js/build/es6/mtcnn/ONet.js
function ONet(x2, params) {
  return Ze(function() {
    var out = sharedLayer(x2, params);
    out = hl(out, [2, 2], [2, 2], "same");
    out = convLayer(out, params.conv4, "valid");
    out = prelu(out, params.prelu4_alpha);
    var vectorized = Or(out, [out.shape[0], params.fc1.weights.shape[0]]);
    var fc1 = fullyConnectedLayer(vectorized, params.fc1);
    var prelu5 = prelu(fc1, params.prelu5_alpha);
    var fc2_1 = fullyConnectedLayer(prelu5, params.fc2_1);
    var max = wr(Sl(fc2_1, 1), 1);
    var prob = go(Cc(fc2_1, max), 1);
    var regions = fullyConnectedLayer(prelu5, params.fc2_2);
    var points = fullyConnectedLayer(prelu5, params.fc2_3);
    var scores = Ur(prob, 1)[1];
    return { scores, regions, points };
  });
}
var init_ONet = __esm({
  "node_modules/face-api.js/build/es6/mtcnn/ONet.js"() {
    "use strict";
    init_tf_core_esm();
    init_common2();
    init_fullyConnectedLayer();
    init_prelu();
    init_sharedLayers();
  }
});

// node_modules/face-api.js/build/es6/mtcnn/stage3.js
function stage3(img, inputBoxes, scoreThreshold, params, stats) {
  return __awaiter2(this, void 0, void 0, function() {
    var ts2, onetInputs, onetOuts, scoresTensor, scores, _a2, _b, indices, filteredRegions, filteredBoxes, filteredScores, finalBoxes, finalScores, points, indicesNms;
    return __generator(this, function(_c6) {
      switch (_c6.label) {
        case 0:
          ts2 = Date.now();
          return [4, extractImagePatches(img, inputBoxes, { width: 48, height: 48 })];
        case 1:
          onetInputs = _c6.sent();
          stats.stage3_extractImagePatches = Date.now() - ts2;
          ts2 = Date.now();
          onetOuts = onetInputs.map(function(onetInput) {
            var out = ONet(onetInput, params);
            onetInput.dispose();
            return out;
          });
          stats.stage3_onet = Date.now() - ts2;
          scoresTensor = onetOuts.length > 1 ? Yn(onetOuts.map(function(out) {
            return out.scores;
          })) : onetOuts[0].scores;
          _b = (_a2 = Array).from;
          return [4, scoresTensor.data()];
        case 2:
          scores = _b.apply(_a2, [_c6.sent()]);
          scoresTensor.dispose();
          indices = scores.map(function(score, idx) {
            return { score, idx };
          }).filter(function(c2) {
            return c2.score > scoreThreshold;
          }).map(function(_a3) {
            var idx = _a3.idx;
            return idx;
          });
          filteredRegions = indices.map(function(idx) {
            var regionsData = onetOuts[idx].regions.arraySync();
            return new MtcnnBox(regionsData[0][0], regionsData[0][1], regionsData[0][2], regionsData[0][3]);
          });
          filteredBoxes = indices.map(function(idx, i2) {
            return inputBoxes[idx].calibrate(filteredRegions[i2]);
          });
          filteredScores = indices.map(function(idx) {
            return scores[idx];
          });
          finalBoxes = [];
          finalScores = [];
          points = [];
          if (filteredBoxes.length > 0) {
            ts2 = Date.now();
            indicesNms = nonMaxSuppression(filteredBoxes, filteredScores, 0.7, false);
            stats.stage3_nms = Date.now() - ts2;
            finalBoxes = indicesNms.map(function(idx) {
              return filteredBoxes[idx];
            });
            finalScores = indicesNms.map(function(idx) {
              return filteredScores[idx];
            });
            points = indicesNms.map(function(idx, i2) {
              return Array(5).fill(0).map(function(_2, ptIdx) {
                var pointsData = onetOuts[idx].points.arraySync();
                return new Point(pointsData[0][ptIdx] * (finalBoxes[i2].width + 1) + finalBoxes[i2].left, pointsData[0][ptIdx + 5] * (finalBoxes[i2].height + 1) + finalBoxes[i2].top);
              });
            });
          }
          onetOuts.forEach(function(t2) {
            t2.regions.dispose();
            t2.scores.dispose();
            t2.points.dispose();
          });
          return [2, {
            boxes: finalBoxes,
            scores: finalScores,
            points
          }];
      }
    });
  });
}
var init_stage3 = __esm({
  "node_modules/face-api.js/build/es6/mtcnn/stage3.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_classes();
    init_ops();
    init_extractImagePatches();
    init_MtcnnBox();
    init_ONet();
  }
});

// node_modules/face-api.js/build/es6/mtcnn/Mtcnn.js
var Mtcnn;
var init_Mtcnn = __esm({
  "node_modules/face-api.js/build/es6/mtcnn/Mtcnn.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_classes();
    init_FaceDetection();
    init_FaceLandmarks5();
    init_dom();
    init_factories();
    init_NeuralNetwork();
    init_bgrToRgbTensor();
    init_config3();
    init_extractParams8();
    init_extractParamsFromWeigthMap8();
    init_getSizesForScale();
    init_MtcnnOptions();
    init_pyramidDown();
    init_stage1();
    init_stage2();
    init_stage3();
    Mtcnn = /** @class */
    function(_super) {
      __extends(Mtcnn2, _super);
      function Mtcnn2() {
        return _super.call(this, "Mtcnn") || this;
      }
      Mtcnn2.prototype.load = function(weightsOrUrl) {
        return __awaiter2(this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            console.warn("mtcnn is deprecated and will be removed soon");
            return [2, _super.prototype.load.call(this, weightsOrUrl)];
          });
        });
      };
      Mtcnn2.prototype.loadFromDisk = function(filePath) {
        return __awaiter2(this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            console.warn("mtcnn is deprecated and will be removed soon");
            return [2, _super.prototype.loadFromDisk.call(this, filePath)];
          });
        });
      };
      Mtcnn2.prototype.forwardInput = function(input2, forwardParams) {
        if (forwardParams === void 0) {
          forwardParams = {};
        }
        return __awaiter2(this, void 0, void 0, function() {
          var params, inputCanvas, stats, tsTotal, imgTensor, onReturn, _a2, height, width, _b, minFaceSize, scaleFactor, maxNumScales, scoreThresholds, scaleSteps, scales, ts2, out1, out2, out3, results;
          return __generator(this, function(_c6) {
            switch (_c6.label) {
              case 0:
                params = this.params;
                if (!params) {
                  throw new Error("Mtcnn - load model before inference");
                }
                inputCanvas = input2.canvases[0];
                if (!inputCanvas) {
                  throw new Error("Mtcnn - inputCanvas is not defined, note that passing tensors into Mtcnn.forwardInput is not supported yet.");
                }
                stats = {};
                tsTotal = Date.now();
                imgTensor = Ze(function() {
                  return bgrToRgbTensor(wr(id.fromPixels(inputCanvas)).toFloat());
                });
                onReturn = function(results2) {
                  imgTensor.dispose();
                  stats.total = Date.now() - tsTotal;
                  return results2;
                };
                _a2 = imgTensor.shape.slice(1), height = _a2[0], width = _a2[1];
                _b = new MtcnnOptions(forwardParams), minFaceSize = _b.minFaceSize, scaleFactor = _b.scaleFactor, maxNumScales = _b.maxNumScales, scoreThresholds = _b.scoreThresholds, scaleSteps = _b.scaleSteps;
                scales = (scaleSteps || pyramidDown(minFaceSize, scaleFactor, [height, width])).filter(function(scale2) {
                  var sizes = getSizesForScale(scale2, [height, width]);
                  return Math.min(sizes.width, sizes.height) > CELL_SIZE;
                }).slice(0, maxNumScales);
                stats.scales = scales;
                stats.pyramid = scales.map(function(scale2) {
                  return getSizesForScale(scale2, [height, width]);
                });
                ts2 = Date.now();
                return [4, stage1(imgTensor, scales, scoreThresholds[0], params.pnet, stats)];
              case 1:
                out1 = _c6.sent();
                stats.total_stage1 = Date.now() - ts2;
                if (!out1.boxes.length) {
                  return [2, onReturn({ results: [], stats })];
                }
                stats.stage2_numInputBoxes = out1.boxes.length;
                ts2 = Date.now();
                return [4, stage2(inputCanvas, out1.boxes, scoreThresholds[1], params.rnet, stats)];
              case 2:
                out2 = _c6.sent();
                stats.total_stage2 = Date.now() - ts2;
                if (!out2.boxes.length) {
                  return [2, onReturn({ results: [], stats })];
                }
                stats.stage3_numInputBoxes = out2.boxes.length;
                ts2 = Date.now();
                return [4, stage3(inputCanvas, out2.boxes, scoreThresholds[2], params.onet, stats)];
              case 3:
                out3 = _c6.sent();
                stats.total_stage3 = Date.now() - ts2;
                results = out3.boxes.map(function(box, idx) {
                  return extendWithFaceLandmarks(extendWithFaceDetection({}, new FaceDetection(out3.scores[idx], new Rect(box.left / width, box.top / height, box.width / width, box.height / height), {
                    height,
                    width
                  })), new FaceLandmarks5(out3.points[idx].map(function(pt2) {
                    return pt2.sub(new Point(box.left, box.top)).div(new Point(box.width, box.height));
                  }), { width: box.width, height: box.height }));
                });
                return [2, onReturn({ results, stats })];
            }
          });
        });
      };
      Mtcnn2.prototype.forward = function(input2, forwardParams) {
        if (forwardParams === void 0) {
          forwardParams = {};
        }
        return __awaiter2(this, void 0, void 0, function() {
          var _a2;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _a2 = this.forwardInput;
                return [4, toNetInput(input2)];
              case 1:
                return [4, _a2.apply(this, [
                  _b.sent(),
                  forwardParams
                ])];
              case 2:
                return [2, _b.sent().results];
            }
          });
        });
      };
      Mtcnn2.prototype.forwardWithStats = function(input2, forwardParams) {
        if (forwardParams === void 0) {
          forwardParams = {};
        }
        return __awaiter2(this, void 0, void 0, function() {
          var _a2;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _a2 = this.forwardInput;
                return [4, toNetInput(input2)];
              case 1:
                return [2, _a2.apply(this, [
                  _b.sent(),
                  forwardParams
                ])];
            }
          });
        });
      };
      Mtcnn2.prototype.getDefaultModelName = function() {
        return "mtcnn_model";
      };
      Mtcnn2.prototype.extractParamsFromWeigthMap = function(weightMap) {
        return extractParamsFromWeigthMap8(weightMap);
      };
      Mtcnn2.prototype.extractParams = function(weights) {
        return extractParams8(weights);
      };
      return Mtcnn2;
    }(NeuralNetwork);
  }
});

// node_modules/face-api.js/build/es6/tinyFaceDetector/const.js
var IOU_THRESHOLD2, BOX_ANCHORS2, MEAN_RGB;
var init_const2 = __esm({
  "node_modules/face-api.js/build/es6/tinyFaceDetector/const.js"() {
    "use strict";
    init_classes();
    IOU_THRESHOLD2 = 0.4;
    BOX_ANCHORS2 = [
      new Point(1.603231, 2.094468),
      new Point(6.041143, 7.080126),
      new Point(2.882459, 3.518061),
      new Point(4.266906, 5.178857),
      new Point(9.041765, 10.66308)
    ];
    MEAN_RGB = [117.001, 114.697, 97.404];
  }
});

// node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetector.js
var TinyFaceDetector;
var init_TinyFaceDetector = __esm({
  "node_modules/face-api.js/build/es6/tinyFaceDetector/TinyFaceDetector.js"() {
    "use strict";
    init_tslib_es62();
    init_classes();
    init_TinyYolov2Base();
    init_const2();
    TinyFaceDetector = /** @class */
    function(_super) {
      __extends(TinyFaceDetector2, _super);
      function TinyFaceDetector2() {
        var _this = this;
        var config2 = {
          withSeparableConvs: true,
          iouThreshold: IOU_THRESHOLD2,
          classes: ["face"],
          anchors: BOX_ANCHORS2,
          meanRgb: MEAN_RGB,
          isFirstLayerConv2d: true,
          filterSizes: [3, 16, 32, 64, 128, 256, 512]
        };
        _this = _super.call(this, config2) || this;
        return _this;
      }
      Object.defineProperty(TinyFaceDetector2.prototype, "anchors", {
        get: function() {
          return this.config.anchors;
        },
        enumerable: true,
        configurable: true
      });
      TinyFaceDetector2.prototype.locateFaces = function(input2, forwardParams) {
        return __awaiter2(this, void 0, void 0, function() {
          var objectDetections;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.detect(input2, forwardParams)];
              case 1:
                objectDetections = _a2.sent();
                return [2, objectDetections.map(function(det) {
                  return new FaceDetection(det.score, det.relativeBox, { width: det.imageWidth, height: det.imageHeight });
                })];
            }
          });
        });
      };
      TinyFaceDetector2.prototype.getDefaultModelName = function() {
        return "tiny_face_detector_model";
      };
      TinyFaceDetector2.prototype.extractParamsFromWeigthMap = function(weightMap) {
        return _super.prototype.extractParamsFromWeigthMap.call(this, weightMap);
      };
      return TinyFaceDetector2;
    }(TinyYolov2Base);
  }
});

// node_modules/face-api.js/build/es6/globalApi/nets.js
var nets;
var init_nets = __esm({
  "node_modules/face-api.js/build/es6/globalApi/nets.js"() {
    "use strict";
    init_AgeGenderNet();
    init_FaceExpressionNet();
    init_FaceLandmark68Net();
    init_FaceLandmark68TinyNet();
    init_FaceRecognitionNet();
    init_Mtcnn();
    init_SsdMobilenetv1();
    init_TinyFaceDetector();
    init_tinyYolov2();
    nets = {
      ssdMobilenetv1: new SsdMobilenetv1(),
      tinyFaceDetector: new TinyFaceDetector(),
      tinyYolov2: new TinyYolov2(),
      mtcnn: new Mtcnn(),
      faceLandmark68Net: new FaceLandmark68Net(),
      faceLandmark68TinyNet: new FaceLandmark68TinyNet(),
      faceRecognitionNet: new FaceRecognitionNet(),
      faceExpressionNet: new FaceExpressionNet(),
      ageGenderNet: new AgeGenderNet()
    };
  }
});

// node_modules/face-api.js/build/es6/globalApi/PredictFaceExpressionsTask.js
var PredictFaceExpressionsTaskBase, PredictAllFaceExpressionsTask, PredictSingleFaceExpressionsTask, PredictAllFaceExpressionsWithFaceAlignmentTask, PredictSingleFaceExpressionsWithFaceAlignmentTask;
var init_PredictFaceExpressionsTask = __esm({
  "node_modules/face-api.js/build/es6/globalApi/PredictFaceExpressionsTask.js"() {
    "use strict";
    init_tslib_es62();
    init_WithFaceExpressions();
    init_ComposableTask();
    init_ComputeFaceDescriptorsTasks();
    init_extractFacesAndComputeResults();
    init_nets();
    init_PredictAgeAndGenderTask();
    PredictFaceExpressionsTaskBase = /** @class */
    function(_super) {
      __extends(PredictFaceExpressionsTaskBase2, _super);
      function PredictFaceExpressionsTaskBase2(parentTask, input2, extractedFaces) {
        var _this = _super.call(this) || this;
        _this.parentTask = parentTask;
        _this.input = input2;
        _this.extractedFaces = extractedFaces;
        return _this;
      }
      return PredictFaceExpressionsTaskBase2;
    }(ComposableTask);
    PredictAllFaceExpressionsTask = /** @class */
    function(_super) {
      __extends(PredictAllFaceExpressionsTask2, _super);
      function PredictAllFaceExpressionsTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PredictAllFaceExpressionsTask2.prototype.run = function() {
        return __awaiter2(this, void 0, void 0, function() {
          var parentResults, faceExpressionsByFace;
          var _this = this;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.parentTask];
              case 1:
                parentResults = _a2.sent();
                return [4, extractAllFacesAndComputeResults(parentResults, this.input, function(faces) {
                  return __awaiter2(_this, void 0, void 0, function() {
                    return __generator(this, function(_a3) {
                      switch (_a3.label) {
                        case 0:
                          return [4, Promise.all(faces.map(function(face) {
                            return nets.faceExpressionNet.predictExpressions(face);
                          }))];
                        case 1:
                          return [2, _a3.sent()];
                      }
                    });
                  });
                }, this.extractedFaces)];
              case 2:
                faceExpressionsByFace = _a2.sent();
                return [2, parentResults.map(function(parentResult, i2) {
                  return extendWithFaceExpressions(parentResult, faceExpressionsByFace[i2]);
                })];
            }
          });
        });
      };
      PredictAllFaceExpressionsTask2.prototype.withAgeAndGender = function() {
        return new PredictAllAgeAndGenderTask(this, this.input);
      };
      return PredictAllFaceExpressionsTask2;
    }(PredictFaceExpressionsTaskBase);
    PredictSingleFaceExpressionsTask = /** @class */
    function(_super) {
      __extends(PredictSingleFaceExpressionsTask2, _super);
      function PredictSingleFaceExpressionsTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PredictSingleFaceExpressionsTask2.prototype.run = function() {
        return __awaiter2(this, void 0, void 0, function() {
          var parentResult, faceExpressions;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.parentTask];
              case 1:
                parentResult = _a2.sent();
                if (!parentResult) {
                  return [
                    2
                    /*return*/
                  ];
                }
                return [4, extractSingleFaceAndComputeResult(parentResult, this.input, function(face) {
                  return nets.faceExpressionNet.predictExpressions(face);
                }, this.extractedFaces)];
              case 2:
                faceExpressions = _a2.sent();
                return [2, extendWithFaceExpressions(parentResult, faceExpressions)];
            }
          });
        });
      };
      PredictSingleFaceExpressionsTask2.prototype.withAgeAndGender = function() {
        return new PredictSingleAgeAndGenderTask(this, this.input);
      };
      return PredictSingleFaceExpressionsTask2;
    }(PredictFaceExpressionsTaskBase);
    PredictAllFaceExpressionsWithFaceAlignmentTask = /** @class */
    function(_super) {
      __extends(PredictAllFaceExpressionsWithFaceAlignmentTask2, _super);
      function PredictAllFaceExpressionsWithFaceAlignmentTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PredictAllFaceExpressionsWithFaceAlignmentTask2.prototype.withAgeAndGender = function() {
        return new PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input);
      };
      PredictAllFaceExpressionsWithFaceAlignmentTask2.prototype.withFaceDescriptors = function() {
        return new ComputeAllFaceDescriptorsTask(this, this.input);
      };
      return PredictAllFaceExpressionsWithFaceAlignmentTask2;
    }(PredictAllFaceExpressionsTask);
    PredictSingleFaceExpressionsWithFaceAlignmentTask = /** @class */
    function(_super) {
      __extends(PredictSingleFaceExpressionsWithFaceAlignmentTask2, _super);
      function PredictSingleFaceExpressionsWithFaceAlignmentTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PredictSingleFaceExpressionsWithFaceAlignmentTask2.prototype.withAgeAndGender = function() {
        return new PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input);
      };
      PredictSingleFaceExpressionsWithFaceAlignmentTask2.prototype.withFaceDescriptor = function() {
        return new ComputeSingleFaceDescriptorTask(this, this.input);
      };
      return PredictSingleFaceExpressionsWithFaceAlignmentTask2;
    }(PredictSingleFaceExpressionsTask);
  }
});

// node_modules/face-api.js/build/es6/globalApi/PredictAgeAndGenderTask.js
var PredictAgeAndGenderTaskBase, PredictAllAgeAndGenderTask, PredictSingleAgeAndGenderTask, PredictAllAgeAndGenderWithFaceAlignmentTask, PredictSingleAgeAndGenderWithFaceAlignmentTask;
var init_PredictAgeAndGenderTask = __esm({
  "node_modules/face-api.js/build/es6/globalApi/PredictAgeAndGenderTask.js"() {
    "use strict";
    init_tslib_es62();
    init_WithAge();
    init_WithGender();
    init_ComposableTask();
    init_ComputeFaceDescriptorsTasks();
    init_extractFacesAndComputeResults();
    init_nets();
    init_PredictFaceExpressionsTask();
    PredictAgeAndGenderTaskBase = /** @class */
    function(_super) {
      __extends(PredictAgeAndGenderTaskBase2, _super);
      function PredictAgeAndGenderTaskBase2(parentTask, input2, extractedFaces) {
        var _this = _super.call(this) || this;
        _this.parentTask = parentTask;
        _this.input = input2;
        _this.extractedFaces = extractedFaces;
        return _this;
      }
      return PredictAgeAndGenderTaskBase2;
    }(ComposableTask);
    PredictAllAgeAndGenderTask = /** @class */
    function(_super) {
      __extends(PredictAllAgeAndGenderTask2, _super);
      function PredictAllAgeAndGenderTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PredictAllAgeAndGenderTask2.prototype.run = function() {
        return __awaiter2(this, void 0, void 0, function() {
          var parentResults, ageAndGenderByFace;
          var _this = this;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.parentTask];
              case 1:
                parentResults = _a2.sent();
                return [4, extractAllFacesAndComputeResults(parentResults, this.input, function(faces) {
                  return __awaiter2(_this, void 0, void 0, function() {
                    return __generator(this, function(_a3) {
                      switch (_a3.label) {
                        case 0:
                          return [4, Promise.all(faces.map(function(face) {
                            return nets.ageGenderNet.predictAgeAndGender(face);
                          }))];
                        case 1:
                          return [2, _a3.sent()];
                      }
                    });
                  });
                }, this.extractedFaces)];
              case 2:
                ageAndGenderByFace = _a2.sent();
                return [2, parentResults.map(function(parentResult, i2) {
                  var _a3 = ageAndGenderByFace[i2], age = _a3.age, gender = _a3.gender, genderProbability = _a3.genderProbability;
                  return extendWithAge(extendWithGender(parentResult, gender, genderProbability), age);
                })];
            }
          });
        });
      };
      PredictAllAgeAndGenderTask2.prototype.withFaceExpressions = function() {
        return new PredictAllFaceExpressionsTask(this, this.input);
      };
      return PredictAllAgeAndGenderTask2;
    }(PredictAgeAndGenderTaskBase);
    PredictSingleAgeAndGenderTask = /** @class */
    function(_super) {
      __extends(PredictSingleAgeAndGenderTask2, _super);
      function PredictSingleAgeAndGenderTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PredictSingleAgeAndGenderTask2.prototype.run = function() {
        return __awaiter2(this, void 0, void 0, function() {
          var parentResult, _a2, age, gender, genderProbability;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this.parentTask];
              case 1:
                parentResult = _b.sent();
                if (!parentResult) {
                  return [
                    2
                    /*return*/
                  ];
                }
                return [4, extractSingleFaceAndComputeResult(parentResult, this.input, function(face) {
                  return nets.ageGenderNet.predictAgeAndGender(face);
                }, this.extractedFaces)];
              case 2:
                _a2 = _b.sent(), age = _a2.age, gender = _a2.gender, genderProbability = _a2.genderProbability;
                return [2, extendWithAge(extendWithGender(parentResult, gender, genderProbability), age)];
            }
          });
        });
      };
      PredictSingleAgeAndGenderTask2.prototype.withFaceExpressions = function() {
        return new PredictSingleFaceExpressionsTask(this, this.input);
      };
      return PredictSingleAgeAndGenderTask2;
    }(PredictAgeAndGenderTaskBase);
    PredictAllAgeAndGenderWithFaceAlignmentTask = /** @class */
    function(_super) {
      __extends(PredictAllAgeAndGenderWithFaceAlignmentTask2, _super);
      function PredictAllAgeAndGenderWithFaceAlignmentTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PredictAllAgeAndGenderWithFaceAlignmentTask2.prototype.withFaceExpressions = function() {
        return new PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input);
      };
      PredictAllAgeAndGenderWithFaceAlignmentTask2.prototype.withFaceDescriptors = function() {
        return new ComputeAllFaceDescriptorsTask(this, this.input);
      };
      return PredictAllAgeAndGenderWithFaceAlignmentTask2;
    }(PredictAllAgeAndGenderTask);
    PredictSingleAgeAndGenderWithFaceAlignmentTask = /** @class */
    function(_super) {
      __extends(PredictSingleAgeAndGenderWithFaceAlignmentTask2, _super);
      function PredictSingleAgeAndGenderWithFaceAlignmentTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PredictSingleAgeAndGenderWithFaceAlignmentTask2.prototype.withFaceExpressions = function() {
        return new PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input);
      };
      PredictSingleAgeAndGenderWithFaceAlignmentTask2.prototype.withFaceDescriptor = function() {
        return new ComputeSingleFaceDescriptorTask(this, this.input);
      };
      return PredictSingleAgeAndGenderWithFaceAlignmentTask2;
    }(PredictSingleAgeAndGenderTask);
  }
});

// node_modules/face-api.js/build/es6/globalApi/ComputeFaceDescriptorsTasks.js
var ComputeFaceDescriptorsTaskBase, ComputeAllFaceDescriptorsTask, ComputeSingleFaceDescriptorTask;
var init_ComputeFaceDescriptorsTasks = __esm({
  "node_modules/face-api.js/build/es6/globalApi/ComputeFaceDescriptorsTasks.js"() {
    "use strict";
    init_tslib_es62();
    init_WithFaceDescriptor();
    init_ComposableTask();
    init_extractFacesAndComputeResults();
    init_nets();
    init_PredictAgeAndGenderTask();
    init_PredictFaceExpressionsTask();
    ComputeFaceDescriptorsTaskBase = /** @class */
    function(_super) {
      __extends(ComputeFaceDescriptorsTaskBase2, _super);
      function ComputeFaceDescriptorsTaskBase2(parentTask, input2) {
        var _this = _super.call(this) || this;
        _this.parentTask = parentTask;
        _this.input = input2;
        return _this;
      }
      return ComputeFaceDescriptorsTaskBase2;
    }(ComposableTask);
    ComputeAllFaceDescriptorsTask = /** @class */
    function(_super) {
      __extends(ComputeAllFaceDescriptorsTask2, _super);
      function ComputeAllFaceDescriptorsTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ComputeAllFaceDescriptorsTask2.prototype.run = function() {
        return __awaiter2(this, void 0, void 0, function() {
          var parentResults, descriptors;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.parentTask];
              case 1:
                parentResults = _a2.sent();
                return [4, extractAllFacesAndComputeResults(parentResults, this.input, function(faces) {
                  return Promise.all(faces.map(function(face) {
                    return nets.faceRecognitionNet.computeFaceDescriptor(face);
                  }));
                }, null, function(parentResult) {
                  return parentResult.landmarks.align(null, { useDlibAlignment: true });
                })];
              case 2:
                descriptors = _a2.sent();
                return [2, descriptors.map(function(descriptor, i2) {
                  return extendWithFaceDescriptor(parentResults[i2], descriptor);
                })];
            }
          });
        });
      };
      ComputeAllFaceDescriptorsTask2.prototype.withFaceExpressions = function() {
        return new PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input);
      };
      ComputeAllFaceDescriptorsTask2.prototype.withAgeAndGender = function() {
        return new PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input);
      };
      return ComputeAllFaceDescriptorsTask2;
    }(ComputeFaceDescriptorsTaskBase);
    ComputeSingleFaceDescriptorTask = /** @class */
    function(_super) {
      __extends(ComputeSingleFaceDescriptorTask2, _super);
      function ComputeSingleFaceDescriptorTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ComputeSingleFaceDescriptorTask2.prototype.run = function() {
        return __awaiter2(this, void 0, void 0, function() {
          var parentResult, descriptor;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.parentTask];
              case 1:
                parentResult = _a2.sent();
                if (!parentResult) {
                  return [
                    2
                    /*return*/
                  ];
                }
                return [4, extractSingleFaceAndComputeResult(parentResult, this.input, function(face) {
                  return nets.faceRecognitionNet.computeFaceDescriptor(face);
                }, null, function(parentResult2) {
                  return parentResult2.landmarks.align(null, { useDlibAlignment: true });
                })];
              case 2:
                descriptor = _a2.sent();
                return [2, extendWithFaceDescriptor(parentResult, descriptor)];
            }
          });
        });
      };
      ComputeSingleFaceDescriptorTask2.prototype.withFaceExpressions = function() {
        return new PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input);
      };
      ComputeSingleFaceDescriptorTask2.prototype.withAgeAndGender = function() {
        return new PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input);
      };
      return ComputeSingleFaceDescriptorTask2;
    }(ComputeFaceDescriptorsTaskBase);
  }
});

// node_modules/face-api.js/build/es6/globalApi/DetectFaceLandmarksTasks.js
var DetectFaceLandmarksTaskBase, DetectAllFaceLandmarksTask, DetectSingleFaceLandmarksTask;
var init_DetectFaceLandmarksTasks = __esm({
  "node_modules/face-api.js/build/es6/globalApi/DetectFaceLandmarksTasks.js"() {
    "use strict";
    init_tslib_es62();
    init_tf_core_esm();
    init_dom();
    init_WithFaceLandmarks();
    init_ComposableTask();
    init_ComputeFaceDescriptorsTasks();
    init_nets();
    init_PredictAgeAndGenderTask();
    init_PredictFaceExpressionsTask();
    DetectFaceLandmarksTaskBase = /** @class */
    function(_super) {
      __extends(DetectFaceLandmarksTaskBase2, _super);
      function DetectFaceLandmarksTaskBase2(parentTask, input2, useTinyLandmarkNet) {
        var _this = _super.call(this) || this;
        _this.parentTask = parentTask;
        _this.input = input2;
        _this.useTinyLandmarkNet = useTinyLandmarkNet;
        return _this;
      }
      Object.defineProperty(DetectFaceLandmarksTaskBase2.prototype, "landmarkNet", {
        get: function() {
          return this.useTinyLandmarkNet ? nets.faceLandmark68TinyNet : nets.faceLandmark68Net;
        },
        enumerable: true,
        configurable: true
      });
      return DetectFaceLandmarksTaskBase2;
    }(ComposableTask);
    DetectAllFaceLandmarksTask = /** @class */
    function(_super) {
      __extends(DetectAllFaceLandmarksTask2, _super);
      function DetectAllFaceLandmarksTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      DetectAllFaceLandmarksTask2.prototype.run = function() {
        return __awaiter2(this, void 0, void 0, function() {
          var parentResults, detections, faces, _a2, faceLandmarksByFace;
          var _this = this;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this.parentTask];
              case 1:
                parentResults = _b.sent();
                detections = parentResults.map(function(res) {
                  return res.detection;
                });
                if (!(this.input instanceof wt)) return [3, 3];
                return [4, extractFaceTensors(this.input, detections)];
              case 2:
                _a2 = _b.sent();
                return [3, 5];
              case 3:
                return [4, extractFaces(this.input, detections)];
              case 4:
                _a2 = _b.sent();
                _b.label = 5;
              case 5:
                faces = _a2;
                return [4, Promise.all(faces.map(function(face) {
                  return _this.landmarkNet.detectLandmarks(face);
                }))];
              case 6:
                faceLandmarksByFace = _b.sent();
                faces.forEach(function(f2) {
                  return f2 instanceof wt && f2.dispose();
                });
                return [2, parentResults.map(function(parentResult, i2) {
                  return extendWithFaceLandmarks(parentResult, faceLandmarksByFace[i2]);
                })];
            }
          });
        });
      };
      DetectAllFaceLandmarksTask2.prototype.withFaceExpressions = function() {
        return new PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input);
      };
      DetectAllFaceLandmarksTask2.prototype.withAgeAndGender = function() {
        return new PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input);
      };
      DetectAllFaceLandmarksTask2.prototype.withFaceDescriptors = function() {
        return new ComputeAllFaceDescriptorsTask(this, this.input);
      };
      return DetectAllFaceLandmarksTask2;
    }(DetectFaceLandmarksTaskBase);
    DetectSingleFaceLandmarksTask = /** @class */
    function(_super) {
      __extends(DetectSingleFaceLandmarksTask2, _super);
      function DetectSingleFaceLandmarksTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      DetectSingleFaceLandmarksTask2.prototype.run = function() {
        return __awaiter2(this, void 0, void 0, function() {
          var parentResult, detection, faces, _a2, landmarks;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this.parentTask];
              case 1:
                parentResult = _b.sent();
                if (!parentResult) {
                  return [
                    2
                    /*return*/
                  ];
                }
                detection = parentResult.detection;
                if (!(this.input instanceof wt)) return [3, 3];
                return [4, extractFaceTensors(this.input, [detection])];
              case 2:
                _a2 = _b.sent();
                return [3, 5];
              case 3:
                return [4, extractFaces(this.input, [detection])];
              case 4:
                _a2 = _b.sent();
                _b.label = 5;
              case 5:
                faces = _a2;
                return [4, this.landmarkNet.detectLandmarks(faces[0])];
              case 6:
                landmarks = _b.sent();
                faces.forEach(function(f2) {
                  return f2 instanceof wt && f2.dispose();
                });
                return [2, extendWithFaceLandmarks(parentResult, landmarks)];
            }
          });
        });
      };
      DetectSingleFaceLandmarksTask2.prototype.withFaceExpressions = function() {
        return new PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input);
      };
      DetectSingleFaceLandmarksTask2.prototype.withAgeAndGender = function() {
        return new PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input);
      };
      DetectSingleFaceLandmarksTask2.prototype.withFaceDescriptor = function() {
        return new ComputeSingleFaceDescriptorTask(this, this.input);
      };
      return DetectSingleFaceLandmarksTask2;
    }(DetectFaceLandmarksTaskBase);
  }
});

// node_modules/face-api.js/build/es6/globalApi/DetectFacesTasks.js
var DetectFacesTaskBase, DetectAllFacesTask, DetectSingleFaceTask;
var init_DetectFacesTasks = __esm({
  "node_modules/face-api.js/build/es6/globalApi/DetectFacesTasks.js"() {
    "use strict";
    init_tslib_es62();
    init_WithFaceDetection();
    init_MtcnnOptions();
    init_SsdMobilenetv1Options();
    init_TinyFaceDetectorOptions();
    init_tinyYolov2();
    init_ComposableTask();
    init_DetectFaceLandmarksTasks();
    init_nets();
    init_PredictAgeAndGenderTask();
    init_PredictFaceExpressionsTask();
    DetectFacesTaskBase = /** @class */
    function(_super) {
      __extends(DetectFacesTaskBase2, _super);
      function DetectFacesTaskBase2(input2, options) {
        if (options === void 0) {
          options = new SsdMobilenetv1Options();
        }
        var _this = _super.call(this) || this;
        _this.input = input2;
        _this.options = options;
        return _this;
      }
      return DetectFacesTaskBase2;
    }(ComposableTask);
    DetectAllFacesTask = /** @class */
    function(_super) {
      __extends(DetectAllFacesTask2, _super);
      function DetectAllFacesTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      DetectAllFacesTask2.prototype.run = function() {
        return __awaiter2(this, void 0, void 0, function() {
          var _a2, input2, options, faceDetectionFunction;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _a2 = this, input2 = _a2.input, options = _a2.options;
                if (!(options instanceof MtcnnOptions)) return [3, 2];
                return [4, nets.mtcnn.forward(input2, options)];
              case 1:
                return [2, _b.sent().map(function(result) {
                  return result.detection;
                })];
              case 2:
                faceDetectionFunction = options instanceof TinyFaceDetectorOptions ? function(input3) {
                  return nets.tinyFaceDetector.locateFaces(input3, options);
                } : options instanceof SsdMobilenetv1Options ? function(input3) {
                  return nets.ssdMobilenetv1.locateFaces(input3, options);
                } : options instanceof TinyYolov2Options ? function(input3) {
                  return nets.tinyYolov2.locateFaces(input3, options);
                } : null;
                if (!faceDetectionFunction) {
                  throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | MtcnnOptions | TinyYolov2Options");
                }
                return [2, faceDetectionFunction(input2)];
            }
          });
        });
      };
      DetectAllFacesTask2.prototype.runAndExtendWithFaceDetections = function() {
        var _this = this;
        return new Promise(function(res) {
          return __awaiter2(_this, void 0, void 0, function() {
            var detections;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.run()];
                case 1:
                  detections = _a2.sent();
                  return [2, res(detections.map(function(detection) {
                    return extendWithFaceDetection({}, detection);
                  }))];
              }
            });
          });
        });
      };
      DetectAllFacesTask2.prototype.withFaceLandmarks = function(useTinyLandmarkNet) {
        if (useTinyLandmarkNet === void 0) {
          useTinyLandmarkNet = false;
        }
        return new DetectAllFaceLandmarksTask(this.runAndExtendWithFaceDetections(), this.input, useTinyLandmarkNet);
      };
      DetectAllFacesTask2.prototype.withFaceExpressions = function() {
        return new PredictAllFaceExpressionsTask(this.runAndExtendWithFaceDetections(), this.input);
      };
      DetectAllFacesTask2.prototype.withAgeAndGender = function() {
        return new PredictAllAgeAndGenderTask(this.runAndExtendWithFaceDetections(), this.input);
      };
      return DetectAllFacesTask2;
    }(DetectFacesTaskBase);
    DetectSingleFaceTask = /** @class */
    function(_super) {
      __extends(DetectSingleFaceTask2, _super);
      function DetectSingleFaceTask2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      DetectSingleFaceTask2.prototype.run = function() {
        return __awaiter2(this, void 0, void 0, function() {
          var faceDetections, faceDetectionWithHighestScore;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, new DetectAllFacesTask(this.input, this.options)];
              case 1:
                faceDetections = _a2.sent();
                faceDetectionWithHighestScore = faceDetections[0];
                faceDetections.forEach(function(faceDetection) {
                  if (faceDetection.score > faceDetectionWithHighestScore.score) {
                    faceDetectionWithHighestScore = faceDetection;
                  }
                });
                return [2, faceDetectionWithHighestScore];
            }
          });
        });
      };
      DetectSingleFaceTask2.prototype.runAndExtendWithFaceDetection = function() {
        var _this = this;
        return new Promise(function(res) {
          return __awaiter2(_this, void 0, void 0, function() {
            var detection;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  return [4, this.run()];
                case 1:
                  detection = _a2.sent();
                  return [2, res(detection ? extendWithFaceDetection({}, detection) : void 0)];
              }
            });
          });
        });
      };
      DetectSingleFaceTask2.prototype.withFaceLandmarks = function(useTinyLandmarkNet) {
        if (useTinyLandmarkNet === void 0) {
          useTinyLandmarkNet = false;
        }
        return new DetectSingleFaceLandmarksTask(this.runAndExtendWithFaceDetection(), this.input, useTinyLandmarkNet);
      };
      DetectSingleFaceTask2.prototype.withFaceExpressions = function() {
        return new PredictSingleFaceExpressionsTask(this.runAndExtendWithFaceDetection(), this.input);
      };
      DetectSingleFaceTask2.prototype.withAgeAndGender = function() {
        return new PredictSingleAgeAndGenderTask(this.runAndExtendWithFaceDetection(), this.input);
      };
      return DetectSingleFaceTask2;
    }(DetectFacesTaskBase);
  }
});

// node_modules/face-api.js/build/es6/globalApi/detectFaces.js
function detectAllFaces(input2, options) {
  if (options === void 0) {
    options = new SsdMobilenetv1Options();
  }
  return new DetectAllFacesTask(input2, options);
}
var init_detectFaces = __esm({
  "node_modules/face-api.js/build/es6/globalApi/detectFaces.js"() {
    "use strict";
    init_SsdMobilenetv1Options();
    init_DetectFacesTasks();
  }
});

// node_modules/face-api.js/build/es6/globalApi/allFaces.js
var init_allFaces = __esm({
  "node_modules/face-api.js/build/es6/globalApi/allFaces.js"() {
    "use strict";
    init_MtcnnOptions();
    init_ssdMobilenetv1();
    init_tinyYolov2();
    init_detectFaces();
  }
});

// node_modules/face-api.js/build/es6/euclideanDistance.js
function euclideanDistance(arr1, arr2) {
  if (arr1.length !== arr2.length)
    throw new Error("euclideanDistance: arr1.length !== arr2.length");
  var desc1 = Array.from(arr1);
  var desc2 = Array.from(arr2);
  return Math.sqrt(desc1.map(function(val, i2) {
    return val - desc2[i2];
  }).reduce(function(res, diff) {
    return res + Math.pow(diff, 2);
  }, 0));
}
var init_euclideanDistance = __esm({
  "node_modules/face-api.js/build/es6/euclideanDistance.js"() {
    "use strict";
  }
});

// node_modules/face-api.js/build/es6/globalApi/FaceMatcher.js
var FaceMatcher;
var init_FaceMatcher = __esm({
  "node_modules/face-api.js/build/es6/globalApi/FaceMatcher.js"() {
    "use strict";
    init_FaceMatch();
    init_LabeledFaceDescriptors();
    init_euclideanDistance();
    FaceMatcher = /** @class */
    function() {
      function FaceMatcher2(inputs, distanceThreshold) {
        if (distanceThreshold === void 0) {
          distanceThreshold = 0.6;
        }
        this._distanceThreshold = distanceThreshold;
        var inputArray = Array.isArray(inputs) ? inputs : [inputs];
        if (!inputArray.length) {
          throw new Error("FaceRecognizer.constructor - expected atleast one input");
        }
        var count = 1;
        var createUniqueLabel = function() {
          return "person " + count++;
        };
        this._labeledDescriptors = inputArray.map(function(desc) {
          if (desc instanceof LabeledFaceDescriptors) {
            return desc;
          }
          if (desc instanceof Float32Array) {
            return new LabeledFaceDescriptors(createUniqueLabel(), [desc]);
          }
          if (desc.descriptor && desc.descriptor instanceof Float32Array) {
            return new LabeledFaceDescriptors(createUniqueLabel(), [desc.descriptor]);
          }
          throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>");
        });
      }
      Object.defineProperty(FaceMatcher2.prototype, "labeledDescriptors", {
        get: function() {
          return this._labeledDescriptors;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(FaceMatcher2.prototype, "distanceThreshold", {
        get: function() {
          return this._distanceThreshold;
        },
        enumerable: true,
        configurable: true
      });
      FaceMatcher2.prototype.computeMeanDistance = function(queryDescriptor, descriptors) {
        return descriptors.map(function(d2) {
          return euclideanDistance(d2, queryDescriptor);
        }).reduce(function(d1, d2) {
          return d1 + d2;
        }, 0) / (descriptors.length || 1);
      };
      FaceMatcher2.prototype.matchDescriptor = function(queryDescriptor) {
        var _this = this;
        return this.labeledDescriptors.map(function(_a2) {
          var descriptors = _a2.descriptors, label = _a2.label;
          return new FaceMatch(label, _this.computeMeanDistance(queryDescriptor, descriptors));
        }).reduce(function(best, curr) {
          return best.distance < curr.distance ? best : curr;
        });
      };
      FaceMatcher2.prototype.findBestMatch = function(queryDescriptor) {
        var bestMatch = this.matchDescriptor(queryDescriptor);
        return bestMatch.distance < this.distanceThreshold ? bestMatch : new FaceMatch("unknown", bestMatch.distance);
      };
      FaceMatcher2.prototype.toJSON = function() {
        return {
          distanceThreshold: this.distanceThreshold,
          labeledDescriptors: this.labeledDescriptors.map(function(ld2) {
            return ld2.toJSON();
          })
        };
      };
      FaceMatcher2.fromJSON = function(json) {
        var labeledDescriptors = json.labeledDescriptors.map(function(ld2) {
          return LabeledFaceDescriptors.fromJSON(ld2);
        });
        return new FaceMatcher2(labeledDescriptors, json.distanceThreshold);
      };
      return FaceMatcher2;
    }();
  }
});

// node_modules/face-api.js/build/es6/globalApi/index.js
var init_globalApi = __esm({
  "node_modules/face-api.js/build/es6/globalApi/index.js"() {
    "use strict";
    init_allFaces();
    init_ComposableTask();
    init_ComputeFaceDescriptorsTasks();
    init_detectFaces();
    init_DetectFacesTasks();
    init_DetectFaceLandmarksTasks();
    init_FaceMatcher();
    init_nets();
  }
});

// node_modules/face-api.js/build/es6/mtcnn/index.js
var init_mtcnn = __esm({
  "node_modules/face-api.js/build/es6/mtcnn/index.js"() {
    "use strict";
    init_Mtcnn();
    init_Mtcnn();
    init_MtcnnOptions();
  }
});

// node_modules/face-api.js/build/es6/tinyFaceDetector/index.js
var init_tinyFaceDetector = __esm({
  "node_modules/face-api.js/build/es6/tinyFaceDetector/index.js"() {
    "use strict";
    init_TinyFaceDetector();
    init_TinyFaceDetector();
    init_TinyFaceDetectorOptions();
  }
});

// node_modules/face-api.js/build/es6/resizeResults.js
function resizeResults(results, dimensions) {
  var _a2 = new Dimensions(dimensions.width, dimensions.height), width = _a2.width, height = _a2.height;
  if (width <= 0 || height <= 0) {
    throw new Error("resizeResults - invalid dimensions: " + JSON.stringify({ width, height }));
  }
  if (Array.isArray(results)) {
    return results.map(function(obj) {
      return resizeResults(obj, { width, height });
    });
  }
  if (isWithFaceLandmarks(results)) {
    var resizedDetection = results.detection.forSize(width, height);
    var resizedLandmarks = results.unshiftedLandmarks.forSize(resizedDetection.box.width, resizedDetection.box.height);
    return extendWithFaceLandmarks(extendWithFaceDetection(results, resizedDetection), resizedLandmarks);
  }
  if (isWithFaceDetection(results)) {
    return extendWithFaceDetection(results, results.detection.forSize(width, height));
  }
  if (results instanceof FaceLandmarks || results instanceof FaceDetection) {
    return results.forSize(width, height);
  }
  return results;
}
var init_resizeResults = __esm({
  "node_modules/face-api.js/build/es6/resizeResults.js"() {
    "use strict";
    init_classes();
    init_FaceDetection();
    init_FaceLandmarks();
    init_WithFaceDetection();
    init_WithFaceLandmarks();
  }
});

// node_modules/face-api.js/build/es6/index.js
var init_es6 = __esm({
  "node_modules/face-api.js/build/es6/index.js"() {
    "use strict";
    init_tf_core_esm();
    init_draw();
    init_utils();
    init_ageGenderNet();
    init_classes();
    init_dom();
    init_env();
    init_faceExpressionNet();
    init_faceLandmarkNet();
    init_faceRecognitionNet();
    init_factories();
    init_globalApi();
    init_mtcnn();
    init_ops();
    init_ssdMobilenetv1();
    init_tinyFaceDetector();
    init_tinyYolov2();
    init_euclideanDistance();
    init_NeuralNetwork();
    init_resizeResults();
  }
});

// src/app/dashboard/dashboard.ts
function Dashboard_main_0_Template(rf2, ctx) {
  if (rf2 & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "main")(1, "div", 3)(2, "div", 4)(3, "h2", 5);
    \u0275\u0275text(4, "Join the Room");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "label", 6)(6, "span", 7);
    \u0275\u0275text(7, "Enter your name");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "input", 8);
    \u0275\u0275twoWayListener("ngModelChange", function Dashboard_main_0_Template_input_ngModelChange_8_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.userName, $event) || (ctx_r1.userName = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(9, "label", 9)(10, "input", 10);
    \u0275\u0275twoWayListener("ngModelChange", function Dashboard_main_0_Template_input_ngModelChange_10_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.termsCheckbox, $event) || (ctx_r1.termsCheckbox = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "span", 7);
    \u0275\u0275text(12, "I agree to the Terms & Conditions");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(13, "button", 11);
    \u0275\u0275listener("click", function Dashboard_main_0_Template_button_click_13_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateNameFirst());
    });
    \u0275\u0275text(14, " Join Room ");
    \u0275\u0275elementEnd()()()();
  }
  if (rf2 & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(8);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.userName);
    \u0275\u0275advance(2);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.termsCheckbox);
  }
}
function Dashboard_main_1_div_2_Template(rf2, ctx) {
  if (rf2 & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 41)(1, "div", 42);
    \u0275\u0275text(2, "Room: ");
    \u0275\u0275elementStart(3, "strong");
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(5, "button", 43);
    \u0275\u0275listener("click", function Dashboard_main_1_div_2_Template_button_click_5_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.toggleChat());
    });
    \u0275\u0275element(6, "i", 44);
    \u0275\u0275text(7, " Menu ");
    \u0275\u0275elementEnd()();
  }
  if (rf2 & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1("#", ctx_r1.roomName);
  }
}
function Dashboard_main_1_div_4_div_1_div_3_Template(rf2, ctx) {
  if (rf2 & 1) {
    \u0275\u0275elementStart(0, "div", 53)(1, "div", 54);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf2 & 2) {
    const p_r5 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", p_r5.initials, " ");
  }
}
function Dashboard_main_1_div_4_div_1_Template(rf2, ctx) {
  if (rf2 & 1) {
    \u0275\u0275elementStart(0, "div", 47);
    \u0275\u0275element(1, "video", 48)(2, "canvas", 49);
    \u0275\u0275template(3, Dashboard_main_1_div_4_div_1_div_3_Template, 3, 1, "div", 50);
    \u0275\u0275elementStart(4, "div", 51);
    \u0275\u0275element(5, "span", 52);
    \u0275\u0275text(6);
    \u0275\u0275elementEnd()();
  }
  if (rf2 & 2) {
    const p_r5 = ctx.$implicit;
    \u0275\u0275classProp("video-on", p_r5.videoOn)("hand-raised", p_r5.handRaised);
    \u0275\u0275advance();
    \u0275\u0275property("appSrcObject", p_r5.stream)("muted", !!p_r5.isYou)("hidden", !p_r5.stream || !p_r5.videoOn);
    \u0275\u0275attribute("data-chan", p_r5.channel);
    \u0275\u0275advance();
    \u0275\u0275attribute("data-chan", p_r5.channel);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !p_r5.stream || !p_r5.videoOn);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction2(12, _c5, p_r5.mic === "on", p_r5.mic === "off"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", p_r5.name, " ");
  }
}
function Dashboard_main_1_div_4_Template(rf2, ctx) {
  if (rf2 & 1) {
    \u0275\u0275elementStart(0, "div", 45);
    \u0275\u0275template(1, Dashboard_main_1_div_4_div_1_Template, 7, 15, "div", 46);
    \u0275\u0275elementEnd();
  }
  if (rf2 & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction5(3, _c4, ctx_r1.gridParticipants.length === 1, ctx_r1.gridParticipants.length === 2, ctx_r1.gridParticipants.length === 3, ctx_r1.gridParticipants.length === 4, ctx_r1.gridParticipants.length > 4));
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.gridParticipants)("ngForTrackBy", ctx_r1.trackByParticipant);
  }
}
function Dashboard_main_1_div_30_video_1_Template(rf2, ctx) {
  if (rf2 & 1) {
    \u0275\u0275element(0, "video", 57);
  }
  if (rf2 & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("appSrcObject", ctx_r1.you == null ? null : ctx_r1.you.stream)("muted", true);
  }
}
function Dashboard_main_1_div_30_Template(rf2, ctx) {
  if (rf2 & 1) {
    \u0275\u0275elementStart(0, "div", 55);
    \u0275\u0275template(1, Dashboard_main_1_div_30_video_1_Template, 1, 2, "video", 56);
    \u0275\u0275elementEnd();
  }
  if (rf2 & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.you == null ? null : ctx_r1.you.stream);
  }
}
function Dashboard_main_1_button_46_Template(rf2, ctx) {
  if (rf2 & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 58);
    \u0275\u0275listener("click", function Dashboard_main_1_button_46_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.closeChat());
    });
    \u0275\u0275text(1, "Close");
    \u0275\u0275elementEnd();
  }
}
function Dashboard_main_1_div_48_div_3_span_3_Template(rf2, ctx) {
  if (rf2 & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf2 & 2) {
    const p_r7 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(p_r7.initials);
  }
}
function Dashboard_main_1_div_48_div_3_span_4_Template(rf2, ctx) {
  if (rf2 & 1) {
    \u0275\u0275elementStart(0, "span", 66);
    \u0275\u0275text(1, "\u270B");
    \u0275\u0275elementEnd();
  }
}
function Dashboard_main_1_div_48_div_3_Template(rf2, ctx) {
  if (rf2 & 1) {
    \u0275\u0275elementStart(0, "div", 62)(1, "div", 63)(2, "div", 64);
    \u0275\u0275template(3, Dashboard_main_1_div_48_div_3_span_3_Template, 2, 1, "span", 1)(4, Dashboard_main_1_div_48_div_3_span_4_Template, 2, 0, "span", 65);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "span");
    \u0275\u0275text(6);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "div");
    \u0275\u0275element(8, "i", 19)(9, "i", 19);
    \u0275\u0275elementEnd()();
  }
  if (rf2 & 2) {
    const p_r7 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275classProp("hand-raised", p_r7.handRaised);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !p_r7.handRaised);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", p_r7.handRaised);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(p_r7.name);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngClass", p_r7.mic === "on" ? "ph-microphone" : "ph-microphone-slash");
    \u0275\u0275advance();
    \u0275\u0275property("ngClass", p_r7.cam === "on" ? "ph-video-camera" : "ph-camera-slash");
  }
}
function Dashboard_main_1_div_48_Template(rf2, ctx) {
  if (rf2 & 1) {
    \u0275\u0275elementStart(0, "div", 59)(1, "h3", 60);
    \u0275\u0275text(2, "Participants");
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, Dashboard_main_1_div_48_div_3_Template, 10, 7, "div", 61);
    \u0275\u0275elementEnd();
  }
  if (rf2 & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx_r1.participants);
  }
}
function Dashboard_main_1_div_49_div_3_Template(rf2, ctx) {
  if (rf2 & 1) {
    \u0275\u0275elementStart(0, "div", 71);
    \u0275\u0275text(1, " No suspicious activity detected yet. ");
    \u0275\u0275elementEnd();
  }
}
function Dashboard_main_1_div_49_div_4_Template(rf2, ctx) {
  if (rf2 & 1) {
    \u0275\u0275elementStart(0, "div", 72)(1, "div", 73);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "div", 74);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
  }
  if (rf2 & 2) {
    const e_r8 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(e_r8.time);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(e_r8.message);
  }
}
function Dashboard_main_1_div_49_Template(rf2, ctx) {
  if (rf2 & 1) {
    \u0275\u0275elementStart(0, "div", 67)(1, "h3", 68);
    \u0275\u0275text(2, "Suspicious Activities");
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, Dashboard_main_1_div_49_div_3_Template, 2, 0, "div", 69)(4, Dashboard_main_1_div_49_div_4_Template, 5, 2, "div", 70);
    \u0275\u0275elementEnd();
  }
  if (rf2 & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", ctx_r1.suspiciousEvents.length === 0);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.suspiciousEvents);
  }
}
function Dashboard_main_1_div_50_div_4_Template(rf2, ctx) {
  if (rf2 & 1) {
    \u0275\u0275elementStart(0, "div", 77)(1, "div", 73);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "div", 42);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
  }
  if (rf2 & 2) {
    const m_r9 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(m_r9.by);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(m_r9.text);
  }
}
function Dashboard_main_1_div_50_Template(rf2, ctx) {
  if (rf2 & 1) {
    \u0275\u0275elementStart(0, "div", 75, 0)(2, "h3", 60);
    \u0275\u0275text(3, "Chat");
    \u0275\u0275elementEnd();
    \u0275\u0275template(4, Dashboard_main_1_div_50_div_4_Template, 5, 2, "div", 76);
    \u0275\u0275elementEnd();
  }
  if (rf2 & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngForOf", ctx_r1.chatMessages);
  }
}
function Dashboard_main_1_form_51_Template(rf2, ctx) {
  if (rf2 & 1) {
    const _r10 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "form", 78);
    \u0275\u0275listener("ngSubmit", function Dashboard_main_1_form_51_Template_form_ngSubmit_0_listener() {
      \u0275\u0275restoreView(_r10);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.sendChat());
    });
    \u0275\u0275elementStart(1, "input", 79);
    \u0275\u0275twoWayListener("ngModelChange", function Dashboard_main_1_form_51_Template_input_ngModelChange_1_listener($event) {
      \u0275\u0275restoreView(_r10);
      const ctx_r1 = \u0275\u0275nextContext(2);
      \u0275\u0275twoWayBindingSet(ctx_r1.chatText, $event) || (ctx_r1.chatText = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "button", 80);
    \u0275\u0275text(3, "Send");
    \u0275\u0275elementEnd()();
  }
  if (rf2 & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.chatText);
  }
}
function Dashboard_main_1_Template(rf2, ctx) {
  if (rf2 & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "main", 12)(1, "section", 13);
    \u0275\u0275template(2, Dashboard_main_1_div_2_Template, 8, 1, "div", 14);
    \u0275\u0275elementStart(3, "div", 15);
    \u0275\u0275template(4, Dashboard_main_1_div_4_Template, 2, 9, "div", 16);
    \u0275\u0275elementStart(5, "div", 17)(6, "button", 18);
    \u0275\u0275listener("click", function Dashboard_main_1_Template_button_click_6_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.toggleMic());
    });
    \u0275\u0275element(7, "i", 19);
    \u0275\u0275elementStart(8, "span");
    \u0275\u0275text(9, "Mic");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(10, "button", 18);
    \u0275\u0275listener("click", function Dashboard_main_1_Template_button_click_10_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.toggleCam());
    });
    \u0275\u0275element(11, "i", 19);
    \u0275\u0275elementStart(12, "span");
    \u0275\u0275text(13, "Video");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(14, "button", 18);
    \u0275\u0275listener("click", function Dashboard_main_1_Template_button_click_14_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.shareScreen());
    });
    \u0275\u0275element(15, "i", 20);
    \u0275\u0275elementStart(16, "span");
    \u0275\u0275text(17, "Share");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(18, "button", 18);
    \u0275\u0275listener("click", function Dashboard_main_1_Template_button_click_18_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.raiseHand());
    });
    \u0275\u0275element(19, "i", 21);
    \u0275\u0275elementStart(20, "span");
    \u0275\u0275text(21, "Hand");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(22, "button", 18);
    \u0275\u0275listener("click", function Dashboard_main_1_Template_button_click_22_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.cycleLayout());
    });
    \u0275\u0275element(23, "i", 22);
    \u0275\u0275elementStart(24, "span");
    \u0275\u0275text(25, "Layout");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(26, "button", 23);
    \u0275\u0275listener("click", function Dashboard_main_1_Template_button_click_26_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.leaveCall());
    });
    \u0275\u0275element(27, "i", 24);
    \u0275\u0275elementStart(28, "span");
    \u0275\u0275text(29, "Leave");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275template(30, Dashboard_main_1_div_30_Template, 2, 1, "div", 25);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(31, "aside", 26)(32, "div", 27)(33, "div", 28);
    \u0275\u0275element(34, "i", 29);
    \u0275\u0275elementStart(35, "input", 30);
    \u0275\u0275listener("change", function Dashboard_main_1_Template_input_change_35_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateName($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(36, "label", 31);
    \u0275\u0275text(37, "update display name from here.");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(38, "div", 32)(39, "div", 33)(40, "button", 34);
    \u0275\u0275listener("click", function Dashboard_main_1_Template_button_click_40_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.activeTab = "participants");
    });
    \u0275\u0275text(41, "Participants");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(42, "button", 34);
    \u0275\u0275listener("click", function Dashboard_main_1_Template_button_click_42_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.activeTab = "chat");
    });
    \u0275\u0275text(43, "Chat");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(44, "button", 34);
    \u0275\u0275listener("click", function Dashboard_main_1_Template_button_click_44_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.activeTab = "alerts");
    });
    \u0275\u0275text(45, "Alerts");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(46, Dashboard_main_1_button_46_Template, 2, 0, "button", 35);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(47, "div", 36);
    \u0275\u0275template(48, Dashboard_main_1_div_48_Template, 4, 1, "div", 37)(49, Dashboard_main_1_div_49_Template, 5, 2, "div", 38)(50, Dashboard_main_1_div_50_Template, 5, 1, "div", 39);
    \u0275\u0275elementEnd();
    \u0275\u0275template(51, Dashboard_main_1_form_51_Template, 4, 1, "form", 40);
    \u0275\u0275elementEnd()();
  }
  if (rf2 & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classProp("chat-open", !ctx_r1.chatCollapsed);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", !ctx_r1.isDesktop);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r1.gridParticipants.length > 0);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngClass", (ctx_r1.you == null ? null : ctx_r1.you.mic) === "on" ? "ph-microphone" : "ph-microphone-slash");
    \u0275\u0275advance(4);
    \u0275\u0275property("ngClass", (ctx_r1.you == null ? null : ctx_r1.you.cam) === "on" ? "ph-video-camera" : "ph-camera-slash");
    \u0275\u0275advance(19);
    \u0275\u0275property("ngIf", ctx_r1.shouldShowSelfVideo);
    \u0275\u0275advance();
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction2(20, _c3, ctx_r1.chatCollapsed && !ctx_r1.isDesktop, !ctx_r1.chatCollapsed || ctx_r1.isDesktop));
    \u0275\u0275advance(4);
    \u0275\u0275property("value", (ctx_r1.you == null ? null : ctx_r1.you.name) || "You");
    \u0275\u0275advance(5);
    \u0275\u0275classProp("active", ctx_r1.activeTab === "participants");
    \u0275\u0275advance(2);
    \u0275\u0275classProp("active", ctx_r1.activeTab === "chat");
    \u0275\u0275advance(2);
    \u0275\u0275classProp("active", ctx_r1.activeTab === "alerts");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", !ctx_r1.isDesktop);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r1.activeTab === "participants");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.activeTab === "alerts");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.activeTab === "chat");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.activeTab === "chat");
  }
}
var _c02, _c12, _c2, _c3, _c4, _c5, MediaSrcObjectDirective, Dashboard;
var init_dashboard = __esm({
  "src/app/dashboard/dashboard.ts"() {
    "use strict";
    init_core();
    init_common();
    init_forms();
    init_signaling_service();
    init_src_object_directive();
    init_drag_drop();
    init_es6();
    init_core();
    init_signaling_service();
    init_common();
    init_forms();
    init_drag_drop();
    _c02 = ["chatScroll"];
    _c12 = ["videoTile"];
    _c2 = ["canvasTile"];
    _c3 = (a0, a1) => ({ "translate-x-full": a0, "translate-x-0": a1 });
    _c4 = (a0, a1, a2, a3, a4) => ({ "layout-1": a0, "layout-2": a1, "layout-3": a2, "layout-4": a3, "layout-more": a4 });
    _c5 = (a0, a1) => ({ "bg-green-400": a0, "bg-red-400": a1 });
    MediaSrcObjectDirective = class _MediaSrcObjectDirective {
      el;
      muted = false;
      constructor(el2) {
        this.el = el2;
      }
      set appSrcObject(stream) {
        const media = this.el.nativeElement;
        media.autoplay = true;
        media.playsInline = true;
        media.srcObject = stream ?? null;
        media.muted = this.muted;
        if (stream) {
          media.play().catch((e2) => {
            if (e2?.name === "NotAllowedError") {
              const oneClick = () => {
                media.play().catch(() => {
                });
                document.removeEventListener("click", oneClick);
              };
              document.addEventListener("click", oneClick, { once: true });
            }
          });
        }
      }
      static \u0275fac = function MediaSrcObjectDirective_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _MediaSrcObjectDirective)(\u0275\u0275directiveInject(ElementRef));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({ type: _MediaSrcObjectDirective, selectors: [["video", "appSrcObject", ""], ["audio", "appSrcObject", ""]], inputs: { muted: "muted", appSrcObject: "appSrcObject" } });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MediaSrcObjectDirective, [{
        type: Directive,
        args: [{ selector: "video[appSrcObject],audio[appSrcObject]", standalone: true }]
      }], () => [{ type: ElementRef }], { muted: [{
        type: Input
      }], appSrcObject: [{
        type: Input
      }] });
    })();
    Dashboard = class _Dashboard {
      signaling;
      // ====== UI state ======
      isDesktop = window.innerWidth >= 1024;
      chatCollapsed = true;
      participants = [];
      chatMessages = [];
      chatText = "";
      tileColsManual = null;
      roomName = "testroom";
      activeTab = "chat";
      isNameUpdated = false;
      chatScroll;
      videoTiles;
      canvasTiles;
      // ====== Signaling ======
      signalingSub = null;
      myServerChan = null;
      myPolite = true;
      // ====== Stores ======
      participantsMap = /* @__PURE__ */ new Map();
      // key: channel id; '__you__' for local
      peers = /* @__PURE__ */ new Map();
      // key: remote channel id
      iceQueue = /* @__PURE__ */ new Map();
      // queued ICE per remote channel
      // ====== Local media ======
      localVideoTrack = null;
      localAudioTrack = null;
      localPreviewStream = new MediaStream();
      // stable instance
      userName;
      termsCheckbox;
      // ====== Gaze tracking state ======
      gazeState = {
        baseline: null,
        calibrationFrames: 0,
        maxCalibrationFrames: 60,
        gazeHistory: [],
        maxHistory: 15,
        lastDirection: "",
        consecutiveCount: 0,
        calibrationBuffer: [],
        stdDev: null,
        hysteresisThreshold: 3,
        headPoseHistory: [],
        blinkHistory: [],
        patternHistory: [],
        lastBlinkTime: 0,
        blinkCount: 0,
        rapidMovementCount: 0,
        prolongedAwayCount: 0
      };
      // ====== Derived getters ======
      get you() {
        return this.participantsMap.get("__you__");
      }
      get tileCount() {
        return this.participants.length;
      }
      get tileCols() {
        if (this.tileColsManual)
          return this.tileColsManual;
        return Math.min(4, Math.max(1, Math.ceil(Math.sqrt(this.tileCount || 1))));
      }
      get layoutCount() {
        return this.participants.length;
      }
      get fullParticipant() {
        const remotes = this.participants.filter((p2) => !p2.isYou);
        if (remotes.length === 0 && this.you?.videoOn)
          return this.you;
        return remotes.find((p2) => p2.videoOn);
      }
      get gridParticipants() {
        const remotes = this.participants.filter((p2) => !p2.isYou);
        const self2 = this.you;
        if (remotes.length === 0 && self2)
          return [self2];
        return remotes;
      }
      suspiciousEvents = [];
      lastSuspiciousEvent = {};
      // store last times
      suspiciousCooldown = 5e3;
      // 5 seconds per message type
      constructor(signaling) {
        this.signaling = signaling;
      }
      updateBaseline(landmarks) {
        const leftEye = landmarks.getLeftEye();
        const rightEye = landmarks.getRightEye();
        const pupil = {
          x: (leftEye[1].x + leftEye[2].x + rightEye[1].x + rightEye[2].x) / 4,
          y: (leftEye[4].y + rightEye[4].y) / 2
        };
        const eyeXmin = Math.min(leftEye[0].x, rightEye[3].x);
        const eyeXmax = Math.max(leftEye[3].x, rightEye[0].x);
        const eyeYtop = (leftEye[1].y + rightEye[1].y) / 2;
        const eyeYbottom = (leftEye[5].y + rightEye[5].y) / 2;
        this.gazeState.calibrationBuffer.push({
          x: (pupil.x - eyeXmin) / (eyeXmax - eyeXmin),
          y: (pupil.y - eyeYtop) / (eyeYbottom - eyeYtop)
        });
        if (this.gazeState.calibrationBuffer.length >= this.gazeState.maxCalibrationFrames) {
          this.gazeState.baseline = {
            x: this.gazeState.calibrationBuffer.reduce((a2, p2) => a2 + p2.x, 0) / this.gazeState.calibrationBuffer.length,
            y: this.gazeState.calibrationBuffer.reduce((a2, p2) => a2 + p2.y, 0) / this.gazeState.calibrationBuffer.length
          };
        }
      }
      estimateGazeCalibrated(landmarks) {
        if (!this.gazeState.baseline)
          return "Calibrating...";
        const leftEye = landmarks.getLeftEye();
        const rightEye = landmarks.getRightEye();
        const pupil = {
          x: (leftEye[1].x + leftEye[2].x + rightEye[1].x + rightEye[2].x) / 4,
          y: (leftEye[4].y + rightEye[4].y) / 2
        };
        const eyeXmin = Math.min(leftEye[0].x, rightEye[3].x);
        const eyeXmax = Math.max(leftEye[3].x, rightEye[0].x);
        const eyeYtop = (leftEye[1].y + rightEye[1].y) / 2;
        const eyeYbottom = (leftEye[5].y + rightEye[5].y) / 2;
        const normX = (pupil.x - eyeXmin) / (eyeXmax - eyeXmin);
        const normY = (pupil.y - eyeYtop) / (eyeYbottom - eyeYtop);
        const dx = normX - this.gazeState.baseline.x;
        const dy = normY - this.gazeState.baseline.y;
        const thrX = (this.gazeState.stdDev?.x ?? 0.03) * 2.5;
        const thrY = (this.gazeState.stdDev?.y ?? 0.03) * 2.5;
        let direction = "Looking Forward";
        if (dx < -thrX)
          direction = "Looking Left";
        else if (dx > thrX)
          direction = "Looking Right";
        else if (dy < -thrY)
          direction = "Looking Up";
        else if (dy > thrY)
          direction = "Looking Down";
        return direction;
      }
      // 🔍 Check suspiciousness with stricter rules
      checkSuspiciousGaze(finalGaze) {
        const now = performance.now();
        this.gazeState.gazeHistory.push(finalGaze);
        if (this.gazeState.gazeHistory.length > this.gazeState.maxHistory) {
          this.gazeState.gazeHistory.shift();
        }
        if (finalGaze !== "Looking Forward" && finalGaze !== "Calibrating...") {
          if (finalGaze === this.gazeState.lastDirection) {
            this.gazeState.consecutiveCount++;
          } else {
            this.gazeState.lastDirection = finalGaze;
            this.gazeState.consecutiveCount = 1;
          }
          if (this.gazeState.consecutiveCount > 10) {
            this.sendSuspiciousEvent(`\u26A0\uFE0F Candidate ${finalGaze} (sustained)`);
            this.gazeState.consecutiveCount = 0;
          }
        } else {
          this.gazeState.consecutiveCount = 0;
          this.gazeState.lastDirection = "Looking Forward";
        }
        if (this.gazeState.gazeHistory.length >= 5) {
          const last5 = this.gazeState.gazeHistory.slice(-5);
          const unique = new Set(last5);
          if (unique.size >= 3) {
            this.sendSuspiciousEvent("\u26A0\uFE0F Rapid eye movement detected");
          }
        }
      }
      smoothGaze(newGaze) {
        this.gazeState.gazeHistory.push(newGaze);
        if (this.gazeState.gazeHistory.length > this.gazeState.maxHistory) {
          this.gazeState.gazeHistory.shift();
        }
        const counts = this.gazeState.gazeHistory.reduce((a2, g2) => {
          a2[g2] = (a2[g2] || 0) + 1;
          return a2;
        }, {});
        return Object.entries(counts).sort((a2, b2) => b2[1] - a2[1])[0][0];
      }
      // ====== Lifecycle ======
      ngOnInit() {
        return __async(this, null, function* () {
          document.addEventListener("visibilitychange", () => {
            if (document.hidden) {
              this.sendSuspiciousEvent("\u26A0\uFE0F Candidate switched tab/window");
            }
          });
        });
      }
      sendSuspiciousEvent(message) {
        const now = Date.now();
        const last4 = this.lastSuspiciousEvent[message] || 0;
        if (now - last4 < this.suspiciousCooldown)
          return;
        this.lastSuspiciousEvent[message] = now;
        const event = {
          time: (/* @__PURE__ */ new Date()).toLocaleTimeString(),
          message
        };
        this.suspiciousEvents.unshift({
          time: (/* @__PURE__ */ new Date()).toLocaleTimeString(),
          message
        });
        if (this.suspiciousEvents.length > 30) {
          this.suspiciousEvents.pop();
        }
      }
      ngAfterViewInit() {
        return __async(this, null, function* () {
          yield Promise.all([
            nets.tinyFaceDetector.loadFromUri("/static/models"),
            nets.faceExpressionNet.loadFromUri("/static/models"),
            nets.faceRecognitionNet.loadFromUri("/static/models"),
            nets.faceLandmark68Net.loadFromUri("/static/models")
            // ✅ for gaze
          ]);
          this.startFaceMonitoring();
          document.addEventListener("keydown", (e2) => {
            this.sendSuspiciousEvent(`Key pressed: ${e2.key}`);
          });
          document.addEventListener("paste", () => {
            this.sendSuspiciousEvent("\u26A0\uFE0F Paste action detected");
          });
        });
      }
      // async startFaceMonitoring() {
      //   const videoEl = document.querySelector('video'); // candidate’s video element
      //   if (!videoEl) return;
      //   const detect = async () => {
      //     const detections = await faceapi.detectAllFaces(videoEl, new faceapi.TinyFaceDetectorOptions())
      //                                     .withFaceExpressions();
      //     if (detections.length > 1) {
      //       this.sendSuspiciousEvent('⚠️ Multiple faces detected');
      //     } else if (detections.length === 0) {
      //       this.sendSuspiciousEvent('No face detected');
      //     }
      //     // Example: check if expression = looking away (low "neutral" + high "surprised")
      //     if (detections[0]?.expressions?.surprised > 0.6) {
      //       this.sendSuspiciousEvent('Candidate looking away / distracted');
      //     }
      //     requestAnimationFrame(detect);
      //   };
      //   detect();
      // }
      startFaceMonitoring() {
        return __async(this, null, function* () {
          const videos = () => Array.from(document.querySelectorAll('video[data-role="tile"]'));
          const canvases = () => Array.from(document.querySelectorAll('canvas[data-role="overlay"]'));
          const pairByChan = () => {
            const vs2 = videos();
            const cs2 = canvases();
            const map2 = /* @__PURE__ */ new Map();
            vs2.forEach((v) => {
              const chan = v.getAttribute("data-chan") || "";
              const c2 = cs2.find((x2) => x2.getAttribute("data-chan") === chan);
              if (chan && c2)
                map2.set(chan, { v, c: c2 });
            });
            return map2;
          };
          const syncCanvasSize = (v, c2) => {
            const w2 = v.offsetWidth || v.clientWidth || v.getBoundingClientRect().width || 0;
            const h2 = v.offsetHeight || v.clientHeight || v.getBoundingClientRect().height || 0;
            if (!w2 || !h2)
              return;
            if (c2.width !== Math.round(w2))
              c2.width = Math.round(w2);
            if (c2.height !== Math.round(h2))
              c2.height = Math.round(h2);
            c2.style.width = `${w2}px`;
            c2.style.height = `${h2}px`;
            c2.style.position = "absolute";
            c2.style.top = "0";
            c2.style.left = "0";
            c2.style.pointerEvents = "none";
            c2.style.zIndex = "50";
          };
          const ro2 = new ResizeObserver(() => {
            pairByChan().forEach(({ v, c: c2 }) => syncCanvasSize(v, c2));
          });
          pairByChan().forEach(({ v, c: c2 }) => {
            syncCanvasSize(v, c2);
            ro2.observe(v);
          });
          let lastT = 0;
          const targetDt = 120;
          const loop = (t2) => __async(this, null, function* () {
            if (t2 - lastT >= targetDt) {
              lastT = t2;
              const pairs = pairByChan();
              for (const { v: videoEl, c: canvasEl } of pairs.values()) {
                const tile = videoEl.closest(".tile");
                const ctx = canvasEl.getContext("2d");
                if (!ctx)
                  continue;
                const chan = videoEl.getAttribute("data-chan") || "";
                const participant = this.participantsMap.get(chan);
                if (!participant?.videoOn || videoEl.readyState < 2) {
                  ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
                  canvasEl.style.display = "none";
                  tile?.classList.remove("suspicious");
                  continue;
                } else {
                  canvasEl.style.display = "block";
                }
                syncCanvasSize(videoEl, canvasEl);
                const detections = yield detectAllFaces(videoEl, new TinyFaceDetectorOptions({ inputSize: 192, scoreThreshold: 0.5 })).withFaceLandmarks().withFaceExpressions();
                ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
                const resized = resizeResults(detections, {
                  width: canvasEl.width,
                  height: canvasEl.height
                });
                draw_exports.drawDetections(canvasEl, resized);
                draw_exports.drawFaceExpressions(canvasEl, resized);
                if (detections.length !== 1) {
                  if (detections.length > 1)
                    this.sendSuspiciousEvent("\u26A0\uFE0F Multiple faces detected");
                  else
                    this.sendSuspiciousEvent("\u26A0\uFE0F No face detected");
                  tile?.classList.add("suspicious");
                } else {
                  tile?.classList.remove("suspicious");
                  const expr = detections[0].expressions;
                  const dom = Object.entries(expr).reduce((a2, b2) => a2[1] > b2[1] ? a2 : b2);
                  this.sendSuspiciousEvent(`Expression: ${dom[0]}`);
                  const landmarks = detections[0].landmarks;
                  if (!this.gazeState.baseline) {
                    this.updateBaseline(landmarks);
                  } else {
                    if (landmarks) {
                      const rawGaze = this.estimateGazeCalibrated(landmarks);
                      const finalGaze = this.smoothGaze(rawGaze);
                      this.checkSuspiciousGaze(finalGaze);
                      if (finalGaze !== "Looking Forward" && finalGaze !== "Calibrating...") {
                        this.sendSuspiciousEvent(`\u26A0\uFE0F Candidate ${finalGaze}`);
                      }
                      ctx.fillStyle = "red";
                      ctx.font = "16px Arial";
                      ctx.fillText(`Gaze: ${finalGaze}`, 10, 20);
                    }
                  }
                }
              }
            }
            requestAnimationFrame(loop);
          });
          requestAnimationFrame(loop);
        });
      }
      joinRoom() {
        console.log("DASHBOARD BUILD MARKER v8 \u2014 stable-media");
        this.localPreviewStream = new MediaStream();
        this.participantsMap.set("__you__", this.makeLocalParticipant(this.userName));
        this.syncParticipantsArray();
        this.signaling.connect(this.roomName);
        this.signalingSub = this.signaling.messages$.subscribe((msg) => this.onSignal(msg));
        setTimeout(() => this.startFaceMonitoring(), 100);
      }
      ngOnDestroy() {
        try {
          this.sendSig({ type: "bye" });
        } catch {
        }
        this.signalingSub?.unsubscribe();
        this.signaling.disconnect();
        this.peers.forEach((st2) => {
          try {
            st2.pc.close();
          } catch {
          }
        });
        this.peers.clear();
        this.stopAndClearLocalTracks();
        this.participantsMap.clear();
        this.iceQueue.clear();
      }
      onBeforeUnload() {
        try {
          this.sendSig({ type: "bye" });
        } catch {
        }
      }
      onResize() {
        this.isDesktop = window.innerWidth >= 1024;
      }
      // ====== Utilities ======
      sendSig(payload) {
        this.signaling.sendMessage(__spreadValues({}, payload));
      }
      initialsFromName(name) {
        const parts = (name || "").trim().split(/\s+/);
        const letters = parts.slice(0, 2).map((s2) => (s2[0] || "").toUpperCase());
        return letters.join("") || "?";
      }
      participantChan(row) {
        return row?.channel;
      }
      asOffer(msg) {
        return msg?.offer && msg.offer.type && msg.offer.sdp ? msg.offer : null;
      }
      asAnswer(msg) {
        return msg?.answer && msg.answer.type && msg.answer.sdp ? msg.answer : null;
      }
      asCandidate(msg) {
        return msg?.ice_candidate || null;
      }
      senderChan(msg) {
        return msg?.sender_channel || msg?.from;
      }
      messageIsForMe(msg) {
        return msg?.to ? msg.to === this.myServerChan : true;
      }
      // ====== Participants store helpers ======
      syncParticipantsArray() {
        this.participants = Array.from(this.participantsMap.values()).filter((p2) => p2.channel !== "__you__").concat(this.you ? [this.you] : []);
        console.log("\u{1F504} syncParticipantsArray:", this.participants.map((p2) => ({
          name: p2.name,
          stream: !!p2.stream,
          videoOn: p2.videoOn,
          tracks: p2.stream?.getTracks().length
        })));
      }
      makeLocalParticipant(name) {
        return {
          name,
          mic: "off",
          cam: "off",
          videoOn: false,
          initials: this.initialsFromName(name),
          isYou: true,
          channel: "__you__",
          stream: null,
          // preview stream will be attached when camera turns on
          handRaised: false
        };
      }
      computeVideoOn(cam, stream) {
        if (cam !== "on" || !stream)
          return false;
        const vt2 = stream.getVideoTracks();
        return vt2.length > 0 && vt2.some((t2) => t2.enabled !== false);
      }
      upsertParticipantFromPayload(row) {
        const ch2 = this.participantChan(row);
        if (!ch2)
          return;
        if (this.myServerChan && ch2 === this.myServerChan)
          return;
        const existingByName = Array.from(this.participantsMap.values()).find((p2) => p2.name === row?.name && !p2.isYou);
        const prev = existingByName ?? this.participantsMap.get(ch2);
        const nextCam = row?.cam ?? prev?.cam ?? "off";
        const nextMic = row?.mic ?? prev?.mic ?? "off";
        const next = {
          name: row?.name ?? prev?.name ?? "Guest",
          mic: nextMic,
          cam: nextCam,
          videoOn: this.computeVideoOn(nextCam, prev?.stream),
          initials: this.initialsFromName(row?.name ?? prev?.name ?? "Guest"),
          isYou: false,
          channel: prev?.channel ?? ch2,
          // ✅ stick to the first channel we saw
          stream: prev?.stream ?? null,
          handRaised: typeof row?.handRaised === "boolean" ? row.handRaised : prev?.handRaised ?? false
        };
        this.participantsMap.set(next.channel, next);
        this.syncParticipantsArray();
      }
      ensureParticipantStream(ch2) {
        const p2 = this.participantsMap.get(ch2);
        if (p2?.stream)
          return p2.stream;
        const ms2 = new MediaStream();
        if (p2) {
          const updated = __spreadProps(__spreadValues({}, p2), { stream: ms2, videoOn: this.computeVideoOn(p2.cam, ms2) });
          this.participantsMap.set(ch2, updated);
        }
        return ms2;
      }
      // ====== Local media helpers ======
      stopAndClearLocalTracks() {
        try {
          this.localVideoTrack?.stop();
        } catch {
        }
        try {
          this.localAudioTrack?.stop();
        } catch {
        }
        this.localVideoTrack = null;
        this.localAudioTrack = null;
        this.localPreviewStream.getTracks().forEach((t2) => {
          try {
            t2.stop();
          } catch {
          }
        });
        this.localPreviewStream = new MediaStream();
        const me2 = this.participantsMap.get("__you__");
        if (me2) {
          const updated = __spreadProps(__spreadValues({}, me2), { cam: "off", mic: "off", stream: null, videoOn: false });
          this.participantsMap.set("__you__", updated);
          this.syncParticipantsArray();
        }
      }
      refreshLocalPreview() {
        const next = new MediaStream();
        if (this.localVideoTrack)
          next.addTrack(this.localVideoTrack);
        this.localPreviewStream = next;
        const me2 = this.participantsMap.get("__you__");
        if (me2) {
          const hasCam = this.localVideoTrack != null;
          const updated = __spreadProps(__spreadValues({}, me2), {
            stream: hasCam ? this.localPreviewStream : null,
            videoOn: this.computeVideoOn(hasCam ? "on" : "off", hasCam ? this.localPreviewStream : null),
            cam: hasCam ? "on" : "off"
          });
          this.participantsMap.set("__you__", updated);
        }
        this.peers.forEach((st2) => {
          try {
            st2.audioSender.replaceTrack(this.localAudioTrack);
          } catch {
          }
          try {
            st2.videoSender.replaceTrack(this.localVideoTrack);
          } catch {
          }
        });
        this.syncParticipantsArray();
      }
      // ====== Peer creation & negotiation ======
      getOrCreatePeer(remoteChan) {
        let st2 = this.peers.get(remoteChan);
        if (st2)
          return st2;
        const pc2 = new RTCPeerConnection({
          iceServers: [
            // Google STUN (optional fallback)
            { urls: "stun:stun.l.google.com:19302" },
            // Your own STUN
            { urls: "stun:smartvid.live:3478" },
            // Your TURN with UDP/TCP/TLS
            {
              urls: [
                "turn:smartvid.live:3478?transport=udp",
                "turn:smartvid.live:5349?transport=tcp",
                "turns:smartvid.live:5349?transport=tcp"
              ],
              username: "test",
              credential: "test123"
            }
          ]
        });
        const at2 = pc2.addTransceiver("audio", { direction: "sendrecv" });
        const vt2 = pc2.addTransceiver("video", { direction: "sendrecv" });
        const h264Codecs = RTCRtpSender.getCapabilities("video")?.codecs.filter((c2) => c2.mimeType.toLowerCase() === "video/h264").filter((c2) => !c2.sdpFmtpLine || c2.sdpFmtpLine.includes("42e01f"));
        if (h264Codecs?.length && vt2.setCodecPreferences) {
          vt2.setCodecPreferences(h264Codecs);
          console.log("\u{1F3A5} Forcing baseline H.264 codec:", h264Codecs);
        } else {
          console.warn("\u26A0\uFE0F H.264 baseline not available, using defaults");
        }
        st2 = {
          pc: pc2,
          makingOffer: false,
          ignoreOffer: false,
          polite: this.myPolite,
          audioSender: at2.sender,
          videoSender: vt2.sender,
          remoteChan,
          isSettingRemoteAnswerPending: false
        };
        try {
          st2.audioSender.replaceTrack(this.localAudioTrack);
        } catch {
        }
        try {
          st2.videoSender.replaceTrack(this.localVideoTrack);
        } catch {
        }
        pc2.onnegotiationneeded = () => __async(this, null, function* () {
          if (st2.makingOffer || pc2.signalingState !== "stable")
            return;
          try {
            st2.makingOffer = true;
            console.log("\u{1F9ED} onnegotiationneeded \u2192 createOffer for", remoteChan);
            yield pc2.setLocalDescription(yield pc2.createOffer());
            this.sendSig({ type: "offer", offer: pc2.localDescription, to: remoteChan });
          } catch (err) {
            console.error("onnegotiationneeded error", err);
          } finally {
            st2.makingOffer = false;
          }
        });
        pc2.ontrack = (ev) => {
          console.log("\u{1F4E1} ontrack from", remoteChan, ev);
          let pPrev = this.participantsMap.get(remoteChan);
          if (!pPrev) {
            pPrev = {
              name: "Unknown",
              initials: "?",
              mic: "off",
              cam: "off",
              videoOn: false,
              channel: remoteChan,
              isYou: false,
              stream: null,
              handRaised: false
            };
          }
          const ms2 = this.ensureParticipantStream(remoteChan);
          const already = ms2.getTracks().some((t2) => t2.id === ev.track.id);
          if (!already)
            ms2.addTrack(ev.track);
          const updated = __spreadProps(__spreadValues({}, pPrev), {
            stream: ms2,
            mic: ms2.getAudioTracks().length > 0 ? "on" : "off",
            cam: ms2.getVideoTracks().length > 0 ? "on" : "off",
            videoOn: this.computeVideoOn(ms2.getVideoTracks().length > 0 ? "on" : "off", ms2)
          });
          this.participantsMap.set(remoteChan, updated);
          this.syncParticipantsArray();
        };
        pc2.onicecandidate = ({ candidate }) => {
          if (!candidate)
            return;
          this.sendSig({ type: "ice_candidate", ice_candidate: candidate.toJSON?.() ?? candidate, to: remoteChan });
        };
        pc2.onconnectionstatechange = () => {
          console.log("pc.connectionState for", remoteChan, "=", pc2.connectionState);
        };
        this.peers.set(remoteChan, st2);
        return st2;
      }
      renegotiate(remoteChan) {
        return __async(this, null, function* () {
          const st2 = this.peers.get(remoteChan);
          if (!st2)
            return;
          const pc2 = st2.pc;
          if (st2.makingOffer || pc2.signalingState !== "stable")
            return;
          try {
            st2.makingOffer = true;
            console.log("manual renegotiate for", remoteChan);
            yield pc2.setLocalDescription(yield pc2.createOffer());
            this.sendSig({ type: "offer", offer: pc2.localDescription, to: remoteChan });
          } catch (err) {
            console.error("renegotiate error", err);
          } finally {
            st2.makingOffer = false;
          }
        });
      }
      queueIce(remoteChan, cand) {
        const q2 = this.iceQueue.get(remoteChan) ?? [];
        q2.push(cand);
        this.iceQueue.set(remoteChan, q2);
      }
      flushIce(remoteChan) {
        return __async(this, null, function* () {
          const st2 = this.peers.get(remoteChan);
          if (!st2 || !st2.pc.remoteDescription)
            return;
          const q2 = this.iceQueue.get(remoteChan);
          if (!q2?.length)
            return;
          for (const c2 of q2) {
            try {
              yield st2.pc.addIceCandidate(c2);
            } catch {
            }
          }
          this.iceQueue.delete(remoteChan);
        });
      }
      // ====== Incoming signaling ======
      onSignal(msg) {
        if (!msg)
          return;
        if (msg.type === "welcome") {
          this.myServerChan = msg.channel || msg.myServerChan || null;
          this.myPolite = !!msg.polite;
          const myName = this.you?.name || "You";
          this.sendSig({ type: "name_update", name: myName });
          console.log("\u2714\uFE0F Received welcome. My channel =", this.myServerChan, "Polite =", this.myPolite);
          return;
        }
        switch (msg.type) {
          case "participants": {
            const list = msg.participants || [];
            list.forEach((row) => {
              const ch2 = this.participantChan(row);
              if (!ch2)
                return;
              if (this.myServerChan && ch2 === this.myServerChan)
                return;
              if (!this.participantsMap.has(ch2)) {
                this.upsertParticipantFromPayload(row);
                this.getOrCreatePeer(ch2);
              }
            });
            break;
          }
          case "participant_joined": {
            const row = msg.participant;
            const ch2 = this.participantChan(row);
            if (!ch2)
              return;
            if (this.myServerChan && ch2 === this.myServerChan)
              return;
            if (!this.participantsMap.has(ch2)) {
              this.upsertParticipantFromPayload(row);
              this.getOrCreatePeer(ch2);
            }
            break;
          }
          case "participant_left": {
            const ch2 = msg.channel;
            if (!ch2)
              break;
            this.participantsMap.delete(ch2);
            const st2 = this.peers.get(ch2);
            if (st2) {
              try {
                st2.pc.close();
              } catch {
              }
              this.peers.delete(ch2);
            }
            this.syncParticipantsArray();
            break;
          }
          case "participant_updated": {
            const row = msg.participant;
            const ch2 = this.participantChan(row);
            if (!ch2)
              return;
            if (this.myServerChan && ch2 === this.myServerChan)
              return;
            this.upsertParticipantFromPayload(row);
            break;
          }
          case "chat_message": {
            const payload = msg.message ?? {};
            const text = payload.text ?? "";
            if (text) {
              const by = payload.by ?? "Guest";
              this.chatMessages = [...this.chatMessages, { by, text }];
              setTimeout(() => this.scrollToBottom(), 0);
            }
            break;
          }
          case "offer": {
            if (!this.messageIsForMe(msg))
              return;
            const from2 = this.senderChan(msg);
            if (!from2)
              return;
            const offer = this.asOffer(msg);
            if (!offer)
              return;
            const st2 = this.getOrCreatePeer(from2);
            const pc2 = st2.pc;
            (() => __async(this, null, function* () {
              const offerCollision = st2.makingOffer || pc2.signalingState !== "stable";
              st2.ignoreOffer = !st2.polite && offerCollision;
              if (st2.ignoreOffer) {
                console.log("ignoring offer from", from2);
                return;
              }
              try {
                if (pc2.signalingState !== "stable") {
                  yield pc2.setLocalDescription({ type: "rollback" });
                }
                yield pc2.setRemoteDescription(offer);
                try {
                  st2.audioSender.replaceTrack(this.localAudioTrack);
                } catch {
                }
                try {
                  st2.videoSender.replaceTrack(this.localVideoTrack);
                } catch {
                }
                yield pc2.setLocalDescription(yield pc2.createAnswer());
                this.sendSig({ type: "answer", answer: pc2.localDescription, to: from2 });
                yield this.flushIce(from2);
              } catch (err) {
                console.error("error handling offer", err);
              }
            }))();
            break;
          }
          case "answer": {
            if (!this.messageIsForMe(msg))
              return;
            const from2 = this.senderChan(msg);
            if (!from2)
              return;
            const answer = this.asAnswer(msg);
            if (!answer)
              return;
            const st2 = this.peers.get(from2);
            if (!st2)
              return;
            const pc2 = st2.pc;
            (() => __async(this, null, function* () {
              try {
                st2.isSettingRemoteAnswerPending = true;
                yield pc2.setRemoteDescription(answer);
                yield this.flushIce(from2);
              } catch (err) {
                console.error("error applying answer", err);
              } finally {
                st2.isSettingRemoteAnswerPending = false;
              }
            }))();
            break;
          }
          case "ice_candidate": {
            if (!this.messageIsForMe(msg))
              return;
            const from2 = this.senderChan(msg);
            if (!from2)
              return;
            const cand = this.asCandidate(msg);
            if (!cand)
              return;
            const st2 = this.peers.get(from2);
            if (!st2) {
              this.queueIce(from2, cand);
              return;
            }
            (() => __async(this, null, function* () {
              try {
                if (st2.pc.remoteDescription)
                  yield st2.pc.addIceCandidate(cand);
                else
                  this.queueIce(from2, cand);
              } catch (e2) {
                if (!st2.ignoreOffer)
                  console.error("error adding ICE", e2);
              }
            }))();
            break;
          }
        }
      }
      // ====== UI actions ======
      toggleChat() {
        this.chatCollapsed = !this.chatCollapsed;
      }
      closeChat() {
        this.chatCollapsed = true;
      }
      sendChat() {
        const text = this.chatText.trim();
        if (!text)
          return;
        const by = this.you?.name || "You";
        this.chatMessages = [...this.chatMessages, { by, text }];
        this.sendSig({ type: "chat", by, text });
        this.chatText = "";
        setTimeout(() => this.scrollToBottom(), 0);
      }
      scrollToBottom() {
        if (this.chatScroll) {
          this.chatScroll.nativeElement.scrollTop = this.chatScroll.nativeElement.scrollHeight;
        }
      }
      updateNameFirst() {
        if (!this.userName) {
          alert("Please Enter User Name");
          return;
        }
        if (!this.termsCheckbox) {
          alert("Please Enter User Name");
          return;
        }
        this.isNameUpdated = true;
        this.joinRoom();
      }
      updateName(e2) {
        const v = e2.target.value.trim() || "You";
        const me2 = this.participantsMap.get("__you__");
        if (me2) {
          this.participantsMap.set("__you__", __spreadProps(__spreadValues({}, me2), { name: v, initials: this.initialsFromName(v) }));
          this.syncParticipantsArray();
        }
        this.sendSig({ type: "name_update", name: v });
      }
      toggleMic() {
        return __async(this, null, function* () {
          const me2 = this.participantsMap.get("__you__");
          if (!me2)
            return;
          const next = me2.mic === "on" ? "off" : "on";
          if (next === "on") {
            try {
              const s2 = yield navigator.mediaDevices.getUserMedia({ audio: true, video: false });
              this.localAudioTrack = s2.getAudioTracks()[0] || null;
            } catch {
              alert("Microphone access denied.");
              return;
            }
          } else {
            try {
              this.localAudioTrack?.stop();
            } finally {
              this.localAudioTrack = null;
            }
          }
          this.peers.forEach((st2) => {
            try {
              st2.audioSender.replaceTrack(this.localAudioTrack);
            } catch {
            }
          });
          this.participantsMap.set("__you__", __spreadProps(__spreadValues({}, me2), { mic: next }));
          this.syncParticipantsArray();
          this.sendSig({ type: "mic_toggle", mic: next });
        });
      }
      toggleCam() {
        return __async(this, null, function* () {
          const me2 = this.participantsMap.get("__you__");
          if (!me2)
            return;
          const turningOn = me2.cam === "off";
          if (turningOn) {
            try {
              const s2 = yield navigator.mediaDevices.getUserMedia({ video: true, audio: false });
              this.localVideoTrack = s2.getVideoTracks()[0] || null;
              if (this.localVideoTrack) {
                this.localVideoTrack.enabled = true;
                this.localVideoTrack.onended = () => {
                  this.localVideoTrack = null;
                  this.refreshLocalPreview();
                  this.participantsMap.set("__you__", __spreadProps(__spreadValues({}, this.participantsMap.get("__you__")), { cam: "off" }));
                  this.syncParticipantsArray();
                  this.sendSig({ type: "cam_toggle", cam: "off" });
                  this.peers.forEach((_st, ch2) => this.renegotiate(ch2));
                };
              }
            } catch (e2) {
              alert("Camera access error: " + (e2?.message || e2));
              return;
            }
          } else {
            try {
              this.localVideoTrack?.stop();
            } finally {
              this.localVideoTrack = null;
            }
          }
          this.refreshLocalPreview();
          const me22 = this.participantsMap.get("__you__");
          const nextCam = turningOn ? "on" : "off";
          const updated = __spreadProps(__spreadValues({}, me22), {
            cam: nextCam,
            videoOn: this.computeVideoOn(nextCam, me22.stream)
          });
          this.participantsMap.set("__you__", updated);
          this.syncParticipantsArray();
          this.sendSig({ type: "cam_toggle", cam: nextCam });
          this.peers.forEach((_st, ch2) => this.renegotiate(ch2));
        });
      }
      shareScreen() {
        return __async(this, null, function* () {
          try {
            const screenStream = yield navigator.mediaDevices.getDisplayMedia({ video: true });
            const screenTrack = screenStream.getVideoTracks()[0];
            if (!screenTrack)
              return;
            try {
              this.localVideoTrack?.stop();
            } catch {
            }
            this.localVideoTrack = screenTrack;
            screenTrack.onended = () => {
              this.localVideoTrack = null;
              this.refreshLocalPreview();
              const me3 = this.participantsMap.get("__you__");
              if (me3) {
                this.participantsMap.set("__you__", __spreadProps(__spreadValues({}, me3), { cam: "off", videoOn: false }));
                this.syncParticipantsArray();
              }
              this.sendSig({ type: "cam_toggle", cam: "off" });
              this.peers.forEach((_st, ch2) => this.renegotiate(ch2));
            };
            this.refreshLocalPreview();
            const me2 = this.participantsMap.get("__you__");
            if (me2) {
              const up = __spreadProps(__spreadValues({}, me2), { cam: "on", videoOn: this.computeVideoOn("on", this.localPreviewStream) });
              this.participantsMap.set("__you__", up);
              this.syncParticipantsArray();
            }
            this.sendSig({ type: "cam_toggle", cam: "on" });
            this.peers.forEach((_st, ch2) => this.renegotiate(ch2));
          } catch {
            alert("Screen share failed.");
          }
        });
      }
      cycleLayout() {
        if (this.tileColsManual == null)
          this.tileColsManual = 1;
        else if (this.tileColsManual < 4)
          this.tileColsManual += 1;
        else
          this.tileColsManual = null;
      }
      leaveCall() {
        this.sendSig({ type: "bye" });
        if (this.you?.stream) {
          this.you.stream.getTracks().forEach((track) => track.stop());
        }
        this.peers.forEach(({ pc: pc2 }) => {
          try {
            pc2.close();
          } catch {
          }
        });
        this.peers.clear();
        this.participantsMap.forEach((_p, ch2) => {
          if (ch2 !== "__you__")
            this.participantsMap.delete(ch2);
        });
        this.participantsMap.delete("__you__");
        this.syncParticipantsArray();
        this.isNameUpdated = false;
      }
      raiseHand() {
        const me2 = this.participantsMap.get("__you__");
        if (!me2)
          return;
        const next = !me2.handRaised;
        this.participantsMap.set("__you__", __spreadProps(__spreadValues({}, me2), { handRaised: next }));
        this.syncParticipantsArray();
        this.sendSig({ type: "hand_toggle", handRaised: next });
      }
      get shouldShowSelfVideo() {
        return !!this.you?.videoOn && !!this.you?.stream && this.gridParticipants.length > 0;
      }
      trackByParticipant(index, item) {
        return item.channel;
      }
      static \u0275fac = function Dashboard_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Dashboard)(\u0275\u0275directiveInject(SignalingService));
      };
      static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _Dashboard, selectors: [["app-dashboard"]], viewQuery: function Dashboard_Query(rf2, ctx) {
        if (rf2 & 1) {
          \u0275\u0275viewQuery(_c02, 5);
          \u0275\u0275viewQuery(_c12, 5);
          \u0275\u0275viewQuery(_c2, 5);
        }
        if (rf2 & 2) {
          let _t2;
          \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.chatScroll = _t2.first);
          \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.videoTiles = _t2);
          \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.canvasTiles = _t2);
        }
      }, hostBindings: function Dashboard_HostBindings(rf2, ctx) {
        if (rf2 & 1) {
          \u0275\u0275listener("beforeunload", function Dashboard_beforeunload_HostBindingHandler() {
            return ctx.onBeforeUnload();
          }, \u0275\u0275resolveWindow)("resize", function Dashboard_resize_HostBindingHandler() {
            return ctx.onResize();
          }, \u0275\u0275resolveWindow);
        }
      }, features: [\u0275\u0275ProvidersFeature([SignalingService])], decls: 2, vars: 2, consts: [["chatScroll", ""], [4, "ngIf"], ["class", "h-screen text-white grid grid-cols-1 lg:grid-cols-[1fr_340px] gap-4 p-4 overflow-hidden items-stretch", 3, "chat-open", 4, "ngIf"], [1, "h-screen", "flex", "items-center", "justify-center", "bg-slate-900", "text-white"], [1, "bg-slate-800", "p-6", "rounded-xl", "shadow-xl", "w-96"], [1, "text-xl", "font-bold", "mb-4"], [1, "block", "mb-3"], [1, "text-sm"], ["id", "nameInput", "type", "text", "placeholder", "Enter Your name", 1, "mt-1", "w-full", "px-3", "py-2", "rounded-md", "bg-slate-700", "text-white", 3, "ngModelChange", "ngModel"], [1, "flex", "items-center", "gap-2", "mb-4"], ["id", "termsCheckbox", "type", "checkbox", 1, "w-4", "h-4", 3, "ngModelChange", "ngModel"], ["id", "joinBtn", 1, "w-full", "px-4", "py-2", "rounded-lg", "bg-sky-600", "hover:bg-sky-700", "disabled:opacity-50", 3, "click"], [1, "h-screen", "text-white", "grid", "grid-cols-1", "lg:grid-cols-[1fr_340px]", "gap-4", "p-4", "overflow-hidden", "items-stretch"], [1, "stage", "flex-1", "flex", "flex-col", "relative", "min-h-0"], ["class", "stage-header flex items-center justify-between px-3 py-2 rounded-t-md shrink-0", 4, "ngIf"], [1, "tile-grid-container", "flex-1", "min-h-0", "p-4", "gap-6", "border", "border-sky-700/40", "rounded-xl", "bg-slate-900/40", "flex", "flex-col", "overflow-hidden"], ["class", "tile-grid min-h-0 overflow-y-auto no-scrollbar", 3, "ngClass", 4, "ngIf"], [1, "controls", "shrink-0", "bg-slate-900/60", "backdrop-blur-sm", "p-4", "rounded-lg", "border-t", "border-sky-700/30", "flex", "flex-wrap", "gap-3", "justify-center"], [1, "ctrl", "secondary", "flex", "items-center", "gap-2", "px-4", "py-2", "rounded-full", 3, "click"], [1, "ph", 3, "ngClass"], [1, "ph", "ph-monitor"], [1, "ph", "ph-hand"], [1, "ph", "ph-grid-four"], [1, "ctrl", "danger", "flex", "items-center", "gap-2", "px-4", "py-2", "rounded-full", 3, "click"], [1, "ph", "ph-sign-out"], ["class", "self-video-floating", "cdkDrag", "", "cdkDragBoundary", ".stage", 4, "ngIf"], [1, "chat-panel", "frosted", "lg:static", "fixed", "inset-y-0", "right-0", "w-full", "max-w-sm", "transform", "transition-transform", "duration-300", "flex", "flex-col", "z-50", "min-h-0", "shadow-2xl", 3, "ngClass"], [1, "shrink-0", "p-3"], [1, "relative", "floating", "mt-2"], [1, "ph", "ph-user", "icon-left", "text-sky-300"], ["id", "username", "type", "text", 1, "floating-input", "pl-10", "pr-3", "py-2", "text-sm", "rounded-md", "w-full", "dark-input", 3, "change", "value"], ["for", "username", 1, "floating-label"], [1, "chat-header", "flex", "items-center", "justify-between", "px-4", "py-3", "border-b", "border-sky-700/20", "shrink-0"], [1, "flex", "gap-4"], [1, "tab-btn", 3, "click"], ["class", "hr-btn px-3 py-1 text-xs", 3, "click", 4, "ngIf"], [1, "flex-1", "min-h-0", "flex", "flex-col"], ["class", "flex-1 max-h-full overflow-y-auto participants-scroll p-4", 4, "ngIf"], ["class", "flex-1 max-h-full overflow-y-auto alerts-scroll p-4", 4, "ngIf"], ["class", "flex-1 max-h-full overflow-y-auto chat-scroll p-4", 4, "ngIf"], ["class", "flex border-t border-sky-700/10 p-2", 3, "ngSubmit", 4, "ngIf"], [1, "stage-header", "flex", "items-center", "justify-between", "px-3", "py-2", "rounded-t-md", "shrink-0"], [1, "text-sm", "text-sky-100"], [1, "hr-btn", "flex", "items-center", "gap-2", 3, "click"], [1, "ph", "ph-users"], [1, "tile-grid", "min-h-0", "overflow-y-auto", "no-scrollbar", 3, "ngClass"], ["class", "tile group relative rounded-xl overflow-hidden aspect-video flex items-center justify-center bg-gradient-to-b from-slate-800 to-slate-900 shadow-md", 3, "video-on", "hand-raised", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "tile", "group", "relative", "rounded-xl", "overflow-hidden", "aspect-video", "flex", "items-center", "justify-center", "bg-gradient-to-b", "from-slate-800", "to-slate-900", "shadow-md"], ["autoplay", "", "playsinline", "", "data-role", "tile", 1, "video-el", "w-full", "h-full", 3, "appSrcObject", "muted", "hidden"], ["data-role", "overlay", 1, "overlay-el"], ["class", "placeholder absolute inset-0 flex items-center justify-center bg-slate-800", 4, "ngIf"], [1, "nameplate", "absolute", "left-3", "bottom-3", "px-3", "py-1", "rounded-full", "text-xs", "font-semibold", "flex", "items-center", "gap-2", "bg-black/50", "backdrop-blur-sm"], [1, "badge", "w-2", "h-2", "rounded-full", 3, "ngClass"], [1, "placeholder", "absolute", "inset-0", "flex", "items-center", "justify-center", "bg-slate-800"], [1, "initials", "w-24", "h-24", "rounded-full", "flex", "items-center", "justify-center", "font-extrabold", "text-2xl", "bg-sky-700/40", "text-white"], ["cdkDrag", "", "cdkDragBoundary", ".stage", 1, "self-video-floating"], ["autoplay", "", "playsinline", "", "class", "w-full h-full object-cover rounded-lg shadow-lg", 3, "appSrcObject", "muted", 4, "ngIf"], ["autoplay", "", "playsinline", "", 1, "w-full", "h-full", "object-cover", "rounded-lg", "shadow-lg", 3, "appSrcObject", "muted"], [1, "hr-btn", "px-3", "py-1", "text-xs", 3, "click"], [1, "flex-1", "max-h-full", "overflow-y-auto", "participants-scroll", "p-4"], [1, "text-sky-100", "text-sm", "mb-2"], ["class", "flex justify-between items-center p-2 bg-slate-800/50 rounded mb-1", 4, "ngFor", "ngForOf"], [1, "flex", "justify-between", "items-center", "p-2", "bg-slate-800/50", "rounded", "mb-1"], [1, "flex", "items-center", "gap-2"], [1, "w-8", "h-8", "rounded-full", "bg-sky-700/40", "flex", "items-center", "justify-center"], ["class", "hand-emoji", 4, "ngIf"], [1, "hand-emoji"], [1, "flex-1", "max-h-full", "overflow-y-auto", "alerts-scroll", "p-4"], [1, "text-red-400", "text-sm", "mb-2"], ["class", "text-sky-300 text-xs", 4, "ngIf"], ["class", "p-2 bg-red-900/50 rounded mb-1", 4, "ngFor", "ngForOf"], [1, "text-sky-300", "text-xs"], [1, "p-2", "bg-red-900/50", "rounded", "mb-1"], [1, "text-xs", "font-semibold", "text-sky-200"], [1, "text-sm", "text-red-300"], [1, "flex-1", "max-h-full", "overflow-y-auto", "chat-scroll", "p-4"], ["class", "p-2 bg-slate-800/60 rounded mb-1", 4, "ngFor", "ngForOf"], [1, "p-2", "bg-slate-800/60", "rounded", "mb-1"], [1, "flex", "border-t", "border-sky-700/10", "p-2", 3, "ngSubmit"], ["name", "chatText", "type", "text", "placeholder", "Message the room...", 1, "flex-1", "rounded-l-full", "px-3", "py-2", "text-sm", "dark-input", 3, "ngModelChange", "ngModel"], ["type", "submit", 1, "px-4", "py-2", "rounded-r-full", "hr-btn"]], template: function Dashboard_Template(rf2, ctx) {
        if (rf2 & 1) {
          \u0275\u0275template(0, Dashboard_main_0_Template, 15, 2, "main", 1)(1, Dashboard_main_1_Template, 52, 23, "main", 2);
        }
        if (rf2 & 2) {
          \u0275\u0275property("ngIf", !ctx.isNameUpdated);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.isNameUpdated);
        }
      }, dependencies: [CommonModule, NgClass, NgForOf, NgIf, FormsModule, \u0275NgNoValidate, DefaultValueAccessor, CheckboxControlValueAccessor, NgControlStatus, NgControlStatusGroup, NgModel, NgForm, MediaSrcObjectDirective, SrcObjectDirective, DragDropModule, CdkDrag], styles: ['@charset "UTF-8";\n\n\n\n[_ngcontent-%COMP%]:root {\n  --c1: #09162b;\n  --c2: #1a3463;\n  --c3: #23293b;\n}\nhtml[_ngcontent-%COMP%] {\n  scroll-behavior: smooth;\n}\nbody[_ngcontent-%COMP%] {\n  font-family: "Inter", sans-serif;\n  color: #fff;\n  margin: 0;\n  background:\n    linear-gradient(\n      135deg,\n      var(--c1),\n      var(--c2),\n      var(--c3));\n  background-size: 400% 400%;\n  animation: _ngcontent-%COMP%_gradientShift 12s ease infinite;\n}\n@keyframes _ngcontent-%COMP%_gradientShift {\n  0% {\n    background-position: 0% 50%;\n  }\n  50% {\n    background-position: 100% 50%;\n  }\n  100% {\n    background-position: 0% 50%;\n  }\n}\n#mainHeader[_ngcontent-%COMP%] {\n  transition: background 500ms ease;\n}\n#mainHeader.overlay[_ngcontent-%COMP%] {\n  background:\n    linear-gradient(\n      to bottom,\n      rgba(2, 12, 27, 0.7),\n      rgba(2, 12, 27, 0));\n}\n.frosted[_ngcontent-%COMP%] {\n  -webkit-backdrop-filter: blur(25px);\n  backdrop-filter: blur(25px);\n  background-color: rgba(18, 27, 40, 0.62);\n  border: 1.5px solid rgba(0, 191, 255, 0.14);\n  box-shadow: 0 12px 40px 0 rgba(38, 112, 255, 0.14), -5px 0 25px rgba(0, 191, 255, 0.16);\n}\ninput[_ngcontent-%COMP%]:focus {\n  outline: none;\n  border-color: #0fd9ff;\n  box-shadow: 0 0 0 3px rgba(15, 217, 255, 0.5);\n}\nbutton[_ngcontent-%COMP%], \n.sign-in-btn[_ngcontent-%COMP%] {\n  background:\n    linear-gradient(\n      90deg,\n      #0fd9ff 0%,\n      #2e57ff 100%);\n  box-shadow: 0 2px 30px 0 rgba(40, 75, 255, 0.16);\n  border-radius: 9999px;\n  padding: 0.6rem 1rem;\n}\nbutton[_ngcontent-%COMP%]:hover, \n.sign-in-btn[_ngcontent-%COMP%]:hover {\n  background:\n    linear-gradient(\n      90deg,\n      #51e2f5 0%,\n      #284bff 100%);\n  box-shadow: 0 4px 32px 0 rgba(40, 75, 255, 0.28);\n  color: #fff;\n}\n.text-xl[_ngcontent-%COMP%], \nh1[_ngcontent-%COMP%], \n.font-bold[_ngcontent-%COMP%] {\n  text-shadow: 1px 1px 8px rgba(40, 75, 255, 0.08);\n}\n.placeholder-gray-400[_ngcontent-%COMP%]::placeholder {\n  color: #a8b0c5;\n  opacity: 1;\n}\ncanvas#particles[_ngcontent-%COMP%] {\n  position: fixed;\n  inset: 0;\n  z-index: -1;\n  background:\n    linear-gradient(\n      135deg,\n      var(--c1),\n      var(--c2),\n      var(--c3));\n  background-size: 400% 400%;\n  animation: _ngcontent-%COMP%_gradientShift 12s ease infinite;\n  pointer-events: none;\n}\n#closeLogin[_ngcontent-%COMP%] {\n  z-index: 9999;\n  position: absolute;\n  top: 1.5rem;\n  right: 1.5rem;\n  background: transparent;\n  border: none;\n  cursor: pointer;\n}\n.floating[_ngcontent-%COMP%] {\n  position: relative;\n}\n.floating[_ngcontent-%COMP%]   input.floating-input[_ngcontent-%COMP%] {\n  width: 100%;\n  padding-left: 2.5rem;\n  padding-top: 1.25rem;\n  padding-bottom: 0.5rem;\n  border-radius: 0.5rem;\n  background: rgba(18, 27, 40, 0.55);\n  border: 1px solid rgba(148, 163, 184, 0.12);\n  color: #fff;\n  transition: box-shadow 0.18s ease, border-color 0.18s ease;\n}\n.floating[_ngcontent-%COMP%]   label.floating-label[_ngcontent-%COMP%] {\n  position: absolute;\n  left: 2.5rem;\n  top: 50%;\n  transform: translateY(-50%);\n  font-size: 1rem;\n  color: #a8b0c5;\n  pointer-events: none;\n  transition: all 180ms ease;\n}\n.floating[_ngcontent-%COMP%]   input.floating-input[_ngcontent-%COMP%]:focus    + label.floating-label[_ngcontent-%COMP%], \n.floating[_ngcontent-%COMP%]   input.floating-input[_ngcontent-%COMP%]:not(:placeholder-shown)    + label.floating-label[_ngcontent-%COMP%] {\n  top: 0.3rem;\n  transform: translateY(0);\n  font-size: 0.78rem;\n  color: #0fd9ff;\n}\n.floating[_ngcontent-%COMP%]   input.floating-input[type=password][_ngcontent-%COMP%] {\n  letter-spacing: 0.25em;\n}\n.floating[_ngcontent-%COMP%]   .icon-left[_ngcontent-%COMP%] {\n  pointer-events: none;\n  position: absolute;\n  left: 0.75rem;\n  top: 50%;\n  transform: translateY(-50%);\n  color: #9aa6bb;\n}\n#openLoginBtn[_ngcontent-%COMP%] {\n  z-index: 45;\n}\n.tile-grid-container[_ngcontent-%COMP%] {\n  flex: 1 1 auto;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  position: relative;\n}\n.tile-grid[_ngcontent-%COMP%] {\n  display: grid;\n  width: 100%;\n  height: 100%;\n  gap: 1rem;\n  justify-items: center;\n  grid-auto-rows: 1fr;\n  overflow: hidden;\n}\n.tile-grid.layout-1[_ngcontent-%COMP%] {\n  grid-template-columns: 1fr;\n}\n.tile-grid.layout-2[_ngcontent-%COMP%] {\n  grid-template-columns: 1fr;\n}\n@media (min-width: 768px) {\n  .tile-grid.layout-2[_ngcontent-%COMP%] {\n    grid-template-columns: 1fr 1fr;\n  }\n}\n.tile-grid.layout-3[_ngcontent-%COMP%] {\n  grid-template-columns: 1fr 1fr;\n}\n.tile-grid.layout-4[_ngcontent-%COMP%] {\n  grid-template-columns: 1fr 1fr;\n  grid-template-rows: 1fr 1fr;\n}\n.tile-grid.layout-more[_ngcontent-%COMP%] {\n  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));\n}\n.tile[_ngcontent-%COMP%] {\n  border: 1px solid rgba(0, 191, 255, 0.14);\n  -webkit-backdrop-filter: blur(12px);\n  backdrop-filter: blur(12px);\n  background: rgba(18, 27, 40, 0.55);\n  border-radius: 1rem;\n  overflow: hidden;\n  position: relative;\n  transition: transform 0.3s ease, box-shadow 0.3s ease;\n  width: 100%;\n  height: 100%;\n  min-height: 200px;\n  aspect-ratio: 16/9;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.tile[_ngcontent-%COMP%]   video[_ngcontent-%COMP%] {\n  position: absolute;\n  inset: 0;\n  width: 100%;\n  height: 100%;\n  object-fit: fill;\n  z-index: 1;\n  transform: translateZ(0);\n  will-change: transform;\n  mix-blend-mode: normal;\n}\n.tile[_ngcontent-%COMP%]   .placeholder[_ngcontent-%COMP%] {\n  position: absolute;\n  inset: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: rgba(18, 27, 40, 0.85);\n  z-index: 15;\n}\n.tile[_ngcontent-%COMP%]   .canvas[data-role=overlay][_ngcontent-%COMP%] {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 50;\n  pointer-events: none;\n  display: block;\n  background: transparent;\n  border: 2px solid green;\n  transform: translateZ(0);\n  will-change: transform;\n}\n.nameplate[_ngcontent-%COMP%] {\n  border: 1px solid rgba(0, 191, 255, 0.25);\n  transition: background 0.3s ease, transform 0.3s ease;\n  z-index: 30;\n}\n.nameplate[_ngcontent-%COMP%]:hover {\n  background: rgba(0, 191, 255, 0.25);\n  transform: translateY(-2px);\n}\n.tile[_ngcontent-%COMP%], \n.tile[_ngcontent-%COMP%]   *[_ngcontent-%COMP%] {\n  scrollbar-width: none;\n}\n.tile[_ngcontent-%COMP%]::-webkit-scrollbar, \n.tile[_ngcontent-%COMP%]   *[_ngcontent-%COMP%]::-webkit-scrollbar {\n  display: none;\n}\n@media (max-width: 640px) {\n  .tile-grid[_ngcontent-%COMP%] {\n    grid-template-columns: 1fr;\n    gap: 0.5rem;\n  }\n  .tile[_ngcontent-%COMP%] {\n    min-height: 200px;\n    max-width: 100%;\n  }\n}\n.controls[_ngcontent-%COMP%] {\n  flex-wrap: wrap;\n  gap: 0.75rem;\n  justify-content: center;\n  background: rgba(18, 27, 40, 0.55);\n  border-top: 1px solid rgba(148, 163, 184, 0.12);\n  -webkit-backdrop-filter: blur(12px);\n  backdrop-filter: blur(12px);\n  padding: 1rem;\n  border-radius: 1rem;\n}\n.controls[_ngcontent-%COMP%]   button[_ngcontent-%COMP%] {\n  background: rgba(18, 27, 40, 0.55);\n  border: 1px solid rgba(148, 163, 184, 0.12);\n  -webkit-backdrop-filter: blur(12px);\n  backdrop-filter: blur(12px);\n  transition:\n    background 0.3s ease,\n    box-shadow 0.25s ease,\n    transform 0.15s ease;\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 0.6rem 1rem;\n  border-radius: 9999px;\n}\n.controls[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:active {\n  transform: scale(0.98);\n}\n.controls[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]   i[_ngcontent-%COMP%] {\n  font-size: 1.25rem;\n}\n.controls[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]   span[_ngcontent-%COMP%] {\n  display: inline;\n}\n@media (max-width: 640px) {\n  .controls[_ngcontent-%COMP%] {\n    justify-content: space-around;\n  }\n  .controls[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]   span[_ngcontent-%COMP%] {\n    display: none;\n  }\n}\n.controls[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:hover {\n  background: rgba(40, 75, 255, 0.35);\n  box-shadow: 0 6px 20px rgba(40, 75, 255, 0.25);\n}\n.hr-btn[_ngcontent-%COMP%] {\n  border-radius: 9999px;\n  padding: 0.6rem 1rem;\n  background:\n    linear-gradient(\n      90deg,\n      #0fd9ff 0%,\n      #2e57ff 100%);\n  color: #fff;\n  font-weight: 600;\n  letter-spacing: 0.02em;\n  border: 1px solid rgba(148, 163, 184, 0.12);\n}\n.hr-btn[_ngcontent-%COMP%]:hover {\n  box-shadow: 0 6px 18px rgba(40, 75, 255, 0.28);\n}\n.dark-input[_ngcontent-%COMP%], \ninput[type=text][_ngcontent-%COMP%], \ninput[type=password][_ngcontent-%COMP%], \ntextarea[_ngcontent-%COMP%] {\n  background: rgba(18, 27, 40, 0.55);\n  border: 1px solid rgba(148, 163, 184, 0.12);\n  border-radius: 0.75rem;\n  color: #fff;\n  padding: 0.6rem 0.8rem;\n  transition: border-color 0.2s ease, box-shadow 0.2s ease;\n}\n.dark-input[_ngcontent-%COMP%]:focus, \ninput[type=text][_ngcontent-%COMP%]:focus, \ninput[type=password][_ngcontent-%COMP%]:focus, \ntextarea[_ngcontent-%COMP%]:focus {\n  outline: none;\n  border-color: #0fd9ff;\n  box-shadow: 0 0 0 3px rgba(15, 217, 255, 0.4);\n}\n.chat-panel[_ngcontent-%COMP%]   .participants-scroll[_ngcontent-%COMP%], \n.chat-panel[_ngcontent-%COMP%]   .chat-scroll[_ngcontent-%COMP%] {\n  flex: 1 1 auto;\n  min-height: 0;\n  overflow-y: auto;\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n  scroll-behavior: smooth;\n  -webkit-overflow-scrolling: touch;\n}\n.chat-panel[_ngcontent-%COMP%]   .participants-scroll[_ngcontent-%COMP%]::-webkit-scrollbar, \n.chat-panel[_ngcontent-%COMP%]   .chat-scroll[_ngcontent-%COMP%]::-webkit-scrollbar {\n  display: none;\n}\n.tab-btn[_ngcontent-%COMP%] {\n  position: relative;\n  font-size: 0.875rem;\n  font-weight: 500;\n  padding: 0.4rem 0.75rem;\n  border-radius: 9999px;\n  background: transparent;\n  color: #a8b0c5;\n  transition: all 0.25s ease;\n}\n.tab-btn[_ngcontent-%COMP%]:hover {\n  background: rgba(40, 75, 255, 0.15);\n  color: #fff;\n}\n.tab-btn.active[_ngcontent-%COMP%] {\n  background:\n    linear-gradient(\n      90deg,\n      #0fd9ff 0%,\n      #2e57ff 100%);\n  color: #fff;\n  font-weight: 600;\n  box-shadow: 0 0 12px rgba(40, 75, 255, 0.35);\n}\n.self-placeholder[_ngcontent-%COMP%] {\n  background: rgba(30, 41, 59, 0.7);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.self-video-floating[_ngcontent-%COMP%] {\n  position: absolute;\n  bottom: 1rem;\n  right: 1rem;\n  width: 200px;\n  height: 150px;\n  z-index: 60;\n  border-radius: 0.5rem;\n  overflow: hidden;\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);\n  background: rgba(18, 27, 40, 0.9);\n  border: 1px solid rgba(0, 191, 255, 0.14);\n  transition: opacity 0.3s ease;\n}\n.self-video-floating[_ngcontent-%COMP%]:hover {\n  box-shadow: 0 6px 24px rgba(40, 75, 255, 0.25);\n}\n.tile.hand-raised[_ngcontent-%COMP%] {\n  border-color: #FFD700;\n  box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);\n}\n.hand-emoji[_ngcontent-%COMP%] {\n  font-size: 1.2em;\n  margin-left: 0.2em;\n}\n.tile.suspicious[_ngcontent-%COMP%] {\n  border-color: #ff3b3b;\n  box-shadow: 0 0 25px rgba(255, 59, 59, 0.8), 0 0 45px rgba(255, 59, 59, 0.6);\n  animation: _ngcontent-%COMP%_suspiciousPulse 1.5s infinite alternate;\n}\n@keyframes _ngcontent-%COMP%_suspiciousPulse {\n  0% {\n    box-shadow: 0 0 15px rgba(255, 59, 59, 0.6), 0 0 25px rgba(255, 59, 59, 0.4);\n  }\n  100% {\n    box-shadow: 0 0 35px rgba(255, 59, 59, 0.9), 0 0 55px rgba(255, 59, 59, 0.7);\n  }\n}\n.tile[_ngcontent-%COMP%] {\n  position: relative;\n}\n.tile[_ngcontent-%COMP%]   .video-el[_ngcontent-%COMP%] {\n  position: absolute;\n  inset: 0;\n  width: 100%;\n  height: 100%;\n  object-fit: fill;\n  background: #000;\n  z-index: 1;\n  transform: translateZ(0);\n  will-change: transform;\n  mix-blend-mode: normal;\n}\n.tile[_ngcontent-%COMP%]   .overlay-el[_ngcontent-%COMP%] {\n  position: absolute;\n  inset: 0;\n  width: 100% !important;\n  height: 100% !important;\n  display: block;\n  background: transparent;\n  pointer-events: none;\n  z-index: 5;\n}\n.tile[_ngcontent-%COMP%]   .placeholder[_ngcontent-%COMP%] {\n  z-index: 2;\n}\n.tile[_ngcontent-%COMP%]   .nameplate[_ngcontent-%COMP%] {\n  z-index: 10;\n}\n.tile.suspicious[_ngcontent-%COMP%] {\n  border-color: #ff3b3b;\n  box-shadow: 0 0 25px rgba(255, 59, 59, 0.8), 0 0 45px rgba(255, 59, 59, 0.6);\n  animation: _ngcontent-%COMP%_suspiciousPulse 1.5s infinite alternate;\n}\n@keyframes _ngcontent-%COMP%_suspiciousPulse {\n  0% {\n    box-shadow: 0 0 15px rgba(255, 59, 59, 0.6), 0 0 25px rgba(255, 59, 59, 0.4);\n  }\n  100% {\n    box-shadow: 0 0 35px rgba(255, 59, 59, 0.9), 0 0 55px rgba(255, 59, 59, 0.7);\n  }\n}\n/*# sourceMappingURL=dashboard.css.map */'] });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Dashboard, [{
        type: Component,
        args: [{ selector: "app-dashboard", standalone: true, imports: [CommonModule, FormsModule, MediaSrcObjectDirective, SrcObjectDirective, DragDropModule], providers: [SignalingService], template: `<main *ngIf="!isNameUpdated">\r
<div class="h-screen flex items-center justify-center bg-slate-900 text-white">\r
  <div class="bg-slate-800 p-6 rounded-xl shadow-xl w-96">\r
    <h2 class="text-xl font-bold mb-4">Join the Room</h2>\r
\r
    <label class="block mb-3">\r
      <span class="text-sm">Enter your name</span>\r
      <input id="nameInput" type="text" placeholder="Enter Your name" [(ngModel)]="userName"\r
        class="mt-1 w-full px-3 py-2 rounded-md bg-slate-700 text-white" />\r
    </label>\r
\r
    <label class="flex items-center gap-2 mb-4">\r
      <input id="termsCheckbox" type="checkbox" [(ngModel)]="termsCheckbox" class="w-4 h-4"/>\r
      <span class="text-sm">I agree to the Terms & Conditions</span>\r
    </label>\r
\r
    <button id="joinBtn" (click)="updateNameFirst()"\r
      class="w-full px-4 py-2 rounded-lg bg-sky-600 hover:bg-sky-700 disabled:opacity-50">\r
      Join Room\r
    </button>\r
  </div>\r
</div>\r
</main>\r
\r
<main *ngIf="isNameUpdated" class="h-screen text-white grid grid-cols-1 lg:grid-cols-[1fr_340px] gap-4 p-4 overflow-hidden items-stretch"\r
      [class.chat-open]="!chatCollapsed">\r
\r
  <!-- Stage -->\r
  <section class="stage flex-1 flex flex-col relative min-h-0">\r
    <div *ngIf="!isDesktop" class="stage-header flex items-center justify-between px-3 py-2 rounded-t-md shrink-0">\r
      <div class="text-sm text-sky-100">Room: <strong>#{{ roomName }}</strong></div>\r
      <button class="hr-btn flex items-center gap-2" (click)="toggleChat()">\r
        <i class="ph ph-users"></i> Menu\r
      </button>\r
    </div>\r
\r
    <div class="tile-grid-container flex-1 min-h-0 p-4 gap-6 border border-sky-700/40 rounded-xl bg-slate-900/40 flex flex-col overflow-hidden">\r
      <!-- Full Video (when one person has video on)\r
      <div *ngIf="fullParticipant" class="full-video-container flex-1 min-h-0">\r
        <div class="tile group rounded-xl overflow-hidden flex items-center justify-center bg-gradient-to-b from-slate-800 to-slate-900 shadow-md hover:shadow-xl transition-all duration-300">\r
          <video *ngIf="fullParticipant.stream"\r
                 [appSrcObject]="fullParticipant.stream"\r
                 [muted]="!!fullParticipant.isYou"\r
                 autoplay playsinline\r
                 class="absolute inset-0 w-full h-full object-cover"></video>\r
          <audio *ngIf="fullParticipant.stream && !fullParticipant.isYou"\r
                 [appSrcObject]="fullParticipant.stream" autoplay></audio>\r
          <div class="placeholder flex items-center justify-center w-full h-full"\r
               *ngIf="!fullParticipant.stream">\r
            <div class="initials w-24 h-24 rounded-full flex items-center justify-center font-extrabold text-2xl bg-sky-700/40 text-white">\r
              {{ fullParticipant.initials }}\r
            </div>\r
          </div>\r
          <div class="nameplate absolute left-3 bottom-3 px-3 py-1 rounded-full text-xs font-semibold flex items-center gap-2 bg-black/50 backdrop-blur-sm">\r
            <span class="badge w-2 h-2 rounded-full"\r
                  [ngClass]="{ 'bg-green-400': fullParticipant.mic==='on', 'bg-red-400': fullParticipant.mic==='off' }"></span>\r
            {{ fullParticipant.name }}\r
          </div>\r
        </div>\r
      </div> -->\r
\r
      <!-- Video Tiles Grid -->\r
      <div class="tile-grid min-h-0 overflow-y-auto no-scrollbar"\r
           [ngClass]="{\r
             'layout-1': gridParticipants.length === 1,\r
             'layout-2': gridParticipants.length === 2,\r
             'layout-3': gridParticipants.length === 3,\r
             'layout-4': gridParticipants.length === 4,\r
             'layout-more': gridParticipants.length > 4\r
           }"\r
           *ngIf="gridParticipants.length > 0">\r
           <div class="tile group relative rounded-xl overflow-hidden aspect-video flex items-center justify-center bg-gradient-to-b from-slate-800 to-slate-900 shadow-md"\r
     *ngFor="let p of gridParticipants; trackBy: trackByParticipant"\r
     [class.video-on]="p.videoOn"\r
     [class.hand-raised]="p.handRaised">\r
\r
  <!-- Keep video & canvas as siblings in same stacking context -->\r
  <video\r
    [appSrcObject]="p.stream"\r
    [muted]="!!p.isYou"\r
    autoplay playsinline\r
    class="video-el w-full h-full"\r
    [attr.data-chan]="p.channel"\r
    [hidden]="!p.stream || !p.videoOn"\r
    data-role="tile">\r
  </video>\r
\r
  <canvas\r
    class="overlay-el"\r
    [attr.data-chan]="p.channel"\r
    data-role="overlay">\r
  </canvas>\r
\r
  <!-- Placeholder initials when no video -->\r
  <div class="placeholder absolute inset-0 flex items-center justify-center bg-slate-800"\r
       *ngIf="!p.stream || !p.videoOn">\r
    <div class="initials w-24 h-24 rounded-full flex items-center justify-center font-extrabold text-2xl bg-sky-700/40 text-white">\r
      {{ p.initials }}\r
    </div>\r
  </div>\r
\r
  <!-- Nameplate -->\r
  <div class="nameplate absolute left-3 bottom-3 px-3 py-1 rounded-full text-xs font-semibold flex items-center gap-2 bg-black/50 backdrop-blur-sm">\r
    <span class="badge w-2 h-2 rounded-full"\r
          [ngClass]="{ 'bg-green-400': p.mic==='on', 'bg-red-400': p.mic==='off' }"></span>\r
    {{ p.name }}\r
  </div>\r
</div>\r
\r
      \r
      \r
      </div>\r
\r
      <!-- Controls -->\r
      <div class="controls shrink-0 bg-slate-900/60 backdrop-blur-sm p-4 rounded-lg border-t border-sky-700/30 flex flex-wrap gap-3 justify-center">\r
        <button (click)="toggleMic()" class="ctrl secondary flex items-center gap-2 px-4 py-2 rounded-full">\r
          <i class="ph" [ngClass]="you?.mic === 'on' ? 'ph-microphone' : 'ph-microphone-slash'"></i>\r
          <span>Mic</span>\r
        </button>\r
        <button (click)="toggleCam()" class="ctrl secondary flex items-center gap-2 px-4 py-2 rounded-full">\r
          <i class="ph" [ngClass]="you?.cam === 'on' ? 'ph-video-camera' : 'ph-camera-slash'"></i>\r
          <span>Video</span>\r
        </button>\r
        <button (click)="shareScreen()" class="ctrl secondary flex items-center gap-2 px-4 py-2 rounded-full">\r
          <i class="ph ph-monitor"></i><span>Share</span>\r
        </button>\r
        <button (click)="raiseHand()" class="ctrl secondary flex items-center gap-2 px-4 py-2 rounded-full">\r
          <i class="ph ph-hand"></i><span>Hand</span>\r
        </button>\r
        <button (click)="cycleLayout()" class="ctrl secondary flex items-center gap-2 px-4 py-2 rounded-full">\r
          <i class="ph ph-grid-four"></i><span>Layout</span>\r
        </button>\r
        <button (click)="leaveCall()" class="ctrl danger flex items-center gap-2 px-4 py-2 rounded-full">\r
          <i class="ph ph-sign-out"></i><span>Leave</span>\r
        </button>\r
      </div>\r
    </div>\r
\r
    <!-- Floating Self Video (PiP) -->\r
    <div class="self-video-floating"\r
         *ngIf="shouldShowSelfVideo"\r
         cdkDrag\r
         cdkDragBoundary=".stage">\r
         <video *ngIf="you?.stream"\r
         [appSrcObject]="you?.stream"\r
         [muted]="true"\r
         autoplay playsinline\r
         class="w-full h-full object-cover rounded-lg shadow-lg"></video>\r
    </div>\r
  </section>\r
\r
  <!-- Side Panel with Tabs -->\r
  <aside class="chat-panel frosted lg:static fixed inset-y-0 right-0 w-full max-w-sm transform transition-transform duration-300 flex flex-col z-50 min-h-0 shadow-2xl"\r
         [ngClass]="{ 'translate-x-full': chatCollapsed && !isDesktop, 'translate-x-0': !chatCollapsed || isDesktop }">\r
\r
    <!-- Username -->\r
    <div class="shrink-0 p-3">\r
      <div class="relative floating mt-2">\r
        <i class="ph ph-user icon-left text-sky-300"></i>\r
        <input\r
          id="username"\r
          type="text"\r
          [value]="you?.name || 'You'"\r
          (change)="updateName($event)"\r
          class="floating-input pl-10 pr-3 py-2 text-sm rounded-md w-full dark-input"\r
        />\r
        <label for="username" class="floating-label">update display name from here.</label>\r
      </div>\r
    </div>\r
\r
    <div class="chat-header flex items-center justify-between px-4 py-3 border-b border-sky-700/20 shrink-0">\r
      <div class="flex gap-4">\r
        <button class="tab-btn" [class.active]="activeTab==='participants'" (click)="activeTab='participants'">Participants</button>\r
        <button class="tab-btn" [class.active]="activeTab==='chat'" (click)="activeTab='chat'">Chat</button>\r
        <button class="tab-btn" [class.active]="activeTab==='alerts'" (click)="activeTab='alerts'">Alerts</button>\r
      </div>\r
      <button (click)="closeChat()" *ngIf="!isDesktop" class="hr-btn px-3 py-1 text-xs">Close</button>\r
    </div>\r
\r
    <div class="flex-1 min-h-0 flex flex-col">\r
      <!-- Participants Tab -->\r
      <div class="flex-1 max-h-full overflow-y-auto participants-scroll p-4"\r
           *ngIf="activeTab==='participants'">\r
        <h3 class="text-sky-100 text-sm mb-2">Participants</h3>\r
        <div *ngFor="let p of participants" class="flex justify-between items-center p-2 bg-slate-800/50 rounded mb-1">\r
          <div class="flex items-center gap-2">\r
            <div class="w-8 h-8 rounded-full bg-sky-700/40 flex items-center justify-center"\r
                 [class.hand-raised]="p.handRaised">\r
              <span *ngIf="!p.handRaised">{{ p.initials }}</span>\r
              <span *ngIf="p.handRaised" class="hand-emoji">\u270B</span>\r
            </div>\r
            <span>{{ p.name }}</span>\r
          </div>\r
          <div>\r
            <i class="ph" [ngClass]="p.mic==='on' ? 'ph-microphone' : 'ph-microphone-slash'"></i>\r
            <i class="ph" [ngClass]="p.cam==='on' ? 'ph-video-camera' : 'ph-camera-slash'"></i>\r
          </div>\r
        </div>\r
      </div>\r
\r
      <!-- Alerts Tab -->\r
    <div class="flex-1 max-h-full overflow-y-auto alerts-scroll p-4"\r
    *ngIf="activeTab==='alerts'">\r
    <h3 class="text-red-400 text-sm mb-2">Suspicious Activities</h3>\r
    <div *ngIf="suspiciousEvents.length === 0" class="text-sky-300 text-xs">\r
    No suspicious activity detected yet.\r
    </div>\r
    <div *ngFor="let e of suspiciousEvents" class="p-2 bg-red-900/50 rounded mb-1">\r
    <div class="text-xs font-semibold text-sky-200">{{ e.time }}</div>\r
    <div class="text-sm text-red-300">{{ e.message }}</div>\r
    </div>\r
    </div>\r
\r
      <!-- Chat Tab -->\r
      <div #chatScroll class="flex-1 max-h-full overflow-y-auto chat-scroll p-4"\r
           *ngIf="activeTab==='chat'">\r
        <h3 class="text-sky-100 text-sm mb-2">Chat</h3>\r
        <div *ngFor="let m of chatMessages" class="p-2 bg-slate-800/60 rounded mb-1">\r
          <div class="text-xs font-semibold text-sky-200">{{ m.by }}</div>\r
          <div class="text-sm text-sky-100">{{ m.text }}</div>\r
        </div>\r
      </div>\r
    </div>\r
\r
    <!-- Chat Input (only show when chat tab is active) -->\r
    <form *ngIf="activeTab==='chat'" (ngSubmit)="sendChat()" class="flex border-t border-sky-700/10 p-2">\r
      <input [(ngModel)]="chatText" name="chatText" type="text" placeholder="Message the room..."\r
             class="flex-1 rounded-l-full px-3 py-2 text-sm dark-input"/>\r
      <button type="submit" class="px-4 py-2 rounded-r-full hr-btn">Send</button>\r
    </form>\r
  </aside>\r
</main>\r
`, styles: ['@charset "UTF-8";\n\n/* src/app/dashboard/dashboard.scss */\n:root {\n  --c1: #09162b;\n  --c2: #1a3463;\n  --c3: #23293b;\n}\nhtml {\n  scroll-behavior: smooth;\n}\nbody {\n  font-family: "Inter", sans-serif;\n  color: #fff;\n  margin: 0;\n  background:\n    linear-gradient(\n      135deg,\n      var(--c1),\n      var(--c2),\n      var(--c3));\n  background-size: 400% 400%;\n  animation: gradientShift 12s ease infinite;\n}\n@keyframes gradientShift {\n  0% {\n    background-position: 0% 50%;\n  }\n  50% {\n    background-position: 100% 50%;\n  }\n  100% {\n    background-position: 0% 50%;\n  }\n}\n#mainHeader {\n  transition: background 500ms ease;\n}\n#mainHeader.overlay {\n  background:\n    linear-gradient(\n      to bottom,\n      rgba(2, 12, 27, 0.7),\n      rgba(2, 12, 27, 0));\n}\n.frosted {\n  -webkit-backdrop-filter: blur(25px);\n  backdrop-filter: blur(25px);\n  background-color: rgba(18, 27, 40, 0.62);\n  border: 1.5px solid rgba(0, 191, 255, 0.14);\n  box-shadow: 0 12px 40px 0 rgba(38, 112, 255, 0.14), -5px 0 25px rgba(0, 191, 255, 0.16);\n}\ninput:focus {\n  outline: none;\n  border-color: #0fd9ff;\n  box-shadow: 0 0 0 3px rgba(15, 217, 255, 0.5);\n}\nbutton,\n.sign-in-btn {\n  background:\n    linear-gradient(\n      90deg,\n      #0fd9ff 0%,\n      #2e57ff 100%);\n  box-shadow: 0 2px 30px 0 rgba(40, 75, 255, 0.16);\n  border-radius: 9999px;\n  padding: 0.6rem 1rem;\n}\nbutton:hover,\n.sign-in-btn:hover {\n  background:\n    linear-gradient(\n      90deg,\n      #51e2f5 0%,\n      #284bff 100%);\n  box-shadow: 0 4px 32px 0 rgba(40, 75, 255, 0.28);\n  color: #fff;\n}\n.text-xl,\nh1,\n.font-bold {\n  text-shadow: 1px 1px 8px rgba(40, 75, 255, 0.08);\n}\n.placeholder-gray-400::placeholder {\n  color: #a8b0c5;\n  opacity: 1;\n}\ncanvas#particles {\n  position: fixed;\n  inset: 0;\n  z-index: -1;\n  background:\n    linear-gradient(\n      135deg,\n      var(--c1),\n      var(--c2),\n      var(--c3));\n  background-size: 400% 400%;\n  animation: gradientShift 12s ease infinite;\n  pointer-events: none;\n}\n#closeLogin {\n  z-index: 9999;\n  position: absolute;\n  top: 1.5rem;\n  right: 1.5rem;\n  background: transparent;\n  border: none;\n  cursor: pointer;\n}\n.floating {\n  position: relative;\n}\n.floating input.floating-input {\n  width: 100%;\n  padding-left: 2.5rem;\n  padding-top: 1.25rem;\n  padding-bottom: 0.5rem;\n  border-radius: 0.5rem;\n  background: rgba(18, 27, 40, 0.55);\n  border: 1px solid rgba(148, 163, 184, 0.12);\n  color: #fff;\n  transition: box-shadow 0.18s ease, border-color 0.18s ease;\n}\n.floating label.floating-label {\n  position: absolute;\n  left: 2.5rem;\n  top: 50%;\n  transform: translateY(-50%);\n  font-size: 1rem;\n  color: #a8b0c5;\n  pointer-events: none;\n  transition: all 180ms ease;\n}\n.floating input.floating-input:focus + label.floating-label,\n.floating input.floating-input:not(:placeholder-shown) + label.floating-label {\n  top: 0.3rem;\n  transform: translateY(0);\n  font-size: 0.78rem;\n  color: #0fd9ff;\n}\n.floating input.floating-input[type=password] {\n  letter-spacing: 0.25em;\n}\n.floating .icon-left {\n  pointer-events: none;\n  position: absolute;\n  left: 0.75rem;\n  top: 50%;\n  transform: translateY(-50%);\n  color: #9aa6bb;\n}\n#openLoginBtn {\n  z-index: 45;\n}\n.tile-grid-container {\n  flex: 1 1 auto;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  position: relative;\n}\n.tile-grid {\n  display: grid;\n  width: 100%;\n  height: 100%;\n  gap: 1rem;\n  justify-items: center;\n  grid-auto-rows: 1fr;\n  overflow: hidden;\n}\n.tile-grid.layout-1 {\n  grid-template-columns: 1fr;\n}\n.tile-grid.layout-2 {\n  grid-template-columns: 1fr;\n}\n@media (min-width: 768px) {\n  .tile-grid.layout-2 {\n    grid-template-columns: 1fr 1fr;\n  }\n}\n.tile-grid.layout-3 {\n  grid-template-columns: 1fr 1fr;\n}\n.tile-grid.layout-4 {\n  grid-template-columns: 1fr 1fr;\n  grid-template-rows: 1fr 1fr;\n}\n.tile-grid.layout-more {\n  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));\n}\n.tile {\n  border: 1px solid rgba(0, 191, 255, 0.14);\n  -webkit-backdrop-filter: blur(12px);\n  backdrop-filter: blur(12px);\n  background: rgba(18, 27, 40, 0.55);\n  border-radius: 1rem;\n  overflow: hidden;\n  position: relative;\n  transition: transform 0.3s ease, box-shadow 0.3s ease;\n  width: 100%;\n  height: 100%;\n  min-height: 200px;\n  aspect-ratio: 16/9;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.tile video {\n  position: absolute;\n  inset: 0;\n  width: 100%;\n  height: 100%;\n  object-fit: fill;\n  z-index: 1;\n  transform: translateZ(0);\n  will-change: transform;\n  mix-blend-mode: normal;\n}\n.tile .placeholder {\n  position: absolute;\n  inset: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: rgba(18, 27, 40, 0.85);\n  z-index: 15;\n}\n.tile .canvas[data-role=overlay] {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 50;\n  pointer-events: none;\n  display: block;\n  background: transparent;\n  border: 2px solid green;\n  transform: translateZ(0);\n  will-change: transform;\n}\n.nameplate {\n  border: 1px solid rgba(0, 191, 255, 0.25);\n  transition: background 0.3s ease, transform 0.3s ease;\n  z-index: 30;\n}\n.nameplate:hover {\n  background: rgba(0, 191, 255, 0.25);\n  transform: translateY(-2px);\n}\n.tile,\n.tile * {\n  scrollbar-width: none;\n}\n.tile::-webkit-scrollbar,\n.tile *::-webkit-scrollbar {\n  display: none;\n}\n@media (max-width: 640px) {\n  .tile-grid {\n    grid-template-columns: 1fr;\n    gap: 0.5rem;\n  }\n  .tile {\n    min-height: 200px;\n    max-width: 100%;\n  }\n}\n.controls {\n  flex-wrap: wrap;\n  gap: 0.75rem;\n  justify-content: center;\n  background: rgba(18, 27, 40, 0.55);\n  border-top: 1px solid rgba(148, 163, 184, 0.12);\n  -webkit-backdrop-filter: blur(12px);\n  backdrop-filter: blur(12px);\n  padding: 1rem;\n  border-radius: 1rem;\n}\n.controls button {\n  background: rgba(18, 27, 40, 0.55);\n  border: 1px solid rgba(148, 163, 184, 0.12);\n  -webkit-backdrop-filter: blur(12px);\n  backdrop-filter: blur(12px);\n  transition:\n    background 0.3s ease,\n    box-shadow 0.25s ease,\n    transform 0.15s ease;\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 0.6rem 1rem;\n  border-radius: 9999px;\n}\n.controls button:active {\n  transform: scale(0.98);\n}\n.controls button i {\n  font-size: 1.25rem;\n}\n.controls button span {\n  display: inline;\n}\n@media (max-width: 640px) {\n  .controls {\n    justify-content: space-around;\n  }\n  .controls button span {\n    display: none;\n  }\n}\n.controls button:hover {\n  background: rgba(40, 75, 255, 0.35);\n  box-shadow: 0 6px 20px rgba(40, 75, 255, 0.25);\n}\n.hr-btn {\n  border-radius: 9999px;\n  padding: 0.6rem 1rem;\n  background:\n    linear-gradient(\n      90deg,\n      #0fd9ff 0%,\n      #2e57ff 100%);\n  color: #fff;\n  font-weight: 600;\n  letter-spacing: 0.02em;\n  border: 1px solid rgba(148, 163, 184, 0.12);\n}\n.hr-btn:hover {\n  box-shadow: 0 6px 18px rgba(40, 75, 255, 0.28);\n}\n.dark-input,\ninput[type=text],\ninput[type=password],\ntextarea {\n  background: rgba(18, 27, 40, 0.55);\n  border: 1px solid rgba(148, 163, 184, 0.12);\n  border-radius: 0.75rem;\n  color: #fff;\n  padding: 0.6rem 0.8rem;\n  transition: border-color 0.2s ease, box-shadow 0.2s ease;\n}\n.dark-input:focus,\ninput[type=text]:focus,\ninput[type=password]:focus,\ntextarea:focus {\n  outline: none;\n  border-color: #0fd9ff;\n  box-shadow: 0 0 0 3px rgba(15, 217, 255, 0.4);\n}\n.chat-panel .participants-scroll,\n.chat-panel .chat-scroll {\n  flex: 1 1 auto;\n  min-height: 0;\n  overflow-y: auto;\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n  scroll-behavior: smooth;\n  -webkit-overflow-scrolling: touch;\n}\n.chat-panel .participants-scroll::-webkit-scrollbar,\n.chat-panel .chat-scroll::-webkit-scrollbar {\n  display: none;\n}\n.tab-btn {\n  position: relative;\n  font-size: 0.875rem;\n  font-weight: 500;\n  padding: 0.4rem 0.75rem;\n  border-radius: 9999px;\n  background: transparent;\n  color: #a8b0c5;\n  transition: all 0.25s ease;\n}\n.tab-btn:hover {\n  background: rgba(40, 75, 255, 0.15);\n  color: #fff;\n}\n.tab-btn.active {\n  background:\n    linear-gradient(\n      90deg,\n      #0fd9ff 0%,\n      #2e57ff 100%);\n  color: #fff;\n  font-weight: 600;\n  box-shadow: 0 0 12px rgba(40, 75, 255, 0.35);\n}\n.self-placeholder {\n  background: rgba(30, 41, 59, 0.7);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.self-video-floating {\n  position: absolute;\n  bottom: 1rem;\n  right: 1rem;\n  width: 200px;\n  height: 150px;\n  z-index: 60;\n  border-radius: 0.5rem;\n  overflow: hidden;\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);\n  background: rgba(18, 27, 40, 0.9);\n  border: 1px solid rgba(0, 191, 255, 0.14);\n  transition: opacity 0.3s ease;\n}\n.self-video-floating:hover {\n  box-shadow: 0 6px 24px rgba(40, 75, 255, 0.25);\n}\n.tile.hand-raised {\n  border-color: #FFD700;\n  box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);\n}\n.hand-emoji {\n  font-size: 1.2em;\n  margin-left: 0.2em;\n}\n.tile.suspicious {\n  border-color: #ff3b3b;\n  box-shadow: 0 0 25px rgba(255, 59, 59, 0.8), 0 0 45px rgba(255, 59, 59, 0.6);\n  animation: suspiciousPulse 1.5s infinite alternate;\n}\n@keyframes suspiciousPulse {\n  0% {\n    box-shadow: 0 0 15px rgba(255, 59, 59, 0.6), 0 0 25px rgba(255, 59, 59, 0.4);\n  }\n  100% {\n    box-shadow: 0 0 35px rgba(255, 59, 59, 0.9), 0 0 55px rgba(255, 59, 59, 0.7);\n  }\n}\n.tile {\n  position: relative;\n}\n.tile .video-el {\n  position: absolute;\n  inset: 0;\n  width: 100%;\n  height: 100%;\n  object-fit: fill;\n  background: #000;\n  z-index: 1;\n  transform: translateZ(0);\n  will-change: transform;\n  mix-blend-mode: normal;\n}\n.tile .overlay-el {\n  position: absolute;\n  inset: 0;\n  width: 100% !important;\n  height: 100% !important;\n  display: block;\n  background: transparent;\n  pointer-events: none;\n  z-index: 5;\n}\n.tile .placeholder {\n  z-index: 2;\n}\n.tile .nameplate {\n  z-index: 10;\n}\n.tile.suspicious {\n  border-color: #ff3b3b;\n  box-shadow: 0 0 25px rgba(255, 59, 59, 0.8), 0 0 45px rgba(255, 59, 59, 0.6);\n  animation: suspiciousPulse 1.5s infinite alternate;\n}\n@keyframes suspiciousPulse {\n  0% {\n    box-shadow: 0 0 15px rgba(255, 59, 59, 0.6), 0 0 25px rgba(255, 59, 59, 0.4);\n  }\n  100% {\n    box-shadow: 0 0 35px rgba(255, 59, 59, 0.9), 0 0 55px rgba(255, 59, 59, 0.7);\n  }\n}\n/*# sourceMappingURL=dashboard.css.map */\n'] }]
      }], () => [{ type: SignalingService }], { chatScroll: [{
        type: ViewChild,
        args: ["chatScroll"]
      }], videoTiles: [{
        type: ViewChildren,
        args: ["videoTile"]
      }], canvasTiles: [{
        type: ViewChildren,
        args: ["canvasTile"]
      }], onBeforeUnload: [{
        type: HostListener,
        args: ["window:beforeunload"]
      }], onResize: [{
        type: HostListener,
        args: ["window:resize"]
      }] });
    })();
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(Dashboard, { className: "Dashboard", filePath: "src/app/dashboard/dashboard.ts", lineNumber: 114 });
    })();
  }
});

// src/app/app.routes.ts
var routes;
var init_app_routes = __esm({
  "src/app/app.routes.ts"() {
    "use strict";
    init_dashboard();
    routes = [
      {
        path: "video-call",
        component: Dashboard
      },
      {
        path: "",
        redirectTo: "video-call",
        pathMatch: "full"
      }
    ];
  }
});

// src/app/app.config.ts
var appConfig;
var init_app_config = __esm({
  "src/app/app.config.ts"() {
    "use strict";
    init_core();
    init_router();
    init_app_routes();
    appConfig = {
      providers: [
        provideBrowserGlobalErrorListeners(),
        provideZoneChangeDetection({ eventCoalescing: true }),
        provideRouter(routes)
      ]
    };
  }
});

// src/app/app.ts
var App;
var init_app = __esm({
  "src/app/app.ts"() {
    "use strict";
    init_core();
    init_dashboard();
    init_http();
    init_core();
    App = class _App {
      title = signal("frontend", ...ngDevMode ? [{ debugName: "title" }] : []);
      static \u0275fac = function App_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _App)();
      };
      static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _App, selectors: [["app-root"]], decls: 2, vars: 0, template: function App_Template(rf2, ctx) {
        if (rf2 & 1) {
          \u0275\u0275elementStart(0, "div");
          \u0275\u0275element(1, "app-dashboard");
          \u0275\u0275elementEnd();
        }
      }, dependencies: [
        Dashboard,
        HttpClientModule
      ], styles: ["\n\n#particles[_ngcontent-%COMP%] {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 50%;\n  z-index: 0;\n  pointer-events: none;\n}\n/*# sourceMappingURL=app.css.map */"] });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(App, [{
        type: Component,
        args: [{ selector: "app-root", imports: [
          Dashboard,
          HttpClientModule
        ], template: "<div>\r\n  <app-dashboard></app-dashboard>\r\n</div>\r\n", styles: ["/* src/app/app.scss */\n#particles {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 50%;\n  z-index: 0;\n  pointer-events: none;\n}\n/*# sourceMappingURL=app.css.map */\n"] }]
      }], null, null);
    })();
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(App, { className: "App", filePath: "src/app/app.ts", lineNumber: 14 });
    })();
  }
});

// src/main.ts
var require_main = __commonJS({
  "src/main.ts"() {
    init_platform_browser();
    init_app_config();
    init_app();
    bootstrapApplication(App, appConfig).catch((err) => console.error(err));
  }
});
export default require_main();
/*! Bundled license information:

@angular/core/fesm2022/not_found.mjs:
@angular/core/fesm2022/signal.mjs:
@angular/core/fesm2022/untracked.mjs:
@angular/core/fesm2022/primitives/signals.mjs:
@angular/core/fesm2022/primitives/di.mjs:
@angular/core/fesm2022/root_effect_scheduler.mjs:
@angular/core/fesm2022/resource.mjs:
@angular/common/fesm2022/location.mjs:
@angular/common/fesm2022/common_module.mjs:
@angular/common/fesm2022/xhr.mjs:
@angular/common/fesm2022/common.mjs:
@angular/platform-browser/fesm2022/dom_renderer.mjs:
@angular/platform-browser/fesm2022/browser.mjs:
@angular/common/fesm2022/module.mjs:
@angular/common/fesm2022/http.mjs:
@angular/platform-browser/fesm2022/platform-browser.mjs:
@angular/router/fesm2022/router2.mjs:
@angular/router/fesm2022/router_module.mjs:
@angular/router/fesm2022/router.mjs:
@angular/forms/fesm2022/forms.mjs:
  (**
   * @license Angular v20.1.7
   * (c) 2010-2025 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/core/fesm2022/debug_node.mjs:
@angular/core/fesm2022/core.mjs:
  (**
   * @license Angular v20.1.7
   * (c) 2010-2025 Google LLC. https://angular.io/
   * License: MIT
   *)
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.dev/license
   *)

@tensorflow/tfjs-core/dist/tf-core.esm.js:
  (**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=main.js.map
