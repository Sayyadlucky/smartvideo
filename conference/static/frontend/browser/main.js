var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b ||= {})
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/@angular/core/fesm2022/not_found.mjs
function getCurrentInjector() {
  return _currentInjector;
}
function setCurrentInjector(injector) {
  const former = _currentInjector;
  _currentInjector = injector;
  return former;
}
function isNotFound(e) {
  return e === NOT_FOUND || e?.name === "\u0275NotFound";
}
var _currentInjector, NOT_FOUND;
var init_not_found = __esm({
  "node_modules/@angular/core/fesm2022/not_found.mjs"() {
    "use strict";
    _currentInjector = void 0;
    NOT_FOUND = Symbol("NotFound");
  }
});

// node_modules/@angular/core/fesm2022/signal.mjs
function defaultEquals(a, b) {
  return Object.is(a, b);
}
function setActiveConsumer(consumer) {
  const prev = activeConsumer;
  activeConsumer = consumer;
  return prev;
}
function getActiveConsumer() {
  return activeConsumer;
}
function isInNotificationPhase() {
  return inNotificationPhase;
}
function producerAccessed(node) {
  if (inNotificationPhase) {
    throw new Error(typeof ngDevMode !== "undefined" && ngDevMode ? `Assertion error: signal read during notification phase` : "");
  }
  if (activeConsumer === null) {
    return;
  }
  activeConsumer.consumerOnSignalRead(node);
  const prevProducerLink = activeConsumer.producersTail;
  if (prevProducerLink !== void 0 && prevProducerLink.producer === node) {
    return;
  }
  let nextProducerLink = void 0;
  const isRecomputing = activeConsumer.recomputing;
  if (isRecomputing) {
    nextProducerLink = prevProducerLink !== void 0 ? prevProducerLink.nextProducer : activeConsumer.producers;
    if (nextProducerLink !== void 0 && nextProducerLink.producer === node) {
      activeConsumer.producersTail = nextProducerLink;
      nextProducerLink.lastReadVersion = node.version;
      return;
    }
  }
  const prevConsumerLink = node.consumersTail;
  if (prevConsumerLink !== void 0 && prevConsumerLink.consumer === activeConsumer && // However, we have to make sure that the link we've discovered isn't from a node that is incrementally rebuilding its producer list
  (!isRecomputing || isValidLink(prevConsumerLink, activeConsumer))) {
    return;
  }
  const isLive = consumerIsLive(activeConsumer);
  const newLink = {
    producer: node,
    consumer: activeConsumer,
    // instead of eagerly destroying the previous link, we delay until we've finished recomputing
    // the producers list, so that we can destroy all of the old links at once.
    nextProducer: nextProducerLink,
    prevConsumer: prevConsumerLink,
    lastReadVersion: node.version,
    nextConsumer: void 0
  };
  activeConsumer.producersTail = newLink;
  if (prevProducerLink !== void 0) {
    prevProducerLink.nextProducer = newLink;
  } else {
    activeConsumer.producers = newLink;
  }
  if (isLive) {
    producerAddLiveConsumer(node, newLink);
  }
}
function producerIncrementEpoch() {
  epoch++;
}
function producerUpdateValueVersion(node) {
  if (consumerIsLive(node) && !node.dirty) {
    return;
  }
  if (!node.dirty && node.lastCleanEpoch === epoch) {
    return;
  }
  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {
    producerMarkClean(node);
    return;
  }
  node.producerRecomputeValue(node);
  producerMarkClean(node);
}
function producerNotifyConsumers(node) {
  if (node.consumers === void 0) {
    return;
  }
  const prev = inNotificationPhase;
  inNotificationPhase = true;
  try {
    for (let link = node.consumers; link !== void 0; link = link.nextConsumer) {
      const consumer = link.consumer;
      if (!consumer.dirty) {
        consumerMarkDirty(consumer);
      }
    }
  } finally {
    inNotificationPhase = prev;
  }
}
function producerUpdatesAllowed() {
  return activeConsumer?.consumerAllowSignalWrites !== false;
}
function consumerMarkDirty(node) {
  node.dirty = true;
  producerNotifyConsumers(node);
  node.consumerMarkedDirty?.(node);
}
function producerMarkClean(node) {
  node.dirty = false;
  node.lastCleanEpoch = epoch;
}
function consumerBeforeComputation(node) {
  if (node) {
    node.producersTail = void 0;
    node.recomputing = true;
  }
  return setActiveConsumer(node);
}
function consumerAfterComputation(node, prevConsumer) {
  setActiveConsumer(prevConsumer);
  if (!node) {
    return;
  }
  node.recomputing = false;
  const producersTail = node.producersTail;
  let toRemove = producersTail !== void 0 ? producersTail.nextProducer : node.producers;
  if (toRemove !== void 0) {
    if (consumerIsLive(node)) {
      do {
        toRemove = producerRemoveLiveConsumerLink(toRemove);
      } while (toRemove !== void 0);
    }
    if (producersTail !== void 0) {
      producersTail.nextProducer = void 0;
    } else {
      node.producers = void 0;
    }
  }
}
function consumerPollProducersForChange(node) {
  for (let link = node.producers; link !== void 0; link = link.nextProducer) {
    const producer = link.producer;
    const seenVersion = link.lastReadVersion;
    if (seenVersion !== producer.version) {
      return true;
    }
    producerUpdateValueVersion(producer);
    if (seenVersion !== producer.version) {
      return true;
    }
  }
  return false;
}
function consumerDestroy(node) {
  if (consumerIsLive(node)) {
    let link = node.producers;
    while (link !== void 0) {
      link = producerRemoveLiveConsumerLink(link);
    }
  }
  node.producers = void 0;
  node.producersTail = void 0;
  node.consumers = void 0;
  node.consumersTail = void 0;
}
function producerAddLiveConsumer(node, link) {
  const consumersTail = node.consumersTail;
  const wasLive = consumerIsLive(node);
  if (consumersTail !== void 0) {
    link.nextConsumer = consumersTail.nextConsumer;
    consumersTail.nextConsumer = link;
  } else {
    link.nextConsumer = void 0;
    node.consumers = link;
  }
  link.prevConsumer = consumersTail;
  node.consumersTail = link;
  if (!wasLive) {
    for (let link2 = node.producers; link2 !== void 0; link2 = link2.nextProducer) {
      producerAddLiveConsumer(link2.producer, link2);
    }
  }
}
function producerRemoveLiveConsumerLink(link) {
  const producer = link.producer;
  const nextProducer = link.nextProducer;
  const nextConsumer = link.nextConsumer;
  const prevConsumer = link.prevConsumer;
  link.nextConsumer = void 0;
  link.prevConsumer = void 0;
  if (nextConsumer !== void 0) {
    nextConsumer.prevConsumer = prevConsumer;
  } else {
    producer.consumersTail = prevConsumer;
  }
  if (prevConsumer !== void 0) {
    prevConsumer.nextConsumer = nextConsumer;
  } else {
    producer.consumers = nextConsumer;
    if (!consumerIsLive(producer)) {
      let producerLink = producer.producers;
      while (producerLink !== void 0) {
        producerLink = producerRemoveLiveConsumerLink(producerLink);
      }
    }
  }
  return nextProducer;
}
function consumerIsLive(node) {
  return node.consumerIsAlwaysLive || node.consumers !== void 0;
}
function runPostProducerCreatedFn(node) {
  postProducerCreatedFn?.(node);
}
function isValidLink(checkLink, consumer) {
  const producersTail = consumer.producersTail;
  if (producersTail !== void 0) {
    let link = consumer.producers;
    do {
      if (link === checkLink) {
        return true;
      }
      if (link === producersTail) {
        break;
      }
      link = link.nextProducer;
    } while (link !== void 0);
  }
  return false;
}
function createComputed(computation, equal) {
  const node = Object.create(COMPUTED_NODE);
  node.computation = computation;
  if (equal !== void 0) {
    node.equal = equal;
  }
  const computed2 = () => {
    producerUpdateValueVersion(node);
    producerAccessed(node);
    if (node.value === ERRORED) {
      throw node.error;
    }
    return node.value;
  };
  computed2[SIGNAL] = node;
  if (typeof ngDevMode !== "undefined" && ngDevMode) {
    const debugName = node.debugName ? " (" + node.debugName + ")" : "";
    computed2.toString = () => `[Computed${debugName}: ${node.value}]`;
  }
  runPostProducerCreatedFn(node);
  return computed2;
}
function defaultThrowError() {
  throw new Error();
}
function throwInvalidWriteToSignalError(node) {
  throwInvalidWriteToSignalErrorFn(node);
}
function setThrowInvalidWriteToSignalError(fn) {
  throwInvalidWriteToSignalErrorFn = fn;
}
function createSignal(initialValue, equal) {
  const node = Object.create(SIGNAL_NODE);
  node.value = initialValue;
  if (equal !== void 0) {
    node.equal = equal;
  }
  const getter = () => signalGetFn(node);
  getter[SIGNAL] = node;
  if (typeof ngDevMode !== "undefined" && ngDevMode) {
    const debugName = node.debugName ? " (" + node.debugName + ")" : "";
    getter.toString = () => `[Signal${debugName}: ${node.value}]`;
  }
  runPostProducerCreatedFn(node);
  const set = (newValue) => signalSetFn(node, newValue);
  const update = (updateFn) => signalUpdateFn(node, updateFn);
  return [getter, set, update];
}
function signalGetFn(node) {
  producerAccessed(node);
  return node.value;
}
function signalSetFn(node, newValue) {
  if (!producerUpdatesAllowed()) {
    throwInvalidWriteToSignalError(node);
  }
  if (!node.equal(node.value, newValue)) {
    node.value = newValue;
    signalValueChanged(node);
  }
}
function signalUpdateFn(node, updater) {
  if (!producerUpdatesAllowed()) {
    throwInvalidWriteToSignalError(node);
  }
  signalSetFn(node, updater(node.value));
}
function signalValueChanged(node) {
  node.version++;
  producerIncrementEpoch();
  producerNotifyConsumers(node);
  postSignalSetFn?.(node);
}
var activeConsumer, inNotificationPhase, epoch, postProducerCreatedFn, SIGNAL, REACTIVE_NODE, UNSET, COMPUTING, ERRORED, COMPUTED_NODE, throwInvalidWriteToSignalErrorFn, postSignalSetFn, SIGNAL_NODE;
var init_signal = __esm({
  "node_modules/@angular/core/fesm2022/signal.mjs"() {
    "use strict";
    activeConsumer = null;
    inNotificationPhase = false;
    epoch = 1;
    postProducerCreatedFn = null;
    SIGNAL = /* @__PURE__ */ Symbol("SIGNAL");
    REACTIVE_NODE = {
      version: 0,
      lastCleanEpoch: 0,
      dirty: false,
      producers: void 0,
      producersTail: void 0,
      consumers: void 0,
      consumersTail: void 0,
      recomputing: false,
      consumerAllowSignalWrites: false,
      consumerIsAlwaysLive: false,
      kind: "unknown",
      producerMustRecompute: () => false,
      producerRecomputeValue: () => {
      },
      consumerMarkedDirty: () => {
      },
      consumerOnSignalRead: () => {
      }
    };
    UNSET = /* @__PURE__ */ Symbol("UNSET");
    COMPUTING = /* @__PURE__ */ Symbol("COMPUTING");
    ERRORED = /* @__PURE__ */ Symbol("ERRORED");
    COMPUTED_NODE = /* @__PURE__ */ (() => {
      return __spreadProps(__spreadValues({}, REACTIVE_NODE), {
        value: UNSET,
        dirty: true,
        error: null,
        equal: defaultEquals,
        kind: "computed",
        producerMustRecompute(node) {
          return node.value === UNSET || node.value === COMPUTING;
        },
        producerRecomputeValue(node) {
          if (node.value === COMPUTING) {
            throw new Error(typeof ngDevMode !== "undefined" && ngDevMode ? "Detected cycle in computations." : "");
          }
          const oldValue = node.value;
          node.value = COMPUTING;
          const prevConsumer = consumerBeforeComputation(node);
          let newValue;
          let wasEqual = false;
          try {
            newValue = node.computation();
            setActiveConsumer(null);
            wasEqual = oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue);
          } catch (err) {
            newValue = ERRORED;
            node.error = err;
          } finally {
            consumerAfterComputation(node, prevConsumer);
          }
          if (wasEqual) {
            node.value = oldValue;
            return;
          }
          node.value = newValue;
          node.version++;
        }
      });
    })();
    throwInvalidWriteToSignalErrorFn = defaultThrowError;
    postSignalSetFn = null;
    SIGNAL_NODE = /* @__PURE__ */ (() => {
      return __spreadProps(__spreadValues({}, REACTIVE_NODE), {
        equal: defaultEquals,
        value: void 0,
        kind: "signal"
      });
    })();
  }
});

// node_modules/rxjs/dist/esm/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}
var init_isFunction = __esm({
  "node_modules/rxjs/dist/esm/internal/util/isFunction.js"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  const _super = (instance) => {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  const ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var init_createErrorClass = __esm({
  "node_modules/rxjs/dist/esm/internal/util/createErrorClass.js"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/util/UnsubscriptionError.js
var UnsubscriptionError;
var init_UnsubscriptionError = __esm({
  "node_modules/rxjs/dist/esm/internal/util/UnsubscriptionError.js"() {
    "use strict";
    init_createErrorClass();
    UnsubscriptionError = createErrorClass((_super) => function UnsubscriptionErrorImpl(errors) {
      _super(this);
      this.message = errors ? `${errors.length} errors occurred during unsubscription:
${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join("\n  ")}` : "";
      this.name = "UnsubscriptionError";
      this.errors = errors;
    });
  }
});

// node_modules/rxjs/dist/esm/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    const index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
var init_arrRemove = __esm({
  "node_modules/rxjs/dist/esm/internal/util/arrRemove.js"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/Subscription.js
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var Subscription, EMPTY_SUBSCRIPTION;
var init_Subscription = __esm({
  "node_modules/rxjs/dist/esm/internal/Subscription.js"() {
    "use strict";
    init_isFunction();
    init_UnsubscriptionError();
    init_arrRemove();
    Subscription = class _Subscription {
      constructor(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
      }
      unsubscribe() {
        let errors;
        if (!this.closed) {
          this.closed = true;
          const { _parentage } = this;
          if (_parentage) {
            this._parentage = null;
            if (Array.isArray(_parentage)) {
              for (const parent of _parentage) {
                parent.remove(this);
              }
            } else {
              _parentage.remove(this);
            }
          }
          const { initialTeardown: initialFinalizer } = this;
          if (isFunction(initialFinalizer)) {
            try {
              initialFinalizer();
            } catch (e) {
              errors = e instanceof UnsubscriptionError ? e.errors : [e];
            }
          }
          const { _finalizers } = this;
          if (_finalizers) {
            this._finalizers = null;
            for (const finalizer of _finalizers) {
              try {
                execFinalizer(finalizer);
              } catch (err) {
                errors = errors !== null && errors !== void 0 ? errors : [];
                if (err instanceof UnsubscriptionError) {
                  errors = [...errors, ...err.errors];
                } else {
                  errors.push(err);
                }
              }
            }
          }
          if (errors) {
            throw new UnsubscriptionError(errors);
          }
        }
      }
      add(teardown) {
        var _a2;
        if (teardown && teardown !== this) {
          if (this.closed) {
            execFinalizer(teardown);
          } else {
            if (teardown instanceof _Subscription) {
              if (teardown.closed || teardown._hasParent(this)) {
                return;
              }
              teardown._addParent(this);
            }
            (this._finalizers = (_a2 = this._finalizers) !== null && _a2 !== void 0 ? _a2 : []).push(teardown);
          }
        }
      }
      _hasParent(parent) {
        const { _parentage } = this;
        return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
      }
      _addParent(parent) {
        const { _parentage } = this;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
      }
      _removeParent(parent) {
        const { _parentage } = this;
        if (_parentage === parent) {
          this._parentage = null;
        } else if (Array.isArray(_parentage)) {
          arrRemove(_parentage, parent);
        }
      }
      remove(teardown) {
        const { _finalizers } = this;
        _finalizers && arrRemove(_finalizers, teardown);
        if (teardown instanceof _Subscription) {
          teardown._removeParent(this);
        }
      }
    };
    Subscription.EMPTY = (() => {
      const empty2 = new Subscription();
      empty2.closed = true;
      return empty2;
    })();
    EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  }
});

// node_modules/rxjs/dist/esm/internal/config.js
var config;
var init_config = __esm({
  "node_modules/rxjs/dist/esm/internal/config.js"() {
    "use strict";
    config = {
      onUnhandledError: null,
      onStoppedNotification: null,
      Promise: void 0,
      useDeprecatedSynchronousErrorHandling: false,
      useDeprecatedNextContext: false
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/timeoutProvider.js
var timeoutProvider;
var init_timeoutProvider = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/timeoutProvider.js"() {
    "use strict";
    timeoutProvider = {
      setTimeout(handler, timeout, ...args) {
        const { delegate } = timeoutProvider;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
          return delegate.setTimeout(handler, timeout, ...args);
        }
        return setTimeout(handler, timeout, ...args);
      },
      clearTimeout(handle) {
        const { delegate } = timeoutProvider;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(() => {
    const { onUnhandledError } = config;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}
var init_reportUnhandledError = __esm({
  "node_modules/rxjs/dist/esm/internal/util/reportUnhandledError.js"() {
    "use strict";
    init_config();
    init_timeoutProvider();
  }
});

// node_modules/rxjs/dist/esm/internal/util/noop.js
function noop() {
}
var init_noop = __esm({
  "node_modules/rxjs/dist/esm/internal/util/noop.js"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/NotificationFactories.js
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}
var COMPLETE_NOTIFICATION;
var init_NotificationFactories = __esm({
  "node_modules/rxjs/dist/esm/internal/NotificationFactories.js"() {
    "use strict";
    COMPLETE_NOTIFICATION = (() => createNotification("C", void 0, void 0))();
  }
});

// node_modules/rxjs/dist/esm/internal/util/errorContext.js
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    const isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      const { errorThrown, error } = context;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}
var context;
var init_errorContext = __esm({
  "node_modules/rxjs/dist/esm/internal/util/errorContext.js"() {
    "use strict";
    init_config();
    context = null;
  }
});

// node_modules/rxjs/dist/esm/internal/Subscriber.js
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  const { onStoppedNotification } = config;
  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));
}
var Subscriber, _bind, ConsumerObserver, SafeSubscriber, EMPTY_OBSERVER;
var init_Subscriber = __esm({
  "node_modules/rxjs/dist/esm/internal/Subscriber.js"() {
    "use strict";
    init_isFunction();
    init_Subscription();
    init_config();
    init_reportUnhandledError();
    init_noop();
    init_NotificationFactories();
    init_timeoutProvider();
    init_errorContext();
    Subscriber = class extends Subscription {
      constructor(destination) {
        super();
        this.isStopped = false;
        if (destination) {
          this.destination = destination;
          if (isSubscription(destination)) {
            destination.add(this);
          }
        } else {
          this.destination = EMPTY_OBSERVER;
        }
      }
      static create(next, error, complete) {
        return new SafeSubscriber(next, error, complete);
      }
      next(value) {
        if (this.isStopped) {
          handleStoppedNotification(nextNotification(value), this);
        } else {
          this._next(value);
        }
      }
      error(err) {
        if (this.isStopped) {
          handleStoppedNotification(errorNotification(err), this);
        } else {
          this.isStopped = true;
          this._error(err);
        }
      }
      complete() {
        if (this.isStopped) {
          handleStoppedNotification(COMPLETE_NOTIFICATION, this);
        } else {
          this.isStopped = true;
          this._complete();
        }
      }
      unsubscribe() {
        if (!this.closed) {
          this.isStopped = true;
          super.unsubscribe();
          this.destination = null;
        }
      }
      _next(value) {
        this.destination.next(value);
      }
      _error(err) {
        try {
          this.destination.error(err);
        } finally {
          this.unsubscribe();
        }
      }
      _complete() {
        try {
          this.destination.complete();
        } finally {
          this.unsubscribe();
        }
      }
    };
    _bind = Function.prototype.bind;
    ConsumerObserver = class {
      constructor(partialObserver) {
        this.partialObserver = partialObserver;
      }
      next(value) {
        const { partialObserver } = this;
        if (partialObserver.next) {
          try {
            partialObserver.next(value);
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      }
      error(err) {
        const { partialObserver } = this;
        if (partialObserver.error) {
          try {
            partialObserver.error(err);
          } catch (error) {
            handleUnhandledError(error);
          }
        } else {
          handleUnhandledError(err);
        }
      }
      complete() {
        const { partialObserver } = this;
        if (partialObserver.complete) {
          try {
            partialObserver.complete();
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      }
    };
    SafeSubscriber = class extends Subscriber {
      constructor(observerOrNext, error, complete) {
        super();
        let partialObserver;
        if (isFunction(observerOrNext) || !observerOrNext) {
          partialObserver = {
            next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
            error: error !== null && error !== void 0 ? error : void 0,
            complete: complete !== null && complete !== void 0 ? complete : void 0
          };
        } else {
          let context2;
          if (this && config.useDeprecatedNextContext) {
            context2 = Object.create(observerOrNext);
            context2.unsubscribe = () => this.unsubscribe();
            partialObserver = {
              next: observerOrNext.next && bind(observerOrNext.next, context2),
              error: observerOrNext.error && bind(observerOrNext.error, context2),
              complete: observerOrNext.complete && bind(observerOrNext.complete, context2)
            };
          } else {
            partialObserver = observerOrNext;
          }
        }
        this.destination = new ConsumerObserver(partialObserver);
      }
    };
    EMPTY_OBSERVER = {
      closed: true,
      next: noop,
      error: defaultErrorHandler,
      complete: noop
    };
  }
});

// node_modules/rxjs/dist/esm/internal/symbol/observable.js
var observable;
var init_observable = __esm({
  "node_modules/rxjs/dist/esm/internal/symbol/observable.js"() {
    "use strict";
    observable = (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
  }
});

// node_modules/rxjs/dist/esm/internal/util/identity.js
function identity(x) {
  return x;
}
var init_identity = __esm({
  "node_modules/rxjs/dist/esm/internal/util/identity.js"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/util/pipe.js
function pipe(...fns) {
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input2) {
    return fns.reduce((prev, fn) => fn(prev), input2);
  };
}
var init_pipe = __esm({
  "node_modules/rxjs/dist/esm/internal/util/pipe.js"() {
    "use strict";
    init_identity();
  }
});

// node_modules/rxjs/dist/esm/internal/Observable.js
function getPromiseCtor(promiseCtor) {
  var _a2;
  return (_a2 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a2 !== void 0 ? _a2 : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
var Observable;
var init_Observable = __esm({
  "node_modules/rxjs/dist/esm/internal/Observable.js"() {
    "use strict";
    init_Subscriber();
    init_Subscription();
    init_observable();
    init_pipe();
    init_config();
    init_isFunction();
    init_errorContext();
    Observable = class _Observable {
      constructor(subscribe) {
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      lift(operator2) {
        const observable2 = new _Observable();
        observable2.source = this;
        observable2.operator = operator2;
        return observable2;
      }
      subscribe(observerOrNext, error, complete) {
        const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
        errorContext(() => {
          const { operator: operator2, source } = this;
          subscriber.add(operator2 ? operator2.call(subscriber, source) : source ? this._subscribe(subscriber) : this._trySubscribe(subscriber));
        });
        return subscriber;
      }
      _trySubscribe(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          sink.error(err);
        }
      }
      forEach(next, promiseCtor) {
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor((resolve, reject) => {
          const subscriber = new SafeSubscriber({
            next: (value) => {
              try {
                next(value);
              } catch (err) {
                reject(err);
                subscriber.unsubscribe();
              }
            },
            error: reject,
            complete: resolve
          });
          this.subscribe(subscriber);
        });
      }
      _subscribe(subscriber) {
        var _a2;
        return (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber);
      }
      [observable]() {
        return this;
      }
      pipe(...operations) {
        return pipeFromArray(operations)(this);
      }
      toPromise(promiseCtor) {
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor((resolve, reject) => {
          let value;
          this.subscribe((x) => value = x, (err) => reject(err), () => resolve(value));
        });
      }
    };
    Observable.create = (subscribe) => {
      return new Observable(subscribe);
    };
  }
});

// node_modules/rxjs/dist/esm/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return (source) => {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
var init_lift = __esm({
  "node_modules/rxjs/dist/esm/internal/util/lift.js"() {
    "use strict";
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber;
var init_OperatorSubscriber = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/OperatorSubscriber.js"() {
    "use strict";
    init_Subscriber();
    OperatorSubscriber = class extends Subscriber {
      constructor(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
        super(destination);
        this.onFinalize = onFinalize;
        this.shouldUnsubscribe = shouldUnsubscribe;
        this._next = onNext ? function(value) {
          try {
            onNext(value);
          } catch (err) {
            destination.error(err);
          }
        } : super._next;
        this._error = onError ? function(err) {
          try {
            onError(err);
          } catch (err2) {
            destination.error(err2);
          } finally {
            this.unsubscribe();
          }
        } : super._error;
        this._complete = onComplete ? function() {
          try {
            onComplete();
          } catch (err) {
            destination.error(err);
          } finally {
            this.unsubscribe();
          }
        } : super._complete;
      }
      unsubscribe() {
        var _a2;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
          const { closed } = this;
          super.unsubscribe();
          !closed && ((_a2 = this.onFinalize) === null || _a2 === void 0 ? void 0 : _a2.call(this));
        }
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/operators/refCount.js
function refCount() {
  return operate((source, subscriber) => {
    let connection = null;
    source._refCount++;
    const refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, () => {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      const sharedConnection = source._connection;
      const conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}
var init_refCount = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/refCount.js"() {
    "use strict";
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/ConnectableObservable.js
var ConnectableObservable;
var init_ConnectableObservable = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/ConnectableObservable.js"() {
    "use strict";
    init_Observable();
    init_Subscription();
    init_refCount();
    init_OperatorSubscriber();
    init_lift();
    ConnectableObservable = class extends Observable {
      constructor(source, subjectFactory) {
        super();
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._subject = null;
        this._refCount = 0;
        this._connection = null;
        if (hasLift(source)) {
          this.lift = source.lift;
        }
      }
      _subscribe(subscriber) {
        return this.getSubject().subscribe(subscriber);
      }
      getSubject() {
        const subject = this._subject;
        if (!subject || subject.isStopped) {
          this._subject = this.subjectFactory();
        }
        return this._subject;
      }
      _teardown() {
        this._refCount = 0;
        const { _connection } = this;
        this._subject = this._connection = null;
        _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
      }
      connect() {
        let connection = this._connection;
        if (!connection) {
          connection = this._connection = new Subscription();
          const subject = this.getSubject();
          connection.add(this.source.subscribe(createOperatorSubscriber(subject, void 0, () => {
            this._teardown();
            subject.complete();
          }, (err) => {
            this._teardown();
            subject.error(err);
          }, () => this._teardown())));
          if (connection.closed) {
            this._connection = null;
            connection = Subscription.EMPTY;
          }
        }
        return connection;
      }
      refCount() {
        return refCount()(this);
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/animationFrameProvider.js
var animationFrameProvider;
var init_animationFrameProvider = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/animationFrameProvider.js"() {
    "use strict";
    init_Subscription();
    animationFrameProvider = {
      schedule(callback) {
        let request = requestAnimationFrame;
        let cancel = cancelAnimationFrame;
        const { delegate } = animationFrameProvider;
        if (delegate) {
          request = delegate.requestAnimationFrame;
          cancel = delegate.cancelAnimationFrame;
        }
        const handle = request((timestamp) => {
          cancel = void 0;
          callback(timestamp);
        });
        return new Subscription(() => cancel === null || cancel === void 0 ? void 0 : cancel(handle));
      },
      requestAnimationFrame(...args) {
        const { delegate } = animationFrameProvider;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame)(...args);
      },
      cancelAnimationFrame(...args) {
        const { delegate } = animationFrameProvider;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame)(...args);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError;
var init_ObjectUnsubscribedError = __esm({
  "node_modules/rxjs/dist/esm/internal/util/ObjectUnsubscribedError.js"() {
    "use strict";
    init_createErrorClass();
    ObjectUnsubscribedError = createErrorClass((_super) => function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    });
  }
});

// node_modules/rxjs/dist/esm/internal/Subject.js
var Subject, AnonymousSubject;
var init_Subject = __esm({
  "node_modules/rxjs/dist/esm/internal/Subject.js"() {
    "use strict";
    init_Observable();
    init_Subscription();
    init_ObjectUnsubscribedError();
    init_arrRemove();
    init_errorContext();
    Subject = class extends Observable {
      constructor() {
        super();
        this.closed = false;
        this.currentObservers = null;
        this.observers = [];
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
      }
      lift(operator2) {
        const subject = new AnonymousSubject(this, this);
        subject.operator = operator2;
        return subject;
      }
      _throwIfClosed() {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
      }
      next(value) {
        errorContext(() => {
          this._throwIfClosed();
          if (!this.isStopped) {
            if (!this.currentObservers) {
              this.currentObservers = Array.from(this.observers);
            }
            for (const observer of this.currentObservers) {
              observer.next(value);
            }
          }
        });
      }
      error(err) {
        errorContext(() => {
          this._throwIfClosed();
          if (!this.isStopped) {
            this.hasError = this.isStopped = true;
            this.thrownError = err;
            const { observers: observers2 } = this;
            while (observers2.length) {
              observers2.shift().error(err);
            }
          }
        });
      }
      complete() {
        errorContext(() => {
          this._throwIfClosed();
          if (!this.isStopped) {
            this.isStopped = true;
            const { observers: observers2 } = this;
            while (observers2.length) {
              observers2.shift().complete();
            }
          }
        });
      }
      unsubscribe() {
        this.isStopped = this.closed = true;
        this.observers = this.currentObservers = null;
      }
      get observed() {
        var _a2;
        return ((_a2 = this.observers) === null || _a2 === void 0 ? void 0 : _a2.length) > 0;
      }
      _trySubscribe(subscriber) {
        this._throwIfClosed();
        return super._trySubscribe(subscriber);
      }
      _subscribe(subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
      }
      _innerSubscribe(subscriber) {
        const { hasError, isStopped, observers: observers2 } = this;
        if (hasError || isStopped) {
          return EMPTY_SUBSCRIPTION;
        }
        this.currentObservers = null;
        observers2.push(subscriber);
        return new Subscription(() => {
          this.currentObservers = null;
          arrRemove(observers2, subscriber);
        });
      }
      _checkFinalizedStatuses(subscriber) {
        const { hasError, thrownError, isStopped } = this;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped) {
          subscriber.complete();
        }
      }
      asObservable() {
        const observable2 = new Observable();
        observable2.source = this;
        return observable2;
      }
    };
    Subject.create = (destination, source) => {
      return new AnonymousSubject(destination, source);
    };
    AnonymousSubject = class extends Subject {
      constructor(destination, source) {
        super();
        this.destination = destination;
        this.source = source;
      }
      next(value) {
        var _a2, _b;
        (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.next) === null || _b === void 0 ? void 0 : _b.call(_a2, value);
      }
      error(err) {
        var _a2, _b;
        (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.error) === null || _b === void 0 ? void 0 : _b.call(_a2, err);
      }
      complete() {
        var _a2, _b;
        (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.complete) === null || _b === void 0 ? void 0 : _b.call(_a2);
      }
      _subscribe(subscriber) {
        var _a2, _b;
        return (_b = (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/BehaviorSubject.js
var BehaviorSubject;
var init_BehaviorSubject = __esm({
  "node_modules/rxjs/dist/esm/internal/BehaviorSubject.js"() {
    "use strict";
    init_Subject();
    BehaviorSubject = class extends Subject {
      constructor(_value) {
        super();
        this._value = _value;
      }
      get value() {
        return this.getValue();
      }
      _subscribe(subscriber) {
        const subscription = super._subscribe(subscriber);
        !subscription.closed && subscriber.next(this._value);
        return subscription;
      }
      getValue() {
        const { hasError, thrownError, _value } = this;
        if (hasError) {
          throw thrownError;
        }
        this._throwIfClosed();
        return _value;
      }
      next(value) {
        super.next(this._value = value);
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider;
var init_dateTimestampProvider = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/dateTimestampProvider.js"() {
    "use strict";
    dateTimestampProvider = {
      now() {
        return (dateTimestampProvider.delegate || Date).now();
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm/internal/ReplaySubject.js
var ReplaySubject;
var init_ReplaySubject = __esm({
  "node_modules/rxjs/dist/esm/internal/ReplaySubject.js"() {
    "use strict";
    init_Subject();
    init_dateTimestampProvider();
    ReplaySubject = class extends Subject {
      constructor(_bufferSize = Infinity, _windowTime = Infinity, _timestampProvider = dateTimestampProvider) {
        super();
        this._bufferSize = _bufferSize;
        this._windowTime = _windowTime;
        this._timestampProvider = _timestampProvider;
        this._buffer = [];
        this._infiniteTimeWindow = true;
        this._infiniteTimeWindow = _windowTime === Infinity;
        this._bufferSize = Math.max(1, _bufferSize);
        this._windowTime = Math.max(1, _windowTime);
      }
      next(value) {
        const { isStopped, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;
        if (!isStopped) {
          _buffer.push(value);
          !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
        }
        this._trimBuffer();
        super.next(value);
      }
      _subscribe(subscriber) {
        this._throwIfClosed();
        this._trimBuffer();
        const subscription = this._innerSubscribe(subscriber);
        const { _infiniteTimeWindow, _buffer } = this;
        const copy = _buffer.slice();
        for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
          subscriber.next(copy[i]);
        }
        this._checkFinalizedStatuses(subscriber);
        return subscription;
      }
      _trimBuffer() {
        const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;
        const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
        if (!_infiniteTimeWindow) {
          const now = _timestampProvider.now();
          let last4 = 0;
          for (let i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
            last4 = i;
          }
          last4 && _buffer.splice(0, last4 + 1);
        }
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/Action.js
var Action;
var init_Action = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/Action.js"() {
    "use strict";
    init_Subscription();
    Action = class extends Subscription {
      constructor(scheduler, work) {
        super();
      }
      schedule(state, delay = 0) {
        return this;
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/intervalProvider.js
var intervalProvider;
var init_intervalProvider = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/intervalProvider.js"() {
    "use strict";
    intervalProvider = {
      setInterval(handler, timeout, ...args) {
        const { delegate } = intervalProvider;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
          return delegate.setInterval(handler, timeout, ...args);
        }
        return setInterval(handler, timeout, ...args);
      },
      clearInterval(handle) {
        const { delegate } = intervalProvider;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/AsyncAction.js
var AsyncAction;
var init_AsyncAction = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/AsyncAction.js"() {
    "use strict";
    init_Action();
    init_intervalProvider();
    init_arrRemove();
    AsyncAction = class extends Action {
      constructor(scheduler, work) {
        super(scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
      }
      schedule(state, delay = 0) {
        var _a2;
        if (this.closed) {
          return this;
        }
        this.state = state;
        const id2 = this.id;
        const scheduler = this.scheduler;
        if (id2 != null) {
          this.id = this.recycleAsyncId(scheduler, id2, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = (_a2 = this.id) !== null && _a2 !== void 0 ? _a2 : this.requestAsyncId(scheduler, this.id, delay);
        return this;
      }
      requestAsyncId(scheduler, _id, delay = 0) {
        return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
      }
      recycleAsyncId(_scheduler, id2, delay = 0) {
        if (delay != null && this.delay === delay && this.pending === false) {
          return id2;
        }
        if (id2 != null) {
          intervalProvider.clearInterval(id2);
        }
        return void 0;
      }
      execute(state, delay) {
        if (this.closed) {
          return new Error("executing a cancelled action");
        }
        this.pending = false;
        const error = this._execute(state, delay);
        if (error) {
          return error;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      }
      _execute(state, _delay) {
        let errored = false;
        let errorValue;
        try {
          this.work(state);
        } catch (e) {
          errored = true;
          errorValue = e ? e : new Error("Scheduled action threw falsy error");
        }
        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      }
      unsubscribe() {
        if (!this.closed) {
          const { id: id2, scheduler } = this;
          const { actions } = scheduler;
          this.work = this.state = this.scheduler = null;
          this.pending = false;
          arrRemove(actions, this);
          if (id2 != null) {
            this.id = this.recycleAsyncId(scheduler, id2, null);
          }
          this.delay = null;
          super.unsubscribe();
        }
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/util/Immediate.js
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var nextHandle, resolved, activeHandles, Immediate;
var init_Immediate = __esm({
  "node_modules/rxjs/dist/esm/internal/util/Immediate.js"() {
    "use strict";
    nextHandle = 1;
    activeHandles = {};
    Immediate = {
      setImmediate(cb) {
        const handle = nextHandle++;
        activeHandles[handle] = true;
        if (!resolved) {
          resolved = Promise.resolve();
        }
        resolved.then(() => findAndClearHandle(handle) && cb());
        return handle;
      },
      clearImmediate(handle) {
        findAndClearHandle(handle);
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/immediateProvider.js
var setImmediate, clearImmediate, immediateProvider;
var init_immediateProvider = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/immediateProvider.js"() {
    "use strict";
    init_Immediate();
    ({ setImmediate, clearImmediate } = Immediate);
    immediateProvider = {
      setImmediate(...args) {
        const { delegate } = immediateProvider;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate)(...args);
      },
      clearImmediate(handle) {
        const { delegate } = immediateProvider;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/AsapAction.js
var AsapAction;
var init_AsapAction = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/AsapAction.js"() {
    "use strict";
    init_AsyncAction();
    init_immediateProvider();
    AsapAction = class extends AsyncAction {
      constructor(scheduler, work) {
        super(scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
      }
      requestAsyncId(scheduler, id2, delay = 0) {
        if (delay !== null && delay > 0) {
          return super.requestAsyncId(scheduler, id2, delay);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
      }
      recycleAsyncId(scheduler, id2, delay = 0) {
        var _a2;
        if (delay != null ? delay > 0 : this.delay > 0) {
          return super.recycleAsyncId(scheduler, id2, delay);
        }
        const { actions } = scheduler;
        if (id2 != null && ((_a2 = actions[actions.length - 1]) === null || _a2 === void 0 ? void 0 : _a2.id) !== id2) {
          immediateProvider.clearImmediate(id2);
          if (scheduler._scheduled === id2) {
            scheduler._scheduled = void 0;
          }
        }
        return void 0;
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/Scheduler.js
var Scheduler;
var init_Scheduler = __esm({
  "node_modules/rxjs/dist/esm/internal/Scheduler.js"() {
    "use strict";
    init_dateTimestampProvider();
    Scheduler = class _Scheduler {
      constructor(schedulerActionCtor, now = _Scheduler.now) {
        this.schedulerActionCtor = schedulerActionCtor;
        this.now = now;
      }
      schedule(work, delay = 0, state) {
        return new this.schedulerActionCtor(this, work).schedule(state, delay);
      }
    };
    Scheduler.now = dateTimestampProvider.now;
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/AsyncScheduler.js
var AsyncScheduler;
var init_AsyncScheduler = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/AsyncScheduler.js"() {
    "use strict";
    init_Scheduler();
    AsyncScheduler = class extends Scheduler {
      constructor(SchedulerAction, now = Scheduler.now) {
        super(SchedulerAction, now);
        this.actions = [];
        this._active = false;
      }
      flush(action) {
        const { actions } = this;
        if (this._active) {
          actions.push(action);
          return;
        }
        let error;
        this._active = true;
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift());
        this._active = false;
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/AsapScheduler.js
var AsapScheduler;
var init_AsapScheduler = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/AsapScheduler.js"() {
    "use strict";
    init_AsyncScheduler();
    AsapScheduler = class extends AsyncScheduler {
      flush(action) {
        this._active = true;
        const flushId = this._scheduled;
        this._scheduled = void 0;
        const { actions } = this;
        let error;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/asap.js
var asapScheduler;
var init_asap = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/asap.js"() {
    "use strict";
    init_AsapAction();
    init_AsapScheduler();
    asapScheduler = new AsapScheduler(AsapAction);
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/async.js
var asyncScheduler, async;
var init_async = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/async.js"() {
    "use strict";
    init_AsyncAction();
    init_AsyncScheduler();
    asyncScheduler = new AsyncScheduler(AsyncAction);
    async = asyncScheduler;
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction;
var init_AnimationFrameAction = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/AnimationFrameAction.js"() {
    "use strict";
    init_AsyncAction();
    init_animationFrameProvider();
    AnimationFrameAction = class extends AsyncAction {
      constructor(scheduler, work) {
        super(scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
      }
      requestAsyncId(scheduler, id2, delay = 0) {
        if (delay !== null && delay > 0) {
          return super.requestAsyncId(scheduler, id2, delay);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(() => scheduler.flush(void 0)));
      }
      recycleAsyncId(scheduler, id2, delay = 0) {
        var _a2;
        if (delay != null ? delay > 0 : this.delay > 0) {
          return super.recycleAsyncId(scheduler, id2, delay);
        }
        const { actions } = scheduler;
        if (id2 != null && id2 === scheduler._scheduled && ((_a2 = actions[actions.length - 1]) === null || _a2 === void 0 ? void 0 : _a2.id) !== id2) {
          animationFrameProvider.cancelAnimationFrame(id2);
          scheduler._scheduled = void 0;
        }
        return void 0;
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler;
var init_AnimationFrameScheduler = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/AnimationFrameScheduler.js"() {
    "use strict";
    init_AsyncScheduler();
    AnimationFrameScheduler = class extends AsyncScheduler {
      flush(action) {
        this._active = true;
        let flushId;
        if (action) {
          flushId = action.id;
        } else {
          flushId = this._scheduled;
          this._scheduled = void 0;
        }
        const { actions } = this;
        let error;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      }
    };
  }
});

// node_modules/rxjs/dist/esm/internal/scheduler/animationFrame.js
var animationFrameScheduler;
var init_animationFrame = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduler/animationFrame.js"() {
    "use strict";
    init_AnimationFrameAction();
    init_AnimationFrameScheduler();
    animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);
  }
});

// node_modules/rxjs/dist/esm/internal/observable/empty.js
var EMPTY;
var init_empty = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/empty.js"() {
    "use strict";
    init_Observable();
    EMPTY = new Observable((subscriber) => subscriber.complete());
  }
});

// node_modules/rxjs/dist/esm/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}
var init_isScheduler = __esm({
  "node_modules/rxjs/dist/esm/internal/util/isScheduler.js"() {
    "use strict";
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}
var init_args = __esm({
  "node_modules/rxjs/dist/esm/internal/util/args.js"() {
    "use strict";
    init_isFunction();
    init_isScheduler();
  }
});

// node_modules/tslib/tslib.es6.mjs
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/util/isArrayLike.js
var isArrayLike;
var init_isArrayLike = __esm({
  "node_modules/rxjs/dist/esm/internal/util/isArrayLike.js"() {
    "use strict";
    isArrayLike = (x) => x && typeof x.length === "number" && typeof x !== "function";
  }
});

// node_modules/rxjs/dist/esm/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}
var init_isPromise = __esm({
  "node_modules/rxjs/dist/esm/internal/util/isPromise.js"() {
    "use strict";
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/util/isInteropObservable.js
function isInteropObservable(input2) {
  return isFunction(input2[observable]);
}
var init_isInteropObservable = __esm({
  "node_modules/rxjs/dist/esm/internal/util/isInteropObservable.js"() {
    "use strict";
    init_observable();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
var init_isAsyncIterable = __esm({
  "node_modules/rxjs/dist/esm/internal/util/isAsyncIterable.js"() {
    "use strict";
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input2) {
  return new TypeError(`You provided ${input2 !== null && typeof input2 === "object" ? "an invalid object" : `'${input2}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`);
}
var init_throwUnobservableError = __esm({
  "node_modules/rxjs/dist/esm/internal/util/throwUnobservableError.js"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator;
var init_iterator = __esm({
  "node_modules/rxjs/dist/esm/internal/symbol/iterator.js"() {
    "use strict";
    iterator = getSymbolIterator();
  }
});

// node_modules/rxjs/dist/esm/internal/util/isIterable.js
function isIterable(input2) {
  return isFunction(input2 === null || input2 === void 0 ? void 0 : input2[iterator]);
}
var init_isIterable = __esm({
  "node_modules/rxjs/dist/esm/internal/util/isIterable.js"() {
    "use strict";
    init_iterator();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function* readableStreamLikeToAsyncGenerator_1() {
    const reader = readableStream.getReader();
    try {
      while (true) {
        const { value, done } = yield __await(reader.read());
        if (done) {
          return yield __await(void 0);
        }
        yield yield __await(value);
      }
    } finally {
      reader.releaseLock();
    }
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
var init_isReadableStreamLike = __esm({
  "node_modules/rxjs/dist/esm/internal/util/isReadableStreamLike.js"() {
    "use strict";
    init_tslib_es6();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/innerFrom.js
function innerFrom(input2) {
  if (input2 instanceof Observable) {
    return input2;
  }
  if (input2 != null) {
    if (isInteropObservable(input2)) {
      return fromInteropObservable(input2);
    }
    if (isArrayLike(input2)) {
      return fromArrayLike(input2);
    }
    if (isPromise(input2)) {
      return fromPromise(input2);
    }
    if (isAsyncIterable(input2)) {
      return fromAsyncIterable(input2);
    }
    if (isIterable(input2)) {
      return fromIterable(input2);
    }
    if (isReadableStreamLike(input2)) {
      return fromReadableStreamLike(input2);
    }
  }
  throw createInvalidObservableTypeError(input2);
}
function fromInteropObservable(obj) {
  return new Observable((subscriber) => {
    const obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable((subscriber) => {
    for (let i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable((subscriber) => {
    promise.then((value) => {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, (err) => subscriber.error(err)).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable((subscriber) => {
    for (const value of iterable) {
      subscriber.next(value);
      if (subscriber.closed) {
        return;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable((subscriber) => {
    process2(asyncIterable, subscriber).catch((err) => subscriber.error(err));
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_1, _a2;
  return __awaiter(this, void 0, void 0, function* () {
    try {
      for (asyncIterable_1 = __asyncValues(asyncIterable); asyncIterable_1_1 = yield asyncIterable_1.next(), !asyncIterable_1_1.done; ) {
        const value = asyncIterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (asyncIterable_1_1 && !asyncIterable_1_1.done && (_a2 = asyncIterable_1.return)) yield _a2.call(asyncIterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
var init_innerFrom = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/innerFrom.js"() {
    "use strict";
    init_tslib_es6();
    init_isArrayLike();
    init_isPromise();
    init_Observable();
    init_isInteropObservable();
    init_isAsyncIterable();
    init_throwUnobservableError();
    init_isIterable();
    init_isReadableStreamLike();
    init_isFunction();
    init_reportUnhandledError();
    init_observable();
  }
});

// node_modules/rxjs/dist/esm/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay = 0, repeat = false) {
  const scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}
var init_executeSchedule = __esm({
  "node_modules/rxjs/dist/esm/internal/util/executeSchedule.js"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/operators/observeOn.js
function observeOn(scheduler, delay = 0) {
  return operate((source, subscriber) => {
    source.subscribe(createOperatorSubscriber(subscriber, (value) => executeSchedule(subscriber, scheduler, () => subscriber.next(value), delay), () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay), (err) => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)));
  });
}
var init_observeOn = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/observeOn.js"() {
    "use strict";
    init_executeSchedule();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay = 0) {
  return operate((source, subscriber) => {
    subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));
  });
}
var init_subscribeOn = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/subscribeOn.js"() {
    "use strict";
    init_lift();
  }
});

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleObservable.js
function scheduleObservable(input2, scheduler) {
  return innerFrom(input2).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
var init_scheduleObservable = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduled/scheduleObservable.js"() {
    "use strict";
    init_innerFrom();
    init_observeOn();
    init_subscribeOn();
  }
});

// node_modules/rxjs/dist/esm/internal/scheduled/schedulePromise.js
function schedulePromise(input2, scheduler) {
  return innerFrom(input2).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
var init_schedulePromise = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduled/schedulePromise.js"() {
    "use strict";
    init_innerFrom();
    init_observeOn();
    init_subscribeOn();
  }
});

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleArray.js
function scheduleArray(input2, scheduler) {
  return new Observable((subscriber) => {
    let i = 0;
    return scheduler.schedule(function() {
      if (i === input2.length) {
        subscriber.complete();
      } else {
        subscriber.next(input2[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
var init_scheduleArray = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduled/scheduleArray.js"() {
    "use strict";
    init_Observable();
  }
});

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleIterable.js
function scheduleIterable(input2, scheduler) {
  return new Observable((subscriber) => {
    let iterator2;
    executeSchedule(subscriber, scheduler, () => {
      iterator2 = input2[iterator]();
      executeSchedule(subscriber, scheduler, () => {
        let value;
        let done;
        try {
          ({ value, done } = iterator2.next());
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return () => isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
  });
}
var init_scheduleIterable = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduled/scheduleIterable.js"() {
    "use strict";
    init_Observable();
    init_iterator();
    init_isFunction();
    init_executeSchedule();
  }
});

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input2, scheduler) {
  if (!input2) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable((subscriber) => {
    executeSchedule(subscriber, scheduler, () => {
      const iterator2 = input2[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, () => {
        iterator2.next().then((result) => {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
var init_scheduleAsyncIterable = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduled/scheduleAsyncIterable.js"() {
    "use strict";
    init_Observable();
    init_executeSchedule();
  }
});

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input2, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input2), scheduler);
}
var init_scheduleReadableStreamLike = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduled/scheduleReadableStreamLike.js"() {
    "use strict";
    init_scheduleAsyncIterable();
    init_isReadableStreamLike();
  }
});

// node_modules/rxjs/dist/esm/internal/scheduled/scheduled.js
function scheduled(input2, scheduler) {
  if (input2 != null) {
    if (isInteropObservable(input2)) {
      return scheduleObservable(input2, scheduler);
    }
    if (isArrayLike(input2)) {
      return scheduleArray(input2, scheduler);
    }
    if (isPromise(input2)) {
      return schedulePromise(input2, scheduler);
    }
    if (isAsyncIterable(input2)) {
      return scheduleAsyncIterable(input2, scheduler);
    }
    if (isIterable(input2)) {
      return scheduleIterable(input2, scheduler);
    }
    if (isReadableStreamLike(input2)) {
      return scheduleReadableStreamLike(input2, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input2);
}
var init_scheduled = __esm({
  "node_modules/rxjs/dist/esm/internal/scheduled/scheduled.js"() {
    "use strict";
    init_scheduleObservable();
    init_schedulePromise();
    init_scheduleArray();
    init_scheduleIterable();
    init_scheduleAsyncIterable();
    init_isInteropObservable();
    init_isPromise();
    init_isArrayLike();
    init_isIterable();
    init_isAsyncIterable();
    init_throwUnobservableError();
    init_isReadableStreamLike();
    init_scheduleReadableStreamLike();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/from.js
function from(input2, scheduler) {
  return scheduler ? scheduled(input2, scheduler) : innerFrom(input2);
}
var init_from = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/from.js"() {
    "use strict";
    init_scheduled();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/of.js
function of(...args) {
  const scheduler = popScheduler(args);
  return from(args, scheduler);
}
var init_of = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/of.js"() {
    "use strict";
    init_args();
    init_from();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  const errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : () => errorOrErrorFactory;
  const init = (subscriber) => subscriber.error(errorFactory());
  return new Observable(scheduler ? (subscriber) => scheduler.schedule(init, 0, subscriber) : init);
}
var init_throwError = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/throwError.js"() {
    "use strict";
    init_Observable();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/util/isObservable.js
function isObservable(obj) {
  return !!obj && (obj instanceof Observable || isFunction(obj.lift) && isFunction(obj.subscribe));
}
var init_isObservable = __esm({
  "node_modules/rxjs/dist/esm/internal/util/isObservable.js"() {
    "use strict";
    init_Observable();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/util/EmptyError.js
var EmptyError;
var init_EmptyError = __esm({
  "node_modules/rxjs/dist/esm/internal/util/EmptyError.js"() {
    "use strict";
    init_createErrorClass();
    EmptyError = createErrorClass((_super) => function EmptyErrorImpl() {
      _super(this);
      this.name = "EmptyError";
      this.message = "no elements in sequence";
    });
  }
});

// node_modules/rxjs/dist/esm/internal/util/isDate.js
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}
var init_isDate = __esm({
  "node_modules/rxjs/dist/esm/internal/util/isDate.js"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/operators/map.js
function map(project, thisArg) {
  return operate((source, subscriber) => {
    let index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}
var init_map = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/map.js"() {
    "use strict";
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/util/mapOneOrManyArgs.js
function callOrApply(fn, args) {
  return isArray(args) ? fn(...args) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map((args) => callOrApply(fn, args));
}
var isArray;
var init_mapOneOrManyArgs = __esm({
  "node_modules/rxjs/dist/esm/internal/util/mapOneOrManyArgs.js"() {
    "use strict";
    init_map();
    ({ isArray } = Array);
  }
});

// node_modules/rxjs/dist/esm/internal/util/argsArgArrayOrObject.js
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    const first2 = args[0];
    if (isArray2(first2)) {
      return { args: first2, keys: null };
    }
    if (isPOJO(first2)) {
      const keys2 = getKeys(first2);
      return {
        args: keys2.map((key) => first2[key]),
        keys: keys2
      };
    }
  }
  return { args, keys: null };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}
var isArray2, getPrototypeOf, objectProto, getKeys;
var init_argsArgArrayOrObject = __esm({
  "node_modules/rxjs/dist/esm/internal/util/argsArgArrayOrObject.js"() {
    "use strict";
    ({ isArray: isArray2 } = Array);
    ({ getPrototypeOf, prototype: objectProto, keys: getKeys } = Object);
  }
});

// node_modules/rxjs/dist/esm/internal/util/createObject.js
function createObject(keys2, values2) {
  return keys2.reduce((result, key, i) => (result[key] = values2[i], result), {});
}
var init_createObject = __esm({
  "node_modules/rxjs/dist/esm/internal/util/createObject.js"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/observable/combineLatest.js
function combineLatest(...args) {
  const scheduler = popScheduler(args);
  const resultSelector = popResultSelector(args);
  const { args: observables, keys: keys2 } = argsArgArrayOrObject(args);
  if (observables.length === 0) {
    return from([], scheduler);
  }
  const result = new Observable(combineLatestInit(observables, scheduler, keys2 ? (values2) => createObject(keys2, values2) : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform = identity) {
  return (subscriber) => {
    maybeSchedule(scheduler, () => {
      const { length } = observables;
      const values2 = new Array(length);
      let active = length;
      let remainingFirstValues = length;
      for (let i = 0; i < length; i++) {
        maybeSchedule(scheduler, () => {
          const source = from(observables[i], scheduler);
          let hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, (value) => {
            values2[i] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values2.slice()));
            }
          }, () => {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}
var init_combineLatest = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/combineLatest.js"() {
    "use strict";
    init_Observable();
    init_argsArgArrayOrObject();
    init_from();
    init_identity();
    init_mapOneOrManyArgs();
    init_args();
    init_createObject();
    init_OperatorSubscriber();
    init_executeSchedule();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
  const buffer = [];
  let active = 0;
  let index = 0;
  let isComplete = false;
  const checkComplete = () => {
    if (isComplete && !buffer.length && !active) {
      subscriber.complete();
    }
  };
  const outerNext = (value) => active < concurrent ? doInnerSub(value) : buffer.push(value);
  const doInnerSub = (value) => {
    expand && subscriber.next(value);
    active++;
    let innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, (innerValue) => {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, () => {
      innerComplete = true;
    }, void 0, () => {
      if (innerComplete) {
        try {
          active--;
          while (buffer.length && active < concurrent) {
            const bufferedValue = buffer.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));
            } else {
              doInnerSub(bufferedValue);
            }
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, () => {
    isComplete = true;
    checkComplete();
  }));
  return () => {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}
var init_mergeInternals = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/mergeInternals.js"() {
    "use strict";
    init_innerFrom();
    init_executeSchedule();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent = Infinity) {
  if (isFunction(resultSelector)) {
    return mergeMap((a, i) => map((b, ii) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));
}
var init_mergeMap = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/mergeMap.js"() {
    "use strict";
    init_map();
    init_innerFrom();
    init_lift();
    init_mergeInternals();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/mergeAll.js
function mergeAll(concurrent = Infinity) {
  return mergeMap(identity, concurrent);
}
var init_mergeAll = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/mergeAll.js"() {
    "use strict";
    init_mergeMap();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}
var init_concatAll = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/concatAll.js"() {
    "use strict";
    init_mergeAll();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/concat.js
function concat(...args) {
  return concatAll()(from(args, popScheduler(args)));
}
var init_concat = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/concat.js"() {
    "use strict";
    init_concatAll();
    init_args();
    init_from();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/defer.js
function defer(observableFactory) {
  return new Observable((subscriber) => {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}
var init_defer = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/defer.js"() {
    "use strict";
    init_Observable();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/forkJoin.js
function forkJoin(...args) {
  const resultSelector = popResultSelector(args);
  const { args: sources, keys: keys2 } = argsArgArrayOrObject(args);
  const result = new Observable((subscriber) => {
    const { length } = sources;
    if (!length) {
      subscriber.complete();
      return;
    }
    const values2 = new Array(length);
    let remainingCompletions = length;
    let remainingEmissions = length;
    for (let sourceIndex = 0; sourceIndex < length; sourceIndex++) {
      let hasValue = false;
      innerFrom(sources[sourceIndex]).subscribe(createOperatorSubscriber(subscriber, (value) => {
        if (!hasValue) {
          hasValue = true;
          remainingEmissions--;
        }
        values2[sourceIndex] = value;
      }, () => remainingCompletions--, void 0, () => {
        if (!remainingCompletions || !hasValue) {
          if (!remainingEmissions) {
            subscriber.next(keys2 ? createObject(keys2, values2) : values2);
          }
          subscriber.complete();
        }
      }));
    }
  });
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
var init_forkJoin = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/forkJoin.js"() {
    "use strict";
    init_Observable();
    init_argsArgArrayOrObject();
    init_innerFrom();
    init_args();
    init_OperatorSubscriber();
    init_mapOneOrManyArgs();
    init_createObject();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/timer.js
function timer(dueTime = 0, intervalOrScheduler, scheduler = async) {
  let intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable((subscriber) => {
    let due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    let n = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}
var init_timer = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/timer.js"() {
    "use strict";
    init_Observable();
    init_async();
    init_isScheduler();
    init_isDate();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/interval.js
function interval(period2 = 0, scheduler = asyncScheduler) {
  if (period2 < 0) {
    period2 = 0;
  }
  return timer(period2, period2, scheduler);
}
var init_interval = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/interval.js"() {
    "use strict";
    init_async();
    init_timer();
  }
});

// node_modules/rxjs/dist/esm/internal/observable/merge.js
function merge(...args) {
  const scheduler = popScheduler(args);
  const concurrent = popNumber(args, Infinity);
  const sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
}
var init_merge = __esm({
  "node_modules/rxjs/dist/esm/internal/observable/merge.js"() {
    "use strict";
    init_mergeAll();
    init_innerFrom();
    init_empty();
    init_args();
    init_from();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/filter.js
function filter(predicate, thisArg) {
  return operate((source, subscriber) => {
    let index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index++) && subscriber.next(value)));
  });
}
var init_filter = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/filter.js"() {
    "use strict";
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/types.js
var init_types = __esm({
  "node_modules/rxjs/dist/esm/internal/types.js"() {
    "use strict";
  }
});

// node_modules/rxjs/dist/esm/internal/operators/audit.js
function audit(durationSelector) {
  return operate((source, subscriber) => {
    let hasValue = false;
    let lastValue = null;
    let durationSubscriber = null;
    let isComplete = false;
    const endDuration = () => {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      durationSubscriber = null;
      if (hasValue) {
        hasValue = false;
        const value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
      isComplete && subscriber.complete();
    };
    const cleanupDuration = () => {
      durationSubscriber = null;
      isComplete && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      hasValue = true;
      lastValue = value;
      if (!durationSubscriber) {
        innerFrom(durationSelector(value)).subscribe(durationSubscriber = createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
      }
    }, () => {
      isComplete = true;
      (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
    }));
  });
}
var init_audit = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/audit.js"() {
    "use strict";
    init_lift();
    init_innerFrom();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/auditTime.js
function auditTime(duration, scheduler = asyncScheduler) {
  return audit(() => timer(duration, scheduler));
}
var init_auditTime = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/auditTime.js"() {
    "use strict";
    init_async();
    init_audit();
    init_timer();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/catchError.js
function catchError(selector) {
  return operate((source, subscriber) => {
    let innerSub = null;
    let syncUnsub = false;
    let handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, (err) => {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}
var init_catchError = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/catchError.js"() {
    "use strict";
    init_innerFrom();
    init_OperatorSubscriber();
    init_lift();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/scanInternals.js
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return (source, subscriber) => {
    let hasState = hasSeed;
    let state = seed;
    let index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      const i = index++;
      state = hasState ? accumulator(state, value, i) : (hasState = true, value);
      emitOnNext && subscriber.next(state);
    }, emitBeforeComplete && (() => {
      hasState && subscriber.next(state);
      subscriber.complete();
    })));
  };
}
var init_scanInternals = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/scanInternals.js"() {
    "use strict";
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/concatMap.js
function concatMap(project, resultSelector) {
  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
}
var init_concatMap = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/concatMap.js"() {
    "use strict";
    init_mergeMap();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/defaultIfEmpty.js
function defaultIfEmpty(defaultValue) {
  return operate((source, subscriber) => {
    let hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      hasValue = true;
      subscriber.next(value);
    }, () => {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}
var init_defaultIfEmpty = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/defaultIfEmpty.js"() {
    "use strict";
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/take.js
function take(count2) {
  return count2 <= 0 ? () => EMPTY : operate((source, subscriber) => {
    let seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      if (++seen <= count2) {
        subscriber.next(value);
        if (count2 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}
var init_take = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/take.js"() {
    "use strict";
    init_empty();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(comparator, keySelector = identity) {
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate((source, subscriber) => {
    let previousKey;
    let first2 = true;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      const currentKey = keySelector(value);
      if (first2 || !comparator(previousKey, currentKey)) {
        first2 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a, b) {
  return a === b;
}
var init_distinctUntilChanged = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/distinctUntilChanged.js"() {
    "use strict";
    init_identity();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/throwIfEmpty.js
function throwIfEmpty(errorFactory = defaultErrorFactory) {
  return operate((source, subscriber) => {
    let hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      hasValue = true;
      subscriber.next(value);
    }, () => hasValue ? subscriber.complete() : subscriber.error(errorFactory())));
  });
}
function defaultErrorFactory() {
  return new EmptyError();
}
var init_throwIfEmpty = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/throwIfEmpty.js"() {
    "use strict";
    init_EmptyError();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/finalize.js
function finalize(callback) {
  return operate((source, subscriber) => {
    try {
      source.subscribe(subscriber);
    } finally {
      subscriber.add(callback);
    }
  });
}
var init_finalize = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/finalize.js"() {
    "use strict";
    init_lift();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/first.js
function first(predicate, defaultValue) {
  const hasDefaultValue = arguments.length >= 2;
  return (source) => source.pipe(predicate ? filter((v, i) => predicate(v, i, source)) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(() => new EmptyError()));
}
var init_first = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/first.js"() {
    "use strict";
    init_EmptyError();
    init_filter();
    init_take();
    init_defaultIfEmpty();
    init_throwIfEmpty();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/takeLast.js
function takeLast(count2) {
  return count2 <= 0 ? () => EMPTY : operate((source, subscriber) => {
    let buffer = [];
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      buffer.push(value);
      count2 < buffer.length && buffer.shift();
    }, () => {
      for (const value of buffer) {
        subscriber.next(value);
      }
      subscriber.complete();
    }, void 0, () => {
      buffer = null;
    }));
  });
}
var init_takeLast = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/takeLast.js"() {
    "use strict";
    init_empty();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/last.js
function last2(predicate, defaultValue) {
  const hasDefaultValue = arguments.length >= 2;
  return (source) => source.pipe(predicate ? filter((v, i) => predicate(v, i, source)) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(() => new EmptyError()));
}
var init_last = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/last.js"() {
    "use strict";
    init_EmptyError();
    init_filter();
    init_takeLast();
    init_throwIfEmpty();
    init_defaultIfEmpty();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/pairwise.js
function pairwise() {
  return operate((source, subscriber) => {
    let prev;
    let hasPrev = false;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      const p = prev;
      prev = value;
      hasPrev && subscriber.next([p, value]);
      hasPrev = true;
    }));
  });
}
var init_pairwise = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/pairwise.js"() {
    "use strict";
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/scan.js
function scan(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
}
var init_scan = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/scan.js"() {
    "use strict";
    init_lift();
    init_scanInternals();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/share.js
function share(options = {}) {
  const { connector = () => new Subject(), resetOnError = true, resetOnComplete = true, resetOnRefCountZero = true } = options;
  return (wrapperSource) => {
    let connection;
    let resetConnection;
    let subject;
    let refCount2 = 0;
    let hasCompleted = false;
    let hasErrored = false;
    const cancelReset = () => {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    const reset = () => {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    const resetAndUnsubscribe = () => {
      const conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate((source, subscriber) => {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      const dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(() => {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount2 > 0) {
        connection = new SafeSubscriber({
          next: (value) => dest.next(value),
          error: (err) => {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: () => {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on, ...args) {
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  const onSubscriber = new SafeSubscriber({
    next: () => {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom(on(...args)).subscribe(onSubscriber);
}
var init_share = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/share.js"() {
    "use strict";
    init_innerFrom();
    init_Subject();
    init_Subscriber();
    init_lift();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/shareReplay.js
function shareReplay(configOrBufferSize, windowTime, scheduler) {
  let bufferSize;
  let refCount2 = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    ({ bufferSize = Infinity, windowTime = Infinity, refCount: refCount2 = false, scheduler } = configOrBufferSize);
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share({
    connector: () => new ReplaySubject(bufferSize, windowTime, scheduler),
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount2
  });
}
var init_shareReplay = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/shareReplay.js"() {
    "use strict";
    init_ReplaySubject();
    init_share();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/startWith.js
function startWith(...values2) {
  const scheduler = popScheduler(values2);
  return operate((source, subscriber) => {
    (scheduler ? concat(values2, source, scheduler) : concat(values2, source)).subscribe(subscriber);
  });
}
var init_startWith = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/startWith.js"() {
    "use strict";
    init_concat();
    init_args();
    init_lift();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  return operate((source, subscriber) => {
    let innerSubscriber = null;
    let index = 0;
    let isComplete = false;
    const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      let innerIndex = 0;
      const outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue), () => {
        innerSubscriber = null;
        checkComplete();
      }));
    }, () => {
      isComplete = true;
      checkComplete();
    }));
  });
}
var init_switchMap = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/switchMap.js"() {
    "use strict";
    init_innerFrom();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return operate((source, subscriber) => {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}
var init_takeUntil = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/takeUntil.js"() {
    "use strict";
    init_lift();
    init_OperatorSubscriber();
    init_innerFrom();
    init_noop();
  }
});

// node_modules/rxjs/dist/esm/internal/operators/tap.js
function tap(observerOrNext, error, complete) {
  const tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate((source, subscriber) => {
    var _a2;
    (_a2 = tapObserver.subscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
    let isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      var _a3;
      (_a3 = tapObserver.next) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver, value);
      subscriber.next(value);
    }, () => {
      var _a3;
      isUnsub = false;
      (_a3 = tapObserver.complete) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver);
      subscriber.complete();
    }, (err) => {
      var _a3;
      isUnsub = false;
      (_a3 = tapObserver.error) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver, err);
      subscriber.error(err);
    }, () => {
      var _a3, _b;
      if (isUnsub) {
        (_a3 = tapObserver.unsubscribe) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}
var init_tap = __esm({
  "node_modules/rxjs/dist/esm/internal/operators/tap.js"() {
    "use strict";
    init_isFunction();
    init_lift();
    init_OperatorSubscriber();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm/index.js
var init_esm = __esm({
  "node_modules/rxjs/dist/esm/index.js"() {
    "use strict";
    init_Observable();
    init_ConnectableObservable();
    init_Subject();
    init_BehaviorSubject();
    init_asap();
    init_animationFrame();
    init_Subscription();
    init_pipe();
    init_isObservable();
    init_EmptyError();
    init_combineLatest();
    init_concat();
    init_defer();
    init_forkJoin();
    init_from();
    init_interval();
    init_merge();
    init_of();
    init_throwError();
    init_empty();
    init_types();
  }
});

// node_modules/@angular/core/fesm2022/untracked.mjs
function createLinkedSignal(sourceFn, computationFn, equalityFn) {
  const node = Object.create(LINKED_SIGNAL_NODE);
  node.source = sourceFn;
  node.computation = computationFn;
  if (equalityFn != void 0) {
    node.equal = equalityFn;
  }
  const linkedSignalGetter = () => {
    producerUpdateValueVersion(node);
    producerAccessed(node);
    if (node.value === ERRORED) {
      throw node.error;
    }
    return node.value;
  };
  const getter = linkedSignalGetter;
  getter[SIGNAL] = node;
  if (typeof ngDevMode !== "undefined" && ngDevMode) {
    const debugName = node.debugName ? " (" + node.debugName + ")" : "";
    getter.toString = () => `[LinkedSignal${debugName}: ${node.value}]`;
  }
  runPostProducerCreatedFn(node);
  return getter;
}
function linkedSignalSetFn(node, newValue) {
  producerUpdateValueVersion(node);
  signalSetFn(node, newValue);
  producerMarkClean(node);
}
function linkedSignalUpdateFn(node, updater) {
  producerUpdateValueVersion(node);
  signalUpdateFn(node, updater);
  producerMarkClean(node);
}
function untracked(nonReactiveReadsFn) {
  const prevConsumer = setActiveConsumer(null);
  try {
    return nonReactiveReadsFn();
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
var LINKED_SIGNAL_NODE;
var init_untracked = __esm({
  "node_modules/@angular/core/fesm2022/untracked.mjs"() {
    "use strict";
    init_signal();
    LINKED_SIGNAL_NODE = /* @__PURE__ */ (() => {
      return __spreadProps(__spreadValues({}, REACTIVE_NODE), {
        value: UNSET,
        dirty: true,
        error: null,
        equal: defaultEquals,
        kind: "linkedSignal",
        producerMustRecompute(node) {
          return node.value === UNSET || node.value === COMPUTING;
        },
        producerRecomputeValue(node) {
          if (node.value === COMPUTING) {
            throw new Error(typeof ngDevMode !== "undefined" && ngDevMode ? "Detected cycle in computations." : "");
          }
          const oldValue = node.value;
          node.value = COMPUTING;
          const prevConsumer = consumerBeforeComputation(node);
          let newValue;
          try {
            const newSourceValue = node.source();
            const prev = oldValue === UNSET || oldValue === ERRORED ? void 0 : {
              source: node.sourceValue,
              value: oldValue
            };
            newValue = node.computation(newSourceValue, prev);
            node.sourceValue = newSourceValue;
          } catch (err) {
            newValue = ERRORED;
            node.error = err;
          } finally {
            consumerAfterComputation(node, prevConsumer);
          }
          if (oldValue !== UNSET && newValue !== ERRORED && node.equal(oldValue, newValue)) {
            node.value = oldValue;
            return;
          }
          node.value = newValue;
          node.version++;
        }
      });
    })();
  }
});

// node_modules/@angular/core/fesm2022/primitives/signals.mjs
var init_signals = __esm({
  "node_modules/@angular/core/fesm2022/primitives/signals.mjs"() {
    "use strict";
    init_signal();
  }
});

// node_modules/@angular/core/fesm2022/primitives/di.mjs
var init_di = __esm({
  "node_modules/@angular/core/fesm2022/primitives/di.mjs"() {
    "use strict";
    init_not_found();
  }
});

// node_modules/@angular/core/fesm2022/root_effect_scheduler.mjs
function formatRuntimeErrorCode(code) {
  return `NG0${Math.abs(code)}`;
}
function formatRuntimeError(code, message) {
  const fullCode = formatRuntimeErrorCode(code);
  let errorMessage = `${fullCode}${message ? ": " + message : ""}`;
  if (ngDevMode && code < 0) {
    const addPeriodSeparator = !errorMessage.match(/[.,;!?\n]$/);
    const separator = addPeriodSeparator ? "." : "";
    errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;
  }
  return errorMessage;
}
function ngDevModeResetPerfCounters() {
  const locationString = typeof location !== "undefined" ? location.toString() : "";
  const newCounters = {
    hydratedNodes: 0,
    hydratedComponents: 0,
    dehydratedViewsRemoved: 0,
    dehydratedViewsCleanupRuns: 0,
    componentsSkippedHydration: 0,
    deferBlocksWithIncrementalHydration: 0
  };
  const allowNgDevModeTrue = locationString.indexOf("ngDevMode=false") === -1;
  if (!allowNgDevModeTrue) {
    _global["ngDevMode"] = false;
  } else {
    if (typeof _global["ngDevMode"] !== "object") {
      _global["ngDevMode"] = {};
    }
    Object.assign(_global["ngDevMode"], newCounters);
  }
  return newCounters;
}
function initNgDevMode() {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (typeof ngDevMode !== "object" || Object.keys(ngDevMode).length === 0) {
      ngDevModeResetPerfCounters();
    }
    return typeof ngDevMode !== "undefined" && !!ngDevMode;
  }
  return false;
}
function getClosureSafeProperty(objWithPropertyToExtract) {
  for (let key in objWithPropertyToExtract) {
    if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
      return key;
    }
  }
  throw Error(typeof ngDevMode !== "undefined" && ngDevMode ? "Could not find renamed property on target object." : "");
}
function fillProperties(target, source) {
  for (const key in source) {
    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
      target[key] = source[key];
    }
  }
}
function stringify(token) {
  if (typeof token === "string") {
    return token;
  }
  if (Array.isArray(token)) {
    return `[${token.map(stringify).join(", ")}]`;
  }
  if (token == null) {
    return "" + token;
  }
  const name2 = token.overriddenName || token.name;
  if (name2) {
    return `${name2}`;
  }
  const result = token.toString();
  if (result == null) {
    return "" + result;
  }
  const newLineIndex = result.indexOf("\n");
  return newLineIndex >= 0 ? result.slice(0, newLineIndex) : result;
}
function concatStringsWithSpace(before, after) {
  if (!before)
    return after || "";
  if (!after)
    return before;
  return `${before} ${after}`;
}
function forwardRef(forwardRefFn) {
  forwardRefFn.__forward_ref__ = forwardRef;
  forwardRefFn.toString = function() {
    return stringify(this());
  };
  return forwardRefFn;
}
function resolveForwardRef(type) {
  return isForwardRef(type) ? type() : type;
}
function isForwardRef(fn) {
  return typeof fn === "function" && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;
}
function assertNumber(actual, msg) {
  if (!(typeof actual === "number")) {
    throwError2(msg, typeof actual, "number", "===");
  }
}
function assertNumberInRange(actual, minInclusive, maxInclusive) {
  assertNumber(actual, "Expected a number");
  assertLessThanOrEqual(actual, maxInclusive, "Expected number to be less than or equal to");
  assertGreaterThanOrEqual(actual, minInclusive, "Expected number to be greater than or equal to");
}
function assertString(actual, msg) {
  if (!(typeof actual === "string")) {
    throwError2(msg, actual === null ? "null" : typeof actual, "string", "===");
  }
}
function assertFunction(actual, msg) {
  if (!(typeof actual === "function")) {
    throwError2(msg, actual === null ? "null" : typeof actual, "function", "===");
  }
}
function assertEqual(actual, expected, msg) {
  if (!(actual == expected)) {
    throwError2(msg, actual, expected, "==");
  }
}
function assertNotEqual(actual, expected, msg) {
  if (!(actual != expected)) {
    throwError2(msg, actual, expected, "!=");
  }
}
function assertSame(actual, expected, msg) {
  if (!(actual === expected)) {
    throwError2(msg, actual, expected, "===");
  }
}
function assertNotSame(actual, expected, msg) {
  if (!(actual !== expected)) {
    throwError2(msg, actual, expected, "!==");
  }
}
function assertLessThan(actual, expected, msg) {
  if (!(actual < expected)) {
    throwError2(msg, actual, expected, "<");
  }
}
function assertLessThanOrEqual(actual, expected, msg) {
  if (!(actual <= expected)) {
    throwError2(msg, actual, expected, "<=");
  }
}
function assertGreaterThan(actual, expected, msg) {
  if (!(actual > expected)) {
    throwError2(msg, actual, expected, ">");
  }
}
function assertGreaterThanOrEqual(actual, expected, msg) {
  if (!(actual >= expected)) {
    throwError2(msg, actual, expected, ">=");
  }
}
function assertDefined(actual, msg) {
  if (actual == null) {
    throwError2(msg, actual, null, "!=");
  }
}
function throwError2(msg, actual, expected, comparison) {
  throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? "" : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));
}
function assertDomNode(node) {
  if (!(node instanceof Node)) {
    throwError2(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);
  }
}
function assertElement(node) {
  if (!(node instanceof Element)) {
    throwError2(`The provided value must be an element but got ${stringify(node)}`);
  }
}
function assertIndexInRange(arr, index) {
  assertDefined(arr, "Array must be defined.");
  const maxLen = arr.length;
  if (index < 0 || index >= maxLen) {
    throwError2(`Index expected to be less than ${maxLen} but got ${index}`);
  }
}
function assertOneOf(value, ...validValues) {
  if (validValues.indexOf(value) !== -1)
    return true;
  throwError2(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);
}
function assertNotReactive(fn) {
  if (getActiveConsumer() !== null) {
    throwError2(`${fn}() should never be called in a reactive context.`);
  }
}
function \u0275\u0275defineInjectable(opts) {
  return {
    token: opts.token,
    providedIn: opts.providedIn || null,
    factory: opts.factory,
    value: void 0
  };
}
function \u0275\u0275defineInjector(options) {
  return { providers: options.providers || [], imports: options.imports || [] };
}
function getInjectableDef(type) {
  return getOwnDefinition(type, NG_PROV_DEF);
}
function isInjectable(type) {
  return getInjectableDef(type) !== null;
}
function getOwnDefinition(type, field) {
  return type.hasOwnProperty(field) && type[field] || null;
}
function getInheritedInjectableDef(type) {
  const def = type?.[NG_PROV_DEF] ?? null;
  if (def) {
    ngDevMode && console.warn(`DEPRECATED: DI is instantiating a token "${type.name}" that inherits its @Injectable decorator but does not provide one itself.
This will become an error in a future version of Angular. Please add @Injectable() to the "${type.name}" class.`);
    return def;
  } else {
    return null;
  }
}
function getInjectorDef(type) {
  return type && type.hasOwnProperty(NG_INJ_DEF) ? type[NG_INJ_DEF] : null;
}
function getInjectorProfilerContext() {
  !ngDevMode && throwError2("getInjectorProfilerContext should never be called in production mode");
  return _injectorProfilerContext;
}
function setInjectorProfilerContext(context2) {
  !ngDevMode && throwError2("setInjectorProfilerContext should never be called in production mode");
  const previous = _injectorProfilerContext;
  _injectorProfilerContext = context2;
  return previous;
}
function removeProfiler(profiler2) {
  const profilerIdx = injectorProfilerCallbacks.indexOf(profiler2);
  if (profilerIdx !== -1) {
    injectorProfilerCallbacks.splice(profilerIdx, 1);
  }
}
function setInjectorProfiler(injectorProfiler2) {
  !ngDevMode && throwError2("setInjectorProfiler should never be called in production mode");
  if (injectorProfiler2 !== null) {
    if (!injectorProfilerCallbacks.includes(injectorProfiler2)) {
      injectorProfilerCallbacks.push(injectorProfiler2);
    }
    return () => removeProfiler(injectorProfiler2);
  } else {
    injectorProfilerCallbacks.length = 0;
    return NOOP_PROFILER_REMOVAL;
  }
}
function injectorProfiler(event) {
  !ngDevMode && throwError2("Injector profiler should never be called in production mode");
  for (let i = 0; i < injectorProfilerCallbacks.length; i++) {
    const injectorProfilerCallback = injectorProfilerCallbacks[i];
    injectorProfilerCallback(event);
  }
}
function emitProviderConfiguredEvent(eventProvider, isViewProvider = false) {
  !ngDevMode && throwError2("Injector profiler should never be called in production mode");
  let token;
  if (typeof eventProvider === "function") {
    token = eventProvider;
  } else if (eventProvider instanceof InjectionToken) {
    token = eventProvider;
  } else {
    token = resolveForwardRef(eventProvider.provide);
  }
  let provider = eventProvider;
  if (eventProvider instanceof InjectionToken) {
    provider = eventProvider.\u0275prov || eventProvider;
  }
  injectorProfiler({
    type: 2,
    context: getInjectorProfilerContext(),
    providerRecord: { token, provider, isViewProvider }
  });
}
function emitInjectorToCreateInstanceEvent(token) {
  !ngDevMode && throwError2("Injector profiler should never be called in production mode");
  injectorProfiler({
    type: 4,
    context: getInjectorProfilerContext(),
    token
  });
}
function emitInstanceCreatedByInjectorEvent(instance) {
  !ngDevMode && throwError2("Injector profiler should never be called in production mode");
  injectorProfiler({
    type: 1,
    context: getInjectorProfilerContext(),
    instance: { value: instance }
  });
}
function emitInjectEvent(token, value, flags) {
  !ngDevMode && throwError2("Injector profiler should never be called in production mode");
  injectorProfiler({
    type: 0,
    context: getInjectorProfilerContext(),
    service: { token, value, flags }
  });
}
function emitEffectCreatedEvent(effect2) {
  !ngDevMode && throwError2("Injector profiler should never be called in production mode");
  injectorProfiler({
    type: 3,
    context: getInjectorProfilerContext(),
    effect: effect2
  });
}
function runInInjectorProfilerContext(injector, token, callback) {
  !ngDevMode && throwError2("runInInjectorProfilerContext should never be called in production mode");
  const prevInjectContext = setInjectorProfilerContext({ injector, token });
  try {
    callback();
  } finally {
    setInjectorProfilerContext(prevInjectContext);
  }
}
function isEnvironmentProviders(value) {
  return value && !!value.\u0275providers;
}
function renderStringify(value) {
  if (typeof value === "string")
    return value;
  if (value == null)
    return "";
  return String(value);
}
function stringifyForError(value) {
  if (typeof value === "function")
    return value.name || value.toString();
  if (typeof value === "object" && value != null && typeof value.type === "function") {
    return value.type.name || value.type.toString();
  }
  return renderStringify(value);
}
function cyclicDependencyError(token, path) {
  const message = ngDevMode ? `Circular dependency detected for \`${token}\`.` : "";
  return createRuntimeError(message, -200, path);
}
function cyclicDependencyErrorWithDetails(token, path) {
  return augmentRuntimeError(cyclicDependencyError(token, path), null);
}
function throwMixedMultiProviderError() {
  throw new Error(`Cannot mix multi providers and regular providers`);
}
function throwInvalidProviderError(ngModuleType, providers, provider) {
  if (ngModuleType && providers) {
    const providerDetail = providers.map((v) => v == provider ? "?" + provider + "?" : "...");
    throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(", ")}]`);
  } else if (isEnvironmentProviders(provider)) {
    if (provider.\u0275fromNgModule) {
      throw new RuntimeError(207, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);
    } else {
      throw new RuntimeError(207, `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`);
    }
  } else {
    throw new Error("Invalid provider");
  }
}
function throwProviderNotFoundError(token, injectorName) {
  const errorMessage = ngDevMode && `No provider for ${stringifyForError(token)} found${injectorName ? ` in ${injectorName}` : ""}`;
  throw new RuntimeError(-201, errorMessage);
}
function prependTokenToDependencyPath(error, token) {
  error[NG_TOKEN_PATH] ??= [];
  const currentPath = error[NG_TOKEN_PATH];
  let pathStr;
  if (typeof token === "object" && "multi" in token && token?.multi === true) {
    assertDefined(token.provide, "Token with multi: true should have a provide property");
    pathStr = stringifyForError(token.provide);
  } else {
    pathStr = stringifyForError(token);
  }
  if (currentPath[0] !== pathStr) {
    error[NG_TOKEN_PATH].unshift(pathStr);
  }
}
function augmentRuntimeError(error, source) {
  const tokenPath = error[NG_TOKEN_PATH];
  const errorCode = error[NG_RUNTIME_ERROR_CODE];
  const message = error[NG_RUNTIME_ERROR_MESSAGE] || error.message;
  error.message = formatErrorMessage(message, errorCode, tokenPath, source);
  return error;
}
function createRuntimeError(message, code, path) {
  const error = new RuntimeError(code, message);
  error[NG_RUNTIME_ERROR_CODE] = code;
  error[NG_RUNTIME_ERROR_MESSAGE] = message;
  if (path) {
    error[NG_TOKEN_PATH] = path;
  }
  return error;
}
function getRuntimeErrorCode(error) {
  return error[NG_RUNTIME_ERROR_CODE];
}
function formatErrorMessage(text, code, path = [], source = null) {
  let pathDetails = "";
  if (path && path.length > 1) {
    pathDetails = ` Path: ${path.join(" -> ")}.`;
  }
  const sourceDetails = source ? ` Source: ${source}.` : "";
  return formatRuntimeError(code, `${text}${sourceDetails}${pathDetails}`);
}
function getInjectImplementation() {
  return _injectImplementation;
}
function setInjectImplementation(impl) {
  const previous = _injectImplementation;
  _injectImplementation = impl;
  return previous;
}
function injectRootLimpMode(token, notFoundValue, flags) {
  const injectableDef = getInjectableDef(token);
  if (injectableDef && injectableDef.providedIn == "root") {
    return injectableDef.value === void 0 ? injectableDef.value = injectableDef.factory() : injectableDef.value;
  }
  if (flags & 8)
    return null;
  if (notFoundValue !== void 0)
    return notFoundValue;
  throwProviderNotFoundError(token, "Injector");
}
function assertInjectImplementationNotEqual(fn) {
  ngDevMode && assertNotEqual(_injectImplementation, fn, "Calling \u0275\u0275inject would cause infinite recursion");
}
function injectInjectorOnly(token, flags = 0) {
  const currentInjector = getCurrentInjector();
  if (currentInjector === void 0) {
    throw new RuntimeError(-203, ngDevMode && `The \`${stringify(token)}\` token injection failed. \`inject()\` function must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \`runInInjectionContext\`.`);
  } else if (currentInjector === null) {
    return injectRootLimpMode(token, void 0, flags);
  } else {
    const options = convertToInjectOptions(flags);
    const value = currentInjector.retrieve(token, options);
    ngDevMode && emitInjectEvent(token, value, flags);
    if (isNotFound(value)) {
      if (options.optional) {
        return null;
      }
      throw value;
    }
    return value;
  }
}
function \u0275\u0275inject(token, flags = 0) {
  return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);
}
function \u0275\u0275invalidFactoryDep(index) {
  throw new RuntimeError(202, ngDevMode && `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.
This can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.

Please check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);
}
function inject2(token, options) {
  return \u0275\u0275inject(token, convertToBitFlags(options));
}
function convertToBitFlags(flags) {
  if (typeof flags === "undefined" || typeof flags === "number") {
    return flags;
  }
  return 0 | // comment to force a line break in the formatter
  (flags.optional && 8) | (flags.host && 1) | (flags.self && 2) | (flags.skipSelf && 4);
}
function convertToInjectOptions(flags) {
  return {
    optional: !!(flags & 8),
    host: !!(flags & 1),
    self: !!(flags & 2),
    skipSelf: !!(flags & 4)
  };
}
function injectArgs(types2) {
  const args = [];
  for (let i = 0; i < types2.length; i++) {
    const arg = resolveForwardRef(types2[i]);
    if (Array.isArray(arg)) {
      if (arg.length === 0) {
        throw new RuntimeError(900, ngDevMode && "Arguments array must have arguments.");
      }
      let type = void 0;
      let flags = 0;
      for (let j = 0; j < arg.length; j++) {
        const meta2 = arg[j];
        const flag = getInjectFlag(meta2);
        if (typeof flag === "number") {
          if (flag === -1) {
            type = meta2.token;
          } else {
            flags |= flag;
          }
        } else {
          type = meta2;
        }
      }
      args.push(\u0275\u0275inject(type, flags));
    } else {
      args.push(\u0275\u0275inject(arg));
    }
  }
  return args;
}
function attachInjectFlag(decorator, flag) {
  decorator[DI_DECORATOR_FLAG] = flag;
  decorator.prototype[DI_DECORATOR_FLAG] = flag;
  return decorator;
}
function getInjectFlag(token) {
  return token[DI_DECORATOR_FLAG];
}
function getFactoryDef(type, throwNotFound) {
  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);
  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {
    throw new Error(`Type ${stringify(type)} does not have '\u0275fac' property.`);
  }
  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;
}
function arrayEquals(a, b, identityAccessor) {
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; i++) {
    let valueA = a[i];
    let valueB = b[i];
    if (identityAccessor) {
      valueA = identityAccessor(valueA);
      valueB = identityAccessor(valueB);
    }
    if (valueB !== valueA) {
      return false;
    }
  }
  return true;
}
function flatten(list) {
  return list.flat(Number.POSITIVE_INFINITY);
}
function deepForEach(input2, fn) {
  input2.forEach((value) => Array.isArray(value) ? deepForEach(value, fn) : fn(value));
}
function addToArray(arr, index, value) {
  if (index >= arr.length) {
    arr.push(value);
  } else {
    arr.splice(index, 0, value);
  }
}
function removeFromArray(arr, index) {
  if (index >= arr.length - 1) {
    return arr.pop();
  } else {
    return arr.splice(index, 1)[0];
  }
}
function newArray(size, value) {
  const list = [];
  for (let i = 0; i < size; i++) {
    list.push(value);
  }
  return list;
}
function arraySplice(array, index, count2) {
  const length = array.length - count2;
  while (index < length) {
    array[index] = array[index + count2];
    index++;
  }
  while (count2--) {
    array.pop();
  }
}
function arrayInsert2(array, index, value1, value2) {
  ngDevMode && assertLessThanOrEqual(index, array.length, "Can't insert past array end.");
  let end = array.length;
  if (end == index) {
    array.push(value1, value2);
  } else if (end === 1) {
    array.push(value2, array[0]);
    array[0] = value1;
  } else {
    end--;
    array.push(array[end - 1], array[end]);
    while (end > index) {
      const previousEnd = end - 2;
      array[end] = array[previousEnd];
      end--;
    }
    array[index] = value1;
    array[index + 1] = value2;
  }
}
function keyValueArraySet(keyValueArray, key, value) {
  let index = keyValueArrayIndexOf(keyValueArray, key);
  if (index >= 0) {
    keyValueArray[index | 1] = value;
  } else {
    index = ~index;
    arrayInsert2(keyValueArray, index, key, value);
  }
  return index;
}
function keyValueArrayGet(keyValueArray, key) {
  const index = keyValueArrayIndexOf(keyValueArray, key);
  if (index >= 0) {
    return keyValueArray[index | 1];
  }
  return void 0;
}
function keyValueArrayIndexOf(keyValueArray, key) {
  return _arrayIndexOfSorted(keyValueArray, key, 1);
}
function _arrayIndexOfSorted(array, value, shift2) {
  ngDevMode && assertEqual(Array.isArray(array), true, "Expecting an array");
  let start = 0;
  let end = array.length >> shift2;
  while (end !== start) {
    const middle = start + (end - start >> 1);
    const current = array[middle << shift2];
    if (value === current) {
      return middle << shift2;
    } else if (current > value) {
      end = middle;
    } else {
      start = middle + 1;
    }
  }
  return ~(end << shift2);
}
function getNgModuleDef(type) {
  return type[NG_MOD_DEF] || null;
}
function getNgModuleDefOrThrow(type) {
  const ngModuleDef = getNgModuleDef(type);
  if (!ngModuleDef) {
    throw new RuntimeError(915, (typeof ngDevMode === "undefined" || ngDevMode) && `Type ${stringify(type)} does not have '\u0275mod' property.`);
  }
  return ngModuleDef;
}
function getComponentDef(type) {
  return type[NG_COMP_DEF] || null;
}
function getDirectiveDefOrThrow(type) {
  const def = getDirectiveDef(type);
  if (!def) {
    throw new RuntimeError(916, (typeof ngDevMode === "undefined" || ngDevMode) && `Type ${stringify(type)} does not have '\u0275dir' property.`);
  }
  return def;
}
function getDirectiveDef(type) {
  return type[NG_DIR_DEF] || null;
}
function getPipeDef(type) {
  return type[NG_PIPE_DEF] || null;
}
function isStandalone(type) {
  const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);
  return def !== null && def.standalone;
}
function makeEnvironmentProviders(providers) {
  return {
    \u0275providers: providers
  };
}
function provideEnvironmentInitializer(initializerFn) {
  return makeEnvironmentProviders([
    {
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useValue: initializerFn
    }
  ]);
}
function importProvidersFrom(...sources) {
  return {
    \u0275providers: internalImportProvidersFrom(true, sources),
    \u0275fromNgModule: true
  };
}
function internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {
  const providersOut = [];
  const dedup = /* @__PURE__ */ new Set();
  let injectorTypesWithProviders;
  const collectProviders = (provider) => {
    providersOut.push(provider);
  };
  deepForEach(sources, (source) => {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && checkForStandaloneCmp) {
      const cmpDef = getComponentDef(source);
      if (cmpDef?.standalone) {
        throw new RuntimeError(800, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component "${stringifyForError(source)}"`);
      }
    }
    const internalSource = source;
    if (walkProviderTree(internalSource, collectProviders, [], dedup)) {
      injectorTypesWithProviders ||= [];
      injectorTypesWithProviders.push(internalSource);
    }
  });
  if (injectorTypesWithProviders !== void 0) {
    processInjectorTypesWithProviders(injectorTypesWithProviders, collectProviders);
  }
  return providersOut;
}
function processInjectorTypesWithProviders(typesWithProviders, visitor) {
  for (let i = 0; i < typesWithProviders.length; i++) {
    const { ngModule, providers } = typesWithProviders[i];
    deepForEachProvider(providers, (provider) => {
      ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);
      visitor(provider, ngModule);
    });
  }
}
function walkProviderTree(container, visitor, parents, dedup) {
  container = resolveForwardRef(container);
  if (!container)
    return false;
  let defType = null;
  let injDef = getInjectorDef(container);
  const cmpDef = !injDef && getComponentDef(container);
  if (!injDef && !cmpDef) {
    const ngModule = container.ngModule;
    injDef = getInjectorDef(ngModule);
    if (injDef) {
      defType = ngModule;
    } else {
      return false;
    }
  } else if (cmpDef && !cmpDef.standalone) {
    return false;
  } else {
    defType = container;
  }
  if (ngDevMode && parents.indexOf(defType) !== -1) {
    const defName = stringify(defType);
    const path = parents.map(stringify).concat(defName);
    throw cyclicDependencyErrorWithDetails(defName, path);
  }
  const isDuplicate = dedup.has(defType);
  if (cmpDef) {
    if (isDuplicate) {
      return false;
    }
    dedup.add(defType);
    if (cmpDef.dependencies) {
      const deps = typeof cmpDef.dependencies === "function" ? cmpDef.dependencies() : cmpDef.dependencies;
      for (const dep of deps) {
        walkProviderTree(dep, visitor, parents, dedup);
      }
    }
  } else if (injDef) {
    if (injDef.imports != null && !isDuplicate) {
      ngDevMode && parents.push(defType);
      dedup.add(defType);
      let importTypesWithProviders;
      try {
        deepForEach(injDef.imports, (imported) => {
          if (walkProviderTree(imported, visitor, parents, dedup)) {
            importTypesWithProviders ||= [];
            importTypesWithProviders.push(imported);
          }
        });
      } finally {
        ngDevMode && parents.pop();
      }
      if (importTypesWithProviders !== void 0) {
        processInjectorTypesWithProviders(importTypesWithProviders, visitor);
      }
    }
    if (!isDuplicate) {
      const factory = getFactoryDef(defType) || (() => new defType());
      visitor({ provide: defType, useFactory: factory, deps: EMPTY_ARRAY }, defType);
      visitor({ provide: INJECTOR_DEF_TYPES, useValue: defType, multi: true }, defType);
      visitor({ provide: ENVIRONMENT_INITIALIZER, useValue: () => \u0275\u0275inject(defType), multi: true }, defType);
    }
    const defProviders = injDef.providers;
    if (defProviders != null && !isDuplicate) {
      const injectorType = container;
      deepForEachProvider(defProviders, (provider) => {
        ngDevMode && validateProvider(provider, defProviders, injectorType);
        visitor(provider, injectorType);
      });
    }
  } else {
    return false;
  }
  return defType !== container && container.providers !== void 0;
}
function validateProvider(provider, providers, containerType) {
  if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) || isExistingProvider(provider)) {
    return;
  }
  const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
  if (!classRef) {
    throwInvalidProviderError(containerType, providers, provider);
  }
}
function deepForEachProvider(providers, fn) {
  for (let provider of providers) {
    if (isEnvironmentProviders(provider)) {
      provider = provider.\u0275providers;
    }
    if (Array.isArray(provider)) {
      deepForEachProvider(provider, fn);
    } else {
      fn(provider);
    }
  }
}
function isValueProvider(value) {
  return value !== null && typeof value == "object" && USE_VALUE in value;
}
function isExistingProvider(value) {
  return !!(value && value.useExisting);
}
function isFactoryProvider(value) {
  return !!(value && value.useFactory);
}
function isTypeProvider(value) {
  return typeof value === "function";
}
function isClassProvider(value) {
  return !!value.useClass;
}
function getNullInjector() {
  if (NULL_INJECTOR === void 0) {
    NULL_INJECTOR = new NullInjector();
  }
  return NULL_INJECTOR;
}
function injectableDefOrInjectorDefFactory(token) {
  const injectableDef = getInjectableDef(token);
  const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);
  if (factory !== null) {
    return factory;
  }
  if (token instanceof InjectionToken) {
    throw new RuntimeError(204, ngDevMode && `Token ${stringify(token)} is missing a \u0275prov definition.`);
  }
  if (token instanceof Function) {
    return getUndecoratedInjectableFactory(token);
  }
  throw new RuntimeError(204, ngDevMode && "unreachable");
}
function getUndecoratedInjectableFactory(token) {
  const paramLength = token.length;
  if (paramLength > 0) {
    throw new RuntimeError(204, ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${newArray(paramLength, "?").join(", ")}).`);
  }
  const inheritedInjectableDef = getInheritedInjectableDef(token);
  if (inheritedInjectableDef !== null) {
    return () => inheritedInjectableDef.factory(token);
  } else {
    return () => new token();
  }
}
function providerToRecord(provider) {
  if (isValueProvider(provider)) {
    return makeRecord(void 0, provider.useValue);
  } else {
    const factory = providerToFactory(provider);
    return makeRecord(factory, NOT_YET);
  }
}
function providerToFactory(provider, ngModuleType, providers) {
  let factory = void 0;
  if (ngDevMode && isEnvironmentProviders(provider)) {
    throwInvalidProviderError(void 0, providers, provider);
  }
  if (isTypeProvider(provider)) {
    const unwrappedProvider = resolveForwardRef(provider);
    return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);
  } else {
    if (isValueProvider(provider)) {
      factory = () => resolveForwardRef(provider.useValue);
    } else if (isFactoryProvider(provider)) {
      factory = () => provider.useFactory(...injectArgs(provider.deps || []));
    } else if (isExistingProvider(provider)) {
      factory = (_, flags) => \u0275\u0275inject(resolveForwardRef(provider.useExisting), flags !== void 0 && flags & 8 ? 8 : void 0);
    } else {
      const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
      if (ngDevMode && !classRef) {
        throwInvalidProviderError(ngModuleType, providers, provider);
      }
      if (hasDeps(provider)) {
        factory = () => new classRef(...injectArgs(provider.deps));
      } else {
        return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);
      }
    }
  }
  return factory;
}
function assertNotDestroyed(injector) {
  if (injector.destroyed) {
    throw new RuntimeError(205, ngDevMode && "Injector has already been destroyed.");
  }
}
function makeRecord(factory, value, multi = false) {
  return {
    factory,
    value,
    multi: multi ? [] : void 0
  };
}
function hasDeps(value) {
  return !!value.deps;
}
function hasOnDestroy(value) {
  return value !== null && typeof value === "object" && typeof value.ngOnDestroy === "function";
}
function couldBeInjectableType(value) {
  return typeof value === "function" || typeof value === "object" && value.ngMetadataName === "InjectionToken";
}
function forEachSingleProvider(providers, fn) {
  for (const provider of providers) {
    if (Array.isArray(provider)) {
      forEachSingleProvider(provider, fn);
    } else if (provider && isEnvironmentProviders(provider)) {
      forEachSingleProvider(provider.\u0275providers, fn);
    } else {
      fn(provider);
    }
  }
}
function runInInjectionContext(injector, fn) {
  let internalInjector;
  if (injector instanceof R3Injector) {
    assertNotDestroyed(injector);
    internalInjector = injector;
  } else {
    internalInjector = new RetrievingInjector(injector);
  }
  let prevInjectorProfilerContext;
  if (ngDevMode) {
    prevInjectorProfilerContext = setInjectorProfilerContext({ injector, token: null });
  }
  const prevInjector = setCurrentInjector(internalInjector);
  const previousInjectImplementation = setInjectImplementation(void 0);
  try {
    return fn();
  } finally {
    setCurrentInjector(prevInjector);
    ngDevMode && setInjectorProfilerContext(prevInjectorProfilerContext);
    setInjectImplementation(previousInjectImplementation);
  }
}
function isInInjectionContext() {
  return getInjectImplementation() !== void 0 || getCurrentInjector() != null;
}
function assertInInjectionContext(debugFn) {
  if (!isInInjectionContext()) {
    throw new RuntimeError(-203, ngDevMode && debugFn.name + "() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`");
  }
}
function isLView(value) {
  return Array.isArray(value) && typeof value[TYPE] === "object";
}
function isLContainer(value) {
  return Array.isArray(value) && value[TYPE] === true;
}
function isContentQueryHost(tNode) {
  return (tNode.flags & 4) !== 0;
}
function isComponentHost(tNode) {
  return tNode.componentOffset > -1;
}
function isDirectiveHost(tNode) {
  return (tNode.flags & 1) === 1;
}
function isComponentDef(def) {
  return !!def.template;
}
function isRootView(target) {
  return (target[FLAGS] & 512) !== 0;
}
function isDestroyed(lView) {
  return (lView[FLAGS] & 256) === 256;
}
function assertTNodeForLView(tNode, lView) {
  assertTNodeForTView(tNode, lView[TVIEW]);
}
function assertTNodeCreationIndex(lView, index) {
  const adjustedIndex = index + HEADER_OFFSET;
  assertIndexInRange(lView, adjustedIndex);
  assertLessThan(adjustedIndex, lView[TVIEW].bindingStartIndex, "TNodes should be created before any bindings");
}
function assertTNodeForTView(tNode, tView) {
  assertTNode(tNode);
  const tData = tView.data;
  for (let i = HEADER_OFFSET; i < tData.length; i++) {
    if (tData[i] === tNode) {
      return;
    }
  }
  throwError2("This TNode does not belong to this TView.");
}
function assertTNode(tNode) {
  assertDefined(tNode, "TNode must be defined");
  if (!(tNode && typeof tNode === "object" && tNode.hasOwnProperty("directiveStylingLast"))) {
    throwError2("Not of type TNode, got: " + tNode);
  }
}
function assertTIcu(tIcu) {
  assertDefined(tIcu, "Expected TIcu to be defined");
  if (!(typeof tIcu.currentCaseLViewIndex === "number")) {
    throwError2("Object is not of TIcu type.");
  }
}
function assertComponentType(actual, msg = "Type passed in is not ComponentType, it does not have '\u0275cmp' property.") {
  if (!getComponentDef(actual)) {
    throwError2(msg);
  }
}
function assertNgModuleType(actual, msg = "Type passed in is not NgModuleType, it does not have '\u0275mod' property.") {
  if (!getNgModuleDef(actual)) {
    throwError2(msg);
  }
}
function assertHasParent(tNode) {
  assertDefined(tNode, "currentTNode should exist!");
  assertDefined(tNode.parent, "currentTNode should have a parent");
}
function assertLContainer(value) {
  assertDefined(value, "LContainer must be defined");
  assertEqual(isLContainer(value), true, "Expecting LContainer");
}
function assertLViewOrUndefined(value) {
  value && assertEqual(isLView(value), true, "Expecting LView or undefined or null");
}
function assertLView(value) {
  assertDefined(value, "LView must be defined");
  assertEqual(isLView(value), true, "Expecting LView");
}
function assertFirstCreatePass(tView, errMessage) {
  assertEqual(tView.firstCreatePass, true, errMessage || "Should only be called in first create pass.");
}
function assertFirstUpdatePass(tView, errMessage) {
  assertEqual(tView.firstUpdatePass, true, "Should only be called in first update pass.");
}
function assertDirectiveDef(obj) {
  if (obj.type === void 0 || obj.selectors == void 0 || obj.inputs === void 0) {
    throwError2(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);
  }
}
function assertIndexInDeclRange(tView, index) {
  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);
}
function assertIndexInExpandoRange(lView, index) {
  const tView = lView[1];
  assertBetween(tView.expandoStartIndex, lView.length, index);
}
function assertBetween(lower, upper, index) {
  if (!(lower <= index && index < upper)) {
    throwError2(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);
  }
}
function assertProjectionSlots(lView, errMessage) {
  assertDefined(lView[DECLARATION_COMPONENT_VIEW], "Component views should exist.");
  assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, "Components with projection nodes (<ng-content>) must have projection slots defined.");
}
function assertParentView(lView, errMessage) {
  assertDefined(lView, "Component views should always have a parent view (component's host view)");
}
function assertNodeInjector(lView, injectorIndex) {
  assertIndexInExpandoRange(lView, injectorIndex);
  assertIndexInExpandoRange(
    lView,
    injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  );
  assertNumber(lView[injectorIndex + 0], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 1], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 2], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 3], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 4], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 5], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 6], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 7], "injectorIndex should point to a bloom filter");
  assertNumber(lView[
    injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  ], "injectorIndex should point to parent injector");
}
function unwrapRNode(value) {
  while (Array.isArray(value)) {
    value = value[HOST];
  }
  return value;
}
function unwrapLView(value) {
  while (Array.isArray(value)) {
    if (typeof value[TYPE] === "object")
      return value;
    value = value[HOST];
  }
  return null;
}
function getNativeByIndex(index, lView) {
  ngDevMode && assertIndexInRange(lView, index);
  ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, "Expected to be past HEADER_OFFSET");
  return unwrapRNode(lView[index]);
}
function getNativeByTNode(tNode, lView) {
  ngDevMode && assertTNodeForLView(tNode, lView);
  ngDevMode && assertIndexInRange(lView, tNode.index);
  const node = unwrapRNode(lView[tNode.index]);
  return node;
}
function getTNode(tView, index) {
  ngDevMode && assertGreaterThan(index, -1, "wrong index for TNode");
  ngDevMode && assertLessThan(index, tView.data.length, "wrong index for TNode");
  const tNode = tView.data[index];
  ngDevMode && tNode !== null && assertTNode(tNode);
  return tNode;
}
function load(view, index) {
  ngDevMode && assertIndexInRange(view, index);
  return view[index];
}
function store(tView, lView, index, value) {
  if (index >= tView.data.length) {
    tView.data[index] = null;
    tView.blueprint[index] = null;
  }
  lView[index] = value;
}
function getComponentLViewByIndex(nodeIndex, hostView) {
  ngDevMode && assertIndexInRange(hostView, nodeIndex);
  const slotValue = hostView[nodeIndex];
  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];
  return lView;
}
function isCreationMode(view) {
  return (view[FLAGS] & 4) === 4;
}
function viewAttachedToChangeDetector(view) {
  return (view[FLAGS] & 128) === 128;
}
function viewAttachedToContainer(view) {
  return isLContainer(view[PARENT]);
}
function getConstant(consts, index) {
  if (index === null || index === void 0)
    return null;
  ngDevMode && assertIndexInRange(consts, index);
  return consts[index];
}
function resetPreOrderHookFlags(lView) {
  lView[PREORDER_HOOK_FLAGS] = 0;
}
function markViewForRefresh(lView) {
  if (lView[FLAGS] & 1024) {
    return;
  }
  lView[FLAGS] |= 1024;
  if (viewAttachedToChangeDetector(lView)) {
    markAncestorsForTraversal(lView);
  }
}
function walkUpViews(nestingLevel, currentView) {
  while (nestingLevel > 0) {
    ngDevMode && assertDefined(currentView[DECLARATION_VIEW], "Declaration view should be defined if nesting level is greater than 0.");
    currentView = currentView[DECLARATION_VIEW];
    nestingLevel--;
  }
  return currentView;
}
function requiresRefreshOrTraversal(lView) {
  return !!(lView[FLAGS] & (1024 | 8192) || lView[REACTIVE_TEMPLATE_CONSUMER]?.dirty);
}
function updateAncestorTraversalFlagsOnAttach(lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(
    8
    /* NotificationSource.ViewAttached */
  );
  if (lView[FLAGS] & 64) {
    lView[FLAGS] |= 1024;
  }
  if (requiresRefreshOrTraversal(lView)) {
    markAncestorsForTraversal(lView);
  }
}
function markAncestorsForTraversal(lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(
    0
    /* NotificationSource.MarkAncestorsForTraversal */
  );
  let parent = getLViewParent(lView);
  while (parent !== null) {
    if (parent[FLAGS] & 8192) {
      break;
    }
    parent[FLAGS] |= 8192;
    if (!viewAttachedToChangeDetector(parent)) {
      break;
    }
    parent = getLViewParent(parent);
  }
}
function storeLViewOnDestroy(lView, onDestroyCallback) {
  if (isDestroyed(lView)) {
    throw new RuntimeError(911, ngDevMode && "View has already been destroyed.");
  }
  if (lView[ON_DESTROY_HOOKS] === null) {
    lView[ON_DESTROY_HOOKS] = [];
  }
  lView[ON_DESTROY_HOOKS].push(onDestroyCallback);
}
function removeLViewOnDestroy(lView, onDestroyCallback) {
  if (lView[ON_DESTROY_HOOKS] === null)
    return;
  const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);
  if (destroyCBIdx !== -1) {
    lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);
  }
}
function getLViewParent(lView) {
  ngDevMode && assertLView(lView);
  const parent = lView[PARENT];
  return isLContainer(parent) ? parent[PARENT] : parent;
}
function getOrCreateLViewCleanup(view) {
  return view[CLEANUP] ??= [];
}
function getOrCreateTViewCleanup(tView) {
  return tView.cleanup ??= [];
}
function storeCleanupWithContext(tView, lView, context2, cleanupFn) {
  const lCleanup = getOrCreateLViewCleanup(lView);
  ngDevMode && assertDefined(context2, "Cleanup context is mandatory when registering framework-level destroy hooks");
  lCleanup.push(context2);
  if (tView.firstCreatePass) {
    getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);
  } else {
    if (ngDevMode) {
      Object.freeze(getOrCreateTViewCleanup(tView));
    }
  }
}
function getElementDepthCount() {
  return instructionState.lFrame.elementDepthCount;
}
function increaseElementDepthCount() {
  instructionState.lFrame.elementDepthCount++;
}
function decreaseElementDepthCount() {
  instructionState.lFrame.elementDepthCount--;
}
function getBindingsEnabled() {
  return instructionState.bindingsEnabled;
}
function isInSkipHydrationBlock() {
  return instructionState.skipHydrationRootTNode !== null;
}
function isSkipHydrationRootTNode(tNode) {
  return instructionState.skipHydrationRootTNode === tNode;
}
function \u0275\u0275enableBindings() {
  instructionState.bindingsEnabled = true;
}
function \u0275\u0275disableBindings() {
  instructionState.bindingsEnabled = false;
}
function leaveSkipHydrationBlock() {
  instructionState.skipHydrationRootTNode = null;
}
function getLView() {
  return instructionState.lFrame.lView;
}
function getTView() {
  return instructionState.lFrame.tView;
}
function \u0275\u0275restoreView(viewToRestore) {
  instructionState.lFrame.contextLView = viewToRestore;
  return viewToRestore[CONTEXT];
}
function \u0275\u0275resetView(value) {
  instructionState.lFrame.contextLView = null;
  return value;
}
function getCurrentTNode() {
  let currentTNode = getCurrentTNodePlaceholderOk();
  while (currentTNode !== null && currentTNode.type === 64) {
    currentTNode = currentTNode.parent;
  }
  return currentTNode;
}
function getCurrentTNodePlaceholderOk() {
  return instructionState.lFrame.currentTNode;
}
function getCurrentParentTNode() {
  const lFrame = instructionState.lFrame;
  const currentTNode = lFrame.currentTNode;
  return lFrame.isParent ? currentTNode : currentTNode.parent;
}
function setCurrentTNode(tNode, isParent2) {
  ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);
  const lFrame = instructionState.lFrame;
  lFrame.currentTNode = tNode;
  lFrame.isParent = isParent2;
}
function isCurrentTNodeParent() {
  return instructionState.lFrame.isParent;
}
function setCurrentTNodeAsNotParent() {
  instructionState.lFrame.isParent = false;
}
function getContextLView() {
  const contextLView = instructionState.lFrame.contextLView;
  ngDevMode && assertDefined(contextLView, "contextLView must be defined.");
  return contextLView;
}
function isInCheckNoChangesMode() {
  !ngDevMode && throwError2("Must never be called in production mode");
  return _checkNoChangesMode !== CheckNoChangesMode.Off;
}
function isExhaustiveCheckNoChanges() {
  !ngDevMode && throwError2("Must never be called in production mode");
  return _checkNoChangesMode === CheckNoChangesMode.Exhaustive;
}
function setIsInCheckNoChangesMode(mode) {
  !ngDevMode && throwError2("Must never be called in production mode");
  _checkNoChangesMode = mode;
}
function isRefreshingViews() {
  return _isRefreshingViews;
}
function setIsRefreshingViews(mode) {
  const prev = _isRefreshingViews;
  _isRefreshingViews = mode;
  return prev;
}
function getBindingRoot() {
  const lFrame = instructionState.lFrame;
  let index = lFrame.bindingRootIndex;
  if (index === -1) {
    index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;
  }
  return index;
}
function getBindingIndex() {
  return instructionState.lFrame.bindingIndex;
}
function setBindingIndex(value) {
  return instructionState.lFrame.bindingIndex = value;
}
function nextBindingIndex() {
  return instructionState.lFrame.bindingIndex++;
}
function incrementBindingIndex(count2) {
  const lFrame = instructionState.lFrame;
  const index = lFrame.bindingIndex;
  lFrame.bindingIndex = lFrame.bindingIndex + count2;
  return index;
}
function isInI18nBlock() {
  return instructionState.lFrame.inI18n;
}
function setInI18nBlock(isInI18nBlock2) {
  instructionState.lFrame.inI18n = isInI18nBlock2;
}
function setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {
  const lFrame = instructionState.lFrame;
  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;
  setCurrentDirectiveIndex(currentDirectiveIndex);
}
function getCurrentDirectiveIndex() {
  return instructionState.lFrame.currentDirectiveIndex;
}
function setCurrentDirectiveIndex(currentDirectiveIndex) {
  instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;
}
function getCurrentDirectiveDef(tData) {
  const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;
  return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];
}
function getCurrentQueryIndex() {
  return instructionState.lFrame.currentQueryIndex;
}
function setCurrentQueryIndex(value) {
  instructionState.lFrame.currentQueryIndex = value;
}
function getDeclarationTNode(lView) {
  const tView = lView[TVIEW];
  if (tView.type === 2) {
    ngDevMode && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents.");
    return tView.declTNode;
  }
  if (tView.type === 1) {
    return lView[T_HOST];
  }
  return null;
}
function enterDI(lView, tNode, flags) {
  ngDevMode && assertLViewOrUndefined(lView);
  if (flags & 4) {
    ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);
    let parentTNode = tNode;
    let parentLView = lView;
    while (true) {
      ngDevMode && assertDefined(parentTNode, "Parent TNode should be defined");
      parentTNode = parentTNode.parent;
      if (parentTNode === null && !(flags & 1)) {
        parentTNode = getDeclarationTNode(parentLView);
        if (parentTNode === null)
          break;
        ngDevMode && assertDefined(parentLView, "Parent LView should be defined");
        parentLView = parentLView[DECLARATION_VIEW];
        if (parentTNode.type & (2 | 8)) {
          break;
        }
      } else {
        break;
      }
    }
    if (parentTNode === null) {
      return false;
    } else {
      tNode = parentTNode;
      lView = parentLView;
    }
  }
  ngDevMode && assertTNodeForLView(tNode, lView);
  const lFrame = instructionState.lFrame = allocLFrame();
  lFrame.currentTNode = tNode;
  lFrame.lView = lView;
  return true;
}
function enterView(newView) {
  ngDevMode && assertNotEqual(newView[0], newView[1], "????");
  ngDevMode && assertLViewOrUndefined(newView);
  const newLFrame = allocLFrame();
  if (ngDevMode) {
    assertEqual(newLFrame.isParent, true, "Expected clean LFrame");
    assertEqual(newLFrame.lView, null, "Expected clean LFrame");
    assertEqual(newLFrame.tView, null, "Expected clean LFrame");
    assertEqual(newLFrame.selectedIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.elementDepthCount, 0, "Expected clean LFrame");
    assertEqual(newLFrame.currentDirectiveIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.currentNamespace, null, "Expected clean LFrame");
    assertEqual(newLFrame.bindingRootIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.currentQueryIndex, 0, "Expected clean LFrame");
  }
  const tView = newView[TVIEW];
  instructionState.lFrame = newLFrame;
  ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);
  newLFrame.currentTNode = tView.firstChild;
  newLFrame.lView = newView;
  newLFrame.tView = tView;
  newLFrame.contextLView = newView;
  newLFrame.bindingIndex = tView.bindingStartIndex;
  newLFrame.inI18n = false;
}
function allocLFrame() {
  const currentLFrame = instructionState.lFrame;
  const childLFrame = currentLFrame === null ? null : currentLFrame.child;
  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;
  return newLFrame;
}
function createLFrame(parent) {
  const lFrame = {
    currentTNode: null,
    isParent: true,
    lView: null,
    tView: null,
    selectedIndex: -1,
    contextLView: null,
    elementDepthCount: 0,
    currentNamespace: null,
    currentDirectiveIndex: -1,
    bindingRootIndex: -1,
    bindingIndex: -1,
    currentQueryIndex: 0,
    parent,
    child: null,
    inI18n: false
  };
  parent !== null && (parent.child = lFrame);
  return lFrame;
}
function leaveViewLight() {
  const oldLFrame = instructionState.lFrame;
  instructionState.lFrame = oldLFrame.parent;
  oldLFrame.currentTNode = null;
  oldLFrame.lView = null;
  return oldLFrame;
}
function leaveView() {
  const oldLFrame = leaveViewLight();
  oldLFrame.isParent = true;
  oldLFrame.tView = null;
  oldLFrame.selectedIndex = -1;
  oldLFrame.contextLView = null;
  oldLFrame.elementDepthCount = 0;
  oldLFrame.currentDirectiveIndex = -1;
  oldLFrame.currentNamespace = null;
  oldLFrame.bindingRootIndex = -1;
  oldLFrame.bindingIndex = -1;
  oldLFrame.currentQueryIndex = 0;
}
function nextContextImpl(level) {
  const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);
  return contextLView[CONTEXT];
}
function getSelectedIndex() {
  return instructionState.lFrame.selectedIndex;
}
function setSelectedIndex(index) {
  ngDevMode && index !== -1 && assertGreaterThanOrEqual(index, HEADER_OFFSET, "Index must be past HEADER_OFFSET (or -1).");
  ngDevMode && assertLessThan(index, instructionState.lFrame.lView.length, "Can't set index passed end of LView");
  instructionState.lFrame.selectedIndex = index;
}
function getSelectedTNode() {
  const lFrame = instructionState.lFrame;
  return getTNode(lFrame.tView, lFrame.selectedIndex);
}
function \u0275\u0275namespaceSVG() {
  instructionState.lFrame.currentNamespace = SVG_NAMESPACE;
}
function \u0275\u0275namespaceMathML() {
  instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;
}
function \u0275\u0275namespaceHTML() {
  namespaceHTMLInternal();
}
function namespaceHTMLInternal() {
  instructionState.lFrame.currentNamespace = null;
}
function getNamespace() {
  return instructionState.lFrame.currentNamespace;
}
function wasLastNodeCreated() {
  return _wasLastNodeCreated;
}
function lastNodeWasCreated(flag) {
  _wasLastNodeCreated = flag;
}
function createInjector(defType, parent = null, additionalProviders = null, name2) {
  const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name2);
  injector.resolveInjectorInitializers();
  return injector;
}
function createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name2, scopes = /* @__PURE__ */ new Set()) {
  const providers = [additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType)];
  name2 = name2 || (typeof defType === "object" ? void 0 : stringify(defType));
  return new R3Injector(providers, parent || getNullInjector(), name2 || null, scopes);
}
function injectDestroyRef() {
  return new NodeInjectorDestroyRef(getLView());
}
function provideBrowserGlobalErrorListeners() {
  return makeEnvironmentProviders([
    provideEnvironmentInitializer(() => void inject2(globalErrorListeners))
  ]);
}
function isSignal(value) {
  return typeof value === "function" && value[SIGNAL] !== void 0;
}
function signal(initialValue, options) {
  const [get, set, update] = createSignal(initialValue, options?.equal);
  const signalFn = get;
  const node = signalFn[SIGNAL];
  signalFn.set = set;
  signalFn.update = update;
  signalFn.asReadonly = signalAsReadonlyFn.bind(signalFn);
  if (ngDevMode) {
    signalFn.toString = () => `[Signal: ${signalFn()}]`;
    node.debugName = options?.debugName;
  }
  return signalFn;
}
function signalAsReadonlyFn() {
  const node = this[SIGNAL];
  if (node.readonlyFn === void 0) {
    const readonlyFn = () => this();
    readonlyFn[SIGNAL] = node;
    node.readonlyFn = readonlyFn;
  }
  return node.readonlyFn;
}
function isWritableSignal(value) {
  return isSignal(value) && typeof value.set === "function";
}
function assertNotInReactiveContext(debugFn, extraContext) {
  if (getActiveConsumer() !== null) {
    throw new RuntimeError(-602, ngDevMode && `${debugFn.name}() cannot be called from within a reactive context.${extraContext ? ` ${extraContext}` : ""}`);
  }
}
function injectViewContext() {
  return new ViewContext(getLView(), getCurrentTNode());
}
function noop2(...args) {
}
var ERROR_DETAILS_PAGE_BASE_URL, XSS_SECURITY_URL, RuntimeError, _global, __forward_ref__, NG_PROV_DEF, NG_INJ_DEF, InjectionToken, _injectorProfilerContext, injectorProfilerCallbacks, NOOP_PROFILER_REMOVAL, NG_COMP_DEF, NG_DIR_DEF, NG_PIPE_DEF, NG_MOD_DEF, NG_FACTORY_DEF, NG_ELEMENT_ID, NG_ENV_ID, NG_RUNTIME_ERROR_CODE, NG_RUNTIME_ERROR_MESSAGE, NG_TOKEN_PATH, _injectImplementation, _THROW_IF_NOT_FOUND, THROW_IF_NOT_FOUND, DI_DECORATOR_FLAG, RetrievingInjector, EMPTY_OBJ, EMPTY_ARRAY, ENVIRONMENT_INITIALIZER, INJECTOR$1, INJECTOR_DEF_TYPES, NullInjector, USE_VALUE, INJECTOR_SCOPE, NOT_YET, CIRCULAR, NULL_INJECTOR, EnvironmentInjector, R3Injector, HOST, TVIEW, FLAGS, PARENT, NEXT, T_HOST, HYDRATION, CLEANUP, CONTEXT, INJECTOR, ENVIRONMENT, RENDERER, CHILD_HEAD, CHILD_TAIL, DECLARATION_VIEW, DECLARATION_COMPONENT_VIEW, DECLARATION_LCONTAINER, PREORDER_HOOK_FLAGS, QUERIES, ID, EMBEDDED_VIEW_INJECTOR, ON_DESTROY_HOOKS, EFFECTS_TO_SCHEDULE, EFFECTS, REACTIVE_TEMPLATE_CONSUMER, AFTER_RENDER_SEQUENCES_TO_ADD, HEADER_OFFSET, TYPE, DEHYDRATED_VIEWS, NATIVE, VIEW_REFS, MOVED_VIEWS, CONTAINER_HEADER_OFFSET, SVG_NAMESPACE, MATH_ML_NAMESPACE, instructionState, CheckNoChangesMode, _checkNoChangesMode, _isRefreshingViews, leaveDI, _wasLastNodeCreated, Injector, DOCUMENT, DestroyRef, NodeInjectorDestroyRef, ErrorHandler, INTERNAL_APPLICATION_ERROR_HANDLER, errorHandlerEnvironmentInitializer, globalErrorListeners, ChangeDetectionScheduler, ZONELESS_ENABLED, PROVIDED_ZONELESS, ZONELESS_SCHEDULER_DISABLED, SCHEDULE_IN_ROOT_ZONE, ViewContext, PendingTasksInternal, PendingTasks, EffectScheduler, ZoneAwareEffectScheduler;
var init_root_effect_scheduler = __esm({
  "node_modules/@angular/core/fesm2022/root_effect_scheduler.mjs"() {
    "use strict";
    init_not_found();
    init_signal();
    init_esm();
    init_signals();
    init_di();
    ERROR_DETAILS_PAGE_BASE_URL = "https://angular.dev/errors";
    XSS_SECURITY_URL = "https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss";
    RuntimeError = class extends Error {
      code;
      constructor(code, message) {
        super(formatRuntimeError(code, message));
        this.code = code;
      }
    };
    _global = globalThis;
    __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });
    NG_PROV_DEF = getClosureSafeProperty({ \u0275prov: getClosureSafeProperty });
    NG_INJ_DEF = getClosureSafeProperty({ \u0275inj: getClosureSafeProperty });
    InjectionToken = class {
      _desc;
      /** @internal */
      ngMetadataName = "InjectionToken";
      \u0275prov;
      /**
       * @param _desc   Description for the token,
       *                used only for debugging purposes,
       *                it should but does not need to be unique
       * @param options Options for the token's usage, as described above
       */
      constructor(_desc, options) {
        this._desc = _desc;
        this.\u0275prov = void 0;
        if (typeof options == "number") {
          (typeof ngDevMode === "undefined" || ngDevMode) && assertLessThan(options, 0, "Only negative numbers are supported here");
          this.__NG_ELEMENT_ID__ = options;
        } else if (options !== void 0) {
          this.\u0275prov = \u0275\u0275defineInjectable({
            token: this,
            providedIn: options.providedIn || "root",
            factory: options.factory
          });
        }
      }
      /**
       * @internal
       */
      get multi() {
        return this;
      }
      toString() {
        return `InjectionToken ${this._desc}`;
      }
    };
    injectorProfilerCallbacks = [];
    NOOP_PROFILER_REMOVAL = () => {
    };
    NG_COMP_DEF = getClosureSafeProperty({ \u0275cmp: getClosureSafeProperty });
    NG_DIR_DEF = getClosureSafeProperty({ \u0275dir: getClosureSafeProperty });
    NG_PIPE_DEF = getClosureSafeProperty({ \u0275pipe: getClosureSafeProperty });
    NG_MOD_DEF = getClosureSafeProperty({ \u0275mod: getClosureSafeProperty });
    NG_FACTORY_DEF = getClosureSafeProperty({ \u0275fac: getClosureSafeProperty });
    NG_ELEMENT_ID = getClosureSafeProperty({
      __NG_ELEMENT_ID__: getClosureSafeProperty
    });
    NG_ENV_ID = getClosureSafeProperty({ __NG_ENV_ID__: getClosureSafeProperty });
    NG_RUNTIME_ERROR_CODE = getClosureSafeProperty({ "ngErrorCode": getClosureSafeProperty });
    NG_RUNTIME_ERROR_MESSAGE = getClosureSafeProperty({ "ngErrorMessage": getClosureSafeProperty });
    NG_TOKEN_PATH = getClosureSafeProperty({ "ngTokenPath": getClosureSafeProperty });
    _THROW_IF_NOT_FOUND = {};
    THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
    DI_DECORATOR_FLAG = "__NG_DI_FLAG__";
    RetrievingInjector = class {
      injector;
      constructor(injector) {
        this.injector = injector;
      }
      retrieve(token, options) {
        const flags = convertToBitFlags(options) || 0;
        try {
          return this.injector.get(
            token,
            // When a dependency is requested with an optional flag, DI returns null as the default value.
            flags & 8 ? null : THROW_IF_NOT_FOUND,
            flags
          );
        } catch (e) {
          if (isNotFound(e)) {
            return e;
          }
          throw e;
        }
      }
    };
    EMPTY_OBJ = {};
    EMPTY_ARRAY = [];
    if ((typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode()) {
      Object.freeze(EMPTY_OBJ);
      Object.freeze(EMPTY_ARRAY);
    }
    ENVIRONMENT_INITIALIZER = new InjectionToken(ngDevMode ? "ENVIRONMENT_INITIALIZER" : "");
    INJECTOR$1 = new InjectionToken(
      ngDevMode ? "INJECTOR" : "",
      // Disable tslint because this is const enum which gets inlined not top level prop access.
      // tslint:disable-next-line: no-toplevel-property-access
      -1
      /* InjectorMarkers.Injector */
    );
    INJECTOR_DEF_TYPES = new InjectionToken(ngDevMode ? "INJECTOR_DEF_TYPES" : "");
    NullInjector = class {
      get(token, notFoundValue = THROW_IF_NOT_FOUND) {
        if (notFoundValue === THROW_IF_NOT_FOUND) {
          const message = ngDevMode ? `No provider found for \`${stringify(token)}\`.` : "";
          const error = createRuntimeError(
            message,
            -201
            /* RuntimeErrorCode.PROVIDER_NOT_FOUND */
          );
          error.name = "\u0275NotFound";
          throw error;
        }
        return notFoundValue;
      }
    };
    USE_VALUE = getClosureSafeProperty({
      provide: String,
      useValue: getClosureSafeProperty
    });
    INJECTOR_SCOPE = new InjectionToken(ngDevMode ? "Set Injector scope." : "");
    NOT_YET = {};
    CIRCULAR = {};
    NULL_INJECTOR = void 0;
    EnvironmentInjector = class {
    };
    R3Injector = class extends EnvironmentInjector {
      parent;
      source;
      scopes;
      /**
       * Map of tokens to records which contain the instances of those tokens.
       * - `null` value implies that we don't have the record. Used by tree-shakable injectors
       * to prevent further searches.
       */
      records = /* @__PURE__ */ new Map();
      /**
       * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.
       */
      _ngOnDestroyHooks = /* @__PURE__ */ new Set();
      _onDestroyHooks = [];
      /**
       * Flag indicating that this injector was previously destroyed.
       */
      get destroyed() {
        return this._destroyed;
      }
      _destroyed = false;
      injectorDefTypes;
      constructor(providers, parent, source, scopes) {
        super();
        this.parent = parent;
        this.source = source;
        this.scopes = scopes;
        forEachSingleProvider(providers, (provider) => this.processProvider(provider));
        this.records.set(INJECTOR$1, makeRecord(void 0, this));
        if (scopes.has("environment")) {
          this.records.set(EnvironmentInjector, makeRecord(void 0, this));
        }
        const record = this.records.get(INJECTOR_SCOPE);
        if (record != null && typeof record.value === "string") {
          this.scopes.add(record.value);
        }
        this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES, EMPTY_ARRAY, { self: true }));
      }
      retrieve(token, options) {
        const flags = convertToBitFlags(options) || 0;
        try {
          return this.get(
            token,
            // When a dependency is requested with an optional flag, DI returns null as the default value.
            THROW_IF_NOT_FOUND,
            flags
          );
        } catch (e) {
          if (isNotFound(e)) {
            return e;
          }
          throw e;
        }
      }
      /**
       * Destroy the injector and release references to every instance or provider associated with it.
       *
       * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a
       * hook was found.
       */
      destroy() {
        assertNotDestroyed(this);
        this._destroyed = true;
        const prevConsumer = setActiveConsumer(null);
        try {
          for (const service of this._ngOnDestroyHooks) {
            service.ngOnDestroy();
          }
          const onDestroyHooks = this._onDestroyHooks;
          this._onDestroyHooks = [];
          for (const hook of onDestroyHooks) {
            hook();
          }
        } finally {
          this.records.clear();
          this._ngOnDestroyHooks.clear();
          this.injectorDefTypes.clear();
          setActiveConsumer(prevConsumer);
        }
      }
      onDestroy(callback) {
        assertNotDestroyed(this);
        this._onDestroyHooks.push(callback);
        return () => this.removeOnDestroy(callback);
      }
      runInContext(fn) {
        assertNotDestroyed(this);
        const previousInjector = setCurrentInjector(this);
        const previousInjectImplementation = setInjectImplementation(void 0);
        let prevInjectContext;
        if (ngDevMode) {
          prevInjectContext = setInjectorProfilerContext({ injector: this, token: null });
        }
        try {
          return fn();
        } finally {
          setCurrentInjector(previousInjector);
          setInjectImplementation(previousInjectImplementation);
          ngDevMode && setInjectorProfilerContext(prevInjectContext);
        }
      }
      get(token, notFoundValue = THROW_IF_NOT_FOUND, options) {
        assertNotDestroyed(this);
        if (token.hasOwnProperty(NG_ENV_ID)) {
          return token[NG_ENV_ID](this);
        }
        const flags = convertToBitFlags(options);
        let prevInjectContext;
        if (ngDevMode) {
          prevInjectContext = setInjectorProfilerContext({ injector: this, token });
        }
        const previousInjector = setCurrentInjector(this);
        const previousInjectImplementation = setInjectImplementation(void 0);
        try {
          if (!(flags & 4)) {
            let record = this.records.get(token);
            if (record === void 0) {
              const def = couldBeInjectableType(token) && getInjectableDef(token);
              if (def && this.injectableDefInScope(def)) {
                if (ngDevMode) {
                  runInInjectorProfilerContext(this, token, () => {
                    emitProviderConfiguredEvent(token);
                  });
                }
                record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);
              } else {
                record = null;
              }
              this.records.set(token, record);
            }
            if (record != null) {
              return this.hydrate(token, record, flags);
            }
          }
          const nextInjector = !(flags & 2) ? this.parent : getNullInjector();
          notFoundValue = flags & 8 && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;
          return nextInjector.get(token, notFoundValue);
        } catch (error) {
          const errorCode = getRuntimeErrorCode(error);
          if (errorCode === -200 || errorCode === -201) {
            if (!ngDevMode) {
              throw new RuntimeError(errorCode, null);
            }
            prependTokenToDependencyPath(error, token);
            if (previousInjector) {
              throw error;
            } else {
              throw augmentRuntimeError(error, this.source);
            }
          } else {
            throw error;
          }
        } finally {
          setInjectImplementation(previousInjectImplementation);
          setCurrentInjector(previousInjector);
          ngDevMode && setInjectorProfilerContext(prevInjectContext);
        }
      }
      /** @internal */
      resolveInjectorInitializers() {
        const prevConsumer = setActiveConsumer(null);
        const previousInjector = setCurrentInjector(this);
        const previousInjectImplementation = setInjectImplementation(void 0);
        let prevInjectContext;
        if (ngDevMode) {
          prevInjectContext = setInjectorProfilerContext({ injector: this, token: null });
        }
        try {
          const initializers = this.get(ENVIRONMENT_INITIALIZER, EMPTY_ARRAY, { self: true });
          if (ngDevMode && !Array.isArray(initializers)) {
            throw new RuntimeError(-209, `Unexpected type of the \`ENVIRONMENT_INITIALIZER\` token value (expected an array, but got ${typeof initializers}). Please check that the \`ENVIRONMENT_INITIALIZER\` token is configured as a \`multi: true\` provider.`);
          }
          for (const initializer of initializers) {
            initializer();
          }
        } finally {
          setCurrentInjector(previousInjector);
          setInjectImplementation(previousInjectImplementation);
          ngDevMode && setInjectorProfilerContext(prevInjectContext);
          setActiveConsumer(prevConsumer);
        }
      }
      toString() {
        const tokens = [];
        const records = this.records;
        for (const token of records.keys()) {
          tokens.push(stringify(token));
        }
        return `R3Injector[${tokens.join(", ")}]`;
      }
      /**
       * Process a `SingleProvider` and add it.
       */
      processProvider(provider) {
        provider = resolveForwardRef(provider);
        let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);
        const record = providerToRecord(provider);
        if (ngDevMode) {
          runInInjectorProfilerContext(this, token, () => {
            if (isValueProvider(provider)) {
              emitInjectorToCreateInstanceEvent(token);
              emitInstanceCreatedByInjectorEvent(provider.useValue);
            }
            emitProviderConfiguredEvent(provider);
          });
        }
        if (!isTypeProvider(provider) && provider.multi === true) {
          let multiRecord = this.records.get(token);
          if (multiRecord) {
            if (ngDevMode && multiRecord.multi === void 0) {
              throwMixedMultiProviderError();
            }
          } else {
            multiRecord = makeRecord(void 0, NOT_YET, true);
            multiRecord.factory = () => injectArgs(multiRecord.multi);
            this.records.set(token, multiRecord);
          }
          token = provider;
          multiRecord.multi.push(provider);
        } else {
          if (ngDevMode) {
            const existing = this.records.get(token);
            if (existing && existing.multi !== void 0) {
              throwMixedMultiProviderError();
            }
          }
        }
        this.records.set(token, record);
      }
      hydrate(token, record, flags) {
        const prevConsumer = setActiveConsumer(null);
        try {
          if (record.value === CIRCULAR) {
            throw cyclicDependencyError(stringify(token));
          } else if (record.value === NOT_YET) {
            record.value = CIRCULAR;
            if (ngDevMode) {
              runInInjectorProfilerContext(this, token, () => {
                emitInjectorToCreateInstanceEvent(token);
                record.value = record.factory(void 0, flags);
                emitInstanceCreatedByInjectorEvent(record.value);
              });
            } else {
              record.value = record.factory(void 0, flags);
            }
          }
          if (typeof record.value === "object" && record.value && hasOnDestroy(record.value)) {
            this._ngOnDestroyHooks.add(record.value);
          }
          return record.value;
        } finally {
          setActiveConsumer(prevConsumer);
        }
      }
      injectableDefInScope(def) {
        if (!def.providedIn) {
          return false;
        }
        const providedIn = resolveForwardRef(def.providedIn);
        if (typeof providedIn === "string") {
          return providedIn === "any" || this.scopes.has(providedIn);
        } else {
          return this.injectorDefTypes.has(providedIn);
        }
      }
      removeOnDestroy(callback) {
        const destroyCBIdx = this._onDestroyHooks.indexOf(callback);
        if (destroyCBIdx !== -1) {
          this._onDestroyHooks.splice(destroyCBIdx, 1);
        }
      }
    };
    HOST = 0;
    TVIEW = 1;
    FLAGS = 2;
    PARENT = 3;
    NEXT = 4;
    T_HOST = 5;
    HYDRATION = 6;
    CLEANUP = 7;
    CONTEXT = 8;
    INJECTOR = 9;
    ENVIRONMENT = 10;
    RENDERER = 11;
    CHILD_HEAD = 12;
    CHILD_TAIL = 13;
    DECLARATION_VIEW = 14;
    DECLARATION_COMPONENT_VIEW = 15;
    DECLARATION_LCONTAINER = 16;
    PREORDER_HOOK_FLAGS = 17;
    QUERIES = 18;
    ID = 19;
    EMBEDDED_VIEW_INJECTOR = 20;
    ON_DESTROY_HOOKS = 21;
    EFFECTS_TO_SCHEDULE = 22;
    EFFECTS = 23;
    REACTIVE_TEMPLATE_CONSUMER = 24;
    AFTER_RENDER_SEQUENCES_TO_ADD = 25;
    HEADER_OFFSET = 26;
    TYPE = 1;
    DEHYDRATED_VIEWS = 6;
    NATIVE = 7;
    VIEW_REFS = 8;
    MOVED_VIEWS = 9;
    CONTAINER_HEADER_OFFSET = 10;
    SVG_NAMESPACE = "svg";
    MATH_ML_NAMESPACE = "math";
    instructionState = {
      lFrame: createLFrame(null),
      bindingsEnabled: true,
      skipHydrationRootTNode: null
    };
    (function(CheckNoChangesMode2) {
      CheckNoChangesMode2[CheckNoChangesMode2["Off"] = 0] = "Off";
      CheckNoChangesMode2[CheckNoChangesMode2["Exhaustive"] = 1] = "Exhaustive";
      CheckNoChangesMode2[CheckNoChangesMode2["OnlyDirtyViews"] = 2] = "OnlyDirtyViews";
    })(CheckNoChangesMode || (CheckNoChangesMode = {}));
    _checkNoChangesMode = 0;
    _isRefreshingViews = false;
    leaveDI = leaveViewLight;
    _wasLastNodeCreated = true;
    Injector = class _Injector {
      static THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
      static NULL = new NullInjector();
      static create(options, parent) {
        if (Array.isArray(options)) {
          return createInjector({ name: "" }, parent, options, "");
        } else {
          const name2 = options.name ?? "";
          return createInjector({ name: name2 }, options.parent, options.providers, name2);
        }
      }
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _Injector,
          providedIn: "any",
          factory: () => \u0275\u0275inject(INJECTOR$1)
        })
      );
      /**
       * @internal
       * @nocollapse
       */
      static __NG_ELEMENT_ID__ = -1;
    };
    DOCUMENT = new InjectionToken(ngDevMode ? "DocumentToken" : "");
    DestroyRef = class {
      /**
       * @internal
       * @nocollapse
       */
      static __NG_ELEMENT_ID__ = injectDestroyRef;
      /**
       * @internal
       * @nocollapse
       */
      static __NG_ENV_ID__ = (injector) => injector;
    };
    NodeInjectorDestroyRef = class extends DestroyRef {
      _lView;
      constructor(_lView) {
        super();
        this._lView = _lView;
      }
      get destroyed() {
        return isDestroyed(this._lView);
      }
      onDestroy(callback) {
        const lView = this._lView;
        storeLViewOnDestroy(lView, callback);
        return () => removeLViewOnDestroy(lView, callback);
      }
    };
    ErrorHandler = class {
      /**
       * @internal
       */
      _console = console;
      handleError(error) {
        this._console.error("ERROR", error);
      }
    };
    INTERNAL_APPLICATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "internal error handler" : "", {
      providedIn: "root",
      factory: () => {
        const injector = inject2(EnvironmentInjector);
        let userErrorHandler;
        return (e) => {
          if (injector.destroyed && !userErrorHandler) {
            setTimeout(() => {
              throw e;
            });
          } else {
            userErrorHandler ??= injector.get(ErrorHandler);
            userErrorHandler.handleError(e);
          }
        };
      }
    });
    errorHandlerEnvironmentInitializer = {
      provide: ENVIRONMENT_INITIALIZER,
      useValue: () => void inject2(ErrorHandler),
      multi: true
    };
    globalErrorListeners = new InjectionToken(ngDevMode ? "GlobalErrorListeners" : "", {
      providedIn: "root",
      factory: () => {
        if (false) {
          return;
        }
        const window2 = inject2(DOCUMENT).defaultView;
        if (!window2) {
          return;
        }
        const errorHandler2 = inject2(INTERNAL_APPLICATION_ERROR_HANDLER);
        const rejectionListener = (e) => {
          errorHandler2(e.reason);
          e.preventDefault();
        };
        const errorListener = (e) => {
          if (e.error) {
            errorHandler2(e.error);
          } else {
            errorHandler2(new Error(ngDevMode ? `An ErrorEvent with no error occurred. See Error.cause for details: ${e.message}` : e.message, { cause: e }));
          }
          e.preventDefault();
        };
        const setupEventListeners = () => {
          window2.addEventListener("unhandledrejection", rejectionListener);
          window2.addEventListener("error", errorListener);
        };
        if (typeof Zone !== "undefined") {
          Zone.root.run(setupEventListeners);
        } else {
          setupEventListeners();
        }
        inject2(DestroyRef).onDestroy(() => {
          window2.removeEventListener("error", errorListener);
          window2.removeEventListener("unhandledrejection", rejectionListener);
        });
      }
    });
    ChangeDetectionScheduler = class {
    };
    ZONELESS_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "Zoneless enabled" : "", { providedIn: "root", factory: () => false });
    PROVIDED_ZONELESS = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "Zoneless provided" : "", { providedIn: "root", factory: () => false });
    ZONELESS_SCHEDULER_DISABLED = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "scheduler disabled" : "");
    SCHEDULE_IN_ROOT_ZONE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "run changes outside zone in root" : "");
    ViewContext = class {
      view;
      node;
      constructor(view, node) {
        this.view = view;
        this.node = node;
      }
      /**
       * @internal
       * @nocollapse
       */
      static __NG_ELEMENT_ID__ = injectViewContext;
    };
    PendingTasksInternal = class _PendingTasksInternal {
      taskId = 0;
      pendingTasks = /* @__PURE__ */ new Set();
      destroyed = false;
      pendingTask = new BehaviorSubject(false);
      get hasPendingTasks() {
        return this.destroyed ? false : this.pendingTask.value;
      }
      /**
       * In case the service is about to be destroyed, return a self-completing observable.
       * Otherwise, return the observable that emits the current state of pending tasks.
       */
      get hasPendingTasksObservable() {
        if (this.destroyed) {
          return new Observable((subscriber) => {
            subscriber.next(false);
            subscriber.complete();
          });
        }
        return this.pendingTask;
      }
      add() {
        if (!this.hasPendingTasks && !this.destroyed) {
          this.pendingTask.next(true);
        }
        const taskId = this.taskId++;
        this.pendingTasks.add(taskId);
        return taskId;
      }
      has(taskId) {
        return this.pendingTasks.has(taskId);
      }
      remove(taskId) {
        this.pendingTasks.delete(taskId);
        if (this.pendingTasks.size === 0 && this.hasPendingTasks) {
          this.pendingTask.next(false);
        }
      }
      ngOnDestroy() {
        this.pendingTasks.clear();
        if (this.hasPendingTasks) {
          this.pendingTask.next(false);
        }
        this.destroyed = true;
        this.pendingTask.unsubscribe();
      }
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _PendingTasksInternal,
          providedIn: "root",
          factory: () => new _PendingTasksInternal()
        })
      );
    };
    PendingTasks = class _PendingTasks {
      internalPendingTasks = inject2(PendingTasksInternal);
      scheduler = inject2(ChangeDetectionScheduler);
      errorHandler = inject2(INTERNAL_APPLICATION_ERROR_HANDLER);
      /**
       * Adds a new task that should block application's stability.
       * @returns A cleanup function that removes a task when called.
       */
      add() {
        const taskId = this.internalPendingTasks.add();
        return () => {
          if (!this.internalPendingTasks.has(taskId)) {
            return;
          }
          this.scheduler.notify(
            11
            /* NotificationSource.PendingTaskRemoved */
          );
          this.internalPendingTasks.remove(taskId);
        };
      }
      /**
       * Runs an asynchronous function and blocks the application's stability until the function completes.
       *
       * ```ts
       * pendingTasks.run(async () => {
       *   const userData = await fetch('/api/user');
       *   this.userData.set(userData);
       * });
       * ```
       *
       * @param fn The asynchronous function to execute
       * @developerPreview 19.0
       */
      run(fn) {
        const removeTask = this.add();
        fn().catch(this.errorHandler).finally(removeTask);
      }
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _PendingTasks,
          providedIn: "root",
          factory: () => new _PendingTasks()
        })
      );
    };
    EffectScheduler = class _EffectScheduler {
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _EffectScheduler,
          providedIn: "root",
          factory: () => new ZoneAwareEffectScheduler()
        })
      );
    };
    ZoneAwareEffectScheduler = class {
      dirtyEffectCount = 0;
      queues = /* @__PURE__ */ new Map();
      add(handle) {
        this.enqueue(handle);
        this.schedule(handle);
      }
      schedule(handle) {
        if (!handle.dirty) {
          return;
        }
        this.dirtyEffectCount++;
      }
      remove(handle) {
        const zone = handle.zone;
        const queue = this.queues.get(zone);
        if (!queue.has(handle)) {
          return;
        }
        queue.delete(handle);
        if (handle.dirty) {
          this.dirtyEffectCount--;
        }
      }
      enqueue(handle) {
        const zone = handle.zone;
        if (!this.queues.has(zone)) {
          this.queues.set(zone, /* @__PURE__ */ new Set());
        }
        const queue = this.queues.get(zone);
        if (queue.has(handle)) {
          return;
        }
        queue.add(handle);
      }
      /**
       * Run all scheduled effects.
       *
       * Execution order of effects within the same zone is guaranteed to be FIFO, but there is no
       * ordering guarantee between effects scheduled in different zones.
       */
      flush() {
        while (this.dirtyEffectCount > 0) {
          let ranOneEffect = false;
          for (const [zone, queue] of this.queues) {
            if (zone === null) {
              ranOneEffect ||= this.flushQueue(queue);
            } else {
              ranOneEffect ||= zone.run(() => this.flushQueue(queue));
            }
          }
          if (!ranOneEffect) {
            this.dirtyEffectCount = 0;
          }
        }
      }
      flushQueue(queue) {
        let ranOneEffect = false;
        for (const handle of queue) {
          if (!handle.dirty) {
            continue;
          }
          this.dirtyEffectCount--;
          ranOneEffect = true;
          handle.run();
        }
        return ranOneEffect;
      }
    };
  }
});

// node_modules/rxjs/dist/esm/operators/index.js
var init_operators = __esm({
  "node_modules/rxjs/dist/esm/operators/index.js"() {
    "use strict";
    init_auditTime();
    init_catchError();
    init_concatMap();
    init_defaultIfEmpty();
    init_distinctUntilChanged();
    init_filter();
    init_finalize();
    init_first();
    init_last();
    init_map();
    init_mergeAll();
    init_mergeMap();
    init_pairwise();
    init_refCount();
    init_scan();
    init_shareReplay();
    init_startWith();
    init_switchMap();
    init_take();
    init_takeLast();
    init_takeUntil();
    init_tap();
  }
});

// node_modules/@angular/core/fesm2022/debug_node.mjs
function noSideEffects(fn) {
  return { toString: fn }.toString();
}
function makeDecorator(name2, props, parentClass, additionalProcessing, typeFn) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function DecoratorFactory(...args) {
      if (this instanceof DecoratorFactory) {
        metaCtor.call(this, ...args);
        return this;
      }
      const annotationInstance = new DecoratorFactory(...args);
      return function TypeDecorator(cls) {
        if (typeFn)
          typeFn(cls, ...args);
        const annotations = cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, { value: [] })[ANNOTATIONS];
        annotations.push(annotationInstance);
        return cls;
      };
    }
    if (parentClass) {
      DecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    DecoratorFactory.prototype.ngMetadataName = name2;
    DecoratorFactory.annotationCls = DecoratorFactory;
    return DecoratorFactory;
  });
}
function makeMetadataCtor(props) {
  return function ctor(...args) {
    if (props) {
      const values2 = props(...args);
      for (const propName in values2) {
        this[propName] = values2[propName];
      }
    }
  };
}
function makeParamDecorator(name2, props, parentClass) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function ParamDecoratorFactory(...args) {
      if (this instanceof ParamDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      const annotationInstance = new ParamDecoratorFactory(...args);
      ParamDecorator.annotation = annotationInstance;
      return ParamDecorator;
      function ParamDecorator(cls, unusedKey, index) {
        const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, { value: [] })[PARAMETERS];
        while (parameters.length <= index) {
          parameters.push(null);
        }
        (parameters[index] = parameters[index] || []).push(annotationInstance);
        return cls;
      }
    }
    ParamDecoratorFactory.prototype.ngMetadataName = name2;
    ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
    return ParamDecoratorFactory;
  });
}
function makePropDecorator(name2, props, parentClass, additionalProcessing) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function PropDecoratorFactory(...args) {
      if (this instanceof PropDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      const decoratorInstance = new PropDecoratorFactory(...args);
      function PropDecorator(target, name3) {
        if (target === void 0) {
          throw new Error("Standard Angular field decorators are not supported in JIT mode.");
        }
        const constructor = target.constructor;
        const meta2 = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, { value: {} })[PROP_METADATA];
        meta2[name3] = meta2.hasOwnProperty(name3) && meta2[name3] || [];
        meta2[name3].unshift(decoratorInstance);
      }
      return PropDecorator;
    }
    if (parentClass) {
      PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    PropDecoratorFactory.prototype.ngMetadataName = name2;
    PropDecoratorFactory.annotationCls = PropDecoratorFactory;
    return PropDecoratorFactory;
  });
}
function getCompilerFacade(request) {
  const globalNg = _global["ng"];
  if (globalNg && globalNg.\u0275compilerFacade) {
    return globalNg.\u0275compilerFacade;
  }
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    console.error(`JIT compilation failed for ${request.kind}`, request.type);
    let message = `The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.

`;
    if (request.usage === 1) {
      message += `The ${request.kind} is part of a library that has been partially compiled.
`;
      message += `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.
`;
      message += "\n";
      message += `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.
`;
    } else {
      message += `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.
`;
    }
    message += `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',
`;
    message += `or manually provide the compiler with 'import "@angular/compiler";' before bootstrapping.`;
    throw new Error(message);
  } else {
    throw new Error("JIT compiler unavailable");
  }
}
function isType(v) {
  return typeof v === "function";
}
function isDelegateCtor(typeStr) {
  return ES5_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr);
}
function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
  if (!decoratorInvocations) {
    return [];
  }
  return decoratorInvocations.map((decoratorInvocation) => {
    const decoratorType = decoratorInvocation.type;
    const annotationCls = decoratorType.annotationCls;
    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
    return new annotationCls(...annotationArgs);
  });
}
function getParentCtor(ctor) {
  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;
  const parentCtor = parentProto ? parentProto.constructor : null;
  return parentCtor || Object;
}
function applyValueToInputField(instance, inputSignalNode, privateName, value) {
  if (inputSignalNode !== null) {
    inputSignalNode.applyValueToInputSignal(inputSignalNode, value);
  } else {
    instance[privateName] = value;
  }
}
function NgOnChangesFeatureImpl(definition) {
  if (definition.type.prototype.ngOnChanges) {
    definition.setInput = ngOnChangesSetInput;
  }
  return rememberChangeHistoryAndInvokeOnChangesHook;
}
function rememberChangeHistoryAndInvokeOnChangesHook() {
  const simpleChangesStore = getSimpleChangesStore(this);
  const current = simpleChangesStore?.current;
  if (current) {
    const previous = simpleChangesStore.previous;
    if (previous === EMPTY_OBJ) {
      simpleChangesStore.previous = current;
    } else {
      for (let key in current) {
        previous[key] = current[key];
      }
    }
    simpleChangesStore.current = null;
    this.ngOnChanges(current);
  }
}
function ngOnChangesSetInput(instance, inputSignalNode, value, publicName, privateName) {
  const declaredName = this.declaredInputs[publicName];
  ngDevMode && assertString(declaredName, "Name of input in ngOnChanges has to be a string");
  const simpleChangesStore = getSimpleChangesStore(instance) || setSimpleChangesStore(instance, { previous: EMPTY_OBJ, current: null });
  const current = simpleChangesStore.current || (simpleChangesStore.current = {});
  const previous = simpleChangesStore.previous;
  const previousChange = previous[declaredName];
  current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);
  applyValueToInputField(instance, inputSignalNode, privateName, value);
}
function getSimpleChangesStore(instance) {
  return instance[SIMPLE_CHANGES_STORE] || null;
}
function setSimpleChangesStore(instance, store2) {
  return instance[SIMPLE_CHANGES_STORE] = store2;
}
function removeProfiler2(profiler2) {
  const profilerIdx = profilerCallbacks.indexOf(profiler2);
  if (profilerIdx !== -1) {
    profilerCallbacks.splice(profilerIdx, 1);
  }
}
function setProfiler(profiler2) {
  if (profiler2 !== null) {
    if (!profilerCallbacks.includes(profiler2)) {
      profilerCallbacks.push(profiler2);
    }
    return () => removeProfiler2(profiler2);
  } else {
    profilerCallbacks.length = 0;
    return NOOP_PROFILER_REMOVAL2;
  }
}
function registerPreOrderHooks(directiveIndex, directiveDef, tView) {
  ngDevMode && assertFirstCreatePass(tView);
  const { ngOnChanges, ngOnInit, ngDoCheck } = directiveDef.type.prototype;
  if (ngOnChanges) {
    const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);
    (tView.preOrderHooks ??= []).push(directiveIndex, wrappedOnChanges);
    (tView.preOrderCheckHooks ??= []).push(directiveIndex, wrappedOnChanges);
  }
  if (ngOnInit) {
    (tView.preOrderHooks ??= []).push(0 - directiveIndex, ngOnInit);
  }
  if (ngDoCheck) {
    (tView.preOrderHooks ??= []).push(directiveIndex, ngDoCheck);
    (tView.preOrderCheckHooks ??= []).push(directiveIndex, ngDoCheck);
  }
}
function registerPostOrderHooks(tView, tNode) {
  ngDevMode && assertFirstCreatePass(tView);
  for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {
    const directiveDef = tView.data[i];
    ngDevMode && assertDefined(directiveDef, "Expecting DirectiveDef");
    const lifecycleHooks = directiveDef.type.prototype;
    const { ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked, ngOnDestroy } = lifecycleHooks;
    if (ngAfterContentInit) {
      (tView.contentHooks ??= []).push(-i, ngAfterContentInit);
    }
    if (ngAfterContentChecked) {
      (tView.contentHooks ??= []).push(i, ngAfterContentChecked);
      (tView.contentCheckHooks ??= []).push(i, ngAfterContentChecked);
    }
    if (ngAfterViewInit) {
      (tView.viewHooks ??= []).push(-i, ngAfterViewInit);
    }
    if (ngAfterViewChecked) {
      (tView.viewHooks ??= []).push(i, ngAfterViewChecked);
      (tView.viewCheckHooks ??= []).push(i, ngAfterViewChecked);
    }
    if (ngOnDestroy != null) {
      (tView.destroyHooks ??= []).push(i, ngOnDestroy);
    }
  }
}
function executeCheckHooks(lView, hooks, nodeIndex) {
  callHooks(lView, hooks, 3, nodeIndex);
}
function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
  ngDevMode && assertNotEqual(initPhase, 3, "Init pre-order hooks should not be called more than once");
  if ((lView[FLAGS] & 3) === initPhase) {
    callHooks(lView, hooks, initPhase, nodeIndex);
  }
}
function incrementInitPhaseFlags(lView, initPhase) {
  ngDevMode && assertNotEqual(initPhase, 3, "Init hooks phase should not be incremented after all init hooks have been run.");
  let flags = lView[FLAGS];
  if ((flags & 3) === initPhase) {
    flags &= 16383;
    flags += 1;
    lView[FLAGS] = flags;
  }
}
function callHooks(currentView, arr, initPhase, currentNodeIndex) {
  ngDevMode && assertEqual(isInCheckNoChangesMode(), false, "Hooks should never be run when in check no changes mode.");
  const startIndex = currentNodeIndex !== void 0 ? currentView[PREORDER_HOOK_FLAGS] & 65535 : 0;
  const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;
  const max = arr.length - 1;
  let lastNodeIndexFound = 0;
  for (let i = startIndex; i < max; i++) {
    const hook = arr[i + 1];
    if (typeof hook === "number") {
      lastNodeIndexFound = arr[i];
      if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {
        break;
      }
    } else {
      const isInitHook = arr[i] < 0;
      if (isInitHook) {
        currentView[PREORDER_HOOK_FLAGS] += 65536;
      }
      if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {
        callHook(currentView, initPhase, arr, i);
        currentView[PREORDER_HOOK_FLAGS] = (currentView[PREORDER_HOOK_FLAGS] & 4294901760) + i + 2;
      }
      i++;
    }
  }
}
function callHookInternal(directive, hook) {
  profiler(4, directive, hook);
  const prevConsumer = setActiveConsumer(null);
  try {
    hook.call(directive);
  } finally {
    setActiveConsumer(prevConsumer);
    profiler(5, directive, hook);
  }
}
function callHook(currentView, initPhase, arr, i) {
  const isInitHook = arr[i] < 0;
  const hook = arr[i + 1];
  const directiveIndex = isInitHook ? -arr[i] : arr[i];
  const directive = currentView[directiveIndex];
  if (isInitHook) {
    const indexWithintInitPhase = currentView[FLAGS] >> 14;
    if (indexWithintInitPhase < currentView[PREORDER_HOOK_FLAGS] >> 16 && (currentView[FLAGS] & 3) === initPhase) {
      currentView[FLAGS] += 16384;
      callHookInternal(directive, hook);
    }
  } else {
    callHookInternal(directive, hook);
  }
}
function toTNodeTypeAsString(tNodeType) {
  let text = "";
  tNodeType & 1 && (text += "|Text");
  tNodeType & 2 && (text += "|Element");
  tNodeType & 4 && (text += "|Container");
  tNodeType & 8 && (text += "|ElementContainer");
  tNodeType & 16 && (text += "|Projection");
  tNodeType & 32 && (text += "|IcuContainer");
  tNodeType & 64 && (text += "|Placeholder");
  tNodeType & 128 && (text += "|LetDeclaration");
  return text.length > 0 ? text.substring(1) : text;
}
function isTNodeShape(value) {
  return value != null && typeof value === "object" && (value.insertBeforeIndex === null || typeof value.insertBeforeIndex === "number" || Array.isArray(value.insertBeforeIndex));
}
function hasClassInput(tNode) {
  return (tNode.flags & 8) !== 0;
}
function hasStyleInput(tNode) {
  return (tNode.flags & 16) !== 0;
}
function assertTNodeType(tNode, expectedTypes, message) {
  assertDefined(tNode, "should be called with a TNode");
  if ((tNode.type & expectedTypes) === 0) {
    throwError2(message || `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);
  }
}
function assertPureTNodeType(type) {
  if (!(type === 2 || type === 1 || type === 4 || type === 8 || type === 32 || type === 16 || type === 64 || type === 128)) {
    throwError2(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);
  }
}
function setUpAttributes(renderer, native, attrs) {
  let i = 0;
  while (i < attrs.length) {
    const value = attrs[i];
    if (typeof value === "number") {
      if (value !== 0) {
        break;
      }
      i++;
      const namespaceURI = attrs[i++];
      const attrName = attrs[i++];
      const attrVal = attrs[i++];
      renderer.setAttribute(native, attrName, attrVal, namespaceURI);
    } else {
      const attrName = value;
      const attrVal = attrs[++i];
      if (isAnimationProp(attrName)) {
        renderer.setProperty(native, attrName, attrVal);
      } else {
        renderer.setAttribute(native, attrName, attrVal);
      }
      i++;
    }
  }
  return i;
}
function isNameOnlyAttributeMarker(marker) {
  return marker === 3 || marker === 4 || marker === 6;
}
function isAnimationProp(name2) {
  return name2.charCodeAt(0) === 64;
}
function mergeHostAttrs(dst, src) {
  if (src === null || src.length === 0) ;
  else if (dst === null || dst.length === 0) {
    dst = src.slice();
  } else {
    let srcMarker = -1;
    for (let i = 0; i < src.length; i++) {
      const item = src[i];
      if (typeof item === "number") {
        srcMarker = item;
      } else {
        if (srcMarker === 0) ;
        else if (srcMarker === -1 || srcMarker === 2) {
          mergeHostAttribute(dst, srcMarker, item, null, src[++i]);
        } else {
          mergeHostAttribute(dst, srcMarker, item, null, null);
        }
      }
    }
  }
  return dst;
}
function mergeHostAttribute(dst, marker, key1, key2, value) {
  let i = 0;
  let markerInsertPosition = dst.length;
  if (marker === -1) {
    markerInsertPosition = -1;
  } else {
    while (i < dst.length) {
      const dstValue = dst[i++];
      if (typeof dstValue === "number") {
        if (dstValue === marker) {
          markerInsertPosition = -1;
          break;
        } else if (dstValue > marker) {
          markerInsertPosition = i - 1;
          break;
        }
      }
    }
  }
  while (i < dst.length) {
    const item = dst[i];
    if (typeof item === "number") {
      break;
    } else if (item === key1) {
      {
        if (value !== null) {
          dst[i + 1] = value;
        }
        return;
      }
    }
    i++;
    if (value !== null)
      i++;
  }
  if (markerInsertPosition !== -1) {
    dst.splice(markerInsertPosition, 0, marker);
    i = markerInsertPosition + 1;
  }
  dst.splice(i++, 0, key1);
  if (value !== null) {
    dst.splice(i++, 0, value);
  }
}
function hasParentInjector(parentLocation) {
  return parentLocation !== NO_PARENT_INJECTOR;
}
function getParentInjectorIndex(parentLocation) {
  if (ngDevMode) {
    assertNumber(parentLocation, "Number expected");
    assertNotEqual(parentLocation, -1, "Not a valid state.");
    const parentInjectorIndex = parentLocation & 32767;
    assertGreaterThan(parentInjectorIndex, HEADER_OFFSET, "Parent injector must be pointing past HEADER_OFFSET.");
  }
  return parentLocation & 32767;
}
function getParentInjectorViewOffset(parentLocation) {
  return parentLocation >> 16;
}
function getParentInjectorView(location2, startView) {
  let viewOffset = getParentInjectorViewOffset(location2);
  let parentView = startView;
  while (viewOffset > 0) {
    parentView = parentView[DECLARATION_VIEW];
    viewOffset--;
  }
  return parentView;
}
function setIncludeViewProviders(v) {
  const oldValue = includeViewProviders;
  includeViewProviders = v;
  return oldValue;
}
function bloomAdd(injectorIndex, tView, type) {
  ngDevMode && assertEqual(tView.firstCreatePass, true, "expected firstCreatePass to be true");
  let id2;
  if (typeof type === "string") {
    id2 = type.charCodeAt(0) || 0;
  } else if (type.hasOwnProperty(NG_ELEMENT_ID)) {
    id2 = type[NG_ELEMENT_ID];
  }
  if (id2 == null) {
    id2 = type[NG_ELEMENT_ID] = nextNgElementId++;
  }
  const bloomHash = id2 & BLOOM_MASK;
  const mask = 1 << bloomHash;
  tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;
}
function getOrCreateNodeInjectorForNode(tNode, lView) {
  const existingInjectorIndex = getInjectorIndex(tNode, lView);
  if (existingInjectorIndex !== -1) {
    return existingInjectorIndex;
  }
  const tView = lView[TVIEW];
  if (tView.firstCreatePass) {
    tNode.injectorIndex = lView.length;
    insertBloom(tView.data, tNode);
    insertBloom(lView, null);
    insertBloom(tView.blueprint, null);
  }
  const parentLoc = getParentInjectorLocation(tNode, lView);
  const injectorIndex = tNode.injectorIndex;
  if (hasParentInjector(parentLoc)) {
    const parentIndex = getParentInjectorIndex(parentLoc);
    const parentLView = getParentInjectorView(parentLoc, lView);
    const parentData = parentLView[TVIEW].data;
    for (let i = 0; i < 8; i++) {
      lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];
    }
  }
  lView[
    injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  ] = parentLoc;
  return injectorIndex;
}
function insertBloom(arr, footer) {
  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
}
function getInjectorIndex(tNode, lView) {
  if (tNode.injectorIndex === -1 || // If the injector index is the same as its parent's injector index, then the index has been
  // copied down from the parent node. No injector has been created yet on this node.
  tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || // After the first template pass, the injector index might exist but the parent values
  // might not have been calculated yet for this instance
  lView[
    tNode.injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  ] === null) {
    return -1;
  } else {
    ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);
    return tNode.injectorIndex;
  }
}
function getParentInjectorLocation(tNode, lView) {
  if (tNode.parent && tNode.parent.injectorIndex !== -1) {
    return tNode.parent.injectorIndex;
  }
  let declarationViewOffset = 0;
  let parentTNode = null;
  let lViewCursor = lView;
  while (lViewCursor !== null) {
    parentTNode = getTNodeFromLView(lViewCursor);
    if (parentTNode === null) {
      return NO_PARENT_INJECTOR;
    }
    ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]);
    declarationViewOffset++;
    lViewCursor = lViewCursor[DECLARATION_VIEW];
    if (parentTNode.injectorIndex !== -1) {
      return parentTNode.injectorIndex | declarationViewOffset << 16;
    }
  }
  return NO_PARENT_INJECTOR;
}
function diPublicInInjector(injectorIndex, tView, token) {
  bloomAdd(injectorIndex, tView, token);
}
function injectAttributeImpl(tNode, attrNameToInject) {
  ngDevMode && assertTNodeType(
    tNode,
    12 | 3
    /* TNodeType.AnyRNode */
  );
  ngDevMode && assertDefined(tNode, "expecting tNode");
  if (attrNameToInject === "class") {
    return tNode.classes;
  }
  if (attrNameToInject === "style") {
    return tNode.styles;
  }
  const attrs = tNode.attrs;
  if (attrs) {
    const attrsLength = attrs.length;
    let i = 0;
    while (i < attrsLength) {
      const value = attrs[i];
      if (isNameOnlyAttributeMarker(value))
        break;
      if (value === 0) {
        i = i + 2;
      } else if (typeof value === "number") {
        i++;
        while (i < attrsLength && typeof attrs[i] === "string") {
          i++;
        }
      } else if (value === attrNameToInject) {
        return attrs[i + 1];
      } else {
        i = i + 2;
      }
    }
  }
  return null;
}
function notFoundValueOrThrow(notFoundValue, token, flags) {
  if (flags & 8 || notFoundValue !== void 0) {
    return notFoundValue;
  } else {
    throwProviderNotFoundError(token, "NodeInjector");
  }
}
function lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {
  if (flags & 8 && notFoundValue === void 0) {
    notFoundValue = null;
  }
  if ((flags & (2 | 1)) === 0) {
    const moduleInjector = lView[INJECTOR];
    const previousInjectImplementation = setInjectImplementation(void 0);
    try {
      if (moduleInjector) {
        return moduleInjector.get(
          token,
          notFoundValue,
          flags & 8
          /* InternalInjectFlags.Optional */
        );
      } else {
        return injectRootLimpMode(
          token,
          notFoundValue,
          flags & 8
          /* InternalInjectFlags.Optional */
        );
      }
    } finally {
      setInjectImplementation(previousInjectImplementation);
    }
  }
  return notFoundValueOrThrow(notFoundValue, token, flags);
}
function getOrCreateInjectable(tNode, lView, token, flags = 0, notFoundValue) {
  if (tNode !== null) {
    if (lView[FLAGS] & 2048 && // The token must be present on the current node injector when the `Self`
    // flag is set, so the lookup on embedded view injector(s) can be skipped.
    !(flags & 2)) {
      const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND2);
      if (embeddedInjectorValue !== NOT_FOUND2) {
        return embeddedInjectorValue;
      }
    }
    const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND2);
    if (value !== NOT_FOUND2) {
      return value;
    }
  }
  return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
}
function lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {
  const bloomHash = bloomHashBitOrFactory(token);
  if (typeof bloomHash === "function") {
    if (!enterDI(lView, tNode, flags)) {
      return flags & 1 ? notFoundValueOrThrow(notFoundValue, token, flags) : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
    }
    try {
      let value;
      if (ngDevMode) {
        runInInjectorProfilerContext(new NodeInjector(getCurrentTNode(), getLView()), token, () => {
          emitInjectorToCreateInstanceEvent(token);
          value = bloomHash(flags);
          emitInstanceCreatedByInjectorEvent(value);
        });
      } else {
        value = bloomHash(flags);
      }
      if (value == null && !(flags & 8)) {
        throwProviderNotFoundError(token);
      } else {
        return value;
      }
    } finally {
      leaveDI();
    }
  } else if (typeof bloomHash === "number") {
    let previousTView = null;
    let injectorIndex = getInjectorIndex(tNode, lView);
    let parentLocation = NO_PARENT_INJECTOR;
    let hostTElementNode = flags & 1 ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;
    if (injectorIndex === -1 || flags & 4) {
      parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) : lView[
        injectorIndex + 8
        /* NodeInjectorOffset.PARENT */
      ];
      if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {
        injectorIndex = -1;
      } else {
        previousTView = lView[TVIEW];
        injectorIndex = getParentInjectorIndex(parentLocation);
        lView = getParentInjectorView(parentLocation, lView);
      }
    }
    while (injectorIndex !== -1) {
      ngDevMode && assertNodeInjector(lView, injectorIndex);
      const tView = lView[TVIEW];
      ngDevMode && assertTNodeForLView(tView.data[
        injectorIndex + 8
        /* NodeInjectorOffset.TNODE */
      ], lView);
      if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
        const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
        if (instance !== NOT_FOUND2) {
          return instance;
        }
      }
      parentLocation = lView[
        injectorIndex + 8
        /* NodeInjectorOffset.PARENT */
      ];
      if (parentLocation !== NO_PARENT_INJECTOR && shouldSearchParent(flags, lView[TVIEW].data[
        injectorIndex + 8
        /* NodeInjectorOffset.TNODE */
      ] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView)) {
        previousTView = tView;
        injectorIndex = getParentInjectorIndex(parentLocation);
        lView = getParentInjectorView(parentLocation, lView);
      } else {
        injectorIndex = -1;
      }
    }
  }
  return notFoundValue;
}
function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
  const currentTView = lView[TVIEW];
  const tNode = currentTView.data[
    injectorIndex + 8
    /* NodeInjectorOffset.TNODE */
  ];
  const canAccessViewProviders = previousTView == null ? (
    // 1) This is the first invocation `previousTView == null` which means that we are at the
    // `TNode` of where injector is starting to look. In such a case the only time we are allowed
    // to look into the ViewProviders is if:
    // - we are on a component
    // - AND the injector set `includeViewProviders` to true (implying that the token can see
    // ViewProviders because it is the Component or a Service which itself was declared in
    // ViewProviders)
    isComponentHost(tNode) && includeViewProviders
  ) : (
    // 2) `previousTView != null` which means that we are now walking across the parent nodes.
    // In such a case we are only allowed to look into the ViewProviders if:
    // - We just crossed from child View to Parent View `previousTView != currentTView`
    // - AND the parent TNode is an Element.
    // This means that we just came from the Component's View and therefore are allowed to see
    // into the ViewProviders.
    previousTView != currentTView && (tNode.type & 3) !== 0
  );
  const isHostSpecialCase = flags & 1 && hostTElementNode === tNode;
  const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);
  if (injectableIdx !== null) {
    return getNodeInjectable(lView, currentTView, injectableIdx, tNode, flags);
  } else {
    return NOT_FOUND2;
  }
}
function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
  const nodeProviderIndexes = tNode.providerIndexes;
  const tInjectables = tView.data;
  const injectablesStart = nodeProviderIndexes & 1048575;
  const directivesStart = tNode.directiveStart;
  const directiveEnd = tNode.directiveEnd;
  const cptViewProvidersCount = nodeProviderIndexes >> 20;
  const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;
  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;
  for (let i = startingIndex; i < endIndex; i++) {
    const providerTokenOrDef = tInjectables[i];
    if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) {
      return i;
    }
  }
  if (isHostSpecialCase) {
    const dirDef = tInjectables[directivesStart];
    if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {
      return directivesStart;
    }
  }
  return null;
}
function getNodeInjectable(lView, tView, index, tNode, flags) {
  let value = lView[index];
  const tData = tView.data;
  if (value instanceof NodeInjectorFactory) {
    const factory = value;
    ngDevMode && injectionPath.push(factory.name ?? "unknown");
    if (factory.resolving) {
      const token2 = stringifyForError(tData[index]);
      if (ngDevMode) {
        throw cyclicDependencyErrorWithDetails(token2, injectionPath);
      } else {
        throw cyclicDependencyError(token2);
      }
    }
    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
    factory.resolving = true;
    const token = tData[index].type || tData[index];
    let prevInjectContext;
    if (ngDevMode) {
      const injector = new NodeInjector(tNode, lView);
      prevInjectContext = setInjectorProfilerContext({ injector, token });
    }
    const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;
    const success = enterDI(
      lView,
      tNode,
      0
      /* InternalInjectFlags.Default */
    );
    ngDevMode && assertEqual(success, true, "Because flags do not contain `SkipSelf' we expect this to always succeed.");
    try {
      ngDevMode && emitInjectorToCreateInstanceEvent(token);
      value = lView[index] = factory.factory(void 0, flags, tData, lView, tNode);
      ngDevMode && emitInstanceCreatedByInjectorEvent(value);
      if (tView.firstCreatePass && index >= tNode.directiveStart) {
        ngDevMode && assertDirectiveDef(tData[index]);
        registerPreOrderHooks(index, tData[index], tView);
      }
    } finally {
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
      previousInjectImplementation !== null && setInjectImplementation(previousInjectImplementation);
      setIncludeViewProviders(previousIncludeViewProviders);
      factory.resolving = false;
      leaveDI();
      ngDevMode && (injectionPath = []);
    }
  }
  return value;
}
function bloomHashBitOrFactory(token) {
  ngDevMode && assertDefined(token, "token must be defined");
  if (typeof token === "string") {
    return token.charCodeAt(0) || 0;
  }
  const tokenId = (
    // First check with `hasOwnProperty` so we don't get an inherited ID.
    token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : void 0
  );
  if (typeof tokenId === "number") {
    if (tokenId >= 0) {
      return tokenId & BLOOM_MASK;
    } else {
      ngDevMode && assertEqual(tokenId, -1, "Expecting to get Special Injector Id");
      return createNodeInjector;
    }
  } else {
    return tokenId;
  }
}
function bloomHasToken(bloomHash, injectorIndex, injectorView) {
  const mask = 1 << bloomHash;
  const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];
  return !!(value & mask);
}
function shouldSearchParent(flags, isFirstHostTNode) {
  return !(flags & 2) && !(flags & 1 && isFirstHostTNode);
}
function getNodeInjectorLView(nodeInjector) {
  return nodeInjector._lView;
}
function getNodeInjectorTNode(nodeInjector) {
  return nodeInjector._tNode;
}
function createNodeInjector() {
  return new NodeInjector(getCurrentTNode(), getLView());
}
function \u0275\u0275getInheritedFactory(type) {
  return noSideEffects(() => {
    const ownConstructor = type.prototype.constructor;
    const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);
    const objectPrototype = Object.prototype;
    let parent = Object.getPrototypeOf(type.prototype).constructor;
    while (parent && parent !== objectPrototype) {
      const factory = parent[NG_FACTORY_DEF] || getFactoryOf(parent);
      if (factory && factory !== ownFactory) {
        return factory;
      }
      parent = Object.getPrototypeOf(parent);
    }
    return (t2) => new t2();
  });
}
function getFactoryOf(type) {
  if (isForwardRef(type)) {
    return () => {
      const factory = getFactoryOf(resolveForwardRef(type));
      return factory && factory();
    };
  }
  return getFactoryDef(type);
}
function lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {
  let currentTNode = tNode;
  let currentLView = lView;
  while (currentTNode !== null && currentLView !== null && currentLView[FLAGS] & 2048 && !isRootView(currentLView)) {
    ngDevMode && assertTNodeForLView(currentTNode, currentLView);
    const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | 2, NOT_FOUND2);
    if (nodeInjectorValue !== NOT_FOUND2) {
      return nodeInjectorValue;
    }
    let parentTNode = currentTNode.parent;
    if (!parentTNode) {
      const embeddedViewInjector = currentLView[EMBEDDED_VIEW_INJECTOR];
      if (embeddedViewInjector) {
        const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND2, flags);
        if (embeddedViewInjectorValue !== NOT_FOUND2) {
          return embeddedViewInjectorValue;
        }
      }
      parentTNode = getTNodeFromLView(currentLView);
      currentLView = currentLView[DECLARATION_VIEW];
    }
    currentTNode = parentTNode;
  }
  return notFoundValue;
}
function getTNodeFromLView(lView) {
  const tView = lView[TVIEW];
  const tViewType = tView.type;
  if (tViewType === 2) {
    ngDevMode && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents.");
    return tView.declTNode;
  } else if (tViewType === 1) {
    return lView[T_HOST];
  }
  return null;
}
function \u0275\u0275injectAttribute(attrNameToInject) {
  return injectAttributeImpl(getCurrentTNode(), attrNameToInject);
}
function getReflect() {
  return _reflect = _reflect || new ReflectionCapabilities();
}
function reflectDependencies(type) {
  return convertDependencies(getReflect().parameters(type));
}
function convertDependencies(deps) {
  return deps.map((dep) => reflectDependency(dep));
}
function reflectDependency(dep) {
  const meta2 = {
    token: null,
    attribute: null,
    host: false,
    optional: false,
    self: false,
    skipSelf: false
  };
  if (Array.isArray(dep) && dep.length > 0) {
    for (let j = 0; j < dep.length; j++) {
      const param = dep[j];
      if (param === void 0) {
        continue;
      }
      const proto = Object.getPrototypeOf(param);
      if (param instanceof Optional || proto.ngMetadataName === "Optional") {
        meta2.optional = true;
      } else if (param instanceof SkipSelf || proto.ngMetadataName === "SkipSelf") {
        meta2.skipSelf = true;
      } else if (param instanceof Self || proto.ngMetadataName === "Self") {
        meta2.self = true;
      } else if (param instanceof Host || proto.ngMetadataName === "Host") {
        meta2.host = true;
      } else if (param instanceof Inject) {
        meta2.token = param.token;
      } else if (param instanceof Attribute) {
        if (param.attributeName === void 0) {
          throw new RuntimeError(204, ngDevMode && `Attribute name must be defined.`);
        }
        meta2.attribute = param.attributeName;
      } else {
        meta2.token = param;
      }
    }
  } else if (dep === void 0 || Array.isArray(dep) && dep.length === 0) {
    meta2.token = null;
  } else {
    meta2.token = dep;
  }
  return meta2;
}
function compileInjectable(type, meta2) {
  let ngInjectableDef = null;
  let ngFactoryDef = null;
  if (!type.hasOwnProperty(NG_PROV_DEF)) {
    Object.defineProperty(type, NG_PROV_DEF, {
      get: () => {
        if (ngInjectableDef === null) {
          const compiler = getCompilerFacade({
            usage: 0,
            kind: "injectable",
            type
          });
          ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/\u0275prov.js`, getInjectableMetadata(type, meta2));
        }
        return ngInjectableDef;
      }
    });
  }
  if (!type.hasOwnProperty(NG_FACTORY_DEF)) {
    Object.defineProperty(type, NG_FACTORY_DEF, {
      get: () => {
        if (ngFactoryDef === null) {
          const compiler = getCompilerFacade({
            usage: 0,
            kind: "injectable",
            type
          });
          ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/\u0275fac.js`, {
            name: type.name,
            type,
            typeArgumentCount: 0,
            // In JIT mode types are not available nor used.
            deps: reflectDependencies(type),
            target: compiler.FactoryTarget.Injectable
          });
        }
        return ngFactoryDef;
      },
      // Leave this configurable so that the factories from directives or pipes can take precedence.
      configurable: true
    });
  }
}
function isUseClassProvider(meta2) {
  return meta2.useClass !== void 0;
}
function isUseValueProvider(meta2) {
  return USE_VALUE2 in meta2;
}
function isUseFactoryProvider(meta2) {
  return meta2.useFactory !== void 0;
}
function isUseExistingProvider(meta2) {
  return meta2.useExisting !== void 0;
}
function getInjectableMetadata(type, srcMeta) {
  const meta2 = srcMeta || { providedIn: null };
  const compilerMeta = {
    name: type.name,
    type,
    typeArgumentCount: 0,
    providedIn: meta2.providedIn
  };
  if ((isUseClassProvider(meta2) || isUseFactoryProvider(meta2)) && meta2.deps !== void 0) {
    compilerMeta.deps = convertDependencies(meta2.deps);
  }
  if (isUseClassProvider(meta2)) {
    compilerMeta.useClass = meta2.useClass;
  } else if (isUseValueProvider(meta2)) {
    compilerMeta.useValue = meta2.useValue;
  } else if (isUseFactoryProvider(meta2)) {
    compilerMeta.useFactory = meta2.useFactory;
  } else if (isUseExistingProvider(meta2)) {
    compilerMeta.useExisting = meta2.useExisting;
  }
  return compilerMeta;
}
function injectElementRef() {
  return createElementRef(getCurrentTNode(), getLView());
}
function createElementRef(tNode, lView) {
  return new ElementRef(getNativeByTNode(tNode, lView));
}
function unwrapElementRef(value) {
  return value instanceof ElementRef ? value.nativeElement : value;
}
function symbolIterator() {
  return this._results[Symbol.iterator]();
}
function hasInSkipHydrationBlockFlag(tNode) {
  return (tNode.flags & 128) === 128;
}
function getUniqueLViewId() {
  return uniqueIdCounter++;
}
function registerLView(lView) {
  ngDevMode && assertNumber(lView[ID], "LView must have an ID in order to be registered");
  TRACKED_LVIEWS.set(lView[ID], lView);
}
function getLViewById(id2) {
  ngDevMode && assertNumber(id2, "ID used for LView lookup must be a number");
  return TRACKED_LVIEWS.get(id2) || null;
}
function unregisterLView(lView) {
  ngDevMode && assertNumber(lView[ID], "Cannot stop tracking an LView that does not have an ID");
  TRACKED_LVIEWS.delete(lView[ID]);
}
function getTrackedLViews() {
  return TRACKED_LVIEWS;
}
function getLContext(target) {
  let mpValue = readPatchedData(target);
  if (mpValue) {
    if (isLView(mpValue)) {
      const lView = mpValue;
      let nodeIndex;
      let component = void 0;
      let directives = void 0;
      if (isComponentInstance(target)) {
        nodeIndex = findViaComponent(lView, target);
        if (nodeIndex == -1) {
          throw new Error("The provided component was not found in the application");
        }
        component = target;
      } else if (isDirectiveInstance(target)) {
        nodeIndex = findViaDirective(lView, target);
        if (nodeIndex == -1) {
          throw new Error("The provided directive was not found in the application");
        }
        directives = getDirectivesAtNodeIndex(nodeIndex, lView);
      } else {
        nodeIndex = findViaNativeElement(lView, target);
        if (nodeIndex == -1) {
          return null;
        }
      }
      const native = unwrapRNode(lView[nodeIndex]);
      const existingCtx = readPatchedData(native);
      const context2 = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);
      if (component && context2.component === void 0) {
        context2.component = component;
        attachPatchData(context2.component, context2);
      }
      if (directives && context2.directives === void 0) {
        context2.directives = directives;
        for (let i = 0; i < directives.length; i++) {
          attachPatchData(directives[i], context2);
        }
      }
      attachPatchData(context2.native, context2);
      mpValue = context2;
    }
  } else {
    const rElement = target;
    ngDevMode && assertDomNode(rElement);
    let parent = rElement;
    while (parent = parent.parentNode) {
      const parentContext = readPatchedData(parent);
      if (parentContext) {
        const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView;
        if (!lView) {
          return null;
        }
        const index = findViaNativeElement(lView, rElement);
        if (index >= 0) {
          const native = unwrapRNode(lView[index]);
          const context2 = createLContext(lView, index, native);
          attachPatchData(native, context2);
          mpValue = context2;
          break;
        }
      }
    }
  }
  return mpValue || null;
}
function createLContext(lView, nodeIndex, native) {
  return new LContext(lView[ID], nodeIndex, native);
}
function getComponentViewByInstance(componentInstance) {
  let patchedData = readPatchedData(componentInstance);
  let lView;
  if (isLView(patchedData)) {
    const contextLView = patchedData;
    const nodeIndex = findViaComponent(contextLView, componentInstance);
    lView = getComponentLViewByIndex(nodeIndex, contextLView);
    const context2 = createLContext(contextLView, nodeIndex, lView[HOST]);
    context2.component = componentInstance;
    attachPatchData(componentInstance, context2);
    attachPatchData(context2.native, context2);
  } else {
    const context2 = patchedData;
    const contextLView = context2.lView;
    ngDevMode && assertLView(contextLView);
    lView = getComponentLViewByIndex(context2.nodeIndex, contextLView);
  }
  return lView;
}
function attachPatchData(target, data2) {
  ngDevMode && assertDefined(target, "Target expected");
  if (isLView(data2)) {
    target[MONKEY_PATCH_KEY_NAME] = data2[ID];
    registerLView(data2);
  } else {
    target[MONKEY_PATCH_KEY_NAME] = data2;
  }
}
function readPatchedData(target) {
  ngDevMode && assertDefined(target, "Target expected");
  const data2 = target[MONKEY_PATCH_KEY_NAME];
  return typeof data2 === "number" ? getLViewById(data2) : data2 || null;
}
function readPatchedLView(target) {
  const value = readPatchedData(target);
  if (value) {
    return isLView(value) ? value : value.lView;
  }
  return null;
}
function isComponentInstance(instance) {
  return instance && instance.constructor && instance.constructor.\u0275cmp;
}
function isDirectiveInstance(instance) {
  return instance && instance.constructor && instance.constructor.\u0275dir;
}
function findViaNativeElement(lView, target) {
  const tView = lView[TVIEW];
  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    if (unwrapRNode(lView[i]) === target) {
      return i;
    }
  }
  return -1;
}
function traverseNextElement(tNode) {
  if (tNode.child) {
    return tNode.child;
  } else if (tNode.next) {
    return tNode.next;
  } else {
    while (tNode.parent && !tNode.parent.next) {
      tNode = tNode.parent;
    }
    return tNode.parent && tNode.parent.next;
  }
}
function findViaComponent(lView, componentInstance) {
  const componentIndices = lView[TVIEW].components;
  if (componentIndices) {
    for (let i = 0; i < componentIndices.length; i++) {
      const elementComponentIndex = componentIndices[i];
      const componentView = getComponentLViewByIndex(elementComponentIndex, lView);
      if (componentView[CONTEXT] === componentInstance) {
        return elementComponentIndex;
      }
    }
  } else {
    const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);
    const rootComponent = rootComponentView[CONTEXT];
    if (rootComponent === componentInstance) {
      return HEADER_OFFSET;
    }
  }
  return -1;
}
function findViaDirective(lView, directiveInstance) {
  let tNode = lView[TVIEW].firstChild;
  while (tNode) {
    const directiveIndexStart = tNode.directiveStart;
    const directiveIndexEnd = tNode.directiveEnd;
    for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {
      if (lView[i] === directiveInstance) {
        return tNode.index;
      }
    }
    tNode = traverseNextElement(tNode);
  }
  return -1;
}
function getDirectivesAtNodeIndex(nodeIndex, lView) {
  const tNode = lView[TVIEW].data[nodeIndex];
  if (tNode.directiveStart === 0)
    return EMPTY_ARRAY;
  const results = [];
  for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {
    const directiveInstance = lView[i];
    if (!isComponentInstance(directiveInstance)) {
      results.push(directiveInstance);
    }
  }
  return results;
}
function getComponentAtNodeIndex(nodeIndex, lView) {
  const tNode = lView[TVIEW].data[nodeIndex];
  return isComponentHost(tNode) ? lView[tNode.directiveStart + tNode.componentOffset] : null;
}
function getRootView(componentOrLView) {
  ngDevMode && assertDefined(componentOrLView, "component");
  let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);
  while (lView && !isRootView(lView)) {
    lView = getLViewParent(lView);
  }
  ngDevMode && assertLView(lView);
  return lView;
}
function getRootContext(viewOrComponent) {
  const rootView = getRootView(viewOrComponent);
  ngDevMode && assertDefined(rootView[CONTEXT], "Root view has no context. Perhaps it is disconnected?");
  return rootView[CONTEXT];
}
function getFirstLContainer(lView) {
  return getNearestLContainer(lView[CHILD_HEAD]);
}
function getNextLContainer(container) {
  return getNearestLContainer(container[NEXT]);
}
function getNearestLContainer(viewOrContainer) {
  while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {
    viewOrContainer = viewOrContainer[NEXT];
  }
  return viewOrContainer;
}
function getComponent(element) {
  ngDevMode && assertDomElement(element);
  const context2 = getLContext(element);
  if (context2 === null)
    return null;
  if (context2.component === void 0) {
    const lView = context2.lView;
    if (lView === null) {
      return null;
    }
    context2.component = getComponentAtNodeIndex(context2.nodeIndex, lView);
  }
  return context2.component;
}
function getContext(element) {
  assertDomElement(element);
  const context2 = getLContext(element);
  const lView = context2 ? context2.lView : null;
  return lView === null ? null : lView[CONTEXT];
}
function getOwningComponent(elementOrDir) {
  const context2 = getLContext(elementOrDir);
  let lView = context2 ? context2.lView : null;
  if (lView === null)
    return null;
  let parent;
  while (lView[TVIEW].type === 2 && (parent = getLViewParent(lView))) {
    lView = parent;
  }
  return isRootView(lView) ? null : lView[CONTEXT];
}
function getRootComponents(elementOrDir) {
  const lView = readPatchedLView(elementOrDir);
  return lView !== null ? [getRootContext(lView)] : [];
}
function getInjector(elementOrDir) {
  const context2 = getLContext(elementOrDir);
  const lView = context2 ? context2.lView : null;
  if (lView === null)
    return Injector.NULL;
  const tNode = lView[TVIEW].data[context2.nodeIndex];
  return new NodeInjector(tNode, lView);
}
function getDirectives(node) {
  if (node instanceof Text) {
    return [];
  }
  const context2 = getLContext(node);
  const lView = context2 ? context2.lView : null;
  if (lView === null) {
    return [];
  }
  const tView = lView[TVIEW];
  const nodeIndex = context2.nodeIndex;
  if (!tView?.data[nodeIndex]) {
    return [];
  }
  if (context2.directives === void 0) {
    context2.directives = getDirectivesAtNodeIndex(nodeIndex, lView);
  }
  return context2.directives === null ? [] : [...context2.directives];
}
function getDirectiveMetadata$1(directiveOrComponentInstance) {
  const { constructor } = directiveOrComponentInstance;
  if (!constructor) {
    throw new Error("Unable to find the instance constructor");
  }
  const componentDef = getComponentDef(constructor);
  if (componentDef) {
    const inputs = extractInputDebugMetadata(componentDef.inputs);
    return {
      inputs,
      outputs: componentDef.outputs,
      encapsulation: componentDef.encapsulation,
      changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush : ChangeDetectionStrategy.Default
    };
  }
  const directiveDef = getDirectiveDef(constructor);
  if (directiveDef) {
    const inputs = extractInputDebugMetadata(directiveDef.inputs);
    return { inputs, outputs: directiveDef.outputs };
  }
  return null;
}
function getHostElement(componentOrDirective) {
  return getLContext(componentOrDirective).native;
}
function getListeners(element) {
  ngDevMode && assertDomElement(element);
  const lContext = getLContext(element);
  const lView = lContext === null ? null : lContext.lView;
  if (lView === null)
    return [];
  const tView = lView[TVIEW];
  const lCleanup = lView[CLEANUP];
  const tCleanup = tView.cleanup;
  const listeners = [];
  if (tCleanup && lCleanup) {
    for (let i = 0; i < tCleanup.length; ) {
      const firstParam = tCleanup[i++];
      const secondParam = tCleanup[i++];
      if (typeof firstParam === "string") {
        const name2 = firstParam;
        const listenerElement = unwrapRNode(lView[secondParam]);
        const callback = lCleanup[tCleanup[i++]];
        const useCaptureOrIndx = tCleanup[i++];
        const type = typeof useCaptureOrIndx === "boolean" || useCaptureOrIndx >= 0 ? "dom" : "output";
        const useCapture = typeof useCaptureOrIndx === "boolean" ? useCaptureOrIndx : false;
        if (element == listenerElement) {
          listeners.push({ element, name: name2, callback, useCapture, type });
        }
      }
    }
  }
  listeners.sort(sortListeners);
  return listeners;
}
function sortListeners(a, b) {
  if (a.name == b.name)
    return 0;
  return a.name < b.name ? -1 : 1;
}
function assertDomElement(value) {
  if (typeof Element !== "undefined" && !(value instanceof Element)) {
    throw new Error("Expecting instance of DOM Element");
  }
}
function extractInputDebugMetadata(inputs) {
  const res = {};
  for (const key in inputs) {
    if (inputs.hasOwnProperty(key)) {
      const value = inputs[key];
      if (value !== void 0) {
        res[key] = value[0];
      }
    }
  }
  return res;
}
function setDocument(document2) {
  DOCUMENT2 = document2;
}
function getDocument() {
  if (DOCUMENT2 !== void 0) {
    return DOCUMENT2;
  } else if (typeof document !== "undefined") {
    return document;
  }
  throw new RuntimeError(210, (typeof ngDevMode === "undefined" || ngDevMode) && `The document object is not available in this context. Make sure the DOCUMENT injection token is provided.`);
}
function makeStateKey(key) {
  return key;
}
function initTransferState() {
  const transferState = new TransferState();
  if (true) {
    transferState.store = retrieveTransferredState(getDocument(), inject2(APP_ID));
  }
  return transferState;
}
function retrieveTransferredState(doc2, appId) {
  const script = doc2.getElementById(appId + "-state");
  if (script?.textContent) {
    try {
      return JSON.parse(script.textContent);
    } catch (e) {
      console.warn("Exception while restoring TransferState for app " + appId, e);
    }
  }
  return {};
}
function onInteraction(trigger, callback) {
  let entry = interactionTriggers.get(trigger);
  if (!entry) {
    entry = new DeferEventEntry();
    interactionTriggers.set(trigger, entry);
    for (const name2 of interactionEventNames) {
      trigger.addEventListener(name2, entry.listener, eventListenerOptions);
    }
  }
  entry.callbacks.add(callback);
  return () => {
    const { callbacks, listener } = entry;
    callbacks.delete(callback);
    if (callbacks.size === 0) {
      interactionTriggers.delete(trigger);
      for (const name2 of interactionEventNames) {
        trigger.removeEventListener(name2, listener, eventListenerOptions);
      }
    }
  };
}
function onHover(trigger, callback) {
  let entry = hoverTriggers.get(trigger);
  if (!entry) {
    entry = new DeferEventEntry();
    hoverTriggers.set(trigger, entry);
    for (const name2 of hoverEventNames) {
      trigger.addEventListener(name2, entry.listener, eventListenerOptions);
    }
  }
  entry.callbacks.add(callback);
  return () => {
    const { callbacks, listener } = entry;
    callbacks.delete(callback);
    if (callbacks.size === 0) {
      for (const name2 of hoverEventNames) {
        trigger.removeEventListener(name2, listener, eventListenerOptions);
      }
      hoverTriggers.delete(trigger);
    }
  };
}
function createIntersectionObserver() {
  return new IntersectionObserver((entries) => {
    for (const current of entries) {
      if (current.isIntersecting && viewportTriggers.has(current.target)) {
        viewportTriggers.get(current.target).listener();
      }
    }
  });
}
function onViewport(trigger, callback, observerFactoryFn) {
  let entry = viewportTriggers.get(trigger);
  intersectionObserver = intersectionObserver || observerFactoryFn();
  if (!entry) {
    entry = new DeferEventEntry();
    intersectionObserver.observe(trigger);
    viewportTriggers.set(trigger, entry);
    observedViewportElements++;
  }
  entry.callbacks.add(callback);
  return () => {
    if (!viewportTriggers.has(trigger)) {
      return;
    }
    entry.callbacks.delete(callback);
    if (entry.callbacks.size === 0) {
      intersectionObserver?.unobserve(trigger);
      viewportTriggers.delete(trigger);
      observedViewportElements--;
    }
    if (observedViewportElements === 0) {
      intersectionObserver?.disconnect();
      intersectionObserver = null;
    }
  };
}
function stashEventListenerImpl(lView, target, eventName, wrappedListener) {
  _stashEventListenerImpl(lView, target, eventName, wrappedListener);
}
function isDetachedByI18n(tNode) {
  return (tNode.flags & 32) === 32;
}
function retrieveHydrationInfo(rNode, injector, isRootView2 = false) {
  return _retrieveHydrationInfoImpl(rNode, injector, isRootView2);
}
function getLNodeForHydration(viewRef) {
  let lView = viewRef._lView;
  const tView = lView[TVIEW];
  if (tView.type === 2) {
    return null;
  }
  if (isRootView(lView)) {
    lView = lView[HEADER_OFFSET];
  }
  return lView;
}
function patchHydrationInfo(node, info) {
  node[HYDRATION_INFO_KEY] = info;
}
function markRNodeAsHavingHydrationMismatch(node, expectedNodeDetails = null, actualNodeDetails = null) {
  if (!ngDevMode) {
    throw new Error("Calling `markRNodeAsMismatchedByHydration` in prod mode is not supported and likely a mistake.");
  }
  while (node && !getComponent(node)) {
    node = node?.parentNode;
  }
  if (node) {
    patchHydrationInfo(node, {
      status: HydrationStatus.Mismatched,
      expectedNodeDetails,
      actualNodeDetails
    });
  }
}
function isIncrementalHydrationEnabled(injector) {
  return injector.get(IS_INCREMENTAL_HYDRATION_ENABLED, false, {
    optional: true
  });
}
function assertIncrementalHydrationIsConfigured(injector) {
  if (!isIncrementalHydrationEnabled(injector)) {
    throw new RuntimeError(508, "Angular has detected that some `@defer` blocks use `hydrate` triggers, but incremental hydration was not enabled. Please ensure that the `withIncrementalHydration()` call is added as an argument for the `provideClientHydration()` function call in your application config.");
  }
}
function assertSsrIdDefined(ssrUniqueId) {
  assertDefined(ssrUniqueId, "Internal error: expecting an SSR id for a defer block that should be hydrated, but the id is not present");
}
function getParentBlockHydrationQueue(deferBlockId, injector) {
  const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
  const transferState = injector.get(TransferState);
  const deferBlockParents = transferState.get(NGH_DEFER_BLOCKS_KEY, {});
  let isTopMostDeferBlock = false;
  let currentBlockId = deferBlockId;
  let parentBlockPromise = null;
  const hydrationQueue = [];
  while (!isTopMostDeferBlock && currentBlockId) {
    ngDevMode && assertEqual(hydrationQueue.indexOf(currentBlockId), -1, "Internal error: defer block hierarchy has a cycle.");
    isTopMostDeferBlock = dehydratedBlockRegistry.has(currentBlockId);
    const hydratingParentBlock = dehydratedBlockRegistry.hydrating.get(currentBlockId);
    if (parentBlockPromise === null && hydratingParentBlock != null) {
      parentBlockPromise = hydratingParentBlock.promise;
      break;
    }
    hydrationQueue.unshift(currentBlockId);
    currentBlockId = deferBlockParents[currentBlockId][DEFER_PARENT_BLOCK_ID];
  }
  return { parentBlockPromise, hydrationQueue };
}
function refreshContentQueries(tView, lView) {
  const contentQueries = tView.contentQueries;
  if (contentQueries !== null) {
    const prevConsumer = setActiveConsumer(null);
    try {
      for (let i = 0; i < contentQueries.length; i += 2) {
        const queryStartIdx = contentQueries[i];
        const directiveDefIdx = contentQueries[i + 1];
        if (directiveDefIdx !== -1) {
          const directiveDef = tView.data[directiveDefIdx];
          ngDevMode && assertDefined(directiveDef, "DirectiveDef not found.");
          ngDevMode && assertDefined(directiveDef.contentQueries, "contentQueries function should be defined");
          setCurrentQueryIndex(queryStartIdx);
          directiveDef.contentQueries(2, lView[directiveDefIdx], directiveDefIdx);
        }
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function executeViewQueryFn(flags, viewQueryFn, component) {
  ngDevMode && assertDefined(viewQueryFn, "View queries function to execute must be defined.");
  setCurrentQueryIndex(0);
  const prevConsumer = setActiveConsumer(null);
  try {
    viewQueryFn(flags, component);
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function executeContentQueries(tView, tNode, lView) {
  if (isContentQueryHost(tNode)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      const start = tNode.directiveStart;
      const end = tNode.directiveEnd;
      for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {
        const def = tView.data[directiveIndex];
        if (def.contentQueries) {
          const directiveInstance = lView[directiveIndex];
          ngDevMode && assertDefined(directiveIndex, "Incorrect reference to a directive defining a content query");
          def.contentQueries(1, directiveInstance, directiveIndex);
        }
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function getPolicy$1() {
  if (policy$1 === void 0) {
    policy$1 = null;
    if (_global.trustedTypes) {
      try {
        policy$1 = _global.trustedTypes.createPolicy("angular", {
          createHTML: (s) => s,
          createScript: (s) => s,
          createScriptURL: (s) => s
        });
      } catch {
      }
    }
  }
  return policy$1;
}
function trustedHTMLFromString(html2) {
  return getPolicy$1()?.createHTML(html2) || html2;
}
function trustedScriptURLFromString(url) {
  return getPolicy$1()?.createScriptURL(url) || url;
}
function getPolicy() {
  if (policy === void 0) {
    policy = null;
    if (_global.trustedTypes) {
      try {
        policy = _global.trustedTypes.createPolicy("angular#unsafe-bypass", {
          createHTML: (s) => s,
          createScript: (s) => s,
          createScriptURL: (s) => s
        });
      } catch {
      }
    }
  }
  return policy;
}
function trustedHTMLFromStringBypass(html2) {
  return getPolicy()?.createHTML(html2) || html2;
}
function trustedScriptFromStringBypass(script) {
  return getPolicy()?.createScript(script) || script;
}
function trustedScriptURLFromStringBypass(url) {
  return getPolicy()?.createScriptURL(url) || url;
}
function unwrapSafeValue(value) {
  return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;
}
function allowSanitizationBypassAndThrow(value, type) {
  const actualType = getSanitizationBypassType(value);
  if (actualType != null && actualType !== type) {
    if (actualType === "ResourceURL" && type === "URL")
      return true;
    throw new Error(`Required a safe ${type}, got a ${actualType} (see ${XSS_SECURITY_URL})`);
  }
  return actualType === type;
}
function getSanitizationBypassType(value) {
  return value instanceof SafeValueImpl && value.getTypeName() || null;
}
function bypassSanitizationTrustHtml(trustedHtml) {
  return new SafeHtmlImpl(trustedHtml);
}
function bypassSanitizationTrustStyle(trustedStyle) {
  return new SafeStyleImpl(trustedStyle);
}
function bypassSanitizationTrustScript(trustedScript) {
  return new SafeScriptImpl(trustedScript);
}
function bypassSanitizationTrustUrl(trustedUrl) {
  return new SafeUrlImpl(trustedUrl);
}
function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {
  return new SafeResourceUrlImpl(trustedResourceUrl);
}
function getInertBodyHelper(defaultDoc) {
  const inertDocumentHelper = new InertDocumentHelper(defaultDoc);
  return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;
}
function isDOMParserAvailable() {
  try {
    return !!new window.DOMParser().parseFromString(trustedHTMLFromString(""), "text/html");
  } catch {
    return false;
  }
}
function _sanitizeUrl(url) {
  url = String(url);
  if (url.match(SAFE_URL_PATTERN))
    return url;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    console.warn(`WARNING: sanitizing unsafe URL value ${url} (see ${XSS_SECURITY_URL})`);
  }
  return "unsafe:" + url;
}
function tagSet(tags3) {
  const res = {};
  for (const t2 of tags3.split(","))
    res[t2] = true;
  return res;
}
function merge2(...sets) {
  const res = {};
  for (const s of sets) {
    for (const v in s) {
      if (s.hasOwnProperty(v))
        res[v] = true;
    }
  }
  return res;
}
function isClobberedElement(parentNode, childNode) {
  return (parentNode.compareDocumentPosition(childNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) !== Node.DOCUMENT_POSITION_CONTAINED_BY;
}
function getNextSibling(node) {
  const nextSibling = node.nextSibling;
  if (nextSibling && node !== nextSibling.previousSibling) {
    throw clobberedElementError(nextSibling);
  }
  return nextSibling;
}
function getFirstChild(node) {
  const firstChild = node.firstChild;
  if (firstChild && isClobberedElement(node, firstChild)) {
    throw clobberedElementError(firstChild);
  }
  return firstChild;
}
function getNodeName(node) {
  const nodeName = node.nodeName;
  return typeof nodeName === "string" ? nodeName : "FORM";
}
function clobberedElementError(node) {
  return new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);
}
function encodeEntities(value) {
  return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(match2) {
    const hi = match2.charCodeAt(0);
    const low = match2.charCodeAt(1);
    return "&#" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ";";
  }).replace(NON_ALPHANUMERIC_REGEXP, function(match2) {
    return "&#" + match2.charCodeAt(0) + ";";
  }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
  let inertBodyElement = null;
  try {
    inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);
    let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : "";
    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
    let mXSSAttempts = 5;
    let parsedHtml = unsafeHtml;
    do {
      if (mXSSAttempts === 0) {
        throw new Error("Failed to sanitize html because the input is unstable");
      }
      mXSSAttempts--;
      unsafeHtml = parsedHtml;
      parsedHtml = inertBodyElement.innerHTML;
      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
    } while (unsafeHtml !== parsedHtml);
    const sanitizer = new SanitizingHtmlSerializer();
    const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
    if ((typeof ngDevMode === "undefined" || ngDevMode) && sanitizer.sanitizedSomething) {
      console.warn(`WARNING: sanitizing HTML stripped some content, see ${XSS_SECURITY_URL}`);
    }
    return trustedHTMLFromString(safeHtml);
  } finally {
    if (inertBodyElement) {
      const parent = getTemplateContent(inertBodyElement) || inertBodyElement;
      while (parent.firstChild) {
        parent.firstChild.remove();
      }
    }
  }
}
function getTemplateContent(el) {
  return "content" in el && isTemplateElement(el) ? el.content : null;
}
function isTemplateElement(el) {
  return el.nodeType === Node.ELEMENT_NODE && el.nodeName === "TEMPLATE";
}
function \u0275\u0275sanitizeHtml(unsafeHtml) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeHtml,
    "HTML"
    /* BypassType.Html */
  )) {
    return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));
  }
  return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));
}
function \u0275\u0275sanitizeStyle(unsafeStyle) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || "";
  }
  if (allowSanitizationBypassAndThrow(
    unsafeStyle,
    "Style"
    /* BypassType.Style */
  )) {
    return unwrapSafeValue(unsafeStyle);
  }
  return renderStringify(unsafeStyle);
}
function \u0275\u0275sanitizeUrl(unsafeUrl) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || "";
  }
  if (allowSanitizationBypassAndThrow(
    unsafeUrl,
    "URL"
    /* BypassType.Url */
  )) {
    return unwrapSafeValue(unsafeUrl);
  }
  return _sanitizeUrl(renderStringify(unsafeUrl));
}
function \u0275\u0275sanitizeResourceUrl(unsafeResourceUrl) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeResourceUrl,
    "ResourceURL"
    /* BypassType.ResourceUrl */
  )) {
    return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));
  }
  throw new RuntimeError(904, ngDevMode && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);
}
function \u0275\u0275sanitizeScript(unsafeScript) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeScript,
    "Script"
    /* BypassType.Script */
  )) {
    return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));
  }
  throw new RuntimeError(905, ngDevMode && "unsafe value used in a script context");
}
function \u0275\u0275trustConstantHtml(html2) {
  if (ngDevMode && (!Array.isArray(html2) || !Array.isArray(html2.raw) || html2.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted HTML constant: ${html2.join("?")}`);
  }
  return trustedHTMLFromString(html2[0]);
}
function \u0275\u0275trustConstantResourceUrl(url) {
  if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join("?")}`);
  }
  return trustedScriptURLFromString(url[0]);
}
function getUrlSanitizer(tag, prop) {
  if (prop === "src" && (tag === "embed" || tag === "frame" || tag === "iframe" || tag === "media" || tag === "script") || prop === "href" && (tag === "base" || tag === "link")) {
    return \u0275\u0275sanitizeResourceUrl;
  }
  return \u0275\u0275sanitizeUrl;
}
function \u0275\u0275sanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {
  return getUrlSanitizer(tag, prop)(unsafeUrl);
}
function validateAgainstEventProperties(name2) {
  if (name2.toLowerCase().startsWith("on")) {
    const errorMessage = `Binding to event property '${name2}' is disallowed for security reasons, please use (${name2.slice(2)})=...
If '${name2}' is a directive input, make sure the directive is imported by the current module.`;
    throw new RuntimeError(306, errorMessage);
  }
}
function validateAgainstEventAttributes(name2) {
  if (name2.toLowerCase().startsWith("on")) {
    const errorMessage = `Binding to event attribute '${name2}' is disallowed for security reasons, please use (${name2.slice(2)})=...`;
    throw new RuntimeError(306, errorMessage);
  }
}
function getSanitizer() {
  const lView = getLView();
  return lView && lView[ENVIRONMENT].sanitizer;
}
function escapeCommentText(value) {
  return value.replace(COMMENT_DISALLOWED, (text) => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));
}
function normalizeDebugBindingName(name2) {
  name2 = camelCaseToDashCase(name2.replace(/[$@]/g, "_"));
  return `ng-reflect-${name2}`;
}
function camelCaseToDashCase(input2) {
  return input2.replace(CAMEL_CASE_REGEXP, (...m) => "-" + m[1].toLowerCase());
}
function normalizeDebugBindingValue(value) {
  try {
    return value != null ? value.toString().slice(0, 30) : value;
  } catch (e) {
    return "[ERROR] Exception while trying to serialize the value";
  }
}
function validateElementIsKnown(lView, tNode) {
  const tView = lView[TVIEW];
  if (tView.schemas === null)
    return;
  const tagName = tNode.value;
  if (!isDirectiveHost(tNode) && tagName !== null) {
    const isUnknown = (
      // Note that we can't check for `typeof HTMLUnknownElement === 'function'` because
      // Domino doesn't expose HTMLUnknownElement globally.
      typeof HTMLUnknownElement !== "undefined" && HTMLUnknownElement && getNativeByTNode(tNode, lView) instanceof HTMLUnknownElement || typeof customElements !== "undefined" && tagName.indexOf("-") > -1 && !customElements.get(tagName)
    );
    if (isUnknown && !matchingSchemas(tView.schemas, tagName)) {
      const isHostStandalone = isHostComponentStandalone(lView);
      const templateLocation = getTemplateLocationDetails(lView);
      const schemas = `'${isHostStandalone ? "@Component" : "@NgModule"}.schemas'`;
      let message = `'${tagName}' is not a known element${templateLocation}:
`;
      message += `1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone ? "included in the '@Component.imports' of this component" : "a part of an @NgModule where this component is declared"}.
`;
      if (tagName && tagName.indexOf("-") > -1) {
        message += `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;
      } else {
        message += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
      }
      if (shouldThrowErrorOnUnknownElement) {
        throw new RuntimeError(304, message);
      } else {
        console.error(formatRuntimeError(304, message));
      }
    }
  }
}
function isPropertyValid(element, propName, tagName, schemas) {
  if (schemas === null)
    return true;
  if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) {
    return true;
  }
  return typeof Node === "undefined" || Node === null || !(element instanceof Node);
}
function handleUnknownPropertyError(propName, tagName, nodeType, lView) {
  if (!tagName && nodeType === 4) {
    tagName = "ng-template";
  }
  const isHostStandalone = isHostComponentStandalone(lView);
  const templateLocation = getTemplateLocationDetails(lView);
  let message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${templateLocation}.`;
  const schemas = `'${isHostStandalone ? "@Component" : "@NgModule"}.schemas'`;
  const importLocation = isHostStandalone ? "included in the '@Component.imports' of this component" : "a part of an @NgModule where this component is declared";
  if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {
    const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName);
    message += `
If the '${propName}' is an Angular control flow directive, please make sure that either the '${correspondingImport}' directive or the 'CommonModule' is ${importLocation}.`;
  } else {
    message += `
1. If '${tagName}' is an Angular component and it has the '${propName}' input, then verify that it is ${importLocation}.`;
    if (tagName && tagName.indexOf("-") > -1) {
      message += `
2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;
      message += `
3. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
    } else {
      message += `
2. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
    }
  }
  reportUnknownPropertyError(message);
}
function reportUnknownPropertyError(message) {
  if (shouldThrowErrorOnUnknownProperty) {
    throw new RuntimeError(303, message);
  } else {
    console.error(formatRuntimeError(303, message));
  }
}
function getDeclarationComponentDef(lView) {
  !ngDevMode && throwError2("Must never be called in production mode");
  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
  const context2 = declarationLView[CONTEXT];
  if (!context2)
    return null;
  return context2.constructor ? getComponentDef(context2.constructor) : null;
}
function isHostComponentStandalone(lView) {
  !ngDevMode && throwError2("Must never be called in production mode");
  const componentDef = getDeclarationComponentDef(lView);
  return !!componentDef?.standalone;
}
function getTemplateLocationDetails(lView) {
  !ngDevMode && throwError2("Must never be called in production mode");
  const hostComponentDef = getDeclarationComponentDef(lView);
  const componentClassName = hostComponentDef?.type?.name;
  return componentClassName ? ` (used in the '${componentClassName}' component template)` : "";
}
function matchingSchemas(schemas, tagName) {
  if (schemas !== null) {
    for (let i = 0; i < schemas.length; i++) {
      const schema = schemas[i];
      if (schema === NO_ERRORS_SCHEMA || schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf("-") > -1) {
        return true;
      }
    }
  }
  return false;
}
function \u0275\u0275resolveWindow(element) {
  return element.ownerDocument.defaultView;
}
function \u0275\u0275resolveDocument(element) {
  return element.ownerDocument;
}
function \u0275\u0275resolveBody(element) {
  return element.ownerDocument.body;
}
function maybeUnwrapFn(value) {
  if (value instanceof Function) {
    return value();
  } else {
    return value;
  }
}
function assertStandaloneComponentType(type) {
  assertComponentDef(type);
  const componentDef = getComponentDef(type);
  if (!componentDef.standalone) {
    throw new RuntimeError(907, `The ${stringifyForError(type)} component is not marked as standalone, but Angular expects to have a standalone component here. Please make sure the ${stringifyForError(type)} component has the \`standalone: true\` flag in the decorator.`);
  }
}
function assertComponentDef(type) {
  if (!getComponentDef(type)) {
    throw new RuntimeError(906, `The ${stringifyForError(type)} is not an Angular component, make sure it has the \`@Component\` decorator.`);
  }
}
function throwMultipleComponentError(tNode, first2, second) {
  throw new RuntimeError(-300, `Multiple components match node with tagname ${tNode.value}: ${stringifyForError(first2)} and ${stringifyForError(second)}`);
}
function throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName, lView) {
  const hostComponentDef = getDeclarationComponentDef(lView);
  const componentClassName = hostComponentDef?.type?.name;
  const field = propName ? ` for '${propName}'` : "";
  let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${formatValue(oldValue)}'. Current value: '${formatValue(currValue)}'.${componentClassName ? ` Expression location: ${componentClassName} component` : ""}`;
  if (creationMode) {
    msg += ` It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook?`;
  }
  throw new RuntimeError(-100, msg);
}
function formatValue(value) {
  let strValue = String(value);
  try {
    if (Array.isArray(value) || strValue === "[object Object]") {
      strValue = JSON.stringify(value);
    }
  } catch (error) {
  }
  return strValue.length > VALUE_STRING_LENGTH_LIMIT ? strValue.substring(0, VALUE_STRING_LENGTH_LIMIT) + "\u2026" : strValue;
}
function constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta2, changedValue) {
  const [propName, prefix, ...chunks] = meta2.split(INTERPOLATION_DELIMITER);
  let oldValue = prefix, newValue = prefix;
  for (let i = 0; i < chunks.length; i++) {
    const slotIdx = rootIndex + i;
    oldValue += `${lView[slotIdx]}${chunks[i]}`;
    newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;
  }
  return { propName, oldValue, newValue };
}
function getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {
  const tData = lView[TVIEW].data;
  const metadata = tData[bindingIndex];
  if (typeof metadata === "string") {
    if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {
      return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);
    }
    return { propName: metadata, oldValue, newValue };
  }
  if (metadata === null) {
    let idx = bindingIndex - 1;
    while (typeof tData[idx] !== "string" && tData[idx + 1] === null) {
      idx--;
    }
    const meta2 = tData[idx];
    if (typeof meta2 === "string") {
      const matches = meta2.match(new RegExp(INTERPOLATION_DELIMITER, "g"));
      if (matches && matches.length - 1 > bindingIndex - idx) {
        return constructDetailsForInterpolation(lView, idx, bindingIndex, meta2, newValue);
      }
    }
  }
  return { propName: void 0, oldValue, newValue };
}
function classIndexOf(className, classToSearch, startingIndex) {
  ngDevMode && assertNotEqual(classToSearch, "", 'can not look for "" string.');
  let end = className.length;
  while (true) {
    const foundIndex = className.indexOf(classToSearch, startingIndex);
    if (foundIndex === -1)
      return foundIndex;
    if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32) {
      const length = classToSearch.length;
      if (foundIndex + length === end || className.charCodeAt(foundIndex + length) <= 32) {
        return foundIndex;
      }
    }
    startingIndex = foundIndex + 1;
  }
}
function isCssClassMatching(tNode, attrs, cssClassToMatch, isProjectionMode) {
  ngDevMode && assertEqual(cssClassToMatch, cssClassToMatch.toLowerCase(), "Class name expected to be lowercase.");
  let i = 0;
  if (isProjectionMode) {
    for (; i < attrs.length && typeof attrs[i] === "string"; i += 2) {
      if (attrs[i] === "class" && classIndexOf(attrs[i + 1].toLowerCase(), cssClassToMatch, 0) !== -1) {
        return true;
      }
    }
  } else if (isInlineTemplate(tNode)) {
    return false;
  }
  i = attrs.indexOf(1, i);
  if (i > -1) {
    let item;
    while (++i < attrs.length && typeof (item = attrs[i]) === "string") {
      if (item.toLowerCase() === cssClassToMatch) {
        return true;
      }
    }
  }
  return false;
}
function isInlineTemplate(tNode) {
  return tNode.type === 4 && tNode.value !== NG_TEMPLATE_SELECTOR;
}
function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
  const tagNameToCompare = tNode.type === 4 && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;
  return currentSelector === tagNameToCompare;
}
function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
  ngDevMode && assertDefined(selector[0], "Selector should have a tag name");
  let mode = 4;
  const nodeAttrs = tNode.attrs;
  const nameOnlyMarkerIdx = nodeAttrs !== null ? getNameOnlyMarkerIndex(nodeAttrs) : 0;
  let skipToNextSelector = false;
  for (let i = 0; i < selector.length; i++) {
    const current = selector[i];
    if (typeof current === "number") {
      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {
        return false;
      }
      if (skipToNextSelector && isPositive(current))
        continue;
      skipToNextSelector = false;
      mode = current | mode & 1;
      continue;
    }
    if (skipToNextSelector)
      continue;
    if (mode & 4) {
      mode = 2 | mode & 1;
      if (current !== "" && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || current === "" && selector.length === 1) {
        if (isPositive(mode))
          return false;
        skipToNextSelector = true;
      }
    } else if (mode & 8) {
      if (nodeAttrs === null || !isCssClassMatching(tNode, nodeAttrs, current, isProjectionMode)) {
        if (isPositive(mode))
          return false;
        skipToNextSelector = true;
      }
    } else {
      const selectorAttrValue = selector[++i];
      const attrIndexInNode = findAttrIndexInNode(current, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);
      if (attrIndexInNode === -1) {
        if (isPositive(mode))
          return false;
        skipToNextSelector = true;
        continue;
      }
      if (selectorAttrValue !== "") {
        let nodeAttrValue;
        if (attrIndexInNode > nameOnlyMarkerIdx) {
          nodeAttrValue = "";
        } else {
          ngDevMode && assertNotEqual(nodeAttrs[attrIndexInNode], 0, "We do not match directives on namespaced attributes");
          nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();
        }
        if (mode & 2 && selectorAttrValue !== nodeAttrValue) {
          if (isPositive(mode))
            return false;
          skipToNextSelector = true;
        }
      }
    }
  }
  return isPositive(mode) || skipToNextSelector;
}
function isPositive(mode) {
  return (mode & 1) === 0;
}
function findAttrIndexInNode(name2, attrs, isInlineTemplate2, isProjectionMode) {
  if (attrs === null)
    return -1;
  let i = 0;
  if (isProjectionMode || !isInlineTemplate2) {
    let bindingsMode = false;
    while (i < attrs.length) {
      const maybeAttrName = attrs[i];
      if (maybeAttrName === name2) {
        return i;
      } else if (maybeAttrName === 3 || maybeAttrName === 6) {
        bindingsMode = true;
      } else if (maybeAttrName === 1 || maybeAttrName === 2) {
        let value = attrs[++i];
        while (typeof value === "string") {
          value = attrs[++i];
        }
        continue;
      } else if (maybeAttrName === 4) {
        break;
      } else if (maybeAttrName === 0) {
        i += 4;
        continue;
      }
      i += bindingsMode ? 1 : 2;
    }
    return -1;
  } else {
    return matchTemplateAttribute(attrs, name2);
  }
}
function isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {
  for (let i = 0; i < selector.length; i++) {
    if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {
      return true;
    }
  }
  return false;
}
function getProjectAsAttrValue(tNode) {
  const nodeAttrs = tNode.attrs;
  if (nodeAttrs != null) {
    const ngProjectAsAttrIdx = nodeAttrs.indexOf(
      5
      /* AttributeMarker.ProjectAs */
    );
    if ((ngProjectAsAttrIdx & 1) === 0) {
      return nodeAttrs[ngProjectAsAttrIdx + 1];
    }
  }
  return null;
}
function getNameOnlyMarkerIndex(nodeAttrs) {
  for (let i = 0; i < nodeAttrs.length; i++) {
    const nodeAttr = nodeAttrs[i];
    if (isNameOnlyAttributeMarker(nodeAttr)) {
      return i;
    }
  }
  return nodeAttrs.length;
}
function matchTemplateAttribute(attrs, name2) {
  let i = attrs.indexOf(
    4
    /* AttributeMarker.Template */
  );
  if (i > -1) {
    i++;
    while (i < attrs.length) {
      const attr = attrs[i];
      if (typeof attr === "number")
        return -1;
      if (attr === name2)
        return i;
      i++;
    }
  }
  return -1;
}
function isSelectorInSelectorList(selector, list) {
  selectorListLoop: for (let i = 0; i < list.length; i++) {
    const currentSelectorInList = list[i];
    if (selector.length !== currentSelectorInList.length) {
      continue;
    }
    for (let j = 0; j < selector.length; j++) {
      if (selector[j] !== currentSelectorInList[j]) {
        continue selectorListLoop;
      }
    }
    return true;
  }
  return false;
}
function maybeWrapInNotSelector(isNegativeMode, chunk) {
  return isNegativeMode ? ":not(" + chunk.trim() + ")" : chunk;
}
function stringifyCSSSelector(selector) {
  let result = selector[0];
  let i = 1;
  let mode = 2;
  let currentChunk = "";
  let isNegativeMode = false;
  while (i < selector.length) {
    let valueOrMarker = selector[i];
    if (typeof valueOrMarker === "string") {
      if (mode & 2) {
        const attrValue = selector[++i];
        currentChunk += "[" + valueOrMarker + (attrValue.length > 0 ? '="' + attrValue + '"' : "") + "]";
      } else if (mode & 8) {
        currentChunk += "." + valueOrMarker;
      } else if (mode & 4) {
        currentChunk += " " + valueOrMarker;
      }
    } else {
      if (currentChunk !== "" && !isPositive(valueOrMarker)) {
        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
        currentChunk = "";
      }
      mode = valueOrMarker;
      isNegativeMode = isNegativeMode || !isPositive(mode);
    }
    i++;
  }
  if (currentChunk !== "") {
    result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
  }
  return result;
}
function stringifyCSSSelectorList(selectorList) {
  return selectorList.map(stringifyCSSSelector).join(",");
}
function extractAttrsAndClassesFromSelector(selector) {
  const attrs = [];
  const classes = [];
  let i = 1;
  let mode = 2;
  while (i < selector.length) {
    let valueOrMarker = selector[i];
    if (typeof valueOrMarker === "string") {
      if (mode === 2) {
        if (valueOrMarker !== "") {
          attrs.push(valueOrMarker, selector[++i]);
        }
      } else if (mode === 8) {
        classes.push(valueOrMarker);
      }
    } else {
      if (!isPositive(mode))
        break;
      mode = valueOrMarker;
    }
    i++;
  }
  if (classes.length) {
    attrs.push(1, ...classes);
  }
  return attrs;
}
function createTextNode(renderer, value) {
  return renderer.createText(value);
}
function updateTextNode(renderer, rNode, value) {
  renderer.setValue(rNode, value);
}
function createCommentNode(renderer, value) {
  return renderer.createComment(escapeCommentText(value));
}
function createElementNode(renderer, name2, namespace) {
  return renderer.createElement(name2, namespace);
}
function nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {
  renderer.insertBefore(parent, child, beforeNode, isMove);
}
function nativeAppendChild(renderer, parent, child) {
  ngDevMode && assertDefined(parent, "parent node must be defined");
  renderer.appendChild(parent, child);
}
function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {
  if (beforeNode !== null) {
    nativeInsertBefore(renderer, parent, child, beforeNode, isMove);
  } else {
    nativeAppendChild(renderer, parent, child);
  }
}
function nativeRemoveNode(renderer, rNode, isHostElement) {
  renderer.removeChild(null, rNode, isHostElement);
}
function writeDirectStyle(renderer, element, newValue) {
  ngDevMode && assertString(newValue, "'newValue' should be a string");
  renderer.setAttribute(element, "style", newValue);
}
function writeDirectClass(renderer, element, newValue) {
  ngDevMode && assertString(newValue, "'newValue' should be a string");
  if (newValue === "") {
    renderer.removeAttribute(element, "class");
  } else {
    renderer.setAttribute(element, "class", newValue);
  }
}
function setupStaticAttributes(renderer, element, tNode) {
  const { mergedAttrs, classes, styles } = tNode;
  if (mergedAttrs !== null) {
    setUpAttributes(renderer, element, mergedAttrs);
  }
  if (classes !== null) {
    writeDirectClass(renderer, element, classes);
  }
  if (styles !== null) {
    writeDirectStyle(renderer, element, styles);
  }
}
function createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory, ssrId) {
  const bindingStartIndex = HEADER_OFFSET + decls;
  const initialViewLength = bindingStartIndex + vars;
  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);
  const consts = typeof constsOrFactory === "function" ? constsOrFactory() : constsOrFactory;
  const tView = blueprint[TVIEW] = {
    type,
    blueprint,
    template: templateFn,
    queries: null,
    viewQuery,
    declTNode,
    data: blueprint.slice().fill(null, bindingStartIndex),
    bindingStartIndex,
    expandoStartIndex: initialViewLength,
    hostBindingOpCodes: null,
    firstCreatePass: true,
    firstUpdatePass: true,
    staticViewQueries: false,
    staticContentQueries: false,
    preOrderHooks: null,
    preOrderCheckHooks: null,
    contentHooks: null,
    contentCheckHooks: null,
    viewHooks: null,
    viewCheckHooks: null,
    destroyHooks: null,
    cleanup: null,
    contentQueries: null,
    components: null,
    directiveRegistry: typeof directives === "function" ? directives() : directives,
    pipeRegistry: typeof pipes === "function" ? pipes() : pipes,
    firstChild: null,
    schemas,
    consts,
    incompleteFirstPass: false,
    ssrId
  };
  if (ngDevMode) {
    Object.seal(tView);
  }
  return tView;
}
function createViewBlueprint(bindingStartIndex, initialViewLength) {
  const blueprint = [];
  for (let i = 0; i < initialViewLength; i++) {
    blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);
  }
  return blueprint;
}
function getOrCreateComponentTView(def) {
  const tView = def.tView;
  if (tView === null || tView.incompleteFirstPass) {
    const declTNode = null;
    return def.tView = createTView(1, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts, def.id);
  }
  return tView;
}
function createLView(parentLView, tView, context2, flags, host, tHostNode, environment, renderer, injector, embeddedViewInjector, hydrationInfo) {
  const lView = tView.blueprint.slice();
  lView[HOST] = host;
  lView[FLAGS] = flags | 4 | 128 | 8 | 64 | 1024;
  if (embeddedViewInjector !== null || parentLView && parentLView[FLAGS] & 2048) {
    lView[FLAGS] |= 2048;
  }
  resetPreOrderHookFlags(lView);
  ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);
  lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;
  lView[CONTEXT] = context2;
  lView[ENVIRONMENT] = environment || parentLView && parentLView[ENVIRONMENT];
  ngDevMode && assertDefined(lView[ENVIRONMENT], "LViewEnvironment is required");
  lView[RENDERER] = renderer || parentLView && parentLView[RENDERER];
  ngDevMode && assertDefined(lView[RENDERER], "Renderer is required");
  lView[INJECTOR] = injector || parentLView && parentLView[INJECTOR] || null;
  lView[T_HOST] = tHostNode;
  lView[ID] = getUniqueLViewId();
  lView[HYDRATION] = hydrationInfo;
  lView[EMBEDDED_VIEW_INJECTOR] = embeddedViewInjector;
  ngDevMode && assertEqual(tView.type == 2 ? parentLView !== null : true, true, "Embedded views must have parentLView");
  lView[DECLARATION_COMPONENT_VIEW] = tView.type == 2 ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;
  return lView;
}
function createComponentLView(lView, hostTNode, def) {
  const native = getNativeByTNode(hostTNode, lView);
  const tView = getOrCreateComponentTView(def);
  const rendererFactory = lView[ENVIRONMENT].rendererFactory;
  const componentView = addToEndOfViewTree(lView, createLView(lView, tView, null, getInitialLViewFlagsFromDef(def), native, hostTNode, null, rendererFactory.createRenderer(native, def), null, null, null));
  return lView[hostTNode.index] = componentView;
}
function getInitialLViewFlagsFromDef(def) {
  let flags = 16;
  if (def.signals) {
    flags = 4096;
  } else if (def.onPush) {
    flags = 64;
  }
  return flags;
}
function allocExpando(tView, lView, numSlotsToAlloc, initialValue) {
  if (numSlotsToAlloc === 0)
    return -1;
  if (ngDevMode) {
    assertFirstCreatePass(tView);
    assertSame(tView, lView[TVIEW], "`LView` must be associated with `TView`!");
    assertEqual(tView.data.length, lView.length, "Expecting LView to be same size as TView");
    assertEqual(tView.data.length, tView.blueprint.length, "Expecting Blueprint to be same size as TView");
    assertFirstUpdatePass(tView);
  }
  const allocIdx = lView.length;
  for (let i = 0; i < numSlotsToAlloc; i++) {
    lView.push(initialValue);
    tView.blueprint.push(initialValue);
    tView.data.push(null);
  }
  return allocIdx;
}
function addToEndOfViewTree(lView, lViewOrLContainer) {
  if (lView[CHILD_HEAD]) {
    lView[CHILD_TAIL][NEXT] = lViewOrLContainer;
  } else {
    lView[CHILD_HEAD] = lViewOrLContainer;
  }
  lView[CHILD_TAIL] = lViewOrLContainer;
  return lViewOrLContainer;
}
function \u0275\u0275advance(delta = 1) {
  ngDevMode && assertGreaterThan(delta, 0, "Can only advance forward");
  selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, !!ngDevMode && isInCheckNoChangesMode());
}
function selectIndexInternal(tView, lView, index, checkNoChangesMode) {
  ngDevMode && assertIndexInDeclRange(lView[TVIEW], index);
  if (!checkNoChangesMode) {
    const hooksInitPhaseCompleted = (lView[FLAGS] & 3) === 3;
    if (hooksInitPhaseCompleted) {
      const preOrderCheckHooks = tView.preOrderCheckHooks;
      if (preOrderCheckHooks !== null) {
        executeCheckHooks(lView, preOrderCheckHooks, index);
      }
    } else {
      const preOrderHooks = tView.preOrderHooks;
      if (preOrderHooks !== null) {
        executeInitAndCheckHooks(lView, preOrderHooks, 0, index);
      }
    }
  }
  setSelectedIndex(index);
}
function writeToDirectiveInput(def, instance, publicName, value) {
  const prevConsumer = setActiveConsumer(null);
  try {
    if (ngDevMode) {
      if (!def.inputs.hasOwnProperty(publicName)) {
        throw new Error(`ASSERTION ERROR: Directive ${def.type.name} does not have an input with a public name of "${publicName}"`);
      }
      if (instance instanceof NodeInjectorFactory) {
        throw new Error(`ASSERTION ERROR: Cannot write input to factory for type ${def.type.name}. Directive has not been created yet.`);
      }
    }
    const [privateName, flags, transform] = def.inputs[publicName];
    let inputSignalNode = null;
    if ((flags & InputFlags.SignalBased) !== 0) {
      const field = instance[privateName];
      inputSignalNode = field[SIGNAL];
    }
    if (inputSignalNode !== null && inputSignalNode.transformFn !== void 0) {
      value = inputSignalNode.transformFn(value);
    } else if (transform !== null) {
      value = transform.call(instance, value);
    }
    if (def.setInput !== null) {
      def.setInput(instance, inputSignalNode, value, publicName, privateName);
    } else {
      applyValueToInputField(instance, inputSignalNode, privateName, value);
    }
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function icuContainerIterate(tIcuContainerNode, lView) {
  return _icuContainerIterate(tIcuContainerNode, lView);
}
function ensureIcuContainerVisitorLoaded(loader) {
  if (_icuContainerIterate === void 0) {
    _icuContainerIterate = loader();
  }
}
function applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {
  if (lNodeToHandle != null) {
    let lContainer;
    let isComponent2 = false;
    if (isLContainer(lNodeToHandle)) {
      lContainer = lNodeToHandle;
    } else if (isLView(lNodeToHandle)) {
      isComponent2 = true;
      ngDevMode && assertDefined(lNodeToHandle[HOST], "HOST must be defined for a component LView");
      lNodeToHandle = lNodeToHandle[HOST];
    }
    const rNode = unwrapRNode(lNodeToHandle);
    if (action === 0 && parent !== null) {
      if (beforeNode == null) {
        nativeAppendChild(renderer, parent, rNode);
      } else {
        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
      }
    } else if (action === 1 && parent !== null) {
      nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
    } else if (action === 2) {
      nativeRemoveNode(renderer, rNode, isComponent2);
    } else if (action === 3) {
      renderer.destroyNode(rNode);
    }
    if (lContainer != null) {
      applyContainer(renderer, action, lContainer, parent, beforeNode);
    }
  }
}
function removeViewFromDOM(tView, lView) {
  detachViewFromDOM(tView, lView);
  lView[HOST] = null;
  lView[T_HOST] = null;
}
function addViewToDOM(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {
  lView[HOST] = parentNativeNode;
  lView[T_HOST] = parentTNode;
  applyView(tView, lView, renderer, 1, parentNativeNode, beforeNode);
}
function detachViewFromDOM(tView, lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(
    9
    /* NotificationSource.ViewDetachedFromDOM */
  );
  applyView(tView, lView, lView[RENDERER], 2, null, null);
}
function destroyViewTree(rootView) {
  let lViewOrLContainer = rootView[CHILD_HEAD];
  if (!lViewOrLContainer) {
    return cleanUpView(rootView[TVIEW], rootView);
  }
  while (lViewOrLContainer) {
    let next = null;
    if (isLView(lViewOrLContainer)) {
      next = lViewOrLContainer[CHILD_HEAD];
    } else {
      ngDevMode && assertLContainer(lViewOrLContainer);
      const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];
      if (firstView)
        next = firstView;
    }
    if (!next) {
      while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {
        if (isLView(lViewOrLContainer)) {
          cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
        }
        lViewOrLContainer = lViewOrLContainer[PARENT];
      }
      if (lViewOrLContainer === null)
        lViewOrLContainer = rootView;
      if (isLView(lViewOrLContainer)) {
        cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
      }
      next = lViewOrLContainer && lViewOrLContainer[NEXT];
    }
    lViewOrLContainer = next;
  }
}
function detachMovedView(declarationContainer, lView) {
  ngDevMode && assertLContainer(declarationContainer);
  ngDevMode && assertDefined(declarationContainer[MOVED_VIEWS], "A projected view should belong to a non-empty projected views collection");
  const movedViews = declarationContainer[MOVED_VIEWS];
  const declarationViewIndex = movedViews.indexOf(lView);
  movedViews.splice(declarationViewIndex, 1);
}
function destroyLView(tView, lView) {
  if (isDestroyed(lView)) {
    return;
  }
  const renderer = lView[RENDERER];
  if (renderer.destroyNode) {
    applyView(tView, lView, renderer, 3, null, null);
  }
  destroyViewTree(lView);
}
function cleanUpView(tView, lView) {
  if (isDestroyed(lView)) {
    return;
  }
  const prevConsumer = setActiveConsumer(null);
  try {
    lView[FLAGS] &= ~128;
    lView[FLAGS] |= 256;
    lView[REACTIVE_TEMPLATE_CONSUMER] && consumerDestroy(lView[REACTIVE_TEMPLATE_CONSUMER]);
    executeOnDestroys(tView, lView);
    processCleanups(tView, lView);
    if (lView[TVIEW].type === 1) {
      lView[RENDERER].destroy();
    }
    const declarationContainer = lView[DECLARATION_LCONTAINER];
    if (declarationContainer !== null && isLContainer(lView[PARENT])) {
      if (declarationContainer !== lView[PARENT]) {
        detachMovedView(declarationContainer, lView);
      }
      const lQueries = lView[QUERIES];
      if (lQueries !== null) {
        lQueries.detachView(tView);
      }
    }
    unregisterLView(lView);
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function processCleanups(tView, lView) {
  ngDevMode && assertNotReactive(processCleanups.name);
  const tCleanup = tView.cleanup;
  const lCleanup = lView[CLEANUP];
  if (tCleanup !== null) {
    for (let i = 0; i < tCleanup.length - 1; i += 2) {
      if (typeof tCleanup[i] === "string") {
        const targetIdx = tCleanup[i + 3];
        ngDevMode && assertNumber(targetIdx, "cleanup target must be a number");
        if (targetIdx >= 0) {
          lCleanup[targetIdx]();
        } else {
          lCleanup[-targetIdx].unsubscribe();
        }
        i += 2;
      } else {
        const context2 = lCleanup[tCleanup[i + 1]];
        tCleanup[i].call(context2);
      }
    }
  }
  if (lCleanup !== null) {
    lView[CLEANUP] = null;
  }
  const destroyHooks = lView[ON_DESTROY_HOOKS];
  if (destroyHooks !== null) {
    lView[ON_DESTROY_HOOKS] = null;
    for (let i = 0; i < destroyHooks.length; i++) {
      const destroyHooksFn = destroyHooks[i];
      ngDevMode && assertFunction(destroyHooksFn, "Expecting destroy hook to be a function.");
      destroyHooksFn();
    }
  }
  const effects = lView[EFFECTS];
  if (effects !== null) {
    lView[EFFECTS] = null;
    for (const effect2 of effects) {
      effect2.destroy();
    }
  }
}
function executeOnDestroys(tView, lView) {
  ngDevMode && assertNotReactive(executeOnDestroys.name);
  let destroyHooks;
  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {
    for (let i = 0; i < destroyHooks.length; i += 2) {
      const context2 = lView[destroyHooks[i]];
      if (!(context2 instanceof NodeInjectorFactory)) {
        const toCall = destroyHooks[i + 1];
        if (Array.isArray(toCall)) {
          for (let j = 0; j < toCall.length; j += 2) {
            const callContext = context2[toCall[j]];
            const hook = toCall[j + 1];
            profiler(4, callContext, hook);
            try {
              hook.call(callContext);
            } finally {
              profiler(5, callContext, hook);
            }
          }
        } else {
          profiler(4, context2, toCall);
          try {
            toCall.call(context2);
          } finally {
            profiler(5, context2, toCall);
          }
        }
      }
    }
  }
}
function getParentRElement(tView, tNode, lView) {
  return getClosestRElement(tView, tNode.parent, lView);
}
function getClosestRElement(tView, tNode, lView) {
  let parentTNode = tNode;
  while (parentTNode !== null && parentTNode.type & (8 | 32 | 128)) {
    tNode = parentTNode;
    parentTNode = tNode.parent;
  }
  if (parentTNode === null) {
    return lView[HOST];
  } else {
    ngDevMode && assertTNodeType(
      parentTNode,
      3 | 4
      /* TNodeType.Container */
    );
    if (isComponentHost(parentTNode)) {
      ngDevMode && assertTNodeForLView(parentTNode, lView);
      const { encapsulation } = tView.data[parentTNode.directiveStart + parentTNode.componentOffset];
      if (encapsulation === ViewEncapsulation.None || encapsulation === ViewEncapsulation.Emulated) {
        return null;
      }
    }
    return getNativeByTNode(parentTNode, lView);
  }
}
function getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {
  return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);
}
function getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {
  if (parentTNode.type & (8 | 32)) {
    return getNativeByTNode(parentTNode, lView);
  }
  return null;
}
function setI18nHandling(getInsertInFrontOfRNodeWithI18n2, processI18nInsertBefore2) {
  _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n2;
  _processI18nInsertBefore = processI18nInsertBefore2;
}
function appendChild(tView, lView, childRNode, childTNode) {
  const parentRNode = getParentRElement(tView, childTNode, lView);
  const renderer = lView[RENDERER];
  const parentTNode = childTNode.parent || lView[T_HOST];
  const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);
  if (parentRNode != null) {
    if (Array.isArray(childRNode)) {
      for (let i = 0; i < childRNode.length; i++) {
        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);
      }
    } else {
      nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);
    }
  }
  _processI18nInsertBefore !== void 0 && _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);
}
function getFirstNativeNode(lView, tNode) {
  if (tNode !== null) {
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 32 | 16 | 128
      /* TNodeType.LetDeclaration */
    );
    const tNodeType = tNode.type;
    if (tNodeType & 3) {
      return getNativeByTNode(tNode, lView);
    } else if (tNodeType & 4) {
      return getBeforeNodeForView(-1, lView[tNode.index]);
    } else if (tNodeType & 8) {
      const elIcuContainerChild = tNode.child;
      if (elIcuContainerChild !== null) {
        return getFirstNativeNode(lView, elIcuContainerChild);
      } else {
        const rNodeOrLContainer = lView[tNode.index];
        if (isLContainer(rNodeOrLContainer)) {
          return getBeforeNodeForView(-1, rNodeOrLContainer);
        } else {
          return unwrapRNode(rNodeOrLContainer);
        }
      }
    } else if (tNodeType & 128) {
      return getFirstNativeNode(lView, tNode.next);
    } else if (tNodeType & 32) {
      let nextRNode = icuContainerIterate(tNode, lView);
      let rNode = nextRNode();
      return rNode || unwrapRNode(lView[tNode.index]);
    } else {
      const projectionNodes = getProjectionNodes(lView, tNode);
      if (projectionNodes !== null) {
        if (Array.isArray(projectionNodes)) {
          return projectionNodes[0];
        }
        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
        ngDevMode && assertParentView(parentView);
        return getFirstNativeNode(parentView, projectionNodes);
      } else {
        return getFirstNativeNode(lView, tNode.next);
      }
    }
  }
  return null;
}
function getProjectionNodes(lView, tNode) {
  if (tNode !== null) {
    const componentView = lView[DECLARATION_COMPONENT_VIEW];
    const componentHost = componentView[T_HOST];
    const slotIdx = tNode.projection;
    ngDevMode && assertProjectionSlots(lView);
    return componentHost.projection[slotIdx];
  }
  return null;
}
function getBeforeNodeForView(viewIndexInContainer, lContainer) {
  const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;
  if (nextViewIndex < lContainer.length) {
    const lView = lContainer[nextViewIndex];
    const firstTNodeOfView = lView[TVIEW].firstChild;
    if (firstTNodeOfView !== null) {
      return getFirstNativeNode(lView, firstTNodeOfView);
    }
  }
  return lContainer[NATIVE];
}
function applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {
  while (tNode != null) {
    ngDevMode && assertTNodeForLView(tNode, lView);
    if (tNode.type === 128) {
      tNode = tNode.next;
      continue;
    }
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 16 | 32
      /* TNodeType.Icu */
    );
    const rawSlotValue = lView[tNode.index];
    const tNodeType = tNode.type;
    if (isProjection) {
      if (action === 0) {
        rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);
        tNode.flags |= 2;
      }
    }
    if (!isDetachedByI18n(tNode)) {
      if (tNodeType & 8) {
        applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      } else if (tNodeType & 32) {
        const nextRNode = icuContainerIterate(tNode, lView);
        let rNode;
        while (rNode = nextRNode()) {
          applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
        }
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      } else if (tNodeType & 16) {
        applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);
      } else {
        ngDevMode && assertTNodeType(
          tNode,
          3 | 4
          /* TNodeType.Container */
        );
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      }
    }
    tNode = isProjection ? tNode.projectionNext : tNode.next;
  }
}
function applyView(tView, lView, renderer, action, parentRElement, beforeNode) {
  applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);
}
function applyProjection(tView, lView, tProjectionNode) {
  const renderer = lView[RENDERER];
  const parentRNode = getParentRElement(tView, tProjectionNode, lView);
  const parentTNode = tProjectionNode.parent || lView[T_HOST];
  let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);
  applyProjectionRecursive(renderer, 0, lView, tProjectionNode, parentRNode, beforeNode);
}
function applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {
  const componentLView = lView[DECLARATION_COMPONENT_VIEW];
  const componentNode = componentLView[T_HOST];
  ngDevMode && assertEqual(typeof tProjectionNode.projection, "number", "expecting projection index");
  const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];
  if (Array.isArray(nodeToProjectOrRNodes)) {
    for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {
      const rNode = nodeToProjectOrRNodes[i];
      applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
    }
  } else {
    let nodeToProject = nodeToProjectOrRNodes;
    const projectedComponentLView = componentLView[PARENT];
    if (hasInSkipHydrationBlockFlag(tProjectionNode)) {
      nodeToProject.flags |= 128;
    }
    applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);
  }
}
function applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {
  ngDevMode && assertLContainer(lContainer);
  const anchor = lContainer[NATIVE];
  const native = unwrapRNode(lContainer);
  if (anchor !== native) {
    applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);
  }
  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    const lView = lContainer[i];
    applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);
  }
}
function applyStyling(renderer, isClassBased, rNode, prop, value) {
  if (isClassBased) {
    if (!value) {
      renderer.removeClass(rNode, prop);
    } else {
      renderer.addClass(rNode, prop);
    }
  } else {
    let flags = prop.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
    if (value == null) {
      renderer.removeStyle(rNode, prop, flags);
    } else {
      const isImportant = typeof value === "string" ? value.endsWith("!important") : false;
      if (isImportant) {
        value = value.slice(0, -10);
        flags |= RendererStyleFlags2.Important;
      }
      renderer.setStyle(rNode, prop, value, flags);
    }
  }
}
function executeTemplate(tView, lView, templateFn, rf, context2) {
  const prevSelectedIndex = getSelectedIndex();
  const isUpdatePhase = rf & 2;
  try {
    setSelectedIndex(-1);
    if (isUpdatePhase && lView.length > HEADER_OFFSET) {
      selectIndexInternal(tView, lView, HEADER_OFFSET, !!ngDevMode && isInCheckNoChangesMode());
    }
    const preHookType = isUpdatePhase ? 2 : 0;
    profiler(preHookType, context2, templateFn);
    templateFn(rf, context2);
  } finally {
    setSelectedIndex(prevSelectedIndex);
    const postHookType = isUpdatePhase ? 3 : 1;
    profiler(postHookType, context2, templateFn);
  }
}
function createDirectivesInstances(tView, lView, tNode) {
  instantiateAllDirectives(tView, lView, tNode);
  if ((tNode.flags & 64) === 64) {
    invokeDirectivesHostBindings(tView, lView, tNode);
  }
}
function saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {
  const localNames = tNode.localNames;
  if (localNames !== null) {
    let localIndex = tNode.index + 1;
    for (let i = 0; i < localNames.length; i += 2) {
      const index = localNames[i + 1];
      const value = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];
      viewData[localIndex++] = value;
    }
  }
}
function locateHostElement(renderer, elementOrSelector, encapsulation, injector) {
  const preserveHostContent = injector.get(PRESERVE_HOST_CONTENT, PRESERVE_HOST_CONTENT_DEFAULT);
  const preserveContent = preserveHostContent || encapsulation === ViewEncapsulation.ShadowDom;
  const rootElement = renderer.selectRootElement(elementOrSelector, preserveContent);
  applyRootElementTransform(rootElement);
  return rootElement;
}
function applyRootElementTransform(rootElement) {
  _applyRootElementTransformImpl(rootElement);
}
function mapPropName(name2) {
  if (name2 === "class")
    return "className";
  if (name2 === "for")
    return "htmlFor";
  if (name2 === "formaction")
    return "formAction";
  if (name2 === "innerHtml")
    return "innerHTML";
  if (name2 === "readonly")
    return "readOnly";
  if (name2 === "tabindex")
    return "tabIndex";
  return name2;
}
function setPropertyAndInputs(tNode, lView, propName, value, renderer, sanitizer) {
  ngDevMode && assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
  const tView = lView[TVIEW];
  const hasSetInput = setAllInputsForProperty(tNode, tView, lView, propName, value);
  if (hasSetInput) {
    isComponentHost(tNode) && markDirtyIfOnPush(lView, tNode.index);
    ngDevMode && setNgReflectProperties(lView, tView, tNode, propName, value);
    return;
  }
  if (tNode.type & 3) {
    propName = mapPropName(propName);
  }
  setDomProperty(tNode, lView, propName, value, renderer, sanitizer);
}
function setDomProperty(tNode, lView, propName, value, renderer, sanitizer) {
  if (tNode.type & 3) {
    const element = getNativeByTNode(tNode, lView);
    if (ngDevMode) {
      validateAgainstEventProperties(propName);
      if (!isPropertyValid(element, propName, tNode.value, lView[TVIEW].schemas)) {
        handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
      }
    }
    value = sanitizer != null ? sanitizer(value, tNode.value || "", propName) : value;
    renderer.setProperty(element, propName, value);
  } else if (tNode.type & 12) {
    if (ngDevMode && !matchingSchemas(lView[TVIEW].schemas, tNode.value)) {
      handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
    }
  }
}
function markDirtyIfOnPush(lView, viewIndex) {
  ngDevMode && assertLView(lView);
  const childComponentLView = getComponentLViewByIndex(viewIndex, lView);
  if (!(childComponentLView[FLAGS] & 16)) {
    childComponentLView[FLAGS] |= 64;
  }
}
function setNgReflectProperty(lView, tNode, attrName, value) {
  const environment = lView[ENVIRONMENT];
  if (!environment.ngReflect) {
    return;
  }
  const element = getNativeByTNode(tNode, lView);
  const renderer = lView[RENDERER];
  attrName = normalizeDebugBindingName(attrName);
  const debugValue = normalizeDebugBindingValue(value);
  if (tNode.type & 3) {
    if (value == null) {
      renderer.removeAttribute(element, attrName);
    } else {
      renderer.setAttribute(element, attrName, debugValue);
    }
  } else {
    const textContent = escapeCommentText(`bindings=${JSON.stringify({ [attrName]: debugValue }, null, 2)}`);
    renderer.setValue(element, textContent);
  }
}
function setNgReflectProperties(lView, tView, tNode, publicName, value) {
  const environment = lView[ENVIRONMENT];
  if (!environment.ngReflect || !(tNode.type & (3 | 4))) {
    return;
  }
  const inputConfig = tNode.inputs?.[publicName];
  const hostInputConfig = tNode.hostDirectiveInputs?.[publicName];
  if (hostInputConfig) {
    for (let i = 0; i < hostInputConfig.length; i += 2) {
      const index = hostInputConfig[i];
      const publicName2 = hostInputConfig[i + 1];
      const def = tView.data[index];
      setNgReflectProperty(lView, tNode, def.inputs[publicName2][0], value);
    }
  }
  if (inputConfig) {
    for (const index of inputConfig) {
      const def = tView.data[index];
      setNgReflectProperty(lView, tNode, def.inputs[publicName][0], value);
    }
  }
}
function instantiateAllDirectives(tView, lView, tNode) {
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  if (isComponentHost(tNode)) {
    ngDevMode && assertTNodeType(
      tNode,
      3
      /* TNodeType.AnyRNode */
    );
    createComponentLView(lView, tNode, tView.data[start + tNode.componentOffset]);
  }
  if (!tView.firstCreatePass) {
    getOrCreateNodeInjectorForNode(tNode, lView);
  }
  const initialInputs = tNode.initialInputs;
  for (let i = start; i < end; i++) {
    const def = tView.data[i];
    const directive = getNodeInjectable(lView, tView, i, tNode);
    attachPatchData(directive, lView);
    if (initialInputs !== null) {
      setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs);
    }
    if (isComponentDef(def)) {
      const componentView = getComponentLViewByIndex(tNode.index, lView);
      componentView[CONTEXT] = getNodeInjectable(lView, tView, i, tNode);
    }
  }
}
function invokeDirectivesHostBindings(tView, lView, tNode) {
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  const elementIndex = tNode.index;
  const currentDirectiveIndex = getCurrentDirectiveIndex();
  try {
    setSelectedIndex(elementIndex);
    for (let dirIndex = start; dirIndex < end; dirIndex++) {
      const def = tView.data[dirIndex];
      const directive = lView[dirIndex];
      setCurrentDirectiveIndex(dirIndex);
      if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {
        invokeHostBindingsInCreationMode(def, directive);
      }
    }
  } finally {
    setSelectedIndex(-1);
    setCurrentDirectiveIndex(currentDirectiveIndex);
  }
}
function invokeHostBindingsInCreationMode(def, directive) {
  if (def.hostBindings !== null) {
    def.hostBindings(1, directive);
  }
}
function findDirectiveDefMatches(tView, tNode) {
  ngDevMode && assertFirstCreatePass(tView);
  ngDevMode && assertTNodeType(
    tNode,
    3 | 12
    /* TNodeType.AnyContainer */
  );
  const registry = tView.directiveRegistry;
  let matches = null;
  if (registry) {
    for (let i = 0; i < registry.length; i++) {
      const def = registry[i];
      if (isNodeMatchingSelectorList(
        tNode,
        def.selectors,
        /* isProjectionMode */
        false
      )) {
        matches ??= [];
        if (isComponentDef(def)) {
          if (ngDevMode) {
            assertTNodeType(tNode, 2, `"${tNode.value}" tags cannot be used as component hosts. Please use a different tag to activate the ${stringify(def.type)} component.`);
            if (matches.length && isComponentDef(matches[0])) {
              throwMultipleComponentError(tNode, matches.find(isComponentDef).type, def.type);
            }
          }
          matches.unshift(def);
        } else {
          matches.push(def);
        }
      }
    }
  }
  return matches;
}
function elementAttributeInternal(tNode, lView, name2, value, sanitizer, namespace) {
  if (ngDevMode) {
    assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
    validateAgainstEventAttributes(name2);
    assertTNodeType(tNode, 2, `Attempted to set attribute \`${name2}\` on a container node. Host bindings are not valid on ng-container or ng-template.`);
  }
  const element = getNativeByTNode(tNode, lView);
  setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name2, value, sanitizer);
}
function setElementAttribute(renderer, element, namespace, tagName, name2, value, sanitizer) {
  if (value == null) {
    renderer.removeAttribute(element, name2, namespace);
  } else {
    const strValue = sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || "", name2);
    renderer.setAttribute(element, name2, strValue, namespace);
  }
}
function setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {
  const initialInputs = initialInputData[directiveIndex];
  if (initialInputs !== null) {
    for (let i = 0; i < initialInputs.length; i += 2) {
      const lookupName = initialInputs[i];
      const value = initialInputs[i + 1];
      writeToDirectiveInput(def, instance, lookupName, value);
      if (ngDevMode) {
        setNgReflectProperty(lView, tNode, def.inputs[lookupName][0], value);
      }
    }
  }
}
function elementLikeStartShared(tNode, lView, index, name2, locateOrCreateNativeNode) {
  const adjustedIndex = HEADER_OFFSET + index;
  const tView = lView[TVIEW];
  const native = locateOrCreateNativeNode(tView, lView, tNode, name2, index);
  lView[adjustedIndex] = native;
  setCurrentTNode(tNode, true);
  const isElement = tNode.type === 2;
  if (isElement) {
    setupStaticAttributes(lView[RENDERER], native, tNode);
    if (getElementDepthCount() === 0 || isDirectiveHost(tNode)) {
      attachPatchData(native, lView);
    }
    increaseElementDepthCount();
  } else {
    attachPatchData(native, lView);
  }
  if (wasLastNodeCreated() && (!isElement || !isDetachedByI18n(tNode))) {
    appendChild(tView, lView, native, tNode);
  }
  return tNode;
}
function elementLikeEndShared(tNode) {
  let currentTNode = tNode;
  if (isCurrentTNodeParent()) {
    setCurrentTNodeAsNotParent();
  } else {
    ngDevMode && assertHasParent(getCurrentTNode());
    currentTNode = currentTNode.parent;
    setCurrentTNode(currentTNode, false);
  }
  return currentTNode;
}
function storePropertyBindingMetadata(tData, tNode, propertyName2, bindingIndex, ...interpolationParts) {
  if (tData[bindingIndex] === null) {
    if (!tNode.inputs?.[propertyName2] && !tNode.hostDirectiveInputs?.[propertyName2]) {
      const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);
      propBindingIdxs.push(bindingIndex);
      let bindingMetadata = propertyName2;
      if (interpolationParts.length > 0) {
        bindingMetadata += INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);
      }
      tData[bindingIndex] = bindingMetadata;
    }
  }
}
function loadComponentRenderer(currentDef, tNode, lView) {
  if (currentDef === null || isComponentDef(currentDef)) {
    lView = unwrapLView(lView[tNode.index]);
  }
  return lView[RENDERER];
}
function handleUncaughtError(lView, error) {
  const injector = lView[INJECTOR];
  if (!injector) {
    return;
  }
  const errorHandler2 = injector.get(INTERNAL_APPLICATION_ERROR_HANDLER, null);
  errorHandler2?.(error);
}
function setAllInputsForProperty(tNode, tView, lView, publicName, value) {
  const inputs = tNode.inputs?.[publicName];
  const hostDirectiveInputs = tNode.hostDirectiveInputs?.[publicName];
  let hasMatch = false;
  if (hostDirectiveInputs) {
    for (let i = 0; i < hostDirectiveInputs.length; i += 2) {
      const index = hostDirectiveInputs[i];
      ngDevMode && assertIndexInRange(lView, index);
      const publicName2 = hostDirectiveInputs[i + 1];
      const def = tView.data[index];
      writeToDirectiveInput(def, lView[index], publicName2, value);
      hasMatch = true;
    }
  }
  if (inputs) {
    for (const index of inputs) {
      ngDevMode && assertIndexInRange(lView, index);
      const instance = lView[index];
      const def = tView.data[index];
      writeToDirectiveInput(def, instance, publicName, value);
      hasMatch = true;
    }
  }
  return hasMatch;
}
function renderComponent(hostLView, componentHostIdx) {
  ngDevMode && assertEqual(isCreationMode(hostLView), true, "Should be run in creation mode");
  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
  const componentTView = componentView[TVIEW];
  syncViewWithBlueprint(componentTView, componentView);
  const hostRNode = componentView[HOST];
  if (hostRNode !== null && componentView[HYDRATION] === null) {
    componentView[HYDRATION] = retrieveHydrationInfo(hostRNode, componentView[INJECTOR]);
  }
  profiler(
    18
    /* ProfilerEvent.ComponentStart */
  );
  renderView(componentTView, componentView, componentView[CONTEXT]);
  profiler(19, componentView[CONTEXT]);
}
function syncViewWithBlueprint(tView, lView) {
  for (let i = lView.length; i < tView.blueprint.length; i++) {
    lView.push(tView.blueprint[i]);
  }
}
function renderView(tView, lView, context2) {
  ngDevMode && assertEqual(isCreationMode(lView), true, "Should be run in creation mode");
  ngDevMode && assertNotReactive(renderView.name);
  enterView(lView);
  try {
    const viewQuery = tView.viewQuery;
    if (viewQuery !== null) {
      executeViewQueryFn(1, viewQuery, context2);
    }
    const templateFn = tView.template;
    if (templateFn !== null) {
      executeTemplate(tView, lView, templateFn, 1, context2);
    }
    if (tView.firstCreatePass) {
      tView.firstCreatePass = false;
    }
    lView[QUERIES]?.finishViewCreation(tView);
    if (tView.staticContentQueries) {
      refreshContentQueries(tView, lView);
    }
    if (tView.staticViewQueries) {
      executeViewQueryFn(2, tView.viewQuery, context2);
    }
    const components = tView.components;
    if (components !== null) {
      renderChildComponents(lView, components);
    }
  } catch (error) {
    if (tView.firstCreatePass) {
      tView.incompleteFirstPass = true;
      tView.firstCreatePass = false;
    }
    throw error;
  } finally {
    lView[FLAGS] &= ~4;
    leaveView();
  }
}
function renderChildComponents(hostLView, components) {
  for (let i = 0; i < components.length; i++) {
    renderComponent(hostLView, components[i]);
  }
}
function createAndRenderEmbeddedLView(declarationLView, templateTNode, context2, options) {
  const prevConsumer = setActiveConsumer(null);
  try {
    const embeddedTView = templateTNode.tView;
    ngDevMode && assertDefined(embeddedTView, "TView must be defined for a template node.");
    ngDevMode && assertTNodeForLView(templateTNode, declarationLView);
    const isSignalView = declarationLView[FLAGS] & 4096;
    const viewFlags = isSignalView ? 4096 : 16;
    const embeddedLView = createLView(declarationLView, embeddedTView, context2, viewFlags, null, templateTNode, null, null, options?.injector ?? null, options?.embeddedViewInjector ?? null, options?.dehydratedView ?? null);
    const declarationLContainer = declarationLView[templateTNode.index];
    ngDevMode && assertLContainer(declarationLContainer);
    embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;
    const declarationViewLQueries = declarationLView[QUERIES];
    if (declarationViewLQueries !== null) {
      embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);
    }
    renderView(embeddedTView, embeddedLView, context2);
    return embeddedLView;
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function shouldAddViewToDom(tNode, dehydratedView) {
  return !dehydratedView || dehydratedView.firstChild === null || hasInSkipHydrationBlockFlag(tNode);
}
function collectNativeNodes(tView, lView, tNode, result, isProjection = false) {
  while (tNode !== null) {
    if (tNode.type === 128) {
      tNode = isProjection ? tNode.projectionNext : tNode.next;
      continue;
    }
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 16 | 32
      /* TNodeType.Icu */
    );
    const lNode = lView[tNode.index];
    if (lNode !== null) {
      result.push(unwrapRNode(lNode));
    }
    if (isLContainer(lNode)) {
      collectNativeNodesInLContainer(lNode, result);
    }
    const tNodeType = tNode.type;
    if (tNodeType & 8) {
      collectNativeNodes(tView, lView, tNode.child, result);
    } else if (tNodeType & 32) {
      const nextRNode = icuContainerIterate(tNode, lView);
      let rNode;
      while (rNode = nextRNode()) {
        result.push(rNode);
      }
    } else if (tNodeType & 16) {
      const nodesInSlot = getProjectionNodes(lView, tNode);
      if (Array.isArray(nodesInSlot)) {
        result.push(...nodesInSlot);
      } else {
        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
        ngDevMode && assertParentView(parentView);
        collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);
      }
    }
    tNode = isProjection ? tNode.projectionNext : tNode.next;
  }
  return result;
}
function collectNativeNodesInLContainer(lContainer, result) {
  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    const lViewInAContainer = lContainer[i];
    const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;
    if (lViewFirstChildTNode !== null) {
      collectNativeNodes(lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);
    }
  }
  if (lContainer[NATIVE] !== lContainer[HOST]) {
    result.push(lContainer[NATIVE]);
  }
}
function addAfterRenderSequencesForView(lView) {
  if (lView[AFTER_RENDER_SEQUENCES_TO_ADD] !== null) {
    for (const sequence of lView[AFTER_RENDER_SEQUENCES_TO_ADD]) {
      sequence.impl.addSequence(sequence);
    }
    lView[AFTER_RENDER_SEQUENCES_TO_ADD].length = 0;
  }
}
function getOrBorrowReactiveLViewConsumer(lView) {
  return lView[REACTIVE_TEMPLATE_CONSUMER] ?? borrowReactiveLViewConsumer(lView);
}
function borrowReactiveLViewConsumer(lView) {
  const consumer = freeConsumers.pop() ?? Object.create(REACTIVE_LVIEW_CONSUMER_NODE);
  consumer.lView = lView;
  return consumer;
}
function maybeReturnReactiveLViewConsumer(consumer) {
  if (consumer.lView[REACTIVE_TEMPLATE_CONSUMER] === consumer) {
    return;
  }
  consumer.lView = null;
  freeConsumers.push(consumer);
}
function getOrCreateTemporaryConsumer(lView) {
  const consumer = lView[REACTIVE_TEMPLATE_CONSUMER] ?? Object.create(TEMPORARY_CONSUMER_NODE);
  consumer.lView = lView;
  return consumer;
}
function viewShouldHaveReactiveConsumer(tView) {
  return tView.type !== 2;
}
function isReactiveLViewConsumer(node) {
  return node.kind === "template";
}
function runEffectsInView(view) {
  if (view[EFFECTS] === null) {
    return;
  }
  let tryFlushEffects = true;
  while (tryFlushEffects) {
    let foundDirtyEffect = false;
    for (const effect2 of view[EFFECTS]) {
      if (!effect2.dirty) {
        continue;
      }
      foundDirtyEffect = true;
      if (effect2.zone === null || Zone.current === effect2.zone) {
        effect2.run();
      } else {
        effect2.zone.run(() => effect2.run());
      }
    }
    tryFlushEffects = foundDirtyEffect && !!(view[FLAGS] & 8192);
  }
}
function detectChangesInternal(lView, mode = 0) {
  const environment = lView[ENVIRONMENT];
  const rendererFactory = environment.rendererFactory;
  const checkNoChangesMode = !!ngDevMode && isInCheckNoChangesMode();
  if (!checkNoChangesMode) {
    rendererFactory.begin?.();
  }
  try {
    detectChangesInViewWhileDirty(lView, mode);
  } finally {
    if (!checkNoChangesMode) {
      rendererFactory.end?.();
    }
  }
}
function detectChangesInViewWhileDirty(lView, mode) {
  const lastIsRefreshingViewsValue = isRefreshingViews();
  try {
    setIsRefreshingViews(true);
    detectChangesInView(lView, mode);
    if (ngDevMode && isExhaustiveCheckNoChanges()) {
      return;
    }
    let retries = 0;
    while (requiresRefreshOrTraversal(lView)) {
      if (retries === MAXIMUM_REFRESH_RERUNS$1) {
        throw new RuntimeError(103, ngDevMode && "Infinite change detection while trying to refresh views. There may be components which each cause the other to require a refresh, causing an infinite loop.");
      }
      retries++;
      detectChangesInView(
        lView,
        1
        /* ChangeDetectionMode.Targeted */
      );
    }
  } finally {
    setIsRefreshingViews(lastIsRefreshingViewsValue);
  }
}
function checkNoChangesInternal(lView, exhaustive) {
  setIsInCheckNoChangesMode(exhaustive ? CheckNoChangesMode.Exhaustive : CheckNoChangesMode.OnlyDirtyViews);
  try {
    detectChangesInternal(lView);
  } finally {
    setIsInCheckNoChangesMode(CheckNoChangesMode.Off);
  }
}
function refreshView(tView, lView, templateFn, context2) {
  ngDevMode && assertEqual(isCreationMode(lView), false, "Should be run in update mode");
  if (isDestroyed(lView))
    return;
  const flags = lView[FLAGS];
  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();
  const isInExhaustiveCheckNoChangesPass = ngDevMode && isExhaustiveCheckNoChanges();
  enterView(lView);
  let returnConsumerToPool = true;
  let prevConsumer = null;
  let currentConsumer = null;
  if (!isInCheckNoChangesPass) {
    if (viewShouldHaveReactiveConsumer(tView)) {
      currentConsumer = getOrBorrowReactiveLViewConsumer(lView);
      prevConsumer = consumerBeforeComputation(currentConsumer);
    } else if (getActiveConsumer() === null) {
      returnConsumerToPool = false;
      currentConsumer = getOrCreateTemporaryConsumer(lView);
      prevConsumer = consumerBeforeComputation(currentConsumer);
    } else if (lView[REACTIVE_TEMPLATE_CONSUMER]) {
      consumerDestroy(lView[REACTIVE_TEMPLATE_CONSUMER]);
      lView[REACTIVE_TEMPLATE_CONSUMER] = null;
    }
  }
  try {
    resetPreOrderHookFlags(lView);
    setBindingIndex(tView.bindingStartIndex);
    if (templateFn !== null) {
      executeTemplate(tView, lView, templateFn, 2, context2);
    }
    const hooksInitPhaseCompleted = (flags & 3) === 3;
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const preOrderCheckHooks = tView.preOrderCheckHooks;
        if (preOrderCheckHooks !== null) {
          executeCheckHooks(lView, preOrderCheckHooks, null);
        }
      } else {
        const preOrderHooks = tView.preOrderHooks;
        if (preOrderHooks !== null) {
          executeInitAndCheckHooks(lView, preOrderHooks, 0, null);
        }
        incrementInitPhaseFlags(
          lView,
          0
          /* InitPhaseState.OnInitHooksToBeRun */
        );
      }
    }
    if (!isInExhaustiveCheckNoChangesPass) {
      markTransplantedViewsForRefresh(lView);
    }
    runEffectsInView(lView);
    detectChangesInEmbeddedViews(
      lView,
      0
      /* ChangeDetectionMode.Global */
    );
    if (tView.contentQueries !== null) {
      refreshContentQueries(tView, lView);
    }
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const contentCheckHooks = tView.contentCheckHooks;
        if (contentCheckHooks !== null) {
          executeCheckHooks(lView, contentCheckHooks);
        }
      } else {
        const contentHooks = tView.contentHooks;
        if (contentHooks !== null) {
          executeInitAndCheckHooks(
            lView,
            contentHooks,
            1
            /* InitPhaseState.AfterContentInitHooksToBeRun */
          );
        }
        incrementInitPhaseFlags(
          lView,
          1
          /* InitPhaseState.AfterContentInitHooksToBeRun */
        );
      }
    }
    processHostBindingOpCodes(tView, lView);
    const components = tView.components;
    if (components !== null) {
      detectChangesInChildComponents(
        lView,
        components,
        0
        /* ChangeDetectionMode.Global */
      );
    }
    const viewQuery = tView.viewQuery;
    if (viewQuery !== null) {
      executeViewQueryFn(2, viewQuery, context2);
    }
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const viewCheckHooks = tView.viewCheckHooks;
        if (viewCheckHooks !== null) {
          executeCheckHooks(lView, viewCheckHooks);
        }
      } else {
        const viewHooks = tView.viewHooks;
        if (viewHooks !== null) {
          executeInitAndCheckHooks(
            lView,
            viewHooks,
            2
            /* InitPhaseState.AfterViewInitHooksToBeRun */
          );
        }
        incrementInitPhaseFlags(
          lView,
          2
          /* InitPhaseState.AfterViewInitHooksToBeRun */
        );
      }
    }
    if (tView.firstUpdatePass === true) {
      tView.firstUpdatePass = false;
    }
    if (lView[EFFECTS_TO_SCHEDULE]) {
      for (const notifyEffect of lView[EFFECTS_TO_SCHEDULE]) {
        notifyEffect();
      }
      lView[EFFECTS_TO_SCHEDULE] = null;
    }
    if (!isInCheckNoChangesPass) {
      addAfterRenderSequencesForView(lView);
      lView[FLAGS] &= ~(64 | 8);
    }
  } catch (e) {
    if (!isInCheckNoChangesPass) {
      markAncestorsForTraversal(lView);
    }
    throw e;
  } finally {
    if (currentConsumer !== null) {
      consumerAfterComputation(currentConsumer, prevConsumer);
      if (returnConsumerToPool) {
        maybeReturnReactiveLViewConsumer(currentConsumer);
      }
    }
    leaveView();
  }
}
function detectChangesInEmbeddedViews(lView, mode) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
      const embeddedLView = lContainer[i];
      detectChangesInViewIfAttached(embeddedLView, mode);
    }
  }
}
function markTransplantedViewsForRefresh(lView) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    if (!(lContainer[FLAGS] & 2))
      continue;
    const movedViews = lContainer[MOVED_VIEWS];
    ngDevMode && assertDefined(movedViews, "Transplanted View flags set but missing MOVED_VIEWS");
    for (let i = 0; i < movedViews.length; i++) {
      const movedLView = movedViews[i];
      markViewForRefresh(movedLView);
    }
  }
}
function detectChangesInComponent(hostLView, componentHostIdx, mode) {
  ngDevMode && assertEqual(isCreationMode(hostLView), false, "Should be run in update mode");
  profiler(
    18
    /* ProfilerEvent.ComponentStart */
  );
  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
  detectChangesInViewIfAttached(componentView, mode);
  profiler(19, componentView[CONTEXT]);
}
function detectChangesInViewIfAttached(lView, mode) {
  if (!viewAttachedToChangeDetector(lView)) {
    return;
  }
  detectChangesInView(lView, mode);
}
function detectChangesInView(lView, mode) {
  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();
  const tView = lView[TVIEW];
  const flags = lView[FLAGS];
  const consumer = lView[REACTIVE_TEMPLATE_CONSUMER];
  let shouldRefreshView = !!(mode === 0 && flags & 16);
  shouldRefreshView ||= !!(flags & 64 && mode === 0 && !isInCheckNoChangesPass);
  shouldRefreshView ||= !!(flags & 1024);
  shouldRefreshView ||= !!(consumer?.dirty && consumerPollProducersForChange(consumer));
  shouldRefreshView ||= !!(ngDevMode && isExhaustiveCheckNoChanges());
  if (consumer) {
    consumer.dirty = false;
  }
  lView[FLAGS] &= ~(8192 | 1024);
  if (shouldRefreshView) {
    refreshView(tView, lView, tView.template, lView[CONTEXT]);
  } else if (flags & 8192) {
    const prevConsumer = setActiveConsumer(null);
    try {
      if (!isInCheckNoChangesPass) {
        runEffectsInView(lView);
      }
      detectChangesInEmbeddedViews(
        lView,
        1
        /* ChangeDetectionMode.Targeted */
      );
      const components = tView.components;
      if (components !== null) {
        detectChangesInChildComponents(
          lView,
          components,
          1
          /* ChangeDetectionMode.Targeted */
        );
      }
      if (!isInCheckNoChangesPass) {
        addAfterRenderSequencesForView(lView);
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function detectChangesInChildComponents(hostLView, components, mode) {
  for (let i = 0; i < components.length; i++) {
    detectChangesInComponent(hostLView, components[i], mode);
  }
}
function processHostBindingOpCodes(tView, lView) {
  const hostBindingOpCodes = tView.hostBindingOpCodes;
  if (hostBindingOpCodes === null)
    return;
  try {
    for (let i = 0; i < hostBindingOpCodes.length; i++) {
      const opCode = hostBindingOpCodes[i];
      if (opCode < 0) {
        setSelectedIndex(~opCode);
      } else {
        const directiveIdx = opCode;
        const bindingRootIndx = hostBindingOpCodes[++i];
        const hostBindingFn = hostBindingOpCodes[++i];
        setBindingRootForHostBindings(bindingRootIndx, directiveIdx);
        const context2 = lView[directiveIdx];
        profiler(24, context2);
        hostBindingFn(2, context2);
        profiler(25, context2);
      }
    }
  } finally {
    setSelectedIndex(-1);
  }
}
function markViewDirty(lView, source) {
  const dirtyBitsToUse = isRefreshingViews() ? (
    // When we are actively refreshing views, we only use the `Dirty` bit to mark a view
    64
  ) : (
    // When we are not actively refreshing a view tree, it is absolutely
    // valid to update state and mark views dirty. We use the `RefreshView` flag in this
    // case to allow synchronously rerunning change detection. This applies today to
    // afterRender hooks as well as animation listeners which execute after detecting
    // changes in a view when the render factory flushes.
    1024 | 64
  );
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(source);
  while (lView) {
    lView[FLAGS] |= dirtyBitsToUse;
    const parent = getLViewParent(lView);
    if (isRootView(lView) && !parent) {
      return lView;
    }
    lView = parent;
  }
  return null;
}
function createLContainer(hostNative, currentView, native, tNode) {
  ngDevMode && assertLView(currentView);
  const lContainer = [
    hostNative,
    // host native
    true,
    // Boolean `true` in this position signifies that this is an `LContainer`
    0,
    // flags
    currentView,
    // parent
    null,
    // next
    tNode,
    // t_host
    null,
    // dehydrated views
    native,
    // native,
    null,
    // view refs
    null
    // moved views
  ];
  ngDevMode && assertEqual(lContainer.length, CONTAINER_HEADER_OFFSET, "Should allocate correct number of slots for LContainer header.");
  return lContainer;
}
function getLViewFromLContainer(lContainer, index) {
  const adjustedIndex = CONTAINER_HEADER_OFFSET + index;
  if (adjustedIndex < lContainer.length) {
    const lView = lContainer[adjustedIndex];
    ngDevMode && assertLView(lView);
    return lView;
  }
  return void 0;
}
function addLViewToLContainer(lContainer, lView, index, addToDOM = true) {
  const tView = lView[TVIEW];
  insertView(tView, lView, lContainer, index);
  if (addToDOM) {
    const beforeNode = getBeforeNodeForView(index, lContainer);
    const renderer = lView[RENDERER];
    const parentRNode = renderer.parentNode(lContainer[NATIVE]);
    if (parentRNode !== null) {
      addViewToDOM(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);
    }
  }
  const hydrationInfo = lView[HYDRATION];
  if (hydrationInfo !== null && hydrationInfo.firstChild !== null) {
    hydrationInfo.firstChild = null;
  }
}
function removeLViewFromLContainer(lContainer, index) {
  const lView = detachView(lContainer, index);
  if (lView !== void 0) {
    destroyLView(lView[TVIEW], lView);
  }
  return lView;
}
function detachView(lContainer, removeIndex) {
  if (lContainer.length <= CONTAINER_HEADER_OFFSET)
    return;
  const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;
  const viewToDetach = lContainer[indexInContainer];
  if (viewToDetach) {
    const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];
    if (declarationLContainer !== null && declarationLContainer !== lContainer) {
      detachMovedView(declarationLContainer, viewToDetach);
    }
    if (removeIndex > 0) {
      lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];
    }
    const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);
    removeViewFromDOM(viewToDetach[TVIEW], viewToDetach);
    const lQueries = removedLView[QUERIES];
    if (lQueries !== null) {
      lQueries.detachView(removedLView[TVIEW]);
    }
    viewToDetach[PARENT] = null;
    viewToDetach[NEXT] = null;
    viewToDetach[FLAGS] &= ~128;
  }
  return viewToDetach;
}
function insertView(tView, lView, lContainer, index) {
  ngDevMode && assertLView(lView);
  ngDevMode && assertLContainer(lContainer);
  const indexInContainer = CONTAINER_HEADER_OFFSET + index;
  const containerLength = lContainer.length;
  if (index > 0) {
    lContainer[indexInContainer - 1][NEXT] = lView;
  }
  if (index < containerLength - CONTAINER_HEADER_OFFSET) {
    lView[NEXT] = lContainer[indexInContainer];
    addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);
  } else {
    lContainer.push(lView);
    lView[NEXT] = null;
  }
  lView[PARENT] = lContainer;
  const declarationLContainer = lView[DECLARATION_LCONTAINER];
  if (declarationLContainer !== null && lContainer !== declarationLContainer) {
    trackMovedView(declarationLContainer, lView);
  }
  const lQueries = lView[QUERIES];
  if (lQueries !== null) {
    lQueries.insertView(tView);
  }
  updateAncestorTraversalFlagsOnAttach(lView);
  lView[FLAGS] |= 128;
}
function trackMovedView(declarationContainer, lView) {
  ngDevMode && assertDefined(lView, "LView required");
  ngDevMode && assertLContainer(declarationContainer);
  const movedViews = declarationContainer[MOVED_VIEWS];
  const parent = lView[PARENT];
  ngDevMode && assertDefined(parent, "missing parent");
  if (isLView(parent)) {
    declarationContainer[FLAGS] |= 2;
  } else {
    const insertedComponentLView = parent[PARENT][DECLARATION_COMPONENT_VIEW];
    ngDevMode && assertDefined(insertedComponentLView, "Missing insertedComponentLView");
    const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];
    ngDevMode && assertDefined(declaredComponentLView, "Missing declaredComponentLView");
    if (declaredComponentLView !== insertedComponentLView) {
      declarationContainer[FLAGS] |= 2;
    }
  }
  if (movedViews === null) {
    declarationContainer[MOVED_VIEWS] = [lView];
  } else {
    movedViews.push(lView);
  }
}
function injectTemplateRef() {
  return createTemplateRef(getCurrentTNode(), getLView());
}
function createTemplateRef(hostTNode, hostLView) {
  if (hostTNode.type & 4) {
    ngDevMode && assertDefined(hostTNode.tView, "TView must be allocated");
    return new TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));
  }
  return null;
}
function getFriendlyStringFromTNodeType(tNodeType) {
  switch (tNodeType) {
    case 4:
      return "view container";
    case 2:
      return "element";
    case 8:
      return "ng-container";
    case 32:
      return "icu";
    case 64:
      return "i18n";
    case 16:
      return "projection";
    case 1:
      return "text";
    case 128:
      return "@let";
    default:
      return "<unknown>";
  }
}
function validateSiblingNodeExists(node) {
  validateNodeExists(node);
  if (!node.nextSibling) {
    const header = "During hydration Angular expected more sibling nodes to be present.\n\n";
    const actual = `Actual DOM is:

${describeDomFromNode(node)}

`;
    const footer = getHydrationErrorFooter();
    const message = header + actual + footer;
    markRNodeAsHavingHydrationMismatch(node, "", actual);
    throw new RuntimeError(-501, message);
  }
}
function validateNodeExists(node, lView = null, tNode = null) {
  if (!node) {
    const header = "During hydration, Angular expected an element to be present at this location.\n\n";
    let expected = "";
    let footer = "";
    if (lView !== null && tNode !== null) {
      expected = describeExpectedDom(lView, tNode, false);
      footer = getHydrationErrorFooter();
      markRNodeAsHavingHydrationMismatch(unwrapRNode(lView[HOST]), expected, "");
    }
    throw new RuntimeError(-502, `${header}${expected}

${footer}`);
  }
}
function stringifyTNodeAttrs(tNode) {
  const results = [];
  if (tNode.attrs) {
    for (let i = 0; i < tNode.attrs.length; ) {
      const attrName = tNode.attrs[i++];
      if (typeof attrName == "number") {
        break;
      }
      const attrValue = tNode.attrs[i++];
      results.push(`${attrName}="${shorten(attrValue)}"`);
    }
  }
  return results.join(" ");
}
function stringifyRNodeAttrs(rNode) {
  const results = [];
  for (let i = 0; i < rNode.attributes.length; i++) {
    const attr = rNode.attributes[i];
    if (internalAttrs.has(attr.name))
      continue;
    results.push(`${attr.name}="${shorten(attr.value)}"`);
  }
  return results.join(" ");
}
function describeTNode(tNode, innerContent = "\u2026") {
  switch (tNode.type) {
    case 1:
      const content2 = tNode.value ? `(${tNode.value})` : "";
      return `#text${content2}`;
    case 2:
      const attrs = stringifyTNodeAttrs(tNode);
      const tag = tNode.value.toLowerCase();
      return `<${tag}${attrs ? " " + attrs : ""}>${innerContent}</${tag}>`;
    case 8:
      return "<!-- ng-container -->";
    case 4:
      return "<!-- container -->";
    default:
      const typeAsString = getFriendlyStringFromTNodeType(tNode.type);
      return `#node(${typeAsString})`;
  }
}
function describeRNode(rNode, innerContent = "\u2026") {
  const node = rNode;
  switch (node.nodeType) {
    case Node.ELEMENT_NODE:
      const tag = node.tagName.toLowerCase();
      const attrs = stringifyRNodeAttrs(node);
      return `<${tag}${attrs ? " " + attrs : ""}>${innerContent}</${tag}>`;
    case Node.TEXT_NODE:
      const content2 = node.textContent ? shorten(node.textContent) : "";
      return `#text${content2 ? `(${content2})` : ""}`;
    case Node.COMMENT_NODE:
      return `<!-- ${shorten(node.textContent ?? "")} -->`;
    default:
      return `#node(${node.nodeType})`;
  }
}
function describeExpectedDom(lView, tNode, isViewContainerAnchor) {
  const spacer = "  ";
  let content2 = "";
  if (tNode.prev) {
    content2 += spacer + "\u2026\n";
    content2 += spacer + describeTNode(tNode.prev) + "\n";
  } else if (tNode.type && tNode.type & 12) {
    content2 += spacer + "\u2026\n";
  }
  if (isViewContainerAnchor) {
    content2 += spacer + describeTNode(tNode) + "\n";
    content2 += spacer + `<!-- container -->  ${AT_THIS_LOCATION}
`;
  } else {
    content2 += spacer + describeTNode(tNode) + `  ${AT_THIS_LOCATION}
`;
  }
  content2 += spacer + "\u2026\n";
  const parentRNode = tNode.type ? getParentRElement(lView[TVIEW], tNode, lView) : null;
  if (parentRNode) {
    content2 = describeRNode(parentRNode, "\n" + content2);
  }
  return content2;
}
function describeDomFromNode(node) {
  const spacer = "  ";
  let content2 = "";
  const currentNode = node;
  if (currentNode.previousSibling) {
    content2 += spacer + "\u2026\n";
    content2 += spacer + describeRNode(currentNode.previousSibling) + "\n";
  }
  content2 += spacer + describeRNode(currentNode) + `  ${AT_THIS_LOCATION}
`;
  if (node.nextSibling) {
    content2 += spacer + "\u2026\n";
  }
  if (node.parentNode) {
    content2 = describeRNode(currentNode.parentNode, "\n" + content2);
  }
  return content2;
}
function getHydrationErrorFooter(componentClassName) {
  const componentInfo = componentClassName ? `the "${componentClassName}"` : "corresponding";
  return `To fix this problem:
  * check ${componentInfo} component for hydration-related issues
  * check to see if your template has valid HTML structure
  * or skip hydration by adding the \`ngSkipHydration\` attribute to its host node in a template

`;
}
function stripNewlines(input2) {
  return input2.replace(/\s+/gm, "");
}
function shorten(input2, maxLength = 50) {
  if (!input2) {
    return "";
  }
  input2 = stripNewlines(input2);
  return input2.length > maxLength ? `${input2.substring(0, maxLength - 1)}\u2026` : input2;
}
function getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {
  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;
  const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;
  if (insertBeforeIndex === null) {
    return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);
  } else {
    ngDevMode && assertIndexInRange(lView, insertBeforeIndex);
    return unwrapRNode(lView[insertBeforeIndex]);
  }
}
function processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {
  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;
  if (Array.isArray(tNodeInsertBeforeIndex)) {
    ngDevMode && assertDomNode(childRNode);
    let i18nParent = childRNode;
    let anchorRNode = null;
    if (!(childTNode.type & 3)) {
      anchorRNode = i18nParent;
      i18nParent = parentRElement;
    }
    if (i18nParent !== null && childTNode.componentOffset === -1) {
      for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {
        const i18nChild = lView[tNodeInsertBeforeIndex[i]];
        nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);
      }
    }
  }
}
function getOrCreateTNode(tView, index, type, name2, attrs) {
  ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in
  // `view_engine_compatibility` for additional context.
  assertGreaterThanOrEqual(index, HEADER_OFFSET, "TNodes can't be in the LView header.");
  ngDevMode && assertPureTNodeType(type);
  let tNode = tView.data[index];
  if (tNode === null) {
    tNode = createTNodeAtIndex(tView, index, type, name2, attrs);
    if (isInI18nBlock()) {
      tNode.flags |= 32;
    }
  } else if (tNode.type & 64) {
    tNode.type = type;
    tNode.value = name2;
    tNode.attrs = attrs;
    const parent = getCurrentParentTNode();
    tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;
    ngDevMode && assertTNodeForTView(tNode, tView);
    ngDevMode && assertEqual(index, tNode.index, "Expecting same index");
  }
  setCurrentTNode(tNode, true);
  return tNode;
}
function createTNodeAtIndex(tView, index, type, name2, attrs) {
  const currentTNode = getCurrentTNodePlaceholderOk();
  const isParent2 = isCurrentTNodeParent();
  const parent = isParent2 ? currentTNode : currentTNode && currentTNode.parent;
  const tNode = tView.data[index] = createTNode(tView, parent, type, index, name2, attrs);
  linkTNodeInTView(tView, tNode, currentTNode, isParent2);
  return tNode;
}
function linkTNodeInTView(tView, tNode, currentTNode, isParent2) {
  if (tView.firstChild === null) {
    tView.firstChild = tNode;
  }
  if (currentTNode !== null) {
    if (isParent2) {
      if (currentTNode.child == null && tNode.parent !== null) {
        currentTNode.child = tNode;
      }
    } else {
      if (currentTNode.next === null) {
        currentTNode.next = tNode;
        tNode.prev = currentTNode;
      }
    }
  }
}
function createTNode(tView, tParent, type, index, value, attrs) {
  ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in
  // `view_engine_compatibility` for additional context.
  assertGreaterThanOrEqual(index, HEADER_OFFSET, "TNodes can't be in the LView header.");
  ngDevMode && assertNotSame(attrs, void 0, "'undefined' is not valid value for 'attrs'");
  ngDevMode && tParent && assertTNodeForTView(tParent, tView);
  let injectorIndex = tParent ? tParent.injectorIndex : -1;
  let flags = 0;
  if (isInSkipHydrationBlock()) {
    flags |= 128;
  }
  const tNode = {
    type,
    index,
    insertBeforeIndex: null,
    injectorIndex,
    directiveStart: -1,
    directiveEnd: -1,
    directiveStylingLast: -1,
    componentOffset: -1,
    propertyBindings: null,
    flags,
    providerIndexes: 0,
    value,
    attrs,
    mergedAttrs: null,
    localNames: null,
    initialInputs: null,
    inputs: null,
    hostDirectiveInputs: null,
    outputs: null,
    hostDirectiveOutputs: null,
    directiveToIndex: null,
    tView: null,
    next: null,
    prev: null,
    projectionNext: null,
    child: null,
    parent: tParent,
    projection: null,
    styles: null,
    stylesWithoutHost: null,
    residualStyles: void 0,
    classes: null,
    classesWithoutHost: null,
    residualClasses: void 0,
    classBindings: 0,
    styleBindings: 0
  };
  if (ngDevMode) {
    Object.seal(tNode);
  }
  return tNode;
}
function addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {
  ngDevMode && assertEqual(newTNode.insertBeforeIndex, null, "We expect that insertBeforeIndex is not set");
  previousTNodes.push(newTNode);
  if (previousTNodes.length > 1) {
    for (let i = previousTNodes.length - 2; i >= 0; i--) {
      const existingTNode = previousTNodes[i];
      if (!isI18nText(existingTNode)) {
        if (isNewTNodeCreatedBefore(existingTNode, newTNode) && getInsertBeforeIndex(existingTNode) === null) {
          setInsertBeforeIndex(existingTNode, newTNode.index);
        }
      }
    }
  }
}
function isI18nText(tNode) {
  return !(tNode.type & 64);
}
function isNewTNodeCreatedBefore(existingTNode, newTNode) {
  return isI18nText(newTNode) || existingTNode.index > newTNode.index;
}
function getInsertBeforeIndex(tNode) {
  const index = tNode.insertBeforeIndex;
  return Array.isArray(index) ? index[0] : index;
}
function setInsertBeforeIndex(tNode, value) {
  const index = tNode.insertBeforeIndex;
  if (Array.isArray(index)) {
    index[0] = value;
  } else {
    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
    tNode.insertBeforeIndex = value;
  }
}
function getTIcu(tView, index) {
  const value = tView.data[index];
  if (value === null || typeof value === "string")
    return null;
  if (ngDevMode && !(value.hasOwnProperty("tView") || value.hasOwnProperty("currentCaseLViewIndex"))) {
    throwError2("We expect to get 'null'|'TIcu'|'TIcuContainer', but got: " + value);
  }
  const tIcu = value.hasOwnProperty("currentCaseLViewIndex") ? value : value.value;
  ngDevMode && assertTIcu(tIcu);
  return tIcu;
}
function setTIcu(tView, index, tIcu) {
  const tNode = tView.data[index];
  ngDevMode && assertEqual(tNode === null || tNode.hasOwnProperty("tView"), true, "We expect to get 'null'|'TIcuContainer'");
  if (tNode === null) {
    tView.data[index] = tIcu;
  } else {
    ngDevMode && assertTNodeType(
      tNode,
      32
      /* TNodeType.Icu */
    );
    tNode.value = tIcu;
  }
}
function setTNodeInsertBeforeIndex(tNode, index) {
  ngDevMode && assertTNode(tNode);
  let insertBeforeIndex = tNode.insertBeforeIndex;
  if (insertBeforeIndex === null) {
    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
    insertBeforeIndex = tNode.insertBeforeIndex = [
      null,
      index
    ];
  } else {
    assertEqual(Array.isArray(insertBeforeIndex), true, "Expecting array here");
    insertBeforeIndex.push(index);
  }
}
function createTNodePlaceholder(tView, previousTNodes, index) {
  const tNode = createTNodeAtIndex(tView, index, 64, null, null);
  addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);
  return tNode;
}
function getCurrentICUCaseIndex(tIcu, lView) {
  const currentCase = lView[tIcu.currentCaseLViewIndex];
  return currentCase === null ? currentCase : currentCase < 0 ? ~currentCase : currentCase;
}
function getParentFromIcuCreateOpCode(mergedCode) {
  return mergedCode >>> 17;
}
function getRefFromIcuCreateOpCode(mergedCode) {
  return (mergedCode & 131070) >>> 1;
}
function getInstructionFromIcuCreateOpCode(mergedCode) {
  return mergedCode & 1;
}
function icuCreateOpCode(opCode, parentIdx, refIdx) {
  ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, "Missing parent index");
  ngDevMode && assertGreaterThan(refIdx, 0, "Missing ref index");
  return opCode | parentIdx << 17 | refIdx << 1;
}
function isRootTemplateMessage(subTemplateIndex) {
  return subTemplateIndex === -1;
}
function enterIcu(state, tIcu, lView) {
  state.index = 0;
  const currentCase = getCurrentICUCaseIndex(tIcu, lView);
  if (currentCase !== null) {
    ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);
    state.removes = tIcu.remove[currentCase];
  } else {
    state.removes = EMPTY_ARRAY;
  }
}
function icuContainerIteratorNext(state) {
  if (state.index < state.removes.length) {
    const removeOpCode = state.removes[state.index++];
    ngDevMode && assertNumber(removeOpCode, "Expecting OpCode number");
    if (removeOpCode > 0) {
      const rNode = state.lView[removeOpCode];
      ngDevMode && assertDomNode(rNode);
      return rNode;
    } else {
      state.stack.push(state.index, state.removes);
      const tIcuIndex = ~removeOpCode;
      const tIcu = state.lView[TVIEW].data[tIcuIndex];
      ngDevMode && assertTIcu(tIcu);
      enterIcu(state, tIcu, state.lView);
      return icuContainerIteratorNext(state);
    }
  } else {
    if (state.stack.length === 0) {
      return null;
    } else {
      state.removes = state.stack.pop();
      state.index = state.stack.pop();
      return icuContainerIteratorNext(state);
    }
  }
}
function loadIcuContainerVisitor() {
  const _state = {
    stack: [],
    index: -1
  };
  function icuContainerIteratorStart(tIcuContainerNode, lView) {
    _state.lView = lView;
    while (_state.stack.length)
      _state.stack.pop();
    ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);
    enterIcu(_state, tIcuContainerNode.value, lView);
    return icuContainerIteratorNext.bind(null, _state);
  }
  return icuContainerIteratorStart;
}
function prepareI18nBlockForHydration(lView, index, parentTNode, subTemplateIndex) {
  _prepareI18nBlockForHydrationImpl(lView, index, parentTNode, subTemplateIndex);
}
function claimDehydratedIcuCase(lView, icuIndex, caseIndex) {
  _claimDehydratedIcuCaseImpl(lView, icuIndex, caseIndex);
}
function cleanupI18nHydrationData(lView) {
  const hydrationInfo = lView[HYDRATION];
  if (hydrationInfo) {
    const { i18nNodes, dehydratedIcuData: dehydratedIcuDataMap } = hydrationInfo;
    if (i18nNodes && dehydratedIcuDataMap) {
      const renderer = lView[RENDERER];
      for (const dehydratedIcuData of dehydratedIcuDataMap.values()) {
        cleanupDehydratedIcuData(renderer, i18nNodes, dehydratedIcuData);
      }
    }
    hydrationInfo.i18nNodes = void 0;
    hydrationInfo.dehydratedIcuData = void 0;
  }
}
function cleanupDehydratedIcuData(renderer, i18nNodes, dehydratedIcuData) {
  for (const node of dehydratedIcuData.node.cases[dehydratedIcuData.case]) {
    const rNode = i18nNodes.get(node.index - HEADER_OFFSET);
    if (rNode) {
      nativeRemoveNode(renderer, rNode, false);
    }
  }
}
function removeDehydratedViews(lContainer) {
  const views = lContainer[DEHYDRATED_VIEWS] ?? [];
  const parentLView = lContainer[PARENT];
  const renderer = parentLView[RENDERER];
  const retainedViews = [];
  for (const view of views) {
    if (view.data[DEFER_BLOCK_ID] !== void 0) {
      retainedViews.push(view);
    } else {
      removeDehydratedView(view, renderer);
      ngDevMode && ngDevMode.dehydratedViewsRemoved++;
    }
  }
  lContainer[DEHYDRATED_VIEWS] = retainedViews;
}
function removeDehydratedViewList(deferBlock) {
  const { lContainer } = deferBlock;
  const dehydratedViews = lContainer[DEHYDRATED_VIEWS];
  if (dehydratedViews === null)
    return;
  const parentLView = lContainer[PARENT];
  const renderer = parentLView[RENDERER];
  for (const view of dehydratedViews) {
    removeDehydratedView(view, renderer);
    ngDevMode && ngDevMode.dehydratedViewsRemoved++;
  }
}
function removeDehydratedView(dehydratedView, renderer) {
  let nodesRemoved = 0;
  let currentRNode = dehydratedView.firstChild;
  if (currentRNode) {
    const numNodes = dehydratedView.data[NUM_ROOT_NODES];
    while (nodesRemoved < numNodes) {
      ngDevMode && validateSiblingNodeExists(currentRNode);
      const nextSibling = currentRNode.nextSibling;
      nativeRemoveNode(renderer, currentRNode, false);
      currentRNode = nextSibling;
      nodesRemoved++;
    }
  }
}
function cleanupLContainer(lContainer) {
  removeDehydratedViews(lContainer);
  const hostLView = lContainer[HOST];
  if (isLView(hostLView)) {
    cleanupLView(hostLView);
  }
  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    cleanupLView(lContainer[i]);
  }
}
function cleanupLView(lView) {
  cleanupI18nHydrationData(lView);
  const tView = lView[TVIEW];
  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    if (isLContainer(lView[i])) {
      const lContainer = lView[i];
      cleanupLContainer(lContainer);
    } else if (isLView(lView[i])) {
      cleanupLView(lView[i]);
    }
  }
}
function cleanupDehydratedViews(appRef) {
  const viewRefs = appRef._views;
  for (const viewRef of viewRefs) {
    const lNode = getLNodeForHydration(viewRef);
    if (lNode !== null && lNode[HOST] !== null) {
      if (isLView(lNode)) {
        cleanupLView(lNode);
      } else {
        cleanupLContainer(lNode);
      }
      ngDevMode && ngDevMode.dehydratedViewsCleanupRuns++;
    }
  }
}
function cleanupHydratedDeferBlocks(deferBlock, hydratedBlocks, registry, appRef) {
  if (deferBlock !== null) {
    registry.cleanup(hydratedBlocks);
    cleanupLContainer(deferBlock.lContainer);
    cleanupDehydratedViews(appRef);
  }
}
function findMatchingDehydratedView(lContainer, template) {
  return _findMatchingDehydratedViewImpl(lContainer, template);
}
function findAndReconcileMatchingDehydratedViews(lContainer, templateTNode, hostLView) {
  return _findAndReconcileMatchingDehydratedViewsImpl(lContainer, templateTNode, hostLView);
}
function injectRenderer2() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);
  return (isLView(nodeAtIndex) ? nodeAtIndex : lView)[RENDERER];
}
function isModuleWithProviders(value) {
  return value.ngModule !== void 0;
}
function isNgModule(value) {
  return !!getNgModuleDef(value);
}
function isPipe(value) {
  return !!getPipeDef(value);
}
function isDirective(value) {
  return !!getDirectiveDef(value);
}
function isComponent(value) {
  return !!getComponentDef(value);
}
function getDependencyTypeForError(type) {
  if (getComponentDef(type))
    return "component";
  if (getDirectiveDef(type))
    return "directive";
  if (getPipeDef(type))
    return "pipe";
  return "type";
}
function verifyStandaloneImport(depType, importingType) {
  if (isForwardRef(depType)) {
    depType = resolveForwardRef(depType);
    if (!depType) {
      throw new Error(`Expected forwardRef function, imported from "${stringifyForError(importingType)}", to return a standalone entity or NgModule but got "${stringifyForError(depType) || depType}".`);
    }
  }
  if (getNgModuleDef(depType) == null) {
    const def = getComponentDef(depType) || getDirectiveDef(depType) || getPipeDef(depType);
    if (def != null) {
      if (!def.standalone) {
        throw new Error(`The "${stringifyForError(depType)}" ${getDependencyTypeForError(depType)}, imported from "${stringifyForError(importingType)}", is not standalone. Did you forget to add the standalone: true flag?`);
      }
    } else {
      if (isModuleWithProviders(depType)) {
        throw new Error(`A module with providers was imported from "${stringifyForError(importingType)}". Modules with providers are not supported in standalone components imports.`);
      } else {
        throw new Error(`The "${stringifyForError(depType)}" type, imported from "${stringifyForError(importingType)}", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`);
      }
    }
  }
}
function addSet(sourceSet, targetSet) {
  for (const m of sourceSet) {
    targetSet.add(m);
  }
}
function computeStaticStyling(tNode, attrs, writeToHost) {
  ngDevMode && assertFirstCreatePass(getTView(), "Expecting to be called in first template pass only");
  let styles = writeToHost ? tNode.styles : null;
  let classes = writeToHost ? tNode.classes : null;
  let mode = 0;
  if (attrs !== null) {
    for (let i = 0; i < attrs.length; i++) {
      const value = attrs[i];
      if (typeof value === "number") {
        mode = value;
      } else if (mode == 1) {
        classes = concatStringsWithSpace(classes, value);
      } else if (mode == 2) {
        const style = value;
        const styleValue = attrs[++i];
        styles = concatStringsWithSpace(styles, style + ": " + styleValue + ";");
      }
    }
  }
  writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;
  writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;
}
function \u0275\u0275directiveInject(token, flags = 0) {
  const lView = getLView();
  if (lView === null) {
    ngDevMode && assertInjectImplementationNotEqual(\u0275\u0275directiveInject);
    return \u0275\u0275inject(token, flags);
  }
  const tNode = getCurrentTNode();
  const value = getOrCreateInjectable(tNode, lView, resolveForwardRef(token), flags);
  ngDevMode && emitInjectEvent(token, value, flags);
  return value;
}
function \u0275\u0275invalidFactory() {
  const msg = ngDevMode ? `This constructor was not compatible with Dependency Injection.` : "invalid";
  throw new Error(msg);
}
function resolveDirectives(tView, lView, tNode, localRefs, directiveMatcher) {
  ngDevMode && assertFirstCreatePass(tView);
  const exportsMap = localRefs === null ? null : { "": -1 };
  const matchedDirectiveDefs = directiveMatcher(tView, tNode);
  if (matchedDirectiveDefs !== null) {
    let directiveDefs = matchedDirectiveDefs;
    let hostDirectiveDefs = null;
    let hostDirectiveRanges = null;
    for (const def of matchedDirectiveDefs) {
      if (def.resolveHostDirectives !== null) {
        [directiveDefs, hostDirectiveDefs, hostDirectiveRanges] = def.resolveHostDirectives(matchedDirectiveDefs);
        break;
      }
    }
    ngDevMode && assertNoDuplicateDirectives(directiveDefs);
    initializeDirectives(tView, lView, tNode, directiveDefs, exportsMap, hostDirectiveDefs, hostDirectiveRanges);
  }
  if (exportsMap !== null && localRefs !== null) {
    cacheMatchingLocalNames(tNode, localRefs, exportsMap);
  }
}
function cacheMatchingLocalNames(tNode, localRefs, exportsMap) {
  const localNames = tNode.localNames = [];
  for (let i = 0; i < localRefs.length; i += 2) {
    const index = exportsMap[localRefs[i + 1]];
    if (index == null)
      throw new RuntimeError(-301, ngDevMode && `Export of name '${localRefs[i + 1]}' not found!`);
    localNames.push(localRefs[i], index);
  }
}
function markAsComponentHost(tView, hostTNode, componentOffset) {
  ngDevMode && assertFirstCreatePass(tView);
  ngDevMode && assertGreaterThan(componentOffset, -1, "componentOffset must be great than -1");
  hostTNode.componentOffset = componentOffset;
  (tView.components ??= []).push(hostTNode.index);
}
function initializeDirectives(tView, lView, tNode, directives, exportsMap, hostDirectiveDefs, hostDirectiveRanges) {
  ngDevMode && assertFirstCreatePass(tView);
  const directivesLength = directives.length;
  let hasSeenComponent = false;
  for (let i = 0; i < directivesLength; i++) {
    const def = directives[i];
    if (!hasSeenComponent && isComponentDef(def)) {
      hasSeenComponent = true;
      markAsComponentHost(tView, tNode, i);
    }
    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, def.type);
  }
  initTNodeFlags(tNode, tView.data.length, directivesLength);
  for (let i = 0; i < directivesLength; i++) {
    const def = directives[i];
    if (def.providersResolver)
      def.providersResolver(def);
  }
  let preOrderHooksFound = false;
  let preOrderCheckHooksFound = false;
  let directiveIdx = allocExpando(tView, lView, directivesLength, null);
  ngDevMode && assertSame(directiveIdx, tNode.directiveStart, "TNode.directiveStart should point to just allocated space");
  if (directivesLength > 0) {
    tNode.directiveToIndex = /* @__PURE__ */ new Map();
  }
  for (let i = 0; i < directivesLength; i++) {
    const def = directives[i];
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
    configureViewWithDirective(tView, tNode, lView, directiveIdx, def);
    saveNameToExportMap(directiveIdx, def, exportsMap);
    if (hostDirectiveRanges !== null && hostDirectiveRanges.has(def)) {
      const [start, end] = hostDirectiveRanges.get(def);
      tNode.directiveToIndex.set(def.type, [
        directiveIdx,
        start + tNode.directiveStart,
        end + tNode.directiveStart
      ]);
    } else if (hostDirectiveDefs === null || !hostDirectiveDefs.has(def)) {
      tNode.directiveToIndex.set(def.type, directiveIdx);
    }
    if (def.contentQueries !== null)
      tNode.flags |= 4;
    if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0)
      tNode.flags |= 64;
    const lifeCycleHooks = def.type.prototype;
    if (!preOrderHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {
      (tView.preOrderHooks ??= []).push(tNode.index);
      preOrderHooksFound = true;
    }
    if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {
      (tView.preOrderCheckHooks ??= []).push(tNode.index);
      preOrderCheckHooksFound = true;
    }
    directiveIdx++;
  }
  initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs);
}
function initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs) {
  ngDevMode && assertFirstCreatePass(tView);
  for (let index = tNode.directiveStart; index < tNode.directiveEnd; index++) {
    const directiveDef = tView.data[index];
    if (hostDirectiveDefs === null || !hostDirectiveDefs.has(directiveDef)) {
      setupSelectorMatchedInputsOrOutputs(0, tNode, directiveDef, index);
      setupSelectorMatchedInputsOrOutputs(1, tNode, directiveDef, index);
      setupInitialInputs(tNode, index, false);
    } else {
      const hostDirectiveDef = hostDirectiveDefs.get(directiveDef);
      setupHostDirectiveInputsOrOutputs(0, tNode, hostDirectiveDef, index);
      setupHostDirectiveInputsOrOutputs(1, tNode, hostDirectiveDef, index);
      setupInitialInputs(tNode, index, true);
    }
  }
}
function setupSelectorMatchedInputsOrOutputs(mode, tNode, def, directiveIndex) {
  const aliasMap = mode === 0 ? def.inputs : def.outputs;
  for (const publicName in aliasMap) {
    if (aliasMap.hasOwnProperty(publicName)) {
      let bindings;
      if (mode === 0) {
        bindings = tNode.inputs ??= {};
      } else {
        bindings = tNode.outputs ??= {};
      }
      bindings[publicName] ??= [];
      bindings[publicName].push(directiveIndex);
      setShadowStylingInputFlags(tNode, publicName);
    }
  }
}
function setupHostDirectiveInputsOrOutputs(mode, tNode, config3, directiveIndex) {
  const aliasMap = mode === 0 ? config3.inputs : config3.outputs;
  for (const initialName in aliasMap) {
    if (aliasMap.hasOwnProperty(initialName)) {
      const publicName = aliasMap[initialName];
      let bindings;
      if (mode === 0) {
        bindings = tNode.hostDirectiveInputs ??= {};
      } else {
        bindings = tNode.hostDirectiveOutputs ??= {};
      }
      bindings[publicName] ??= [];
      bindings[publicName].push(directiveIndex, initialName);
      setShadowStylingInputFlags(tNode, publicName);
    }
  }
}
function setShadowStylingInputFlags(tNode, publicName) {
  if (publicName === "class") {
    tNode.flags |= 8;
  } else if (publicName === "style") {
    tNode.flags |= 16;
  }
}
function setupInitialInputs(tNode, directiveIndex, isHostDirective) {
  const { attrs, inputs, hostDirectiveInputs } = tNode;
  if (attrs === null || !isHostDirective && inputs === null || isHostDirective && hostDirectiveInputs === null || // Do not use unbound attributes as inputs to structural directives, since structural
  // directive inputs can only be set using microsyntax (e.g. `<div *dir="exp">`).
  isInlineTemplate(tNode)) {
    tNode.initialInputs ??= [];
    tNode.initialInputs.push(null);
    return;
  }
  let inputsToStore = null;
  let i = 0;
  while (i < attrs.length) {
    const attrName = attrs[i];
    if (attrName === 0) {
      i += 4;
      continue;
    } else if (attrName === 5) {
      i += 2;
      continue;
    } else if (typeof attrName === "number") {
      break;
    }
    if (!isHostDirective && inputs.hasOwnProperty(attrName)) {
      const inputConfig = inputs[attrName];
      for (const index of inputConfig) {
        if (index === directiveIndex) {
          inputsToStore ??= [];
          inputsToStore.push(attrName, attrs[i + 1]);
          break;
        }
      }
    } else if (isHostDirective && hostDirectiveInputs.hasOwnProperty(attrName)) {
      const config3 = hostDirectiveInputs[attrName];
      for (let j = 0; j < config3.length; j += 2) {
        if (config3[j] === directiveIndex) {
          inputsToStore ??= [];
          inputsToStore.push(config3[j + 1], attrs[i + 1]);
          break;
        }
      }
    }
    i += 2;
  }
  tNode.initialInputs ??= [];
  tNode.initialInputs.push(inputsToStore);
}
function configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {
  ngDevMode && assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, "Must be in Expando section");
  tView.data[directiveIndex] = def;
  const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));
  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), \u0275\u0275directiveInject, ngDevMode ? def.type.name : null);
  tView.blueprint[directiveIndex] = nodeInjectorFactory;
  lView[directiveIndex] = nodeInjectorFactory;
  registerHostBindingOpCodes(tView, tNode, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);
}
function registerHostBindingOpCodes(tView, tNode, directiveIdx, directiveVarsIdx, def) {
  ngDevMode && assertFirstCreatePass(tView);
  const hostBindings = def.hostBindings;
  if (hostBindings) {
    let hostBindingOpCodes = tView.hostBindingOpCodes;
    if (hostBindingOpCodes === null) {
      hostBindingOpCodes = tView.hostBindingOpCodes = [];
    }
    const elementIndx = ~tNode.index;
    if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {
      hostBindingOpCodes.push(elementIndx);
    }
    hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);
  }
}
function lastSelectedElementIdx(hostBindingOpCodes) {
  let i = hostBindingOpCodes.length;
  while (i > 0) {
    const value = hostBindingOpCodes[--i];
    if (typeof value === "number" && value < 0) {
      return value;
    }
  }
  return 0;
}
function saveNameToExportMap(directiveIdx, def, exportsMap) {
  if (exportsMap) {
    if (def.exportAs) {
      for (let i = 0; i < def.exportAs.length; i++) {
        exportsMap[def.exportAs[i]] = directiveIdx;
      }
    }
    if (isComponentDef(def))
      exportsMap[""] = directiveIdx;
  }
}
function initTNodeFlags(tNode, index, numberOfDirectives) {
  ngDevMode && assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, "Reached the max number of directives");
  tNode.flags |= 1;
  tNode.directiveStart = index;
  tNode.directiveEnd = index + numberOfDirectives;
  tNode.providerIndexes = index;
}
function assertNoDuplicateDirectives(directives) {
  if (directives.length < 2) {
    return;
  }
  const seenDirectives = /* @__PURE__ */ new Set();
  for (const current of directives) {
    if (seenDirectives.has(current)) {
      throw new RuntimeError(309, `Directive ${current.type.name} matches multiple times on the same element. Directives can only match an element once.`);
    }
    seenDirectives.add(current);
  }
}
function directiveHostFirstCreatePass(index, lView, type, name2, directiveMatcher, bindingsEnabled, attrsIndex, localRefsIndex) {
  const tView = lView[TVIEW];
  ngDevMode && assertFirstCreatePass(tView);
  const tViewConsts = tView.consts;
  const attrs = getConstant(tViewConsts, attrsIndex);
  const tNode = getOrCreateTNode(tView, index, type, name2, attrs);
  if (bindingsEnabled) {
    resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex), directiveMatcher);
  }
  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
  if (tNode.attrs !== null) {
    computeStaticStyling(tNode, tNode.attrs, false);
  }
  if (tNode.mergedAttrs !== null) {
    computeStaticStyling(tNode, tNode.mergedAttrs, true);
  }
  if (tView.queries !== null) {
    tView.queries.elementStart(tView, tNode);
  }
  return tNode;
}
function directiveHostEndFirstCreatePass(tView, tNode) {
  ngDevMode && assertFirstCreatePass(tView);
  registerPostOrderHooks(tView, tNode);
  if (isContentQueryHost(tNode)) {
    tView.queries.elementEnd(tNode);
  }
}
function domOnlyFirstCreatePass(index, tView, type, name2, attrsIndex, localRefsIndex) {
  ngDevMode && assertFirstCreatePass(tView);
  const tViewConsts = tView.consts;
  const attrs = getConstant(tViewConsts, attrsIndex);
  const tNode = getOrCreateTNode(tView, index, type, name2, attrs);
  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
  if (localRefsIndex != null) {
    const refs = getConstant(tViewConsts, localRefsIndex);
    tNode.localNames = [];
    for (let i = 0; i < refs.length; i += 2) {
      tNode.localNames.push(refs[i], -1);
    }
  }
  if (tNode.attrs !== null) {
    computeStaticStyling(tNode, tNode.attrs, false);
  }
  if (tNode.mergedAttrs !== null) {
    computeStaticStyling(tNode, tNode.mergedAttrs, true);
  }
  if (tView.queries !== null) {
    tView.queries.elementStart(tView, tNode);
  }
  return tNode;
}
function isListLikeIterable(obj) {
  if (!isJsObject(obj))
    return false;
  return Array.isArray(obj) || !(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]
  Symbol.iterator in obj;
}
function areIterablesEqual(a, b, comparator) {
  const iterator1 = a[Symbol.iterator]();
  const iterator2 = b[Symbol.iterator]();
  while (true) {
    const item1 = iterator1.next();
    const item2 = iterator2.next();
    if (item1.done && item2.done)
      return true;
    if (item1.done || item2.done)
      return false;
    if (!comparator(item1.value, item2.value))
      return false;
  }
}
function iterateListLike(obj, fn) {
  if (Array.isArray(obj)) {
    for (let i = 0; i < obj.length; i++) {
      fn(obj[i]);
    }
  } else {
    const iterator2 = obj[Symbol.iterator]();
    let item;
    while (!(item = iterator2.next()).done) {
      fn(item.value);
    }
  }
}
function isJsObject(o) {
  return o !== null && (typeof o === "function" || typeof o === "object");
}
function devModeEqual(a, b) {
  const isListLikeIterableA = isListLikeIterable(a);
  const isListLikeIterableB = isListLikeIterable(b);
  if (isListLikeIterableA && isListLikeIterableB) {
    return areIterablesEqual(a, b, devModeEqual);
  } else {
    const isAObject = a && (typeof a === "object" || typeof a === "function");
    const isBObject = b && (typeof b === "object" || typeof b === "function");
    if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
      return true;
    } else {
      return Object.is(a, b);
    }
  }
}
function updateBinding(lView, bindingIndex, value) {
  return lView[bindingIndex] = value;
}
function getBinding(lView, bindingIndex) {
  ngDevMode && assertIndexInRange(lView, bindingIndex);
  ngDevMode && assertNotSame(lView[bindingIndex], NO_CHANGE, "Stored value should never be NO_CHANGE.");
  return lView[bindingIndex];
}
function bindingUpdated(lView, bindingIndex, value) {
  ngDevMode && assertLessThan(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);
  if (value === NO_CHANGE) {
    return false;
  }
  const oldValue = lView[bindingIndex];
  if (Object.is(oldValue, value)) {
    return false;
  } else {
    if (ngDevMode && isInCheckNoChangesMode()) {
      const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : void 0;
      if (!devModeEqual(oldValueToCompare, value)) {
        const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);
        throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName, lView);
      }
      return false;
    }
    lView[bindingIndex] = value;
    return true;
  }
}
function bindingUpdated2(lView, bindingIndex, exp1, exp2) {
  const different = bindingUpdated(lView, bindingIndex, exp1);
  return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
}
function bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {
  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
  return bindingUpdated(lView, bindingIndex + 2, exp3) || different;
}
function bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {
  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
  return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;
}
function wrapListener(tNode, lView, listenerFn) {
  return function wrapListenerIn_markDirtyAndPreventDefault(event) {
    const startView = isComponentHost(tNode) ? getComponentLViewByIndex(tNode.index, lView) : lView;
    markViewDirty(
      startView,
      5
      /* NotificationSource.Listener */
    );
    const context2 = lView[CONTEXT];
    let result = executeListenerWithErrorHandling(lView, context2, listenerFn, event);
    let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;
    while (nextListenerFn) {
      result = executeListenerWithErrorHandling(lView, context2, nextListenerFn, event) && result;
      nextListenerFn = nextListenerFn.__ngNextListenerFn__;
    }
    return result;
  };
}
function executeListenerWithErrorHandling(lView, context2, listenerFn, e) {
  const prevConsumer = setActiveConsumer(null);
  try {
    profiler(6, context2, listenerFn);
    return listenerFn(e) !== false;
  } catch (error) {
    handleUncaughtError(lView, error);
    return false;
  } finally {
    profiler(7, context2, listenerFn);
    setActiveConsumer(prevConsumer);
  }
}
function listenToDomEvent(tNode, tView, lView, eventTargetResolver, renderer, eventName, originalListener, wrappedListener) {
  ngDevMode && assertNotSame(wrappedListener, originalListener, "Expected wrapped and original listeners to be different.");
  const isTNodeDirectiveHost = isDirectiveHost(tNode);
  let hasCoalesced = false;
  let existingListener = null;
  if (!eventTargetResolver && isTNodeDirectiveHost) {
    existingListener = findExistingListener(tView, lView, eventName, tNode.index);
  }
  if (existingListener !== null) {
    const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;
    lastListenerFn.__ngNextListenerFn__ = originalListener;
    existingListener.__ngLastListenerFn__ = originalListener;
    hasCoalesced = true;
  } else {
    const native = getNativeByTNode(tNode, lView);
    const target = eventTargetResolver ? eventTargetResolver(native) : native;
    stashEventListenerImpl(lView, target, eventName, wrappedListener);
    const cleanupFn = renderer.listen(target, eventName, wrappedListener);
    const idxOrTargetGetter = eventTargetResolver ? (_lView) => eventTargetResolver(unwrapRNode(_lView[tNode.index])) : tNode.index;
    storeListenerCleanup(idxOrTargetGetter, tView, lView, eventName, wrappedListener, cleanupFn, false);
  }
  return hasCoalesced;
}
function findExistingListener(tView, lView, eventName, tNodeIndex) {
  const tCleanup = tView.cleanup;
  if (tCleanup != null) {
    for (let i = 0; i < tCleanup.length - 1; i += 2) {
      const cleanupEventName = tCleanup[i];
      if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIndex) {
        const lCleanup = lView[CLEANUP];
        const listenerIdxInLCleanup = tCleanup[i + 2];
        return lCleanup && lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;
      }
      if (typeof cleanupEventName === "string") {
        i += 2;
      }
    }
  }
  return null;
}
function storeListenerCleanup(indexOrTargetGetter, tView, lView, eventName, listenerFn, cleanup, isOutput) {
  const tCleanup = tView.firstCreatePass ? getOrCreateTViewCleanup(tView) : null;
  const lCleanup = getOrCreateLViewCleanup(lView);
  const index = lCleanup.length;
  lCleanup.push(listenerFn, cleanup);
  tCleanup && tCleanup.push(eventName, indexOrTargetGetter, index, (index + 1) * (isOutput ? -1 : 1));
}
function listenToOutput(tNode, lView, directiveIndex, lookupName, eventName, listenerFn) {
  ngDevMode && assertIndexInRange(lView, directiveIndex);
  const instance = lView[directiveIndex];
  const tView = lView[TVIEW];
  const def = tView.data[directiveIndex];
  const propertyName2 = def.outputs[lookupName];
  const output = instance[propertyName2];
  if (ngDevMode && !isOutputSubscribable(output)) {
    throw new Error(`@Output ${propertyName2} not initialized in '${instance.constructor.name}'.`);
  }
  const subscription = output.subscribe(listenerFn);
  storeListenerCleanup(tNode.index, tView, lView, eventName, listenerFn, subscription, true);
}
function isOutputSubscribable(value) {
  return value != null && typeof value.subscribe === "function";
}
function toInputRefArray(map2) {
  return Object.keys(map2).map((name2) => {
    const [propName, flags, transform] = map2[name2];
    const inputData = {
      propName,
      templateName: name2,
      isSignal: (flags & InputFlags.SignalBased) !== 0
    };
    if (transform) {
      inputData.transform = transform;
    }
    return inputData;
  });
}
function toOutputRefArray(map2) {
  return Object.keys(map2).map((name2) => ({ propName: map2[name2], templateName: name2 }));
}
function verifyNotAnOrphanComponent(componentDef) {
  if (false) {
    if (depsTracker.isOrphanComponent(componentDef.type)) {
      throw new RuntimeError(981, `Orphan component found! Trying to render the component ${debugStringifyTypeForError(componentDef.type)} without first loading the NgModule that declares it. It is recommended to make this component standalone in order to avoid this error. If this is not possible now, import the component's NgModule in the appropriate NgModule, or the standalone component in which you are trying to render this component. If this is a lazy import, load the NgModule lazily as well and use its module injector.`);
    }
  }
}
function createRootViewInjector(componentDef, environmentInjector, injector) {
  let realEnvironmentInjector = environmentInjector instanceof EnvironmentInjector ? environmentInjector : environmentInjector?.injector;
  if (realEnvironmentInjector && componentDef.getStandaloneInjector !== null) {
    realEnvironmentInjector = componentDef.getStandaloneInjector(realEnvironmentInjector) || realEnvironmentInjector;
  }
  const rootViewInjector = realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;
  return rootViewInjector;
}
function createRootLViewEnvironment(rootLViewInjector) {
  const rendererFactory = rootLViewInjector.get(RendererFactory2, null);
  if (rendererFactory === null) {
    throw new RuntimeError(407, ngDevMode && "Angular was not able to inject a renderer (RendererFactory2). Likely this is due to a broken DI hierarchy. Make sure that any injector used to create this component has a correct parent.");
  }
  const sanitizer = rootLViewInjector.get(Sanitizer, null);
  const changeDetectionScheduler = rootLViewInjector.get(ChangeDetectionScheduler, null);
  let ngReflect = false;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    ngReflect = rootLViewInjector.get(NG_REFLECT_ATTRS_FLAG, NG_REFLECT_ATTRS_FLAG_DEFAULT);
  }
  return {
    rendererFactory,
    sanitizer,
    changeDetectionScheduler,
    ngReflect
  };
}
function createHostElement(componentDef, render) {
  const tagName = (componentDef.selectors[0][0] || "div").toLowerCase();
  const namespace = tagName === "svg" ? SVG_NAMESPACE : tagName === "math" ? MATH_ML_NAMESPACE : null;
  return createElementNode(render, tagName, namespace);
}
function createRootTView(rootSelectorOrNode, componentDef, componentBindings, directives) {
  const tAttributes = rootSelectorOrNode ? ["ng-version", "20.1.7"] : (
    // Extract attributes and classes from the first selector only to match VE behavior.
    extractAttrsAndClassesFromSelector(componentDef.selectors[0])
  );
  let creationBindings = null;
  let updateBindings = null;
  let varsToAllocate = 0;
  if (componentBindings) {
    for (const binding of componentBindings) {
      varsToAllocate += binding[BINDING].requiredVars;
      if (binding.create) {
        binding.targetIdx = 0;
        (creationBindings ??= []).push(binding);
      }
      if (binding.update) {
        binding.targetIdx = 0;
        (updateBindings ??= []).push(binding);
      }
    }
  }
  if (directives) {
    for (let i = 0; i < directives.length; i++) {
      const directive = directives[i];
      if (typeof directive !== "function") {
        for (const binding of directive.bindings) {
          varsToAllocate += binding[BINDING].requiredVars;
          const targetDirectiveIdx = i + 1;
          if (binding.create) {
            binding.targetIdx = targetDirectiveIdx;
            (creationBindings ??= []).push(binding);
          }
          if (binding.update) {
            binding.targetIdx = targetDirectiveIdx;
            (updateBindings ??= []).push(binding);
          }
        }
      }
    }
  }
  const directivesToApply = [componentDef];
  if (directives) {
    for (const directive of directives) {
      const directiveType = typeof directive === "function" ? directive : directive.type;
      const directiveDef = ngDevMode ? getDirectiveDefOrThrow(directiveType) : getDirectiveDef(directiveType);
      if (ngDevMode && !directiveDef.standalone) {
        throw new RuntimeError(907, `The ${stringifyForError(directiveType)} directive must be standalone in order to be applied to a dynamically-created component.`);
      }
      directivesToApply.push(directiveDef);
    }
  }
  const rootTView = createTView(0, null, getRootTViewTemplate(creationBindings, updateBindings), 1, varsToAllocate, directivesToApply, null, null, null, [tAttributes], null);
  return rootTView;
}
function getRootTViewTemplate(creationBindings, updateBindings) {
  if (!creationBindings && !updateBindings) {
    return null;
  }
  return (flags) => {
    if (flags & 1 && creationBindings) {
      for (const binding of creationBindings) {
        binding.create();
      }
    }
    if (flags & 2 && updateBindings) {
      for (const binding of updateBindings) {
        binding.update();
      }
    }
  };
}
function isInputBinding(binding) {
  const kind = binding[BINDING].kind;
  return kind === "input" || kind === "twoWay";
}
function projectNodes(tNode, ngContentSelectors, projectableNodes) {
  const projection = tNode.projection = [];
  for (let i = 0; i < ngContentSelectors.length; i++) {
    const nodesforSlot = projectableNodes[i];
    projection.push(nodesforSlot != null && nodesforSlot.length ? Array.from(nodesforSlot) : null);
  }
}
function injectViewContainerRef() {
  const previousTNode = getCurrentTNode();
  return createContainerRef(previousTNode, getLView());
}
function getViewRefs(lContainer) {
  return lContainer[VIEW_REFS];
}
function getOrCreateViewRefs(lContainer) {
  return lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = []);
}
function createContainerRef(hostTNode, hostLView) {
  ngDevMode && assertTNodeType(
    hostTNode,
    12 | 3
    /* TNodeType.AnyRNode */
  );
  let lContainer;
  const slotValue = hostLView[hostTNode.index];
  if (isLContainer(slotValue)) {
    lContainer = slotValue;
  } else {
    lContainer = createLContainer(slotValue, hostLView, null, hostTNode);
    hostLView[hostTNode.index] = lContainer;
    addToEndOfViewTree(hostLView, lContainer);
  }
  _locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue);
  return new R3ViewContainerRef(lContainer, hostTNode, hostLView);
}
function insertAnchorNode(hostLView, hostTNode) {
  const renderer = hostLView[RENDERER];
  const commentNode = renderer.createComment(ngDevMode ? "container" : "");
  const hostNative = getNativeByTNode(hostTNode, hostLView);
  const parentOfHostNative = renderer.parentNode(hostNative);
  nativeInsertBefore(renderer, parentOfHostNative, commentNode, renderer.nextSibling(hostNative), false);
  return commentNode;
}
function populateDehydratedViewsInLContainer(lContainer, tNode, hostLView) {
  return _populateDehydratedViewsInLContainer(lContainer, tNode, hostLView);
}
function createAnchorNode(lContainer, hostLView, hostTNode, slotValue) {
  if (lContainer[NATIVE])
    return;
  let commentNode;
  if (hostTNode.type & 8) {
    commentNode = unwrapRNode(slotValue);
  } else {
    commentNode = insertAnchorNode(hostLView, hostTNode);
  }
  lContainer[NATIVE] = commentNode;
}
function getIdxOfMatchingSelector(tNode, selector) {
  const localNames = tNode.localNames;
  if (localNames !== null) {
    for (let i = 0; i < localNames.length; i += 2) {
      if (localNames[i] === selector) {
        return localNames[i + 1];
      }
    }
  }
  return null;
}
function createResultByTNodeType(tNode, currentView) {
  if (tNode.type & (3 | 8)) {
    return createElementRef(tNode, currentView);
  } else if (tNode.type & 4) {
    return createTemplateRef(tNode, currentView);
  }
  return null;
}
function createResultForNode(lView, tNode, matchingIdx, read) {
  if (matchingIdx === -1) {
    return createResultByTNodeType(tNode, lView);
  } else if (matchingIdx === -2) {
    return createSpecialToken(lView, tNode, read);
  } else {
    return getNodeInjectable(lView, lView[TVIEW], matchingIdx, tNode);
  }
}
function createSpecialToken(lView, tNode, read) {
  if (read === ElementRef) {
    return createElementRef(tNode, lView);
  } else if (read === TemplateRef) {
    return createTemplateRef(tNode, lView);
  } else if (read === ViewContainerRef) {
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12
      /* TNodeType.AnyContainer */
    );
    return createContainerRef(tNode, lView);
  } else {
    ngDevMode && throwError2(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${stringify(read)}.`);
  }
}
function materializeViewResults(tView, lView, tQuery, queryIndex) {
  const lQuery = lView[QUERIES].queries[queryIndex];
  if (lQuery.matches === null) {
    const tViewData = tView.data;
    const tQueryMatches = tQuery.matches;
    const result = [];
    for (let i = 0; tQueryMatches !== null && i < tQueryMatches.length; i += 2) {
      const matchedNodeIdx = tQueryMatches[i];
      if (matchedNodeIdx < 0) {
        result.push(null);
      } else {
        ngDevMode && assertIndexInRange(tViewData, matchedNodeIdx);
        const tNode = tViewData[matchedNodeIdx];
        result.push(createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read));
      }
    }
    lQuery.matches = result;
  }
  return lQuery.matches;
}
function collectQueryResults(tView, lView, queryIndex, result) {
  const tQuery = tView.queries.getByIndex(queryIndex);
  const tQueryMatches = tQuery.matches;
  if (tQueryMatches !== null) {
    const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);
    for (let i = 0; i < tQueryMatches.length; i += 2) {
      const tNodeIdx = tQueryMatches[i];
      if (tNodeIdx > 0) {
        result.push(lViewResults[i / 2]);
      } else {
        const childQueryIndex = tQueryMatches[i + 1];
        const declarationLContainer = lView[-tNodeIdx];
        ngDevMode && assertLContainer(declarationLContainer);
        for (let i2 = CONTAINER_HEADER_OFFSET; i2 < declarationLContainer.length; i2++) {
          const embeddedLView = declarationLContainer[i2];
          if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) {
            collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
          }
        }
        if (declarationLContainer[MOVED_VIEWS] !== null) {
          const embeddedLViews = declarationLContainer[MOVED_VIEWS];
          for (let i2 = 0; i2 < embeddedLViews.length; i2++) {
            const embeddedLView = embeddedLViews[i2];
            collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
          }
        }
      }
    }
  }
  return result;
}
function loadQueryInternal(lView, queryIndex) {
  ngDevMode && assertDefined(lView[QUERIES], "LQueries should be defined when trying to load a query");
  ngDevMode && assertIndexInRange(lView[QUERIES].queries, queryIndex);
  return lView[QUERIES].queries[queryIndex].queryList;
}
function createLQuery(tView, lView, flags) {
  const queryList = new QueryList(
    (flags & 4) === 4
    /* QueryFlags.emitDistinctChangesOnly */
  );
  storeCleanupWithContext(tView, lView, queryList, queryList.destroy);
  const lQueries = (lView[QUERIES] ??= new LQueries_()).queries;
  return lQueries.push(new LQuery_(queryList)) - 1;
}
function createViewQuery(predicate, flags, read) {
  ngDevMode && assertNumber(flags, "Expecting flags");
  const tView = getTView();
  if (tView.firstCreatePass) {
    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);
    if ((flags & 2) === 2) {
      tView.staticViewQueries = true;
    }
  }
  return createLQuery(tView, getLView(), flags);
}
function createContentQuery(directiveIndex, predicate, flags, read) {
  ngDevMode && assertNumber(flags, "Expecting flags");
  const tView = getTView();
  if (tView.firstCreatePass) {
    const tNode = getCurrentTNode();
    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);
    saveContentQueryAndDirectiveIndex(tView, directiveIndex);
    if ((flags & 2) === 2) {
      tView.staticContentQueries = true;
    }
  }
  return createLQuery(tView, getLView(), flags);
}
function splitQueryMultiSelectors(locator) {
  return locator.split(",").map((s) => s.trim());
}
function createTQuery(tView, metadata, nodeIndex) {
  if (tView.queries === null)
    tView.queries = new TQueries_();
  tView.queries.track(new TQuery_(metadata, nodeIndex));
}
function saveContentQueryAndDirectiveIndex(tView, directiveIndex) {
  const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);
  const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;
  if (directiveIndex !== lastSavedDirectiveIndex) {
    tViewContentQueries.push(tView.queries.length - 1, directiveIndex);
  }
}
function getTQuery(tView, index) {
  ngDevMode && assertDefined(tView.queries, "TQueries must be defined to retrieve a TQuery");
  return tView.queries.getByIndex(index);
}
function getQueryResults(lView, queryIndex) {
  const tView = lView[TVIEW];
  const tQuery = getTQuery(tView, queryIndex);
  return tQuery.crossesNgTemplate ? collectQueryResults(tView, lView, queryIndex, []) : materializeViewResults(tView, lView, tQuery, queryIndex);
}
function createQuerySignalFn(firstOnly, required, opts) {
  let node;
  const signalFn = createComputed(() => {
    node._dirtyCounter();
    const value = refreshSignalQuery(node, firstOnly);
    if (required && value === void 0) {
      throw new RuntimeError(-951, ngDevMode && "Child query result is required but no value is available.");
    }
    return value;
  });
  node = signalFn[SIGNAL];
  node._dirtyCounter = signal(0);
  node._flatValue = void 0;
  if (ngDevMode) {
    signalFn.toString = () => `[Query Signal]`;
    node.debugName = opts?.debugName;
  }
  return signalFn;
}
function createSingleResultOptionalQuerySignalFn(opts) {
  return createQuerySignalFn(
    /* firstOnly */
    true,
    /* required */
    false,
    opts
  );
}
function createSingleResultRequiredQuerySignalFn(opts) {
  return createQuerySignalFn(
    /* firstOnly */
    true,
    /* required */
    true,
    opts
  );
}
function createMultiResultQuerySignalFn(opts) {
  return createQuerySignalFn(
    /* firstOnly */
    false,
    /* required */
    false,
    opts
  );
}
function bindQueryToSignal(target, queryIndex) {
  const node = target[SIGNAL];
  node._lView = getLView();
  node._queryIndex = queryIndex;
  node._queryList = loadQueryInternal(node._lView, queryIndex);
  node._queryList.onDirty(() => node._dirtyCounter.update((v) => v + 1));
}
function refreshSignalQuery(node, firstOnly) {
  const lView = node._lView;
  const queryIndex = node._queryIndex;
  if (lView === void 0 || queryIndex === void 0 || lView[FLAGS] & 4) {
    return firstOnly ? void 0 : EMPTY_ARRAY;
  }
  const queryList = loadQueryInternal(lView, queryIndex);
  const results = getQueryResults(lView, queryIndex);
  queryList.reset(results, unwrapElementRef);
  if (firstOnly) {
    return queryList.first;
  } else {
    const resultChanged = queryList._changesDetected;
    if (resultChanged || node._flatValue === void 0) {
      return node._flatValue = queryList.toArray();
    }
    return node._flatValue;
  }
}
function resolveComponentResources(resourceResolver) {
  const componentResolved = [];
  const urlMap = /* @__PURE__ */ new Map();
  function cachedResourceResolve(url) {
    let promise = urlMap.get(url);
    if (!promise) {
      const resp = resourceResolver(url);
      urlMap.set(url, promise = resp.then((res) => unwrapResponse(url, res)));
    }
    return promise;
  }
  componentResourceResolutionQueue.forEach((component, type) => {
    const promises = [];
    if (component.templateUrl) {
      promises.push(cachedResourceResolve(component.templateUrl).then((template) => {
        component.template = template;
      }));
    }
    const styles = typeof component.styles === "string" ? [component.styles] : component.styles || [];
    component.styles = styles;
    if (component.styleUrl && component.styleUrls?.length) {
      throw new Error("@Component cannot define both `styleUrl` and `styleUrls`. Use `styleUrl` if the component has one stylesheet, or `styleUrls` if it has multiple");
    } else if (component.styleUrls?.length) {
      const styleOffset = component.styles.length;
      const styleUrls = component.styleUrls;
      component.styleUrls.forEach((styleUrl, index) => {
        styles.push("");
        promises.push(cachedResourceResolve(styleUrl).then((style) => {
          styles[styleOffset + index] = style;
          styleUrls.splice(styleUrls.indexOf(styleUrl), 1);
          if (styleUrls.length == 0) {
            component.styleUrls = void 0;
          }
        }));
      });
    } else if (component.styleUrl) {
      promises.push(cachedResourceResolve(component.styleUrl).then((style) => {
        styles.push(style);
        component.styleUrl = void 0;
      }));
    }
    const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));
    componentResolved.push(fullyResolved);
  });
  clearResolutionOfComponentResourcesQueue();
  return Promise.all(componentResolved).then(() => void 0);
}
function maybeQueueResolutionOfComponentResources(type, metadata) {
  if (componentNeedsResolution(metadata)) {
    componentResourceResolutionQueue.set(type, metadata);
    componentDefPendingResolution.add(type);
  }
}
function componentNeedsResolution(component) {
  return !!(component.templateUrl && !component.hasOwnProperty("template") || component.styleUrls && component.styleUrls.length || component.styleUrl);
}
function clearResolutionOfComponentResourcesQueue() {
  const old = componentResourceResolutionQueue;
  componentResourceResolutionQueue = /* @__PURE__ */ new Map();
  return old;
}
function isComponentResourceResolutionQueueEmpty() {
  return componentResourceResolutionQueue.size === 0;
}
function unwrapResponse(url, response) {
  if (typeof response === "string") {
    return response;
  }
  if (response.status !== void 0 && response.status !== 200) {
    return Promise.reject(new RuntimeError(918, ngDevMode && `Could not load resource: ${url}. Response status: ${response.status}`));
  }
  return response.text();
}
function componentDefResolved(type) {
  componentDefPendingResolution.delete(type);
}
function assertSameOrNotExisting(id2, type, incoming) {
  if (type && type !== incoming && checkForDuplicateNgModules) {
    throw new Error(`Duplicate module registered for ${id2} - ${stringify(type)} vs ${stringify(type.name)}`);
  }
}
function registerNgModuleType(ngModuleType, id2) {
  const existing = modules.get(id2) || null;
  assertSameOrNotExisting(id2, existing, ngModuleType);
  modules.set(id2, ngModuleType);
}
function \u0275\u0275validateIframeAttribute(attrValue, tagName, attrName) {
  const lView = getLView();
  const tNode = getSelectedTNode();
  const element = getNativeByTNode(tNode, lView);
  if (tNode.type === 2 && tagName.toLowerCase() === "iframe") {
    const iframe = element;
    iframe.src = "";
    iframe.srcdoc = trustedHTMLFromString("");
    nativeRemoveNode(lView[RENDERER], iframe);
    const errorMessage = ngDevMode && `Angular has detected that the \`${attrName}\` was applied as a binding to an <iframe>${getTemplateLocationDetails(lView)}. For security reasons, the \`${attrName}\` can be set on an <iframe> as a static attribute only. 
To fix this, switch the \`${attrName}\` binding to a static attribute in a template or in host bindings section.`;
    throw new RuntimeError(-910, errorMessage);
  }
  return attrValue;
}
function performanceMarkFeature(feature) {
  if (markedFeatures.has(feature)) {
    return;
  }
  markedFeatures.add(feature);
  performance?.mark?.("mark_feature_usage", { detail: { feature } });
}
function createNgModule(ngModule, parentInjector) {
  return new NgModuleRef2(ngModule, parentInjector ?? null, []);
}
function createNgModuleRefWithProviders(moduleType, parentInjector, additionalProviders) {
  return new NgModuleRef2(moduleType, parentInjector, additionalProviders, false);
}
function createEnvironmentInjector(providers, parent, debugName = null) {
  const adapter = new EnvironmentNgModuleRefAdapter({
    providers,
    parent,
    debugName,
    runEnvironmentInitializers: true
  });
  return adapter.injector;
}
function \u0275\u0275defineComponent(componentDefinition) {
  return noSideEffects(() => {
    (typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode();
    const baseDef = getNgDirectiveDef(componentDefinition);
    const def = __spreadProps(__spreadValues({}, baseDef), {
      decls: componentDefinition.decls,
      vars: componentDefinition.vars,
      template: componentDefinition.template,
      consts: componentDefinition.consts || null,
      ngContentSelectors: componentDefinition.ngContentSelectors,
      onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
      directiveDefs: null,
      // assigned in noSideEffects
      pipeDefs: null,
      // assigned in noSideEffects
      dependencies: baseDef.standalone && componentDefinition.dependencies || null,
      getStandaloneInjector: baseDef.standalone ? (parentInjector) => {
        return parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(def);
      } : null,
      getExternalStyles: null,
      signals: componentDefinition.signals ?? false,
      data: componentDefinition.data || {},
      encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,
      styles: componentDefinition.styles || EMPTY_ARRAY,
      _: null,
      schemas: componentDefinition.schemas || null,
      tView: null,
      id: ""
    });
    if (baseDef.standalone) {
      performanceMarkFeature("NgStandalone");
    }
    initFeatures(def);
    const dependencies = componentDefinition.dependencies;
    def.directiveDefs = extractDefListOrFactory(dependencies, extractDirectiveDef);
    def.pipeDefs = extractDefListOrFactory(dependencies, getPipeDef);
    def.id = getComponentId(def);
    return def;
  });
}
function extractDirectiveDef(type) {
  return getComponentDef(type) || getDirectiveDef(type);
}
function \u0275\u0275defineNgModule(def) {
  return noSideEffects(() => {
    const res = {
      type: def.type,
      bootstrap: def.bootstrap || EMPTY_ARRAY,
      declarations: def.declarations || EMPTY_ARRAY,
      imports: def.imports || EMPTY_ARRAY,
      exports: def.exports || EMPTY_ARRAY,
      transitiveCompileScopes: null,
      schemas: def.schemas || null,
      id: def.id || null
    };
    return res;
  });
}
function parseAndConvertInputsForDefinition(obj, declaredInputs) {
  if (obj == null)
    return EMPTY_OBJ;
  const newLookup = {};
  for (const minifiedKey in obj) {
    if (obj.hasOwnProperty(minifiedKey)) {
      const value = obj[minifiedKey];
      let publicName;
      let declaredName;
      let inputFlags;
      let transform;
      if (Array.isArray(value)) {
        inputFlags = value[0];
        publicName = value[1];
        declaredName = value[2] ?? publicName;
        transform = value[3] || null;
      } else {
        publicName = value;
        declaredName = value;
        inputFlags = InputFlags.None;
        transform = null;
      }
      newLookup[publicName] = [minifiedKey, inputFlags, transform];
      declaredInputs[publicName] = declaredName;
    }
  }
  return newLookup;
}
function parseAndConvertOutputsForDefinition(obj) {
  if (obj == null)
    return EMPTY_OBJ;
  const newLookup = {};
  for (const minifiedKey in obj) {
    if (obj.hasOwnProperty(minifiedKey)) {
      newLookup[obj[minifiedKey]] = minifiedKey;
    }
  }
  return newLookup;
}
function \u0275\u0275defineDirective(directiveDefinition) {
  return noSideEffects(() => {
    const def = getNgDirectiveDef(directiveDefinition);
    initFeatures(def);
    return def;
  });
}
function \u0275\u0275definePipe(pipeDef) {
  return {
    type: pipeDef.type,
    name: pipeDef.name,
    factory: null,
    pure: pipeDef.pure !== false,
    standalone: pipeDef.standalone ?? true,
    onDestroy: pipeDef.type.prototype.ngOnDestroy || null
  };
}
function getNgDirectiveDef(directiveDefinition) {
  const declaredInputs = {};
  return {
    type: directiveDefinition.type,
    providersResolver: null,
    factory: null,
    hostBindings: directiveDefinition.hostBindings || null,
    hostVars: directiveDefinition.hostVars || 0,
    hostAttrs: directiveDefinition.hostAttrs || null,
    contentQueries: directiveDefinition.contentQueries || null,
    declaredInputs,
    inputConfig: directiveDefinition.inputs || EMPTY_OBJ,
    exportAs: directiveDefinition.exportAs || null,
    standalone: directiveDefinition.standalone ?? true,
    signals: directiveDefinition.signals === true,
    selectors: directiveDefinition.selectors || EMPTY_ARRAY,
    viewQuery: directiveDefinition.viewQuery || null,
    features: directiveDefinition.features || null,
    setInput: null,
    resolveHostDirectives: null,
    hostDirectives: null,
    inputs: parseAndConvertInputsForDefinition(directiveDefinition.inputs, declaredInputs),
    outputs: parseAndConvertOutputsForDefinition(directiveDefinition.outputs),
    debugInfo: null
  };
}
function initFeatures(definition) {
  definition.features?.forEach((fn) => fn(definition));
}
function extractDefListOrFactory(dependencies, defExtractor) {
  if (!dependencies) {
    return null;
  }
  return () => {
    const resolvedDependencies = typeof dependencies === "function" ? dependencies() : dependencies;
    const result = [];
    for (const dep of resolvedDependencies) {
      const definition = defExtractor(dep);
      if (definition !== null) {
        result.push(definition);
      }
    }
    return result;
  };
}
function getComponentId(componentDef) {
  let hash3 = 0;
  const componentDefConsts = typeof componentDef.consts === "function" ? "" : componentDef.consts;
  const hashSelectors = [
    componentDef.selectors,
    componentDef.ngContentSelectors,
    componentDef.hostVars,
    componentDef.hostAttrs,
    componentDefConsts,
    componentDef.vars,
    componentDef.decls,
    componentDef.encapsulation,
    componentDef.standalone,
    componentDef.signals,
    componentDef.exportAs,
    JSON.stringify(componentDef.inputs),
    JSON.stringify(componentDef.outputs),
    // We cannot use 'componentDef.type.name' as the name of the symbol will change and will not
    // match in the server and browser bundles.
    Object.getOwnPropertyNames(componentDef.type.prototype),
    !!componentDef.contentQueries,
    !!componentDef.viewQuery
  ];
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    for (const item of hashSelectors) {
      assertNotEqual(typeof item, "function", "Internal error: attempting to use a function in component id computation logic.");
    }
  }
  for (const char of hashSelectors.join("|")) {
    hash3 = Math.imul(31, hash3) + char.charCodeAt(0) << 0;
  }
  hash3 += 2147483647 + 1;
  const compId = "c" + hash3;
  if ((typeof ngDevMode === "undefined" || ngDevMode) && true) {
    if (GENERATED_COMP_IDS.has(compId)) {
      const previousCompDefType = GENERATED_COMP_IDS.get(compId);
      if (previousCompDefType !== componentDef.type) {
        console.warn(formatRuntimeError(-912, `Component ID generation collision detected. Components '${previousCompDefType.name}' and '${componentDef.type.name}' with selector '${stringifyCSSSelectorList(componentDef.selectors)}' generated the same component ID. To fix this, you can change the selector of one of those components or add an extra host attribute to force a different ID.`));
      }
    } else {
      GENERATED_COMP_IDS.set(compId, componentDef.type);
    }
  }
  return compId;
}
function getSuperType(type) {
  return Object.getPrototypeOf(type.prototype).constructor;
}
function \u0275\u0275InheritDefinitionFeature(definition) {
  let superType = getSuperType(definition.type);
  let shouldInheritFields = true;
  const inheritanceChain = [definition];
  while (superType) {
    let superDef = void 0;
    if (isComponentDef(definition)) {
      superDef = superType.\u0275cmp || superType.\u0275dir;
    } else {
      if (superType.\u0275cmp) {
        throw new RuntimeError(903, ngDevMode && `Directives cannot inherit Components. Directive ${stringifyForError(definition.type)} is attempting to extend component ${stringifyForError(superType)}`);
      }
      superDef = superType.\u0275dir;
    }
    if (superDef) {
      if (shouldInheritFields) {
        inheritanceChain.push(superDef);
        const writeableDef = definition;
        writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);
        writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);
        writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);
        const superHostBindings = superDef.hostBindings;
        superHostBindings && inheritHostBindings(definition, superHostBindings);
        const superViewQuery = superDef.viewQuery;
        const superContentQueries = superDef.contentQueries;
        superViewQuery && inheritViewQuery(definition, superViewQuery);
        superContentQueries && inheritContentQueries(definition, superContentQueries);
        mergeInputsWithTransforms(definition, superDef);
        fillProperties(definition.outputs, superDef.outputs);
        if (isComponentDef(superDef) && superDef.data.animation) {
          const defData = definition.data;
          defData.animation = (defData.animation || []).concat(superDef.data.animation);
        }
      }
      const features = superDef.features;
      if (features) {
        for (let i = 0; i < features.length; i++) {
          const feature = features[i];
          if (feature && feature.ngInherit) {
            feature(definition);
          }
          if (feature === \u0275\u0275InheritDefinitionFeature) {
            shouldInheritFields = false;
          }
        }
      }
    }
    superType = Object.getPrototypeOf(superType);
  }
  mergeHostAttrsAcrossInheritance(inheritanceChain);
}
function mergeInputsWithTransforms(target, source) {
  for (const key in source.inputs) {
    if (!source.inputs.hasOwnProperty(key)) {
      continue;
    }
    if (target.inputs.hasOwnProperty(key)) {
      continue;
    }
    const value = source.inputs[key];
    if (value !== void 0) {
      target.inputs[key] = value;
      target.declaredInputs[key] = source.declaredInputs[key];
    }
  }
}
function mergeHostAttrsAcrossInheritance(inheritanceChain) {
  let hostVars = 0;
  let hostAttrs = null;
  for (let i = inheritanceChain.length - 1; i >= 0; i--) {
    const def = inheritanceChain[i];
    def.hostVars = hostVars += def.hostVars;
    def.hostAttrs = mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));
  }
}
function maybeUnwrapEmpty(value) {
  if (value === EMPTY_OBJ) {
    return {};
  } else if (value === EMPTY_ARRAY) {
    return [];
  } else {
    return value;
  }
}
function inheritViewQuery(definition, superViewQuery) {
  const prevViewQuery = definition.viewQuery;
  if (prevViewQuery) {
    definition.viewQuery = (rf, ctx) => {
      superViewQuery(rf, ctx);
      prevViewQuery(rf, ctx);
    };
  } else {
    definition.viewQuery = superViewQuery;
  }
}
function inheritContentQueries(definition, superContentQueries) {
  const prevContentQueries = definition.contentQueries;
  if (prevContentQueries) {
    definition.contentQueries = (rf, ctx, directiveIndex) => {
      superContentQueries(rf, ctx, directiveIndex);
      prevContentQueries(rf, ctx, directiveIndex);
    };
  } else {
    definition.contentQueries = superContentQueries;
  }
}
function inheritHostBindings(definition, superHostBindings) {
  const prevHostBindings = definition.hostBindings;
  if (prevHostBindings) {
    definition.hostBindings = (rf, ctx) => {
      superHostBindings(rf, ctx);
      prevHostBindings(rf, ctx);
    };
  } else {
    definition.hostBindings = superHostBindings;
  }
}
function \u0275\u0275CopyDefinitionFeature(definition) {
  let superType = getSuperType(definition.type);
  let superDef = void 0;
  if (isComponentDef(definition)) {
    superDef = superType.\u0275cmp;
  } else {
    superDef = superType.\u0275dir;
  }
  const defAny = definition;
  for (const field of COPY_DIRECTIVE_FIELDS) {
    defAny[field] = superDef[field];
  }
  if (isComponentDef(superDef)) {
    for (const field of COPY_COMPONENT_FIELDS) {
      defAny[field] = superDef[field];
    }
  }
}
function \u0275\u0275HostDirectivesFeature(rawHostDirectives) {
  const feature = (definition) => {
    const isEager = Array.isArray(rawHostDirectives);
    if (definition.hostDirectives === null) {
      definition.resolveHostDirectives = resolveHostDirectives;
      definition.hostDirectives = isEager ? rawHostDirectives.map(createHostDirectiveDef) : [rawHostDirectives];
    } else if (isEager) {
      definition.hostDirectives.unshift(...rawHostDirectives.map(createHostDirectiveDef));
    } else {
      definition.hostDirectives.unshift(rawHostDirectives);
    }
  };
  feature.ngInherit = true;
  return feature;
}
function resolveHostDirectives(matches) {
  const allDirectiveDefs = [];
  let hasComponent = false;
  let hostDirectiveDefs = null;
  let hostDirectiveRanges = null;
  for (let i = 0; i < matches.length; i++) {
    const def = matches[i];
    if (def.hostDirectives !== null) {
      const start = allDirectiveDefs.length;
      hostDirectiveDefs ??= /* @__PURE__ */ new Map();
      hostDirectiveRanges ??= /* @__PURE__ */ new Map();
      findHostDirectiveDefs(def, allDirectiveDefs, hostDirectiveDefs);
      hostDirectiveRanges.set(def, [start, allDirectiveDefs.length - 1]);
    }
    if (i === 0 && isComponentDef(def)) {
      hasComponent = true;
      allDirectiveDefs.push(def);
    }
  }
  for (let i = hasComponent ? 1 : 0; i < matches.length; i++) {
    allDirectiveDefs.push(matches[i]);
  }
  return [allDirectiveDefs, hostDirectiveDefs, hostDirectiveRanges];
}
function findHostDirectiveDefs(currentDef, matchedDefs, hostDirectiveDefs) {
  if (currentDef.hostDirectives !== null) {
    for (const configOrFn of currentDef.hostDirectives) {
      if (typeof configOrFn === "function") {
        const resolved2 = configOrFn();
        for (const config3 of resolved2) {
          trackHostDirectiveDef(createHostDirectiveDef(config3), matchedDefs, hostDirectiveDefs);
        }
      } else {
        trackHostDirectiveDef(configOrFn, matchedDefs, hostDirectiveDefs);
      }
    }
  }
}
function trackHostDirectiveDef(def, matchedDefs, hostDirectiveDefs) {
  const hostDirectiveDef = getDirectiveDef(def.directive);
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    validateHostDirective(def, hostDirectiveDef);
  }
  patchDeclaredInputs(hostDirectiveDef.declaredInputs, def.inputs);
  findHostDirectiveDefs(hostDirectiveDef, matchedDefs, hostDirectiveDefs);
  hostDirectiveDefs.set(hostDirectiveDef, def);
  matchedDefs.push(hostDirectiveDef);
}
function createHostDirectiveDef(config3) {
  return typeof config3 === "function" ? { directive: resolveForwardRef(config3), inputs: EMPTY_OBJ, outputs: EMPTY_OBJ } : {
    directive: resolveForwardRef(config3.directive),
    inputs: bindingArrayToMap(config3.inputs),
    outputs: bindingArrayToMap(config3.outputs)
  };
}
function bindingArrayToMap(bindings) {
  if (bindings === void 0 || bindings.length === 0) {
    return EMPTY_OBJ;
  }
  const result = {};
  for (let i = 0; i < bindings.length; i += 2) {
    result[bindings[i]] = bindings[i + 1];
  }
  return result;
}
function patchDeclaredInputs(declaredInputs, exposedInputs) {
  for (const publicName in exposedInputs) {
    if (exposedInputs.hasOwnProperty(publicName)) {
      const remappedPublicName = exposedInputs[publicName];
      const privateName = declaredInputs[publicName];
      if ((typeof ngDevMode === "undefined" || ngDevMode) && declaredInputs.hasOwnProperty(remappedPublicName)) {
        assertEqual(declaredInputs[remappedPublicName], declaredInputs[publicName], `Conflicting host directive input alias ${publicName}.`);
      }
      declaredInputs[remappedPublicName] = privateName;
    }
  }
}
function validateHostDirective(hostDirectiveConfig, directiveDef) {
  const type = hostDirectiveConfig.directive;
  if (directiveDef === null) {
    if (getComponentDef(type) !== null) {
      throw new RuntimeError(310, `Host directive ${type.name} cannot be a component.`);
    }
    throw new RuntimeError(307, `Could not resolve metadata for host directive ${type.name}. Make sure that the ${type.name} class is annotated with an @Directive decorator.`);
  }
  if (!directiveDef.standalone) {
    throw new RuntimeError(308, `Host directive ${directiveDef.type.name} must be standalone.`);
  }
  validateMappings("input", directiveDef, hostDirectiveConfig.inputs);
  validateMappings("output", directiveDef, hostDirectiveConfig.outputs);
}
function validateMappings(bindingType, def, hostDirectiveBindings) {
  const className = def.type.name;
  const bindings = bindingType === "input" ? def.inputs : def.outputs;
  for (const publicName in hostDirectiveBindings) {
    if (hostDirectiveBindings.hasOwnProperty(publicName)) {
      if (!bindings.hasOwnProperty(publicName)) {
        throw new RuntimeError(311, `Directive ${className} does not have an ${bindingType} with a public name of ${publicName}.`);
      }
      const remappedPublicName = hostDirectiveBindings[publicName];
      if (bindings.hasOwnProperty(remappedPublicName) && remappedPublicName !== publicName) {
        throw new RuntimeError(312, `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${remappedPublicName}, because it already has a different ${bindingType} with the same public name.`);
      }
    }
  }
}
function templateCreate(tNode, declarationLView, declarationTView, index, templateFn, decls, vars, flags) {
  if (declarationTView.firstCreatePass) {
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
    const embeddedTView = tNode.tView = createTView(
      2,
      tNode,
      templateFn,
      decls,
      vars,
      declarationTView.directiveRegistry,
      declarationTView.pipeRegistry,
      null,
      declarationTView.schemas,
      declarationTView.consts,
      null
      /* ssrId */
    );
    if (declarationTView.queries !== null) {
      declarationTView.queries.template(declarationTView, tNode);
      embeddedTView.queries = declarationTView.queries.embeddedTView(tNode);
    }
  }
  if (flags) {
    tNode.flags |= flags;
  }
  setCurrentTNode(tNode, false);
  const comment2 = _locateOrCreateContainerAnchor(declarationTView, declarationLView, tNode, index);
  if (wasLastNodeCreated()) {
    appendChild(declarationTView, declarationLView, comment2, tNode);
  }
  attachPatchData(comment2, declarationLView);
  const lContainer = createLContainer(comment2, declarationLView, comment2, tNode);
  declarationLView[index + HEADER_OFFSET] = lContainer;
  addToEndOfViewTree(declarationLView, lContainer);
  populateDehydratedViewsInLContainer(lContainer, tNode, declarationLView);
}
function declareDirectiveHostTemplate(declarationLView, declarationTView, index, templateFn, decls, vars, tagName, attrs, flags, localRefsIndex, localRefExtractor) {
  const adjustedIndex = index + HEADER_OFFSET;
  let tNode;
  if (declarationTView.firstCreatePass) {
    tNode = getOrCreateTNode(declarationTView, adjustedIndex, 4, tagName || null, attrs || null);
    if (getBindingsEnabled()) {
      resolveDirectives(declarationTView, declarationLView, tNode, getConstant(declarationTView.consts, localRefsIndex), findDirectiveDefMatches);
    }
    registerPostOrderHooks(declarationTView, tNode);
  } else {
    tNode = declarationTView.data[adjustedIndex];
  }
  templateCreate(tNode, declarationLView, declarationTView, index, templateFn, decls, vars, flags);
  if (isDirectiveHost(tNode)) {
    createDirectivesInstances(declarationTView, declarationLView, tNode);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(declarationLView, tNode, localRefExtractor);
  }
  return tNode;
}
function declareNoDirectiveHostTemplate(declarationLView, declarationTView, index, templateFn, decls, vars, tagName, attrs, flags, localRefsIndex, localRefExtractor) {
  const adjustedIndex = index + HEADER_OFFSET;
  let tNode;
  if (declarationTView.firstCreatePass) {
    tNode = getOrCreateTNode(declarationTView, adjustedIndex, 4, tagName || null, attrs || null);
    if (localRefsIndex != null) {
      const refs = getConstant(declarationTView.consts, localRefsIndex);
      tNode.localNames = [];
      for (let i = 0; i < refs.length; i += 2) {
        tNode.localNames.push(refs[i], -1);
      }
    }
  } else {
    tNode = declarationTView.data[adjustedIndex];
  }
  templateCreate(tNode, declarationLView, declarationTView, index, templateFn, decls, vars, flags);
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(declarationLView, tNode, localRefExtractor);
  }
  return tNode;
}
function \u0275\u0275template(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  const lView = getLView();
  const tView = getTView();
  const attrs = getConstant(tView.consts, attrsIndex);
  declareDirectiveHostTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, void 0, localRefsIndex, localRefExtractor);
  return \u0275\u0275template;
}
function \u0275\u0275domTemplate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  const lView = getLView();
  const tView = getTView();
  const attrs = getConstant(tView.consts, attrsIndex);
  declareNoDirectiveHostTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, void 0, localRefsIndex, localRefExtractor);
  return \u0275\u0275domTemplate;
}
function createContainerAnchorImpl(tView, lView, tNode, index) {
  lastNodeWasCreated(true);
  return lView[RENDERER].createComment(ngDevMode ? "container" : "");
}
function storeTriggerCleanupFn(type, lDetails, cleanupFn) {
  const key = getCleanupFnKeyByType(type);
  if (lDetails[key] === null) {
    lDetails[key] = [];
  }
  lDetails[key].push(cleanupFn);
}
function invokeTriggerCleanupFns(type, lDetails) {
  const key = getCleanupFnKeyByType(type);
  const cleanupFns = lDetails[key];
  if (cleanupFns !== null) {
    for (const cleanupFn of cleanupFns) {
      cleanupFn();
    }
    lDetails[key] = null;
  }
}
function invokeAllTriggerCleanupFns(lDetails) {
  invokeTriggerCleanupFns(1, lDetails);
  invokeTriggerCleanupFns(0, lDetails);
  invokeTriggerCleanupFns(2, lDetails);
}
function getCleanupFnKeyByType(type) {
  let key = TRIGGER_CLEANUP_FNS;
  if (type === 1) {
    key = PREFETCH_TRIGGER_CLEANUP_FNS;
  } else if (type === 2) {
    key = HYDRATE_TRIGGER_CLEANUP_FNS;
  }
  return key;
}
function scheduleCallbackWithRafRace(callback) {
  let timeoutId;
  let animationFrameId;
  function cleanup() {
    callback = noop2;
    try {
      if (animationFrameId !== void 0 && typeof cancelAnimationFrame === "function") {
        cancelAnimationFrame(animationFrameId);
      }
      if (timeoutId !== void 0) {
        clearTimeout(timeoutId);
      }
    } catch {
    }
  }
  timeoutId = setTimeout(() => {
    callback();
    cleanup();
  });
  if (typeof requestAnimationFrame === "function") {
    animationFrameId = requestAnimationFrame(() => {
      callback();
      cleanup();
    });
  }
  return () => cleanup();
}
function scheduleCallbackWithMicrotask(callback) {
  queueMicrotask(() => callback());
  return () => {
    callback = noop2;
  };
}
function checkStable(zone) {
  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
    try {
      zone._nesting++;
      zone.onMicrotaskEmpty.emit(null);
    } finally {
      zone._nesting--;
      if (!zone.hasPendingMicrotasks) {
        try {
          zone.runOutsideAngular(() => zone.onStable.emit(null));
        } finally {
          zone.isStable = true;
        }
      }
    }
  }
}
function delayChangeDetectionForEvents(zone) {
  if (zone.isCheckStableRunning || zone.callbackScheduled) {
    return;
  }
  zone.callbackScheduled = true;
  function scheduleCheckStable() {
    scheduleCallbackWithRafRace(() => {
      zone.callbackScheduled = false;
      updateMicroTaskStatus(zone);
      zone.isCheckStableRunning = true;
      checkStable(zone);
      zone.isCheckStableRunning = false;
    });
  }
  if (zone.scheduleInRootZone) {
    Zone.root.run(() => {
      scheduleCheckStable();
    });
  } else {
    zone._outer.run(() => {
      scheduleCheckStable();
    });
  }
  updateMicroTaskStatus(zone);
}
function forkInnerZoneWithAngularBehavior(zone) {
  const delayChangeDetectionForEventsDelegate = () => {
    delayChangeDetectionForEvents(zone);
  };
  const instanceId = ngZoneInstanceId++;
  zone._inner = zone._inner.fork({
    name: "angular",
    properties: {
      [isAngularZoneProperty]: true,
      [angularZoneInstanceIdProperty]: instanceId,
      [angularZoneInstanceIdProperty + instanceId]: true
    },
    onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
      if (shouldBeIgnoredByZone(applyArgs)) {
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      }
      try {
        onEnter(zone);
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      } finally {
        if (zone.shouldCoalesceEventChangeDetection && task.type === "eventTask" || zone.shouldCoalesceRunChangeDetection) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
      try {
        onEnter(zone);
        return delegate.invoke(target, callback, applyThis, applyArgs, source);
      } finally {
        if (zone.shouldCoalesceRunChangeDetection && // Do not delay change detection when the task is the scheduler's tick.
        // We need to synchronously trigger the stability logic so that the
        // zone-based scheduler can prevent a duplicate ApplicationRef.tick
        // by first checking if the scheduler tick is running. This does seem a bit roundabout,
        // but we _do_ still want to trigger all the correct events when we exit the zone.run
        // (`onMicrotaskEmpty` and `onStable` _should_ emit; developers can have code which
        // relies on these events happening after change detection runs).
        // Note: `zone.callbackScheduled` is already in delayChangeDetectionForEventsDelegate
        // but is added here as well to prevent reads of applyArgs when not necessary
        !zone.callbackScheduled && !isSchedulerTick(applyArgs)) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onHasTask: (delegate, current, target, hasTaskState) => {
      delegate.hasTask(target, hasTaskState);
      if (current === target) {
        if (hasTaskState.change == "microTask") {
          zone._hasPendingMicrotasks = hasTaskState.microTask;
          updateMicroTaskStatus(zone);
          checkStable(zone);
        } else if (hasTaskState.change == "macroTask") {
          zone.hasPendingMacrotasks = hasTaskState.macroTask;
        }
      }
    },
    onHandleError: (delegate, current, target, error) => {
      delegate.handleError(target, error);
      zone.runOutsideAngular(() => zone.onError.emit(error));
      return false;
    }
  });
}
function updateMicroTaskStatus(zone) {
  if (zone._hasPendingMicrotasks || (zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) && zone.callbackScheduled === true) {
    zone.hasPendingMicrotasks = true;
  } else {
    zone.hasPendingMicrotasks = false;
  }
}
function onEnter(zone) {
  zone._nesting++;
  if (zone.isStable) {
    zone.isStable = false;
    zone.onUnstable.emit(null);
  }
}
function onLeave(zone) {
  zone._nesting--;
  checkStable(zone);
}
function shouldBeIgnoredByZone(applyArgs) {
  return hasApplyArgsData(applyArgs, "__ignore_ng_zone__");
}
function isSchedulerTick(applyArgs) {
  return hasApplyArgsData(applyArgs, "__scheduler_tick__");
}
function hasApplyArgsData(applyArgs, key) {
  if (!Array.isArray(applyArgs)) {
    return false;
  }
  if (applyArgs.length !== 1) {
    return false;
  }
  return applyArgs[0]?.data?.[key] === true;
}
function getNgZone(ngZoneToUse = "zone.js", options) {
  if (ngZoneToUse === "noop") {
    return new NoopNgZone();
  }
  if (ngZoneToUse === "zone.js") {
    return new NgZone(options);
  }
  return ngZoneToUse;
}
function afterEveryRender(callbackOrSpec, options) {
  ngDevMode && assertNotInReactiveContext(afterEveryRender, "Call `afterEveryRender` outside of a reactive context. For example, schedule the render callback inside the component constructor`.");
  if (ngDevMode && !options?.injector) {
    assertInInjectionContext(afterEveryRender);
  }
  const injector = options?.injector ?? inject2(Injector);
  if (false) {
    return NOOP_AFTER_RENDER_REF;
  }
  performanceMarkFeature("NgAfterRender");
  return afterEveryRenderImpl(
    callbackOrSpec,
    injector,
    options,
    /* once */
    false
  );
}
function afterNextRender(callbackOrSpec, options) {
  if (ngDevMode && !options?.injector) {
    assertInInjectionContext(afterNextRender);
  }
  const injector = options?.injector ?? inject2(Injector);
  if (false) {
    return NOOP_AFTER_RENDER_REF;
  }
  performanceMarkFeature("NgAfterNextRender");
  return afterEveryRenderImpl(
    callbackOrSpec,
    injector,
    options,
    /* once */
    true
  );
}
function getHooks(callbackOrSpec) {
  if (callbackOrSpec instanceof Function) {
    return [
      void 0,
      void 0,
      /* MixedReadWrite */
      callbackOrSpec,
      void 0
    ];
  } else {
    return [
      callbackOrSpec.earlyRead,
      callbackOrSpec.write,
      callbackOrSpec.mixedReadWrite,
      callbackOrSpec.read
    ];
  }
}
function afterEveryRenderImpl(callbackOrSpec, injector, options, once) {
  const manager = injector.get(AfterRenderManager);
  manager.impl ??= injector.get(AfterRenderImpl);
  const tracing = injector.get(TracingService, null, { optional: true });
  const destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;
  const viewContext = injector.get(ViewContext, null, { optional: true });
  const sequence = new AfterRenderSequence(manager.impl, getHooks(callbackOrSpec), viewContext?.view, once, destroyRef, tracing?.snapshot(null));
  manager.impl.register(sequence);
  return sequence;
}
function getDeferBlockDataIndex(deferBlockIndex) {
  return deferBlockIndex + 1;
}
function getLDeferBlockDetails(lView, tNode) {
  const tView = lView[TVIEW];
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  return lView[slotIndex];
}
function setLDeferBlockDetails(lView, deferBlockIndex, lDetails) {
  const tView = lView[TVIEW];
  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  lView[slotIndex] = lDetails;
}
function getTDeferBlockDetails(tView, tNode) {
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  return tView.data[slotIndex];
}
function setTDeferBlockDetails(tView, deferBlockIndex, deferBlockConfig) {
  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  tView.data[slotIndex] = deferBlockConfig;
}
function getTemplateIndexForState(newState, hostLView, tNode) {
  const tView = hostLView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  switch (newState) {
    case DeferBlockState.Complete:
      return tDetails.primaryTmplIndex;
    case DeferBlockState.Loading:
      return tDetails.loadingTmplIndex;
    case DeferBlockState.Error:
      return tDetails.errorTmplIndex;
    case DeferBlockState.Placeholder:
      return tDetails.placeholderTmplIndex;
    default:
      ngDevMode && throwError2(`Unexpected defer block state: ${newState}`);
      return null;
  }
}
function getMinimumDurationForState(tDetails, currentState) {
  if (currentState === DeferBlockState.Placeholder) {
    return tDetails.placeholderBlockConfig?.[MINIMUM_SLOT] ?? null;
  } else if (currentState === DeferBlockState.Loading) {
    return tDetails.loadingBlockConfig?.[MINIMUM_SLOT] ?? null;
  }
  return null;
}
function getLoadingBlockAfter(tDetails) {
  return tDetails.loadingBlockConfig?.[LOADING_AFTER_SLOT] ?? null;
}
function addDepsToRegistry(currentDeps, newDeps) {
  if (!currentDeps || currentDeps.length === 0) {
    return newDeps;
  }
  const currentDepSet = new Set(currentDeps);
  for (const dep of newDeps) {
    currentDepSet.add(dep);
  }
  return currentDeps.length === currentDepSet.size ? currentDeps : Array.from(currentDepSet);
}
function getPrimaryBlockTNode(tView, tDetails) {
  const adjustedIndex = tDetails.primaryTmplIndex + HEADER_OFFSET;
  return getTNode(tView, adjustedIndex);
}
function assertDeferredDependenciesLoaded(tDetails) {
  assertEqual(tDetails.loadingState, DeferDependenciesLoadingState.COMPLETE, "Expecting all deferred dependencies to be loaded.");
}
function isTDeferBlockDetails(value) {
  return value !== null && typeof value === "object" && typeof value.primaryTmplIndex === "number";
}
function trackTriggerForDebugging(tView, tNode, textRepresentation) {
  const tDetails = getTDeferBlockDetails(tView, tNode);
  tDetails.debug ??= {};
  tDetails.debug.triggers ??= /* @__PURE__ */ new Set();
  tDetails.debug.triggers.add(textRepresentation);
}
function onViewportWrapper(trigger, callback, injector) {
  const ngZone = injector.get(NgZone);
  return onViewport(trigger, () => ngZone.run(callback), () => ngZone.runOutsideAngular(() => createIntersectionObserver()));
}
function getTriggerLView(deferredHostLView, deferredTNode, walkUpTimes) {
  if (walkUpTimes == null) {
    return deferredHostLView;
  }
  if (walkUpTimes >= 0) {
    return walkUpViews(walkUpTimes, deferredHostLView);
  }
  const deferredContainer = deferredHostLView[deferredTNode.index];
  ngDevMode && assertLContainer(deferredContainer);
  const triggerLView = deferredContainer[CONTAINER_HEADER_OFFSET] ?? null;
  if (ngDevMode && triggerLView !== null) {
    const lDetails = getLDeferBlockDetails(deferredHostLView, deferredTNode);
    const renderedState = lDetails[DEFER_BLOCK_STATE];
    assertEqual(renderedState, DeferBlockState.Placeholder, "Expected a placeholder to be rendered in this defer block.");
    assertLView(triggerLView);
  }
  return triggerLView;
}
function getTriggerElement(triggerLView, triggerIndex) {
  const element = getNativeByIndex(HEADER_OFFSET + triggerIndex, triggerLView);
  ngDevMode && assertElement(element);
  return element;
}
function registerDomTrigger(initialLView, tNode, triggerIndex, walkUpTimes, registerFn, callback, type) {
  const injector = initialLView[INJECTOR];
  const zone = injector.get(NgZone);
  let poll;
  function pollDomTrigger() {
    if (isDestroyed(initialLView)) {
      poll.destroy();
      return;
    }
    const lDetails = getLDeferBlockDetails(initialLView, tNode);
    const renderedState = lDetails[DEFER_BLOCK_STATE];
    if (renderedState !== DeferBlockInternalState.Initial && renderedState !== DeferBlockState.Placeholder) {
      poll.destroy();
      return;
    }
    const triggerLView = getTriggerLView(initialLView, tNode, walkUpTimes);
    if (!triggerLView) {
      return;
    }
    poll.destroy();
    if (isDestroyed(triggerLView)) {
      return;
    }
    const element = getTriggerElement(triggerLView, triggerIndex);
    const cleanup = registerFn(element, () => {
      zone.run(() => {
        if (initialLView !== triggerLView) {
          removeLViewOnDestroy(triggerLView, cleanup);
        }
        callback();
      });
    }, injector);
    if (initialLView !== triggerLView) {
      storeLViewOnDestroy(triggerLView, cleanup);
    }
    storeTriggerCleanupFn(type, lDetails, cleanup);
  }
  poll = afterEveryRender({ read: pollDomTrigger }, { injector });
}
function onIdle(callback, injector) {
  const scheduler = injector.get(IdleScheduler);
  const cleanupFn = () => scheduler.remove(callback);
  scheduler.add(callback);
  return cleanupFn;
}
function onTimer(delay) {
  return (callback, injector) => scheduleTimerTrigger(delay, callback, injector);
}
function scheduleTimerTrigger(delay, callback, injector) {
  const scheduler = injector.get(TimerScheduler);
  const ngZone = injector.get(NgZone);
  const cleanupFn = () => scheduler.remove(callback);
  scheduler.add(delay, callback, ngZone);
  return cleanupFn;
}
function getOrCreateEnvironmentInjector(parentInjector, tDetails, providers) {
  return parentInjector.get(CachedInjectorService).getOrCreateInjector(tDetails, parentInjector, providers, ngDevMode ? "DeferBlock Injector" : "");
}
function createDeferBlockInjector(parentInjector, tDetails, providers) {
  if (parentInjector instanceof ChainedInjector) {
    const origInjector = parentInjector.injector;
    const parentEnvInjector2 = parentInjector.parentInjector;
    const envInjector = getOrCreateEnvironmentInjector(parentEnvInjector2, tDetails, providers);
    return new ChainedInjector(origInjector, envInjector);
  }
  const parentEnvInjector = parentInjector.get(EnvironmentInjector);
  if (parentEnvInjector !== parentInjector) {
    const envInjector = getOrCreateEnvironmentInjector(parentEnvInjector, tDetails, providers);
    return new ChainedInjector(parentInjector, envInjector);
  }
  return getOrCreateEnvironmentInjector(parentInjector, tDetails, providers);
}
function renderDeferBlockState(newState, tNode, lContainer, skipTimerScheduling = false) {
  const hostLView = lContainer[PARENT];
  const hostTView = hostLView[TVIEW];
  if (isDestroyed(hostLView))
    return;
  ngDevMode && assertTNodeForLView(tNode, hostLView);
  const lDetails = getLDeferBlockDetails(hostLView, tNode);
  ngDevMode && assertDefined(lDetails, "Expected a defer block state defined");
  const currentState = lDetails[DEFER_BLOCK_STATE];
  const ssrState = lDetails[SSR_BLOCK_STATE];
  if (ssrState !== null && newState < ssrState) {
    return;
  }
  if (isValidStateChange(currentState, newState) && isValidStateChange(lDetails[NEXT_DEFER_BLOCK_STATE] ?? -1, newState)) {
    const tDetails = getTDeferBlockDetails(hostTView, tNode);
    const needsScheduling = !skipTimerScheduling && true && (getLoadingBlockAfter(tDetails) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Loading) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Placeholder));
    if (ngDevMode && needsScheduling) {
      assertDefined(applyDeferBlockStateWithSchedulingImpl, "Expected scheduling function to be defined");
    }
    const applyStateFn = needsScheduling ? applyDeferBlockStateWithSchedulingImpl : applyDeferBlockState;
    try {
      applyStateFn(newState, lDetails, lContainer, tNode, hostLView);
    } catch (error) {
      handleUncaughtError(hostLView, error);
    }
  }
}
function findMatchingDehydratedViewForDeferBlock(lContainer, lDetails) {
  const dehydratedViewIx = lContainer[DEHYDRATED_VIEWS]?.findIndex((view) => view.data[DEFER_BLOCK_STATE$1] === lDetails[DEFER_BLOCK_STATE]) ?? -1;
  const dehydratedView = dehydratedViewIx > -1 ? lContainer[DEHYDRATED_VIEWS][dehydratedViewIx] : null;
  return { dehydratedView, dehydratedViewIx };
}
function applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView) {
  profiler(
    20
    /* ProfilerEvent.DeferBlockStateStart */
  );
  const stateTmplIndex = getTemplateIndexForState(newState, hostLView, tNode);
  if (stateTmplIndex !== null) {
    lDetails[DEFER_BLOCK_STATE] = newState;
    const hostTView = hostLView[TVIEW];
    const adjustedIndex = stateTmplIndex + HEADER_OFFSET;
    const activeBlockTNode = getTNode(hostTView, adjustedIndex);
    const viewIndex = 0;
    removeLViewFromLContainer(lContainer, viewIndex);
    let injector;
    if (newState === DeferBlockState.Complete) {
      const tDetails = getTDeferBlockDetails(hostTView, tNode);
      const providers = tDetails.providers;
      if (providers && providers.length > 0) {
        injector = createDeferBlockInjector(hostLView[INJECTOR], tDetails, providers);
      }
    }
    const { dehydratedView, dehydratedViewIx } = findMatchingDehydratedViewForDeferBlock(lContainer, lDetails);
    const embeddedLView = createAndRenderEmbeddedLView(hostLView, activeBlockTNode, null, {
      injector,
      dehydratedView
    });
    addLViewToLContainer(lContainer, embeddedLView, viewIndex, shouldAddViewToDom(activeBlockTNode, dehydratedView));
    markViewDirty(
      embeddedLView,
      2
      /* NotificationSource.DeferBlockStateUpdate */
    );
    if (dehydratedViewIx > -1) {
      lContainer[DEHYDRATED_VIEWS]?.splice(dehydratedViewIx, 1);
    }
    if ((newState === DeferBlockState.Complete || newState === DeferBlockState.Error) && Array.isArray(lDetails[ON_COMPLETE_FNS])) {
      for (const callback of lDetails[ON_COMPLETE_FNS]) {
        callback();
      }
      lDetails[ON_COMPLETE_FNS] = null;
    }
  }
  profiler(
    21
    /* ProfilerEvent.DeferBlockStateEnd */
  );
}
function applyDeferBlockStateWithScheduling(newState, lDetails, lContainer, tNode, hostLView) {
  const now = Date.now();
  const hostTView = hostLView[TVIEW];
  const tDetails = getTDeferBlockDetails(hostTView, tNode);
  if (lDetails[STATE_IS_FROZEN_UNTIL] === null || lDetails[STATE_IS_FROZEN_UNTIL] <= now) {
    lDetails[STATE_IS_FROZEN_UNTIL] = null;
    const loadingAfter = getLoadingBlockAfter(tDetails);
    const inLoadingAfterPhase = lDetails[LOADING_AFTER_CLEANUP_FN] !== null;
    if (newState === DeferBlockState.Loading && loadingAfter !== null && !inLoadingAfterPhase) {
      lDetails[NEXT_DEFER_BLOCK_STATE] = newState;
      const cleanupFn = scheduleDeferBlockUpdate(loadingAfter, lDetails, tNode, lContainer, hostLView);
      lDetails[LOADING_AFTER_CLEANUP_FN] = cleanupFn;
    } else {
      if (newState > DeferBlockState.Loading && inLoadingAfterPhase) {
        lDetails[LOADING_AFTER_CLEANUP_FN]();
        lDetails[LOADING_AFTER_CLEANUP_FN] = null;
        lDetails[NEXT_DEFER_BLOCK_STATE] = null;
      }
      applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView);
      const duration = getMinimumDurationForState(tDetails, newState);
      if (duration !== null) {
        lDetails[STATE_IS_FROZEN_UNTIL] = now + duration;
        scheduleDeferBlockUpdate(duration, lDetails, tNode, lContainer, hostLView);
      }
    }
  } else {
    lDetails[NEXT_DEFER_BLOCK_STATE] = newState;
  }
}
function scheduleDeferBlockUpdate(timeout, lDetails, tNode, lContainer, hostLView) {
  const callback = () => {
    const nextState = lDetails[NEXT_DEFER_BLOCK_STATE];
    lDetails[STATE_IS_FROZEN_UNTIL] = null;
    lDetails[NEXT_DEFER_BLOCK_STATE] = null;
    if (nextState !== null) {
      renderDeferBlockState(nextState, tNode, lContainer);
    }
  };
  return scheduleTimerTrigger(timeout, callback, hostLView[INJECTOR]);
}
function isValidStateChange(currentState, newState) {
  return currentState < newState;
}
function renderPlaceholder(lView, tNode) {
  const lContainer = lView[tNode.index];
  ngDevMode && assertLContainer(lContainer);
  renderDeferBlockState(DeferBlockState.Placeholder, tNode, lContainer);
}
function renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer) {
  ngDevMode && assertDefined(tDetails.loadingPromise, "Expected loading Promise to exist on this defer block");
  tDetails.loadingPromise.then(() => {
    if (tDetails.loadingState === DeferDependenciesLoadingState.COMPLETE) {
      ngDevMode && assertDeferredDependenciesLoaded(tDetails);
      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);
    } else if (tDetails.loadingState === DeferDependenciesLoadingState.FAILED) {
      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);
    }
  });
}
function \u0275\u0275deferEnableTimerScheduling(tView, tDetails, placeholderConfigIndex, loadingConfigIndex) {
  const tViewConsts = tView.consts;
  if (placeholderConfigIndex != null) {
    tDetails.placeholderBlockConfig = getConstant(tViewConsts, placeholderConfigIndex);
  }
  if (loadingConfigIndex != null) {
    tDetails.loadingBlockConfig = getConstant(tViewConsts, loadingConfigIndex);
  }
  if (applyDeferBlockStateWithSchedulingImpl === null) {
    applyDeferBlockStateWithSchedulingImpl = applyDeferBlockStateWithScheduling;
  }
}
function setClassMetadata(type, decorators, ctorParameters, propDecorators) {
  return noSideEffects(() => {
    const clazz = type;
    if (decorators !== null) {
      if (clazz.hasOwnProperty("decorators") && clazz.decorators !== void 0) {
        clazz.decorators.push(...decorators);
      } else {
        clazz.decorators = decorators;
      }
    }
    if (ctorParameters !== null) {
      clazz.ctorParameters = ctorParameters;
    }
    if (propDecorators !== null) {
      if (clazz.hasOwnProperty("propDecorators") && clazz.propDecorators !== void 0) {
        clazz.propDecorators = __spreadValues(__spreadValues({}, clazz.propDecorators), propDecorators);
      } else {
        clazz.propDecorators = propDecorators;
      }
    }
  });
}
function getFrameworkDIDebugData() {
  return frameworkDIDebugData;
}
function setupFrameworkInjectorProfiler() {
  frameworkDIDebugData.reset();
  setInjectorProfiler(injectorProfilerEventHandler);
}
function injectorProfilerEventHandler(injectorProfilerEvent) {
  const { context: context2, type } = injectorProfilerEvent;
  if (type === 0) {
    handleInjectEvent(context2, injectorProfilerEvent.service);
  } else if (type === 1) {
    handleInstanceCreatedByInjectorEvent(context2, injectorProfilerEvent.instance);
  } else if (type === 2) {
    handleProviderConfiguredEvent(context2, injectorProfilerEvent.providerRecord);
  } else if (type === 3) {
    handleEffectCreatedEvent(context2, injectorProfilerEvent.effect);
  }
}
function handleEffectCreatedEvent(context2, effect2) {
  const diResolver = getDIResolver(context2.injector);
  if (diResolver === null) {
    throwError2("An EffectCreated event must be run within an injection context.");
  }
  const { resolverToEffects } = frameworkDIDebugData;
  if (!resolverToEffects.has(diResolver)) {
    resolverToEffects.set(diResolver, []);
  }
  resolverToEffects.get(diResolver).push(effect2);
}
function handleInjectEvent(context2, data2) {
  const diResolver = getDIResolver(context2.injector);
  if (diResolver === null) {
    throwError2("An Inject event must be run within an injection context.");
  }
  const diResolverToInstantiatedToken = frameworkDIDebugData.resolverToTokenToDependencies;
  if (!diResolverToInstantiatedToken.has(diResolver)) {
    diResolverToInstantiatedToken.set(diResolver, /* @__PURE__ */ new WeakMap());
  }
  if (!canBeHeldWeakly(context2.token)) {
    return;
  }
  const instantiatedTokenToDependencies = diResolverToInstantiatedToken.get(diResolver);
  if (!instantiatedTokenToDependencies.has(context2.token)) {
    instantiatedTokenToDependencies.set(context2.token, []);
  }
  const { token, value, flags } = data2;
  assertDefined(context2.token, "Injector profiler context token is undefined.");
  const dependencies = instantiatedTokenToDependencies.get(context2.token);
  assertDefined(dependencies, "Could not resolve dependencies for token.");
  if (context2.injector instanceof NodeInjector) {
    dependencies.push({ token, value, flags, injectedIn: getNodeInjectorContext(context2.injector) });
  } else {
    dependencies.push({ token, value, flags });
  }
}
function getNodeInjectorContext(injector) {
  if (!(injector instanceof NodeInjector)) {
    throwError2("getNodeInjectorContext must be called with a NodeInjector");
  }
  const lView = getNodeInjectorLView(injector);
  const tNode = getNodeInjectorTNode(injector);
  if (tNode === null) {
    return;
  }
  assertTNodeForLView(tNode, lView);
  return { lView, tNode };
}
function handleInstanceCreatedByInjectorEvent(context2, data2) {
  const { value } = data2;
  if (data2.value == null) {
    return;
  }
  if (getDIResolver(context2.injector) === null) {
    throwError2("An InjectorCreatedInstance event must be run within an injection context.");
  }
  let standaloneComponent = void 0;
  if (typeof value === "object") {
    standaloneComponent = value?.constructor;
  }
  if (standaloneComponent == void 0 || !isStandaloneComponent(standaloneComponent)) {
    return;
  }
  const environmentInjector = context2.injector.get(EnvironmentInjector, null, { optional: true });
  if (environmentInjector === null) {
    return;
  }
  const { standaloneInjectorToComponent } = frameworkDIDebugData;
  if (standaloneInjectorToComponent.has(environmentInjector)) {
    return;
  }
  standaloneInjectorToComponent.set(environmentInjector, standaloneComponent);
}
function isStandaloneComponent(value) {
  const def = getComponentDef(value);
  return !!def?.standalone;
}
function handleProviderConfiguredEvent(context2, data2) {
  const { resolverToProviders } = frameworkDIDebugData;
  let diResolver;
  if (context2?.injector instanceof NodeInjector) {
    diResolver = getNodeInjectorTNode(context2.injector);
  } else {
    diResolver = context2.injector;
  }
  if (diResolver === null) {
    throwError2("A ProviderConfigured event must be run within an injection context.");
  }
  if (!resolverToProviders.has(diResolver)) {
    resolverToProviders.set(diResolver, []);
  }
  resolverToProviders.get(diResolver).push(data2);
}
function getDIResolver(injector) {
  let diResolver = null;
  if (injector === void 0) {
    return diResolver;
  }
  if (injector instanceof NodeInjector) {
    diResolver = getNodeInjectorLView(injector);
  } else {
    diResolver = injector;
  }
  return diResolver;
}
function canBeHeldWeakly(value) {
  return value !== null && (typeof value === "object" || typeof value === "function" || typeof value === "symbol");
}
function applyChanges(component) {
  ngDevMode && assertDefined(component, "component");
  markViewDirty(
    getComponentViewByInstance(component),
    3
    /* NotificationSource.DebugApplyChanges */
  );
  getRootComponents(component).forEach((rootComponent) => detectChanges(rootComponent));
}
function detectChanges(component) {
  const view = getComponentViewByInstance(component);
  view[FLAGS] |= 1024;
  detectChangesInternal(view);
}
function getDeferBlocks$1(lView, deferBlocks) {
  const tView = lView[TVIEW];
  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    if (isLContainer(lView[i])) {
      const lContainer = lView[i];
      const isLast = i === tView.bindingStartIndex - 1;
      if (!isLast) {
        const tNode = tView.data[i];
        const tDetails = getTDeferBlockDetails(tView, tNode);
        if (isTDeferBlockDetails(tDetails)) {
          deferBlocks.push({ lContainer, lView, tNode, tDetails });
          continue;
        }
      }
      if (isLView(lContainer[HOST])) {
        getDeferBlocks$1(lContainer[HOST], deferBlocks);
      }
      for (let j = CONTAINER_HEADER_OFFSET; j < lContainer.length; j++) {
        getDeferBlocks$1(lContainer[j], deferBlocks);
      }
    } else if (isLView(lView[i])) {
      getDeferBlocks$1(lView[i], deferBlocks);
    }
  }
}
function getDeferBlocks(node) {
  const results = [];
  const lView = getLContext(node)?.lView;
  if (lView) {
    findDeferBlocks(node, lView, results);
  }
  return results;
}
function findDeferBlocks(node, lView, results) {
  const viewInjector = lView[INJECTOR];
  const registry = viewInjector.get(DEHYDRATED_BLOCK_REGISTRY, null, { optional: true });
  const blocks = [];
  getDeferBlocks$1(lView, blocks);
  const transferState = viewInjector.get(TransferState);
  const deferBlockParents = transferState.get(NGH_DEFER_BLOCKS_KEY, {});
  for (const details of blocks) {
    const native = getNativeByTNode(details.tNode, details.lView);
    const lDetails = getLDeferBlockDetails(details.lView, details.tNode);
    if (!node.contains(native)) {
      continue;
    }
    const tDetails = details.tDetails;
    const renderedLView = getRendererLView(details);
    const rootNodes = [];
    const hydrationState = inferHydrationState(tDetails, lDetails, registry);
    if (renderedLView !== null) {
      collectNativeNodes(renderedLView[TVIEW], renderedLView, renderedLView[TVIEW].firstChild, rootNodes);
    } else if (hydrationState === "dehydrated") {
      const deferId = lDetails[SSR_UNIQUE_ID];
      const deferData = deferBlockParents[deferId];
      const numberOfRootNodes = deferData[NUM_ROOT_NODES];
      let collectedNodeCount = 0;
      const deferBlockCommentNode = details.lContainer[NATIVE];
      let currentNode = deferBlockCommentNode.previousSibling;
      while (collectedNodeCount < numberOfRootNodes && currentNode) {
        rootNodes.unshift(currentNode);
        currentNode = currentNode.previousSibling;
        collectedNodeCount++;
      }
    }
    const data2 = {
      state: stringifyState(lDetails[DEFER_BLOCK_STATE]),
      incrementalHydrationState: hydrationState,
      hasErrorBlock: tDetails.errorTmplIndex !== null,
      loadingBlock: {
        exists: tDetails.loadingTmplIndex !== null,
        minimumTime: tDetails.loadingBlockConfig?.[MINIMUM_SLOT] ?? null,
        afterTime: tDetails.loadingBlockConfig?.[LOADING_AFTER_SLOT] ?? null
      },
      placeholderBlock: {
        exists: tDetails.placeholderTmplIndex !== null,
        minimumTime: tDetails.placeholderBlockConfig?.[MINIMUM_SLOT] ?? null
      },
      triggers: tDetails.debug?.triggers ? Array.from(tDetails.debug.triggers).sort() : [],
      rootNodes
    };
    results.push(data2);
    if (renderedLView !== null) {
      findDeferBlocks(node, renderedLView, results);
    }
  }
}
function stringifyState(state) {
  switch (state) {
    case DeferBlockState.Complete:
      return "complete";
    case DeferBlockState.Loading:
      return "loading";
    case DeferBlockState.Placeholder:
      return "placeholder";
    case DeferBlockState.Error:
      return "error";
    case DeferBlockInternalState.Initial:
      return "initial";
    default:
      throw new Error(`Unrecognized state ${state}`);
  }
}
function inferHydrationState(tDetails, lDetails, registry) {
  if (registry === null || lDetails[SSR_UNIQUE_ID] === null || tDetails.hydrateTriggers === null || tDetails.hydrateTriggers.has(
    7
    /* DeferBlockTrigger.Never */
  )) {
    return "not-configured";
  }
  return registry.has(lDetails[SSR_UNIQUE_ID]) ? "dehydrated" : "hydrated";
}
function getRendererLView(details) {
  if (details.lContainer.length <= CONTAINER_HEADER_OFFSET) {
    return null;
  }
  const lView = details.lContainer[CONTAINER_HEADER_OFFSET];
  ngDevMode && assertLView(lView);
  return lView;
}
function getDependenciesFromInjectable(injector, token) {
  const instance = injector.get(token, null, { self: true, optional: true });
  if (instance === null) {
    throw new Error(`Unable to determine instance of ${token} in given injector`);
  }
  const unformattedDependencies = getDependenciesForTokenInInjector(token, injector);
  const resolutionPath = getInjectorResolutionPath(injector);
  const dependencies = unformattedDependencies.map((dep) => {
    const formattedDependency = {
      value: dep.value
    };
    const flags = dep.flags;
    formattedDependency.flags = {
      optional: (8 & flags) === 8,
      host: (1 & flags) === 1,
      self: (2 & flags) === 2,
      skipSelf: (4 & flags) === 4
    };
    for (let i = 0; i < resolutionPath.length; i++) {
      const injectorToCheck = resolutionPath[i];
      if (i === 0 && formattedDependency.flags.skipSelf) {
        continue;
      }
      if (formattedDependency.flags.host && injectorToCheck instanceof EnvironmentInjector) {
        break;
      }
      const instance2 = injectorToCheck.get(dep.token, null, {
        self: true,
        optional: true
      });
      if (instance2 !== null) {
        if (formattedDependency.flags.host) {
          const firstInjector = resolutionPath[0];
          const lookupFromFirstInjector = firstInjector.get(dep.token, null, __spreadProps(__spreadValues({}, formattedDependency.flags), {
            optional: true
          }));
          if (lookupFromFirstInjector !== null) {
            formattedDependency.providedIn = injectorToCheck;
          }
          break;
        }
        formattedDependency.providedIn = injectorToCheck;
        break;
      }
      if (i === 0 && formattedDependency.flags.self) {
        break;
      }
    }
    if (dep.token)
      formattedDependency.token = dep.token;
    return formattedDependency;
  });
  return { instance, dependencies };
}
function getDependenciesForTokenInInjector(token, injector) {
  const { resolverToTokenToDependencies } = getFrameworkDIDebugData();
  if (!(injector instanceof NodeInjector)) {
    return resolverToTokenToDependencies.get(injector)?.get?.(token) ?? [];
  }
  const lView = getNodeInjectorLView(injector);
  const tokenDependencyMap = resolverToTokenToDependencies.get(lView);
  const dependencies = tokenDependencyMap?.get(token) ?? [];
  return dependencies.filter((dependency) => {
    const dependencyNode = dependency.injectedIn?.tNode;
    if (dependencyNode === void 0) {
      return false;
    }
    const instanceNode = getNodeInjectorTNode(injector);
    assertTNode(dependencyNode);
    assertTNode(instanceNode);
    return dependencyNode === instanceNode;
  });
}
function getProviderImportsContainer(injector) {
  const { standaloneInjectorToComponent } = getFrameworkDIDebugData();
  if (standaloneInjectorToComponent.has(injector)) {
    return standaloneInjectorToComponent.get(injector);
  }
  const defTypeRef = injector.get(NgModuleRef$1, null, { self: true, optional: true });
  if (defTypeRef === null) {
    return null;
  }
  if (defTypeRef.instance === null) {
    return null;
  }
  return defTypeRef.instance.constructor;
}
function getNodeInjectorProviders(injector) {
  const diResolver = getNodeInjectorTNode(injector);
  const { resolverToProviders } = getFrameworkDIDebugData();
  return resolverToProviders.get(diResolver) ?? [];
}
function getProviderImportPaths(providerImportsContainer) {
  const providerToPath = /* @__PURE__ */ new Map();
  const visitedContainers = /* @__PURE__ */ new Set();
  const visitor = walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers);
  walkProviderTree(providerImportsContainer, visitor, [], /* @__PURE__ */ new Set());
  return providerToPath;
}
function walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers) {
  return (provider, container) => {
    if (!providerToPath.has(provider)) {
      providerToPath.set(provider, [container]);
    }
    if (!visitedContainers.has(container)) {
      for (const prov of providerToPath.keys()) {
        const existingImportPath = providerToPath.get(prov);
        let containerDef = getInjectorDef(container);
        if (!containerDef) {
          const ngModule = container.ngModule;
          containerDef = getInjectorDef(ngModule);
        }
        if (!containerDef) {
          return;
        }
        const lastContainerAddedToPath = existingImportPath[0];
        let isNextStepInPath = false;
        deepForEach(containerDef.imports, (moduleImport) => {
          if (isNextStepInPath) {
            return;
          }
          isNextStepInPath = moduleImport.ngModule === lastContainerAddedToPath || moduleImport === lastContainerAddedToPath;
          if (isNextStepInPath) {
            providerToPath.get(prov)?.unshift(container);
          }
        });
      }
    }
    visitedContainers.add(container);
  };
}
function getEnvironmentInjectorProviders(injector) {
  const providerRecordsWithoutImportPaths = getFrameworkDIDebugData().resolverToProviders.get(injector) ?? [];
  if (isPlatformInjector(injector)) {
    return providerRecordsWithoutImportPaths;
  }
  const providerImportsContainer = getProviderImportsContainer(injector);
  if (providerImportsContainer === null) {
    return providerRecordsWithoutImportPaths;
  }
  const providerToPath = getProviderImportPaths(providerImportsContainer);
  const providerRecords = [];
  for (const providerRecord of providerRecordsWithoutImportPaths) {
    const provider = providerRecord.provider;
    const token = provider.provide;
    if (token === ENVIRONMENT_INITIALIZER || token === INJECTOR_DEF_TYPES) {
      continue;
    }
    let importPath = providerToPath.get(provider) ?? [];
    const def = getComponentDef(providerImportsContainer);
    const isStandaloneComponent2 = !!def?.standalone;
    if (isStandaloneComponent2) {
      importPath = [providerImportsContainer, ...importPath];
    }
    providerRecords.push(__spreadProps(__spreadValues({}, providerRecord), { importPath }));
  }
  return providerRecords;
}
function isPlatformInjector(injector) {
  return injector instanceof R3Injector && injector.scopes.has("platform");
}
function getInjectorProviders(injector) {
  if (injector instanceof NodeInjector) {
    return getNodeInjectorProviders(injector);
  } else if (injector instanceof EnvironmentInjector) {
    return getEnvironmentInjectorProviders(injector);
  }
  throwError2("getInjectorProviders only supports NodeInjector and EnvironmentInjector");
}
function getInjectorMetadata(injector) {
  if (injector instanceof NodeInjector) {
    const lView = getNodeInjectorLView(injector);
    const tNode = getNodeInjectorTNode(injector);
    assertTNodeForLView(tNode, lView);
    return { type: "element", source: getNativeByTNode(tNode, lView) };
  }
  if (injector instanceof R3Injector) {
    return { type: "environment", source: injector.source ?? null };
  }
  if (injector instanceof NullInjector) {
    return { type: "null", source: null };
  }
  return null;
}
function getInjectorResolutionPath(injector) {
  const resolutionPath = [injector];
  getInjectorResolutionPathHelper(injector, resolutionPath);
  return resolutionPath;
}
function getInjectorResolutionPathHelper(injector, resolutionPath) {
  const parent = getInjectorParent(injector);
  if (parent === null) {
    if (injector instanceof NodeInjector) {
      const firstInjector = resolutionPath[0];
      if (firstInjector instanceof NodeInjector) {
        const moduleInjector = getModuleInjectorOfNodeInjector(firstInjector);
        if (moduleInjector === null) {
          throwError2("NodeInjector must have some connection to the module injector tree");
        }
        resolutionPath.push(moduleInjector);
        getInjectorResolutionPathHelper(moduleInjector, resolutionPath);
      }
      return resolutionPath;
    }
  } else {
    resolutionPath.push(parent);
    getInjectorResolutionPathHelper(parent, resolutionPath);
  }
  return resolutionPath;
}
function getInjectorParent(injector) {
  if (injector instanceof R3Injector) {
    return injector.parent;
  }
  let tNode;
  let lView;
  if (injector instanceof NodeInjector) {
    tNode = getNodeInjectorTNode(injector);
    lView = getNodeInjectorLView(injector);
  } else if (injector instanceof NullInjector) {
    return null;
  } else if (injector instanceof ChainedInjector) {
    return injector.parentInjector;
  } else {
    throwError2("getInjectorParent only support injectors of type R3Injector, NodeInjector, NullInjector");
  }
  const parentLocation = getParentInjectorLocation(tNode, lView);
  if (hasParentInjector(parentLocation)) {
    const parentInjectorIndex = getParentInjectorIndex(parentLocation);
    const parentLView = getParentInjectorView(parentLocation, lView);
    const parentTView = parentLView[TVIEW];
    const parentTNode = parentTView.data[
      parentInjectorIndex + 8
      /* NodeInjectorOffset.TNODE */
    ];
    return new NodeInjector(parentTNode, parentLView);
  } else {
    const chainedInjector = lView[INJECTOR];
    const injectorParent = chainedInjector.injector?.parent;
    if (injectorParent instanceof NodeInjector) {
      return injectorParent;
    }
  }
  return null;
}
function getModuleInjectorOfNodeInjector(injector) {
  let lView;
  if (injector instanceof NodeInjector) {
    lView = getNodeInjectorLView(injector);
  } else {
    throwError2("getModuleInjectorOfNodeInjector must be called with a NodeInjector");
  }
  const inj = lView[INJECTOR];
  const moduleInjector = inj instanceof ChainedInjector ? inj.parentInjector : inj.parent;
  if (!moduleInjector) {
    throwError2("NodeInjector must have some connection to the module injector tree");
  }
  return moduleInjector;
}
function isComputedNode(node) {
  return node.kind === "computed";
}
function isTemplateEffectNode(node) {
  return node.kind === "template";
}
function isSignalNode(node) {
  return node.kind === "signal";
}
function getTemplateConsumer(injector) {
  const tNode = getNodeInjectorTNode(injector);
  assertTNode(tNode);
  const lView = getNodeInjectorLView(injector);
  assertLView(lView);
  const templateLView = lView[tNode.index];
  if (isLView(templateLView)) {
    return templateLView[REACTIVE_TEMPLATE_CONSUMER] ?? null;
  }
  return null;
}
function getNodesAndEdgesFromSignalMap(signalMap) {
  const nodes = Array.from(signalMap.keys());
  const debugSignalGraphNodes = [];
  const edges = [];
  for (const [consumer, producers] of signalMap.entries()) {
    const consumerIndex = nodes.indexOf(consumer);
    let id2 = signalDebugMap.get(consumer);
    if (!id2) {
      counter$1++;
      id2 = counter$1.toString();
      signalDebugMap.set(consumer, id2);
    }
    if (isComputedNode(consumer)) {
      debugSignalGraphNodes.push({
        label: consumer.debugName,
        value: consumer.value,
        kind: consumer.kind,
        epoch: consumer.version,
        debuggableFn: consumer.computation,
        id: id2
      });
    } else if (isSignalNode(consumer)) {
      debugSignalGraphNodes.push({
        label: consumer.debugName,
        value: consumer.value,
        kind: consumer.kind,
        epoch: consumer.version,
        id: id2
      });
    } else if (isTemplateEffectNode(consumer)) {
      debugSignalGraphNodes.push({
        label: consumer.debugName ?? consumer.lView?.[HOST]?.tagName?.toLowerCase?.(),
        kind: consumer.kind,
        epoch: consumer.version,
        // The `lView[CONTEXT]` is a reference to an instance of the component's class.
        // We get the constructor so that `inspect(.constructor)` shows the component class.
        debuggableFn: consumer.lView?.[CONTEXT]?.constructor,
        id: id2
      });
    } else {
      debugSignalGraphNodes.push({
        label: consumer.debugName,
        kind: consumer.kind,
        epoch: consumer.version,
        id: id2
      });
    }
    for (const producer of producers) {
      edges.push({ consumer: consumerIndex, producer: nodes.indexOf(producer) });
    }
  }
  return { nodes: debugSignalGraphNodes, edges };
}
function extractEffectsFromInjector(injector) {
  let diResolver = injector;
  if (injector instanceof NodeInjector) {
    const lView = getNodeInjectorLView(injector);
    diResolver = lView;
  }
  const resolverToEffects = getFrameworkDIDebugData().resolverToEffects;
  const effects = resolverToEffects.get(diResolver) ?? [];
  return effects.map((effect2) => effect2[SIGNAL]);
}
function extractSignalNodesAndEdgesFromRoots(nodes, signalDependenciesMap = /* @__PURE__ */ new Map()) {
  for (const node of nodes) {
    if (signalDependenciesMap.has(node)) {
      continue;
    }
    const producerNodes = [];
    for (let link = node.producers; link !== void 0; link = link.nextProducer) {
      const producer = link.producer;
      producerNodes.push(producer);
    }
    signalDependenciesMap.set(node, producerNodes);
    extractSignalNodesAndEdgesFromRoots(producerNodes, signalDependenciesMap);
  }
  return signalDependenciesMap;
}
function getSignalGraph(injector) {
  let templateConsumer = null;
  if (!(injector instanceof NodeInjector) && !(injector instanceof R3Injector)) {
    return throwError2("getSignalGraph must be called with a NodeInjector or R3Injector");
  }
  if (injector instanceof NodeInjector) {
    templateConsumer = getTemplateConsumer(injector);
  }
  const nonTemplateEffectNodes = extractEffectsFromInjector(injector);
  const signalNodes = templateConsumer ? [templateConsumer, ...nonTemplateEffectNodes] : nonTemplateEffectNodes;
  const signalDependenciesMap = extractSignalNodesAndEdgesFromRoots(signalNodes);
  return getNodesAndEdgesFromSignalMap(signalDependenciesMap);
}
function measureStart(startEvent) {
  eventsStack.push([startEvent, counter]);
  console.timeStamp("Event_" + startEvent + "_" + counter++);
}
function measureEnd(startEvent, entryName, color) {
  const top2 = eventsStack.pop();
  assertDefined(top2, "Profiling error: could not find start event entry " + startEvent);
  assertEqual(top2[0], startEvent, `Profiling error: expected to see ${startEvent} event but got ${top2[0]}`);
  console.timeStamp(entryName, "Event_" + top2[0] + "_" + top2[1], void 0, "\u{1F170}\uFE0F Angular", void 0, color);
}
function getComponentMeasureName(instance) {
  return instance.constructor.name;
}
function getProviderTokenMeasureName(token) {
  if (isTypeProvider(token)) {
    return token.name;
  } else if (token.provide != null) {
    return getProviderTokenMeasureName(token.provide);
  }
  return token.toString();
}
function enableProfiling() {
  performanceMarkFeature("Chrome DevTools profiling");
  if (typeof ngDevMode !== "undefined" && ngDevMode) {
    const removeInjectorProfiler = setInjectorProfiler(chromeDevToolsInjectorProfiler);
    const removeProfiler3 = setProfiler(devToolsProfiler);
    return () => {
      removeInjectorProfiler();
      removeProfiler3();
    };
  }
  return () => {
  };
}
function publishDefaultGlobalUtils$1() {
  if (!_published) {
    _published = true;
    if (typeof window !== "undefined") {
      setupFrameworkInjectorProfiler();
    }
    for (const [methodName, method] of Object.entries(globalUtilsFunctions)) {
      publishGlobalUtil(methodName, method);
    }
  }
}
function publishGlobalUtil(name2, fn) {
  publishUtil(name2, fn);
}
function publishUtil(name2, fn) {
  if (typeof COMPILED === "undefined" || !COMPILED) {
    const w = _global;
    ngDevMode && assertDefined(fn, "function not defined");
    w[GLOBAL_PUBLISH_EXPANDO_KEY] ??= {};
    w[GLOBAL_PUBLISH_EXPANDO_KEY][name2] = fn;
  }
}
function setTestabilityGetter(getter) {
  _testabilityGetter = getter;
}
function isPromise2(obj) {
  return !!obj && typeof obj.then === "function";
}
function isSubscribable(obj) {
  return !!obj && typeof obj.subscribe === "function";
}
function provideAppInitializer(initializerFn) {
  return makeEnvironmentProviders([
    {
      provide: APP_INITIALIZER,
      multi: true,
      useValue: initializerFn
    }
  ]);
}
function publishDefaultGlobalUtils() {
  ngDevMode && publishDefaultGlobalUtils$1();
}
function publishSignalConfiguration() {
  setThrowInvalidWriteToSignalError(() => {
    let errorMessage = "";
    if (ngDevMode) {
      const activeConsumer2 = getActiveConsumer();
      errorMessage = activeConsumer2 && isReactiveLViewConsumer(activeConsumer2) ? "Writing to signals is not allowed while Angular renders the template (eg. interpolations)" : "Writing to signals is not allowed in a `computed`";
    }
    throw new RuntimeError(600, errorMessage);
  });
}
function isBoundToModule(cf) {
  return cf.isBoundToModule;
}
function optionsReducer(dst, objs) {
  if (Array.isArray(objs)) {
    return objs.reduce(optionsReducer, dst);
  }
  return __spreadValues(__spreadValues({}, dst), objs);
}
function warnIfDestroyed(destroyed) {
  if (destroyed) {
    console.warn(formatRuntimeError(406, "This instance of the `ApplicationRef` has already been destroyed."));
  }
}
function remove(list, el) {
  const index = list.indexOf(el);
  if (index > -1) {
    list.splice(index, 1);
  }
}
function scheduleDelayedTrigger(scheduleFn) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  renderPlaceholder(lView, tNode);
  if (!shouldTriggerDeferBlock(0, lView))
    return;
  const injector = lView[INJECTOR];
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const cleanupFn = scheduleFn(() => triggerDeferBlock(0, lView, tNode), injector);
  storeTriggerCleanupFn(0, lDetails, cleanupFn);
}
function scheduleDelayedPrefetching(scheduleFn, trigger) {
  if (false)
    return;
  const lView = getLView();
  const injector = lView[INJECTOR];
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    const lDetails = getLDeferBlockDetails(lView, tNode);
    const prefetch = () => triggerPrefetching(tDetails, lView, tNode);
    const cleanupFn = scheduleFn(prefetch, injector);
    storeTriggerCleanupFn(1, lDetails, cleanupFn);
  }
}
function scheduleDelayedHydrating(scheduleFn, lView, tNode) {
  if (false)
    return;
  const injector = lView[INJECTOR];
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const ssrUniqueId = lDetails[SSR_UNIQUE_ID];
  ngDevMode && assertSsrIdDefined(ssrUniqueId);
  const cleanupFn = scheduleFn(() => triggerHydrationFromBlockName(injector, ssrUniqueId), injector);
  storeTriggerCleanupFn(2, lDetails, cleanupFn);
}
function triggerPrefetching(tDetails, lView, tNode) {
  triggerResourceLoading(tDetails, lView, tNode);
}
function triggerResourceLoading(tDetails, lView, tNode) {
  const injector = lView[INJECTOR];
  const tView = lView[TVIEW];
  if (tDetails.loadingState !== DeferDependenciesLoadingState.NOT_STARTED) {
    return tDetails.loadingPromise ?? Promise.resolve();
  }
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const primaryBlockTNode = getPrimaryBlockTNode(tView, tDetails);
  tDetails.loadingState = DeferDependenciesLoadingState.IN_PROGRESS;
  invokeTriggerCleanupFns(1, lDetails);
  let dependenciesFn = tDetails.dependencyResolverFn;
  if (ngDevMode) {
    const deferDependencyInterceptor = injector.get(DEFER_BLOCK_DEPENDENCY_INTERCEPTOR, null, {
      optional: true
    });
    if (deferDependencyInterceptor) {
      dependenciesFn = deferDependencyInterceptor.intercept(dependenciesFn);
    }
  }
  const removeTask = injector.get(PendingTasks).add();
  if (!dependenciesFn) {
    tDetails.loadingPromise = Promise.resolve().then(() => {
      tDetails.loadingPromise = null;
      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;
      removeTask();
    });
    return tDetails.loadingPromise;
  }
  tDetails.loadingPromise = Promise.allSettled(dependenciesFn()).then((results) => {
    let failed = false;
    const directiveDefs = [];
    const pipeDefs = [];
    for (const result of results) {
      if (result.status === "fulfilled") {
        const dependency = result.value;
        const directiveDef = getComponentDef(dependency) || getDirectiveDef(dependency);
        if (directiveDef) {
          directiveDefs.push(directiveDef);
        } else {
          const pipeDef = getPipeDef(dependency);
          if (pipeDef) {
            pipeDefs.push(pipeDef);
          }
        }
      } else {
        failed = true;
        break;
      }
    }
    if (failed) {
      tDetails.loadingState = DeferDependenciesLoadingState.FAILED;
      if (tDetails.errorTmplIndex === null) {
        const templateLocation = ngDevMode ? getTemplateLocationDetails(lView) : "";
        const error = new RuntimeError(-750, ngDevMode && `Loading dependencies for \`@defer\` block failed, but no \`@error\` block was configured${templateLocation}. Consider using the \`@error\` block to render an error state.`);
        handleUncaughtError(lView, error);
      }
    } else {
      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;
      const primaryBlockTView = primaryBlockTNode.tView;
      if (directiveDefs.length > 0) {
        primaryBlockTView.directiveRegistry = addDepsToRegistry(primaryBlockTView.directiveRegistry, directiveDefs);
        const directiveTypes = directiveDefs.map((def) => def.type);
        const providers = internalImportProvidersFrom(false, ...directiveTypes);
        tDetails.providers = providers;
      }
      if (pipeDefs.length > 0) {
        primaryBlockTView.pipeRegistry = addDepsToRegistry(primaryBlockTView.pipeRegistry, pipeDefs);
      }
    }
  });
  return tDetails.loadingPromise.finally(() => {
    tDetails.loadingPromise = null;
    removeTask();
  });
}
function shouldTriggerDeferBlock(triggerType, lView) {
  if (triggerType === 0 && true && false) {
    return false;
  }
  const injector = lView[INJECTOR];
  const config3 = injector.get(DEFER_BLOCK_CONFIG, null, { optional: true });
  if (config3?.behavior === DeferBlockBehavior.Manual) {
    return false;
  }
  return true;
}
function triggerDeferBlock(triggerType, lView, tNode) {
  const tView = lView[TVIEW];
  const lContainer = lView[tNode.index];
  ngDevMode && assertLContainer(lContainer);
  if (!shouldTriggerDeferBlock(triggerType, lView))
    return;
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const tDetails = getTDeferBlockDetails(tView, tNode);
  invokeAllTriggerCleanupFns(lDetails);
  switch (tDetails.loadingState) {
    case DeferDependenciesLoadingState.NOT_STARTED:
      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);
      triggerResourceLoading(tDetails, lView, tNode);
      if (tDetails.loadingState === DeferDependenciesLoadingState.IN_PROGRESS) {
        renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);
      }
      break;
    case DeferDependenciesLoadingState.IN_PROGRESS:
      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);
      renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);
      break;
    case DeferDependenciesLoadingState.COMPLETE:
      ngDevMode && assertDeferredDependenciesLoaded(tDetails);
      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);
      break;
    case DeferDependenciesLoadingState.FAILED:
      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);
      break;
    default:
      if (ngDevMode) {
        throwError2("Unknown defer block state");
      }
  }
}
function triggerHydrationFromBlockName(injector, blockName, replayQueuedEventsFn) {
  return __async(this, null, function* () {
    const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;
    if (blocksBeingHydrated.has(blockName)) {
      return;
    }
    const { parentBlockPromise, hydrationQueue } = getParentBlockHydrationQueue(blockName, injector);
    if (hydrationQueue.length === 0)
      return;
    if (parentBlockPromise !== null) {
      hydrationQueue.shift();
    }
    populateHydratingStateForQueue(dehydratedBlockRegistry, hydrationQueue);
    if (parentBlockPromise !== null) {
      yield parentBlockPromise;
    }
    const topmostParentBlock = hydrationQueue[0];
    if (dehydratedBlockRegistry.has(topmostParentBlock)) {
      yield triggerHydrationForBlockQueue(injector, hydrationQueue, replayQueuedEventsFn);
    } else {
      dehydratedBlockRegistry.awaitParentBlock(topmostParentBlock, () => __async(null, null, function* () {
        return yield triggerHydrationForBlockQueue(injector, hydrationQueue, replayQueuedEventsFn);
      }));
    }
  });
}
function triggerHydrationForBlockQueue(injector, hydrationQueue, replayQueuedEventsFn) {
  return __async(this, null, function* () {
    const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;
    const pendingTasks = injector.get(PendingTasksInternal);
    const taskId = pendingTasks.add();
    for (let blockQueueIdx = 0; blockQueueIdx < hydrationQueue.length; blockQueueIdx++) {
      const dehydratedBlockId = hydrationQueue[blockQueueIdx];
      const dehydratedDeferBlock = dehydratedBlockRegistry.get(dehydratedBlockId);
      if (dehydratedDeferBlock != null) {
        yield triggerResourceLoadingForHydration(dehydratedDeferBlock);
        yield nextRender(injector);
        if (deferBlockHasErrored(dehydratedDeferBlock)) {
          removeDehydratedViewList(dehydratedDeferBlock);
          cleanupRemainingHydrationQueue(hydrationQueue.slice(blockQueueIdx), dehydratedBlockRegistry);
          break;
        }
        blocksBeingHydrated.get(dehydratedBlockId).resolve();
      } else {
        cleanupParentContainer(blockQueueIdx, hydrationQueue, dehydratedBlockRegistry);
        cleanupRemainingHydrationQueue(hydrationQueue.slice(blockQueueIdx), dehydratedBlockRegistry);
        break;
      }
    }
    const lastBlockName = hydrationQueue[hydrationQueue.length - 1];
    yield blocksBeingHydrated.get(lastBlockName)?.promise;
    pendingTasks.remove(taskId);
    if (replayQueuedEventsFn) {
      replayQueuedEventsFn(hydrationQueue);
    }
    cleanupHydratedDeferBlocks(dehydratedBlockRegistry.get(lastBlockName), hydrationQueue, dehydratedBlockRegistry, injector.get(ApplicationRef));
  });
}
function deferBlockHasErrored(deferBlock) {
  return getLDeferBlockDetails(deferBlock.lView, deferBlock.tNode)[DEFER_BLOCK_STATE] === DeferBlockState.Error;
}
function cleanupParentContainer(currentBlockIdx, hydrationQueue, dehydratedBlockRegistry) {
  const parentDeferBlockIdx = currentBlockIdx - 1;
  const parentDeferBlock = parentDeferBlockIdx > -1 ? dehydratedBlockRegistry.get(hydrationQueue[parentDeferBlockIdx]) : null;
  if (parentDeferBlock) {
    cleanupLContainer(parentDeferBlock.lContainer);
  }
}
function cleanupRemainingHydrationQueue(hydrationQueue, dehydratedBlockRegistry) {
  const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;
  for (const dehydratedBlockId in hydrationQueue) {
    blocksBeingHydrated.get(dehydratedBlockId)?.reject();
  }
  dehydratedBlockRegistry.cleanup(hydrationQueue);
}
function populateHydratingStateForQueue(registry, queue) {
  for (let blockId of queue) {
    registry.hydrating.set(blockId, Promise.withResolvers());
  }
}
function nextRender(injector) {
  return new Promise((resolveFn) => afterNextRender(resolveFn, { injector }));
}
function triggerResourceLoadingForHydration(dehydratedBlock) {
  return __async(this, null, function* () {
    const { tNode, lView } = dehydratedBlock;
    const lDetails = getLDeferBlockDetails(lView, tNode);
    return new Promise((resolve) => {
      onDeferBlockCompletion(lDetails, resolve);
      triggerDeferBlock(2, lView, tNode);
    });
  });
}
function onDeferBlockCompletion(lDetails, callback) {
  if (!Array.isArray(lDetails[ON_COMPLETE_FNS])) {
    lDetails[ON_COMPLETE_FNS] = [];
  }
  lDetails[ON_COMPLETE_FNS].push(callback);
}
function shouldAttachTrigger(triggerType, lView, tNode) {
  if (triggerType === 0) {
    return shouldAttachRegularTrigger(lView, tNode);
  } else if (triggerType === 2) {
    return !shouldAttachRegularTrigger(lView, tNode);
  }
  return true;
}
function hasHydrateTriggers(flags) {
  return flags != null && (flags & 1) === 1;
}
function shouldAttachRegularTrigger(lView, tNode) {
  const injector = lView[INJECTOR];
  const tDetails = getTDeferBlockDetails(lView[TVIEW], tNode);
  const incrementalHydrationEnabled = isIncrementalHydrationEnabled(injector);
  const _hasHydrateTriggers = hasHydrateTriggers(tDetails.flags);
  if (false) {
    return !incrementalHydrationEnabled || !_hasHydrateTriggers;
  }
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const wasServerSideRendered = lDetails[SSR_UNIQUE_ID] !== null;
  if (_hasHydrateTriggers && wasServerSideRendered && incrementalHydrationEnabled) {
    return false;
  }
  return true;
}
function getHydrateTriggers(tView, tNode) {
  const tDetails = getTDeferBlockDetails(tView, tNode);
  return tDetails.hydrateTriggers ??= /* @__PURE__ */ new Map();
}
function \u0275\u0275defer(index, primaryTmplIndex, dependencyResolverFn, loadingTmplIndex, placeholderTmplIndex, errorTmplIndex, loadingConfigIndex, placeholderConfigIndex, enableTimerScheduling, flags) {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = declareNoDirectiveHostTemplate(lView, tView, index, null, 0, 0);
  const injector = lView[INJECTOR];
  if (tView.firstCreatePass) {
    performanceMarkFeature("NgDefer");
    if (ngDevMode) {
      if (false) {
        logHmrWarning(injector);
      }
      if (hasHydrateTriggers(flags)) {
        assertIncrementalHydrationIsConfigured(injector);
      }
    }
    const tDetails = {
      primaryTmplIndex,
      loadingTmplIndex: loadingTmplIndex ?? null,
      placeholderTmplIndex: placeholderTmplIndex ?? null,
      errorTmplIndex: errorTmplIndex ?? null,
      placeholderBlockConfig: null,
      loadingBlockConfig: null,
      dependencyResolverFn: dependencyResolverFn ?? null,
      loadingState: DeferDependenciesLoadingState.NOT_STARTED,
      loadingPromise: null,
      providers: null,
      hydrateTriggers: null,
      debug: null,
      flags: flags ?? 0
    };
    enableTimerScheduling?.(tView, tDetails, placeholderConfigIndex, loadingConfigIndex);
    setTDeferBlockDetails(tView, adjustedIndex, tDetails);
  }
  const lContainer = lView[adjustedIndex];
  populateDehydratedViewsInLContainer(lContainer, tNode, lView);
  let ssrBlockState = null;
  let ssrUniqueId = null;
  if (lContainer[DEHYDRATED_VIEWS]?.length > 0) {
    const info = lContainer[DEHYDRATED_VIEWS][0].data;
    ssrUniqueId = info[DEFER_BLOCK_ID] ?? null;
    ssrBlockState = info[DEFER_BLOCK_STATE$1];
  }
  const lDetails = [
    null,
    // NEXT_DEFER_BLOCK_STATE
    DeferBlockInternalState.Initial,
    // DEFER_BLOCK_STATE
    null,
    // STATE_IS_FROZEN_UNTIL
    null,
    // LOADING_AFTER_CLEANUP_FN
    null,
    // TRIGGER_CLEANUP_FNS
    null,
    // PREFETCH_TRIGGER_CLEANUP_FNS
    ssrUniqueId,
    // SSR_UNIQUE_ID
    ssrBlockState,
    // SSR_BLOCK_STATE
    null,
    // ON_COMPLETE_FNS
    null
    // HYDRATE_TRIGGER_CLEANUP_FNS
  ];
  setLDeferBlockDetails(lView, adjustedIndex, lDetails);
  let registry = null;
  if (ssrUniqueId !== null) {
    registry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    registry.add(ssrUniqueId, { lView, tNode, lContainer });
  }
  const onLViewDestroy = () => {
    invokeAllTriggerCleanupFns(lDetails);
    if (ssrUniqueId !== null) {
      registry?.cleanup([ssrUniqueId]);
    }
  };
  storeTriggerCleanupFn(0, lDetails, () => removeLViewOnDestroy(lView, onLViewDestroy));
  storeLViewOnDestroy(lView, onLViewDestroy);
}
function \u0275\u0275deferWhen(rawValue) {
  const lView = getLView();
  const tNode = getSelectedTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "when <expression>");
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      const value = Boolean(rawValue);
      const lDetails = getLDeferBlockDetails(lView, tNode);
      const renderedState = lDetails[DEFER_BLOCK_STATE];
      if (value === false && renderedState === DeferBlockInternalState.Initial) {
        renderPlaceholder(lView, tNode);
      } else if (value === true && (renderedState === DeferBlockInternalState.Initial || renderedState === DeferBlockState.Placeholder)) {
        triggerDeferBlock(0, lView, tNode);
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function \u0275\u0275deferPrefetchWhen(rawValue) {
  const lView = getLView();
  const tNode = getSelectedTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "prefetch when <expression>");
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      const value = Boolean(rawValue);
      const tView = lView[TVIEW];
      const tNode2 = getSelectedTNode();
      const tDetails = getTDeferBlockDetails(tView, tNode2);
      if (value === true && tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
        triggerPrefetching(tDetails, lView, tNode2);
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function \u0275\u0275deferHydrateWhen(rawValue) {
  const lView = getLView();
  const tNode = getSelectedTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "hydrate when <expression>");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const bindingIndex = nextBindingIndex();
  const tView = getTView();
  const hydrateTriggers = getHydrateTriggers(tView, tNode);
  hydrateTriggers.set(6, null);
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    if (false) {
      triggerDeferBlock(2, lView, tNode);
    } else {
      const injector = lView[INJECTOR];
      const prevConsumer = setActiveConsumer(null);
      try {
        const value = Boolean(rawValue);
        if (value === true) {
          const lDetails = getLDeferBlockDetails(lView, tNode);
          const ssrUniqueId = lDetails[SSR_UNIQUE_ID];
          ngDevMode && assertSsrIdDefined(ssrUniqueId);
          triggerHydrationFromBlockName(injector, ssrUniqueId);
        }
      } finally {
        setActiveConsumer(prevConsumer);
      }
    }
  }
}
function \u0275\u0275deferHydrateNever() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "hydrate never");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
  hydrateTriggers.set(7, null);
  if (false) {
    triggerDeferBlock(2, lView, tNode);
  }
}
function \u0275\u0275deferOnIdle() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "on idle");
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  scheduleDelayedTrigger(onIdle);
}
function \u0275\u0275deferPrefetchOnIdle() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "prefetch on idle");
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  scheduleDelayedPrefetching(onIdle);
}
function \u0275\u0275deferHydrateOnIdle() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "hydrate on idle");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
  hydrateTriggers.set(0, null);
  if (false) {
    triggerDeferBlock(2, lView, tNode);
  } else {
    scheduleDelayedHydrating(onIdle, lView, tNode);
  }
}
function \u0275\u0275deferOnImmediate() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "on immediate");
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  const tDetails = getTDeferBlockDetails(lView[TVIEW], tNode);
  if (tDetails.loadingTmplIndex === null) {
    renderPlaceholder(lView, tNode);
  }
  triggerDeferBlock(0, lView, tNode);
}
function \u0275\u0275deferPrefetchOnImmediate() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "prefetch on immediate");
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    triggerResourceLoading(tDetails, lView, tNode);
  }
}
function \u0275\u0275deferHydrateOnImmediate() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "hydrate on immediate");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
  hydrateTriggers.set(1, null);
  if (false) {
    triggerDeferBlock(2, lView, tNode);
  } else {
    const injector = lView[INJECTOR];
    const lDetails = getLDeferBlockDetails(lView, tNode);
    const ssrUniqueId = lDetails[SSR_UNIQUE_ID];
    ngDevMode && assertSsrIdDefined(ssrUniqueId);
    triggerHydrationFromBlockName(injector, ssrUniqueId);
  }
}
function \u0275\u0275deferOnTimer(delay) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, `on timer(${delay}ms)`);
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  scheduleDelayedTrigger(onTimer(delay));
}
function \u0275\u0275deferPrefetchOnTimer(delay) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, `prefetch on timer(${delay}ms)`);
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  scheduleDelayedPrefetching(onTimer(delay));
}
function \u0275\u0275deferHydrateOnTimer(delay) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, `hydrate on timer(${delay}ms)`);
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
  hydrateTriggers.set(5, { delay });
  if (false) {
    triggerDeferBlock(2, lView, tNode);
  } else {
    scheduleDelayedHydrating(onTimer(delay), lView, tNode);
  }
}
function \u0275\u0275deferOnHover(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, `on hover${walkUpTimes === -1 ? "" : "(<target>)"}`);
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  renderPlaceholder(lView, tNode);
  if (true) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onHover,
      () => triggerDeferBlock(0, lView, tNode),
      0
      /* TriggerType.Regular */
    );
  }
}
function \u0275\u0275deferPrefetchOnHover(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, `prefetch on hover${walkUpTimes === -1 ? "" : "(<target>)"}`);
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onHover,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function \u0275\u0275deferHydrateOnHover() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "hydrate on hover");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
  hydrateTriggers.set(4, null);
  if (false) {
    triggerDeferBlock(2, lView, tNode);
  }
}
function \u0275\u0275deferOnInteraction(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, `on interaction${walkUpTimes === -1 ? "" : "(<target>)"}`);
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  renderPlaceholder(lView, tNode);
  if (true) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onInteraction,
      () => triggerDeferBlock(0, lView, tNode),
      0
      /* TriggerType.Regular */
    );
  }
}
function \u0275\u0275deferPrefetchOnInteraction(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, `prefetch on interaction${walkUpTimes === -1 ? "" : "(<target>)"}`);
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onInteraction,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function \u0275\u0275deferHydrateOnInteraction() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "hydrate on interaction");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
  hydrateTriggers.set(3, null);
  if (false) {
    triggerDeferBlock(2, lView, tNode);
  }
}
function \u0275\u0275deferOnViewport(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, `on viewport${walkUpTimes === -1 ? "" : "(<target>)"}`);
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  renderPlaceholder(lView, tNode);
  if (true) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onViewportWrapper,
      () => triggerDeferBlock(0, lView, tNode),
      0
      /* TriggerType.Regular */
    );
  }
}
function \u0275\u0275deferPrefetchOnViewport(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, `prefetch on viewport${walkUpTimes === -1 ? "" : "(<target>)"}`);
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onViewportWrapper,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function \u0275\u0275deferHydrateOnViewport() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[TVIEW], tNode, "hydrate on viewport");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
  hydrateTriggers.set(2, null);
  if (false) {
    triggerDeferBlock(2, lView, tNode);
  }
}
function \u0275\u0275attribute(name2, value, sanitizer, namespace) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, name2, value, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, "attr." + name2, bindingIndex);
  }
  return \u0275\u0275attribute;
}
function \u0275\u0275componentInstance() {
  const instance = getLView()[DECLARATION_COMPONENT_VIEW][CONTEXT];
  ngDevMode && assertDefined(instance, "Expected component instance to be defined");
  return instance;
}
function valuesMatching(liveIdx, liveValue, newIdx, newValue, trackBy) {
  if (liveIdx === newIdx && Object.is(liveValue, newValue)) {
    return 1;
  } else if (Object.is(trackBy(liveIdx, liveValue), trackBy(newIdx, newValue))) {
    return -1;
  }
  return 0;
}
function recordDuplicateKeys(keyToIdx, key, idx) {
  const idxSoFar = keyToIdx.get(key);
  if (idxSoFar !== void 0) {
    idxSoFar.add(idx);
  } else {
    keyToIdx.set(key, /* @__PURE__ */ new Set([idx]));
  }
}
function reconcile(liveCollection, newCollection, trackByFn) {
  let detachedItems = void 0;
  let liveKeysInTheFuture = void 0;
  let liveStartIdx = 0;
  let liveEndIdx = liveCollection.length - 1;
  const duplicateKeys = ngDevMode ? /* @__PURE__ */ new Map() : void 0;
  if (Array.isArray(newCollection)) {
    let newEndIdx = newCollection.length - 1;
    while (liveStartIdx <= liveEndIdx && liveStartIdx <= newEndIdx) {
      const liveStartValue = liveCollection.at(liveStartIdx);
      const newStartValue = newCollection[liveStartIdx];
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(liveStartIdx, newStartValue), liveStartIdx);
      }
      const isStartMatching = valuesMatching(liveStartIdx, liveStartValue, liveStartIdx, newStartValue, trackByFn);
      if (isStartMatching !== 0) {
        if (isStartMatching < 0) {
          liveCollection.updateValue(liveStartIdx, newStartValue);
        }
        liveStartIdx++;
        continue;
      }
      const liveEndValue = liveCollection.at(liveEndIdx);
      const newEndValue = newCollection[newEndIdx];
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(newEndIdx, newEndValue), newEndIdx);
      }
      const isEndMatching = valuesMatching(liveEndIdx, liveEndValue, newEndIdx, newEndValue, trackByFn);
      if (isEndMatching !== 0) {
        if (isEndMatching < 0) {
          liveCollection.updateValue(liveEndIdx, newEndValue);
        }
        liveEndIdx--;
        newEndIdx--;
        continue;
      }
      const liveStartKey = trackByFn(liveStartIdx, liveStartValue);
      const liveEndKey = trackByFn(liveEndIdx, liveEndValue);
      const newStartKey = trackByFn(liveStartIdx, newStartValue);
      if (Object.is(newStartKey, liveEndKey)) {
        const newEndKey = trackByFn(newEndIdx, newEndValue);
        if (Object.is(newEndKey, liveStartKey)) {
          liveCollection.swap(liveStartIdx, liveEndIdx);
          liveCollection.updateValue(liveEndIdx, newEndValue);
          newEndIdx--;
          liveEndIdx--;
        } else {
          liveCollection.move(liveEndIdx, liveStartIdx);
        }
        liveCollection.updateValue(liveStartIdx, newStartValue);
        liveStartIdx++;
        continue;
      }
      detachedItems ??= new UniqueValueMultiKeyMap();
      liveKeysInTheFuture ??= initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);
      if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newStartKey)) {
        liveCollection.updateValue(liveStartIdx, newStartValue);
        liveStartIdx++;
        liveEndIdx++;
      } else if (!liveKeysInTheFuture.has(newStartKey)) {
        const newItem = liveCollection.create(liveStartIdx, newCollection[liveStartIdx]);
        liveCollection.attach(liveStartIdx, newItem);
        liveStartIdx++;
        liveEndIdx++;
      } else {
        detachedItems.set(liveStartKey, liveCollection.detach(liveStartIdx));
        liveEndIdx--;
      }
    }
    while (liveStartIdx <= newEndIdx) {
      createOrAttach(liveCollection, detachedItems, trackByFn, liveStartIdx, newCollection[liveStartIdx]);
      liveStartIdx++;
    }
  } else if (newCollection != null) {
    const newCollectionIterator = newCollection[Symbol.iterator]();
    let newIterationResult = newCollectionIterator.next();
    while (!newIterationResult.done && liveStartIdx <= liveEndIdx) {
      const liveValue = liveCollection.at(liveStartIdx);
      const newValue = newIterationResult.value;
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(liveStartIdx, newValue), liveStartIdx);
      }
      const isStartMatching = valuesMatching(liveStartIdx, liveValue, liveStartIdx, newValue, trackByFn);
      if (isStartMatching !== 0) {
        if (isStartMatching < 0) {
          liveCollection.updateValue(liveStartIdx, newValue);
        }
        liveStartIdx++;
        newIterationResult = newCollectionIterator.next();
      } else {
        detachedItems ??= new UniqueValueMultiKeyMap();
        liveKeysInTheFuture ??= initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);
        const newKey = trackByFn(liveStartIdx, newValue);
        if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newKey)) {
          liveCollection.updateValue(liveStartIdx, newValue);
          liveStartIdx++;
          liveEndIdx++;
          newIterationResult = newCollectionIterator.next();
        } else if (!liveKeysInTheFuture.has(newKey)) {
          liveCollection.attach(liveStartIdx, liveCollection.create(liveStartIdx, newValue));
          liveStartIdx++;
          liveEndIdx++;
          newIterationResult = newCollectionIterator.next();
        } else {
          const liveKey = trackByFn(liveStartIdx, liveValue);
          detachedItems.set(liveKey, liveCollection.detach(liveStartIdx));
          liveEndIdx--;
        }
      }
    }
    while (!newIterationResult.done) {
      createOrAttach(liveCollection, detachedItems, trackByFn, liveCollection.length, newIterationResult.value);
      newIterationResult = newCollectionIterator.next();
    }
  }
  while (liveStartIdx <= liveEndIdx) {
    liveCollection.destroy(liveCollection.detach(liveEndIdx--));
  }
  detachedItems?.forEach((item) => {
    liveCollection.destroy(item);
  });
  if (ngDevMode) {
    let duplicatedKeysMsg = [];
    for (const [key, idxSet] of duplicateKeys) {
      if (idxSet.size > 1) {
        const idx = [...idxSet].sort((a, b) => a - b);
        for (let i = 1; i < idx.length; i++) {
          duplicatedKeysMsg.push(`key "${stringifyForError(key)}" at index "${idx[i - 1]}" and "${idx[i]}"`);
        }
      }
    }
    if (duplicatedKeysMsg.length > 0) {
      const message = formatRuntimeError(-955, "The provided track expression resulted in duplicated keys for a given collection. Adjust the tracking expression such that it uniquely identifies all the items in the collection. Duplicated keys were: \n" + duplicatedKeysMsg.join(", \n") + ".");
      console.warn(message);
    }
  }
}
function attachPreviouslyDetached(prevCollection, detachedItems, index, key) {
  if (detachedItems !== void 0 && detachedItems.has(key)) {
    prevCollection.attach(index, detachedItems.get(key));
    detachedItems.delete(key);
    return true;
  }
  return false;
}
function createOrAttach(liveCollection, detachedItems, trackByFn, index, value) {
  if (!attachPreviouslyDetached(liveCollection, detachedItems, index, trackByFn(index, value))) {
    const newItem = liveCollection.create(index, value);
    liveCollection.attach(index, newItem);
  } else {
    liveCollection.updateValue(index, value);
  }
}
function initLiveItemsInTheFuture(liveCollection, start, end, trackByFn) {
  const keys2 = /* @__PURE__ */ new Set();
  for (let i = start; i <= end; i++) {
    keys2.add(trackByFn(i, liveCollection.at(i)));
  }
  return keys2;
}
function \u0275\u0275conditionalCreate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  performanceMarkFeature("NgControlFlow");
  const lView = getLView();
  const tView = getTView();
  const attrs = getConstant(tView.consts, attrsIndex);
  declareNoDirectiveHostTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, 256, localRefsIndex, localRefExtractor);
  return \u0275\u0275conditionalBranchCreate;
}
function \u0275\u0275conditionalBranchCreate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  performanceMarkFeature("NgControlFlow");
  const lView = getLView();
  const tView = getTView();
  const attrs = getConstant(tView.consts, attrsIndex);
  declareNoDirectiveHostTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, 512, localRefsIndex, localRefExtractor);
  return \u0275\u0275conditionalBranchCreate;
}
function \u0275\u0275conditional(matchingTemplateIndex, contextValue) {
  performanceMarkFeature("NgControlFlow");
  const hostLView = getLView();
  const bindingIndex = nextBindingIndex();
  const prevMatchingTemplateIndex = hostLView[bindingIndex] !== NO_CHANGE ? hostLView[bindingIndex] : -1;
  const prevContainer = prevMatchingTemplateIndex !== -1 ? getLContainer(hostLView, HEADER_OFFSET + prevMatchingTemplateIndex) : void 0;
  const viewInContainerIdx = 0;
  if (bindingUpdated(hostLView, bindingIndex, matchingTemplateIndex)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      if (prevContainer !== void 0) {
        removeLViewFromLContainer(prevContainer, viewInContainerIdx);
      }
      if (matchingTemplateIndex !== -1) {
        const nextLContainerIndex = HEADER_OFFSET + matchingTemplateIndex;
        const nextContainer = getLContainer(hostLView, nextLContainerIndex);
        const templateTNode = getExistingTNode(hostLView[TVIEW], nextLContainerIndex);
        const dehydratedView = findAndReconcileMatchingDehydratedViews(nextContainer, templateTNode, hostLView);
        const embeddedLView = createAndRenderEmbeddedLView(hostLView, templateTNode, contextValue, {
          dehydratedView
        });
        addLViewToLContainer(nextContainer, embeddedLView, viewInContainerIdx, shouldAddViewToDom(templateTNode, dehydratedView));
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  } else if (prevContainer !== void 0) {
    const lView = getLViewFromLContainer(prevContainer, viewInContainerIdx);
    if (lView !== void 0) {
      lView[CONTEXT] = contextValue;
    }
  }
}
function \u0275\u0275repeaterTrackByIndex(index) {
  return index;
}
function \u0275\u0275repeaterTrackByIdentity(_, value) {
  return value;
}
function \u0275\u0275repeaterCreate(index, templateFn, decls, vars, tagName, attrsIndex, trackByFn, trackByUsesComponentInstance, emptyTemplateFn, emptyDecls, emptyVars, emptyTagName, emptyAttrsIndex) {
  performanceMarkFeature("NgControlFlow");
  ngDevMode && assertFunction(trackByFn, `A track expression must be a function, was ${typeof trackByFn} instead.`);
  const lView = getLView();
  const tView = getTView();
  const hasEmptyBlock = emptyTemplateFn !== void 0;
  const hostLView = getLView();
  const boundTrackBy = trackByUsesComponentInstance ? (
    // We only want to bind when necessary, because it produces a
    // new function. For pure functions it's not necessary.
    trackByFn.bind(hostLView[DECLARATION_COMPONENT_VIEW][CONTEXT])
  ) : trackByFn;
  const metadata = new RepeaterMetadata(hasEmptyBlock, boundTrackBy);
  hostLView[HEADER_OFFSET + index] = metadata;
  declareNoDirectiveHostTemplate(
    lView,
    tView,
    index + 1,
    templateFn,
    decls,
    vars,
    tagName,
    getConstant(tView.consts, attrsIndex),
    256
    /* TNodeFlags.isControlFlowStart */
  );
  if (hasEmptyBlock) {
    ngDevMode && assertDefined(emptyDecls, "Missing number of declarations for the empty repeater block.");
    ngDevMode && assertDefined(emptyVars, "Missing number of bindings for the empty repeater block.");
    declareNoDirectiveHostTemplate(
      lView,
      tView,
      index + 2,
      emptyTemplateFn,
      emptyDecls,
      emptyVars,
      emptyTagName,
      getConstant(tView.consts, emptyAttrsIndex),
      512
      /* TNodeFlags.isInControlFlow */
    );
  }
}
function isViewExpensiveToRecreate(lView) {
  return lView.length - HEADER_OFFSET > 2;
}
function \u0275\u0275repeater(collection) {
  const prevConsumer = setActiveConsumer(null);
  const metadataSlotIdx = getSelectedIndex();
  try {
    const hostLView = getLView();
    const hostTView = hostLView[TVIEW];
    const metadata = hostLView[metadataSlotIdx];
    const containerIndex = metadataSlotIdx + 1;
    const lContainer = getLContainer(hostLView, containerIndex);
    if (metadata.liveCollection === void 0) {
      const itemTemplateTNode = getExistingTNode(hostTView, containerIndex);
      metadata.liveCollection = new LiveCollectionLContainerImpl(lContainer, hostLView, itemTemplateTNode);
    } else {
      metadata.liveCollection.reset();
    }
    const liveCollection = metadata.liveCollection;
    reconcile(liveCollection, collection, metadata.trackByFn);
    if (ngDevMode && metadata.trackByFn === \u0275\u0275repeaterTrackByIdentity && liveCollection.operationsCounter?.wasReCreated(liveCollection.length) && isViewExpensiveToRecreate(getExistingLViewFromLContainer(lContainer, 0))) {
      const message = formatRuntimeError(-956, `The configured tracking expression (track by identity) caused re-creation of the entire collection of size ${liveCollection.length}. This is an expensive operation requiring destruction and subsequent creation of DOM nodes, directives, components etc. Please review the "track expression" and make sure that it uniquely identifies items in a collection.`);
      console.warn(message);
    }
    liveCollection.updateIndexes();
    if (metadata.hasEmptyBlock) {
      const bindingIndex = nextBindingIndex();
      const isCollectionEmpty = liveCollection.length === 0;
      if (bindingUpdated(hostLView, bindingIndex, isCollectionEmpty)) {
        const emptyTemplateIndex = metadataSlotIdx + 2;
        const lContainerForEmpty = getLContainer(hostLView, emptyTemplateIndex);
        if (isCollectionEmpty) {
          const emptyTemplateTNode = getExistingTNode(hostTView, emptyTemplateIndex);
          const dehydratedView = findAndReconcileMatchingDehydratedViews(lContainerForEmpty, emptyTemplateTNode, hostLView);
          const embeddedLView = createAndRenderEmbeddedLView(hostLView, emptyTemplateTNode, void 0, { dehydratedView });
          addLViewToLContainer(lContainerForEmpty, embeddedLView, 0, shouldAddViewToDom(emptyTemplateTNode, dehydratedView));
        } else {
          if (hostTView.firstUpdatePass) {
            removeDehydratedViews(lContainerForEmpty);
          }
          removeLViewFromLContainer(lContainerForEmpty, 0);
        }
      }
    }
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function getLContainer(lView, index) {
  const lContainer = lView[index];
  ngDevMode && assertLContainer(lContainer);
  return lContainer;
}
function detachExistingView(lContainer, index) {
  const existingLView = detachView(lContainer, index);
  ngDevMode && assertLView(existingLView);
  return existingLView;
}
function getExistingLViewFromLContainer(lContainer, index) {
  const existingLView = getLViewFromLContainer(lContainer, index);
  ngDevMode && assertLView(existingLView);
  return existingLView;
}
function getExistingTNode(tView, index) {
  const tNode = getTNode(tView, index);
  ngDevMode && assertTNode(tNode);
  return tNode;
}
function \u0275\u0275property(propName, value, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    setPropertyAndInputs(tNode, lView, propName, value, lView[RENDERER], sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275property;
}
function setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {
  setAllInputsForProperty(tNode, tView, lView, isClassBased ? "class" : "style", value);
}
function \u0275\u0275elementStart(index, name2, attrsIndex, localRefsIndex) {
  const lView = getLView();
  ngDevMode && assertTNodeCreationIndex(lView, index);
  const tView = lView[TVIEW];
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? directiveHostFirstCreatePass(adjustedIndex, lView, 2, name2, findDirectiveDefMatches, getBindingsEnabled(), attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  elementLikeStartShared(tNode, lView, index, name2, _locateOrCreateElementNode);
  if (isDirectiveHost(tNode)) {
    const tView2 = lView[TVIEW];
    createDirectivesInstances(tView2, lView, tNode);
    executeContentQueries(tView2, tNode, lView);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  if (ngDevMode && lView[TVIEW].firstCreatePass) {
    validateElementIsKnown(lView, tNode);
  }
  return \u0275\u0275elementStart;
}
function \u0275\u0275elementEnd() {
  const tView = getTView();
  const initialTNode = getCurrentTNode();
  ngDevMode && assertDefined(initialTNode, "No parent node to close.");
  const currentTNode = elementLikeEndShared(initialTNode);
  ngDevMode && assertTNodeType(
    currentTNode,
    3
    /* TNodeType.AnyRNode */
  );
  if (tView.firstCreatePass) {
    directiveHostEndFirstCreatePass(tView, currentTNode);
  }
  if (isSkipHydrationRootTNode(currentTNode)) {
    leaveSkipHydrationBlock();
  }
  decreaseElementDepthCount();
  if (currentTNode.classesWithoutHost != null && hasClassInput(currentTNode)) {
    setDirectiveInputsWhichShadowsStyling(tView, currentTNode, getLView(), currentTNode.classesWithoutHost, true);
  }
  if (currentTNode.stylesWithoutHost != null && hasStyleInput(currentTNode)) {
    setDirectiveInputsWhichShadowsStyling(tView, currentTNode, getLView(), currentTNode.stylesWithoutHost, false);
  }
  return \u0275\u0275elementEnd;
}
function \u0275\u0275element(index, name2, attrsIndex, localRefsIndex) {
  \u0275\u0275elementStart(index, name2, attrsIndex, localRefsIndex);
  \u0275\u0275elementEnd();
  return \u0275\u0275element;
}
function \u0275\u0275domElementStart(index, name2, attrsIndex, localRefsIndex) {
  const lView = getLView();
  ngDevMode && assertTNodeCreationIndex(lView, index);
  const tView = lView[TVIEW];
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? domOnlyFirstCreatePass(adjustedIndex, tView, 2, name2, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  elementLikeStartShared(tNode, lView, index, name2, _locateOrCreateElementNode);
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  if (ngDevMode && lView[TVIEW].firstCreatePass) {
    validateElementIsKnown(lView, tNode);
  }
  return \u0275\u0275domElementStart;
}
function \u0275\u0275domElementEnd() {
  const initialTNode = getCurrentTNode();
  ngDevMode && assertDefined(initialTNode, "No parent node to close.");
  const currentTNode = elementLikeEndShared(initialTNode);
  ngDevMode && assertTNodeType(
    currentTNode,
    3
    /* TNodeType.AnyRNode */
  );
  if (isSkipHydrationRootTNode(currentTNode)) {
    leaveSkipHydrationBlock();
  }
  decreaseElementDepthCount();
  return \u0275\u0275domElementEnd;
}
function \u0275\u0275domElement(index, name2, attrsIndex, localRefsIndex) {
  \u0275\u0275domElementStart(index, name2, attrsIndex, localRefsIndex);
  \u0275\u0275domElementEnd();
  return \u0275\u0275domElement;
}
function \u0275\u0275elementContainerStart(index, attrsIndex, localRefsIndex) {
  const lView = getLView();
  ngDevMode && assertTNodeCreationIndex(lView, index);
  const tView = lView[TVIEW];
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? directiveHostFirstCreatePass(adjustedIndex, lView, 8, "ng-container", findDirectiveDefMatches, getBindingsEnabled(), attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  elementLikeStartShared(tNode, lView, index, "ng-container", _locateOrCreateElementContainerNode);
  if (isDirectiveHost(tNode)) {
    const tView2 = lView[TVIEW];
    createDirectivesInstances(tView2, lView, tNode);
    executeContentQueries(tView2, tNode, lView);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  return \u0275\u0275elementContainerStart;
}
function \u0275\u0275elementContainerEnd() {
  const tView = getTView();
  const initialTNode = getCurrentTNode();
  ngDevMode && assertDefined(initialTNode, "No parent node to close.");
  const currentTNode = elementLikeEndShared(initialTNode);
  if (tView.firstCreatePass) {
    directiveHostEndFirstCreatePass(tView, currentTNode);
  }
  ngDevMode && assertTNodeType(
    currentTNode,
    8
    /* TNodeType.ElementContainer */
  );
  return \u0275\u0275elementContainerEnd;
}
function \u0275\u0275elementContainer(index, attrsIndex, localRefsIndex) {
  \u0275\u0275elementContainerStart(index, attrsIndex, localRefsIndex);
  \u0275\u0275elementContainerEnd();
  return \u0275\u0275elementContainer;
}
function \u0275\u0275domElementContainerStart(index, attrsIndex, localRefsIndex) {
  const lView = getLView();
  ngDevMode && assertTNodeCreationIndex(lView, index);
  const tView = lView[TVIEW];
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? domOnlyFirstCreatePass(adjustedIndex, tView, 8, "ng-container", attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  elementLikeStartShared(tNode, lView, index, "ng-container", _locateOrCreateElementContainerNode);
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  return \u0275\u0275domElementContainerStart;
}
function \u0275\u0275domElementContainerEnd() {
  const initialTNode = getCurrentTNode();
  ngDevMode && assertDefined(initialTNode, "No parent node to close.");
  const currentTNode = elementLikeEndShared(initialTNode);
  ngDevMode && assertTNodeType(
    currentTNode,
    8
    /* TNodeType.ElementContainer */
  );
  return \u0275\u0275elementContainerEnd;
}
function \u0275\u0275domElementContainer(index, attrsIndex, localRefsIndex) {
  \u0275\u0275domElementContainerStart(index, attrsIndex, localRefsIndex);
  \u0275\u0275domElementContainerEnd();
  return \u0275\u0275domElementContainer;
}
function \u0275\u0275getCurrentView() {
  return getLView();
}
function \u0275\u0275domProperty(propName, value, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    setDomProperty(tNode, lView, propName, value, lView[RENDERER], sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275domProperty;
}
function \u0275\u0275syntheticHostProperty(propName, value, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    const currentDef = getCurrentDirectiveDef(tView.data);
    const renderer = loadComponentRenderer(currentDef, tNode, lView);
    setDomProperty(tNode, lView, propName, value, renderer, sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275syntheticHostProperty;
}
function plural(val) {
  const i = Math.floor(Math.abs(val)), v = val.toString().replace(/^[^.]*\.?/, "").length;
  if (i === 1 && v === 0)
    return 1;
  return 5;
}
function findLocaleData(locale) {
  const normalizedLocale = normalizeLocale(locale);
  let match2 = getLocaleData(normalizedLocale);
  if (match2) {
    return match2;
  }
  const parentLocale = normalizedLocale.split("-")[0];
  match2 = getLocaleData(parentLocale);
  if (match2) {
    return match2;
  }
  if (parentLocale === "en") {
    return localeEn;
  }
  throw new RuntimeError(701, ngDevMode && `Missing locale data for the locale "${locale}".`);
}
function getLocalePluralCase(locale) {
  const data2 = findLocaleData(locale);
  return data2[LocaleDataIndex.PluralCase];
}
function getLocaleData(normalizedLocale) {
  if (!(normalizedLocale in LOCALE_DATA)) {
    LOCALE_DATA[normalizedLocale] = _global.ng && _global.ng.common && _global.ng.common.locales && _global.ng.common.locales[normalizedLocale];
  }
  return LOCALE_DATA[normalizedLocale];
}
function normalizeLocale(locale) {
  return locale.toLowerCase().replace(/_/g, "-");
}
function getPluralCase(value, locale) {
  const plural2 = getLocalePluralCase(locale)(parseInt(value, 10));
  const result = pluralMapping[plural2];
  return result !== void 0 ? result : "other";
}
function setLocaleId(localeId) {
  ngDevMode && assertDefined(localeId, `Expected localeId to be defined`);
  if (typeof localeId === "string") {
    LOCALE_ID$1 = localeId.toLowerCase().replace(/_/g, "-");
  }
}
function getLocaleId() {
  return LOCALE_ID$1;
}
function setMaskBit(hasChange) {
  if (hasChange) {
    changeMask = changeMask | 1 << Math.min(changeMaskCounter, 31);
  }
  changeMaskCounter++;
}
function applyI18n(tView, lView, index) {
  if (changeMaskCounter > 0) {
    ngDevMode && assertDefined(tView, `tView should be defined`);
    const tI18n = tView.data[index];
    const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;
    const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;
    applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);
  }
  changeMask = 0;
  changeMaskCounter = 0;
}
function createNodeWithoutHydration(lView, textOrName, nodeType) {
  const renderer = lView[RENDERER];
  switch (nodeType) {
    case Node.COMMENT_NODE:
      return createCommentNode(renderer, textOrName);
    case Node.TEXT_NODE:
      return createTextNode(renderer, textOrName);
    case Node.ELEMENT_NODE:
      return createElementNode(renderer, textOrName, null);
  }
}
function applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {
  const renderer = lView[RENDERER];
  for (let i = 0; i < createOpCodes.length; i++) {
    const opCode = createOpCodes[i++];
    const text = createOpCodes[i];
    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
    const index = opCode >>> I18nCreateOpCode.SHIFT;
    let rNode = lView[index];
    let lastNodeWasCreated2 = false;
    if (rNode === null) {
      rNode = lView[index] = _locateOrCreateNode(lView, index, text, isComment ? Node.COMMENT_NODE : Node.TEXT_NODE);
      lastNodeWasCreated2 = wasLastNodeCreated();
    }
    if (appendNow && parentRNode !== null && lastNodeWasCreated2) {
      nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);
    }
  }
}
function applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {
  ngDevMode && assertDomNode(anchorRNode);
  const renderer = lView[RENDERER];
  let rootIdx = null;
  let rootRNode;
  for (let i = 0; i < mutableOpCodes.length; i++) {
    const opCode = mutableOpCodes[i];
    if (typeof opCode == "string") {
      const textNodeIndex = mutableOpCodes[++i];
      if (lView[textNodeIndex] === null) {
        ngDevMode && assertIndexInRange(lView, textNodeIndex);
        lView[textNodeIndex] = _locateOrCreateNode(lView, textNodeIndex, opCode, Node.TEXT_NODE);
      }
    } else if (typeof opCode == "number") {
      switch (opCode & 1) {
        case 0:
          const parentIdx = getParentFromIcuCreateOpCode(opCode);
          if (rootIdx === null) {
            rootIdx = parentIdx;
            rootRNode = renderer.parentNode(anchorRNode);
          }
          let insertInFrontOf;
          let parentRNode;
          if (parentIdx === rootIdx) {
            insertInFrontOf = anchorRNode;
            parentRNode = rootRNode;
          } else {
            insertInFrontOf = null;
            parentRNode = unwrapRNode(lView[parentIdx]);
          }
          if (parentRNode !== null) {
            ngDevMode && assertDomNode(parentRNode);
            const refIdx = getRefFromIcuCreateOpCode(opCode);
            ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, "Missing ref");
            const child = lView[refIdx];
            ngDevMode && assertDomNode(child);
            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);
            const tIcu = getTIcu(tView, refIdx);
            if (tIcu !== null && typeof tIcu === "object") {
              ngDevMode && assertTIcu(tIcu);
              const caseIndex = getCurrentICUCaseIndex(tIcu, lView);
              if (caseIndex !== null) {
                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);
              }
            }
          }
          break;
        case 1:
          const elementNodeIndex = opCode >>> 1;
          const attrName = mutableOpCodes[++i];
          const attrValue = mutableOpCodes[++i];
          setElementAttribute(renderer, getNativeByIndex(elementNodeIndex, lView), null, null, attrName, attrValue, null);
          break;
        default:
          if (ngDevMode) {
            throw new RuntimeError(700, `Unable to determine the type of mutate operation for "${opCode}"`);
          }
      }
    } else {
      switch (opCode) {
        case ICU_MARKER:
          const commentValue = mutableOpCodes[++i];
          const commentNodeIndex = mutableOpCodes[++i];
          if (lView[commentNodeIndex] === null) {
            ngDevMode && assertEqual(typeof commentValue, "string", `Expected "${commentValue}" to be a comment node value`);
            ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);
            const commentRNode = lView[commentNodeIndex] = _locateOrCreateNode(lView, commentNodeIndex, commentValue, Node.COMMENT_NODE);
            attachPatchData(commentRNode, lView);
          }
          break;
        case ELEMENT_MARKER:
          const tagName = mutableOpCodes[++i];
          const elementNodeIndex = mutableOpCodes[++i];
          if (lView[elementNodeIndex] === null) {
            ngDevMode && assertEqual(typeof tagName, "string", `Expected "${tagName}" to be an element node tag name`);
            ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);
            const elementRNode = lView[elementNodeIndex] = _locateOrCreateNode(lView, elementNodeIndex, tagName, Node.ELEMENT_NODE);
            attachPatchData(elementRNode, lView);
          }
          break;
        default:
          ngDevMode && throwError2(`Unable to determine the type of mutate operation for "${opCode}"`);
      }
    }
  }
}
function applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask2) {
  for (let i = 0; i < updateOpCodes.length; i++) {
    const checkBit = updateOpCodes[i];
    const skipCodes = updateOpCodes[++i];
    if (checkBit & changeMask2) {
      let value = "";
      for (let j = i + 1; j <= i + skipCodes; j++) {
        const opCode = updateOpCodes[j];
        if (typeof opCode == "string") {
          value += opCode;
        } else if (typeof opCode == "number") {
          if (opCode < 0) {
            value += renderStringify(lView[bindingsStartIndex - opCode]);
          } else {
            const nodeIndex = opCode >>> 2;
            switch (opCode & 3) {
              case 1:
                const propName = updateOpCodes[++j];
                const sanitizeFn = updateOpCodes[++j];
                const tNodeOrTagName = tView.data[nodeIndex];
                ngDevMode && assertDefined(tNodeOrTagName, "Experting TNode or string");
                if (typeof tNodeOrTagName === "string") {
                  setElementAttribute(lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value, sanitizeFn);
                } else {
                  setPropertyAndInputs(tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn);
                }
                break;
              case 0:
                const rText = lView[nodeIndex];
                rText !== null && updateTextNode(lView[RENDERER], rText, value);
                break;
              case 2:
                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);
                break;
              case 3:
                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);
                break;
            }
          }
        }
      }
    } else {
      const opCode = updateOpCodes[i + 1];
      if (opCode > 0 && (opCode & 3) === 3) {
        const nodeIndex = opCode >>> 2;
        const tIcu = getTIcu(tView, nodeIndex);
        const currentIndex = lView[tIcu.currentCaseLViewIndex];
        if (currentIndex < 0) {
          applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);
        }
      }
    }
    i += skipCodes;
  }
}
function applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {
  ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);
  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];
  if (activeCaseIndex !== null) {
    let mask = changeMask;
    if (activeCaseIndex < 0) {
      activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;
      mask = -1;
    }
    applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);
  }
}
function applyIcuSwitchCase(tView, tIcu, lView, value) {
  const caseIndex = getCaseIndex(tIcu, value);
  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
  if (activeCaseIndex !== caseIndex) {
    applyIcuSwitchCaseRemove(tView, tIcu, lView);
    lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;
    if (caseIndex !== null) {
      const anchorRNode = lView[tIcu.anchorIdx];
      if (anchorRNode) {
        ngDevMode && assertDomNode(anchorRNode);
        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);
      }
      claimDehydratedIcuCase(lView, tIcu.anchorIdx, caseIndex);
    }
  }
}
function applyIcuSwitchCaseRemove(tView, tIcu, lView) {
  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
  if (activeCaseIndex !== null) {
    const removeCodes = tIcu.remove[activeCaseIndex];
    for (let i = 0; i < removeCodes.length; i++) {
      const nodeOrIcuIndex = removeCodes[i];
      if (nodeOrIcuIndex > 0) {
        const rNode = getNativeByIndex(nodeOrIcuIndex, lView);
        rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);
      } else {
        applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);
      }
    }
  }
}
function getCaseIndex(icuExpression, bindingValue) {
  let index = icuExpression.cases.indexOf(bindingValue);
  if (index === -1) {
    switch (icuExpression.type) {
      case 1: {
        const resolvedCase = getPluralCase(bindingValue, getLocaleId());
        index = icuExpression.cases.indexOf(resolvedCase);
        if (index === -1 && resolvedCase !== "other") {
          index = icuExpression.cases.indexOf("other");
        }
        break;
      }
      case 0: {
        index = icuExpression.cases.indexOf("other");
        break;
      }
    }
  }
  return index === -1 ? null : index;
}
function i18nCreateOpCodesToString(opcodes) {
  const createOpCodes = opcodes || (Array.isArray(this) ? this : []);
  let lines = [];
  for (let i = 0; i < createOpCodes.length; i++) {
    const opCode = createOpCodes[i++];
    const text = createOpCodes[i];
    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
    const index = opCode >>> I18nCreateOpCode.SHIFT;
    lines.push(`lView[${index}] = document.${isComment ? "createComment" : "createText"}(${JSON.stringify(text)});`);
    if (appendNow) {
      lines.push(`parent.appendChild(lView[${index}]);`);
    }
  }
  return lines;
}
function i18nUpdateOpCodesToString(opcodes) {
  const parser7 = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
  let lines = [];
  function consumeOpCode(value) {
    const ref = value >>> 2;
    const opCode = value & 3;
    switch (opCode) {
      case 0:
        return `(lView[${ref}] as Text).textContent = $$$`;
      case 1:
        const attrName = parser7.consumeString();
        const sanitizationFn = parser7.consumeFunction();
        const value2 = sanitizationFn ? `(${sanitizationFn})($$$)` : "$$$";
        return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value2})`;
      case 2:
        return `icuSwitchCase(${ref}, $$$)`;
      case 3:
        return `icuUpdateCase(${ref})`;
    }
    throw new Error("unexpected OpCode");
  }
  while (parser7.hasMore()) {
    let mask = parser7.consumeNumber();
    let size = parser7.consumeNumber();
    const end = parser7.i + size;
    const statements = [];
    let statement = "";
    while (parser7.i < end) {
      let value = parser7.consumeNumberOrString();
      if (typeof value === "string") {
        statement += value;
      } else if (value < 0) {
        statement += "${lView[i" + value + "]}";
      } else {
        const opCodeText = consumeOpCode(value);
        statements.push(opCodeText.replace("$$$", "`" + statement + "`") + ";");
        statement = "";
      }
    }
    lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(" ")} }`);
  }
  return lines;
}
function icuCreateOpCodesToString(opcodes) {
  const parser7 = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
  let lines = [];
  function consumeOpCode(opCode) {
    const parent = getParentFromIcuCreateOpCode(opCode);
    const ref = getRefFromIcuCreateOpCode(opCode);
    switch (getInstructionFromIcuCreateOpCode(opCode)) {
      case 0:
        return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;
      case 1:
        return `(lView[${ref}] as Element).setAttribute("${parser7.consumeString()}", "${parser7.consumeString()}")`;
    }
    throw new Error("Unexpected OpCode: " + getInstructionFromIcuCreateOpCode(opCode));
  }
  let lastRef = -1;
  while (parser7.hasMore()) {
    let value = parser7.consumeNumberStringOrMarker();
    if (value === ICU_MARKER) {
      const text = parser7.consumeString();
      lastRef = parser7.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createComment("${text}")`);
    } else if (value === ELEMENT_MARKER) {
      const text = parser7.consumeString();
      lastRef = parser7.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createElement("${text}")`);
    } else if (typeof value === "string") {
      lastRef = parser7.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createTextNode("${value}")`);
    } else if (typeof value === "number") {
      const line = consumeOpCode(value);
      line && lines.push(line);
    } else {
      throw new Error("Unexpected value");
    }
  }
  return lines;
}
function i18nRemoveOpCodesToString(opcodes) {
  const removeCodes = opcodes || (Array.isArray(this) ? this : []);
  let lines = [];
  for (let i = 0; i < removeCodes.length; i++) {
    const nodeOrIcuIndex = removeCodes[i];
    if (nodeOrIcuIndex > 0) {
      lines.push(`remove(lView[${nodeOrIcuIndex}])`);
    } else {
      lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);
    }
  }
  return lines;
}
function replaceNgsp(value) {
  return value.replace(NGSP_UNICODE_REGEXP, " ");
}
function attachDebugGetter(obj, debugGetter) {
  if (ngDevMode) {
    Object.defineProperty(obj, "debug", { get: debugGetter, enumerable: false });
  } else {
    throw new Error("This method should be guarded with `ngDevMode` so that it can be tree shaken in production!");
  }
}
function i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index, message, subTemplateIndex) {
  const rootTNode = getCurrentParentTNode();
  const createOpCodes = [];
  const updateOpCodes = [];
  const existingTNodeStack = [[]];
  const astStack = [[]];
  if (ngDevMode) {
    attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  message = getTranslationForTemplate(message, subTemplateIndex);
  const msgParts = replaceNgsp(message).split(PH_REGEXP);
  for (let i = 0; i < msgParts.length; i++) {
    let value = msgParts[i];
    if ((i & 1) === 0) {
      const parts = i18nParseTextIntoPartsAndICU(value);
      for (let j = 0; j < parts.length; j++) {
        let part = parts[j];
        if ((j & 1) === 0) {
          const text = part;
          ngDevMode && assertString(text, "Parsed ICU part should be string");
          if (text !== "") {
            i18nStartFirstCreatePassProcessTextNode(astStack[0], tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);
          }
        } else {
          const icuExpression = part;
          if (typeof icuExpression !== "object") {
            throw new Error(`Unable to parse ICU expression in "${message}" message.`);
          }
          const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : "", true);
          const icuNodeIndex = icuContainerTNode.index;
          ngDevMode && assertGreaterThanOrEqual(icuNodeIndex, HEADER_OFFSET, "Index must be in absolute LView offset");
          icuStart(astStack[0], tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);
        }
      }
    } else {
      const isClosing = value.charCodeAt(0) === 47;
      const type = value.charCodeAt(isClosing ? 1 : 0);
      ngDevMode && assertOneOf(
        type,
        42,
        35
        /* CharCode.HASH */
      );
      const index2 = HEADER_OFFSET + Number.parseInt(value.substring(isClosing ? 2 : 1));
      if (isClosing) {
        existingTNodeStack.shift();
        astStack.shift();
        setCurrentTNode(getCurrentParentTNode(), false);
      } else {
        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index2);
        existingTNodeStack.unshift([]);
        setCurrentTNode(tNode, true);
        const placeholderNode = {
          kind: 2,
          index: index2,
          children: [],
          type: type === 35 ? 0 : 1
        };
        astStack[0].push(placeholderNode);
        astStack.unshift(placeholderNode.children);
      }
    }
  }
  tView.data[index] = {
    create: createOpCodes,
    update: updateOpCodes,
    ast: astStack[0],
    parentTNodeIndex
  };
}
function createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {
  const i18nNodeIdx = allocExpando(tView, lView, 1, null);
  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;
  let parentTNode = getCurrentParentTNode();
  if (rootTNode === parentTNode) {
    parentTNode = null;
  }
  if (parentTNode === null) {
    opCode |= I18nCreateOpCode.APPEND_EAGERLY;
  }
  if (isICU) {
    opCode |= I18nCreateOpCode.COMMENT;
    ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);
  }
  createOpCodes.push(opCode, text === null ? "" : text);
  const tNode = createTNodeAtIndex(tView, i18nNodeIdx, isICU ? 32 : 1, text === null ? ngDevMode ? "{{?}}" : "" : text, null);
  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);
  const tNodeIdx = tNode.index;
  setCurrentTNode(
    tNode,
    false
    /* Text nodes are self closing */
  );
  if (parentTNode !== null && rootTNode !== parentTNode) {
    setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);
  }
  return tNode;
}
function i18nStartFirstCreatePassProcessTextNode(ast, tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {
  const hasBinding = text.match(BINDING_REGEXP);
  const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);
  const index = tNode.index;
  if (hasBinding) {
    generateBindingUpdateOpCodes(updateOpCodes, text, index, null, 0, null);
  }
  ast.push({ kind: 0, index });
}
function i18nAttributesFirstPass(tView, index, values2) {
  const previousElement = getCurrentTNode();
  const previousElementIndex = previousElement.index;
  const updateOpCodes = [];
  if (ngDevMode) {
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  if (tView.firstCreatePass && tView.data[index] === null) {
    for (let i = 0; i < values2.length; i += 2) {
      const attrName = values2[i];
      const message = values2[i + 1];
      if (message !== "") {
        if (ICU_REGEXP.test(message)) {
          throw new Error(`ICU expressions are not supported in attributes. Message: "${message}".`);
        }
        generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes), null);
      }
    }
    tView.data[index] = updateOpCodes;
  }
}
function generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {
  ngDevMode && assertGreaterThanOrEqual(destinationNode, HEADER_OFFSET, "Index must be in absolute LView offset");
  const maskIndex = updateOpCodes.length;
  const sizeIndex = maskIndex + 1;
  updateOpCodes.push(null, null);
  const startIndex = maskIndex + 2;
  if (ngDevMode) {
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  const textParts = str.split(BINDING_REGEXP);
  let mask = 0;
  for (let j = 0; j < textParts.length; j++) {
    const textValue = textParts[j];
    if (j & 1) {
      const bindingIndex = bindingStart + parseInt(textValue, 10);
      updateOpCodes.push(-1 - bindingIndex);
      mask = mask | toMaskBit(bindingIndex);
    } else if (textValue !== "") {
      updateOpCodes.push(textValue);
    }
  }
  updateOpCodes.push(destinationNode << 2 | (attrName ? 1 : 0));
  if (attrName) {
    updateOpCodes.push(attrName, sanitizeFn);
  }
  updateOpCodes[maskIndex] = mask;
  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;
  return mask;
}
function countBindings(opCodes) {
  let count2 = 0;
  for (let i = 0; i < opCodes.length; i++) {
    const opCode = opCodes[i];
    if (typeof opCode === "number" && opCode < 0) {
      count2++;
    }
  }
  return count2;
}
function toMaskBit(bindingIndex) {
  return 1 << Math.min(bindingIndex, 31);
}
function removeInnerTemplateTranslation(message) {
  let match2;
  let res = "";
  let index = 0;
  let inTemplate = false;
  let tagMatched;
  while ((match2 = SUBTEMPLATE_REGEXP.exec(message)) !== null) {
    if (!inTemplate) {
      res += message.substring(index, match2.index + match2[0].length);
      tagMatched = match2[1];
      inTemplate = true;
    } else {
      if (match2[0] === `${MARKER}/*${tagMatched}${MARKER}`) {
        index = match2.index;
        inTemplate = false;
      }
    }
  }
  ngDevMode && assertEqual(inTemplate, false, `Tag mismatch: unable to find the end of the sub-template in the translation "${message}"`);
  res += message.slice(index);
  return res;
}
function getTranslationForTemplate(message, subTemplateIndex) {
  if (isRootTemplateMessage(subTemplateIndex)) {
    return removeInnerTemplateTranslation(message);
  } else {
    const start = message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;
    const end = message.search(new RegExp(`${MARKER}\\/\\*\\d+:${subTemplateIndex}${MARKER}`));
    return removeInnerTemplateTranslation(message.substring(start, end));
  }
}
function icuStart(ast, tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {
  ngDevMode && assertDefined(icuExpression, "ICU expression must be defined");
  let bindingMask = 0;
  const tIcu = {
    type: icuExpression.type,
    currentCaseLViewIndex: allocExpando(tView, lView, 1, null),
    anchorIdx,
    cases: [],
    create: [],
    remove: [],
    update: []
  };
  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);
  setTIcu(tView, anchorIdx, tIcu);
  const values2 = icuExpression.values;
  const cases = [];
  for (let i = 0; i < values2.length; i++) {
    const valueArr = values2[i];
    const nestedIcus = [];
    for (let j = 0; j < valueArr.length; j++) {
      const value = valueArr[j];
      if (typeof value !== "string") {
        const icuIndex = nestedIcus.push(value) - 1;
        valueArr[j] = `<!--\uFFFD${icuIndex}\uFFFD-->`;
      }
    }
    const caseAst = [];
    cases.push(caseAst);
    bindingMask = parseIcuCase(caseAst, tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i], valueArr.join(""), nestedIcus) | bindingMask;
  }
  if (bindingMask) {
    addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);
  }
  ast.push({
    kind: 3,
    index: anchorIdx,
    cases,
    currentCaseLViewIndex: tIcu.currentCaseLViewIndex
  });
}
function parseICUBlock(pattern) {
  const cases = [];
  const values2 = [];
  let icuType = 1;
  let mainBinding = 0;
  pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str, binding, type) {
    if (type === "select") {
      icuType = 0;
    } else {
      icuType = 1;
    }
    mainBinding = parseInt(binding.slice(1), 10);
    return "";
  });
  const parts = i18nParseTextIntoPartsAndICU(pattern);
  for (let pos = 0; pos < parts.length; ) {
    let key = parts[pos++].trim();
    if (icuType === 1) {
      key = key.replace(/\s*(?:=)?(\w+)\s*/, "$1");
    }
    if (key.length) {
      cases.push(key);
    }
    const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);
    if (cases.length > values2.length) {
      values2.push(blocks);
    }
  }
  return { type: icuType, mainBinding, cases, values: values2 };
}
function i18nParseTextIntoPartsAndICU(pattern) {
  if (!pattern) {
    return [];
  }
  let prevPos = 0;
  const braceStack = [];
  const results = [];
  const braces = /[{}]/g;
  braces.lastIndex = 0;
  let match2;
  while (match2 = braces.exec(pattern)) {
    const pos = match2.index;
    if (match2[0] == "}") {
      braceStack.pop();
      if (braceStack.length == 0) {
        const block = pattern.substring(prevPos, pos);
        if (ICU_BLOCK_REGEXP.test(block)) {
          results.push(parseICUBlock(block));
        } else {
          results.push(block);
        }
        prevPos = pos + 1;
      }
    } else {
      if (braceStack.length == 0) {
        const substring2 = pattern.substring(prevPos, pos);
        results.push(substring2);
        prevPos = pos + 1;
      }
      braceStack.push("{");
    }
  }
  const substring = pattern.substring(prevPos);
  results.push(substring);
  return results;
}
function parseIcuCase(ast, tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {
  const create = [];
  const remove3 = [];
  const update = [];
  if (ngDevMode) {
    attachDebugGetter(create, icuCreateOpCodesToString);
    attachDebugGetter(remove3, i18nRemoveOpCodesToString);
    attachDebugGetter(update, i18nUpdateOpCodesToString);
  }
  tIcu.cases.push(caseName);
  tIcu.create.push(create);
  tIcu.remove.push(remove3);
  tIcu.update.push(update);
  const inertBodyHelper2 = getInertBodyHelper(getDocument());
  const inertBodyElement = inertBodyHelper2.getInertBodyElement(unsafeCaseHtml);
  ngDevMode && assertDefined(inertBodyElement, "Unable to generate inert body element");
  const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;
  if (inertRootNode) {
    return walkIcuTree(ast, tView, tIcu, lView, updateOpCodes, create, remove3, update, inertRootNode, parentIdx, nestedIcus, 0);
  } else {
    return 0;
  }
}
function walkIcuTree(ast, tView, tIcu, lView, sharedUpdateOpCodes, create, remove3, update, parentNode, parentIdx, nestedIcus, depth) {
  let bindingMask = 0;
  let currentNode = parentNode.firstChild;
  while (currentNode) {
    const newIndex = allocExpando(tView, lView, 1, null);
    switch (currentNode.nodeType) {
      case Node.ELEMENT_NODE:
        const element = currentNode;
        const tagName = element.tagName.toLowerCase();
        if (VALID_ELEMENTS.hasOwnProperty(tagName)) {
          addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);
          tView.data[newIndex] = tagName;
          const elAttrs = element.attributes;
          for (let i = 0; i < elAttrs.length; i++) {
            const attr = elAttrs.item(i);
            const lowerAttrName = attr.name.toLowerCase();
            const hasBinding2 = !!attr.value.match(BINDING_REGEXP);
            if (hasBinding2) {
              if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {
                if (URI_ATTRS[lowerAttrName]) {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);
                } else {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);
                }
              } else {
                ngDevMode && console.warn(`WARNING: ignoring unsafe attribute value ${lowerAttrName} on element ${tagName} (see ${XSS_SECURITY_URL})`);
              }
            } else {
              addCreateAttribute(create, newIndex, attr);
            }
          }
          const elementNode = {
            kind: 1,
            index: newIndex,
            children: []
          };
          ast.push(elementNode);
          bindingMask = walkIcuTree(elementNode.children, tView, tIcu, lView, sharedUpdateOpCodes, create, remove3, update, currentNode, newIndex, nestedIcus, depth + 1) | bindingMask;
          addRemoveNode(remove3, newIndex, depth);
        }
        break;
      case Node.TEXT_NODE:
        const value = currentNode.textContent || "";
        const hasBinding = value.match(BINDING_REGEXP);
        addCreateNodeAndAppend(create, null, hasBinding ? "" : value, parentIdx, newIndex);
        addRemoveNode(remove3, newIndex, depth);
        if (hasBinding) {
          bindingMask = generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;
        }
        ast.push({
          kind: 0,
          index: newIndex
        });
        break;
      case Node.COMMENT_NODE:
        const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || "");
        if (isNestedIcu) {
          const nestedIcuIndex = parseInt(isNestedIcu[1], 10);
          const icuExpression = nestedIcus[nestedIcuIndex];
          addCreateNodeAndAppend(create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : "", parentIdx, newIndex);
          icuStart(ast, tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);
          addRemoveNestedIcu(remove3, newIndex, depth);
        }
        break;
    }
    currentNode = currentNode.nextSibling;
  }
  return bindingMask;
}
function addRemoveNode(remove3, index, depth) {
  if (depth === 0) {
    remove3.push(index);
  }
}
function addRemoveNestedIcu(remove3, index, depth) {
  if (depth === 0) {
    remove3.push(~index);
    remove3.push(index);
  }
}
function addUpdateIcuSwitch(update, icuExpression, index) {
  update.push(
    toMaskBit(icuExpression.mainBinding),
    2,
    -1 - icuExpression.mainBinding,
    index << 2 | 2
    /* I18nUpdateOpCode.IcuSwitch */
  );
}
function addUpdateIcuUpdate(update, bindingMask, index) {
  update.push(
    bindingMask,
    1,
    index << 2 | 3
    /* I18nUpdateOpCode.IcuUpdate */
  );
}
function addCreateNodeAndAppend(create, marker, text, appendToParentIdx, createAtIdx) {
  if (marker !== null) {
    create.push(marker);
  }
  create.push(text, createAtIdx, icuCreateOpCode(0, appendToParentIdx, createAtIdx));
}
function addCreateAttribute(create, newIndex, attr) {
  create.push(newIndex << 1 | 1, attr.name, attr.value);
}
function i18nPostprocess(message, replacements = {}) {
  let result = message;
  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {
    const matches = {};
    const templateIdsStack = [ROOT_TEMPLATE_ID];
    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl) => {
      const content2 = phs || tmpl;
      const placeholders = matches[content2] || [];
      if (!placeholders.length) {
        content2.split("|").forEach((placeholder2) => {
          const match2 = placeholder2.match(PP_TEMPLATE_ID_REGEXP);
          const templateId2 = match2 ? parseInt(match2[1], 10) : ROOT_TEMPLATE_ID;
          const isCloseTemplateTag2 = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder2);
          placeholders.push([templateId2, isCloseTemplateTag2, placeholder2]);
        });
        matches[content2] = placeholders;
      }
      if (!placeholders.length) {
        throw new Error(`i18n postprocess: unmatched placeholder - ${content2}`);
      }
      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];
      let idx = 0;
      for (let i = 0; i < placeholders.length; i++) {
        if (placeholders[i][0] === currentTemplateId) {
          idx = i;
          break;
        }
      }
      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];
      if (isCloseTemplateTag) {
        templateIdsStack.pop();
      } else if (currentTemplateId !== templateId) {
        templateIdsStack.push(templateId);
      }
      placeholders.splice(idx, 1);
      return placeholder;
    });
  }
  if (!Object.keys(replacements).length) {
    return result;
  }
  result = result.replace(PP_ICU_VARS_REGEXP, (match2, start, key, _type, _idx, end) => {
    return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match2;
  });
  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match2, key) => {
    return replacements.hasOwnProperty(key) ? replacements[key] : match2;
  });
  result = result.replace(PP_ICUS_REGEXP, (match2, key) => {
    if (replacements.hasOwnProperty(key)) {
      const list = replacements[key];
      if (!list.length) {
        throw new Error(`i18n postprocess: unmatched ICU - ${match2} with key: ${key}`);
      }
      return list.shift();
    }
    return match2;
  });
  return result;
}
function \u0275\u0275i18nStart(index, messageIndex, subTemplateIndex = -1) {
  const tView = getTView();
  const lView = getLView();
  const adjustedIndex = HEADER_OFFSET + index;
  ngDevMode && assertDefined(tView, `tView should be defined`);
  const message = getConstant(tView.consts, messageIndex);
  const parentTNode = getCurrentParentTNode();
  if (tView.firstCreatePass) {
    i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message, subTemplateIndex);
  }
  if (tView.type === 2) {
    const componentLView = lView[DECLARATION_COMPONENT_VIEW];
    componentLView[FLAGS] |= 32;
  } else {
    lView[FLAGS] |= 32;
  }
  const tI18n = tView.data[adjustedIndex];
  const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;
  const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);
  const insertInFrontOf = parentTNode && parentTNode.type & 8 ? lView[parentTNode.index] : null;
  prepareI18nBlockForHydration(lView, adjustedIndex, parentTNode, subTemplateIndex);
  applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);
  setInI18nBlock(true);
}
function \u0275\u0275i18nEnd() {
  setInI18nBlock(false);
}
function \u0275\u0275i18n(index, messageIndex, subTemplateIndex) {
  \u0275\u0275i18nStart(index, messageIndex, subTemplateIndex);
  \u0275\u0275i18nEnd();
}
function \u0275\u0275i18nAttributes(index, attrsIndex) {
  const tView = getTView();
  ngDevMode && assertDefined(tView, `tView should be defined`);
  const attrs = getConstant(tView.consts, attrsIndex);
  i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);
}
function \u0275\u0275i18nExp(value) {
  const lView = getLView();
  setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));
  return \u0275\u0275i18nExp;
}
function \u0275\u0275i18nApply(index) {
  applyI18n(getTView(), getLView(), index + HEADER_OFFSET);
}
function \u0275\u0275i18nPostprocess(message, replacements = {}) {
  return i18nPostprocess(message, replacements);
}
function \u0275\u0275listener(eventName, listenerFn, eventTargetResolver) {
  const lView = getLView();
  const tView = getTView();
  const tNode = getCurrentTNode();
  listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn, eventTargetResolver);
  return \u0275\u0275listener;
}
function \u0275\u0275syntheticHostListener(eventName, listenerFn) {
  const tNode = getCurrentTNode();
  const lView = getLView();
  const tView = getTView();
  const currentDef = getCurrentDirectiveDef(tView.data);
  const renderer = loadComponentRenderer(currentDef, tNode, lView);
  listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn);
  return \u0275\u0275syntheticHostListener;
}
function \u0275\u0275domListener(eventName, listenerFn, eventTargetResolver) {
  const lView = getLView();
  const tView = getTView();
  const tNode = getCurrentTNode();
  if (tNode.type & 3 || eventTargetResolver) {
    listenToDomEvent(tNode, tView, lView, eventTargetResolver, lView[RENDERER], eventName, listenerFn, wrapListener(tNode, lView, listenerFn));
  }
  return \u0275\u0275domListener;
}
function listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, eventTargetResolver) {
  ngDevMode && assertTNodeType(
    tNode,
    3 | 12
    /* TNodeType.AnyContainer */
  );
  let processOutputs = true;
  let wrappedListener = null;
  if (tNode.type & 3 || eventTargetResolver) {
    wrappedListener ??= wrapListener(tNode, lView, listenerFn);
    const hasCoalescedDomEvent = listenToDomEvent(tNode, tView, lView, eventTargetResolver, renderer, eventName, listenerFn, wrappedListener);
    if (hasCoalescedDomEvent) {
      processOutputs = false;
    }
  }
  if (processOutputs) {
    const outputConfig = tNode.outputs?.[eventName];
    const hostDirectiveOutputConfig = tNode.hostDirectiveOutputs?.[eventName];
    if (hostDirectiveOutputConfig && hostDirectiveOutputConfig.length) {
      for (let i = 0; i < hostDirectiveOutputConfig.length; i += 2) {
        const index = hostDirectiveOutputConfig[i];
        const lookupName = hostDirectiveOutputConfig[i + 1];
        wrappedListener ??= wrapListener(tNode, lView, listenerFn);
        listenToOutput(tNode, lView, index, lookupName, eventName, wrappedListener);
      }
    }
    if (outputConfig && outputConfig.length) {
      for (const index of outputConfig) {
        wrappedListener ??= wrapListener(tNode, lView, listenerFn);
        listenToOutput(tNode, lView, index, eventName, eventName, wrappedListener);
      }
    }
  }
}
function \u0275\u0275nextContext(level = 1) {
  return nextContextImpl(level);
}
function matchingProjectionSlotIndex(tNode, projectionSlots) {
  let wildcardNgContentIndex = null;
  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);
  for (let i = 0; i < projectionSlots.length; i++) {
    const slotValue = projectionSlots[i];
    if (slotValue === "*") {
      wildcardNgContentIndex = i;
      continue;
    }
    if (ngProjectAsAttrVal === null ? isNodeMatchingSelectorList(
      tNode,
      slotValue,
      /* isProjectionMode */
      true
    ) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {
      return i;
    }
  }
  return wildcardNgContentIndex;
}
function \u0275\u0275projectionDef(projectionSlots) {
  const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST];
  if (!componentNode.projection) {
    const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;
    const projectionHeads = componentNode.projection = newArray(numProjectionSlots, null);
    const tails = projectionHeads.slice();
    let componentChild = componentNode.child;
    while (componentChild !== null) {
      if (componentChild.type !== 128) {
        const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;
        if (slotIndex !== null) {
          if (tails[slotIndex]) {
            tails[slotIndex].projectionNext = componentChild;
          } else {
            projectionHeads[slotIndex] = componentChild;
          }
          tails[slotIndex] = componentChild;
        }
      }
      componentChild = componentChild.next;
    }
  }
}
function \u0275\u0275projection(nodeIndex, selectorIndex = 0, attrs, fallbackTemplateFn, fallbackDecls, fallbackVars) {
  const lView = getLView();
  const tView = getTView();
  const fallbackIndex = fallbackTemplateFn ? nodeIndex + 1 : null;
  if (fallbackIndex !== null) {
    declareNoDirectiveHostTemplate(lView, tView, fallbackIndex, fallbackTemplateFn, fallbackDecls, fallbackVars, null, attrs);
  }
  const tProjectionNode = getOrCreateTNode(tView, HEADER_OFFSET + nodeIndex, 16, null, attrs || null);
  if (tProjectionNode.projection === null) {
    tProjectionNode.projection = selectorIndex;
  }
  setCurrentTNodeAsNotParent();
  const hydrationInfo = lView[HYDRATION];
  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock();
  const componentHostNode = lView[DECLARATION_COMPONENT_VIEW][T_HOST];
  const isEmpty = componentHostNode.projection[tProjectionNode.projection] === null;
  if (isEmpty && fallbackIndex !== null) {
    insertFallbackContent(lView, tView, fallbackIndex);
  } else if (isNodeCreationMode && !isDetachedByI18n(tProjectionNode)) {
    applyProjection(tView, lView, tProjectionNode);
  }
}
function insertFallbackContent(lView, tView, fallbackIndex) {
  const adjustedIndex = HEADER_OFFSET + fallbackIndex;
  const fallbackTNode = tView.data[adjustedIndex];
  const fallbackLContainer = lView[adjustedIndex];
  ngDevMode && assertTNode(fallbackTNode);
  ngDevMode && assertLContainer(fallbackLContainer);
  const dehydratedView = findMatchingDehydratedView(fallbackLContainer, fallbackTNode.tView.ssrId);
  const fallbackLView = createAndRenderEmbeddedLView(lView, fallbackTNode, void 0, {
    dehydratedView
  });
  addLViewToLContainer(fallbackLContainer, fallbackLView, 0, shouldAddViewToDom(fallbackTNode, dehydratedView));
}
function \u0275\u0275contentQuery(directiveIndex, predicate, flags, read) {
  createContentQuery(directiveIndex, predicate, flags, read);
}
function \u0275\u0275viewQuery(predicate, flags, read) {
  createViewQuery(predicate, flags, read);
}
function \u0275\u0275queryRefresh(queryList) {
  const lView = getLView();
  const tView = getTView();
  const queryIndex = getCurrentQueryIndex();
  setCurrentQueryIndex(queryIndex + 1);
  const tQuery = getTQuery(tView, queryIndex);
  if (queryList.dirty && isCreationMode(lView) === ((tQuery.metadata.flags & 2) === 2)) {
    if (tQuery.matches === null) {
      queryList.reset([]);
    } else {
      const result = getQueryResults(lView, queryIndex);
      queryList.reset(result, unwrapElementRef);
      queryList.notifyOnChanges();
    }
    return true;
  }
  return false;
}
function \u0275\u0275loadQuery() {
  return loadQueryInternal(getLView(), getCurrentQueryIndex());
}
function \u0275\u0275contentQuerySignal(directiveIndex, target, predicate, flags, read) {
  bindQueryToSignal(target, createContentQuery(directiveIndex, predicate, flags, read));
}
function \u0275\u0275viewQuerySignal(target, predicate, flags, read) {
  bindQueryToSignal(target, createViewQuery(predicate, flags, read));
}
function \u0275\u0275queryAdvance(indexOffset = 1) {
  setCurrentQueryIndex(getCurrentQueryIndex() + indexOffset);
}
function \u0275\u0275reference(index) {
  const contextLView = getContextLView();
  return load(contextLView, HEADER_OFFSET + index);
}
function toTStylingRange(prev, next) {
  ngDevMode && assertNumberInRange(
    prev,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  ngDevMode && assertNumberInRange(
    next,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return prev << 17 | next << 2;
}
function getTStylingRangePrev(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return tStylingRange >> 17 & 32767;
}
function getTStylingRangePrevDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 2) == 2;
}
function setTStylingRangePrev(tStylingRange, previous) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  ngDevMode && assertNumberInRange(
    previous,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return tStylingRange & ~4294836224 | previous << 17;
}
function setTStylingRangePrevDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return tStylingRange | 2;
}
function getTStylingRangeNext(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 131068) >> 2;
}
function setTStylingRangeNext(tStylingRange, next) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  ngDevMode && assertNumberInRange(
    next,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return tStylingRange & ~131068 | //
  next << 2;
}
function getTStylingRangeNextDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 1) === 1;
}
function setTStylingRangeNextDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return tStylingRange | 1;
}
function insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index, isHostBinding, isClassBinding) {
  ngDevMode && assertFirstUpdatePass(getTView());
  let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;
  let tmplHead = getTStylingRangePrev(tBindings);
  let tmplTail = getTStylingRangeNext(tBindings);
  tData[index] = tStylingKeyWithStatic;
  let isKeyDuplicateOfStatic = false;
  let tStylingKey;
  if (Array.isArray(tStylingKeyWithStatic)) {
    const staticKeyValueArray = tStylingKeyWithStatic;
    tStylingKey = staticKeyValueArray[1];
    if (tStylingKey === null || keyValueArrayIndexOf(staticKeyValueArray, tStylingKey) > 0) {
      isKeyDuplicateOfStatic = true;
    }
  } else {
    tStylingKey = tStylingKeyWithStatic;
  }
  if (isHostBinding) {
    const hasTemplateBindings = tmplTail !== 0;
    if (hasTemplateBindings) {
      const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);
      tData[index + 1] = toTStylingRange(previousNode, tmplHead);
      if (previousNode !== 0) {
        tData[previousNode + 1] = setTStylingRangeNext(tData[previousNode + 1], index);
      }
      tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);
    } else {
      tData[index + 1] = toTStylingRange(tmplHead, 0);
      if (tmplHead !== 0) {
        tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);
      }
      tmplHead = index;
    }
  } else {
    tData[index + 1] = toTStylingRange(tmplTail, 0);
    ngDevMode && assertEqual(tmplHead !== 0 && tmplTail === 0, false, "Adding template bindings after hostBindings is not allowed.");
    if (tmplHead === 0) {
      tmplHead = index;
    } else {
      tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);
    }
    tmplTail = index;
  }
  if (isKeyDuplicateOfStatic) {
    tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);
  }
  markDuplicates(tData, tStylingKey, index, true);
  markDuplicates(tData, tStylingKey, index, false);
  markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);
  tBindings = toTStylingRange(tmplHead, tmplTail);
  if (isClassBinding) {
    tNode.classBindings = tBindings;
  } else {
    tNode.styleBindings = tBindings;
  }
}
function markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {
  const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;
  if (residual != null && typeof tStylingKey == "string" && keyValueArrayIndexOf(residual, tStylingKey) >= 0) {
    tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);
  }
}
function markDuplicates(tData, tStylingKey, index, isPrevDir) {
  const tStylingAtIndex = tData[index + 1];
  const isMap = tStylingKey === null;
  let cursor2 = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);
  let foundDuplicate = false;
  while (cursor2 !== 0 && (foundDuplicate === false || isMap)) {
    ngDevMode && assertIndexInRange(tData, cursor2);
    const tStylingValueAtCursor = tData[cursor2];
    const tStyleRangeAtCursor = tData[cursor2 + 1];
    if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {
      foundDuplicate = true;
      tData[cursor2 + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) : setTStylingRangePrevDuplicate(tStyleRangeAtCursor);
    }
    cursor2 = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) : getTStylingRangeNext(tStyleRangeAtCursor);
  }
  if (foundDuplicate) {
    tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) : setTStylingRangeNextDuplicate(tStylingAtIndex);
  }
}
function isStylingMatch(tStylingKeyCursor, tStylingKey) {
  ngDevMode && assertNotEqual(Array.isArray(tStylingKey), true, "Expected that 'tStylingKey' has been unwrapped");
  if (tStylingKeyCursor === null || // If the cursor is `null` it means that we have map at that
  // location so we must assume that we have a match.
  tStylingKey == null || // If `tStylingKey` is `null` then it is a map therefor assume that it
  // contains a match.
  (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) === tStylingKey) {
    return true;
  } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === "string") {
    return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >= 0;
  }
  return false;
}
function getLastParsedKey(text) {
  return text.substring(parserState.key, parserState.keyEnd);
}
function getLastParsedValue(text) {
  return text.substring(parserState.value, parserState.valueEnd);
}
function parseClassName(text) {
  resetParserState(text);
  return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));
}
function parseClassNameNext(text, index) {
  const end = parserState.textEnd;
  if (end === index) {
    return -1;
  }
  index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);
  return consumeWhitespace(text, index, end);
}
function parseStyle(text) {
  resetParserState(text);
  return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));
}
function parseStyleNext(text, startIndex) {
  const end = parserState.textEnd;
  let index = parserState.key = consumeWhitespace(text, startIndex, end);
  if (end === index) {
    return -1;
  }
  index = parserState.keyEnd = consumeStyleKey(text, index, end);
  index = consumeSeparator(
    text,
    index,
    end,
    58
    /* CharCode.COLON */
  );
  index = parserState.value = consumeWhitespace(text, index, end);
  index = parserState.valueEnd = consumeStyleValue(text, index, end);
  return consumeSeparator(
    text,
    index,
    end,
    59
    /* CharCode.SEMI_COLON */
  );
}
function resetParserState(text) {
  parserState.key = 0;
  parserState.keyEnd = 0;
  parserState.value = 0;
  parserState.valueEnd = 0;
  parserState.textEnd = text.length;
}
function consumeWhitespace(text, startIndex, endIndex) {
  while (startIndex < endIndex && text.charCodeAt(startIndex) <= 32) {
    startIndex++;
  }
  return startIndex;
}
function consumeClassToken(text, startIndex, endIndex) {
  while (startIndex < endIndex && text.charCodeAt(startIndex) > 32) {
    startIndex++;
  }
  return startIndex;
}
function consumeStyleKey(text, startIndex, endIndex) {
  let ch;
  while (startIndex < endIndex && ((ch = text.charCodeAt(startIndex)) === 45 || ch === 95 || (ch & -33) >= 65 && (ch & -33) <= 90 || ch >= 48 && ch <= 57)) {
    startIndex++;
  }
  return startIndex;
}
function consumeSeparator(text, startIndex, endIndex, separator) {
  startIndex = consumeWhitespace(text, startIndex, endIndex);
  if (startIndex < endIndex) {
    if (ngDevMode && text.charCodeAt(startIndex) !== separator) {
      malformedStyleError(text, String.fromCharCode(separator), startIndex);
    }
    startIndex++;
  }
  return startIndex;
}
function consumeStyleValue(text, startIndex, endIndex) {
  let ch1 = -1;
  let ch2 = -1;
  let ch3 = -1;
  let i = startIndex;
  let lastChIndex = i;
  while (i < endIndex) {
    const ch = text.charCodeAt(i++);
    if (ch === 59) {
      return lastChIndex;
    } else if (ch === 34 || ch === 39) {
      lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);
    } else if (startIndex === i - 4 && // We have seen only 4 characters so far "URL(" (Ignore "foo_URL()")
    ch3 === 85 && ch2 === 82 && ch1 === 76 && ch === 40) {
      lastChIndex = i = consumeQuotedText(text, 41, i, endIndex);
    } else if (ch > 32) {
      lastChIndex = i;
    }
    ch3 = ch2;
    ch2 = ch1;
    ch1 = ch & -33;
  }
  return lastChIndex;
}
function consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {
  let ch1 = -1;
  let index = startIndex;
  while (index < endIndex) {
    const ch = text.charCodeAt(index++);
    if (ch == quoteCharCode && ch1 !== 92) {
      return index;
    }
    if (ch == 92 && ch1 === 92) {
      ch1 = 0;
    } else {
      ch1 = ch;
    }
  }
  throw ngDevMode ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) : new Error();
}
function malformedStyleError(text, expecting, index) {
  ngDevMode && assertEqual(typeof text === "string", true, "String expected here");
  throw throwError2(`Malformed style at location ${index} in string '` + text.substring(0, index) + "[>>" + text.substring(index, index + 1) + "<<]" + text.slice(index + 1) + `'. Expecting '${expecting}'.`);
}
function \u0275\u0275styleProp(prop, value, suffix) {
  checkStylingProperty(prop, value, suffix, false);
  return \u0275\u0275styleProp;
}
function \u0275\u0275classProp(className, value) {
  checkStylingProperty(className, value, null, true);
  return \u0275\u0275classProp;
}
function \u0275\u0275styleMap(styles) {
  checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);
}
function styleStringParser(keyValueArray, text) {
  for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {
    styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));
  }
}
function \u0275\u0275classMap(classes) {
  checkStylingMap(classKeyValueArraySet, classStringParser, classes, true);
}
function classStringParser(keyValueArray, text) {
  for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {
    keyValueArraySet(keyValueArray, getLastParsedKey(text), true);
  }
}
function checkStylingProperty(prop, value, suffix, isClassBased) {
  const lView = getLView();
  const tView = getTView();
  const bindingIndex = incrementBindingIndex(2);
  if (tView.firstUpdatePass) {
    stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);
  }
  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
    const tNode = tView.data[getSelectedIndex()];
    updateStyling(tView, tNode, lView, lView[RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);
  }
}
function checkStylingMap(keyValueArraySet2, stringParser, value, isClassBased) {
  const tView = getTView();
  const bindingIndex = incrementBindingIndex(2);
  if (tView.firstUpdatePass) {
    stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);
  }
  const lView = getLView();
  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
    const tNode = tView.data[getSelectedIndex()];
    if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {
      if (ngDevMode) {
        const tStylingKey = tView.data[bindingIndex];
        assertEqual(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, "Styling linked list shadow input should be marked as 'false'");
      }
      let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;
      ngDevMode && isClassBased === false && staticPrefix !== null && assertEqual(staticPrefix.endsWith(";"), true, "Expecting static portion to end with ';'");
      if (staticPrefix !== null) {
        value = concatStringsWithSpace(staticPrefix, value ? value : "");
      }
      setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);
    } else {
      updateStylingMap(tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet2, stringParser, value), isClassBased, bindingIndex);
    }
  }
}
function isInHostBindings(tView, bindingIndex) {
  return bindingIndex >= tView.expandoStartIndex;
}
function stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {
  ngDevMode && assertFirstUpdatePass(tView);
  const tData = tView.data;
  if (tData[bindingIndex + 1] === null) {
    const tNode = tData[getSelectedIndex()];
    ngDevMode && assertDefined(tNode, "TNode expected");
    const isHostBindings = isInHostBindings(tView, bindingIndex);
    if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {
      tStylingKey = false;
    }
    tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);
    insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);
  }
}
function wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {
  const hostDirectiveDef = getCurrentDirectiveDef(tData);
  let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
  if (hostDirectiveDef === null) {
    const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;
    if (isFirstStylingInstructionInTemplate) {
      stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);
      stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);
      residual = null;
    }
  } else {
    const directiveStylingLast = tNode.directiveStylingLast;
    const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;
    if (isFirstStylingInstructionInHostBinding) {
      stylingKey = collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);
      if (residual === null) {
        let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);
        if (templateStylingKey !== void 0 && Array.isArray(templateStylingKey)) {
          templateStylingKey = collectStylingFromDirectives(null, tData, tNode, templateStylingKey[1], isClassBased);
          templateStylingKey = collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);
          setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);
        }
      } else {
        residual = collectResidual(tData, tNode, isClassBased);
      }
    }
  }
  if (residual !== void 0) {
    isClassBased ? tNode.residualClasses = residual : tNode.residualStyles = residual;
  }
  return stylingKey;
}
function getTemplateHeadTStylingKey(tData, tNode, isClassBased) {
  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
  if (getTStylingRangeNext(bindings) === 0) {
    return void 0;
  }
  return tData[getTStylingRangePrev(bindings)];
}
function setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {
  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
  ngDevMode && assertNotEqual(getTStylingRangeNext(bindings), 0, "Expecting to have at least one template styling binding.");
  tData[getTStylingRangePrev(bindings)] = tStylingKey;
}
function collectResidual(tData, tNode, isClassBased) {
  let residual = void 0;
  const directiveEnd = tNode.directiveEnd;
  ngDevMode && assertNotEqual(tNode.directiveStylingLast, -1, "By the time this function gets called at least one hostBindings-node styling instruction must have executed.");
  for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {
    const attrs = tData[i].hostAttrs;
    residual = collectStylingFromTAttrs(residual, attrs, isClassBased);
  }
  return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);
}
function collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {
  let currentDirective = null;
  const directiveEnd = tNode.directiveEnd;
  let directiveStylingLast = tNode.directiveStylingLast;
  if (directiveStylingLast === -1) {
    directiveStylingLast = tNode.directiveStart;
  } else {
    directiveStylingLast++;
  }
  while (directiveStylingLast < directiveEnd) {
    currentDirective = tData[directiveStylingLast];
    ngDevMode && assertDefined(currentDirective, "expected to be defined");
    stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);
    if (currentDirective === hostDirectiveDef)
      break;
    directiveStylingLast++;
  }
  if (hostDirectiveDef !== null) {
    tNode.directiveStylingLast = directiveStylingLast;
  }
  return stylingKey;
}
function collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {
  const desiredMarker = isClassBased ? 1 : 2;
  let currentMarker = -1;
  if (attrs !== null) {
    for (let i = 0; i < attrs.length; i++) {
      const item = attrs[i];
      if (typeof item === "number") {
        currentMarker = item;
      } else {
        if (currentMarker === desiredMarker) {
          if (!Array.isArray(stylingKey)) {
            stylingKey = stylingKey === void 0 ? [] : ["", stylingKey];
          }
          keyValueArraySet(stylingKey, item, isClassBased ? true : attrs[++i]);
        }
      }
    }
  }
  return stylingKey === void 0 ? null : stylingKey;
}
function toStylingKeyValueArray(keyValueArraySet2, stringParser, value) {
  if (value == null || value === "")
    return EMPTY_ARRAY;
  const styleKeyValueArray = [];
  const unwrappedValue = unwrapSafeValue(value);
  if (Array.isArray(unwrappedValue)) {
    for (let i = 0; i < unwrappedValue.length; i++) {
      keyValueArraySet2(styleKeyValueArray, unwrappedValue[i], true);
    }
  } else if (typeof unwrappedValue === "object") {
    for (const key in unwrappedValue) {
      if (unwrappedValue.hasOwnProperty(key)) {
        keyValueArraySet2(styleKeyValueArray, key, unwrappedValue[key]);
      }
    }
  } else if (typeof unwrappedValue === "string") {
    stringParser(styleKeyValueArray, unwrappedValue);
  } else {
    ngDevMode && throwError2("Unsupported styling type: " + typeof unwrappedValue + " (" + unwrappedValue + ")");
  }
  return styleKeyValueArray;
}
function styleKeyValueArraySet(keyValueArray, key, value) {
  keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));
}
function classKeyValueArraySet(keyValueArray, key, value) {
  const stringKey = String(key);
  if (stringKey !== "" && !stringKey.includes(" ")) {
    keyValueArraySet(keyValueArray, stringKey, value);
  }
}
function updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {
  if (oldKeyValueArray === NO_CHANGE) {
    oldKeyValueArray = EMPTY_ARRAY;
  }
  let oldIndex = 0;
  let newIndex = 0;
  let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;
  let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;
  while (oldKey !== null || newKey !== null) {
    ngDevMode && assertLessThan(oldIndex, 999, "Are we stuck in infinite loop?");
    ngDevMode && assertLessThan(newIndex, 999, "Are we stuck in infinite loop?");
    const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : void 0;
    const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : void 0;
    let setKey = null;
    let setValue = void 0;
    if (oldKey === newKey) {
      oldIndex += 2;
      newIndex += 2;
      if (oldValue !== newValue) {
        setKey = newKey;
        setValue = newValue;
      }
    } else if (newKey === null || oldKey !== null && oldKey < newKey) {
      oldIndex += 2;
      setKey = oldKey;
    } else {
      ngDevMode && assertDefined(newKey, "Expecting to have a valid key");
      newIndex += 2;
      setKey = newKey;
      setValue = newValue;
    }
    if (setKey !== null) {
      updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);
    }
    oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;
    newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;
  }
}
function updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {
  if (!(tNode.type & 3)) {
    return;
  }
  const tData = tView.data;
  const tRange = tData[bindingIndex + 1];
  const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ? findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) : void 0;
  if (!isStylingValuePresent(higherPriorityValue)) {
    if (!isStylingValuePresent(value)) {
      if (getTStylingRangePrevDuplicate(tRange)) {
        value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);
      }
    }
    const rNode = getNativeByIndex(getSelectedIndex(), lView);
    applyStyling(renderer, isClassBased, rNode, prop, value);
  }
}
function findStylingValue(tData, tNode, lView, prop, index, isClassBased) {
  const isPrevDirection = tNode === null;
  let value = void 0;
  while (index > 0) {
    const rawKey = tData[index];
    const containsStatics = Array.isArray(rawKey);
    const key = containsStatics ? rawKey[1] : rawKey;
    const isStylingMap = key === null;
    let valueAtLViewIndex = lView[index + 1];
    if (valueAtLViewIndex === NO_CHANGE) {
      valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : void 0;
    }
    let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) : key === prop ? valueAtLViewIndex : void 0;
    if (containsStatics && !isStylingValuePresent(currentValue)) {
      currentValue = keyValueArrayGet(rawKey, prop);
    }
    if (isStylingValuePresent(currentValue)) {
      value = currentValue;
      if (isPrevDirection) {
        return value;
      }
    }
    const tRange = tData[index + 1];
    index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);
  }
  if (tNode !== null) {
    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
    if (residual != null) {
      value = keyValueArrayGet(residual, prop);
    }
  }
  return value;
}
function isStylingValuePresent(value) {
  return value !== void 0;
}
function normalizeSuffix(value, suffix) {
  if (value == null || value === "") ;
  else if (typeof suffix === "string") {
    value = value + suffix;
  } else if (typeof value === "object") {
    value = stringify(unwrapSafeValue(value));
  }
  return value;
}
function hasStylingInputShadow(tNode, isClassBased) {
  return (tNode.flags & (isClassBased ? 8 : 16)) !== 0;
}
function \u0275\u0275text(index, value = "") {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = index + HEADER_OFFSET;
  ngDevMode && assertTNodeCreationIndex(lView, index);
  const tNode = tView.firstCreatePass ? getOrCreateTNode(tView, adjustedIndex, 1, value, null) : tView.data[adjustedIndex];
  const textNative = _locateOrCreateTextNode(tView, lView, tNode, value, index);
  lView[adjustedIndex] = textNative;
  if (wasLastNodeCreated()) {
    appendChild(tView, lView, textNative, tNode);
  }
  setCurrentTNode(tNode, false);
}
function interpolationV(lView, values2) {
  ngDevMode && assertLessThan(2, values2.length, "should have at least 3 values");
  let isBindingUpdated = false;
  let bindingIndex = getBindingIndex();
  for (let i = 1; i < values2.length; i += 2) {
    isBindingUpdated = bindingUpdated(lView, bindingIndex++, values2[i]) || isBindingUpdated;
  }
  setBindingIndex(bindingIndex);
  if (!isBindingUpdated) {
    return NO_CHANGE;
  }
  let content2 = values2[0];
  for (let i = 1; i < values2.length; i += 2) {
    content2 += renderStringify(values2[i]) + (i + 1 !== values2.length ? values2[i + 1] : "");
  }
  return content2;
}
function interpolation1(lView, prefix, v0, suffix = "") {
  const different = bindingUpdated(lView, nextBindingIndex(), v0);
  return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;
}
function interpolation2(lView, prefix, v0, i0, v1, suffix = "") {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated2(lView, bindingIndex, v0, v1);
  incrementBindingIndex(2);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;
}
function interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix = "") {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);
  incrementBindingIndex(3);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix : NO_CHANGE;
}
function interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix = "") {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  incrementBindingIndex(4);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + suffix : NO_CHANGE;
}
function interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix = "") {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated(lView, bindingIndex + 4, v4) || different;
  incrementBindingIndex(5);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + suffix : NO_CHANGE;
}
function interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix = "") {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;
  incrementBindingIndex(6);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix : NO_CHANGE;
}
function interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix = "") {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;
  incrementBindingIndex(7);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + suffix : NO_CHANGE;
}
function interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix = "") {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;
  incrementBindingIndex(8);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix : NO_CHANGE;
}
function \u0275\u0275textInterpolate(v0) {
  \u0275\u0275textInterpolate1("", v0);
  return \u0275\u0275textInterpolate;
}
function \u0275\u0275textInterpolate1(prefix, v0, suffix) {
  const lView = getLView();
  const interpolated = interpolation1(lView, prefix, v0, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate1;
}
function \u0275\u0275textInterpolate2(prefix, v0, i0, v1, suffix) {
  const lView = getLView();
  const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate2;
}
function \u0275\u0275textInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
  const lView = getLView();
  const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate3;
}
function \u0275\u0275textInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const lView = getLView();
  const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate4;
}
function \u0275\u0275textInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const lView = getLView();
  const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate5;
}
function \u0275\u0275textInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const lView = getLView();
  const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate6;
}
function \u0275\u0275textInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const lView = getLView();
  const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate7;
}
function \u0275\u0275textInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const lView = getLView();
  const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate8;
}
function \u0275\u0275textInterpolateV(values2) {
  const lView = getLView();
  const interpolated = interpolationV(lView, values2);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolateV;
}
function textBindingInternal(lView, index, value) {
  ngDevMode && assertString(value, "Value should be a string");
  ngDevMode && assertNotSame(value, NO_CHANGE, "value should not be NO_CHANGE");
  ngDevMode && assertIndexInRange(lView, index);
  const element = getNativeByIndex(index, lView);
  ngDevMode && assertDefined(element, "native element should exist");
  updateTextNode(lView[RENDERER], element, value);
}
function \u0275\u0275twoWayProperty(propName, value, sanitizer) {
  if (isWritableSignal(value)) {
    value = value();
  }
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    setPropertyAndInputs(tNode, lView, propName, value, lView[RENDERER], sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275twoWayProperty;
}
function \u0275\u0275twoWayBindingSet(target, value) {
  const canWrite = isWritableSignal(target);
  canWrite && target.set(value);
  return canWrite;
}
function \u0275\u0275twoWayListener(eventName, listenerFn) {
  const lView = getLView();
  const tView = getTView();
  const tNode = getCurrentTNode();
  listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn);
  return \u0275\u0275twoWayListener;
}
function \u0275\u0275declareLet(index) {
  const tView = getTView();
  const lView = getLView();
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = getOrCreateTNode(tView, adjustedIndex, 128, null, null);
  setCurrentTNode(tNode, false);
  store(tView, lView, adjustedIndex, UNINITIALIZED_LET);
  return \u0275\u0275declareLet;
}
function \u0275\u0275storeLet(value) {
  performanceMarkFeature("NgLet");
  const tView = getTView();
  const lView = getLView();
  const index = getSelectedIndex();
  store(tView, lView, index, value);
  return value;
}
function \u0275\u0275readContextLet(index) {
  const contextLView = getContextLView();
  const value = load(contextLView, HEADER_OFFSET + index);
  if (value === UNINITIALIZED_LET) {
    throw new RuntimeError(314, ngDevMode && "Attempting to access a @let declaration whose value is not available yet");
  }
  return value;
}
function \u0275\u0275attachSourceLocations(templatePath, locations) {
  const tView = getTView();
  const lView = getLView();
  const renderer = lView[RENDERER];
  const attributeName = "data-ng-source-location";
  for (const [index, offset, line, column] of locations) {
    const tNode = getTNode(tView, index + HEADER_OFFSET);
    ngDevMode && assertTNodeType(
      tNode,
      2
      /* TNodeType.Element */
    );
    const node = getNativeByIndex(index + HEADER_OFFSET, lView);
    if (!node.hasAttribute(attributeName)) {
      const attributeValue = `${templatePath}@o:${offset},l:${line},c:${column}`;
      renderer.setAttribute(node, attributeName, attributeValue);
    }
  }
}
function \u0275\u0275interpolate(v0) {
  return bindingUpdated(getLView(), nextBindingIndex(), v0) ? renderStringify(v0) : NO_CHANGE;
}
function \u0275\u0275interpolate1(prefix, v0, suffix = "") {
  return interpolation1(getLView(), prefix, v0, suffix);
}
function \u0275\u0275interpolate2(prefix, v0, i0, v1, suffix = "") {
  return interpolation2(getLView(), prefix, v0, i0, v1, suffix);
}
function \u0275\u0275interpolate3(prefix, v0, i0, v1, i1, v2, suffix = "") {
  return interpolation3(getLView(), prefix, v0, i0, v1, i1, v2, suffix);
}
function \u0275\u0275interpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix = "") {
  return interpolation4(getLView(), prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
}
function \u0275\u0275interpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix = "") {
  return interpolation5(getLView(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
}
function \u0275\u0275interpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix = "") {
  return interpolation6(getLView(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
}
function \u0275\u0275interpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix = "") {
  return interpolation7(getLView(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
}
function \u0275\u0275interpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix = "") {
  return interpolation8(getLView(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
}
function \u0275\u0275interpolateV(values2) {
  return interpolationV(getLView(), values2);
}
function providersResolver(def, providers, viewProviders) {
  const tView = getTView();
  if (tView.firstCreatePass) {
    const isComponent2 = isComponentDef(def);
    resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent2, true);
    resolveProvider(providers, tView.data, tView.blueprint, isComponent2, false);
  }
}
function resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent2, isViewProvider) {
  provider = resolveForwardRef(provider);
  if (Array.isArray(provider)) {
    for (let i = 0; i < provider.length; i++) {
      resolveProvider(provider[i], tInjectables, lInjectablesBlueprint, isComponent2, isViewProvider);
    }
  } else {
    const tView = getTView();
    const lView = getLView();
    const tNode = getCurrentTNode();
    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);
    const providerFactory = providerToFactory(provider);
    if (ngDevMode) {
      const injector = new NodeInjector(tNode, lView);
      runInInjectorProfilerContext(injector, token, () => {
        emitProviderConfiguredEvent(provider, isViewProvider);
      });
    }
    const beginIndex = tNode.providerIndexes & 1048575;
    const endIndex = tNode.directiveStart;
    const cptViewProvidersCount = tNode.providerIndexes >> 20;
    if (isTypeProvider(provider) || !provider.multi) {
      const factory = new NodeInjectorFactory(providerFactory, isViewProvider, \u0275\u0275directiveInject, ngDevMode ? providerName(provider) : null);
      const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);
      if (existingFactoryIndex === -1) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
        registerDestroyHooksIfSupported(tView, provider, tInjectables.length);
        tInjectables.push(token);
        tNode.directiveStart++;
        tNode.directiveEnd++;
        if (isViewProvider) {
          tNode.providerIndexes += 1048576;
        }
        lInjectablesBlueprint.push(factory);
        lView.push(factory);
      } else {
        lInjectablesBlueprint[existingFactoryIndex] = factory;
        lView[existingFactoryIndex] = factory;
      }
    } else {
      const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);
      const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);
      const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex];
      const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];
      if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
        const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent2, providerFactory, provider);
        if (!isViewProvider && doesViewProvidersFactoryExist) {
          lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;
        }
        registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);
        tInjectables.push(token);
        tNode.directiveStart++;
        tNode.directiveEnd++;
        if (isViewProvider) {
          tNode.providerIndexes += 1048576;
        }
        lInjectablesBlueprint.push(factory);
        lView.push(factory);
      } else {
        const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent2);
        registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex : existingViewProvidersFactoryIndex, indexInFactory);
      }
      if (!isViewProvider && isComponent2 && doesViewProvidersFactoryExist) {
        lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;
      }
    }
  }
}
function registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {
  const providerIsTypeProvider = isTypeProvider(provider);
  const providerIsClassProvider = isClassProvider(provider);
  if (providerIsTypeProvider || providerIsClassProvider) {
    const classToken = providerIsClassProvider ? resolveForwardRef(provider.useClass) : provider;
    const prototype = classToken.prototype;
    const ngOnDestroy = prototype.ngOnDestroy;
    if (ngOnDestroy) {
      const hooks = tView.destroyHooks || (tView.destroyHooks = []);
      if (!providerIsTypeProvider && provider.multi) {
        ngDevMode && assertDefined(indexInFactory, "indexInFactory when registering multi factory destroy hook");
        const existingCallbacksIndex = hooks.indexOf(contextIndex);
        if (existingCallbacksIndex === -1) {
          hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);
        } else {
          hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);
        }
      } else {
        hooks.push(contextIndex, ngOnDestroy);
      }
    }
  }
}
function multiFactoryAdd(multiFactory2, factory, isComponentProvider) {
  if (isComponentProvider) {
    multiFactory2.componentProviders++;
  }
  return multiFactory2.multi.push(factory) - 1;
}
function indexOf(item, arr, begin, end) {
  for (let i = begin; i < end; i++) {
    if (arr[i] === item)
      return i;
  }
  return -1;
}
function multiProvidersFactoryResolver(_, flags, tData, lData, tNode) {
  return multiResolve(this.multi, []);
}
function multiViewProvidersFactoryResolver(_, _flags, _tData, lView, tNode) {
  const factories = this.multi;
  let result;
  if (this.providerFactory) {
    const componentCount = this.providerFactory.componentProviders;
    const multiProviders = getNodeInjectable(lView, lView[TVIEW], this.providerFactory.index, tNode);
    result = multiProviders.slice(0, componentCount);
    multiResolve(factories, result);
    for (let i = componentCount; i < multiProviders.length; i++) {
      result.push(multiProviders[i]);
    }
  } else {
    result = [];
    multiResolve(factories, result);
  }
  return result;
}
function multiResolve(factories, result) {
  for (let i = 0; i < factories.length; i++) {
    const factory = factories[i];
    result.push(factory());
  }
  return result;
}
function multiFactory(factoryFn, index, isViewProvider, isComponent2, f, provider) {
  const factory = new NodeInjectorFactory(factoryFn, isViewProvider, \u0275\u0275directiveInject, ngDevMode ? providerName(provider) : null);
  factory.multi = [];
  factory.index = index;
  factory.componentProviders = 0;
  multiFactoryAdd(factory, f, isComponent2 && !isViewProvider);
  return factory;
}
function providerName(provider) {
  if (Array.isArray(provider)) {
    return null;
  }
  if (isTypeProvider(provider)) {
    return provider.name;
  } else if (isClassProvider(provider)) {
    if (provider.provide instanceof InjectionToken) {
      return `('${provider.provide.toString()}':${provider.useClass.name})`;
    }
    return provider.useClass.name;
  } else if (provider.provide instanceof InjectionToken) {
    return provider.provide.toString();
  } else if (typeof provider.provide === "string") {
    return provider.provide;
  } else {
    return null;
  }
}
function \u0275\u0275ProvidersFeature(providers, viewProviders = []) {
  return (definition) => {
    definition.providersResolver = (def, processProvidersFn) => {
      return providersResolver(
        def,
        //
        processProvidersFn ? processProvidersFn(providers) : providers,
        //
        viewProviders
      );
    };
  };
}
function \u0275\u0275ExternalStylesFeature(styleUrls) {
  return (definition) => {
    if (styleUrls.length < 1) {
      return;
    }
    definition.getExternalStyles = (encapsulationId) => {
      const urls = styleUrls.map((value) => value + "?ngcomp" + (encapsulationId ? "=" + encodeURIComponent(encapsulationId) : "") + "&e=" + definition.encapsulation);
      return urls;
    };
  };
}
function \u0275\u0275setComponentScope(type, directives, pipes) {
  const def = type.\u0275cmp;
  def.directiveDefs = extractDefListOrFactory(directives, extractDirectiveDef);
  def.pipeDefs = extractDefListOrFactory(pipes, getPipeDef);
}
function \u0275\u0275setNgModuleScope(type, scope) {
  return noSideEffects(() => {
    const ngModuleDef = getNgModuleDefOrThrow(type);
    ngModuleDef.declarations = convertToTypeArray(scope.declarations || EMPTY_ARRAY);
    ngModuleDef.imports = convertToTypeArray(scope.imports || EMPTY_ARRAY);
    ngModuleDef.exports = convertToTypeArray(scope.exports || EMPTY_ARRAY);
    if (scope.bootstrap) {
      ngModuleDef.bootstrap = convertToTypeArray(scope.bootstrap);
    }
    depsTracker.registerNgModule(type, scope);
  });
}
function convertToTypeArray(values2) {
  if (typeof values2 === "function") {
    return values2;
  }
  const flattenValues = flatten(values2);
  if (flattenValues.some(isForwardRef)) {
    return () => flattenValues.map(resolveForwardRef).map(maybeUnwrapModuleWithProviders);
  } else {
    return flattenValues.map(maybeUnwrapModuleWithProviders);
  }
}
function maybeUnwrapModuleWithProviders(value) {
  return isModuleWithProviders(value) ? value.ngModule : value;
}
function \u0275\u0275pureFunction0(slotOffset, pureFn, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  return lView[bindingIndex] === NO_CHANGE ? updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) : getBinding(lView, bindingIndex);
}
function \u0275\u0275pureFunction1(slotOffset, pureFn, exp, thisArg) {
  return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);
}
function \u0275\u0275pureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {
  return pureFunction2Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, thisArg);
}
function \u0275\u0275pureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
  return pureFunction3Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);
}
function \u0275\u0275pureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
  return pureFunction4Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);
}
function \u0275\u0275pureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated(lView, bindingIndex + 4, exp5) || different ? updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) : pureFn(exp1, exp2, exp3, exp4, exp5)) : getBinding(lView, bindingIndex + 5);
}
function \u0275\u0275pureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ? updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) : getBinding(lView, bindingIndex + 6);
}
function \u0275\u0275pureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ? updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) : getBinding(lView, bindingIndex + 7);
}
function \u0275\u0275pureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ? updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) : getBinding(lView, bindingIndex + 8);
}
function \u0275\u0275pureFunctionV(slotOffset, pureFn, exps, thisArg) {
  return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);
}
function getPureFunctionReturnValue(lView, returnValueIndex) {
  ngDevMode && assertIndexInRange(lView, returnValueIndex);
  const lastReturnValue = lView[returnValueIndex];
  return lastReturnValue === NO_CHANGE ? void 0 : lastReturnValue;
}
function pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getPureFunctionReturnValue(lView, bindingIndex + 1);
}
function pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getPureFunctionReturnValue(lView, bindingIndex + 2);
}
function pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ? updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) : getPureFunctionReturnValue(lView, bindingIndex + 3);
}
function pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ? updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) : getPureFunctionReturnValue(lView, bindingIndex + 4);
}
function pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {
  let bindingIndex = bindingRoot + slotOffset;
  let different = false;
  for (let i = 0; i < exps.length; i++) {
    bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);
  }
  return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) : getPureFunctionReturnValue(lView, bindingIndex);
}
function \u0275\u0275pipe(index, pipeName) {
  const tView = getTView();
  let pipeDef;
  const adjustedIndex = index + HEADER_OFFSET;
  if (tView.firstCreatePass) {
    pipeDef = getPipeDef2(pipeName, tView.pipeRegistry);
    tView.data[adjustedIndex] = pipeDef;
    if (pipeDef.onDestroy) {
      (tView.destroyHooks ??= []).push(adjustedIndex, pipeDef.onDestroy);
    }
  } else {
    pipeDef = tView.data[adjustedIndex];
  }
  const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));
  let previousInjectorProfilerContext;
  if (ngDevMode) {
    previousInjectorProfilerContext = setInjectorProfilerContext({
      injector: new NodeInjector(getCurrentTNode(), getLView()),
      token: pipeDef.type
    });
  }
  const previousInjectImplementation = setInjectImplementation(\u0275\u0275directiveInject);
  try {
    const previousIncludeViewProviders = setIncludeViewProviders(false);
    const pipeInstance = pipeFactory();
    setIncludeViewProviders(previousIncludeViewProviders);
    store(tView, getLView(), adjustedIndex, pipeInstance);
    return pipeInstance;
  } finally {
    setInjectImplementation(previousInjectImplementation);
    ngDevMode && setInjectorProfilerContext(previousInjectorProfilerContext);
  }
}
function getPipeDef2(name2, registry) {
  if (registry) {
    if (ngDevMode) {
      const pipes = registry.filter((pipe2) => pipe2.name === name2);
      if (pipes.length > 1) {
        console.warn(formatRuntimeError(313, getMultipleMatchingPipesMessage(name2)));
      }
    }
    for (let i = registry.length - 1; i >= 0; i--) {
      const pipeDef = registry[i];
      if (name2 === pipeDef.name) {
        return pipeDef;
      }
    }
  }
  if (ngDevMode) {
    throw new RuntimeError(-302, getPipeNotFoundErrorMessage(name2));
  }
  return;
}
function getMultipleMatchingPipesMessage(name2) {
  const lView = getLView();
  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
  const context2 = declarationLView[CONTEXT];
  const hostIsStandalone = isHostComponentStandalone(lView);
  const componentInfoMessage = context2 ? ` in the '${context2.constructor.name}' component` : "";
  const verifyMessage = `check ${hostIsStandalone ? "'@Component.imports' of this component" : "the imports of this module"}`;
  const errorMessage = `Multiple pipes match the name \`${name2}\`${componentInfoMessage}. ${verifyMessage}`;
  return errorMessage;
}
function getPipeNotFoundErrorMessage(name2) {
  const lView = getLView();
  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
  const context2 = declarationLView[CONTEXT];
  const hostIsStandalone = isHostComponentStandalone(lView);
  const componentInfoMessage = context2 ? ` in the '${context2.constructor.name}' component` : "";
  const verifyMessage = `Verify that it is ${hostIsStandalone ? "included in the '@Component.imports' of this component" : "declared or imported in this module"}`;
  const errorMessage = `The pipe '${name2}' could not be found${componentInfoMessage}. ${verifyMessage}`;
  return errorMessage;
}
function \u0275\u0275pipeBind1(index, offset, v1) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction1Internal(lView, getBindingRoot(), offset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1);
}
function \u0275\u0275pipeBind2(index, slotOffset, v1, v2) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction2Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) : pipeInstance.transform(v1, v2);
}
function \u0275\u0275pipeBind3(index, slotOffset, v1, v2, v3) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction3Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) : pipeInstance.transform(v1, v2, v3);
}
function \u0275\u0275pipeBind4(index, slotOffset, v1, v2, v3, v4) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) : pipeInstance.transform(v1, v2, v3, v4);
}
function \u0275\u0275pipeBindV(index, slotOffset, values2) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunctionVInternal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, values2, pipeInstance) : pipeInstance.transform.apply(pipeInstance, values2);
}
function isPure(lView, index) {
  return lView[TVIEW].data[index].pure;
}
function \u0275\u0275templateRefExtractor(tNode, lView) {
  return createTemplateRef(tNode, lView);
}
function \u0275\u0275getComponentDepsFactory(type, rawImports) {
  return () => {
    try {
      return depsTracker.getComponentDependencies(type, rawImports).dependencies;
    } catch (e) {
      console.error(`Computing dependencies in local compilation mode for the component "${type.name}" failed with the exception:`, e);
      throw e;
    }
  };
}
function \u0275setClassDebugInfo(type, debugInfo) {
  const def = getComponentDef(type);
  if (def !== null) {
    def.debugInfo = debugInfo;
  }
}
function \u0275\u0275getReplaceMetadataURL(id2, timestamp, base2) {
  const url = `./@ng/component?c=${id2}&t=${encodeURIComponent(timestamp)}`;
  return new URL(url, base2).href;
}
function \u0275\u0275replaceMetadata(type, applyMetadata, namespaces, locals, importMeta = null, id2 = null) {
  ngDevMode && assertComponentDef(type);
  const currentDef = getComponentDef(type);
  applyMetadata.apply(null, [type, namespaces, ...locals]);
  const { newDef, oldDef } = mergeWithExistingDefinition(currentDef, getComponentDef(type));
  type[NG_COMP_DEF] = newDef;
  if (oldDef.tView) {
    const trackedViews = getTrackedLViews().values();
    for (const root of trackedViews) {
      if (isRootView(root) && root[PARENT] === null) {
        recreateMatchingLViews(importMeta, id2, newDef, oldDef, root);
      }
    }
  }
}
function mergeWithExistingDefinition(currentDef, newDef) {
  const clone = __spreadValues({}, currentDef);
  const replacement = Object.assign(currentDef, newDef, {
    // We need to keep the existing directive and pipe defs, because they can get patched on
    // by a call to `setComponentScope` from a module file. That call won't make it into the
    // HMR replacement function, because it lives in an entirely different file.
    directiveDefs: clone.directiveDefs,
    pipeDefs: clone.pipeDefs,
    // Preserve the old `setInput` function, because it has some state.
    // This is fine, because the component instance is preserved as well.
    setInput: clone.setInput,
    // Externally this is redundant since we redeclare the definition using the original type.
    // Internally we may receive a definition with an alternate, but identical, type so we have
    // to ensure that the original one is preserved.
    type: clone.type
  });
  ngDevMode && assertEqual(replacement, currentDef, "Expected definition to be merged in place");
  return { newDef: replacement, oldDef: clone };
}
function recreateMatchingLViews(importMeta, id2, newDef, oldDef, rootLView) {
  ngDevMode && assertDefined(oldDef.tView, "Expected a component definition that has been instantiated at least once");
  const tView = rootLView[TVIEW];
  if (tView === oldDef.tView) {
    ngDevMode && assertComponentDef(oldDef.type);
    recreateLView(importMeta, id2, newDef, oldDef, rootLView);
    return;
  }
  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    const current = rootLView[i];
    if (isLContainer(current)) {
      if (isLView(current[HOST])) {
        recreateMatchingLViews(importMeta, id2, newDef, oldDef, current[HOST]);
      }
      for (let j = CONTAINER_HEADER_OFFSET; j < current.length; j++) {
        recreateMatchingLViews(importMeta, id2, newDef, oldDef, current[j]);
      }
    } else if (isLView(current)) {
      recreateMatchingLViews(importMeta, id2, newDef, oldDef, current);
    }
  }
}
function clearRendererCache(factory, def) {
  factory.componentReplaced?.(def.id);
}
function recreateLView(importMeta, id2, newDef, oldDef, lView) {
  const instance = lView[CONTEXT];
  let host = lView[HOST];
  const parentLView = lView[PARENT];
  ngDevMode && assertLView(parentLView);
  const tNode = lView[T_HOST];
  ngDevMode && assertTNodeType(
    tNode,
    2
    /* TNodeType.Element */
  );
  ngDevMode && assertNotEqual(newDef, oldDef, "Expected different component definition");
  const zone = lView[INJECTOR].get(NgZone, null);
  const recreate = () => {
    if (oldDef.encapsulation === ViewEncapsulation.ShadowDom) {
      const newHost = host.cloneNode(false);
      host.replaceWith(newHost);
      host = newHost;
    }
    const newTView = getOrCreateComponentTView(newDef);
    const newLView = createLView(
      parentLView,
      newTView,
      instance,
      getInitialLViewFlagsFromDef(newDef),
      host,
      tNode,
      null,
      null,
      // The renderer will be created a bit further down once the old one is destroyed.
      null,
      null,
      null
    );
    replaceLViewInTree(parentLView, lView, newLView, tNode.index);
    destroyLView(lView[TVIEW], lView);
    const rendererFactory = lView[ENVIRONMENT].rendererFactory;
    clearRendererCache(rendererFactory, oldDef);
    newLView[RENDERER] = rendererFactory.createRenderer(host, newDef);
    removeViewFromDOM(lView[TVIEW], lView);
    resetProjectionState(tNode);
    renderView(newTView, newLView, instance);
    refreshView(newTView, newLView, newTView.template, instance);
  };
  if (zone === null) {
    executeWithInvalidateFallback(importMeta, id2, recreate);
  } else {
    zone.run(() => executeWithInvalidateFallback(importMeta, id2, recreate));
  }
}
function executeWithInvalidateFallback(importMeta, id2, callback) {
  try {
    callback();
  } catch (e) {
    const error = e;
    if (id2 !== null && error.message) {
      const toLog = error.message + (error.stack ? "\n" + error.stack : "");
      importMeta?.hot?.send?.("angular:invalidate", { id: id2, message: toLog, error: true });
    }
    throw e;
  }
}
function replaceLViewInTree(parentLView, oldLView, newLView, index) {
  for (let i = HEADER_OFFSET; i < parentLView[TVIEW].bindingStartIndex; i++) {
    const current = parentLView[i];
    if ((isLView(current) || isLContainer(current)) && current[NEXT] === oldLView) {
      current[NEXT] = newLView;
      break;
    }
  }
  if (parentLView[CHILD_HEAD] === oldLView) {
    parentLView[CHILD_HEAD] = newLView;
  }
  if (parentLView[CHILD_TAIL] === oldLView) {
    parentLView[CHILD_TAIL] = newLView;
  }
  newLView[NEXT] = oldLView[NEXT];
  oldLView[NEXT] = null;
  parentLView[index] = newLView;
}
function resetProjectionState(tNode) {
  if (tNode.projection !== null) {
    for (const current of tNode.projection) {
      if (isTNodeShape(current)) {
        current.projectionNext = null;
        current.flags &= ~2;
      }
    }
    tNode.projection = null;
  }
}
function setJitOptions(options) {
  if (jitOptions !== null) {
    if (options.defaultEncapsulation !== jitOptions.defaultEncapsulation) {
      ngDevMode && console.error("Provided value for `defaultEncapsulation` can not be changed once it has been set.");
      return;
    }
    if (options.preserveWhitespaces !== jitOptions.preserveWhitespaces) {
      ngDevMode && console.error("Provided value for `preserveWhitespaces` can not be changed once it has been set.");
      return;
    }
  }
  jitOptions = options;
}
function getJitOptions() {
  return jitOptions;
}
function enqueueModuleForDelayedScoping(moduleType, ngModule) {
  moduleQueue.push({ moduleType, ngModule });
}
function flushModuleScopingQueueAsMuchAsPossible() {
  if (!flushingModuleQueue) {
    flushingModuleQueue = true;
    try {
      for (let i = moduleQueue.length - 1; i >= 0; i--) {
        const { moduleType, ngModule } = moduleQueue[i];
        if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {
          moduleQueue.splice(i, 1);
          setScopeOnDeclaredComponents(moduleType, ngModule);
        }
      }
    } finally {
      flushingModuleQueue = false;
    }
  }
}
function isResolvedDeclaration(declaration) {
  if (Array.isArray(declaration)) {
    return declaration.every(isResolvedDeclaration);
  }
  return !!resolveForwardRef(declaration);
}
function compileNgModule(moduleType, ngModule = {}) {
  compileNgModuleDefs(moduleType, ngModule);
  if (ngModule.id !== void 0) {
    registerNgModuleType(moduleType, ngModule.id);
  }
  enqueueModuleForDelayedScoping(moduleType, ngModule);
}
function compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {
  ngDevMode && assertDefined(moduleType, "Required value moduleType");
  ngDevMode && assertDefined(ngModule, "Required value ngModule");
  const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
  let ngModuleDef = null;
  Object.defineProperty(moduleType, NG_MOD_DEF, {
    configurable: true,
    get: () => {
      if (ngModuleDef === null) {
        if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {
          throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);
        }
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/\u0275mod.js`, {
          type: moduleType,
          bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),
          declarations: declarations.map(resolveForwardRef),
          imports: flatten(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
          exports: flatten(ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
          schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,
          id: ngModule.id || null
        });
        if (!ngModuleDef.schemas) {
          ngModuleDef.schemas = [];
        }
      }
      return ngModuleDef;
    }
  });
  let ngFactoryDef = null;
  Object.defineProperty(moduleType, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/\u0275fac.js`, {
          name: moduleType.name,
          type: moduleType,
          deps: reflectDependencies(moduleType),
          target: compiler.FactoryTarget.NgModule,
          typeArgumentCount: 0
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
  let ngInjectorDef = null;
  Object.defineProperty(moduleType, NG_INJ_DEF, {
    get: () => {
      if (ngInjectorDef === null) {
        ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);
        const meta2 = {
          name: moduleType.name,
          type: moduleType,
          providers: ngModule.providers || EMPTY_ARRAY,
          imports: [
            (ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef),
            (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef)
          ]
        };
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngInjectorDef = compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/\u0275inj.js`, meta2);
      }
      return ngInjectorDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function generateStandaloneInDeclarationsError(type, location2) {
  const prefix = `Unexpected "${stringifyForError(type)}" found in the "declarations" array of the`;
  const suffix = `"${stringifyForError(type)}" is marked as standalone and can't be declared in any NgModule - did you intend to import it instead (by adding it to the "imports" array)?`;
  return `${prefix} ${location2}, ${suffix}`;
}
function verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {
  if (verifiedNgModule.get(moduleType))
    return;
  if (isStandalone(moduleType))
    return;
  verifiedNgModule.set(moduleType, true);
  moduleType = resolveForwardRef(moduleType);
  let ngModuleDef;
  if (importingModule) {
    ngModuleDef = getNgModuleDef(moduleType);
    if (!ngModuleDef) {
      throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
    }
  } else {
    ngModuleDef = getNgModuleDefOrThrow(moduleType);
  }
  const errors = [];
  const declarations = maybeUnwrapFn(ngModuleDef.declarations);
  const imports = maybeUnwrapFn(ngModuleDef.imports);
  flatten(imports).map(unwrapModuleWithProvidersImports).forEach((modOrStandaloneCmpt) => {
    verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);
    verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);
  });
  const exports = maybeUnwrapFn(ngModuleDef.exports);
  declarations.forEach(verifyDeclarationsHaveDefinitions);
  declarations.forEach(verifyDirectivesHaveSelector);
  declarations.forEach((declarationType) => verifyNotStandalone(declarationType, moduleType));
  const combinedDeclarations = [
    ...declarations.map(resolveForwardRef),
    ...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef)
  ];
  exports.forEach(verifyExportsAreDeclaredOrReExported);
  declarations.forEach((decl) => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));
  const ngModule = getAnnotation(moduleType, "NgModule");
  if (ngModule) {
    ngModule.imports && flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach((mod) => {
      verifySemanticsOfNgModuleImport(mod, moduleType);
      verifySemanticsOfNgModuleDef(mod, false, moduleType);
    });
    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);
    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);
  }
  if (errors.length) {
    throw new Error(errors.join("\n"));
  }
  function verifyDeclarationsHaveDefinitions(type) {
    type = resolveForwardRef(type);
    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);
    if (!def) {
      errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);
    }
  }
  function verifyDirectivesHaveSelector(type) {
    type = resolveForwardRef(type);
    const def = getDirectiveDef(type);
    if (!getComponentDef(type) && def && def.selectors.length == 0) {
      errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);
    }
  }
  function verifyNotStandalone(type, moduleType2) {
    type = resolveForwardRef(type);
    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);
    if (def?.standalone) {
      const location2 = `"${stringifyForError(moduleType2)}" NgModule`;
      errors.push(generateStandaloneInDeclarationsError(type, location2));
    }
  }
  function verifyExportsAreDeclaredOrReExported(type) {
    type = resolveForwardRef(type);
    const kind = getComponentDef(type) && "component" || getDirectiveDef(type) && "directive" || getPipeDef(type) && "pipe";
    if (kind) {
      if (combinedDeclarations.lastIndexOf(type) === -1) {
        errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${stringifyForError(moduleType)} as it was neither declared nor imported!`);
      }
    }
  }
  function verifyDeclarationIsUnique(type, suppressErrors) {
    type = resolveForwardRef(type);
    const existingModule = ownerNgModule.get(type);
    if (existingModule && existingModule !== moduleType) {
      if (!suppressErrors) {
        const modules2 = [existingModule, moduleType].map(stringifyForError).sort();
        errors.push(`Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${modules2[0]} and ${modules2[1]}! Please consider moving ${stringifyForError(type)} to a higher module that imports ${modules2[0]} and ${modules2[1]}. You can also create a new NgModule that exports and includes ${stringifyForError(type)} then import that NgModule in ${modules2[0]} and ${modules2[1]}.`);
      }
    } else {
      ownerNgModule.set(type, moduleType);
    }
  }
  function verifyComponentIsPartOfNgModule(type) {
    type = resolveForwardRef(type);
    const existingModule = ownerNgModule.get(type);
    if (!existingModule && !isStandalone(type)) {
      errors.push(`Component ${stringifyForError(type)} is not part of any NgModule or the module has not been imported into your module.`);
    }
  }
  function verifyCorrectBootstrapType(type) {
    type = resolveForwardRef(type);
    if (!getComponentDef(type)) {
      errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);
    }
    if (isStandalone(type)) {
      errors.push(`The \`${stringifyForError(type)}\` class is a standalone component, which can not be used in the \`@NgModule.bootstrap\` array. Use the \`bootstrapApplication\` function for bootstrap instead.`);
    }
  }
  function verifySemanticsOfNgModuleImport(type, importingModule2) {
    type = resolveForwardRef(type);
    const directiveDef = getComponentDef(type) || getDirectiveDef(type);
    if (directiveDef !== null && !directiveDef.standalone) {
      throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
    }
    const pipeDef = getPipeDef(type);
    if (pipeDef !== null && !pipeDef.standalone) {
      throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
    }
  }
}
function unwrapModuleWithProvidersImports(typeOrWithProviders) {
  typeOrWithProviders = resolveForwardRef(typeOrWithProviders);
  return typeOrWithProviders.ngModule || typeOrWithProviders;
}
function getAnnotation(type, name2) {
  let annotation = null;
  collect(type.__annotations__);
  collect(type.decorators);
  return annotation;
  function collect(annotations) {
    if (annotations) {
      annotations.forEach(readAnnotation);
    }
  }
  function readAnnotation(decorator) {
    if (!annotation) {
      const proto = Object.getPrototypeOf(decorator);
      if (proto.ngMetadataName == name2) {
        annotation = decorator;
      } else if (decorator.type) {
        const proto2 = Object.getPrototypeOf(decorator.type);
        if (proto2.ngMetadataName == name2) {
          annotation = decorator.args[0];
        }
      }
    }
  }
}
function computeCombinedExports(type) {
  type = resolveForwardRef(type);
  const ngModuleDef = getNgModuleDef(type);
  if (ngModuleDef === null) {
    return [type];
  }
  return flatten(maybeUnwrapFn(ngModuleDef.exports).map((type2) => {
    const ngModuleDef2 = getNgModuleDef(type2);
    if (ngModuleDef2) {
      verifySemanticsOfNgModuleDef(type2, false);
      return computeCombinedExports(type2);
    } else {
      return type2;
    }
  }));
}
function setScopeOnDeclaredComponents(moduleType, ngModule) {
  const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
  const transitiveScopes = transitiveScopesFor(moduleType);
  declarations.forEach((declaration) => {
    declaration = resolveForwardRef(declaration);
    if (declaration.hasOwnProperty(NG_COMP_DEF)) {
      const component = declaration;
      const componentDef = getComponentDef(component);
      patchComponentDefWithScope(componentDef, transitiveScopes);
    } else if (!declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {
      declaration.ngSelectorScope = moduleType;
    }
  });
}
function patchComponentDefWithScope(componentDef, transitiveScopes) {
  componentDef.directiveDefs = () => Array.from(transitiveScopes.compilation.directives).map((dir) => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef(dir) : getDirectiveDef(dir)).filter((def) => !!def);
  componentDef.pipeDefs = () => Array.from(transitiveScopes.compilation.pipes).map((pipe2) => getPipeDef(pipe2));
  componentDef.schemas = transitiveScopes.schemas;
  componentDef.tView = null;
}
function transitiveScopesFor(type) {
  if (isNgModule(type)) {
    const scope = depsTracker.getNgModuleScope(type);
    const def = getNgModuleDefOrThrow(type);
    return __spreadValues({
      schemas: def.schemas || null
    }, scope);
  } else if (isStandalone(type)) {
    const directiveDef = getComponentDef(type) || getDirectiveDef(type);
    if (directiveDef !== null) {
      return {
        schemas: null,
        compilation: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set()
        },
        exported: {
          directives: /* @__PURE__ */ new Set([type]),
          pipes: /* @__PURE__ */ new Set()
        }
      };
    }
    const pipeDef = getPipeDef(type);
    if (pipeDef !== null) {
      return {
        schemas: null,
        compilation: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set()
        },
        exported: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set([type])
        }
      };
    }
  }
  throw new Error(`${type.name} does not have a module def (\u0275mod property)`);
}
function expandModuleWithProviders(value) {
  if (isModuleWithProviders(value)) {
    return value.ngModule;
  }
  return value;
}
function compileComponent(type, metadata) {
  (typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode();
  let ngComponentDef = null;
  maybeQueueResolutionOfComponentResources(type, metadata);
  addDirectiveFactoryDef(type, metadata);
  Object.defineProperty(type, NG_COMP_DEF, {
    get: () => {
      if (ngComponentDef === null) {
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "component",
          type
        });
        if (componentNeedsResolution(metadata)) {
          const error = [`Component '${type.name}' is not resolved:`];
          if (metadata.templateUrl) {
            error.push(` - templateUrl: ${metadata.templateUrl}`);
          }
          if (metadata.styleUrls && metadata.styleUrls.length) {
            error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);
          }
          if (metadata.styleUrl) {
            error.push(` - styleUrl: ${metadata.styleUrl}`);
          }
          error.push(`Did you run and wait for 'resolveComponentResources()'?`);
          throw new Error(error.join("\n"));
        }
        const options = getJitOptions();
        let preserveWhitespaces = metadata.preserveWhitespaces;
        if (preserveWhitespaces === void 0) {
          if (options !== null && options.preserveWhitespaces !== void 0) {
            preserveWhitespaces = options.preserveWhitespaces;
          } else {
            preserveWhitespaces = false;
          }
        }
        let encapsulation = metadata.encapsulation;
        if (encapsulation === void 0) {
          if (options !== null && options.defaultEncapsulation !== void 0) {
            encapsulation = options.defaultEncapsulation;
          } else {
            encapsulation = ViewEncapsulation.Emulated;
          }
        }
        const templateUrl = metadata.templateUrl || `ng:///${type.name}/template.html`;
        const baseMeta = directiveMetadata(type, metadata);
        const meta2 = __spreadProps(__spreadValues({}, baseMeta), {
          typeSourceSpan: compiler.createParseSourceSpan("Component", type.name, templateUrl),
          template: metadata.template || "",
          preserveWhitespaces,
          styles: typeof metadata.styles === "string" ? [metadata.styles] : metadata.styles || EMPTY_ARRAY,
          animations: metadata.animations,
          // JIT components are always compiled against an empty set of `declarations`. Instead, the
          // `directiveDefs` and `pipeDefs` are updated at a later point:
          //  * for NgModule-based components, they're set when the NgModule which declares the
          //    component resolves in the module scoping queue
          //  * for standalone components, they're set just below, after `compileComponent`.
          declarations: [],
          changeDetection: metadata.changeDetection,
          encapsulation,
          interpolation: metadata.interpolation,
          viewProviders: metadata.viewProviders || null,
          // We can't inspect whether any of the dependencies are actually directives, because they
          // get patched on after compilation. That's why in JIT mode we consider that any
          // dependency might be a directive dependency.
          hasDirectiveDependencies: !baseMeta.isStandalone || metadata.imports != null && metadata.imports.length > 0
        });
        compilationDepth++;
        try {
          if (meta2.usesInheritance) {
            addDirectiveDefToUndecoratedParents(type);
          }
          ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta2);
          if (meta2.isStandalone) {
            const imports = flatten(metadata.imports || EMPTY_ARRAY);
            const { directiveDefs, pipeDefs } = getStandaloneDefFunctions(type, imports);
            ngComponentDef.directiveDefs = directiveDefs;
            ngComponentDef.pipeDefs = pipeDefs;
            ngComponentDef.dependencies = () => imports.map(resolveForwardRef);
          }
        } finally {
          compilationDepth--;
        }
        if (compilationDepth === 0) {
          flushModuleScopingQueueAsMuchAsPossible();
        }
        if (hasSelectorScope(type)) {
          const scopes = transitiveScopesFor(type.ngSelectorScope);
          patchComponentDefWithScope(ngComponentDef, scopes);
        }
        if (metadata.schemas) {
          if (meta2.isStandalone) {
            ngComponentDef.schemas = metadata.schemas;
          } else {
            throw new Error(`The 'schemas' was specified for the ${stringifyForError(type)} but is only valid on a component that is standalone.`);
          }
        } else if (meta2.isStandalone) {
          ngComponentDef.schemas = [];
        }
      }
      return ngComponentDef;
    },
    set: (def) => {
      ngComponentDef = def;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getStandaloneDefFunctions(type, imports) {
  const directiveDefs = () => {
    if (ngDevMode) {
      for (const rawDep of imports) {
        verifyStandaloneImport(rawDep, type);
      }
    }
    if (!isComponent(type)) {
      return [];
    }
    const scope = depsTracker.getStandaloneComponentScope(type, imports);
    return [...scope.compilation.directives].map((p) => getComponentDef(p) || getDirectiveDef(p)).filter((d) => d !== null);
  };
  const pipeDefs = () => {
    if (ngDevMode) {
      for (const rawDep of imports) {
        verifyStandaloneImport(rawDep, type);
      }
    }
    if (!isComponent(type)) {
      return [];
    }
    const scope = depsTracker.getStandaloneComponentScope(type, imports);
    return [...scope.compilation.pipes].map((p) => getPipeDef(p)).filter((d) => d !== null);
  };
  return {
    directiveDefs,
    pipeDefs
  };
}
function hasSelectorScope(component) {
  return component.ngSelectorScope !== void 0;
}
function compileDirective(type, directive) {
  let ngDirectiveDef = null;
  addDirectiveFactoryDef(type, directive || {});
  Object.defineProperty(type, NG_DIR_DEF, {
    get: () => {
      if (ngDirectiveDef === null) {
        const meta2 = getDirectiveMetadata(type, directive || {});
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "directive",
          type
        });
        ngDirectiveDef = compiler.compileDirective(angularCoreEnv, meta2.sourceMapUrl, meta2.metadata);
      }
      return ngDirectiveDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getDirectiveMetadata(type, metadata) {
  const name2 = type && type.name;
  const sourceMapUrl = `ng:///${name2}/\u0275dir.js`;
  const compiler = getCompilerFacade({ usage: 0, kind: "directive", type });
  const facade = directiveMetadata(type, metadata);
  facade.typeSourceSpan = compiler.createParseSourceSpan("Directive", name2, sourceMapUrl);
  if (facade.usesInheritance) {
    addDirectiveDefToUndecoratedParents(type);
  }
  return { metadata: facade, sourceMapUrl };
}
function addDirectiveFactoryDef(type, metadata) {
  let ngFactoryDef = null;
  Object.defineProperty(type, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const meta2 = getDirectiveMetadata(type, metadata);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "directive",
          type
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${type.name}/\u0275fac.js`, {
          name: meta2.metadata.name,
          type: meta2.metadata.type,
          typeArgumentCount: 0,
          deps: reflectDependencies(type),
          target: compiler.FactoryTarget.Directive
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function extendsDirectlyFromObject(type) {
  return Object.getPrototypeOf(type.prototype) === Object.prototype;
}
function directiveMetadata(type, metadata) {
  const reflect = getReflect();
  const propMetadata = reflect.ownPropMetadata(type);
  return {
    name: type.name,
    type,
    selector: metadata.selector !== void 0 ? metadata.selector : null,
    host: metadata.host || EMPTY_OBJ,
    propMetadata,
    inputs: metadata.inputs || EMPTY_ARRAY,
    outputs: metadata.outputs || EMPTY_ARRAY,
    queries: extractQueriesMetadata(type, propMetadata, isContentQuery),
    lifecycle: { usesOnChanges: reflect.hasLifecycleHook(type, "ngOnChanges") },
    typeSourceSpan: null,
    usesInheritance: !extendsDirectlyFromObject(type),
    exportAs: extractExportAs(metadata.exportAs),
    providers: metadata.providers || null,
    viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery),
    isStandalone: metadata.standalone === void 0 ? true : !!metadata.standalone,
    isSignal: !!metadata.signals,
    hostDirectives: metadata.hostDirectives?.map((directive) => typeof directive === "function" ? { directive } : directive) || null
  };
}
function addDirectiveDefToUndecoratedParents(type) {
  const objPrototype = Object.prototype;
  let parent = Object.getPrototypeOf(type.prototype).constructor;
  while (parent && parent !== objPrototype) {
    if (!getDirectiveDef(parent) && !getComponentDef(parent) && shouldAddAbstractDirective(parent)) {
      compileDirective(parent, null);
    }
    parent = Object.getPrototypeOf(parent);
  }
}
function convertToR3QueryPredicate(selector) {
  return typeof selector === "string" ? splitByComma(selector) : resolveForwardRef(selector);
}
function convertToR3QueryMetadata(propertyName2, ann) {
  return {
    propertyName: propertyName2,
    predicate: convertToR3QueryPredicate(ann.selector),
    descendants: ann.descendants,
    first: ann.first,
    read: ann.read ? ann.read : null,
    static: !!ann.static,
    emitDistinctChangesOnly: !!ann.emitDistinctChangesOnly,
    isSignal: !!ann.isSignal
  };
}
function extractQueriesMetadata(type, propMetadata, isQueryAnn) {
  const queriesMeta = [];
  for (const field in propMetadata) {
    if (propMetadata.hasOwnProperty(field)) {
      const annotations = propMetadata[field];
      annotations.forEach((ann) => {
        if (isQueryAnn(ann)) {
          if (!ann.selector) {
            throw new Error(`Can't construct a query for the property "${field}" of "${stringifyForError(type)}" since the query selector wasn't defined.`);
          }
          if (annotations.some(isInputAnnotation)) {
            throw new Error(`Cannot combine @Input decorators with query decorators`);
          }
          queriesMeta.push(convertToR3QueryMetadata(field, ann));
        }
      });
    }
  }
  return queriesMeta;
}
function extractExportAs(exportAs) {
  return exportAs === void 0 ? null : splitByComma(exportAs);
}
function isContentQuery(value) {
  const name2 = value.ngMetadataName;
  return name2 === "ContentChild" || name2 === "ContentChildren";
}
function isViewQuery(value) {
  const name2 = value.ngMetadataName;
  return name2 === "ViewChild" || name2 === "ViewChildren";
}
function isInputAnnotation(value) {
  return value.ngMetadataName === "Input";
}
function splitByComma(value) {
  return value.split(",").map((piece) => piece.trim());
}
function shouldAddAbstractDirective(type) {
  const reflect = getReflect();
  if (LIFECYCLE_HOOKS.some((hookName) => reflect.hasLifecycleHook(type, hookName))) {
    return true;
  }
  const propMetadata = reflect.propMetadata(type);
  for (const field in propMetadata) {
    const annotations = propMetadata[field];
    for (let i = 0; i < annotations.length; i++) {
      const current = annotations[i];
      const metadataName = current.ngMetadataName;
      if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) || metadataName === "Output" || metadataName === "HostBinding" || metadataName === "HostListener") {
        return true;
      }
    }
  }
  return false;
}
function compilePipe(type, meta2) {
  let ngPipeDef = null;
  let ngFactoryDef = null;
  Object.defineProperty(type, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const metadata = getPipeMetadata(type, meta2);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "pipe",
          type: metadata.type
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${metadata.name}/\u0275fac.js`, {
          name: metadata.name,
          type: metadata.type,
          typeArgumentCount: 0,
          deps: reflectDependencies(type),
          target: compiler.FactoryTarget.Pipe
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
  Object.defineProperty(type, NG_PIPE_DEF, {
    get: () => {
      if (ngPipeDef === null) {
        const metadata = getPipeMetadata(type, meta2);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "pipe",
          type: metadata.type
        });
        ngPipeDef = compiler.compilePipe(angularCoreEnv, `ng:///${metadata.name}/\u0275pipe.js`, metadata);
      }
      return ngPipeDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getPipeMetadata(type, meta2) {
  return {
    type,
    name: type.name,
    pipeName: meta2.name,
    pure: meta2.pure !== void 0 ? meta2.pure : true,
    isStandalone: meta2.standalone === void 0 ? true : !!meta2.standalone
  };
}
function internalProvideZoneChangeDetection({ ngZoneFactory, ignoreChangesOutsideZone, scheduleInRootZone }) {
  ngZoneFactory ??= () => new NgZone(__spreadProps(__spreadValues({}, getNgZoneOptions()), { scheduleInRootZone }));
  return [
    { provide: NgZone, useFactory: ngZoneFactory },
    {
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const ngZoneChangeDetectionScheduler = inject2(NgZoneChangeDetectionScheduler, {
          optional: true
        });
        if ((typeof ngDevMode === "undefined" || ngDevMode) && ngZoneChangeDetectionScheduler === null) {
          throw new RuntimeError(402, `A required Injectable was not found in the dependency injection tree. If you are bootstrapping an NgModule, make sure that the \`BrowserModule\` is imported.`);
        }
        return () => ngZoneChangeDetectionScheduler.initialize();
      }
    },
    {
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const service = inject2(ZoneStablePendingTask);
        return () => {
          service.initialize();
        };
      }
    },
    // Always disable scheduler whenever explicitly disabled, even if another place called
    // `provideZoneChangeDetection` without the 'ignore' option.
    ignoreChangesOutsideZone === true ? { provide: ZONELESS_SCHEDULER_DISABLED, useValue: true } : [],
    {
      provide: SCHEDULE_IN_ROOT_ZONE,
      useValue: scheduleInRootZone ?? SCHEDULE_IN_ROOT_ZONE_DEFAULT
    },
    {
      provide: INTERNAL_APPLICATION_ERROR_HANDLER,
      useFactory: () => {
        const zone = inject2(NgZone);
        const injector = inject2(EnvironmentInjector);
        let userErrorHandler;
        return (e) => {
          zone.runOutsideAngular(() => {
            if (injector.destroyed && !userErrorHandler) {
              setTimeout(() => {
                throw e;
              });
            } else {
              userErrorHandler ??= injector.get(ErrorHandler);
              userErrorHandler.handleError(e);
            }
          });
        };
      }
    }
  ];
}
function provideZoneChangeDetection(options) {
  const ignoreChangesOutsideZone = options?.ignoreChangesOutsideZone;
  const scheduleInRootZone = options?.scheduleInRootZone;
  const zoneProviders = internalProvideZoneChangeDetection({
    ngZoneFactory: () => {
      const ngZoneOptions = getNgZoneOptions(options);
      ngZoneOptions.scheduleInRootZone = scheduleInRootZone;
      if (ngZoneOptions.shouldCoalesceEventChangeDetection) {
        performanceMarkFeature("NgZone_CoalesceEvent");
      }
      return new NgZone(ngZoneOptions);
    },
    ignoreChangesOutsideZone,
    scheduleInRootZone
  });
  return makeEnvironmentProviders([
    { provide: PROVIDED_NG_ZONE, useValue: true },
    { provide: ZONELESS_ENABLED, useValue: false },
    zoneProviders
  ]);
}
function getNgZoneOptions(options) {
  return {
    enableLongStackTrace: typeof ngDevMode === "undefined" ? false : !!ngDevMode,
    shouldCoalesceEventChangeDetection: options?.eventCoalescing ?? false,
    shouldCoalesceRunChangeDetection: options?.runCoalescing ?? false
  };
}
function trackMicrotaskNotificationForDebugging() {
  consecutiveMicrotaskNotifications++;
  if (CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT - consecutiveMicrotaskNotifications < 5) {
    const stack = new Error().stack;
    if (stack) {
      stackFromLastFewNotifications.push(stack);
    }
  }
  if (consecutiveMicrotaskNotifications === CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT) {
    throw new RuntimeError(103, "Angular could not stabilize because there were endless change notifications within the browser event loop. The stack from the last several notifications: \n" + stackFromLastFewNotifications.join("\n"));
  }
}
function getGlobalLocale() {
  if (false) {
    return goog.LOCALE;
  } else {
    return typeof $localize !== "undefined" && $localize.locale || DEFAULT_LOCALE_ID;
  }
}
var ANNOTATIONS, PARAMETERS, PROP_METADATA, Inject, Optional, Self, SkipSelf, Host, angularCoreDiEnv, Type, ES5_DELEGATE_CTOR, ES2015_INHERITED_CLASS, ES2015_INHERITED_CLASS_WITH_CTOR, ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR, ReflectionCapabilities, SimpleChange, \u0275\u0275NgOnChangesFeature, SIMPLE_CHANGES_STORE, profilerCallbacks, NOOP_PROFILER_REMOVAL2, profiler, NO_PARENT_INJECTOR, NodeInjectorFactory, includeViewProviders, BLOOM_SIZE, BLOOM_MASK, BLOOM_BUCKET_BITS, nextNgElementId, NOT_FOUND2, injectionPath, NodeInjector, Attribute, _reflect, USE_VALUE2, Injectable, ElementRef, QueryList, ChangeDetectionStrategy, TRACKED_LVIEWS, uniqueIdCounter, LContext, MONKEY_PATCH_KEY_NAME, Framework, AcxChangeDetectionStrategy, AcxViewEncapsulation, DOCUMENT2, APP_ID, DEFAULT_APP_ID, PLATFORM_INITIALIZER, PLATFORM_ID, PACKAGE_ROOT_URL, ANIMATION_MODULE_TYPE, CSP_NONCE, IMAGE_CONFIG_DEFAULTS, IMAGE_CONFIG, TransferState, REFERENCE_NODE_HOST, REFERENCE_NODE_BODY, NUM_ROOT_NODES, DEFER_BLOCK_ID, DEFER_BLOCK_STATE$1, DEFER_PARENT_BLOCK_ID, IS_HYDRATION_DOM_REUSE_ENABLED, PRESERVE_HOST_CONTENT_DEFAULT, PRESERVE_HOST_CONTENT, IS_I18N_HYDRATION_ENABLED, IS_EVENT_REPLAY_ENABLED, IS_INCREMENTAL_HYDRATION_ENABLED, JSACTION_BLOCK_ELEMENT_MAP, eventListenerOptions, hoverTriggers, interactionTriggers, viewportTriggers, interactionEventNames, hoverEventNames, intersectionObserver, observedViewportElements, DeferEventEntry, JSACTION_EVENT_CONTRACT, _stashEventListenerImpl, DEHYDRATED_BLOCK_REGISTRY, TRANSFER_STATE_TOKEN_ID, NGH_DATA_KEY, TRANSFER_STATE_DEFER_BLOCKS_INFO, NGH_DEFER_BLOCKS_KEY, _retrieveHydrationInfoImpl, HydrationStatus, HYDRATION_INFO_KEY, ViewEncapsulation, policy$1, policy, SafeValueImpl, SafeHtmlImpl, SafeStyleImpl, SafeScriptImpl, SafeUrlImpl, SafeResourceUrlImpl, DOMParserHelper, InertDocumentHelper, SAFE_URL_PATTERN, VOID_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS, OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, VALID_ELEMENTS, URI_ATTRS, HTML_ATTRS, ARIA_ATTRS, VALID_ATTRS, SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS, SanitizingHtmlSerializer, SURROGATE_PAIR_REGEXP, NON_ALPHANUMERIC_REGEXP, inertBodyHelper, SecurityContext, COMMENT_DISALLOWED, COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED, NG_REFLECT_ATTRS_FLAG_DEFAULT, NG_REFLECT_ATTRS_FLAG, CAMEL_CASE_REGEXP, CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, shouldThrowErrorOnUnknownElement, shouldThrowErrorOnUnknownProperty, KNOWN_CONTROL_FLOW_DIRECTIVES, INTERPOLATION_DELIMITER, VALUE_STRING_LENGTH_LIMIT, NG_TEMPLATE_SELECTOR, NO_CHANGE, InputFlags, RendererStyleFlags2, _icuContainerIterate, _getInsertInFrontOfRNodeWithI18n, _processI18nInsertBefore, _applyRootElementTransformImpl, USE_EXHAUSTIVE_CHECK_NO_CHANGES_DEFAULT, UseExhaustiveCheckNoChanges, freeConsumers, REACTIVE_LVIEW_CONSUMER_NODE, TEMPORARY_CONSUMER_NODE, MAXIMUM_REFRESH_RERUNS$1, ViewRef, TemplateRef, AT_THIS_LOCATION, internalAttrs, REF_EXTRACTOR_REGEXP, _prepareI18nBlockForHydrationImpl, _claimDehydratedIcuCaseImpl, _findMatchingDehydratedViewImpl, _findAndReconcileMatchingDehydratedViewsImpl, ComponentRef$1, ComponentFactory$1, _NullComponentFactoryResolver, ComponentFactoryResolver$1, RendererFactory2, Renderer2, Sanitizer, DepsTracker, depsTracker, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, ChainedInjector, BINDING, ComponentFactoryResolver2, ComponentFactory2, ComponentRef2, ViewContainerRef, VE_ViewContainerRef, R3ViewContainerRef, _locateOrCreateAnchorNode, _populateDehydratedViewsInLContainer, LQuery_, LQueries_, TQueryMetadata_, TQueries_, TQuery_, componentResourceResolutionQueue, componentDefPendingResolution, modules, checkForDuplicateNgModules, markedFeatures, NgModuleRef$1, NgModuleFactory$1, NgModuleRef2, NgModuleFactory2, EnvironmentNgModuleRefAdapter, StandaloneService, GENERATED_COMP_IDS, COPY_DIRECTIVE_FIELDS, COPY_COMPONENT_FIELDS, _locateOrCreateContainerAnchor, DeferDependenciesLoadingState, MINIMUM_SLOT, LOADING_AFTER_SLOT, DeferBlockState, DeferBlockInternalState, NEXT_DEFER_BLOCK_STATE, DEFER_BLOCK_STATE, STATE_IS_FROZEN_UNTIL, LOADING_AFTER_CLEANUP_FN, TRIGGER_CLEANUP_FNS, PREFETCH_TRIGGER_CLEANUP_FNS, SSR_UNIQUE_ID, SSR_BLOCK_STATE, ON_COMPLETE_FNS, HYDRATE_TRIGGER_CLEANUP_FNS, DeferBlockBehavior, TracingAction, TracingService, SCHEDULE_IN_ROOT_ZONE_DEFAULT, EventEmitter_, EventEmitter, AsyncStackTaggingZoneSpec, isAngularZoneProperty, angularZoneInstanceIdProperty, ngZoneInstanceId, NgZone, EMPTY_PAYLOAD, NoopNgZone, AfterRenderManager, AFTER_RENDER_PHASES, AfterRenderImpl, AfterRenderSequence, _requestIdleCallback, _cancelIdleCallback, IdleScheduler, TimerScheduler, CachedInjectorService, DEFER_BLOCK_DEPENDENCY_INTERCEPTOR, DEFER_BLOCK_CONFIG, applyDeferBlockStateWithSchedulingImpl, Console, DIDebugData, frameworkDIDebugData, signalDebugMap, counter$1, changeDetectionRuns, changeDetectionSyncRuns, counter, eventsStack, chromeDevToolsInjectorProfiler, devToolsProfiler, GLOBAL_PUBLISH_EXPANDO_KEY, globalUtilsFunctions, _published, TESTABILITY, TESTABILITY_GETTER, Testability, TestabilityRegistry, _testabilityGetter, APP_INITIALIZER, ApplicationInitStatus, APP_BOOTSTRAP_LISTENER, MAXIMUM_REFRESH_RERUNS, ApplicationRef, LiveCollection, UniqueValueMultiKeyMap, RepeaterContext, RepeaterMetadata, OperationsCounter, LiveCollectionLContainerImpl, _locateOrCreateElementNode, _locateOrCreateElementContainerNode, u, localeEn, LOCALE_DATA, LocaleDataIndex, pluralMapping, DEFAULT_LOCALE_ID, USD_CURRENCY_CODE, ELEMENT_MARKER, ICU_MARKER, I18nCreateOpCode, LOCALE_ID$1, changeMask, changeMaskCounter, _locateOrCreateNode, OpCodeParser, BINDING_REGEXP, ICU_REGEXP, NESTED_ICU, ICU_BLOCK_REGEXP, MARKER, SUBTEMPLATE_REGEXP, PH_REGEXP, NGSP_UNICODE_REGEXP, ROOT_TEMPLATE_ID, PP_MULTI_VALUE_PLACEHOLDERS_REGEXP, PP_PLACEHOLDERS_REGEXP, PP_ICU_VARS_REGEXP, PP_ICU_PLACEHOLDERS_REGEXP, PP_ICUS_REGEXP, PP_CLOSE_TEMPLATE_REGEXP, PP_TEMPLATE_ID_REGEXP, parserState, _locateOrCreateTextNode, UNINITIALIZED_LET, angularCoreEnv, jitOptions, moduleQueue, flushingModuleQueue, ownerNgModule, verifiedNgModule, compilationDepth, LIFECYCLE_HOOKS, Directive, Component, Pipe, Input, Output, HostBinding, HostListener, NgModule, ModuleWithComponentFactories, Compiler, COMPILER_OPTIONS, NgZoneChangeDetectionScheduler, PROVIDED_NG_ZONE, ZoneStablePendingTask, CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT, consecutiveMicrotaskNotifications, stackFromLastFewNotifications, ChangeDetectionSchedulerImpl, LOCALE_ID, DEFAULT_CURRENCY_CODE, TRANSLATIONS, TRANSLATIONS_FORMAT, MissingTranslationStrategy;
var init_debug_node = __esm({
  "node_modules/@angular/core/fesm2022/debug_node.mjs"() {
    "use strict";
    init_root_effect_scheduler();
    init_signal();
    init_esm();
    init_signals();
    init_operators();
    ANNOTATIONS = "__annotations__";
    PARAMETERS = "__parameters__";
    PROP_METADATA = "__prop__metadata__";
    Inject = attachInjectFlag(
      // Disable tslint because `DecoratorFlags` is a const enum which gets inlined.
      makeParamDecorator("Inject", (token) => ({ token })),
      -1
      /* DecoratorFlags.Inject */
    );
    Optional = // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
    // tslint:disable-next-line: no-toplevel-property-access
    attachInjectFlag(
      makeParamDecorator("Optional"),
      8
      /* InternalInjectFlags.Optional */
    );
    Self = // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
    // tslint:disable-next-line: no-toplevel-property-access
    attachInjectFlag(
      makeParamDecorator("Self"),
      2
      /* InternalInjectFlags.Self */
    );
    SkipSelf = // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
    // tslint:disable-next-line: no-toplevel-property-access
    attachInjectFlag(
      makeParamDecorator("SkipSelf"),
      4
      /* InternalInjectFlags.SkipSelf */
    );
    Host = // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
    // tslint:disable-next-line: no-toplevel-property-access
    attachInjectFlag(
      makeParamDecorator("Host"),
      1
      /* InternalInjectFlags.Host */
    );
    angularCoreDiEnv = {
      "\u0275\u0275defineInjectable": \u0275\u0275defineInjectable,
      "\u0275\u0275defineInjector": \u0275\u0275defineInjector,
      "\u0275\u0275inject": \u0275\u0275inject,
      "\u0275\u0275invalidFactoryDep": \u0275\u0275invalidFactoryDep,
      "resolveForwardRef": resolveForwardRef
    };
    Type = Function;
    ES5_DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/;
    ES2015_INHERITED_CLASS = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/;
    ES2015_INHERITED_CLASS_WITH_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/;
    ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{[^}]*super\(\.\.\.arguments\)/;
    ReflectionCapabilities = class {
      _reflect;
      constructor(reflect) {
        this._reflect = reflect || _global["Reflect"];
      }
      factory(t2) {
        return (...args) => new t2(...args);
      }
      /** @internal */
      _zipTypesAndAnnotations(paramTypes, paramAnnotations) {
        let result;
        if (typeof paramTypes === "undefined") {
          result = newArray(paramAnnotations.length);
        } else {
          result = newArray(paramTypes.length);
        }
        for (let i = 0; i < result.length; i++) {
          if (typeof paramTypes === "undefined") {
            result[i] = [];
          } else if (paramTypes[i] && paramTypes[i] != Object) {
            result[i] = [paramTypes[i]];
          } else {
            result[i] = [];
          }
          if (paramAnnotations && paramAnnotations[i] != null) {
            result[i] = result[i].concat(paramAnnotations[i]);
          }
        }
        return result;
      }
      _ownParameters(type, parentCtor) {
        const typeStr = type.toString();
        if (isDelegateCtor(typeStr)) {
          return null;
        }
        if (type.parameters && type.parameters !== parentCtor.parameters) {
          return type.parameters;
        }
        const tsickleCtorParams = type.ctorParameters;
        if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
          const ctorParameters = typeof tsickleCtorParams === "function" ? tsickleCtorParams() : tsickleCtorParams;
          const paramTypes2 = ctorParameters.map((ctorParam) => ctorParam && ctorParam.type);
          const paramAnnotations2 = ctorParameters.map((ctorParam) => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));
          return this._zipTypesAndAnnotations(paramTypes2, paramAnnotations2);
        }
        const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];
        const paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata("design:paramtypes", type);
        if (paramTypes || paramAnnotations) {
          return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
        }
        return newArray(type.length);
      }
      parameters(type) {
        if (!isType(type)) {
          return [];
        }
        const parentCtor = getParentCtor(type);
        let parameters = this._ownParameters(type, parentCtor);
        if (!parameters && parentCtor !== Object) {
          parameters = this.parameters(parentCtor);
        }
        return parameters || [];
      }
      _ownAnnotations(typeOrFunc, parentCtor) {
        if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {
          let annotations = typeOrFunc.annotations;
          if (typeof annotations === "function" && annotations.annotations) {
            annotations = annotations.annotations;
          }
          return annotations;
        }
        if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {
          return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
        }
        if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {
          return typeOrFunc[ANNOTATIONS];
        }
        return null;
      }
      annotations(typeOrFunc) {
        if (!isType(typeOrFunc)) {
          return [];
        }
        const parentCtor = getParentCtor(typeOrFunc);
        const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
        const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
        return parentAnnotations.concat(ownAnnotations);
      }
      _ownPropMetadata(typeOrFunc, parentCtor) {
        if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {
          let propMetadata = typeOrFunc.propMetadata;
          if (typeof propMetadata === "function" && propMetadata.propMetadata) {
            propMetadata = propMetadata.propMetadata;
          }
          return propMetadata;
        }
        if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {
          const propDecorators = typeOrFunc.propDecorators;
          const propMetadata = {};
          Object.keys(propDecorators).forEach((prop) => {
            propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);
          });
          return propMetadata;
        }
        if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {
          return typeOrFunc[PROP_METADATA];
        }
        return null;
      }
      propMetadata(typeOrFunc) {
        if (!isType(typeOrFunc)) {
          return {};
        }
        const parentCtor = getParentCtor(typeOrFunc);
        const propMetadata = {};
        if (parentCtor !== Object) {
          const parentPropMetadata = this.propMetadata(parentCtor);
          Object.keys(parentPropMetadata).forEach((propName) => {
            propMetadata[propName] = parentPropMetadata[propName];
          });
        }
        const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
        if (ownPropMetadata) {
          Object.keys(ownPropMetadata).forEach((propName) => {
            const decorators = [];
            if (propMetadata.hasOwnProperty(propName)) {
              decorators.push(...propMetadata[propName]);
            }
            decorators.push(...ownPropMetadata[propName]);
            propMetadata[propName] = decorators;
          });
        }
        return propMetadata;
      }
      ownPropMetadata(typeOrFunc) {
        if (!isType(typeOrFunc)) {
          return {};
        }
        return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};
      }
      hasLifecycleHook(type, lcProperty) {
        return type instanceof Type && lcProperty in type.prototype;
      }
    };
    SimpleChange = class {
      previousValue;
      currentValue;
      firstChange;
      constructor(previousValue, currentValue, firstChange) {
        this.previousValue = previousValue;
        this.currentValue = currentValue;
        this.firstChange = firstChange;
      }
      /**
       * Check whether the new value is the first value assigned.
       */
      isFirstChange() {
        return this.firstChange;
      }
    };
    \u0275\u0275NgOnChangesFeature = /* @__PURE__ */ (() => {
      const \u0275\u0275NgOnChangesFeatureImpl = () => NgOnChangesFeatureImpl;
      \u0275\u0275NgOnChangesFeatureImpl.ngInherit = true;
      return \u0275\u0275NgOnChangesFeatureImpl;
    })();
    SIMPLE_CHANGES_STORE = "__ngSimpleChanges__";
    profilerCallbacks = [];
    NOOP_PROFILER_REMOVAL2 = () => {
    };
    profiler = function(event, instance = null, eventFn) {
      for (let i = 0; i < profilerCallbacks.length; i++) {
        const profilerCallback = profilerCallbacks[i];
        profilerCallback(event, instance, eventFn);
      }
    };
    NO_PARENT_INJECTOR = -1;
    NodeInjectorFactory = class {
      factory;
      name;
      /**
       * The inject implementation to be activated when using the factory.
       */
      injectImpl;
      /**
       * Marker set to true during factory invocation to see if we get into recursive loop.
       * Recursive loop causes an error to be displayed.
       */
      resolving = false;
      /**
       * Marks that the token can see other Tokens declared in `viewProviders` on the same node.
       */
      canSeeViewProviders;
      /**
       * An array of factories to use in case of `multi` provider.
       */
      multi;
      /**
       * Number of `multi`-providers which belong to the component.
       *
       * This is needed because when multiple components and directives declare the `multi` provider
       * they have to be concatenated in the correct order.
       *
       * Example:
       *
       * If we have a component and directive active an a single element as declared here
       * ```ts
       * component:
       *   providers: [ {provide: String, useValue: 'component', multi: true} ],
       *   viewProviders: [ {provide: String, useValue: 'componentView', multi: true} ],
       *
       * directive:
       *   providers: [ {provide: String, useValue: 'directive', multi: true} ],
       * ```
       *
       * Then the expected results are:
       *
       * ```ts
       * providers: ['component', 'directive']
       * viewProviders: ['component', 'componentView', 'directive']
       * ```
       *
       * The way to think about it is that the `viewProviders` have been inserted after the component
       * but before the directives, which is why we need to know how many `multi`s have been declared by
       * the component.
       */
      componentProviders;
      /**
       * Current index of the Factory in the `data`. Needed for `viewProviders` and `providers` merging.
       * See `providerFactory`.
       */
      index;
      /**
       * Because the same `multi` provider can be declared in `providers` and `viewProviders` it is
       * possible for `viewProviders` to shadow the `providers`. For this reason we store the
       * `provideFactory` of the `providers` so that `providers` can be extended with `viewProviders`.
       *
       * Example:
       *
       * Given:
       * ```ts
       * providers: [ {provide: String, useValue: 'all', multi: true} ],
       * viewProviders: [ {provide: String, useValue: 'viewOnly', multi: true} ],
       * ```
       *
       * We have to return `['all']` in case of content injection, but `['all', 'viewOnly']` in case
       * of view injection. We further have to make sure that the shared instances (in our case
       * `all`) are the exact same instance in both the content as well as the view injection. (We
       * have to make sure that we don't double instantiate.) For this reason the `viewProviders`
       * `Factory` has a pointer to the shadowed `providers` factory so that it can instantiate the
       * `providers` (`['all']`) and then extend it with `viewProviders` (`['all'] + ['viewOnly'] =
       * ['all', 'viewOnly']`).
       */
      providerFactory;
      constructor(factory, isViewProvider, injectImplementation, name2) {
        this.factory = factory;
        this.name = name2;
        ngDevMode && assertDefined(factory, "Factory not specified");
        ngDevMode && assertEqual(typeof factory, "function", "Expected factory function.");
        this.canSeeViewProviders = isViewProvider;
        this.injectImpl = injectImplementation;
      }
    };
    includeViewProviders = true;
    BLOOM_SIZE = 256;
    BLOOM_MASK = BLOOM_SIZE - 1;
    BLOOM_BUCKET_BITS = 5;
    nextNgElementId = 0;
    NOT_FOUND2 = {};
    injectionPath = [];
    NodeInjector = class {
      _tNode;
      _lView;
      constructor(_tNode, _lView) {
        this._tNode = _tNode;
        this._lView = _lView;
      }
      get(token, notFoundValue, flags) {
        return getOrCreateInjectable(this._tNode, this._lView, token, convertToBitFlags(flags), notFoundValue);
      }
    };
    Attribute = makeParamDecorator("Attribute", (attributeName) => ({
      attributeName,
      __NG_ELEMENT_ID__: () => \u0275\u0275injectAttribute(attributeName)
    }));
    _reflect = null;
    USE_VALUE2 = getClosureSafeProperty({
      provide: String,
      useValue: getClosureSafeProperty
    });
    Injectable = makeDecorator("Injectable", void 0, void 0, void 0, (type, meta2) => compileInjectable(type, meta2));
    ElementRef = class {
      /**
       * <div class="docs-alert docs-alert-important">
       *   <header>Use with caution</header>
       *   <p>
       *    Use this API as the last resort when direct access to DOM is needed. Use templating and
       *    data-binding provided by Angular instead. If used, it is recommended in combination with
       *    {@link /best-practices/security#direct-use-of-the-dom-apis-and-explicit-sanitization-calls DomSanitizer}
       *    for maxiumum security;
       *   </p>
       * </div>
       */
      nativeElement;
      constructor(nativeElement) {
        this.nativeElement = nativeElement;
      }
      /**
       * @internal
       * @nocollapse
       */
      static __NG_ELEMENT_ID__ = injectElementRef;
    };
    QueryList = class {
      _emitDistinctChangesOnly;
      dirty = true;
      _onDirty = void 0;
      _results = [];
      _changesDetected = false;
      _changes = void 0;
      length = 0;
      first = void 0;
      last = void 0;
      /**
       * Returns `Observable` of `QueryList` notifying the subscriber of changes.
       */
      get changes() {
        return this._changes ??= new Subject();
      }
      /**
       * @param emitDistinctChangesOnly Whether `QueryList.changes` should fire only when actual change
       *     has occurred. Or if it should fire when query is recomputed. (recomputing could resolve in
       *     the same result)
       */
      constructor(_emitDistinctChangesOnly = false) {
        this._emitDistinctChangesOnly = _emitDistinctChangesOnly;
      }
      /**
       * Returns the QueryList entry at `index`.
       */
      get(index) {
        return this._results[index];
      }
      /**
       * See
       * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
       */
      map(fn) {
        return this._results.map(fn);
      }
      filter(fn) {
        return this._results.filter(fn);
      }
      /**
       * See
       * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
       */
      find(fn) {
        return this._results.find(fn);
      }
      /**
       * See
       * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
       */
      reduce(fn, init) {
        return this._results.reduce(fn, init);
      }
      /**
       * See
       * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
       */
      forEach(fn) {
        this._results.forEach(fn);
      }
      /**
       * See
       * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
       */
      some(fn) {
        return this._results.some(fn);
      }
      /**
       * Returns a copy of the internal results list as an Array.
       */
      toArray() {
        return this._results.slice();
      }
      toString() {
        return this._results.toString();
      }
      /**
       * Updates the stored data of the query list, and resets the `dirty` flag to `false`, so that
       * on change detection, it will not notify of changes to the queries, unless a new change
       * occurs.
       *
       * @param resultsTree The query results to store
       * @param identityAccessor Optional function for extracting stable object identity from a value
       *    in the array. This function is executed for each element of the query result list while
       *    comparing current query list with the new one (provided as a first argument of the `reset`
       *    function) to detect if the lists are different. If the function is not provided, elements
       *    are compared as is (without any pre-processing).
       */
      reset(resultsTree, identityAccessor) {
        this.dirty = false;
        const newResultFlat = flatten(resultsTree);
        if (this._changesDetected = !arrayEquals(this._results, newResultFlat, identityAccessor)) {
          this._results = newResultFlat;
          this.length = newResultFlat.length;
          this.last = newResultFlat[this.length - 1];
          this.first = newResultFlat[0];
        }
      }
      /**
       * Triggers a change event by emitting on the `changes` {@link EventEmitter}.
       */
      notifyOnChanges() {
        if (this._changes !== void 0 && (this._changesDetected || !this._emitDistinctChangesOnly))
          this._changes.next(this);
      }
      /** @internal */
      onDirty(cb) {
        this._onDirty = cb;
      }
      /** internal */
      setDirty() {
        this.dirty = true;
        this._onDirty?.();
      }
      /** internal */
      destroy() {
        if (this._changes !== void 0) {
          this._changes.complete();
          this._changes.unsubscribe();
        }
      }
      [Symbol.iterator] = /* @__PURE__ */ (() => symbolIterator)();
    };
    (function(ChangeDetectionStrategy2) {
      ChangeDetectionStrategy2[ChangeDetectionStrategy2["OnPush"] = 0] = "OnPush";
      ChangeDetectionStrategy2[ChangeDetectionStrategy2["Default"] = 1] = "Default";
    })(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));
    TRACKED_LVIEWS = /* @__PURE__ */ new Map();
    uniqueIdCounter = 0;
    LContext = class {
      lViewId;
      nodeIndex;
      native;
      /**
       * The instance of the Component node.
       */
      component;
      /**
       * The list of active directives that exist on this element.
       */
      directives;
      /**
       * The map of local references (local reference name => element or directive instance) that
       * exist on this element.
       */
      localRefs;
      /** Component's parent view data. */
      get lView() {
        return getLViewById(this.lViewId);
      }
      constructor(lViewId, nodeIndex, native) {
        this.lViewId = lViewId;
        this.nodeIndex = nodeIndex;
        this.native = native;
      }
    };
    MONKEY_PATCH_KEY_NAME = "__ngContext__";
    (function(Framework2) {
      Framework2["Angular"] = "angular";
      Framework2["ACX"] = "acx";
      Framework2["Wiz"] = "wiz";
    })(Framework || (Framework = {}));
    (function(AcxChangeDetectionStrategy2) {
      AcxChangeDetectionStrategy2[AcxChangeDetectionStrategy2["Default"] = 0] = "Default";
      AcxChangeDetectionStrategy2[AcxChangeDetectionStrategy2["OnPush"] = 1] = "OnPush";
    })(AcxChangeDetectionStrategy || (AcxChangeDetectionStrategy = {}));
    (function(AcxViewEncapsulation2) {
      AcxViewEncapsulation2[AcxViewEncapsulation2["Emulated"] = 0] = "Emulated";
      AcxViewEncapsulation2[AcxViewEncapsulation2["None"] = 1] = "None";
    })(AcxViewEncapsulation || (AcxViewEncapsulation = {}));
    DOCUMENT2 = void 0;
    APP_ID = new InjectionToken(ngDevMode ? "AppId" : "", {
      providedIn: "root",
      factory: () => DEFAULT_APP_ID
    });
    DEFAULT_APP_ID = "ng";
    PLATFORM_INITIALIZER = new InjectionToken(ngDevMode ? "Platform Initializer" : "");
    PLATFORM_ID = new InjectionToken(ngDevMode ? "Platform ID" : "", {
      providedIn: "platform",
      factory: () => "unknown"
      // set a default platform name, when none set explicitly
    });
    PACKAGE_ROOT_URL = new InjectionToken(ngDevMode ? "Application Packages Root URL" : "");
    ANIMATION_MODULE_TYPE = new InjectionToken(ngDevMode ? "AnimationModuleType" : "");
    CSP_NONCE = new InjectionToken(ngDevMode ? "CSP nonce" : "", {
      providedIn: "root",
      factory: () => {
        return getDocument().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null;
      }
    });
    IMAGE_CONFIG_DEFAULTS = {
      breakpoints: [16, 32, 48, 64, 96, 128, 256, 384, 640, 750, 828, 1080, 1200, 1920, 2048, 3840],
      placeholderResolution: 30,
      disableImageSizeWarning: false,
      disableImageLazyLoadWarning: false
    };
    IMAGE_CONFIG = new InjectionToken(ngDevMode ? "ImageConfig" : "", {
      providedIn: "root",
      factory: () => IMAGE_CONFIG_DEFAULTS
    });
    TransferState = class _TransferState {
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _TransferState,
          providedIn: "root",
          factory: initTransferState
        })
      );
      /** @internal */
      store = {};
      onSerializeCallbacks = {};
      /**
       * Get the value corresponding to a key. Return `defaultValue` if key is not found.
       */
      get(key, defaultValue) {
        return this.store[key] !== void 0 ? this.store[key] : defaultValue;
      }
      /**
       * Set the value corresponding to a key.
       */
      set(key, value) {
        this.store[key] = value;
      }
      /**
       * Remove a key from the store.
       */
      remove(key) {
        delete this.store[key];
      }
      /**
       * Test whether a key exists in the store.
       */
      hasKey(key) {
        return this.store.hasOwnProperty(key);
      }
      /**
       * Indicates whether the state is empty.
       */
      get isEmpty() {
        return Object.keys(this.store).length === 0;
      }
      /**
       * Register a callback to provide the value for a key when `toJson` is called.
       */
      onSerialize(key, callback) {
        this.onSerializeCallbacks[key] = callback;
      }
      /**
       * Serialize the current state of the store to JSON.
       */
      toJson() {
        for (const key in this.onSerializeCallbacks) {
          if (this.onSerializeCallbacks.hasOwnProperty(key)) {
            try {
              this.store[key] = this.onSerializeCallbacks[key]();
            } catch (e) {
              console.warn("Exception in onSerialize callback: ", e);
            }
          }
        }
        return JSON.stringify(this.store).replace(/</g, "\\u003C");
      }
    };
    REFERENCE_NODE_HOST = "h";
    REFERENCE_NODE_BODY = "b";
    NUM_ROOT_NODES = "r";
    DEFER_BLOCK_ID = "di";
    DEFER_BLOCK_STATE$1 = "s";
    DEFER_PARENT_BLOCK_ID = "p";
    IS_HYDRATION_DOM_REUSE_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_HYDRATION_DOM_REUSE_ENABLED" : "");
    PRESERVE_HOST_CONTENT_DEFAULT = false;
    PRESERVE_HOST_CONTENT = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "PRESERVE_HOST_CONTENT" : "", {
      providedIn: "root",
      factory: () => PRESERVE_HOST_CONTENT_DEFAULT
    });
    IS_I18N_HYDRATION_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_I18N_HYDRATION_ENABLED" : "");
    IS_EVENT_REPLAY_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_EVENT_REPLAY_ENABLED" : "");
    IS_INCREMENTAL_HYDRATION_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_INCREMENTAL_HYDRATION_ENABLED" : "");
    JSACTION_BLOCK_ELEMENT_MAP = new InjectionToken(ngDevMode ? "JSACTION_BLOCK_ELEMENT_MAP" : "", {
      providedIn: "root",
      factory: () => /* @__PURE__ */ new Map()
    });
    eventListenerOptions = {
      passive: true,
      capture: true
    };
    hoverTriggers = /* @__PURE__ */ new WeakMap();
    interactionTriggers = /* @__PURE__ */ new WeakMap();
    viewportTriggers = /* @__PURE__ */ new WeakMap();
    interactionEventNames = ["click", "keydown"];
    hoverEventNames = ["mouseenter", "mouseover", "focusin"];
    intersectionObserver = null;
    observedViewportElements = 0;
    DeferEventEntry = class {
      callbacks = /* @__PURE__ */ new Set();
      listener = () => {
        for (const callback of this.callbacks) {
          callback();
        }
      };
    };
    JSACTION_EVENT_CONTRACT = new InjectionToken(ngDevMode ? "EVENT_CONTRACT_DETAILS" : "", {
      providedIn: "root",
      factory: () => ({})
    });
    _stashEventListenerImpl = (lView, target, eventName, wrappedListener) => {
    };
    DEHYDRATED_BLOCK_REGISTRY = new InjectionToken(ngDevMode ? "DEHYDRATED_BLOCK_REGISTRY" : "");
    TRANSFER_STATE_TOKEN_ID = "__nghData__";
    NGH_DATA_KEY = makeStateKey(TRANSFER_STATE_TOKEN_ID);
    TRANSFER_STATE_DEFER_BLOCKS_INFO = "__nghDeferData__";
    NGH_DEFER_BLOCKS_KEY = makeStateKey(TRANSFER_STATE_DEFER_BLOCKS_INFO);
    _retrieveHydrationInfoImpl = () => null;
    (function(HydrationStatus2) {
      HydrationStatus2["Hydrated"] = "hydrated";
      HydrationStatus2["Skipped"] = "skipped";
      HydrationStatus2["Mismatched"] = "mismatched";
    })(HydrationStatus || (HydrationStatus = {}));
    HYDRATION_INFO_KEY = "__ngDebugHydrationInfo__";
    (function(ViewEncapsulation3) {
      ViewEncapsulation3[ViewEncapsulation3["Emulated"] = 0] = "Emulated";
      ViewEncapsulation3[ViewEncapsulation3["None"] = 2] = "None";
      ViewEncapsulation3[ViewEncapsulation3["ShadowDom"] = 3] = "ShadowDom";
    })(ViewEncapsulation || (ViewEncapsulation = {}));
    SafeValueImpl = class {
      changingThisBreaksApplicationSecurity;
      constructor(changingThisBreaksApplicationSecurity) {
        this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
      }
      toString() {
        return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${XSS_SECURITY_URL})`;
      }
    };
    SafeHtmlImpl = class extends SafeValueImpl {
      getTypeName() {
        return "HTML";
      }
    };
    SafeStyleImpl = class extends SafeValueImpl {
      getTypeName() {
        return "Style";
      }
    };
    SafeScriptImpl = class extends SafeValueImpl {
      getTypeName() {
        return "Script";
      }
    };
    SafeUrlImpl = class extends SafeValueImpl {
      getTypeName() {
        return "URL";
      }
    };
    SafeResourceUrlImpl = class extends SafeValueImpl {
      getTypeName() {
        return "ResourceURL";
      }
    };
    DOMParserHelper = class {
      inertDocumentHelper;
      constructor(inertDocumentHelper) {
        this.inertDocumentHelper = inertDocumentHelper;
      }
      getInertBodyElement(html2) {
        html2 = "<body><remove></remove>" + html2;
        try {
          const body = new window.DOMParser().parseFromString(trustedHTMLFromString(html2), "text/html").body;
          if (body === null) {
            return this.inertDocumentHelper.getInertBodyElement(html2);
          }
          body.firstChild?.remove();
          return body;
        } catch {
          return null;
        }
      }
    };
    InertDocumentHelper = class {
      defaultDoc;
      inertDocument;
      constructor(defaultDoc) {
        this.defaultDoc = defaultDoc;
        this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert");
      }
      getInertBodyElement(html2) {
        const templateEl = this.inertDocument.createElement("template");
        templateEl.innerHTML = trustedHTMLFromString(html2);
        return templateEl;
      }
    };
    SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;
    VOID_ELEMENTS = tagSet("area,br,col,hr,img,wbr");
    OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr");
    OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet("rp,rt");
    OPTIONAL_END_TAG_ELEMENTS = merge2(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
    BLOCK_ELEMENTS = merge2(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul"));
    INLINE_ELEMENTS = merge2(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video"));
    VALID_ELEMENTS = merge2(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
    URI_ATTRS = tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href");
    HTML_ATTRS = tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width");
    ARIA_ATTRS = tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext");
    VALID_ATTRS = merge2(URI_ATTRS, HTML_ATTRS, ARIA_ATTRS);
    SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet("script,style,template");
    SanitizingHtmlSerializer = class {
      // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just
      // because characters were re-encoded.
      sanitizedSomething = false;
      buf = [];
      sanitizeChildren(el) {
        let current = el.firstChild;
        let traverseContent = true;
        let parentNodes = [];
        while (current) {
          if (current.nodeType === Node.ELEMENT_NODE) {
            traverseContent = this.startElement(current);
          } else if (current.nodeType === Node.TEXT_NODE) {
            this.chars(current.nodeValue);
          } else {
            this.sanitizedSomething = true;
          }
          if (traverseContent && current.firstChild) {
            parentNodes.push(current);
            current = getFirstChild(current);
            continue;
          }
          while (current) {
            if (current.nodeType === Node.ELEMENT_NODE) {
              this.endElement(current);
            }
            let next = getNextSibling(current);
            if (next) {
              current = next;
              break;
            }
            current = parentNodes.pop();
          }
        }
        return this.buf.join("");
      }
      /**
       * Sanitizes an opening element tag (if valid) and returns whether the element's contents should
       * be traversed. Element content must always be traversed (even if the element itself is not
       * valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.
       *
       * @param element The element to sanitize.
       * @return True if the element's contents should be traversed.
       */
      startElement(element) {
        const tagName = getNodeName(element).toLowerCase();
        if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
          this.sanitizedSomething = true;
          return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
        }
        this.buf.push("<");
        this.buf.push(tagName);
        const elAttrs = element.attributes;
        for (let i = 0; i < elAttrs.length; i++) {
          const elAttr = elAttrs.item(i);
          const attrName = elAttr.name;
          const lower = attrName.toLowerCase();
          if (!VALID_ATTRS.hasOwnProperty(lower)) {
            this.sanitizedSomething = true;
            continue;
          }
          let value = elAttr.value;
          if (URI_ATTRS[lower])
            value = _sanitizeUrl(value);
          this.buf.push(" ", attrName, '="', encodeEntities(value), '"');
        }
        this.buf.push(">");
        return true;
      }
      endElement(current) {
        const tagName = getNodeName(current).toLowerCase();
        if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
          this.buf.push("</");
          this.buf.push(tagName);
          this.buf.push(">");
        }
      }
      chars(chars) {
        this.buf.push(encodeEntities(chars));
      }
    };
    SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
    (function(SecurityContext2) {
      SecurityContext2[SecurityContext2["NONE"] = 0] = "NONE";
      SecurityContext2[SecurityContext2["HTML"] = 1] = "HTML";
      SecurityContext2[SecurityContext2["STYLE"] = 2] = "STYLE";
      SecurityContext2[SecurityContext2["SCRIPT"] = 3] = "SCRIPT";
      SecurityContext2[SecurityContext2["URL"] = 4] = "URL";
      SecurityContext2[SecurityContext2["RESOURCE_URL"] = 5] = "RESOURCE_URL";
    })(SecurityContext || (SecurityContext = {}));
    COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;
    COMMENT_DELIMITER = /(<|>)/g;
    COMMENT_DELIMITER_ESCAPED = "\u200B$1\u200B";
    NG_REFLECT_ATTRS_FLAG_DEFAULT = false;
    NG_REFLECT_ATTRS_FLAG = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "NG_REFLECT_FLAG" : "", {
      providedIn: "root",
      factory: () => NG_REFLECT_ATTRS_FLAG_DEFAULT
    });
    CAMEL_CASE_REGEXP = /([A-Z])/g;
    CUSTOM_ELEMENTS_SCHEMA = {
      name: "custom-elements"
    };
    NO_ERRORS_SCHEMA = {
      name: "no-errors-schema"
    };
    shouldThrowErrorOnUnknownElement = false;
    shouldThrowErrorOnUnknownProperty = false;
    KNOWN_CONTROL_FLOW_DIRECTIVES = /* @__PURE__ */ new Map([
      ["ngIf", "NgIf"],
      ["ngFor", "NgFor"],
      ["ngSwitchCase", "NgSwitchCase"],
      ["ngSwitchDefault", "NgSwitchDefault"]
    ]);
    INTERPOLATION_DELIMITER = `\uFFFD`;
    VALUE_STRING_LENGTH_LIMIT = 200;
    NG_TEMPLATE_SELECTOR = "ng-template";
    NO_CHANGE = typeof ngDevMode === "undefined" || ngDevMode ? { __brand__: "NO_CHANGE" } : {};
    (function(InputFlags2) {
      InputFlags2[InputFlags2["None"] = 0] = "None";
      InputFlags2[InputFlags2["SignalBased"] = 1] = "SignalBased";
      InputFlags2[InputFlags2["HasDecoratorInputTransform"] = 2] = "HasDecoratorInputTransform";
    })(InputFlags || (InputFlags = {}));
    (function(RendererStyleFlags22) {
      RendererStyleFlags22[RendererStyleFlags22["Important"] = 1] = "Important";
      RendererStyleFlags22[RendererStyleFlags22["DashCase"] = 2] = "DashCase";
    })(RendererStyleFlags2 || (RendererStyleFlags2 = {}));
    _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;
    _applyRootElementTransformImpl = () => null;
    USE_EXHAUSTIVE_CHECK_NO_CHANGES_DEFAULT = false;
    UseExhaustiveCheckNoChanges = new InjectionToken(ngDevMode ? "exhaustive checkNoChanges" : "");
    freeConsumers = [];
    REACTIVE_LVIEW_CONSUMER_NODE = __spreadProps(__spreadValues({}, REACTIVE_NODE), {
      consumerIsAlwaysLive: true,
      kind: "template",
      consumerMarkedDirty: (node) => {
        markAncestorsForTraversal(node.lView);
      },
      consumerOnSignalRead() {
        this.lView[REACTIVE_TEMPLATE_CONSUMER] = this;
      }
    });
    TEMPORARY_CONSUMER_NODE = __spreadProps(__spreadValues({}, REACTIVE_NODE), {
      consumerIsAlwaysLive: true,
      kind: "template",
      consumerMarkedDirty: (node) => {
        let parent = getLViewParent(node.lView);
        while (parent && !viewShouldHaveReactiveConsumer(parent[TVIEW])) {
          parent = getLViewParent(parent);
        }
        if (!parent) {
          return;
        }
        markViewForRefresh(parent);
      },
      consumerOnSignalRead() {
        this.lView[REACTIVE_TEMPLATE_CONSUMER] = this;
      }
    });
    MAXIMUM_REFRESH_RERUNS$1 = 100;
    ViewRef = class {
      _lView;
      _cdRefInjectingView;
      _appRef = null;
      _attachedToViewContainer = false;
      exhaustive;
      get rootNodes() {
        const lView = this._lView;
        const tView = lView[TVIEW];
        return collectNativeNodes(tView, lView, tView.firstChild, []);
      }
      constructor(_lView, _cdRefInjectingView) {
        this._lView = _lView;
        this._cdRefInjectingView = _cdRefInjectingView;
      }
      get context() {
        return this._lView[CONTEXT];
      }
      /**
       * @deprecated Replacing the full context object is not supported. Modify the context
       *   directly, or consider using a `Proxy` if you need to replace the full object.
       * // TODO(devversion): Remove this.
       */
      set context(value) {
        if (ngDevMode) {
          console.warn("Angular: Replacing the `context` object of an `EmbeddedViewRef` is deprecated.");
        }
        this._lView[CONTEXT] = value;
      }
      get destroyed() {
        return isDestroyed(this._lView);
      }
      destroy() {
        if (this._appRef) {
          this._appRef.detachView(this);
        } else if (this._attachedToViewContainer) {
          const parent = this._lView[PARENT];
          if (isLContainer(parent)) {
            const viewRefs = parent[VIEW_REFS];
            const index = viewRefs ? viewRefs.indexOf(this) : -1;
            if (index > -1) {
              ngDevMode && assertEqual(index, parent.indexOf(this._lView) - CONTAINER_HEADER_OFFSET, "An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.");
              detachView(parent, index);
              removeFromArray(viewRefs, index);
            }
          }
          this._attachedToViewContainer = false;
        }
        destroyLView(this._lView[TVIEW], this._lView);
      }
      onDestroy(callback) {
        storeLViewOnDestroy(this._lView, callback);
      }
      /**
       * Marks a view and all of its ancestors dirty.
       *
       * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush} component is
       * checked when it needs to be re-rendered but the two normal triggers haven't marked it
       * dirty (i.e. inputs haven't changed and events haven't fired in the view).
       *
       * <!-- TODO: Add a link to a chapter on OnPush components -->
       *
       * @usageNotes
       * ### Example
       *
       * ```ts
       * @Component({
       *   selector: 'app-root',
       *   template: `Number of ticks: {{numberOfTicks}}`
       *   changeDetection: ChangeDetectionStrategy.OnPush,
       * })
       * class AppComponent {
       *   numberOfTicks = 0;
       *
       *   constructor(private ref: ChangeDetectorRef) {
       *     setInterval(() => {
       *       this.numberOfTicks++;
       *       // the following is required, otherwise the view will not be updated
       *       this.ref.markForCheck();
       *     }, 1000);
       *   }
       * }
       * ```
       */
      markForCheck() {
        markViewDirty(
          this._cdRefInjectingView || this._lView,
          4
          /* NotificationSource.MarkForCheck */
        );
      }
      /**
       * Detaches the view from the change detection tree.
       *
       * Detached views will not be checked during change detection runs until they are
       * re-attached, even if they are dirty. `detach` can be used in combination with
       * {@link ChangeDetectorRef#detectChanges} to implement local change
       * detection checks.
       *
       * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
       * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
       *
       * @usageNotes
       * ### Example
       *
       * The following example defines a component with a large list of readonly data.
       * Imagine the data changes constantly, many times per second. For performance reasons,
       * we want to check and update the list every five seconds. We can do that by detaching
       * the component's change detector and doing a local check every five seconds.
       *
       * ```ts
       * class DataProvider {
       *   // in a real application the returned data will be different every time
       *   get data() {
       *     return [1,2,3,4,5];
       *   }
       * }
       *
       * @Component({
       *   selector: 'giant-list',
       *   template: `
       *     @for(d of dataProvider.data; track $index) {
       *        <li>Data {{d}}</li>
       *     }
       *   `,
       * })
       * class GiantList {
       *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {
       *     ref.detach();
       *     setInterval(() => {
       *       this.ref.detectChanges();
       *     }, 5000);
       *   }
       * }
       *
       * @Component({
       *   selector: 'app',
       *   providers: [DataProvider],
       *   template: `
       *     <giant-list><giant-list>
       *   `,
       * })
       * class App {
       * }
       * ```
       */
      detach() {
        this._lView[FLAGS] &= ~128;
      }
      /**
       * Re-attaches a view to the change detection tree.
       *
       * This can be used to re-attach views that were previously detached from the tree
       * using {@link ChangeDetectorRef#detach}. Views are attached to the tree by default.
       *
       * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
       *
       * @usageNotes
       * ### Example
       *
       * The following example creates a component displaying `live` data. The component will detach
       * its change detector from the main change detector tree when the component's live property
       * is set to false.
       *
       * ```ts
       * class DataProvider {
       *   data = 1;
       *
       *   constructor() {
       *     setInterval(() => {
       *       this.data = this.data * 2;
       *     }, 500);
       *   }
       * }
       *
       * @Component({
       *   selector: 'live-data',
       *   inputs: ['live'],
       *   template: 'Data: {{dataProvider.data}}'
       * })
       * class LiveData {
       *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}
       *
       *   set live(value) {
       *     if (value) {
       *       this.ref.reattach();
       *     } else {
       *       this.ref.detach();
       *     }
       *   }
       * }
       *
       * @Component({
       *   selector: 'app-root',
       *   providers: [DataProvider],
       *   template: `
       *     Live Update: <input type="checkbox" [(ngModel)]="live">
       *     <live-data [live]="live"><live-data>
       *   `,
       * })
       * class AppComponent {
       *   live = true;
       * }
       * ```
       */
      reattach() {
        updateAncestorTraversalFlagsOnAttach(this._lView);
        this._lView[FLAGS] |= 128;
      }
      /**
       * Checks the view and its children.
       *
       * This can also be used in combination with {@link ChangeDetectorRef#detach} to implement
       * local change detection checks.
       *
       * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
       * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
       *
       * @usageNotes
       * ### Example
       *
       * The following example defines a component with a large list of readonly data.
       * Imagine, the data changes constantly, many times per second. For performance reasons,
       * we want to check and update the list every five seconds.
       *
       * We can do that by detaching the component's change detector and doing a local change detection
       * check every five seconds.
       *
       * See {@link ChangeDetectorRef#detach} for more information.
       */
      detectChanges() {
        this._lView[FLAGS] |= 1024;
        detectChangesInternal(this._lView);
      }
      /**
       * Checks the change detector and its children, and throws if any changes are detected.
       *
       * This is used in development mode to verify that running change detection doesn't
       * introduce other changes.
       */
      checkNoChanges() {
        if (!ngDevMode)
          return;
        try {
          this.exhaustive ??= this._lView[INJECTOR].get(UseExhaustiveCheckNoChanges, USE_EXHAUSTIVE_CHECK_NO_CHANGES_DEFAULT);
        } catch {
          this.exhaustive = USE_EXHAUSTIVE_CHECK_NO_CHANGES_DEFAULT;
        }
        checkNoChangesInternal(this._lView, this.exhaustive);
      }
      attachToViewContainerRef() {
        if (this._appRef) {
          throw new RuntimeError(902, ngDevMode && "This view is already attached directly to the ApplicationRef!");
        }
        this._attachedToViewContainer = true;
      }
      detachFromAppRef() {
        this._appRef = null;
        const isRoot = isRootView(this._lView);
        const declarationContainer = this._lView[DECLARATION_LCONTAINER];
        if (declarationContainer !== null && !isRoot) {
          detachMovedView(declarationContainer, this._lView);
        }
        detachViewFromDOM(this._lView[TVIEW], this._lView);
      }
      attachToAppRef(appRef) {
        if (this._attachedToViewContainer) {
          throw new RuntimeError(902, ngDevMode && "This view is already attached to a ViewContainer!");
        }
        this._appRef = appRef;
        const isRoot = isRootView(this._lView);
        const declarationContainer = this._lView[DECLARATION_LCONTAINER];
        if (declarationContainer !== null && !isRoot) {
          trackMovedView(declarationContainer, this._lView);
        }
        updateAncestorTraversalFlagsOnAttach(this._lView);
      }
    };
    TemplateRef = class {
      _declarationLView;
      _declarationTContainer;
      /**
       * The anchor element in the parent view for this embedded view.
       *
       * The data-binding and [injection contexts](guide/di/dependency-injection-context) of embedded
       * views created from this `TemplateRef` inherit from the contexts of this location.
       *
       * Typically new embedded views are attached to the view container of this location, but in
       * advanced use-cases, the view can be attached to a different container while keeping the
       * data-binding and injection context from the original location.
       *
       */
      elementRef;
      /**
       * @internal
       * @nocollapse
       */
      static __NG_ELEMENT_ID__ = injectTemplateRef;
      /** @internal */
      constructor(_declarationLView, _declarationTContainer, elementRef) {
        this._declarationLView = _declarationLView;
        this._declarationTContainer = _declarationTContainer;
        this.elementRef = elementRef;
      }
      /**
       * Returns an `ssrId` associated with a TView, which was used to
       * create this instance of the `TemplateRef`.
       *
       * @internal
       */
      get ssrId() {
        return this._declarationTContainer.tView?.ssrId || null;
      }
      /**
       * Instantiates an unattached embedded view based on this template.
       * @param context The data-binding context of the embedded view, as declared
       * in the `<ng-template>` usage.
       * @param injector Injector to be used within the embedded view.
       * @returns The new embedded view object.
       */
      createEmbeddedView(context2, injector) {
        return this.createEmbeddedViewImpl(context2, injector);
      }
      /**
       * Implementation of the `createEmbeddedView` function.
       *
       * This implementation is internal and allows framework code
       * to invoke it with extra parameters (e.g. for hydration) without
       * affecting public API.
       *
       * @internal
       */
      createEmbeddedViewImpl(context2, injector, dehydratedView) {
        const embeddedLView = createAndRenderEmbeddedLView(this._declarationLView, this._declarationTContainer, context2, { embeddedViewInjector: injector, dehydratedView });
        return new ViewRef(embeddedLView);
      }
    };
    AT_THIS_LOCATION = "<-- AT THIS LOCATION";
    internalAttrs = /* @__PURE__ */ new Set(["ngh", "ng-version", "ng-server-context"]);
    REF_EXTRACTOR_REGEXP = /* @__PURE__ */ new RegExp(`^(\\d+)*(${REFERENCE_NODE_BODY}|${REFERENCE_NODE_HOST})*(.*)`);
    _prepareI18nBlockForHydrationImpl = () => {
    };
    _claimDehydratedIcuCaseImpl = () => {
    };
    _findMatchingDehydratedViewImpl = () => null;
    _findAndReconcileMatchingDehydratedViewsImpl = () => null;
    ComponentRef$1 = class ComponentRef {
    };
    ComponentFactory$1 = class ComponentFactory {
    };
    _NullComponentFactoryResolver = class {
      resolveComponentFactory(component) {
        throw new RuntimeError(917, typeof ngDevMode !== "undefined" && ngDevMode && `No component factory found for ${stringify(component)}.`);
      }
    };
    ComponentFactoryResolver$1 = class ComponentFactoryResolver {
      static NULL = new _NullComponentFactoryResolver();
    };
    RendererFactory2 = class {
    };
    Renderer2 = class {
      /**
       * If null or undefined, the view engine won't call it.
       * This is used as a performance optimization for production mode.
       */
      destroyNode = null;
      /**
       * @internal
       * @nocollapse
       */
      static __NG_ELEMENT_ID__ = () => injectRenderer2();
    };
    Sanitizer = class _Sanitizer {
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _Sanitizer,
          providedIn: "root",
          factory: () => null
        })
      );
    };
    DepsTracker = class {
      ownerNgModule = /* @__PURE__ */ new Map();
      ngModulesWithSomeUnresolvedDecls = /* @__PURE__ */ new Set();
      ngModulesScopeCache = /* @__PURE__ */ new Map();
      standaloneComponentsScopeCache = /* @__PURE__ */ new Map();
      /**
       * Attempts to resolve ng module's forward ref declarations as much as possible and add them to
       * the `ownerNgModule` map. This method normally should be called after the initial parsing when
       * all the forward refs are resolved (e.g., when trying to render a component)
       */
      resolveNgModulesDecls() {
        if (this.ngModulesWithSomeUnresolvedDecls.size === 0) {
          return;
        }
        for (const moduleType of this.ngModulesWithSomeUnresolvedDecls) {
          const def = getNgModuleDef(moduleType);
          if (def?.declarations) {
            for (const decl of maybeUnwrapFn(def.declarations)) {
              if (isComponent(decl)) {
                this.ownerNgModule.set(decl, moduleType);
              }
            }
          }
        }
        this.ngModulesWithSomeUnresolvedDecls.clear();
      }
      /** @override */
      getComponentDependencies(type, rawImports) {
        this.resolveNgModulesDecls();
        const def = getComponentDef(type);
        if (def === null) {
          throw new Error(`Attempting to get component dependencies for a type that is not a component: ${type}`);
        }
        if (def.standalone) {
          const scope = this.getStandaloneComponentScope(type, rawImports);
          if (scope.compilation.isPoisoned) {
            return { dependencies: [] };
          }
          return {
            dependencies: [
              ...scope.compilation.directives,
              ...scope.compilation.pipes,
              ...scope.compilation.ngModules
            ]
          };
        } else {
          if (!this.ownerNgModule.has(type)) {
            return { dependencies: [] };
          }
          const scope = this.getNgModuleScope(this.ownerNgModule.get(type));
          if (scope.compilation.isPoisoned) {
            return { dependencies: [] };
          }
          return {
            dependencies: [...scope.compilation.directives, ...scope.compilation.pipes]
          };
        }
      }
      /**
       * @override
       * This implementation does not make use of param scopeInfo since it assumes the scope info is
       * already added to the type itself through methods like {@link setNgModuleScope}
       */
      registerNgModule(type, scopeInfo) {
        if (!isNgModule(type)) {
          throw new Error(`Attempting to register a Type which is not NgModule as NgModule: ${type}`);
        }
        this.ngModulesWithSomeUnresolvedDecls.add(type);
      }
      /** @override */
      clearScopeCacheFor(type) {
        this.ngModulesScopeCache.delete(type);
        this.standaloneComponentsScopeCache.delete(type);
      }
      /** @override */
      getNgModuleScope(type) {
        if (this.ngModulesScopeCache.has(type)) {
          return this.ngModulesScopeCache.get(type);
        }
        const scope = this.computeNgModuleScope(type);
        this.ngModulesScopeCache.set(type, scope);
        return scope;
      }
      /** Compute NgModule scope afresh. */
      computeNgModuleScope(type) {
        const def = getNgModuleDefOrThrow(type);
        const scope = {
          exported: { directives: /* @__PURE__ */ new Set(), pipes: /* @__PURE__ */ new Set() },
          compilation: { directives: /* @__PURE__ */ new Set(), pipes: /* @__PURE__ */ new Set() }
        };
        for (const imported of maybeUnwrapFn(def.imports)) {
          if (isNgModule(imported)) {
            const importedScope = this.getNgModuleScope(imported);
            addSet(importedScope.exported.directives, scope.compilation.directives);
            addSet(importedScope.exported.pipes, scope.compilation.pipes);
          } else if (isStandalone(imported)) {
            if (isDirective(imported) || isComponent(imported)) {
              scope.compilation.directives.add(imported);
            } else if (isPipe(imported)) {
              scope.compilation.pipes.add(imported);
            } else {
              throw new RuntimeError(980, "The standalone imported type is neither a component nor a directive nor a pipe");
            }
          } else {
            scope.compilation.isPoisoned = true;
            break;
          }
        }
        if (!scope.compilation.isPoisoned) {
          for (const decl of maybeUnwrapFn(def.declarations)) {
            if (isNgModule(decl) || isStandalone(decl)) {
              scope.compilation.isPoisoned = true;
              break;
            }
            if (isPipe(decl)) {
              scope.compilation.pipes.add(decl);
            } else {
              scope.compilation.directives.add(decl);
            }
          }
        }
        for (const exported of maybeUnwrapFn(def.exports)) {
          if (isNgModule(exported)) {
            const exportedScope = this.getNgModuleScope(exported);
            addSet(exportedScope.exported.directives, scope.exported.directives);
            addSet(exportedScope.exported.pipes, scope.exported.pipes);
            addSet(exportedScope.exported.directives, scope.compilation.directives);
            addSet(exportedScope.exported.pipes, scope.compilation.pipes);
          } else if (isPipe(exported)) {
            scope.exported.pipes.add(exported);
          } else {
            scope.exported.directives.add(exported);
          }
        }
        return scope;
      }
      /** @override */
      getStandaloneComponentScope(type, rawImports) {
        if (this.standaloneComponentsScopeCache.has(type)) {
          return this.standaloneComponentsScopeCache.get(type);
        }
        const ans = this.computeStandaloneComponentScope(type, rawImports);
        this.standaloneComponentsScopeCache.set(type, ans);
        return ans;
      }
      computeStandaloneComponentScope(type, rawImports) {
        const ans = {
          compilation: {
            // Standalone components are always able to self-reference.
            directives: /* @__PURE__ */ new Set([type]),
            pipes: /* @__PURE__ */ new Set(),
            ngModules: /* @__PURE__ */ new Set()
          }
        };
        for (const rawImport of flatten(rawImports ?? [])) {
          const imported = resolveForwardRef(rawImport);
          try {
            verifyStandaloneImport(imported, type);
          } catch (e) {
            ans.compilation.isPoisoned = true;
            return ans;
          }
          if (isNgModule(imported)) {
            ans.compilation.ngModules.add(imported);
            const importedScope = this.getNgModuleScope(imported);
            if (importedScope.exported.isPoisoned) {
              ans.compilation.isPoisoned = true;
              return ans;
            }
            addSet(importedScope.exported.directives, ans.compilation.directives);
            addSet(importedScope.exported.pipes, ans.compilation.pipes);
          } else if (isPipe(imported)) {
            ans.compilation.pipes.add(imported);
          } else if (isDirective(imported) || isComponent(imported)) {
            ans.compilation.directives.add(imported);
          } else {
            ans.compilation.isPoisoned = true;
            return ans;
          }
        }
        return ans;
      }
      /** @override */
      isOrphanComponent(cmp) {
        const def = getComponentDef(cmp);
        if (!def || def.standalone) {
          return false;
        }
        this.resolveNgModulesDecls();
        return !this.ownerNgModule.has(cmp);
      }
    };
    depsTracker = new DepsTracker();
    NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
    ChainedInjector = class {
      injector;
      parentInjector;
      constructor(injector, parentInjector) {
        this.injector = injector;
        this.parentInjector = parentInjector;
      }
      get(token, notFoundValue, options) {
        const value = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, options);
        if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
          return value;
        }
        return this.parentInjector.get(token, notFoundValue, options);
      }
    };
    BINDING = /* @__PURE__ */ Symbol("BINDING");
    ComponentFactoryResolver2 = class extends ComponentFactoryResolver$1 {
      ngModule;
      /**
       * @param ngModule The NgModuleRef to which all resolved factories are bound.
       */
      constructor(ngModule) {
        super();
        this.ngModule = ngModule;
      }
      resolveComponentFactory(component) {
        ngDevMode && assertComponentType(component);
        const componentDef = getComponentDef(component);
        return new ComponentFactory2(componentDef, this.ngModule);
      }
    };
    ComponentFactory2 = class extends ComponentFactory$1 {
      componentDef;
      ngModule;
      selector;
      componentType;
      ngContentSelectors;
      isBoundToModule;
      cachedInputs = null;
      cachedOutputs = null;
      get inputs() {
        this.cachedInputs ??= toInputRefArray(this.componentDef.inputs);
        return this.cachedInputs;
      }
      get outputs() {
        this.cachedOutputs ??= toOutputRefArray(this.componentDef.outputs);
        return this.cachedOutputs;
      }
      /**
       * @param componentDef The component definition.
       * @param ngModule The NgModuleRef to which the factory is bound.
       */
      constructor(componentDef, ngModule) {
        super();
        this.componentDef = componentDef;
        this.ngModule = ngModule;
        this.componentType = componentDef.type;
        this.selector = stringifyCSSSelectorList(componentDef.selectors);
        this.ngContentSelectors = componentDef.ngContentSelectors ?? [];
        this.isBoundToModule = !!ngModule;
      }
      create(injector, projectableNodes, rootSelectorOrNode, environmentInjector, directives, componentBindings) {
        profiler(
          22
          /* ProfilerEvent.DynamicComponentStart */
        );
        const prevConsumer = setActiveConsumer(null);
        try {
          const cmpDef = this.componentDef;
          ngDevMode && verifyNotAnOrphanComponent(cmpDef);
          const rootTView = createRootTView(rootSelectorOrNode, cmpDef, componentBindings, directives);
          const rootViewInjector = createRootViewInjector(cmpDef, environmentInjector || this.ngModule, injector);
          const environment = createRootLViewEnvironment(rootViewInjector);
          const hostRenderer = environment.rendererFactory.createRenderer(null, cmpDef);
          const hostElement = rootSelectorOrNode ? locateHostElement(hostRenderer, rootSelectorOrNode, cmpDef.encapsulation, rootViewInjector) : createHostElement(cmpDef, hostRenderer);
          const hasInputBindings = componentBindings?.some(isInputBinding) || directives?.some((d) => typeof d !== "function" && d.bindings.some(isInputBinding));
          const rootLView = createLView(null, rootTView, null, 512 | getInitialLViewFlagsFromDef(cmpDef), null, null, environment, hostRenderer, rootViewInjector, null, retrieveHydrationInfo(
            hostElement,
            rootViewInjector,
            true
            /* isRootView */
          ));
          rootLView[HEADER_OFFSET] = hostElement;
          enterView(rootLView);
          let componentView = null;
          try {
            const hostTNode = directiveHostFirstCreatePass(HEADER_OFFSET, rootLView, 2, "#host", () => rootTView.directiveRegistry, true, 0);
            if (hostElement) {
              setupStaticAttributes(hostRenderer, hostElement, hostTNode);
              attachPatchData(hostElement, rootLView);
            }
            createDirectivesInstances(rootTView, rootLView, hostTNode);
            executeContentQueries(rootTView, hostTNode, rootLView);
            directiveHostEndFirstCreatePass(rootTView, hostTNode);
            if (projectableNodes !== void 0) {
              projectNodes(hostTNode, this.ngContentSelectors, projectableNodes);
            }
            componentView = getComponentLViewByIndex(hostTNode.index, rootLView);
            rootLView[CONTEXT] = componentView[CONTEXT];
            renderView(rootTView, rootLView, null);
          } catch (e) {
            if (componentView !== null) {
              unregisterLView(componentView);
            }
            unregisterLView(rootLView);
            throw e;
          } finally {
            profiler(
              23
              /* ProfilerEvent.DynamicComponentEnd */
            );
            leaveView();
          }
          return new ComponentRef2(this.componentType, rootLView, !!hasInputBindings);
        } finally {
          setActiveConsumer(prevConsumer);
        }
      }
    };
    ComponentRef2 = class extends ComponentRef$1 {
      _rootLView;
      _hasInputBindings;
      instance;
      hostView;
      changeDetectorRef;
      componentType;
      location;
      previousInputValues = null;
      _tNode;
      constructor(componentType, _rootLView, _hasInputBindings) {
        super();
        this._rootLView = _rootLView;
        this._hasInputBindings = _hasInputBindings;
        this._tNode = getTNode(_rootLView[TVIEW], HEADER_OFFSET);
        this.location = createElementRef(this._tNode, _rootLView);
        this.instance = getComponentLViewByIndex(this._tNode.index, _rootLView)[CONTEXT];
        this.hostView = this.changeDetectorRef = new ViewRef(
          _rootLView,
          void 0
          /* _cdRefInjectingView */
        );
        this.componentType = componentType;
      }
      setInput(name2, value) {
        if (this._hasInputBindings && ngDevMode) {
          throw new RuntimeError(317, "Cannot call `setInput` on a component that is using the `inputBinding` or `twoWayBinding` functions.");
        }
        const tNode = this._tNode;
        this.previousInputValues ??= /* @__PURE__ */ new Map();
        if (this.previousInputValues.has(name2) && Object.is(this.previousInputValues.get(name2), value)) {
          return;
        }
        const lView = this._rootLView;
        const hasSetInput = setAllInputsForProperty(tNode, lView[TVIEW], lView, name2, value);
        this.previousInputValues.set(name2, value);
        const childComponentLView = getComponentLViewByIndex(tNode.index, lView);
        markViewDirty(
          childComponentLView,
          1
          /* NotificationSource.SetInput */
        );
        if (ngDevMode && !hasSetInput) {
          const cmpNameForError = stringifyForError(this.componentType);
          let message = `Can't set value of the '${name2}' input on the '${cmpNameForError}' component. `;
          message += `Make sure that the '${name2}' property is declared as an input using the @Input() decorator or the input() function.`;
          reportUnknownPropertyError(message);
        }
      }
      get injector() {
        return new NodeInjector(this._tNode, this._rootLView);
      }
      destroy() {
        this.hostView.destroy();
      }
      onDestroy(callback) {
        this.hostView.onDestroy(callback);
      }
    };
    ViewContainerRef = class {
      /**
       * @internal
       * @nocollapse
       */
      static __NG_ELEMENT_ID__ = injectViewContainerRef;
    };
    VE_ViewContainerRef = ViewContainerRef;
    R3ViewContainerRef = class ViewContainerRef2 extends VE_ViewContainerRef {
      _lContainer;
      _hostTNode;
      _hostLView;
      constructor(_lContainer, _hostTNode, _hostLView) {
        super();
        this._lContainer = _lContainer;
        this._hostTNode = _hostTNode;
        this._hostLView = _hostLView;
      }
      get element() {
        return createElementRef(this._hostTNode, this._hostLView);
      }
      get injector() {
        return new NodeInjector(this._hostTNode, this._hostLView);
      }
      /** @deprecated No replacement */
      get parentInjector() {
        const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);
        if (hasParentInjector(parentLocation)) {
          const parentView = getParentInjectorView(parentLocation, this._hostLView);
          const injectorIndex = getParentInjectorIndex(parentLocation);
          ngDevMode && assertNodeInjector(parentView, injectorIndex);
          const parentTNode = parentView[TVIEW].data[
            injectorIndex + 8
            /* NodeInjectorOffset.TNODE */
          ];
          return new NodeInjector(parentTNode, parentView);
        } else {
          return new NodeInjector(null, this._hostLView);
        }
      }
      clear() {
        while (this.length > 0) {
          this.remove(this.length - 1);
        }
      }
      get(index) {
        const viewRefs = getViewRefs(this._lContainer);
        return viewRefs !== null && viewRefs[index] || null;
      }
      get length() {
        return this._lContainer.length - CONTAINER_HEADER_OFFSET;
      }
      createEmbeddedView(templateRef, context2, indexOrOptions) {
        let index;
        let injector;
        if (typeof indexOrOptions === "number") {
          index = indexOrOptions;
        } else if (indexOrOptions != null) {
          index = indexOrOptions.index;
          injector = indexOrOptions.injector;
        }
        const dehydratedView = findMatchingDehydratedView(this._lContainer, templateRef.ssrId);
        const viewRef = templateRef.createEmbeddedViewImpl(context2 || {}, injector, dehydratedView);
        this.insertImpl(viewRef, index, shouldAddViewToDom(this._hostTNode, dehydratedView));
        return viewRef;
      }
      createComponent(componentFactoryOrType, indexOrOptions, injector, projectableNodes, environmentInjector, directives, bindings) {
        const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);
        let index;
        if (isComponentFactory) {
          if (ngDevMode) {
            assertEqual(typeof indexOrOptions !== "object", true, "It looks like Component factory was provided as the first argument and an options object as the second argument. This combination of arguments is incompatible. You can either change the first argument to provide Component type or change the second argument to be a number (representing an index at which to insert the new component's host view into this container)");
          }
          index = indexOrOptions;
        } else {
          if (ngDevMode) {
            assertDefined(getComponentDef(componentFactoryOrType), `Provided Component class doesn't contain Component definition. Please check whether provided class has @Component decorator.`);
            assertEqual(typeof indexOrOptions !== "number", true, "It looks like Component type was provided as the first argument and a number (representing an index at which to insert the new component's host view into this container as the second argument. This combination of arguments is incompatible. Please use an object as the second argument instead.");
          }
          const options = indexOrOptions || {};
          if (ngDevMode && options.environmentInjector && options.ngModuleRef) {
            throwError2(`Cannot pass both environmentInjector and ngModuleRef options to createComponent().`);
          }
          index = options.index;
          injector = options.injector;
          projectableNodes = options.projectableNodes;
          environmentInjector = options.environmentInjector || options.ngModuleRef;
          directives = options.directives;
          bindings = options.bindings;
        }
        const componentFactory = isComponentFactory ? componentFactoryOrType : new ComponentFactory2(getComponentDef(componentFactoryOrType));
        const contextInjector = injector || this.parentInjector;
        if (!environmentInjector && componentFactory.ngModule == null) {
          const _injector = isComponentFactory ? contextInjector : this.parentInjector;
          const result = _injector.get(EnvironmentInjector, null);
          if (result) {
            environmentInjector = result;
          }
        }
        const componentDef = getComponentDef(componentFactory.componentType ?? {});
        const dehydratedView = findMatchingDehydratedView(this._lContainer, componentDef?.id ?? null);
        const rNode = dehydratedView?.firstChild ?? null;
        const componentRef = componentFactory.create(contextInjector, projectableNodes, rNode, environmentInjector, directives, bindings);
        this.insertImpl(componentRef.hostView, index, shouldAddViewToDom(this._hostTNode, dehydratedView));
        return componentRef;
      }
      insert(viewRef, index) {
        return this.insertImpl(viewRef, index, true);
      }
      insertImpl(viewRef, index, addToDOM) {
        const lView = viewRef._lView;
        if (ngDevMode && viewRef.destroyed) {
          throw new Error("Cannot insert a destroyed View in a ViewContainer!");
        }
        if (viewAttachedToContainer(lView)) {
          const prevIdx = this.indexOf(viewRef);
          if (prevIdx !== -1) {
            this.detach(prevIdx);
          } else {
            const prevLContainer = lView[PARENT];
            ngDevMode && assertEqual(isLContainer(prevLContainer), true, "An attached view should have its PARENT point to a container.");
            const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[T_HOST], prevLContainer[PARENT]);
            prevVCRef.detach(prevVCRef.indexOf(viewRef));
          }
        }
        const adjustedIdx = this._adjustIndex(index);
        const lContainer = this._lContainer;
        addLViewToLContainer(lContainer, lView, adjustedIdx, addToDOM);
        viewRef.attachToViewContainerRef();
        addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);
        return viewRef;
      }
      move(viewRef, newIndex) {
        if (ngDevMode && viewRef.destroyed) {
          throw new Error("Cannot move a destroyed View in a ViewContainer!");
        }
        return this.insert(viewRef, newIndex);
      }
      indexOf(viewRef) {
        const viewRefsArr = getViewRefs(this._lContainer);
        return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;
      }
      remove(index) {
        const adjustedIdx = this._adjustIndex(index, -1);
        const detachedView = detachView(this._lContainer, adjustedIdx);
        if (detachedView) {
          removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);
          destroyLView(detachedView[TVIEW], detachedView);
        }
      }
      detach(index) {
        const adjustedIdx = this._adjustIndex(index, -1);
        const view = detachView(this._lContainer, adjustedIdx);
        const wasDetached = view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;
        return wasDetached ? new ViewRef(view) : null;
      }
      _adjustIndex(index, shift2 = 0) {
        if (index == null) {
          return this.length + shift2;
        }
        if (ngDevMode) {
          assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`);
          assertLessThan(index, this.length + 1 + shift2, "index");
        }
        return index;
      }
    };
    _locateOrCreateAnchorNode = createAnchorNode;
    _populateDehydratedViewsInLContainer = () => false;
    LQuery_ = class _LQuery_ {
      queryList;
      matches = null;
      constructor(queryList) {
        this.queryList = queryList;
      }
      clone() {
        return new _LQuery_(this.queryList);
      }
      setDirty() {
        this.queryList.setDirty();
      }
    };
    LQueries_ = class _LQueries_ {
      queries;
      constructor(queries = []) {
        this.queries = queries;
      }
      createEmbeddedView(tView) {
        const tQueries = tView.queries;
        if (tQueries !== null) {
          const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;
          const viewLQueries = [];
          for (let i = 0; i < noOfInheritedQueries; i++) {
            const tQuery = tQueries.getByIndex(i);
            const parentLQuery = this.queries[tQuery.indexInDeclarationView];
            viewLQueries.push(parentLQuery.clone());
          }
          return new _LQueries_(viewLQueries);
        }
        return null;
      }
      insertView(tView) {
        this.dirtyQueriesWithMatches(tView);
      }
      detachView(tView) {
        this.dirtyQueriesWithMatches(tView);
      }
      finishViewCreation(tView) {
        this.dirtyQueriesWithMatches(tView);
      }
      dirtyQueriesWithMatches(tView) {
        for (let i = 0; i < this.queries.length; i++) {
          if (getTQuery(tView, i).matches !== null) {
            this.queries[i].setDirty();
          }
        }
      }
    };
    TQueryMetadata_ = class {
      flags;
      read;
      predicate;
      constructor(predicate, flags, read = null) {
        this.flags = flags;
        this.read = read;
        if (typeof predicate === "string") {
          this.predicate = splitQueryMultiSelectors(predicate);
        } else {
          this.predicate = predicate;
        }
      }
    };
    TQueries_ = class _TQueries_ {
      queries;
      constructor(queries = []) {
        this.queries = queries;
      }
      elementStart(tView, tNode) {
        ngDevMode && assertFirstCreatePass(tView, "Queries should collect results on the first template pass only");
        for (let i = 0; i < this.queries.length; i++) {
          this.queries[i].elementStart(tView, tNode);
        }
      }
      elementEnd(tNode) {
        for (let i = 0; i < this.queries.length; i++) {
          this.queries[i].elementEnd(tNode);
        }
      }
      embeddedTView(tNode) {
        let queriesForTemplateRef = null;
        for (let i = 0; i < this.length; i++) {
          const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;
          const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);
          if (tqueryClone) {
            tqueryClone.indexInDeclarationView = i;
            if (queriesForTemplateRef !== null) {
              queriesForTemplateRef.push(tqueryClone);
            } else {
              queriesForTemplateRef = [tqueryClone];
            }
          }
        }
        return queriesForTemplateRef !== null ? new _TQueries_(queriesForTemplateRef) : null;
      }
      template(tView, tNode) {
        ngDevMode && assertFirstCreatePass(tView, "Queries should collect results on the first template pass only");
        for (let i = 0; i < this.queries.length; i++) {
          this.queries[i].template(tView, tNode);
        }
      }
      getByIndex(index) {
        ngDevMode && assertIndexInRange(this.queries, index);
        return this.queries[index];
      }
      get length() {
        return this.queries.length;
      }
      track(tquery) {
        this.queries.push(tquery);
      }
    };
    TQuery_ = class _TQuery_ {
      metadata;
      matches = null;
      indexInDeclarationView = -1;
      crossesNgTemplate = false;
      /**
       * A node index on which a query was declared (-1 for view queries and ones inherited from the
       * declaration template). We use this index (alongside with _appliesToNextNode flag) to know
       * when to apply content queries to elements in a template.
       */
      _declarationNodeIndex;
      /**
       * A flag indicating if a given query still applies to nodes it is crossing. We use this flag
       * (alongside with _declarationNodeIndex) to know when to stop applying content queries to
       * elements in a template.
       */
      _appliesToNextNode = true;
      constructor(metadata, nodeIndex = -1) {
        this.metadata = metadata;
        this._declarationNodeIndex = nodeIndex;
      }
      elementStart(tView, tNode) {
        if (this.isApplyingToNode(tNode)) {
          this.matchTNode(tView, tNode);
        }
      }
      elementEnd(tNode) {
        if (this._declarationNodeIndex === tNode.index) {
          this._appliesToNextNode = false;
        }
      }
      template(tView, tNode) {
        this.elementStart(tView, tNode);
      }
      embeddedTView(tNode, childQueryIndex) {
        if (this.isApplyingToNode(tNode)) {
          this.crossesNgTemplate = true;
          this.addMatch(-tNode.index, childQueryIndex);
          return new _TQuery_(this.metadata);
        }
        return null;
      }
      isApplyingToNode(tNode) {
        if (this._appliesToNextNode && (this.metadata.flags & 1) !== 1) {
          const declarationNodeIdx = this._declarationNodeIndex;
          let parent = tNode.parent;
          while (parent !== null && parent.type & 8 && parent.index !== declarationNodeIdx) {
            parent = parent.parent;
          }
          return declarationNodeIdx === (parent !== null ? parent.index : -1);
        }
        return this._appliesToNextNode;
      }
      matchTNode(tView, tNode) {
        const predicate = this.metadata.predicate;
        if (Array.isArray(predicate)) {
          for (let i = 0; i < predicate.length; i++) {
            const name2 = predicate[i];
            this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name2));
            this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name2, false, false));
          }
        } else {
          if (predicate === TemplateRef) {
            if (tNode.type & 4) {
              this.matchTNodeWithReadOption(tView, tNode, -1);
            }
          } else {
            this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));
          }
        }
      }
      matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {
        if (nodeMatchIdx !== null) {
          const read = this.metadata.read;
          if (read !== null) {
            if (read === ElementRef || read === ViewContainerRef || read === TemplateRef && tNode.type & 4) {
              this.addMatch(tNode.index, -2);
            } else {
              const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);
              if (directiveOrProviderIdx !== null) {
                this.addMatch(tNode.index, directiveOrProviderIdx);
              }
            }
          } else {
            this.addMatch(tNode.index, nodeMatchIdx);
          }
        }
      }
      addMatch(tNodeIdx, matchIdx) {
        if (this.matches === null) {
          this.matches = [tNodeIdx, matchIdx];
        } else {
          this.matches.push(tNodeIdx, matchIdx);
        }
      }
    };
    componentResourceResolutionQueue = /* @__PURE__ */ new Map();
    componentDefPendingResolution = /* @__PURE__ */ new Set();
    modules = /* @__PURE__ */ new Map();
    checkForDuplicateNgModules = true;
    markedFeatures = /* @__PURE__ */ new Set();
    NgModuleRef$1 = class NgModuleRef {
    };
    NgModuleFactory$1 = class NgModuleFactory {
    };
    NgModuleRef2 = class extends NgModuleRef$1 {
      ngModuleType;
      _parent;
      // tslint:disable-next-line:require-internal-with-underscore
      _bootstrapComponents = [];
      _r3Injector;
      instance;
      destroyCbs = [];
      // When bootstrapping a module we have a dependency graph that looks like this:
      // ApplicationRef -> ComponentFactoryResolver -> NgModuleRef. The problem is that if the
      // module being resolved tries to inject the ComponentFactoryResolver, it'll create a
      // circular dependency which will result in a runtime error, because the injector doesn't
      // exist yet. We work around the issue by creating the ComponentFactoryResolver ourselves
      // and providing it, rather than letting the injector resolve it.
      componentFactoryResolver = new ComponentFactoryResolver2(this);
      constructor(ngModuleType, _parent, additionalProviders, runInjectorInitializers = true) {
        super();
        this.ngModuleType = ngModuleType;
        this._parent = _parent;
        const ngModuleDef = getNgModuleDef(ngModuleType);
        ngDevMode && assertDefined(ngModuleDef, `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`);
        this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap);
        this._r3Injector = createInjectorWithoutInjectorInstances(ngModuleType, _parent, [
          { provide: NgModuleRef$1, useValue: this },
          {
            provide: ComponentFactoryResolver$1,
            useValue: this.componentFactoryResolver
          },
          ...additionalProviders
        ], stringify(ngModuleType), /* @__PURE__ */ new Set(["environment"]));
        if (runInjectorInitializers) {
          this.resolveInjectorInitializers();
        }
      }
      resolveInjectorInitializers() {
        this._r3Injector.resolveInjectorInitializers();
        this.instance = this._r3Injector.get(this.ngModuleType);
      }
      get injector() {
        return this._r3Injector;
      }
      destroy() {
        ngDevMode && assertDefined(this.destroyCbs, "NgModule already destroyed");
        const injector = this._r3Injector;
        !injector.destroyed && injector.destroy();
        this.destroyCbs.forEach((fn) => fn());
        this.destroyCbs = null;
      }
      onDestroy(callback) {
        ngDevMode && assertDefined(this.destroyCbs, "NgModule already destroyed");
        this.destroyCbs.push(callback);
      }
    };
    NgModuleFactory2 = class extends NgModuleFactory$1 {
      moduleType;
      constructor(moduleType) {
        super();
        this.moduleType = moduleType;
      }
      create(parentInjector) {
        return new NgModuleRef2(this.moduleType, parentInjector, []);
      }
    };
    EnvironmentNgModuleRefAdapter = class extends NgModuleRef$1 {
      injector;
      componentFactoryResolver = new ComponentFactoryResolver2(this);
      instance = null;
      constructor(config3) {
        super();
        const injector = new R3Injector([
          ...config3.providers,
          { provide: NgModuleRef$1, useValue: this },
          { provide: ComponentFactoryResolver$1, useValue: this.componentFactoryResolver }
        ], config3.parent || getNullInjector(), config3.debugName, /* @__PURE__ */ new Set(["environment"]));
        this.injector = injector;
        if (config3.runEnvironmentInitializers) {
          injector.resolveInjectorInitializers();
        }
      }
      destroy() {
        this.injector.destroy();
      }
      onDestroy(callback) {
        this.injector.onDestroy(callback);
      }
    };
    StandaloneService = class _StandaloneService {
      _injector;
      cachedInjectors = /* @__PURE__ */ new Map();
      constructor(_injector) {
        this._injector = _injector;
      }
      getOrCreateStandaloneInjector(componentDef) {
        if (!componentDef.standalone) {
          return null;
        }
        if (!this.cachedInjectors.has(componentDef)) {
          const providers = internalImportProvidersFrom(false, componentDef.type);
          const standaloneInjector = providers.length > 0 ? createEnvironmentInjector([providers], this._injector, `Standalone[${componentDef.type.name}]`) : null;
          this.cachedInjectors.set(componentDef, standaloneInjector);
        }
        return this.cachedInjectors.get(componentDef);
      }
      ngOnDestroy() {
        try {
          for (const injector of this.cachedInjectors.values()) {
            if (injector !== null) {
              injector.destroy();
            }
          }
        } finally {
          this.cachedInjectors.clear();
        }
      }
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _StandaloneService,
          providedIn: "environment",
          factory: () => new _StandaloneService(\u0275\u0275inject(EnvironmentInjector))
        })
      );
    };
    GENERATED_COMP_IDS = /* @__PURE__ */ new Map();
    COPY_DIRECTIVE_FIELDS = [
      // The child class should use the providers of its parent.
      "providersResolver"
      // Not listed here are any fields which are handled by the `InheritDefinitionFeature`, such
      // as inputs, outputs, and host binding functions.
    ];
    COPY_COMPONENT_FIELDS = [
      // The child class should use the template function of its parent, including all template
      // semantics.
      "template",
      "decls",
      "consts",
      "vars",
      "onPush",
      "ngContentSelectors",
      // The child class should use the CSS styles of its parent, including all styling semantics.
      "styles",
      "encapsulation",
      // The child class should be checked by the runtime in the same way as its parent.
      "schemas"
    ];
    _locateOrCreateContainerAnchor = createContainerAnchorImpl;
    (function(DeferDependenciesLoadingState2) {
      DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["NOT_STARTED"] = 0] = "NOT_STARTED";
      DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["IN_PROGRESS"] = 1] = "IN_PROGRESS";
      DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["COMPLETE"] = 2] = "COMPLETE";
      DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["FAILED"] = 3] = "FAILED";
    })(DeferDependenciesLoadingState || (DeferDependenciesLoadingState = {}));
    MINIMUM_SLOT = 0;
    LOADING_AFTER_SLOT = 1;
    (function(DeferBlockState2) {
      DeferBlockState2[DeferBlockState2["Placeholder"] = 0] = "Placeholder";
      DeferBlockState2[DeferBlockState2["Loading"] = 1] = "Loading";
      DeferBlockState2[DeferBlockState2["Complete"] = 2] = "Complete";
      DeferBlockState2[DeferBlockState2["Error"] = 3] = "Error";
    })(DeferBlockState || (DeferBlockState = {}));
    (function(DeferBlockInternalState2) {
      DeferBlockInternalState2[DeferBlockInternalState2["Initial"] = -1] = "Initial";
    })(DeferBlockInternalState || (DeferBlockInternalState = {}));
    NEXT_DEFER_BLOCK_STATE = 0;
    DEFER_BLOCK_STATE = 1;
    STATE_IS_FROZEN_UNTIL = 2;
    LOADING_AFTER_CLEANUP_FN = 3;
    TRIGGER_CLEANUP_FNS = 4;
    PREFETCH_TRIGGER_CLEANUP_FNS = 5;
    SSR_UNIQUE_ID = 6;
    SSR_BLOCK_STATE = 7;
    ON_COMPLETE_FNS = 8;
    HYDRATE_TRIGGER_CLEANUP_FNS = 9;
    (function(DeferBlockBehavior2) {
      DeferBlockBehavior2[DeferBlockBehavior2["Manual"] = 0] = "Manual";
      DeferBlockBehavior2[DeferBlockBehavior2["Playthrough"] = 1] = "Playthrough";
    })(DeferBlockBehavior || (DeferBlockBehavior = {}));
    (function(TracingAction2) {
      TracingAction2[TracingAction2["CHANGE_DETECTION"] = 0] = "CHANGE_DETECTION";
      TracingAction2[TracingAction2["AFTER_NEXT_RENDER"] = 1] = "AFTER_NEXT_RENDER";
    })(TracingAction || (TracingAction = {}));
    TracingService = new InjectionToken(ngDevMode ? "TracingService" : "");
    SCHEDULE_IN_ROOT_ZONE_DEFAULT = false;
    EventEmitter_ = class extends Subject {
      // tslint:disable-next-line:require-internal-with-underscore
      __isAsync;
      destroyRef = void 0;
      pendingTasks = void 0;
      constructor(isAsync = false) {
        super();
        this.__isAsync = isAsync;
        if (isInInjectionContext()) {
          this.destroyRef = inject2(DestroyRef, { optional: true }) ?? void 0;
          this.pendingTasks = inject2(PendingTasksInternal, { optional: true }) ?? void 0;
        }
      }
      emit(value) {
        const prevConsumer = setActiveConsumer(null);
        try {
          super.next(value);
        } finally {
          setActiveConsumer(prevConsumer);
        }
      }
      subscribe(observerOrNext, error, complete) {
        let nextFn = observerOrNext;
        let errorFn = error || (() => null);
        let completeFn = complete;
        if (observerOrNext && typeof observerOrNext === "object") {
          const observer = observerOrNext;
          nextFn = observer.next?.bind(observer);
          errorFn = observer.error?.bind(observer);
          completeFn = observer.complete?.bind(observer);
        }
        if (this.__isAsync) {
          errorFn = this.wrapInTimeout(errorFn);
          if (nextFn) {
            nextFn = this.wrapInTimeout(nextFn);
          }
          if (completeFn) {
            completeFn = this.wrapInTimeout(completeFn);
          }
        }
        const sink = super.subscribe({ next: nextFn, error: errorFn, complete: completeFn });
        if (observerOrNext instanceof Subscription) {
          observerOrNext.add(sink);
        }
        return sink;
      }
      wrapInTimeout(fn) {
        return (value) => {
          const taskId = this.pendingTasks?.add();
          setTimeout(() => {
            try {
              fn(value);
            } finally {
              if (taskId !== void 0) {
                this.pendingTasks?.remove(taskId);
              }
            }
          });
        };
      }
    };
    EventEmitter = EventEmitter_;
    AsyncStackTaggingZoneSpec = class {
      createTask;
      constructor(namePrefix, consoleAsyncStackTaggingImpl = console) {
        this.name = "asyncStackTagging for " + namePrefix;
        this.createTask = consoleAsyncStackTaggingImpl?.createTask ?? (() => null);
      }
      // ZoneSpec implementation below.
      name;
      onScheduleTask(delegate, _current, target, task) {
        task.consoleTask = this.createTask(`Zone - ${task.source || task.type}`);
        return delegate.scheduleTask(target, task);
      }
      onInvokeTask(delegate, _currentZone, targetZone, task, applyThis, applyArgs) {
        let ret;
        if (task.consoleTask) {
          ret = task.consoleTask.run(() => delegate.invokeTask(targetZone, task, applyThis, applyArgs));
        } else {
          ret = delegate.invokeTask(targetZone, task, applyThis, applyArgs);
        }
        return ret;
      }
    };
    isAngularZoneProperty = "isAngularZone";
    angularZoneInstanceIdProperty = isAngularZoneProperty + "_ID";
    ngZoneInstanceId = 0;
    NgZone = class _NgZone {
      hasPendingMacrotasks = false;
      hasPendingMicrotasks = false;
      /**
       * Whether there are no outstanding microtasks or macrotasks.
       */
      isStable = true;
      /**
       * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
       */
      onUnstable = new EventEmitter(false);
      /**
       * Notifies when there is no more microtasks enqueued in the current VM Turn.
       * This is a hint for Angular to do change detection, which may enqueue more microtasks.
       * For this reason this event can fire multiple times per VM Turn.
       */
      onMicrotaskEmpty = new EventEmitter(false);
      /**
       * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
       * implies we are about to relinquish VM turn.
       * This event gets called just once.
       */
      onStable = new EventEmitter(false);
      /**
       * Notifies that an error has been delivered.
       */
      onError = new EventEmitter(false);
      constructor(options) {
        const { enableLongStackTrace = false, shouldCoalesceEventChangeDetection = false, shouldCoalesceRunChangeDetection = false, scheduleInRootZone = SCHEDULE_IN_ROOT_ZONE_DEFAULT } = options;
        if (typeof Zone == "undefined") {
          throw new RuntimeError(908, ngDevMode && `In this configuration Angular requires Zone.js`);
        }
        Zone.assertZonePatched();
        const self2 = this;
        self2._nesting = 0;
        self2._outer = self2._inner = Zone.current;
        if (ngDevMode) {
          self2._inner = self2._inner.fork(new AsyncStackTaggingZoneSpec("Angular"));
        }
        if (Zone["TaskTrackingZoneSpec"]) {
          self2._inner = self2._inner.fork(new Zone["TaskTrackingZoneSpec"]());
        }
        if (enableLongStackTrace && Zone["longStackTraceZoneSpec"]) {
          self2._inner = self2._inner.fork(Zone["longStackTraceZoneSpec"]);
        }
        self2.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;
        self2.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;
        self2.callbackScheduled = false;
        self2.scheduleInRootZone = scheduleInRootZone;
        forkInnerZoneWithAngularBehavior(self2);
      }
      /**
        This method checks whether the method call happens within an Angular Zone instance.
      */
      static isInAngularZone() {
        return typeof Zone !== "undefined" && Zone.current.get(isAngularZoneProperty) === true;
      }
      /**
        Assures that the method is called within the Angular Zone, otherwise throws an error.
      */
      static assertInAngularZone() {
        if (!_NgZone.isInAngularZone()) {
          throw new RuntimeError(909, ngDevMode && "Expected to be in Angular Zone, but it is not!");
        }
      }
      /**
        Assures that the method is called outside of the Angular Zone, otherwise throws an error.
      */
      static assertNotInAngularZone() {
        if (_NgZone.isInAngularZone()) {
          throw new RuntimeError(909, ngDevMode && "Expected to not be in Angular Zone, but it is!");
        }
      }
      /**
       * Executes the `fn` function synchronously within the Angular zone and returns value returned by
       * the function.
       *
       * Running functions via `run` allows you to reenter Angular zone from a task that was executed
       * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
       *
       * Any future tasks or microtasks scheduled from within this function will continue executing from
       * within the Angular zone.
       *
       * If a synchronous error happens it will be rethrown and not reported via `onError`.
       */
      run(fn, applyThis, applyArgs) {
        return this._inner.run(fn, applyThis, applyArgs);
      }
      /**
       * Executes the `fn` function synchronously within the Angular zone as a task and returns value
       * returned by the function.
       *
       * Running functions via `runTask` allows you to reenter Angular zone from a task that was executed
       * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
       *
       * Any future tasks or microtasks scheduled from within this function will continue executing from
       * within the Angular zone.
       *
       * If a synchronous error happens it will be rethrown and not reported via `onError`.
       */
      runTask(fn, applyThis, applyArgs, name2) {
        const zone = this._inner;
        const task = zone.scheduleEventTask("NgZoneEvent: " + name2, fn, EMPTY_PAYLOAD, noop2, noop2);
        try {
          return zone.runTask(task, applyThis, applyArgs);
        } finally {
          zone.cancelTask(task);
        }
      }
      /**
       * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
       * rethrown.
       */
      runGuarded(fn, applyThis, applyArgs) {
        return this._inner.runGuarded(fn, applyThis, applyArgs);
      }
      /**
       * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
       * the function.
       *
       * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do
       * work that
       * doesn't trigger Angular change-detection or is subject to Angular's error handling.
       *
       * Any future tasks or microtasks scheduled from within this function will continue executing from
       * outside of the Angular zone.
       *
       * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
       */
      runOutsideAngular(fn) {
        return this._outer.run(fn);
      }
    };
    EMPTY_PAYLOAD = {};
    NoopNgZone = class {
      hasPendingMicrotasks = false;
      hasPendingMacrotasks = false;
      isStable = true;
      onUnstable = new EventEmitter();
      onMicrotaskEmpty = new EventEmitter();
      onStable = new EventEmitter();
      onError = new EventEmitter();
      run(fn, applyThis, applyArgs) {
        return fn.apply(applyThis, applyArgs);
      }
      runGuarded(fn, applyThis, applyArgs) {
        return fn.apply(applyThis, applyArgs);
      }
      runOutsideAngular(fn) {
        return fn();
      }
      runTask(fn, applyThis, applyArgs, name2) {
        return fn.apply(applyThis, applyArgs);
      }
    };
    AfterRenderManager = class _AfterRenderManager {
      impl = null;
      execute() {
        this.impl?.execute();
      }
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _AfterRenderManager,
          providedIn: "root",
          factory: () => new _AfterRenderManager()
        })
      );
    };
    AFTER_RENDER_PHASES = /* @__PURE__ */ (() => [
      0,
      1,
      2,
      3
    ])();
    AfterRenderImpl = class _AfterRenderImpl {
      ngZone = inject2(NgZone);
      scheduler = inject2(ChangeDetectionScheduler);
      errorHandler = inject2(ErrorHandler, { optional: true });
      /** Current set of active sequences. */
      sequences = /* @__PURE__ */ new Set();
      /** Tracks registrations made during the current set of executions. */
      deferredRegistrations = /* @__PURE__ */ new Set();
      /** Whether the `AfterRenderManager` is currently executing hooks. */
      executing = false;
      constructor() {
        inject2(TracingService, { optional: true });
      }
      /**
       * Run the sequence of phases of hooks, once through. As a result of executing some hooks, more
       * might be scheduled.
       */
      execute() {
        const hasSequencesToExecute = this.sequences.size > 0;
        if (hasSequencesToExecute) {
          profiler(
            16
            /* ProfilerEvent.AfterRenderHooksStart */
          );
        }
        this.executing = true;
        for (const phase of AFTER_RENDER_PHASES) {
          for (const sequence of this.sequences) {
            if (sequence.erroredOrDestroyed || !sequence.hooks[phase]) {
              continue;
            }
            try {
              sequence.pipelinedValue = this.ngZone.runOutsideAngular(() => this.maybeTrace(() => {
                const hookFn = sequence.hooks[phase];
                const value = hookFn(sequence.pipelinedValue);
                return value;
              }, sequence.snapshot));
            } catch (err) {
              sequence.erroredOrDestroyed = true;
              this.errorHandler?.handleError(err);
            }
          }
        }
        this.executing = false;
        for (const sequence of this.sequences) {
          sequence.afterRun();
          if (sequence.once) {
            this.sequences.delete(sequence);
            sequence.destroy();
          }
        }
        for (const sequence of this.deferredRegistrations) {
          this.sequences.add(sequence);
        }
        if (this.deferredRegistrations.size > 0) {
          this.scheduler.notify(
            7
            /* NotificationSource.RenderHook */
          );
        }
        this.deferredRegistrations.clear();
        if (hasSequencesToExecute) {
          profiler(
            17
            /* ProfilerEvent.AfterRenderHooksEnd */
          );
        }
      }
      register(sequence) {
        const { view } = sequence;
        if (view !== void 0) {
          (view[AFTER_RENDER_SEQUENCES_TO_ADD] ??= []).push(sequence);
          markAncestorsForTraversal(view);
          view[FLAGS] |= 8192;
        } else if (!this.executing) {
          this.addSequence(sequence);
        } else {
          this.deferredRegistrations.add(sequence);
        }
      }
      addSequence(sequence) {
        this.sequences.add(sequence);
        this.scheduler.notify(
          7
          /* NotificationSource.RenderHook */
        );
      }
      unregister(sequence) {
        if (this.executing && this.sequences.has(sequence)) {
          sequence.erroredOrDestroyed = true;
          sequence.pipelinedValue = void 0;
          sequence.once = true;
        } else {
          this.sequences.delete(sequence);
          this.deferredRegistrations.delete(sequence);
        }
      }
      maybeTrace(fn, snapshot) {
        return snapshot ? snapshot.run(TracingAction.AFTER_NEXT_RENDER, fn) : fn();
      }
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _AfterRenderImpl,
          providedIn: "root",
          factory: () => new _AfterRenderImpl()
        })
      );
    };
    AfterRenderSequence = class {
      impl;
      hooks;
      view;
      once;
      snapshot;
      /**
       * Whether this sequence errored or was destroyed during this execution, and hooks should no
       * longer run for it.
       */
      erroredOrDestroyed = false;
      /**
       * The value returned by the last hook execution (if any), ready to be pipelined into the next
       * one.
       */
      pipelinedValue = void 0;
      unregisterOnDestroy;
      constructor(impl, hooks, view, once, destroyRef, snapshot = null) {
        this.impl = impl;
        this.hooks = hooks;
        this.view = view;
        this.once = once;
        this.snapshot = snapshot;
        this.unregisterOnDestroy = destroyRef?.onDestroy(() => this.destroy());
      }
      afterRun() {
        this.erroredOrDestroyed = false;
        this.pipelinedValue = void 0;
        this.snapshot?.dispose();
        this.snapshot = null;
      }
      destroy() {
        this.impl.unregister(this);
        this.unregisterOnDestroy?.();
        const scheduled2 = this.view?.[AFTER_RENDER_SEQUENCES_TO_ADD];
        if (scheduled2) {
          this.view[AFTER_RENDER_SEQUENCES_TO_ADD] = scheduled2.filter((s) => s !== this);
        }
      }
    };
    _requestIdleCallback = () => typeof requestIdleCallback !== "undefined" ? requestIdleCallback : setTimeout;
    _cancelIdleCallback = () => typeof requestIdleCallback !== "undefined" ? cancelIdleCallback : clearTimeout;
    IdleScheduler = class _IdleScheduler {
      // Indicates whether current callbacks are being invoked.
      executingCallbacks = false;
      // Currently scheduled idle callback id.
      idleId = null;
      // Set of callbacks to be invoked next.
      current = /* @__PURE__ */ new Set();
      // Set of callbacks collected while invoking current set of callbacks.
      // Those callbacks are scheduled for the next idle period.
      deferred = /* @__PURE__ */ new Set();
      ngZone = inject2(NgZone);
      requestIdleCallbackFn = _requestIdleCallback().bind(globalThis);
      cancelIdleCallbackFn = _cancelIdleCallback().bind(globalThis);
      add(callback) {
        const target = this.executingCallbacks ? this.deferred : this.current;
        target.add(callback);
        if (this.idleId === null) {
          this.scheduleIdleCallback();
        }
      }
      remove(callback) {
        const { current, deferred } = this;
        current.delete(callback);
        deferred.delete(callback);
        if (current.size === 0 && deferred.size === 0) {
          this.cancelIdleCallback();
        }
      }
      scheduleIdleCallback() {
        const callback = () => {
          this.cancelIdleCallback();
          this.executingCallbacks = true;
          for (const callback2 of this.current) {
            callback2();
          }
          this.current.clear();
          this.executingCallbacks = false;
          if (this.deferred.size > 0) {
            for (const callback2 of this.deferred) {
              this.current.add(callback2);
            }
            this.deferred.clear();
            this.scheduleIdleCallback();
          }
        };
        this.idleId = this.requestIdleCallbackFn(() => this.ngZone.run(callback));
      }
      cancelIdleCallback() {
        if (this.idleId !== null) {
          this.cancelIdleCallbackFn(this.idleId);
          this.idleId = null;
        }
      }
      ngOnDestroy() {
        this.cancelIdleCallback();
        this.current.clear();
        this.deferred.clear();
      }
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _IdleScheduler,
          providedIn: "root",
          factory: () => new _IdleScheduler()
        })
      );
    };
    TimerScheduler = class _TimerScheduler {
      // Indicates whether current callbacks are being invoked.
      executingCallbacks = false;
      // Currently scheduled `setTimeout` id.
      timeoutId = null;
      // When currently scheduled timer would fire.
      invokeTimerAt = null;
      // List of callbacks to be invoked.
      // For each callback we also store a timestamp on when the callback
      // should be invoked. We store timestamps and callback functions
      // in a flat array to avoid creating new objects for each entry.
      // [timestamp1, callback1, timestamp2, callback2, ...]
      current = [];
      // List of callbacks collected while invoking current set of callbacks.
      // Those callbacks are added to the "current" queue at the end of
      // the current callback invocation. The shape of this list is the same
      // as the shape of the `current` list.
      deferred = [];
      add(delay, callback, ngZone) {
        const target = this.executingCallbacks ? this.deferred : this.current;
        this.addToQueue(target, Date.now() + delay, callback);
        this.scheduleTimer(ngZone);
      }
      remove(callback) {
        const { current, deferred } = this;
        const callbackIndex = this.removeFromQueue(current, callback);
        if (callbackIndex === -1) {
          this.removeFromQueue(deferred, callback);
        }
        if (current.length === 0 && deferred.length === 0) {
          this.clearTimeout();
        }
      }
      addToQueue(target, invokeAt, callback) {
        let insertAtIndex = target.length;
        for (let i = 0; i < target.length; i += 2) {
          const invokeQueuedCallbackAt = target[i];
          if (invokeQueuedCallbackAt > invokeAt) {
            insertAtIndex = i;
            break;
          }
        }
        arrayInsert2(target, insertAtIndex, invokeAt, callback);
      }
      removeFromQueue(target, callback) {
        let index = -1;
        for (let i = 0; i < target.length; i += 2) {
          const queuedCallback = target[i + 1];
          if (queuedCallback === callback) {
            index = i;
            break;
          }
        }
        if (index > -1) {
          arraySplice(target, index, 2);
        }
        return index;
      }
      scheduleTimer(ngZone) {
        const callback = () => {
          this.clearTimeout();
          this.executingCallbacks = true;
          const current = [...this.current];
          const now = Date.now();
          for (let i = 0; i < current.length; i += 2) {
            const invokeAt = current[i];
            const callback2 = current[i + 1];
            if (invokeAt <= now) {
              callback2();
            } else {
              break;
            }
          }
          let lastCallbackIndex = -1;
          for (let i = 0; i < this.current.length; i += 2) {
            const invokeAt = this.current[i];
            if (invokeAt <= now) {
              lastCallbackIndex = i + 1;
            } else {
              break;
            }
          }
          if (lastCallbackIndex >= 0) {
            arraySplice(this.current, 0, lastCallbackIndex + 1);
          }
          this.executingCallbacks = false;
          if (this.deferred.length > 0) {
            for (let i = 0; i < this.deferred.length; i += 2) {
              const invokeAt = this.deferred[i];
              const callback2 = this.deferred[i + 1];
              this.addToQueue(this.current, invokeAt, callback2);
            }
            this.deferred.length = 0;
          }
          this.scheduleTimer(ngZone);
        };
        const FRAME_DURATION_MS = 16;
        if (this.current.length > 0) {
          const now = Date.now();
          const invokeAt = this.current[0];
          if (this.timeoutId === null || // Reschedule a timer in case a queue contains an item with
          // an earlier timestamp and the delta is more than an average
          // frame duration.
          this.invokeTimerAt && this.invokeTimerAt - invokeAt > FRAME_DURATION_MS) {
            this.clearTimeout();
            const timeout = Math.max(invokeAt - now, FRAME_DURATION_MS);
            this.invokeTimerAt = invokeAt;
            this.timeoutId = ngZone.runOutsideAngular(() => {
              return setTimeout(() => ngZone.run(callback), timeout);
            });
          }
        }
      }
      clearTimeout() {
        if (this.timeoutId !== null) {
          clearTimeout(this.timeoutId);
          this.timeoutId = null;
        }
      }
      ngOnDestroy() {
        this.clearTimeout();
        this.current.length = 0;
        this.deferred.length = 0;
      }
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _TimerScheduler,
          providedIn: "root",
          factory: () => new _TimerScheduler()
        })
      );
    };
    CachedInjectorService = class _CachedInjectorService {
      cachedInjectors = /* @__PURE__ */ new Map();
      getOrCreateInjector(key, parentInjector, providers, debugName) {
        if (!this.cachedInjectors.has(key)) {
          const injector = providers.length > 0 ? createEnvironmentInjector(providers, parentInjector, debugName) : null;
          this.cachedInjectors.set(key, injector);
        }
        return this.cachedInjectors.get(key);
      }
      ngOnDestroy() {
        try {
          for (const injector of this.cachedInjectors.values()) {
            if (injector !== null) {
              injector.destroy();
            }
          }
        } finally {
          this.cachedInjectors.clear();
        }
      }
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _CachedInjectorService,
          providedIn: "environment",
          factory: () => new _CachedInjectorService()
        })
      );
    };
    DEFER_BLOCK_DEPENDENCY_INTERCEPTOR = /* @__PURE__ */ new InjectionToken("DEFER_BLOCK_DEPENDENCY_INTERCEPTOR");
    DEFER_BLOCK_CONFIG = new InjectionToken(ngDevMode ? "DEFER_BLOCK_CONFIG" : "");
    applyDeferBlockStateWithSchedulingImpl = null;
    Console = class _Console {
      log(message) {
        console.log(message);
      }
      // Note: for reporting errors use `DOM.logError()` as it is platform specific
      warn(message) {
        console.warn(message);
      }
      static \u0275fac = function Console_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Console)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _Console, factory: _Console.\u0275fac, providedIn: "platform" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Console, [{
        type: Injectable,
        args: [{ providedIn: "platform" }]
      }], null, null);
    })();
    DIDebugData = class {
      resolverToTokenToDependencies = /* @__PURE__ */ new WeakMap();
      resolverToProviders = /* @__PURE__ */ new WeakMap();
      resolverToEffects = /* @__PURE__ */ new WeakMap();
      standaloneInjectorToComponent = /* @__PURE__ */ new WeakMap();
      reset() {
        this.resolverToTokenToDependencies = /* @__PURE__ */ new WeakMap();
        this.resolverToProviders = /* @__PURE__ */ new WeakMap();
        this.standaloneInjectorToComponent = /* @__PURE__ */ new WeakMap();
      }
    };
    frameworkDIDebugData = new DIDebugData();
    signalDebugMap = /* @__PURE__ */ new WeakMap();
    counter$1 = 0;
    changeDetectionRuns = 0;
    changeDetectionSyncRuns = 0;
    counter = 0;
    eventsStack = [];
    chromeDevToolsInjectorProfiler = (event) => {
      const eventType = event.type;
      if (eventType === 4) {
        measureStart(
          100
          /* ProfilerDIEvent.InjectorToCreateInstanceEvent */
        );
      } else if (eventType === 1) {
        const token = event.context.token;
        measureEnd(100, getProviderTokenMeasureName(token), "tertiary-dark");
      }
    };
    devToolsProfiler = (event, instance, eventFn) => {
      switch (event) {
        case 8:
        case 10:
        case 12:
        case 14:
        case 16:
        case 18:
        case 20:
        case 22:
        case 0:
        case 4:
        case 2:
        case 24:
        case 6: {
          measureStart(event);
          break;
        }
        case 9: {
          measureEnd(8, "Bootstrap application", "primary-dark");
          break;
        }
        case 11: {
          measureEnd(10, "Bootstrap component", "primary-dark");
          break;
        }
        case 13: {
          changeDetectionSyncRuns = 0;
          measureEnd(12, "Change detection " + changeDetectionRuns++, "primary-dark");
          break;
        }
        case 15: {
          measureEnd(14, "Synchronization " + changeDetectionSyncRuns++, "primary");
          break;
        }
        case 17: {
          measureEnd(16, "After render hooks", "primary");
          break;
        }
        case 19: {
          const typeName2 = getComponentMeasureName(instance);
          measureEnd(18, typeName2, "primary-light");
          break;
        }
        case 21: {
          measureEnd(20, "Defer block", "primary-dark");
          break;
        }
        case 23: {
          measureEnd(22, "Dynamic component creation", "primary-dark");
          break;
        }
        case 3: {
          measureEnd(2, stringifyForError(eventFn) + " (update)", "secondary-dark");
          break;
        }
        case 1: {
          measureEnd(0, stringifyForError(eventFn) + " (create)", "secondary");
          break;
        }
        case 25: {
          measureEnd(24, "HostBindings", "secondary-dark");
          break;
        }
        case 5: {
          const typeName2 = getComponentMeasureName(instance);
          measureEnd(4, `${typeName2}:${stringifyForError(eventFn)}`, "tertiary");
          break;
        }
        case 7: {
          measureEnd(6, stringifyForError(eventFn), "tertiary-light");
          break;
        }
        default: {
          throw new Error("Unexpected profiling event type: " + event);
        }
      }
    };
    GLOBAL_PUBLISH_EXPANDO_KEY = "ng";
    globalUtilsFunctions = {
      /**
       * Warning: functions that start with `` are considered *INTERNAL* and should not be relied upon
       * in application's code. The contract of those functions might be changed in any release and/or a
       * function can be removed completely.
       */
      "\u0275getDependenciesFromInjectable": getDependenciesFromInjectable,
      "\u0275getInjectorProviders": getInjectorProviders,
      "\u0275getInjectorResolutionPath": getInjectorResolutionPath,
      "\u0275getInjectorMetadata": getInjectorMetadata,
      "\u0275setProfiler": setProfiler,
      "\u0275getSignalGraph": getSignalGraph,
      "\u0275getDeferBlocks": getDeferBlocks,
      "getDirectiveMetadata": getDirectiveMetadata$1,
      "getComponent": getComponent,
      "getContext": getContext,
      "getListeners": getListeners,
      "getOwningComponent": getOwningComponent,
      "getHostElement": getHostElement,
      "getInjector": getInjector,
      "getRootComponents": getRootComponents,
      "getDirectives": getDirectives,
      "applyChanges": applyChanges,
      "isSignal": isSignal,
      "enableProfiling": enableProfiling
    };
    _published = false;
    TESTABILITY = new InjectionToken("");
    TESTABILITY_GETTER = new InjectionToken("");
    Testability = class _Testability {
      _ngZone;
      registry;
      _isZoneStable = true;
      _callbacks = [];
      _taskTrackingZone = null;
      _destroyRef;
      constructor(_ngZone, registry, testabilityGetter) {
        this._ngZone = _ngZone;
        this.registry = registry;
        if (isInInjectionContext()) {
          this._destroyRef = inject2(DestroyRef, { optional: true }) ?? void 0;
        }
        if (!_testabilityGetter) {
          setTestabilityGetter(testabilityGetter);
          testabilityGetter.addToWindow(registry);
        }
        this._watchAngularEvents();
        _ngZone.run(() => {
          this._taskTrackingZone = typeof Zone == "undefined" ? null : Zone.current.get("TaskTrackingZone");
        });
      }
      _watchAngularEvents() {
        const onUnstableSubscription = this._ngZone.onUnstable.subscribe({
          next: () => {
            this._isZoneStable = false;
          }
        });
        const onStableSubscription = this._ngZone.runOutsideAngular(() => this._ngZone.onStable.subscribe({
          next: () => {
            NgZone.assertNotInAngularZone();
            queueMicrotask(() => {
              this._isZoneStable = true;
              this._runCallbacksIfReady();
            });
          }
        }));
        this._destroyRef?.onDestroy(() => {
          onUnstableSubscription.unsubscribe();
          onStableSubscription.unsubscribe();
        });
      }
      /**
       * Whether an associated application is stable
       */
      isStable() {
        return this._isZoneStable && !this._ngZone.hasPendingMacrotasks;
      }
      _runCallbacksIfReady() {
        if (this.isStable()) {
          queueMicrotask(() => {
            while (this._callbacks.length !== 0) {
              let cb = this._callbacks.pop();
              clearTimeout(cb.timeoutId);
              cb.doneCb();
            }
          });
        } else {
          let pending = this.getPendingTasks();
          this._callbacks = this._callbacks.filter((cb) => {
            if (cb.updateCb && cb.updateCb(pending)) {
              clearTimeout(cb.timeoutId);
              return false;
            }
            return true;
          });
        }
      }
      getPendingTasks() {
        if (!this._taskTrackingZone) {
          return [];
        }
        return this._taskTrackingZone.macroTasks.map((t2) => {
          return {
            source: t2.source,
            // From TaskTrackingZone:
            // https://github.com/angular/zone.js/blob/master/lib/zone-spec/task-tracking.ts#L40
            creationLocation: t2.creationLocation,
            data: t2.data
          };
        });
      }
      addCallback(cb, timeout, updateCb) {
        let timeoutId = -1;
        if (timeout && timeout > 0) {
          timeoutId = setTimeout(() => {
            this._callbacks = this._callbacks.filter((cb2) => cb2.timeoutId !== timeoutId);
            cb();
          }, timeout);
        }
        this._callbacks.push({ doneCb: cb, timeoutId, updateCb });
      }
      /**
       * Wait for the application to be stable with a timeout. If the timeout is reached before that
       * happens, the callback receives a list of the macro tasks that were pending, otherwise null.
       *
       * @param doneCb The callback to invoke when Angular is stable or the timeout expires
       *    whichever comes first.
       * @param timeout Optional. The maximum time to wait for Angular to become stable. If not
       *    specified, whenStable() will wait forever.
       * @param updateCb Optional. If specified, this callback will be invoked whenever the set of
       *    pending macrotasks changes. If this callback returns true doneCb will not be invoked
       *    and no further updates will be issued.
       */
      whenStable(doneCb, timeout, updateCb) {
        if (updateCb && !this._taskTrackingZone) {
          throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
        }
        this.addCallback(doneCb, timeout, updateCb);
        this._runCallbacksIfReady();
      }
      /**
       * Registers an application with a testability hook so that it can be tracked.
       * @param token token of application, root element
       *
       * @internal
       */
      registerApplication(token) {
        this.registry.registerApplication(token, this);
      }
      /**
       * Unregisters an application.
       * @param token token of application, root element
       *
       * @internal
       */
      unregisterApplication(token) {
        this.registry.unregisterApplication(token);
      }
      /**
       * Find providers by name
       * @param using The root element to search from
       * @param provider The name of binding variable
       * @param exactMatch Whether using exactMatch
       */
      findProviders(using, provider, exactMatch) {
        return [];
      }
      static \u0275fac = function Testability_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Testability)(\u0275\u0275inject(NgZone), \u0275\u0275inject(TestabilityRegistry), \u0275\u0275inject(TESTABILITY_GETTER));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _Testability, factory: _Testability.\u0275fac });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Testability, [{
        type: Injectable
      }], () => [{ type: NgZone }, { type: TestabilityRegistry }, { type: void 0, decorators: [{
        type: Inject,
        args: [TESTABILITY_GETTER]
      }] }], null);
    })();
    TestabilityRegistry = class _TestabilityRegistry {
      /** @internal */
      _applications = /* @__PURE__ */ new Map();
      /**
       * Registers an application with a testability hook so that it can be tracked
       * @param token token of application, root element
       * @param testability Testability hook
       */
      registerApplication(token, testability) {
        this._applications.set(token, testability);
      }
      /**
       * Unregisters an application.
       * @param token token of application, root element
       */
      unregisterApplication(token) {
        this._applications.delete(token);
      }
      /**
       * Unregisters all applications
       */
      unregisterAllApplications() {
        this._applications.clear();
      }
      /**
       * Get a testability hook associated with the application
       * @param elem root element
       */
      getTestability(elem) {
        return this._applications.get(elem) || null;
      }
      /**
       * Get all registered testabilities
       */
      getAllTestabilities() {
        return Array.from(this._applications.values());
      }
      /**
       * Get all registered applications(root elements)
       */
      getAllRootElements() {
        return Array.from(this._applications.keys());
      }
      /**
       * Find testability of a node in the Tree
       * @param elem node
       * @param findInAncestors whether finding testability in ancestors if testability was not found in
       * current node
       */
      findTestabilityInTree(elem, findInAncestors = true) {
        return _testabilityGetter?.findTestabilityInTree(this, elem, findInAncestors) ?? null;
      }
      static \u0275fac = function TestabilityRegistry_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _TestabilityRegistry)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _TestabilityRegistry, factory: _TestabilityRegistry.\u0275fac, providedIn: "platform" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TestabilityRegistry, [{
        type: Injectable,
        args: [{ providedIn: "platform" }]
      }], null, null);
    })();
    APP_INITIALIZER = new InjectionToken(ngDevMode ? "Application Initializer" : "");
    ApplicationInitStatus = class _ApplicationInitStatus {
      // Using non null assertion, these fields are defined below
      // within the `new Promise` callback (synchronously).
      resolve;
      reject;
      initialized = false;
      done = false;
      donePromise = new Promise((res, rej) => {
        this.resolve = res;
        this.reject = rej;
      });
      appInits = inject2(APP_INITIALIZER, { optional: true }) ?? [];
      injector = inject2(Injector);
      constructor() {
        if ((typeof ngDevMode === "undefined" || ngDevMode) && !Array.isArray(this.appInits)) {
          throw new RuntimeError(-209, `Unexpected type of the \`APP_INITIALIZER\` token value (expected an array, but got ${typeof this.appInits}). Please check that the \`APP_INITIALIZER\` token is configured as a \`multi: true\` provider.`);
        }
      }
      /** @internal */
      runInitializers() {
        if (this.initialized) {
          return;
        }
        const asyncInitPromises = [];
        for (const appInits of this.appInits) {
          const initResult = runInInjectionContext(this.injector, appInits);
          if (isPromise2(initResult)) {
            asyncInitPromises.push(initResult);
          } else if (isSubscribable(initResult)) {
            const observableAsPromise = new Promise((resolve, reject) => {
              initResult.subscribe({ complete: resolve, error: reject });
            });
            asyncInitPromises.push(observableAsPromise);
          }
        }
        const complete = () => {
          this.done = true;
          this.resolve();
        };
        Promise.all(asyncInitPromises).then(() => {
          complete();
        }).catch((e) => {
          this.reject(e);
        });
        if (asyncInitPromises.length === 0) {
          complete();
        }
        this.initialized = true;
      }
      static \u0275fac = function ApplicationInitStatus_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ApplicationInitStatus)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ApplicationInitStatus, factory: _ApplicationInitStatus.\u0275fac, providedIn: "root" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationInitStatus, [{
        type: Injectable,
        args: [{ providedIn: "root" }]
      }], () => [], null);
    })();
    APP_BOOTSTRAP_LISTENER = new InjectionToken(ngDevMode ? "appBootstrapListener" : "");
    MAXIMUM_REFRESH_RERUNS = 10;
    ApplicationRef = class _ApplicationRef {
      /** @internal */
      _runningTick = false;
      _destroyed = false;
      _destroyListeners = [];
      /** @internal */
      _views = [];
      internalErrorHandler = inject2(INTERNAL_APPLICATION_ERROR_HANDLER);
      afterRenderManager = inject2(AfterRenderManager);
      zonelessEnabled = inject2(ZONELESS_ENABLED);
      rootEffectScheduler = inject2(EffectScheduler);
      /**
       * Current dirty state of the application across a number of dimensions (views, afterRender hooks,
       * etc).
       *
       * A flag set here means that `tick()` will attempt to resolve the dirtiness when executed.
       *
       * @internal
       */
      dirtyFlags = 0;
      /**
       * Most recent snapshot from the `TracingService`, if any.
       *
       * This snapshot attempts to capture the context when `tick()` was first
       * scheduled. It then runs wrapped in this context.
       *
       * @internal
       */
      tracingSnapshot = null;
      // Needed for ComponentFixture temporarily during migration of autoDetect behavior
      // Eventually the hostView of the fixture should just attach to ApplicationRef.
      allTestViews = /* @__PURE__ */ new Set();
      autoDetectTestViews = /* @__PURE__ */ new Set();
      includeAllTestViews = false;
      /** @internal */
      afterTick = new Subject();
      /** @internal */
      get allViews() {
        return [
          ...(this.includeAllTestViews ? this.allTestViews : this.autoDetectTestViews).keys(),
          ...this._views
        ];
      }
      /**
       * Indicates whether this instance was destroyed.
       */
      get destroyed() {
        return this._destroyed;
      }
      /**
       * Get a list of component types registered to this application.
       * This list is populated even before the component is created.
       */
      componentTypes = [];
      /**
       * Get a list of components registered to this application.
       */
      components = [];
      internalPendingTask = inject2(PendingTasksInternal);
      /**
       * Returns an Observable that indicates when the application is stable or unstable.
       */
      get isStable() {
        return this.internalPendingTask.hasPendingTasksObservable.pipe(map((pending) => !pending));
      }
      constructor() {
        inject2(TracingService, { optional: true });
      }
      /**
       * @returns A promise that resolves when the application becomes stable
       */
      whenStable() {
        let subscription;
        return new Promise((resolve) => {
          subscription = this.isStable.subscribe({
            next: (stable) => {
              if (stable) {
                resolve();
              }
            }
          });
        }).finally(() => {
          subscription.unsubscribe();
        });
      }
      _injector = inject2(EnvironmentInjector);
      _rendererFactory = null;
      /**
       * The `EnvironmentInjector` used to create this application.
       */
      get injector() {
        return this._injector;
      }
      /**
       * Bootstrap a component onto the element identified by its selector or, optionally, to a
       * specified element.
       *
       * @usageNotes
       * ### Bootstrap process
       *
       * When bootstrapping a component, Angular mounts it onto a target DOM element
       * and kicks off automatic change detection. The target DOM element can be
       * provided using the `rootSelectorOrNode` argument.
       *
       * If the target DOM element is not provided, Angular tries to find one on a page
       * using the `selector` of the component that is being bootstrapped
       * (first matched element is used).
       *
       * ### Example
       *
       * Generally, we define the component to bootstrap in the `bootstrap` array of `NgModule`,
       * but it requires us to know the component while writing the application code.
       *
       * Imagine a situation where we have to wait for an API call to decide about the component to
       * bootstrap. We can use the `ngDoBootstrap` hook of the `NgModule` and call this method to
       * dynamically bootstrap a component.
       *
       * {@example core/ts/platform/platform.ts region='componentSelector'}
       *
       * Optionally, a component can be mounted onto a DOM element that does not match the
       * selector of the bootstrapped component.
       *
       * In the following example, we are providing a CSS selector to match the target element.
       *
       * {@example core/ts/platform/platform.ts region='cssSelector'}
       *
       * While in this example, we are providing reference to a DOM node.
       *
       * {@example core/ts/platform/platform.ts region='domNode'}
       */
      bootstrap(componentOrFactory, rootSelectorOrNode) {
        return this.bootstrapImpl(componentOrFactory, rootSelectorOrNode);
      }
      bootstrapImpl(componentOrFactory, rootSelectorOrNode, injector = Injector.NULL) {
        const ngZone = this._injector.get(NgZone);
        return ngZone.run(() => {
          profiler(
            10
            /* ProfilerEvent.BootstrapComponentStart */
          );
          (typeof ngDevMode === "undefined" || ngDevMode) && warnIfDestroyed(this._destroyed);
          const isComponentFactory = componentOrFactory instanceof ComponentFactory$1;
          const initStatus = this._injector.get(ApplicationInitStatus);
          if (!initStatus.done) {
            let errorMessage = "";
            if (typeof ngDevMode === "undefined" || ngDevMode) {
              const standalone = !isComponentFactory && isStandalone(componentOrFactory);
              errorMessage = "Cannot bootstrap as there are still asynchronous initializers running." + (standalone ? "" : " Bootstrap components in the `ngDoBootstrap` method of the root module.");
            }
            throw new RuntimeError(405, errorMessage);
          }
          let componentFactory;
          if (isComponentFactory) {
            componentFactory = componentOrFactory;
          } else {
            const resolver = this._injector.get(ComponentFactoryResolver$1);
            componentFactory = resolver.resolveComponentFactory(componentOrFactory);
          }
          this.componentTypes.push(componentFactory.componentType);
          const ngModule = isBoundToModule(componentFactory) ? void 0 : this._injector.get(NgModuleRef$1);
          const selectorOrNode = rootSelectorOrNode || componentFactory.selector;
          const compRef = componentFactory.create(injector, [], selectorOrNode, ngModule);
          const nativeElement = compRef.location.nativeElement;
          const testability = compRef.injector.get(TESTABILITY, null);
          testability?.registerApplication(nativeElement);
          compRef.onDestroy(() => {
            this.detachView(compRef.hostView);
            remove(this.components, compRef);
            testability?.unregisterApplication(nativeElement);
          });
          this._loadComponent(compRef);
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            const _console = this._injector.get(Console);
            _console.log(`Angular is running in development mode.`);
          }
          profiler(11, compRef);
          return compRef;
        });
      }
      /**
       * Invoke this method to explicitly process change detection and its side-effects.
       *
       * In development mode, `tick()` also performs a second change detection cycle to ensure that no
       * further changes are detected. If additional changes are picked up during this second cycle,
       * bindings in the app have side-effects that cannot be resolved in a single change detection
       * pass.
       * In this case, Angular throws an error, since an Angular application can only have one change
       * detection pass during which all change detection must complete.
       */
      tick() {
        if (!this.zonelessEnabled) {
          this.dirtyFlags |= 1;
        }
        this._tick();
      }
      /** @internal */
      _tick() {
        profiler(
          12
          /* ProfilerEvent.ChangeDetectionStart */
        );
        if (this.tracingSnapshot !== null) {
          this.tracingSnapshot.run(TracingAction.CHANGE_DETECTION, this.tickImpl);
        } else {
          this.tickImpl();
        }
      }
      tickImpl = () => {
        (typeof ngDevMode === "undefined" || ngDevMode) && warnIfDestroyed(this._destroyed);
        if (this._runningTick) {
          throw new RuntimeError(101, ngDevMode && "ApplicationRef.tick is called recursively");
        }
        const prevConsumer = setActiveConsumer(null);
        try {
          this._runningTick = true;
          this.synchronize();
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            for (let view of this.allViews) {
              view.checkNoChanges();
            }
          }
        } finally {
          this._runningTick = false;
          this.tracingSnapshot?.dispose();
          this.tracingSnapshot = null;
          setActiveConsumer(prevConsumer);
          this.afterTick.next();
          profiler(
            13
            /* ProfilerEvent.ChangeDetectionEnd */
          );
        }
      };
      /**
       * Performs the core work of synchronizing the application state with the UI, resolving any
       * pending dirtiness (potentially in a loop).
       */
      synchronize() {
        if (this._rendererFactory === null && !this._injector.destroyed) {
          this._rendererFactory = this._injector.get(RendererFactory2, null, { optional: true });
        }
        let runs = 0;
        while (this.dirtyFlags !== 0 && runs++ < MAXIMUM_REFRESH_RERUNS) {
          profiler(
            14
            /* ProfilerEvent.ChangeDetectionSyncStart */
          );
          this.synchronizeOnce();
          profiler(
            15
            /* ProfilerEvent.ChangeDetectionSyncEnd */
          );
        }
        if ((typeof ngDevMode === "undefined" || ngDevMode) && runs >= MAXIMUM_REFRESH_RERUNS) {
          throw new RuntimeError(103, ngDevMode && "Infinite change detection while refreshing application views. Ensure views are not calling `markForCheck` on every template execution or that afterRender hooks always mark views for check.");
        }
      }
      /**
       * Perform a single synchronization pass.
       */
      synchronizeOnce() {
        if (this.dirtyFlags & 16) {
          this.dirtyFlags &= ~16;
          this.rootEffectScheduler.flush();
        }
        let ranDetectChanges = false;
        if (this.dirtyFlags & 7) {
          const useGlobalCheck = Boolean(
            this.dirtyFlags & 1
            /* ApplicationRefDirtyFlags.ViewTreeGlobal */
          );
          this.dirtyFlags &= ~7;
          this.dirtyFlags |= 8;
          for (let { _lView } of this.allViews) {
            if (!useGlobalCheck && !requiresRefreshOrTraversal(_lView)) {
              continue;
            }
            const mode = useGlobalCheck && !this.zonelessEnabled ? (
              // Global mode includes `CheckAlways` views.
              0
            ) : (
              // Only refresh views with the `RefreshView` flag or views is a changed signal
              1
            );
            detectChangesInternal(_lView, mode);
            ranDetectChanges = true;
          }
          this.dirtyFlags &= ~4;
          this.syncDirtyFlagsWithViews();
          if (this.dirtyFlags & (7 | 16)) {
            return;
          }
        }
        if (!ranDetectChanges) {
          this._rendererFactory?.begin?.();
          this._rendererFactory?.end?.();
        }
        if (this.dirtyFlags & 8) {
          this.dirtyFlags &= ~8;
          this.afterRenderManager.execute();
        }
        this.syncDirtyFlagsWithViews();
      }
      /**
       * Checks `allViews` for views which require refresh/traversal, and updates `dirtyFlags`
       * accordingly, with two potential behaviors:
       *
       * 1. If any of our views require updating, then this adds the `ViewTreeTraversal` dirty flag.
       *    This _should_ be a no-op, since the scheduler should've added the flag at the same time the
       *    view was marked as needing updating.
       *
       *    TODO(alxhub): figure out if this behavior is still needed for edge cases.
       *
       * 2. If none of our views require updating, then clear the view-related `dirtyFlag`s. This
       *    happens when the scheduler is notified of a view becoming dirty, but the view itself isn't
       *    reachable through traversal from our roots (e.g. it's detached from the CD tree).
       */
      syncDirtyFlagsWithViews() {
        if (this.allViews.some(({ _lView }) => requiresRefreshOrTraversal(_lView))) {
          this.dirtyFlags |= 2;
          return;
        } else {
          this.dirtyFlags &= ~7;
        }
      }
      /**
       * Attaches a view so that it will be dirty checked.
       * The view will be automatically detached when it is destroyed.
       * This will throw if the view is already attached to a ViewContainer.
       */
      attachView(viewRef) {
        (typeof ngDevMode === "undefined" || ngDevMode) && warnIfDestroyed(this._destroyed);
        const view = viewRef;
        this._views.push(view);
        view.attachToAppRef(this);
      }
      /**
       * Detaches a view from dirty checking again.
       */
      detachView(viewRef) {
        (typeof ngDevMode === "undefined" || ngDevMode) && warnIfDestroyed(this._destroyed);
        const view = viewRef;
        remove(this._views, view);
        view.detachFromAppRef();
      }
      _loadComponent(componentRef) {
        this.attachView(componentRef.hostView);
        try {
          this.tick();
        } catch (e) {
          this.internalErrorHandler(e);
        }
        this.components.push(componentRef);
        const listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []);
        if (ngDevMode && !Array.isArray(listeners)) {
          throw new RuntimeError(-209, `Unexpected type of the \`APP_BOOTSTRAP_LISTENER\` token value (expected an array, but got ${typeof listeners}). Please check that the \`APP_BOOTSTRAP_LISTENER\` token is configured as a \`multi: true\` provider.`);
        }
        listeners.forEach((listener) => listener(componentRef));
      }
      /** @internal */
      ngOnDestroy() {
        if (this._destroyed)
          return;
        try {
          this._destroyListeners.forEach((listener) => listener());
          this._views.slice().forEach((view) => view.destroy());
        } finally {
          this._destroyed = true;
          this._views = [];
          this._destroyListeners = [];
        }
      }
      /**
       * Registers a listener to be called when an instance is destroyed.
       *
       * @param callback A callback function to add as a listener.
       * @returns A function which unregisters a listener.
       */
      onDestroy(callback) {
        (typeof ngDevMode === "undefined" || ngDevMode) && warnIfDestroyed(this._destroyed);
        this._destroyListeners.push(callback);
        return () => remove(this._destroyListeners, callback);
      }
      /**
       * Destroys an Angular application represented by this `ApplicationRef`. Calling this function
       * will destroy the associated environment injectors as well as all the bootstrapped components
       * with their views.
       */
      destroy() {
        if (this._destroyed) {
          throw new RuntimeError(406, ngDevMode && "This instance of the `ApplicationRef` has already been destroyed.");
        }
        const injector = this._injector;
        if (injector.destroy && !injector.destroyed) {
          injector.destroy();
        }
      }
      /**
       * Returns the number of attached views.
       */
      get viewCount() {
        return this._views.length;
      }
      static \u0275fac = function ApplicationRef_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ApplicationRef)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ApplicationRef, factory: _ApplicationRef.\u0275fac, providedIn: "root" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationRef, [{
        type: Injectable,
        args: [{ providedIn: "root" }]
      }], () => [], null);
    })();
    LiveCollection = class {
      destroy(item) {
      }
      updateValue(index, value) {
      }
      // operations below could be implemented on top of the operations defined so far, but having
      // them explicitly allow clear expression of intent and potentially more performant
      // implementations
      swap(index1, index2) {
        const startIdx = Math.min(index1, index2);
        const endIdx = Math.max(index1, index2);
        const endItem = this.detach(endIdx);
        if (endIdx - startIdx > 1) {
          const startItem = this.detach(startIdx);
          this.attach(startIdx, endItem);
          this.attach(endIdx, startItem);
        } else {
          this.attach(startIdx, endItem);
        }
      }
      move(prevIndex, newIdx) {
        this.attach(newIdx, this.detach(prevIndex));
      }
    };
    UniqueValueMultiKeyMap = class {
      // A map from a key to the first value corresponding to this key.
      kvMap = /* @__PURE__ */ new Map();
      // A map that acts as a linked list of values - each value maps to the next value in this "linked
      // list" (this only works if values are unique). Allocated lazily to avoid memory consumption when
      // there are no duplicated values.
      _vMap = void 0;
      has(key) {
        return this.kvMap.has(key);
      }
      delete(key) {
        if (!this.has(key))
          return false;
        const value = this.kvMap.get(key);
        if (this._vMap !== void 0 && this._vMap.has(value)) {
          this.kvMap.set(key, this._vMap.get(value));
          this._vMap.delete(value);
        } else {
          this.kvMap.delete(key);
        }
        return true;
      }
      get(key) {
        return this.kvMap.get(key);
      }
      set(key, value) {
        if (this.kvMap.has(key)) {
          let prevValue = this.kvMap.get(key);
          if (ngDevMode && prevValue === value) {
            throw new Error(`Detected a duplicated value ${value} for the key ${key}`);
          }
          if (this._vMap === void 0) {
            this._vMap = /* @__PURE__ */ new Map();
          }
          const vMap = this._vMap;
          while (vMap.has(prevValue)) {
            prevValue = vMap.get(prevValue);
          }
          vMap.set(prevValue, value);
        } else {
          this.kvMap.set(key, value);
        }
      }
      forEach(cb) {
        for (let [key, value] of this.kvMap) {
          cb(value, key);
          if (this._vMap !== void 0) {
            const vMap = this._vMap;
            while (vMap.has(value)) {
              value = vMap.get(value);
              cb(value, key);
            }
          }
        }
      }
    };
    RepeaterContext = class {
      lContainer;
      $implicit;
      $index;
      constructor(lContainer, $implicit, $index) {
        this.lContainer = lContainer;
        this.$implicit = $implicit;
        this.$index = $index;
      }
      get $count() {
        return this.lContainer.length - CONTAINER_HEADER_OFFSET;
      }
    };
    RepeaterMetadata = class {
      hasEmptyBlock;
      trackByFn;
      liveCollection;
      constructor(hasEmptyBlock, trackByFn, liveCollection) {
        this.hasEmptyBlock = hasEmptyBlock;
        this.trackByFn = trackByFn;
        this.liveCollection = liveCollection;
      }
    };
    OperationsCounter = class {
      created = 0;
      destroyed = 0;
      reset() {
        this.created = 0;
        this.destroyed = 0;
      }
      recordCreate() {
        this.created++;
      }
      recordDestroy() {
        this.destroyed++;
      }
      /**
       * A method indicating if the entire collection was re-created as part of the reconciliation pass.
       * Used to warn developers about the usage of a tracking function that might result in excessive
       * amount of view creation / destroy operations.
       *
       * @returns boolean value indicating if a live collection was re-created
       */
      wasReCreated(collectionLen) {
        return collectionLen > 0 && this.created === this.destroyed && this.created === collectionLen;
      }
    };
    LiveCollectionLContainerImpl = class extends LiveCollection {
      lContainer;
      hostLView;
      templateTNode;
      operationsCounter = ngDevMode ? new OperationsCounter() : void 0;
      /**
        Property indicating if indexes in the repeater context need to be updated following the live
        collection changes. Index updates are necessary if and only if views are inserted / removed in
        the middle of LContainer. Adds and removals at the end don't require index updates.
      */
      needsIndexUpdate = false;
      constructor(lContainer, hostLView, templateTNode) {
        super();
        this.lContainer = lContainer;
        this.hostLView = hostLView;
        this.templateTNode = templateTNode;
      }
      get length() {
        return this.lContainer.length - CONTAINER_HEADER_OFFSET;
      }
      at(index) {
        return this.getLView(index)[CONTEXT].$implicit;
      }
      attach(index, lView) {
        const dehydratedView = lView[HYDRATION];
        this.needsIndexUpdate ||= index !== this.length;
        addLViewToLContainer(this.lContainer, lView, index, shouldAddViewToDom(this.templateTNode, dehydratedView));
      }
      detach(index) {
        this.needsIndexUpdate ||= index !== this.length - 1;
        return detachExistingView(this.lContainer, index);
      }
      create(index, value) {
        const dehydratedView = findMatchingDehydratedView(this.lContainer, this.templateTNode.tView.ssrId);
        const embeddedLView = createAndRenderEmbeddedLView(this.hostLView, this.templateTNode, new RepeaterContext(this.lContainer, value, index), { dehydratedView });
        this.operationsCounter?.recordCreate();
        return embeddedLView;
      }
      destroy(lView) {
        destroyLView(lView[TVIEW], lView);
        this.operationsCounter?.recordDestroy();
      }
      updateValue(index, value) {
        this.getLView(index)[CONTEXT].$implicit = value;
      }
      reset() {
        this.needsIndexUpdate = false;
        this.operationsCounter?.reset();
      }
      updateIndexes() {
        if (this.needsIndexUpdate) {
          for (let i = 0; i < this.length; i++) {
            this.getLView(i)[CONTEXT].$index = i;
          }
        }
      }
      getLView(index) {
        return getExistingLViewFromLContainer(this.lContainer, index);
      }
    };
    _locateOrCreateElementNode = (tView, lView, tNode, name2, index) => {
      lastNodeWasCreated(true);
      return createElementNode(lView[RENDERER], name2, getNamespace());
    };
    _locateOrCreateElementContainerNode = (tView, lView, tNode, commentText, index) => {
      lastNodeWasCreated(true);
      return createCommentNode(lView[RENDERER], ngDevMode ? commentText : "");
    };
    u = void 0;
    localeEn = ["en", [["a", "p"], ["AM", "PM"], u], [["AM", "PM"], u, u], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], u, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], u, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", u, "{1} 'at' {0}", u], [".", ",", ";", "%", "+", "-", "E", "\xD7", "\u2030", "\u221E", "NaN", ":"], ["#,##0.###", "#,##0%", "\xA4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", plural];
    LOCALE_DATA = {};
    (function(LocaleDataIndex2) {
      LocaleDataIndex2[LocaleDataIndex2["LocaleId"] = 0] = "LocaleId";
      LocaleDataIndex2[LocaleDataIndex2["DayPeriodsFormat"] = 1] = "DayPeriodsFormat";
      LocaleDataIndex2[LocaleDataIndex2["DayPeriodsStandalone"] = 2] = "DayPeriodsStandalone";
      LocaleDataIndex2[LocaleDataIndex2["DaysFormat"] = 3] = "DaysFormat";
      LocaleDataIndex2[LocaleDataIndex2["DaysStandalone"] = 4] = "DaysStandalone";
      LocaleDataIndex2[LocaleDataIndex2["MonthsFormat"] = 5] = "MonthsFormat";
      LocaleDataIndex2[LocaleDataIndex2["MonthsStandalone"] = 6] = "MonthsStandalone";
      LocaleDataIndex2[LocaleDataIndex2["Eras"] = 7] = "Eras";
      LocaleDataIndex2[LocaleDataIndex2["FirstDayOfWeek"] = 8] = "FirstDayOfWeek";
      LocaleDataIndex2[LocaleDataIndex2["WeekendRange"] = 9] = "WeekendRange";
      LocaleDataIndex2[LocaleDataIndex2["DateFormat"] = 10] = "DateFormat";
      LocaleDataIndex2[LocaleDataIndex2["TimeFormat"] = 11] = "TimeFormat";
      LocaleDataIndex2[LocaleDataIndex2["DateTimeFormat"] = 12] = "DateTimeFormat";
      LocaleDataIndex2[LocaleDataIndex2["NumberSymbols"] = 13] = "NumberSymbols";
      LocaleDataIndex2[LocaleDataIndex2["NumberFormats"] = 14] = "NumberFormats";
      LocaleDataIndex2[LocaleDataIndex2["CurrencyCode"] = 15] = "CurrencyCode";
      LocaleDataIndex2[LocaleDataIndex2["CurrencySymbol"] = 16] = "CurrencySymbol";
      LocaleDataIndex2[LocaleDataIndex2["CurrencyName"] = 17] = "CurrencyName";
      LocaleDataIndex2[LocaleDataIndex2["Currencies"] = 18] = "Currencies";
      LocaleDataIndex2[LocaleDataIndex2["Directionality"] = 19] = "Directionality";
      LocaleDataIndex2[LocaleDataIndex2["PluralCase"] = 20] = "PluralCase";
      LocaleDataIndex2[LocaleDataIndex2["ExtraData"] = 21] = "ExtraData";
    })(LocaleDataIndex || (LocaleDataIndex = {}));
    pluralMapping = ["zero", "one", "two", "few", "many"];
    DEFAULT_LOCALE_ID = "en-US";
    USD_CURRENCY_CODE = "USD";
    ELEMENT_MARKER = {
      marker: "element"
    };
    ICU_MARKER = {
      marker: "ICU"
    };
    (function(I18nCreateOpCode2) {
      I18nCreateOpCode2[I18nCreateOpCode2["SHIFT"] = 2] = "SHIFT";
      I18nCreateOpCode2[I18nCreateOpCode2["APPEND_EAGERLY"] = 1] = "APPEND_EAGERLY";
      I18nCreateOpCode2[I18nCreateOpCode2["COMMENT"] = 2] = "COMMENT";
    })(I18nCreateOpCode || (I18nCreateOpCode = {}));
    LOCALE_ID$1 = DEFAULT_LOCALE_ID;
    changeMask = 0;
    changeMaskCounter = 0;
    _locateOrCreateNode = (lView, index, textOrName, nodeType) => {
      lastNodeWasCreated(true);
      return createNodeWithoutHydration(lView, textOrName, nodeType);
    };
    OpCodeParser = class {
      i = 0;
      codes;
      constructor(codes) {
        this.codes = codes;
      }
      hasMore() {
        return this.i < this.codes.length;
      }
      consumeNumber() {
        let value = this.codes[this.i++];
        assertNumber(value, "expecting number in OpCode");
        return value;
      }
      consumeString() {
        let value = this.codes[this.i++];
        assertString(value, "expecting string in OpCode");
        return value;
      }
      consumeFunction() {
        let value = this.codes[this.i++];
        if (value === null || typeof value === "function") {
          return value;
        }
        throw new Error("expecting function in OpCode");
      }
      consumeNumberOrString() {
        let value = this.codes[this.i++];
        if (typeof value === "string") {
          return value;
        }
        assertNumber(value, "expecting number or string in OpCode");
        return value;
      }
      consumeNumberStringOrMarker() {
        let value = this.codes[this.i++];
        if (typeof value === "string" || typeof value === "number" || value == ICU_MARKER || value == ELEMENT_MARKER) {
          return value;
        }
        assertNumber(value, "expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode");
        return value;
      }
    };
    BINDING_REGEXP = /(\d+):?\d*/gi;
    ICU_REGEXP = /({\s*\d+:?\d*\s*,\s*\S{6}\s*,[\s\S]*})/gi;
    NESTED_ICU = /(\d+)/;
    ICU_BLOCK_REGEXP = /^\s*(\d+:?\d*)\s*,\s*(select|plural)\s*,/;
    MARKER = `\uFFFD`;
    SUBTEMPLATE_REGEXP = /\/?\*(\d+:\d+)/gi;
    PH_REGEXP = /(\/?[#*]\d+):?\d*/gi;
    NGSP_UNICODE_REGEXP = /\uE500/g;
    ROOT_TEMPLATE_ID = 0;
    PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\[(.+??)\]/;
    PP_PLACEHOLDERS_REGEXP = /\[(.+??)\]|(\/?\*\d+:\d+)/g;
    PP_ICU_VARS_REGEXP = /({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g;
    PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;
    PP_ICUS_REGEXP = /I18N_EXP_(ICU(_\d+)?)/g;
    PP_CLOSE_TEMPLATE_REGEXP = /\/\*/;
    PP_TEMPLATE_ID_REGEXP = /\d+\:(\d+)/;
    parserState = {
      textEnd: 0,
      key: 0,
      keyEnd: 0,
      value: 0,
      valueEnd: 0
    };
    _locateOrCreateTextNode = (tView, lView, tNode, value, index) => {
      lastNodeWasCreated(true);
      return createTextNode(lView[RENDERER], value);
    };
    UNINITIALIZED_LET = {};
    angularCoreEnv = /* @__PURE__ */ (() => ({
      "\u0275\u0275attribute": \u0275\u0275attribute,
      "\u0275\u0275defineComponent": \u0275\u0275defineComponent,
      "\u0275\u0275defineDirective": \u0275\u0275defineDirective,
      "\u0275\u0275defineInjectable": \u0275\u0275defineInjectable,
      "\u0275\u0275defineInjector": \u0275\u0275defineInjector,
      "\u0275\u0275defineNgModule": \u0275\u0275defineNgModule,
      "\u0275\u0275definePipe": \u0275\u0275definePipe,
      "\u0275\u0275directiveInject": \u0275\u0275directiveInject,
      "\u0275\u0275getInheritedFactory": \u0275\u0275getInheritedFactory,
      "\u0275\u0275inject": \u0275\u0275inject,
      "\u0275\u0275injectAttribute": \u0275\u0275injectAttribute,
      "\u0275\u0275invalidFactory": \u0275\u0275invalidFactory,
      "\u0275\u0275invalidFactoryDep": \u0275\u0275invalidFactoryDep,
      "\u0275\u0275templateRefExtractor": \u0275\u0275templateRefExtractor,
      "\u0275\u0275resetView": \u0275\u0275resetView,
      "\u0275\u0275HostDirectivesFeature": \u0275\u0275HostDirectivesFeature,
      "\u0275\u0275NgOnChangesFeature": \u0275\u0275NgOnChangesFeature,
      "\u0275\u0275ProvidersFeature": \u0275\u0275ProvidersFeature,
      "\u0275\u0275CopyDefinitionFeature": \u0275\u0275CopyDefinitionFeature,
      "\u0275\u0275InheritDefinitionFeature": \u0275\u0275InheritDefinitionFeature,
      "\u0275\u0275ExternalStylesFeature": \u0275\u0275ExternalStylesFeature,
      "\u0275\u0275nextContext": \u0275\u0275nextContext,
      "\u0275\u0275namespaceHTML": \u0275\u0275namespaceHTML,
      "\u0275\u0275namespaceMathML": \u0275\u0275namespaceMathML,
      "\u0275\u0275namespaceSVG": \u0275\u0275namespaceSVG,
      "\u0275\u0275enableBindings": \u0275\u0275enableBindings,
      "\u0275\u0275disableBindings": \u0275\u0275disableBindings,
      "\u0275\u0275elementStart": \u0275\u0275elementStart,
      "\u0275\u0275elementEnd": \u0275\u0275elementEnd,
      "\u0275\u0275element": \u0275\u0275element,
      "\u0275\u0275elementContainerStart": \u0275\u0275elementContainerStart,
      "\u0275\u0275elementContainerEnd": \u0275\u0275elementContainerEnd,
      "\u0275\u0275domElement": \u0275\u0275domElement,
      "\u0275\u0275domElementStart": \u0275\u0275domElementStart,
      "\u0275\u0275domElementEnd": \u0275\u0275domElementEnd,
      "\u0275\u0275domElementContainer": \u0275\u0275domElementContainer,
      "\u0275\u0275domElementContainerStart": \u0275\u0275domElementContainerStart,
      "\u0275\u0275domElementContainerEnd": \u0275\u0275domElementContainerEnd,
      "\u0275\u0275domTemplate": \u0275\u0275domTemplate,
      "\u0275\u0275domListener": \u0275\u0275domListener,
      "\u0275\u0275elementContainer": \u0275\u0275elementContainer,
      "\u0275\u0275pureFunction0": \u0275\u0275pureFunction0,
      "\u0275\u0275pureFunction1": \u0275\u0275pureFunction1,
      "\u0275\u0275pureFunction2": \u0275\u0275pureFunction2,
      "\u0275\u0275pureFunction3": \u0275\u0275pureFunction3,
      "\u0275\u0275pureFunction4": \u0275\u0275pureFunction4,
      "\u0275\u0275pureFunction5": \u0275\u0275pureFunction5,
      "\u0275\u0275pureFunction6": \u0275\u0275pureFunction6,
      "\u0275\u0275pureFunction7": \u0275\u0275pureFunction7,
      "\u0275\u0275pureFunction8": \u0275\u0275pureFunction8,
      "\u0275\u0275pureFunctionV": \u0275\u0275pureFunctionV,
      "\u0275\u0275getCurrentView": \u0275\u0275getCurrentView,
      "\u0275\u0275restoreView": \u0275\u0275restoreView,
      "\u0275\u0275listener": \u0275\u0275listener,
      "\u0275\u0275projection": \u0275\u0275projection,
      "\u0275\u0275syntheticHostProperty": \u0275\u0275syntheticHostProperty,
      "\u0275\u0275syntheticHostListener": \u0275\u0275syntheticHostListener,
      "\u0275\u0275pipeBind1": \u0275\u0275pipeBind1,
      "\u0275\u0275pipeBind2": \u0275\u0275pipeBind2,
      "\u0275\u0275pipeBind3": \u0275\u0275pipeBind3,
      "\u0275\u0275pipeBind4": \u0275\u0275pipeBind4,
      "\u0275\u0275pipeBindV": \u0275\u0275pipeBindV,
      "\u0275\u0275projectionDef": \u0275\u0275projectionDef,
      "\u0275\u0275domProperty": \u0275\u0275domProperty,
      "\u0275\u0275property": \u0275\u0275property,
      "\u0275\u0275pipe": \u0275\u0275pipe,
      "\u0275\u0275queryRefresh": \u0275\u0275queryRefresh,
      "\u0275\u0275queryAdvance": \u0275\u0275queryAdvance,
      "\u0275\u0275viewQuery": \u0275\u0275viewQuery,
      "\u0275\u0275viewQuerySignal": \u0275\u0275viewQuerySignal,
      "\u0275\u0275loadQuery": \u0275\u0275loadQuery,
      "\u0275\u0275contentQuery": \u0275\u0275contentQuery,
      "\u0275\u0275contentQuerySignal": \u0275\u0275contentQuerySignal,
      "\u0275\u0275reference": \u0275\u0275reference,
      "\u0275\u0275classMap": \u0275\u0275classMap,
      "\u0275\u0275styleMap": \u0275\u0275styleMap,
      "\u0275\u0275styleProp": \u0275\u0275styleProp,
      "\u0275\u0275classProp": \u0275\u0275classProp,
      "\u0275\u0275advance": \u0275\u0275advance,
      "\u0275\u0275template": \u0275\u0275template,
      "\u0275\u0275conditional": \u0275\u0275conditional,
      "\u0275\u0275conditionalCreate": \u0275\u0275conditionalCreate,
      "\u0275\u0275conditionalBranchCreate": \u0275\u0275conditionalBranchCreate,
      "\u0275\u0275defer": \u0275\u0275defer,
      "\u0275\u0275deferWhen": \u0275\u0275deferWhen,
      "\u0275\u0275deferOnIdle": \u0275\u0275deferOnIdle,
      "\u0275\u0275deferOnImmediate": \u0275\u0275deferOnImmediate,
      "\u0275\u0275deferOnTimer": \u0275\u0275deferOnTimer,
      "\u0275\u0275deferOnHover": \u0275\u0275deferOnHover,
      "\u0275\u0275deferOnInteraction": \u0275\u0275deferOnInteraction,
      "\u0275\u0275deferOnViewport": \u0275\u0275deferOnViewport,
      "\u0275\u0275deferPrefetchWhen": \u0275\u0275deferPrefetchWhen,
      "\u0275\u0275deferPrefetchOnIdle": \u0275\u0275deferPrefetchOnIdle,
      "\u0275\u0275deferPrefetchOnImmediate": \u0275\u0275deferPrefetchOnImmediate,
      "\u0275\u0275deferPrefetchOnTimer": \u0275\u0275deferPrefetchOnTimer,
      "\u0275\u0275deferPrefetchOnHover": \u0275\u0275deferPrefetchOnHover,
      "\u0275\u0275deferPrefetchOnInteraction": \u0275\u0275deferPrefetchOnInteraction,
      "\u0275\u0275deferPrefetchOnViewport": \u0275\u0275deferPrefetchOnViewport,
      "\u0275\u0275deferHydrateWhen": \u0275\u0275deferHydrateWhen,
      "\u0275\u0275deferHydrateNever": \u0275\u0275deferHydrateNever,
      "\u0275\u0275deferHydrateOnIdle": \u0275\u0275deferHydrateOnIdle,
      "\u0275\u0275deferHydrateOnImmediate": \u0275\u0275deferHydrateOnImmediate,
      "\u0275\u0275deferHydrateOnTimer": \u0275\u0275deferHydrateOnTimer,
      "\u0275\u0275deferHydrateOnHover": \u0275\u0275deferHydrateOnHover,
      "\u0275\u0275deferHydrateOnInteraction": \u0275\u0275deferHydrateOnInteraction,
      "\u0275\u0275deferHydrateOnViewport": \u0275\u0275deferHydrateOnViewport,
      "\u0275\u0275deferEnableTimerScheduling": \u0275\u0275deferEnableTimerScheduling,
      "\u0275\u0275repeater": \u0275\u0275repeater,
      "\u0275\u0275repeaterCreate": \u0275\u0275repeaterCreate,
      "\u0275\u0275repeaterTrackByIndex": \u0275\u0275repeaterTrackByIndex,
      "\u0275\u0275repeaterTrackByIdentity": \u0275\u0275repeaterTrackByIdentity,
      "\u0275\u0275componentInstance": \u0275\u0275componentInstance,
      "\u0275\u0275text": \u0275\u0275text,
      "\u0275\u0275textInterpolate": \u0275\u0275textInterpolate,
      "\u0275\u0275textInterpolate1": \u0275\u0275textInterpolate1,
      "\u0275\u0275textInterpolate2": \u0275\u0275textInterpolate2,
      "\u0275\u0275textInterpolate3": \u0275\u0275textInterpolate3,
      "\u0275\u0275textInterpolate4": \u0275\u0275textInterpolate4,
      "\u0275\u0275textInterpolate5": \u0275\u0275textInterpolate5,
      "\u0275\u0275textInterpolate6": \u0275\u0275textInterpolate6,
      "\u0275\u0275textInterpolate7": \u0275\u0275textInterpolate7,
      "\u0275\u0275textInterpolate8": \u0275\u0275textInterpolate8,
      "\u0275\u0275textInterpolateV": \u0275\u0275textInterpolateV,
      "\u0275\u0275i18n": \u0275\u0275i18n,
      "\u0275\u0275i18nAttributes": \u0275\u0275i18nAttributes,
      "\u0275\u0275i18nExp": \u0275\u0275i18nExp,
      "\u0275\u0275i18nStart": \u0275\u0275i18nStart,
      "\u0275\u0275i18nEnd": \u0275\u0275i18nEnd,
      "\u0275\u0275i18nApply": \u0275\u0275i18nApply,
      "\u0275\u0275i18nPostprocess": \u0275\u0275i18nPostprocess,
      "\u0275\u0275resolveWindow": \u0275\u0275resolveWindow,
      "\u0275\u0275resolveDocument": \u0275\u0275resolveDocument,
      "\u0275\u0275resolveBody": \u0275\u0275resolveBody,
      "\u0275\u0275setComponentScope": \u0275\u0275setComponentScope,
      "\u0275\u0275setNgModuleScope": \u0275\u0275setNgModuleScope,
      "\u0275\u0275registerNgModuleType": registerNgModuleType,
      "\u0275\u0275getComponentDepsFactory": \u0275\u0275getComponentDepsFactory,
      "\u0275setClassDebugInfo": \u0275setClassDebugInfo,
      "\u0275\u0275declareLet": \u0275\u0275declareLet,
      "\u0275\u0275storeLet": \u0275\u0275storeLet,
      "\u0275\u0275readContextLet": \u0275\u0275readContextLet,
      "\u0275\u0275attachSourceLocations": \u0275\u0275attachSourceLocations,
      "\u0275\u0275interpolate": \u0275\u0275interpolate,
      "\u0275\u0275interpolate1": \u0275\u0275interpolate1,
      "\u0275\u0275interpolate2": \u0275\u0275interpolate2,
      "\u0275\u0275interpolate3": \u0275\u0275interpolate3,
      "\u0275\u0275interpolate4": \u0275\u0275interpolate4,
      "\u0275\u0275interpolate5": \u0275\u0275interpolate5,
      "\u0275\u0275interpolate6": \u0275\u0275interpolate6,
      "\u0275\u0275interpolate7": \u0275\u0275interpolate7,
      "\u0275\u0275interpolate8": \u0275\u0275interpolate8,
      "\u0275\u0275interpolateV": \u0275\u0275interpolateV,
      "\u0275\u0275sanitizeHtml": \u0275\u0275sanitizeHtml,
      "\u0275\u0275sanitizeStyle": \u0275\u0275sanitizeStyle,
      "\u0275\u0275sanitizeResourceUrl": \u0275\u0275sanitizeResourceUrl,
      "\u0275\u0275sanitizeScript": \u0275\u0275sanitizeScript,
      "\u0275\u0275sanitizeUrl": \u0275\u0275sanitizeUrl,
      "\u0275\u0275sanitizeUrlOrResourceUrl": \u0275\u0275sanitizeUrlOrResourceUrl,
      "\u0275\u0275trustConstantHtml": \u0275\u0275trustConstantHtml,
      "\u0275\u0275trustConstantResourceUrl": \u0275\u0275trustConstantResourceUrl,
      "\u0275\u0275validateIframeAttribute": \u0275\u0275validateIframeAttribute,
      "forwardRef": forwardRef,
      "resolveForwardRef": resolveForwardRef,
      "\u0275\u0275twoWayProperty": \u0275\u0275twoWayProperty,
      "\u0275\u0275twoWayBindingSet": \u0275\u0275twoWayBindingSet,
      "\u0275\u0275twoWayListener": \u0275\u0275twoWayListener,
      "\u0275\u0275replaceMetadata": \u0275\u0275replaceMetadata,
      "\u0275\u0275getReplaceMetadataURL": \u0275\u0275getReplaceMetadataURL
    }))();
    jitOptions = null;
    moduleQueue = [];
    flushingModuleQueue = false;
    ownerNgModule = /* @__PURE__ */ new WeakMap();
    verifiedNgModule = /* @__PURE__ */ new WeakMap();
    compilationDepth = 0;
    LIFECYCLE_HOOKS = [
      "ngOnChanges",
      "ngOnInit",
      "ngOnDestroy",
      "ngDoCheck",
      "ngAfterViewInit",
      "ngAfterViewChecked",
      "ngAfterContentInit",
      "ngAfterContentChecked"
    ];
    Directive = makeDecorator("Directive", (dir = {}) => dir, void 0, void 0, (type, meta2) => compileDirective(type, meta2));
    Component = makeDecorator("Component", (c = {}) => __spreadValues({ changeDetection: ChangeDetectionStrategy.Default }, c), Directive, void 0, (type, meta2) => compileComponent(type, meta2));
    Pipe = makeDecorator("Pipe", (p) => __spreadValues({ pure: true }, p), void 0, void 0, (type, meta2) => compilePipe(type, meta2));
    Input = makePropDecorator("Input", (arg) => {
      if (!arg) {
        return {};
      }
      return typeof arg === "string" ? { alias: arg } : arg;
    });
    Output = makePropDecorator("Output", (alias) => ({ alias }));
    HostBinding = makePropDecorator("HostBinding", (hostPropertyName) => ({ hostPropertyName }));
    HostListener = makePropDecorator("HostListener", (eventName, args) => ({ eventName, args }));
    NgModule = makeDecorator(
      "NgModule",
      (ngModule) => ngModule,
      void 0,
      void 0,
      /**
       * Decorator that marks the following class as an NgModule, and supplies
       * configuration metadata for it.
       *
       * * The `declarations` option configures the compiler
       * with information about what belongs to the NgModule.
       * * The `providers` options configures the NgModule's injector to provide
       * dependencies the NgModule members.
       * * The `imports` and `exports` options bring in members from other modules, and make
       * this module's members available to others.
       */
      (type, meta2) => compileNgModule(type, meta2)
    );
    ModuleWithComponentFactories = class {
      ngModuleFactory;
      componentFactories;
      constructor(ngModuleFactory, componentFactories) {
        this.ngModuleFactory = ngModuleFactory;
        this.componentFactories = componentFactories;
      }
    };
    Compiler = class _Compiler {
      /**
       * Compiles the given NgModule and all of its components. All templates of the components
       * have to be inlined.
       */
      compileModuleSync(moduleType) {
        return new NgModuleFactory2(moduleType);
      }
      /**
       * Compiles the given NgModule and all of its components
       */
      compileModuleAsync(moduleType) {
        return Promise.resolve(this.compileModuleSync(moduleType));
      }
      /**
       * Same as {@link Compiler#compileModuleSync compileModuleSync} but also creates ComponentFactories for all components.
       */
      compileModuleAndAllComponentsSync(moduleType) {
        const ngModuleFactory = this.compileModuleSync(moduleType);
        const moduleDef = getNgModuleDef(moduleType);
        const componentFactories = maybeUnwrapFn(moduleDef.declarations).reduce((factories, declaration) => {
          const componentDef = getComponentDef(declaration);
          componentDef && factories.push(new ComponentFactory2(componentDef));
          return factories;
        }, []);
        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
      }
      /**
       * Same as {@link Compiler#compileModuleAsync compileModuleAsync} but also creates ComponentFactories for all components.
       */
      compileModuleAndAllComponentsAsync(moduleType) {
        return Promise.resolve(this.compileModuleAndAllComponentsSync(moduleType));
      }
      /**
       * Clears all caches.
       */
      clearCache() {
      }
      /**
       * Clears the cache for the given component/ngModule.
       */
      clearCacheFor(type) {
      }
      /**
       * Returns the id for a given NgModule, if one is defined and known to the compiler.
       */
      getModuleId(moduleType) {
        return void 0;
      }
      static \u0275fac = function Compiler_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Compiler)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _Compiler, factory: _Compiler.\u0275fac, providedIn: "root" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Compiler, [{
        type: Injectable,
        args: [{ providedIn: "root" }]
      }], null, null);
    })();
    COMPILER_OPTIONS = new InjectionToken(ngDevMode ? "compilerOptions" : "");
    NgZoneChangeDetectionScheduler = class _NgZoneChangeDetectionScheduler {
      zone = inject2(NgZone);
      changeDetectionScheduler = inject2(ChangeDetectionScheduler);
      applicationRef = inject2(ApplicationRef);
      applicationErrorHandler = inject2(INTERNAL_APPLICATION_ERROR_HANDLER);
      _onMicrotaskEmptySubscription;
      initialize() {
        if (this._onMicrotaskEmptySubscription) {
          return;
        }
        this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({
          next: () => {
            if (this.changeDetectionScheduler.runningTick) {
              return;
            }
            this.zone.run(() => {
              try {
                this.applicationRef.dirtyFlags |= 1;
                this.applicationRef._tick();
              } catch (e) {
                this.applicationErrorHandler(e);
              }
            });
          }
        });
      }
      ngOnDestroy() {
        this._onMicrotaskEmptySubscription?.unsubscribe();
      }
      static \u0275fac = function NgZoneChangeDetectionScheduler_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgZoneChangeDetectionScheduler)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _NgZoneChangeDetectionScheduler, factory: _NgZoneChangeDetectionScheduler.\u0275fac, providedIn: "root" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgZoneChangeDetectionScheduler, [{
        type: Injectable,
        args: [{ providedIn: "root" }]
      }], null, null);
    })();
    PROVIDED_NG_ZONE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "provideZoneChangeDetection token" : "", { factory: () => false });
    ZoneStablePendingTask = class _ZoneStablePendingTask {
      subscription = new Subscription();
      initialized = false;
      zone = inject2(NgZone);
      pendingTasks = inject2(PendingTasksInternal);
      initialize() {
        if (this.initialized) {
          return;
        }
        this.initialized = true;
        let task = null;
        if (!this.zone.isStable && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {
          task = this.pendingTasks.add();
        }
        this.zone.runOutsideAngular(() => {
          this.subscription.add(this.zone.onStable.subscribe(() => {
            NgZone.assertNotInAngularZone();
            queueMicrotask(() => {
              if (task !== null && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {
                this.pendingTasks.remove(task);
                task = null;
              }
            });
          }));
        });
        this.subscription.add(this.zone.onUnstable.subscribe(() => {
          NgZone.assertInAngularZone();
          task ??= this.pendingTasks.add();
        }));
      }
      ngOnDestroy() {
        this.subscription.unsubscribe();
      }
      static \u0275fac = function ZoneStablePendingTask_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ZoneStablePendingTask)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ZoneStablePendingTask, factory: _ZoneStablePendingTask.\u0275fac, providedIn: "root" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ZoneStablePendingTask, [{
        type: Injectable,
        args: [{ providedIn: "root" }]
      }], null, null);
    })();
    CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT = 100;
    consecutiveMicrotaskNotifications = 0;
    stackFromLastFewNotifications = [];
    ChangeDetectionSchedulerImpl = class _ChangeDetectionSchedulerImpl {
      applicationErrorHandler = inject2(INTERNAL_APPLICATION_ERROR_HANDLER);
      appRef = inject2(ApplicationRef);
      taskService = inject2(PendingTasksInternal);
      ngZone = inject2(NgZone);
      zonelessEnabled = inject2(ZONELESS_ENABLED);
      tracing = inject2(TracingService, { optional: true });
      disableScheduling = inject2(ZONELESS_SCHEDULER_DISABLED, { optional: true }) ?? false;
      zoneIsDefined = typeof Zone !== "undefined" && !!Zone.root.run;
      schedulerTickApplyArgs = [{ data: { "__scheduler_tick__": true } }];
      subscriptions = new Subscription();
      angularZoneId = this.zoneIsDefined ? this.ngZone._inner?.get(angularZoneInstanceIdProperty) : null;
      scheduleInRootZone = !this.zonelessEnabled && this.zoneIsDefined && (inject2(SCHEDULE_IN_ROOT_ZONE, { optional: true }) ?? false);
      cancelScheduledCallback = null;
      useMicrotaskScheduler = false;
      runningTick = false;
      pendingRenderTaskId = null;
      constructor() {
        this.subscriptions.add(this.appRef.afterTick.subscribe(() => {
          if (!this.runningTick) {
            this.cleanup();
          }
        }));
        this.subscriptions.add(this.ngZone.onUnstable.subscribe(() => {
          if (!this.runningTick) {
            this.cleanup();
          }
        }));
        this.disableScheduling ||= !this.zonelessEnabled && // NoopNgZone without enabling zoneless means no scheduling whatsoever
        (this.ngZone instanceof NoopNgZone || // The same goes for the lack of Zone without enabling zoneless scheduling
        !this.zoneIsDefined);
      }
      notify(source) {
        if (!this.zonelessEnabled && source === 5) {
          return;
        }
        let force = false;
        switch (source) {
          case 0: {
            this.appRef.dirtyFlags |= 2;
            break;
          }
          case 3:
          case 2:
          case 4:
          case 5:
          case 1: {
            this.appRef.dirtyFlags |= 4;
            break;
          }
          case 6: {
            this.appRef.dirtyFlags |= 2;
            force = true;
            break;
          }
          case 12: {
            this.appRef.dirtyFlags |= 16;
            force = true;
            break;
          }
          case 13: {
            this.appRef.dirtyFlags |= 2;
            force = true;
            break;
          }
          case 11: {
            force = true;
            break;
          }
          case 9:
          case 8:
          case 7:
          case 10:
          default: {
            this.appRef.dirtyFlags |= 8;
          }
        }
        this.appRef.tracingSnapshot = this.tracing?.snapshot(this.appRef.tracingSnapshot) ?? null;
        if (!this.shouldScheduleTick(force)) {
          return;
        }
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          if (this.useMicrotaskScheduler) {
            trackMicrotaskNotificationForDebugging();
          } else {
            consecutiveMicrotaskNotifications = 0;
            stackFromLastFewNotifications.length = 0;
          }
        }
        const scheduleCallback = this.useMicrotaskScheduler ? scheduleCallbackWithMicrotask : scheduleCallbackWithRafRace;
        this.pendingRenderTaskId = this.taskService.add();
        if (this.scheduleInRootZone) {
          this.cancelScheduledCallback = Zone.root.run(() => scheduleCallback(() => this.tick()));
        } else {
          this.cancelScheduledCallback = this.ngZone.runOutsideAngular(() => scheduleCallback(() => this.tick()));
        }
      }
      shouldScheduleTick(force) {
        if (this.disableScheduling && !force || this.appRef.destroyed) {
          return false;
        }
        if (this.pendingRenderTaskId !== null || this.runningTick || this.appRef._runningTick) {
          return false;
        }
        if (!this.zonelessEnabled && this.zoneIsDefined && Zone.current.get(angularZoneInstanceIdProperty + this.angularZoneId)) {
          return false;
        }
        return true;
      }
      /**
       * Calls ApplicationRef._tick inside the `NgZone`.
       *
       * Calling `tick` directly runs change detection and cancels any change detection that had been
       * scheduled previously.
       *
       * @param shouldRefreshViews Passed directly to `ApplicationRef._tick` and skips straight to
       *     render hooks when `false`.
       */
      tick() {
        if (this.runningTick || this.appRef.destroyed) {
          return;
        }
        if (this.appRef.dirtyFlags === 0) {
          this.cleanup();
          return;
        }
        if (!this.zonelessEnabled && this.appRef.dirtyFlags & 7) {
          this.appRef.dirtyFlags |= 1;
        }
        const task = this.taskService.add();
        try {
          this.ngZone.run(() => {
            this.runningTick = true;
            this.appRef._tick();
          }, void 0, this.schedulerTickApplyArgs);
        } catch (e) {
          this.taskService.remove(task);
          this.applicationErrorHandler(e);
        } finally {
          this.cleanup();
        }
        this.useMicrotaskScheduler = true;
        scheduleCallbackWithMicrotask(() => {
          this.useMicrotaskScheduler = false;
          this.taskService.remove(task);
        });
      }
      ngOnDestroy() {
        this.subscriptions.unsubscribe();
        this.cleanup();
      }
      cleanup() {
        this.runningTick = false;
        this.cancelScheduledCallback?.();
        this.cancelScheduledCallback = null;
        if (this.pendingRenderTaskId !== null) {
          const taskId = this.pendingRenderTaskId;
          this.pendingRenderTaskId = null;
          this.taskService.remove(taskId);
        }
      }
      static \u0275fac = function ChangeDetectionSchedulerImpl_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ChangeDetectionSchedulerImpl)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ChangeDetectionSchedulerImpl, factory: _ChangeDetectionSchedulerImpl.\u0275fac, providedIn: "root" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChangeDetectionSchedulerImpl, [{
        type: Injectable,
        args: [{ providedIn: "root" }]
      }], () => [], null);
    })();
    LOCALE_ID = new InjectionToken(ngDevMode ? "LocaleId" : "", {
      providedIn: "root",
      factory: () => inject2(LOCALE_ID, { optional: true, skipSelf: true }) || getGlobalLocale()
    });
    DEFAULT_CURRENCY_CODE = new InjectionToken(ngDevMode ? "DefaultCurrencyCode" : "", {
      providedIn: "root",
      factory: () => USD_CURRENCY_CODE
    });
    TRANSLATIONS = new InjectionToken(ngDevMode ? "Translations" : "");
    TRANSLATIONS_FORMAT = new InjectionToken(ngDevMode ? "TranslationsFormat" : "");
    (function(MissingTranslationStrategy2) {
      MissingTranslationStrategy2[MissingTranslationStrategy2["Error"] = 0] = "Error";
      MissingTranslationStrategy2[MissingTranslationStrategy2["Warning"] = 1] = "Warning";
      MissingTranslationStrategy2[MissingTranslationStrategy2["Ignore"] = 2] = "Ignore";
    })(MissingTranslationStrategy || (MissingTranslationStrategy = {}));
  }
});

// node_modules/@angular/core/fesm2022/resource.mjs
function untracked2(nonReactiveReadsFn) {
  return untracked(nonReactiveReadsFn);
}
function computed(computation, options) {
  const getter = createComputed(computation, options?.equal);
  if (ngDevMode) {
    getter.toString = () => `[Computed: ${getter()}]`;
    getter[SIGNAL].debugName = options?.debugName;
  }
  return getter;
}
function effect(effectFn, options) {
  ngDevMode && assertNotInReactiveContext(effect, "Call `effect` outside of a reactive context. For example, schedule the effect inside the component constructor.");
  if (ngDevMode && !options?.injector) {
    assertInInjectionContext(effect);
  }
  if (ngDevMode && options?.allowSignalWrites !== void 0) {
    console.warn(`The 'allowSignalWrites' flag is deprecated and no longer impacts effect() (writes are always allowed)`);
  }
  const injector = options?.injector ?? inject2(Injector);
  let destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;
  let node;
  const viewContext = injector.get(ViewContext, null, { optional: true });
  const notifier = injector.get(ChangeDetectionScheduler);
  if (viewContext !== null) {
    node = createViewEffect(viewContext.view, notifier, effectFn);
    if (destroyRef instanceof NodeInjectorDestroyRef && destroyRef._lView === viewContext.view) {
      destroyRef = null;
    }
  } else {
    node = createRootEffect(effectFn, injector.get(EffectScheduler), notifier);
  }
  node.injector = injector;
  if (destroyRef !== null) {
    node.onDestroyFn = destroyRef.onDestroy(() => node.destroy());
  }
  const effectRef = new EffectRefImpl(node);
  if (ngDevMode) {
    node.debugName = options?.debugName ?? "";
    const prevInjectorProfilerContext = setInjectorProfilerContext({ injector, token: null });
    try {
      emitEffectCreatedEvent(effectRef);
    } finally {
      setInjectorProfilerContext(prevInjectorProfilerContext);
    }
  }
  return effectRef;
}
function createViewEffect(view, notifier, fn) {
  const node = Object.create(VIEW_EFFECT_NODE);
  node.view = view;
  node.zone = typeof Zone !== "undefined" ? Zone.current : null;
  node.notifier = notifier;
  node.fn = fn;
  view[EFFECTS] ??= /* @__PURE__ */ new Set();
  view[EFFECTS].add(node);
  node.consumerMarkedDirty(node);
  return node;
}
function createRootEffect(fn, scheduler, notifier) {
  const node = Object.create(ROOT_EFFECT_NODE);
  node.fn = fn;
  node.scheduler = scheduler;
  node.notifier = notifier;
  node.zone = typeof Zone !== "undefined" ? Zone.current : null;
  node.scheduler.add(node);
  node.notifier.notify(
    12
    /* NotificationSource.RootEffect */
  );
  return node;
}
function linkedSignal(optionsOrComputation, options) {
  if (typeof optionsOrComputation === "function") {
    const getter = createLinkedSignal(optionsOrComputation, identityFn, options?.equal);
    return upgradeLinkedSignalGetter(getter);
  } else {
    const getter = createLinkedSignal(optionsOrComputation.source, optionsOrComputation.computation, optionsOrComputation.equal);
    return upgradeLinkedSignalGetter(getter);
  }
}
function upgradeLinkedSignalGetter(getter) {
  if (ngDevMode) {
    getter.toString = () => `[LinkedSignal: ${getter()}]`;
  }
  const node = getter[SIGNAL];
  const upgradedGetter = getter;
  upgradedGetter.set = (newValue) => linkedSignalSetFn(node, newValue);
  upgradedGetter.update = (updateFn) => linkedSignalUpdateFn(node, updateFn);
  upgradedGetter.asReadonly = signalAsReadonlyFn.bind(getter);
  return upgradedGetter;
}
function projectStatusOfState(state) {
  switch (state.status) {
    case "loading":
      return state.extRequest.reload === 0 ? "loading" : "reloading";
    case "resolved":
      return isResolved(state.stream()) ? "resolved" : "error";
    default:
      return state.status;
  }
}
function isResolved(state) {
  return state.error === void 0;
}
function encapsulateResourceError(error) {
  if (error instanceof Error) {
    return error;
  }
  return new ResourceWrappedError(error);
}
var OutputEmitterRef, EffectRefImpl, BASE_EFFECT_NODE, ROOT_EFFECT_NODE, VIEW_EFFECT_NODE, identityFn, RESOURCE_VALUE_THROWS_ERRORS_DEFAULT, BaseWritableResource, ResourceImpl, ResourceValueError, ResourceWrappedError;
var init_resource = __esm({
  "node_modules/@angular/core/fesm2022/resource.mjs"() {
    "use strict";
    init_root_effect_scheduler();
    init_signal();
    init_untracked();
    OutputEmitterRef = class {
      destroyed = false;
      listeners = null;
      errorHandler = inject2(ErrorHandler, { optional: true });
      /** @internal */
      destroyRef = inject2(DestroyRef);
      constructor() {
        this.destroyRef.onDestroy(() => {
          this.destroyed = true;
          this.listeners = null;
        });
      }
      subscribe(callback) {
        if (this.destroyed) {
          throw new RuntimeError(953, ngDevMode && "Unexpected subscription to destroyed `OutputRef`. The owning directive/component is destroyed.");
        }
        (this.listeners ??= []).push(callback);
        return {
          unsubscribe: () => {
            const idx = this.listeners?.indexOf(callback);
            if (idx !== void 0 && idx !== -1) {
              this.listeners?.splice(idx, 1);
            }
          }
        };
      }
      /** Emits a new value to the output. */
      emit(value) {
        if (this.destroyed) {
          console.warn(formatRuntimeError(953, ngDevMode && "Unexpected emit for destroyed `OutputRef`. The owning directive/component is destroyed."));
          return;
        }
        if (this.listeners === null) {
          return;
        }
        const previousConsumer = setActiveConsumer(null);
        try {
          for (const listenerFn of this.listeners) {
            try {
              listenerFn(value);
            } catch (err) {
              this.errorHandler?.handleError(err);
            }
          }
        } finally {
          setActiveConsumer(previousConsumer);
        }
      }
    };
    EffectRefImpl = class {
      [SIGNAL];
      constructor(node) {
        this[SIGNAL] = node;
      }
      destroy() {
        this[SIGNAL].destroy();
      }
    };
    BASE_EFFECT_NODE = /* @__PURE__ */ (() => __spreadProps(__spreadValues({}, REACTIVE_NODE), {
      consumerIsAlwaysLive: true,
      consumerAllowSignalWrites: true,
      dirty: true,
      hasRun: false,
      cleanupFns: void 0,
      zone: null,
      kind: "effect",
      onDestroyFn: noop2,
      run() {
        this.dirty = false;
        if (ngDevMode && isInNotificationPhase()) {
          throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);
        }
        if (this.hasRun && !consumerPollProducersForChange(this)) {
          return;
        }
        this.hasRun = true;
        const registerCleanupFn = (cleanupFn) => (this.cleanupFns ??= []).push(cleanupFn);
        const prevNode = consumerBeforeComputation(this);
        const prevRefreshingViews = setIsRefreshingViews(false);
        try {
          this.maybeCleanup();
          this.fn(registerCleanupFn);
        } finally {
          setIsRefreshingViews(prevRefreshingViews);
          consumerAfterComputation(this, prevNode);
        }
      },
      maybeCleanup() {
        if (!this.cleanupFns?.length) {
          return;
        }
        const prevConsumer = setActiveConsumer(null);
        try {
          while (this.cleanupFns.length) {
            this.cleanupFns.pop()();
          }
        } finally {
          this.cleanupFns = [];
          setActiveConsumer(prevConsumer);
        }
      }
    }))();
    ROOT_EFFECT_NODE = /* @__PURE__ */ (() => __spreadProps(__spreadValues({}, BASE_EFFECT_NODE), {
      consumerMarkedDirty() {
        this.scheduler.schedule(this);
        this.notifier.notify(
          12
          /* NotificationSource.RootEffect */
        );
      },
      destroy() {
        consumerDestroy(this);
        this.onDestroyFn();
        this.maybeCleanup();
        this.scheduler.remove(this);
      }
    }))();
    VIEW_EFFECT_NODE = /* @__PURE__ */ (() => __spreadProps(__spreadValues({}, BASE_EFFECT_NODE), {
      consumerMarkedDirty() {
        this.view[FLAGS] |= 8192;
        markAncestorsForTraversal(this.view);
        this.notifier.notify(
          13
          /* NotificationSource.ViewEffect */
        );
      },
      destroy() {
        consumerDestroy(this);
        this.onDestroyFn();
        this.maybeCleanup();
        this.view[EFFECTS]?.delete(this);
      }
    }))();
    identityFn = (v) => v;
    RESOURCE_VALUE_THROWS_ERRORS_DEFAULT = true;
    BaseWritableResource = class {
      value;
      constructor(value) {
        this.value = value;
        this.value.set = this.set.bind(this);
        this.value.update = this.update.bind(this);
        this.value.asReadonly = signalAsReadonlyFn;
      }
      isError = computed(() => this.status() === "error");
      update(updateFn) {
        this.set(updateFn(untracked2(this.value)));
      }
      isLoading = computed(() => this.status() === "loading" || this.status() === "reloading");
      // Use a computed here to avoid triggering reactive consumers if the value changes while staying
      // either defined or undefined.
      isValueDefined = computed(() => {
        if (this.isError()) {
          return false;
        }
        return this.value() !== void 0;
      });
      hasValue() {
        return this.isValueDefined();
      }
      asReadonly() {
        return this;
      }
    };
    ResourceImpl = class extends BaseWritableResource {
      loaderFn;
      equal;
      pendingTasks;
      /**
       * The current state of the resource. Status, value, and error are derived from this.
       */
      state;
      /**
       * Combines the current request with a reload counter which allows the resource to be reloaded on
       * imperative command.
       */
      extRequest;
      effectRef;
      pendingController;
      resolvePendingTask = void 0;
      destroyed = false;
      unregisterOnDestroy;
      constructor(request, loaderFn, defaultValue, equal, injector, throwErrorsFromValue = RESOURCE_VALUE_THROWS_ERRORS_DEFAULT) {
        super(
          // Feed a computed signal for the value to `BaseWritableResource`, which will upgrade it to a
          // `WritableSignal` that delegates to `ResourceImpl.set`.
          computed(() => {
            const streamValue = this.state().stream?.();
            if (!streamValue) {
              return defaultValue;
            }
            if (this.state().status === "loading" && this.error()) {
              return defaultValue;
            }
            if (!isResolved(streamValue)) {
              if (throwErrorsFromValue) {
                throw new ResourceValueError(this.error());
              } else {
                return defaultValue;
              }
            }
            return streamValue.value;
          }, { equal })
        );
        this.loaderFn = loaderFn;
        this.equal = equal;
        this.extRequest = linkedSignal({
          source: request,
          computation: (request2) => ({ request: request2, reload: 0 })
        });
        this.state = linkedSignal({
          // Whenever the request changes,
          source: this.extRequest,
          // Compute the state of the resource given a change in status.
          computation: (extRequest, previous) => {
            const status = extRequest.request === void 0 ? "idle" : "loading";
            if (!previous) {
              return {
                extRequest,
                status,
                previousStatus: "idle",
                stream: void 0
              };
            } else {
              return {
                extRequest,
                status,
                previousStatus: projectStatusOfState(previous.value),
                // If the request hasn't changed, keep the previous stream.
                stream: previous.value.extRequest.request === extRequest.request ? previous.value.stream : void 0
              };
            }
          }
        });
        this.effectRef = effect(this.loadEffect.bind(this), {
          injector,
          manualCleanup: true
        });
        this.pendingTasks = injector.get(PendingTasks);
        this.unregisterOnDestroy = injector.get(DestroyRef).onDestroy(() => this.destroy());
      }
      status = computed(() => projectStatusOfState(this.state()));
      error = computed(() => {
        const stream = this.state().stream?.();
        return stream && !isResolved(stream) ? stream.error : void 0;
      });
      /**
       * Called either directly via `WritableResource.set` or via `.value.set()`.
       */
      set(value) {
        if (this.destroyed) {
          return;
        }
        const error = untracked2(this.error);
        const state = untracked2(this.state);
        if (!error) {
          const current = untracked2(this.value);
          if (state.status === "local" && (this.equal ? this.equal(current, value) : current === value)) {
            return;
          }
        }
        this.state.set({
          extRequest: state.extRequest,
          status: "local",
          previousStatus: "local",
          stream: signal({ value })
        });
        this.abortInProgressLoad();
      }
      reload() {
        const { status } = untracked2(this.state);
        if (status === "idle" || status === "loading") {
          return false;
        }
        this.extRequest.update(({ request, reload }) => ({ request, reload: reload + 1 }));
        return true;
      }
      destroy() {
        this.destroyed = true;
        this.unregisterOnDestroy();
        this.effectRef.destroy();
        this.abortInProgressLoad();
        this.state.set({
          extRequest: { request: void 0, reload: 0 },
          status: "idle",
          previousStatus: "idle",
          stream: void 0
        });
      }
      loadEffect() {
        return __async(this, null, function* () {
          const extRequest = this.extRequest();
          const { status: currentStatus, previousStatus } = untracked2(this.state);
          if (extRequest.request === void 0) {
            return;
          } else if (currentStatus !== "loading") {
            return;
          }
          this.abortInProgressLoad();
          let resolvePendingTask = this.resolvePendingTask = this.pendingTasks.add();
          const { signal: abortSignal } = this.pendingController = new AbortController();
          try {
            const stream = yield untracked2(() => {
              return this.loaderFn({
                params: extRequest.request,
                // TODO(alxhub): cleanup after g3 removal of `request` alias.
                request: extRequest.request,
                abortSignal,
                previous: {
                  status: previousStatus
                }
              });
            });
            if (abortSignal.aborted || untracked2(this.extRequest) !== extRequest) {
              return;
            }
            this.state.set({
              extRequest,
              status: "resolved",
              previousStatus: "resolved",
              stream
            });
          } catch (err) {
            if (abortSignal.aborted || untracked2(this.extRequest) !== extRequest) {
              return;
            }
            this.state.set({
              extRequest,
              status: "resolved",
              previousStatus: "error",
              stream: signal({ error: encapsulateResourceError(err) })
            });
          } finally {
            resolvePendingTask?.();
            resolvePendingTask = void 0;
          }
        });
      }
      abortInProgressLoad() {
        untracked2(() => this.pendingController?.abort());
        this.pendingController = void 0;
        this.resolvePendingTask?.();
        this.resolvePendingTask = void 0;
      }
    };
    ResourceValueError = class extends Error {
      constructor(error) {
        super(ngDevMode ? `Resource is currently in an error state (see Error.cause for details): ${error.message}` : error.message, { cause: error });
      }
    };
    ResourceWrappedError = class extends Error {
      constructor(error) {
        super(ngDevMode ? `Resource returned an error that's not an Error instance: ${String(error)}. Check this error's .cause for the actual error.` : String(error), { cause: error });
      }
    };
  }
});

// node_modules/@angular/core/fesm2022/core.mjs
function createInputSignal(initialValue, options) {
  const node = Object.create(INPUT_SIGNAL_NODE);
  node.value = initialValue;
  node.transformFn = options?.transform;
  function inputValueFn() {
    producerAccessed(node);
    if (node.value === REQUIRED_UNSET_VALUE) {
      let message = null;
      if (ngDevMode) {
        const name2 = options?.debugName ?? options?.alias;
        message = `Input${name2 ? ` "${name2}"` : ""} is required but no value is available yet.`;
      }
      throw new RuntimeError(-950, message);
    }
    return node.value;
  }
  inputValueFn[SIGNAL] = node;
  if (ngDevMode) {
    inputValueFn.toString = () => `[Input Signal: ${inputValueFn()}]`;
    node.debugName = options?.debugName;
  }
  return inputValueFn;
}
function getDevModeNodeName(tNode) {
  if (tNode.type & 8) {
    return "an <ng-container>";
  } else if (tNode.type & 4) {
    return "an <ng-template>";
  } else if (tNode.type & 128) {
    return "an @let declaration";
  } else {
    return "a node";
  }
}
function inputFunction(initialValue, opts) {
  ngDevMode && assertInInjectionContext(input);
  return createInputSignal(initialValue, opts);
}
function inputRequiredFunction(opts) {
  ngDevMode && assertInInjectionContext(input);
  return createInputSignal(REQUIRED_UNSET_VALUE, opts);
}
function viewChildFn(locator, opts) {
  ngDevMode && assertInInjectionContext(viewChild);
  return createSingleResultOptionalQuerySignalFn(opts);
}
function viewChildRequiredFn(locator, opts) {
  ngDevMode && assertInInjectionContext(viewChild);
  return createSingleResultRequiredQuerySignalFn(opts);
}
function contentChildFn(locator, opts) {
  ngDevMode && assertInInjectionContext(contentChild);
  return createSingleResultOptionalQuerySignalFn(opts);
}
function contentChildRequiredFn(locator, opts) {
  ngDevMode && assertInInjectionContext(contentChildren);
  return createSingleResultRequiredQuerySignalFn(opts);
}
function contentChildren(locator, opts) {
  return createMultiResultQuerySignalFn(opts);
}
function createModelSignal(initialValue, opts) {
  const node = Object.create(INPUT_SIGNAL_NODE);
  const emitterRef = new OutputEmitterRef();
  node.value = initialValue;
  function getter() {
    producerAccessed(node);
    assertModelSet(node.value);
    return node.value;
  }
  getter[SIGNAL] = node;
  getter.asReadonly = signalAsReadonlyFn.bind(getter);
  getter.set = (newValue) => {
    if (!node.equal(node.value, newValue)) {
      signalSetFn(node, newValue);
      emitterRef.emit(newValue);
    }
  };
  getter.update = (updateFn) => {
    assertModelSet(node.value);
    getter.set(updateFn(node.value));
  };
  getter.subscribe = emitterRef.subscribe.bind(emitterRef);
  getter.destroyRef = emitterRef.destroyRef;
  if (ngDevMode) {
    getter.toString = () => `[Model Signal: ${getter()}]`;
    node.debugName = opts?.debugName;
  }
  return getter;
}
function assertModelSet(value) {
  if (value === REQUIRED_UNSET_VALUE) {
    throw new RuntimeError(952, ngDevMode && "Model is required but no value is available yet.");
  }
}
function modelFunction(initialValue, opts) {
  ngDevMode && assertInInjectionContext(model);
  return createModelSignal(initialValue, opts);
}
function modelRequiredFunction(opts) {
  ngDevMode && assertInInjectionContext(model);
  return createModelSignal(REQUIRED_UNSET_VALUE, opts);
}
function compileNgModuleFactory(injector, options, moduleType) {
  ngDevMode && assertNgModuleType(moduleType);
  const moduleFactory = new NgModuleFactory2(moduleType);
  if (true) {
    return Promise.resolve(moduleFactory);
  }
  const compilerOptions = injector.get(COMPILER_OPTIONS, []).concat(options);
  setJitOptions({
    defaultEncapsulation: _lastDefined(compilerOptions.map((opts) => opts.defaultEncapsulation)),
    preserveWhitespaces: _lastDefined(compilerOptions.map((opts) => opts.preserveWhitespaces))
  });
  if (isComponentResourceResolutionQueueEmpty()) {
    return Promise.resolve(moduleFactory);
  }
  const compilerProviders = compilerOptions.flatMap((option) => option.providers ?? []);
  if (compilerProviders.length === 0) {
    return Promise.resolve(moduleFactory);
  }
  const compiler = getCompilerFacade({
    usage: 0,
    kind: "NgModule",
    type: moduleType
  });
  const compilerInjector = Injector.create({ providers: compilerProviders });
  const resourceLoader = compilerInjector.get(compiler.ResourceLoader);
  return resolveComponentResources((url) => Promise.resolve(resourceLoader.get(url))).then(() => moduleFactory);
}
function _lastDefined(args) {
  for (let i = args.length - 1; i >= 0; i--) {
    if (args[i] !== void 0) {
      return args[i];
    }
  }
  return void 0;
}
function logLazyLCPWarning(src) {
  console.warn(formatRuntimeError(-913, `An image with src ${src} is the Largest Contentful Paint (LCP) element but was given a "loading" value of "lazy", which can negatively impact application loading performance. This warning can be addressed by changing the loading value of the LCP image to "eager", or by using the NgOptimizedImage directive's prioritization utilities. For more information about addressing or disabling this warning, see https://angular.dev/errors/NG0913`));
}
function logOversizedImageWarning(src) {
  console.warn(formatRuntimeError(-913, `An image with src ${src} has intrinsic file dimensions much larger than its rendered size. This can negatively impact application loading performance. For more information about addressing or disabling this warning, see https://angular.dev/errors/NG0913`));
}
function isApplicationBootstrapConfig(config3) {
  return !config3.moduleRef;
}
function bootstrap(config3) {
  const envInjector = isApplicationBootstrapConfig(config3) ? config3.r3Injector : config3.moduleRef.injector;
  const ngZone = envInjector.get(NgZone);
  return ngZone.run(() => {
    if (isApplicationBootstrapConfig(config3)) {
      config3.r3Injector.resolveInjectorInitializers();
    } else {
      config3.moduleRef.resolveInjectorInitializers();
    }
    const exceptionHandler = envInjector.get(INTERNAL_APPLICATION_ERROR_HANDLER);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (envInjector.get(PROVIDED_ZONELESS) && envInjector.get(PROVIDED_NG_ZONE)) {
        throw new RuntimeError(408, "Invalid change detection configuration: provideZoneChangeDetection and provideZonelessChangeDetection cannot be used together.");
      }
    }
    let onErrorSubscription;
    ngZone.runOutsideAngular(() => {
      onErrorSubscription = ngZone.onError.subscribe({
        next: exceptionHandler
      });
    });
    if (isApplicationBootstrapConfig(config3)) {
      const destroyListener = () => envInjector.destroy();
      const onPlatformDestroyListeners = config3.platformInjector.get(PLATFORM_DESTROY_LISTENERS);
      onPlatformDestroyListeners.add(destroyListener);
      envInjector.onDestroy(() => {
        onErrorSubscription.unsubscribe();
        onPlatformDestroyListeners.delete(destroyListener);
      });
    } else {
      const destroyListener = () => config3.moduleRef.destroy();
      const onPlatformDestroyListeners = config3.platformInjector.get(PLATFORM_DESTROY_LISTENERS);
      onPlatformDestroyListeners.add(destroyListener);
      config3.moduleRef.onDestroy(() => {
        remove(config3.allPlatformModules, config3.moduleRef);
        onErrorSubscription.unsubscribe();
        onPlatformDestroyListeners.delete(destroyListener);
      });
    }
    return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {
      const pendingTasks = envInjector.get(PendingTasksInternal);
      const taskId = pendingTasks.add();
      const initStatus = envInjector.get(ApplicationInitStatus);
      initStatus.runInitializers();
      return initStatus.donePromise.then(() => {
        const localeId = envInjector.get(LOCALE_ID, DEFAULT_LOCALE_ID);
        setLocaleId(localeId || DEFAULT_LOCALE_ID);
        const enableRootComponentBoostrap = envInjector.get(ENABLE_ROOT_COMPONENT_BOOTSTRAP, true);
        if (!enableRootComponentBoostrap) {
          if (isApplicationBootstrapConfig(config3)) {
            return envInjector.get(ApplicationRef);
          }
          config3.allPlatformModules.push(config3.moduleRef);
          return config3.moduleRef;
        }
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          const imagePerformanceService = envInjector.get(ImagePerformanceWarning);
          imagePerformanceService.start();
        }
        if (isApplicationBootstrapConfig(config3)) {
          const appRef = envInjector.get(ApplicationRef);
          if (config3.rootComponent !== void 0) {
            appRef.bootstrap(config3.rootComponent);
          }
          return appRef;
        } else {
          moduleBootstrapImpl?.(config3.moduleRef, config3.allPlatformModules);
          return config3.moduleRef;
        }
      }).finally(() => void pendingTasks.remove(taskId));
    });
  });
}
function setModuleBootstrapImpl() {
  moduleBootstrapImpl = _moduleDoBootstrap;
}
function _moduleDoBootstrap(moduleRef, allPlatformModules) {
  const appRef = moduleRef.injector.get(ApplicationRef);
  if (moduleRef._bootstrapComponents.length > 0) {
    moduleRef._bootstrapComponents.forEach((f) => appRef.bootstrap(f));
  } else if (moduleRef.instance.ngDoBootstrap) {
    moduleRef.instance.ngDoBootstrap(appRef);
  } else {
    throw new RuntimeError(-403, ngDevMode && `The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);
  }
  allPlatformModules.push(moduleRef);
}
function _callAndReportToErrorHandler(errorHandler2, ngZone, callback) {
  try {
    const result = callback();
    if (isPromise2(result)) {
      return result.catch((e) => {
        ngZone.runOutsideAngular(() => errorHandler2(e));
        throw e;
      });
    }
    return result;
  } catch (e) {
    ngZone.runOutsideAngular(() => errorHandler2(e));
    throw e;
  }
}
function createPlatform(injector) {
  if (_platformInjector && !_platformInjector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
    throw new RuntimeError(400, ngDevMode && "There can be only one platform. Destroy the previous one to create a new one.");
  }
  publishDefaultGlobalUtils();
  publishSignalConfiguration();
  _platformInjector = injector;
  const platform = injector.get(PlatformRef);
  runPlatformInitializers(injector);
  return platform;
}
function createPlatformFactory(parentPlatformFactory, name2, providers = []) {
  const desc = `Platform: ${name2}`;
  const marker = new InjectionToken(desc);
  return (extraProviders = []) => {
    let platform = getPlatform();
    if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
      const platformProviders = [
        ...providers,
        ...extraProviders,
        { provide: marker, useValue: true }
      ];
      if (parentPlatformFactory) {
        parentPlatformFactory(platformProviders);
      } else {
        createPlatform(createPlatformInjector(platformProviders, desc));
      }
    }
    return assertPlatform(marker);
  };
}
function createPlatformInjector(providers = [], name2) {
  return Injector.create({
    name: name2,
    providers: [
      { provide: INJECTOR_SCOPE, useValue: "platform" },
      { provide: PLATFORM_DESTROY_LISTENERS, useValue: /* @__PURE__ */ new Set([() => _platformInjector = null]) },
      ...providers
    ]
  });
}
function assertPlatform(requiredToken) {
  const platform = getPlatform();
  if (!platform) {
    throw new RuntimeError(401, ngDevMode && "No platform exists!");
  }
  if ((typeof ngDevMode === "undefined" || ngDevMode) && !platform.injector.get(requiredToken, null)) {
    throw new RuntimeError(400, "A platform with a different configuration has been created. Please destroy it first.");
  }
  return platform;
}
function getPlatform() {
  return _platformInjector?.get(PlatformRef) ?? null;
}
function createOrReusePlatformInjector(providers = []) {
  if (_platformInjector)
    return _platformInjector;
  publishDefaultGlobalUtils();
  const injector = createPlatformInjector(providers);
  _platformInjector = injector;
  publishSignalConfiguration();
  runPlatformInitializers(injector);
  return injector;
}
function runPlatformInitializers(injector) {
  const inits = injector.get(PLATFORM_INITIALIZER, null);
  runInInjectionContext(injector, () => {
    inits?.forEach((init) => init());
  });
}
function injectChangeDetectorRef(flags) {
  return createViewRef(
    getCurrentTNode(),
    getLView(),
    (flags & 16) === 16
    /* InternalInjectFlags.ForPipe */
  );
}
function createViewRef(tNode, lView, isPipe2) {
  if (isComponentHost(tNode) && !isPipe2) {
    const componentView = getComponentLViewByIndex(tNode.index, lView);
    return new ViewRef(componentView, componentView);
  } else if (tNode.type & (3 | 12 | 32 | 128)) {
    const hostComponentView = lView[DECLARATION_COMPONENT_VIEW];
    return new ViewRef(hostComponentView, lView);
  }
  return null;
}
function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
  const previousIndex = item.previousIndex;
  if (previousIndex === null)
    return previousIndex;
  let moveOffset = 0;
  if (moveOffsets && previousIndex < moveOffsets.length) {
    moveOffset = moveOffsets[previousIndex];
  }
  return previousIndex + addRemoveOffset + moveOffset;
}
function defaultIterableDiffersFactory() {
  return new IterableDiffers([new DefaultIterableDifferFactory()]);
}
function getTypeNameForDebugging(type) {
  return type["name"] || typeof type;
}
function defaultKeyValueDiffersFactory() {
  return new KeyValueDiffers([new DefaultKeyValueDifferFactory()]);
}
function internalCreateApplication(config3) {
  profiler(
    8
    /* ProfilerEvent.BootstrapApplicationStart */
  );
  try {
    const { rootComponent, appProviders, platformProviders } = config3;
    if ((typeof ngDevMode === "undefined" || ngDevMode) && rootComponent !== void 0) {
      assertStandaloneComponentType(rootComponent);
    }
    const platformInjector = createOrReusePlatformInjector(platformProviders);
    const allAppProviders = [
      internalProvideZoneChangeDetection({}),
      { provide: ChangeDetectionScheduler, useExisting: ChangeDetectionSchedulerImpl },
      errorHandlerEnvironmentInitializer,
      ...appProviders || []
    ];
    const adapter = new EnvironmentNgModuleRefAdapter({
      providers: allAppProviders,
      parent: platformInjector,
      debugName: typeof ngDevMode === "undefined" || ngDevMode ? "Environment Injector" : "",
      // We skip environment initializers because we need to run them inside the NgZone, which
      // happens after we get the NgZone instance from the Injector.
      runEnvironmentInitializers: false
    });
    return bootstrap({
      r3Injector: adapter.injector,
      platformInjector,
      rootComponent
    });
  } catch (e) {
    return Promise.reject(e);
  } finally {
    profiler(
      9
      /* ProfilerEvent.BootstrapApplicationEnd */
    );
  }
}
function booleanAttribute(value) {
  return typeof value === "boolean" ? value : value != null && value !== "false";
}
function numberAttribute(value, fallbackValue = NaN) {
  const isNumberValue = !isNaN(parseFloat(value)) && !isNaN(Number(value));
  return isNumberValue ? Number(value) : fallbackValue;
}
function createComponent(component, options) {
  ngDevMode && assertComponentDef(component);
  const componentDef = getComponentDef(component);
  const elementInjector = options.elementInjector || getNullInjector();
  const factory = new ComponentFactory2(componentDef);
  return factory.create(elementInjector, options.projectableNodes, options.hostElement, options.environmentInjector, options.directives, options.bindings);
}
function reflectComponentType(component) {
  const componentDef = getComponentDef(component);
  if (!componentDef)
    return null;
  const factory = new ComponentFactory2(componentDef);
  return {
    get selector() {
      return factory.selector;
    },
    get type() {
      return factory.componentType;
    },
    get inputs() {
      return factory.inputs;
    },
    get outputs() {
      return factory.outputs;
    },
    get ngContentSelectors() {
      return factory.ngContentSelectors;
    },
    get isStandalone() {
      return componentDef.standalone;
    },
    get isSignal() {
      return componentDef.signals;
    }
  };
}
var REQUIRED_UNSET_VALUE, INPUT_SIGNAL_NODE, FactoryTarget, R3TemplateDependencyKind, ViewEncapsulation2, HostAttributeToken, HOST_TAG_NAME, input, viewChild, contentChild, model, emitDistinctChangesOnlyDefaultValue, Query, ContentChildren, ContentChild, ViewChildren, ViewChild, Version, VERSION, SCAN_DELAY, OVERSIZED_IMAGE_TOLERANCE, ImagePerformanceWarning, PLATFORM_DESTROY_LISTENERS, ENABLE_ROOT_COMPONENT_BOOTSTRAP, moduleBootstrapImpl, PlatformRef, _platformInjector, ALLOW_MULTIPLE_PLATFORMS, ChangeDetectorRef, DefaultIterableDifferFactory, trackByIdentity, DefaultIterableDiffer, IterableChangeRecord_, _DuplicateItemRecordList, _DuplicateMap, DefaultKeyValueDifferFactory, DefaultKeyValueDiffer, KeyValueChangeRecord_, IterableDiffers, KeyValueDiffers, keyValDiff, iterableDiff, defaultIterableDiffers, defaultKeyValueDiffers, platformCore, ApplicationModule, REQUEST, RESPONSE_INIT, REQUEST_CONTEXT;
var init_core = __esm({
  "node_modules/@angular/core/fesm2022/core.mjs"() {
    "use strict";
    init_root_effect_scheduler();
    init_root_effect_scheduler();
    init_signal();
    init_debug_node();
    init_debug_node();
    init_resource();
    init_resource();
    REQUIRED_UNSET_VALUE = /* @__PURE__ */ Symbol("InputSignalNode#UNSET");
    INPUT_SIGNAL_NODE = /* @__PURE__ */ (() => {
      return __spreadProps(__spreadValues({}, SIGNAL_NODE), {
        transformFn: void 0,
        applyValueToInputSignal(node, value) {
          signalSetFn(node, value);
        }
      });
    })();
    (function(FactoryTarget2) {
      FactoryTarget2[FactoryTarget2["Directive"] = 0] = "Directive";
      FactoryTarget2[FactoryTarget2["Component"] = 1] = "Component";
      FactoryTarget2[FactoryTarget2["Injectable"] = 2] = "Injectable";
      FactoryTarget2[FactoryTarget2["Pipe"] = 3] = "Pipe";
      FactoryTarget2[FactoryTarget2["NgModule"] = 4] = "NgModule";
    })(FactoryTarget || (FactoryTarget = {}));
    (function(R3TemplateDependencyKind2) {
      R3TemplateDependencyKind2[R3TemplateDependencyKind2["Directive"] = 0] = "Directive";
      R3TemplateDependencyKind2[R3TemplateDependencyKind2["Pipe"] = 1] = "Pipe";
      R3TemplateDependencyKind2[R3TemplateDependencyKind2["NgModule"] = 2] = "NgModule";
    })(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));
    (function(ViewEncapsulation3) {
      ViewEncapsulation3[ViewEncapsulation3["Emulated"] = 0] = "Emulated";
      ViewEncapsulation3[ViewEncapsulation3["None"] = 2] = "None";
      ViewEncapsulation3[ViewEncapsulation3["ShadowDom"] = 3] = "ShadowDom";
    })(ViewEncapsulation2 || (ViewEncapsulation2 = {}));
    HostAttributeToken = class {
      attributeName;
      constructor(attributeName) {
        this.attributeName = attributeName;
      }
      /** @internal */
      __NG_ELEMENT_ID__ = () => \u0275\u0275injectAttribute(this.attributeName);
      toString() {
        return `HostAttributeToken ${this.attributeName}`;
      }
    };
    HOST_TAG_NAME = new InjectionToken(ngDevMode ? "HOST_TAG_NAME" : "");
    HOST_TAG_NAME.__NG_ELEMENT_ID__ = (flags) => {
      const tNode = getCurrentTNode();
      if (tNode === null) {
        throw new RuntimeError(204, ngDevMode && "HOST_TAG_NAME can only be injected in directives and components during construction time (in a class constructor or as a class field initializer)");
      }
      if (tNode.type & 2) {
        return tNode.value;
      }
      if (flags & 8) {
        return null;
      }
      throw new RuntimeError(204, ngDevMode && `HOST_TAG_NAME was used on ${getDevModeNodeName(tNode)} which doesn't have an underlying element in the DOM. This is invalid, and so the dependency should be marked as optional.`);
    };
    input = (() => {
      inputFunction.required = inputRequiredFunction;
      return inputFunction;
    })();
    viewChild = (() => {
      viewChildFn.required = viewChildRequiredFn;
      return viewChildFn;
    })();
    contentChild = (() => {
      contentChildFn.required = contentChildRequiredFn;
      return contentChildFn;
    })();
    model = (() => {
      modelFunction.required = modelRequiredFunction;
      return modelFunction;
    })();
    emitDistinctChangesOnlyDefaultValue = true;
    Query = class {
    };
    ContentChildren = makePropDecorator("ContentChildren", (selector, opts = {}) => __spreadValues({
      selector,
      first: false,
      isViewQuery: false,
      descendants: false,
      emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue
    }, opts), Query);
    ContentChild = makePropDecorator("ContentChild", (selector, opts = {}) => __spreadValues({
      selector,
      first: true,
      isViewQuery: false,
      descendants: true
    }, opts), Query);
    ViewChildren = makePropDecorator("ViewChildren", (selector, opts = {}) => __spreadValues({
      selector,
      first: false,
      isViewQuery: true,
      descendants: true,
      emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue
    }, opts), Query);
    ViewChild = makePropDecorator("ViewChild", (selector, opts) => __spreadValues({
      selector,
      first: true,
      isViewQuery: true,
      descendants: true
    }, opts), Query);
    Version = class {
      full;
      major;
      minor;
      patch;
      constructor(full) {
        this.full = full;
        const parts = full.split(".");
        this.major = parts[0];
        this.minor = parts[1];
        this.patch = parts.slice(2).join(".");
      }
    };
    VERSION = new Version("20.1.7");
    SCAN_DELAY = 200;
    OVERSIZED_IMAGE_TOLERANCE = 1200;
    ImagePerformanceWarning = class _ImagePerformanceWarning {
      // Map of full image URLs -> original `ngSrc` values.
      window = null;
      observer = null;
      options = inject2(IMAGE_CONFIG);
      lcpImageUrl;
      start() {
        if (typeof PerformanceObserver === "undefined" || this.options?.disableImageSizeWarning && this.options?.disableImageLazyLoadWarning) {
          return;
        }
        this.observer = this.initPerformanceObserver();
        const doc2 = getDocument();
        const win = doc2.defaultView;
        if (win) {
          this.window = win;
          const waitToScan = () => {
            setTimeout(this.scanImages.bind(this), SCAN_DELAY);
          };
          const setup = () => {
            if (doc2.readyState === "complete") {
              waitToScan();
            } else {
              this.window?.addEventListener("load", waitToScan, { once: true });
            }
          };
          if (typeof Zone !== "undefined") {
            Zone.root.run(() => setup());
          } else {
            setup();
          }
        }
      }
      ngOnDestroy() {
        this.observer?.disconnect();
      }
      initPerformanceObserver() {
        if (typeof PerformanceObserver === "undefined") {
          return null;
        }
        const observer = new PerformanceObserver((entryList) => {
          const entries = entryList.getEntries();
          if (entries.length === 0)
            return;
          const lcpElement = entries[entries.length - 1];
          const imgSrc = lcpElement.element?.src ?? "";
          if (imgSrc.startsWith("data:") || imgSrc.startsWith("blob:"))
            return;
          this.lcpImageUrl = imgSrc;
        });
        observer.observe({ type: "largest-contentful-paint", buffered: true });
        return observer;
      }
      scanImages() {
        const images = getDocument().querySelectorAll("img");
        let lcpElementFound, lcpElementLoadedCorrectly = false;
        for (let index = 0; index < images.length; index++) {
          const image = images[index];
          if (!image) {
            continue;
          }
          if (!this.options?.disableImageSizeWarning) {
            if (!image.getAttribute("ng-img") && this.isOversized(image)) {
              logOversizedImageWarning(image.src);
            }
          }
          if (!this.options?.disableImageLazyLoadWarning && this.lcpImageUrl) {
            if (image.src === this.lcpImageUrl) {
              lcpElementFound = true;
              if (image.loading !== "lazy" || image.getAttribute("ng-img")) {
                lcpElementLoadedCorrectly = true;
              }
            }
          }
        }
        if (lcpElementFound && !lcpElementLoadedCorrectly && this.lcpImageUrl && !this.options?.disableImageLazyLoadWarning) {
          logLazyLCPWarning(this.lcpImageUrl);
        }
      }
      isOversized(image) {
        if (!this.window) {
          return false;
        }
        const nonOversizedImageExtentions = [
          // SVG images are vector-based, which means they can scale
          // to any size without losing quality.
          ".svg"
        ];
        const imageSource = (image.src || "").toLowerCase();
        if (nonOversizedImageExtentions.some((extension) => imageSource.endsWith(extension))) {
          return false;
        }
        const computedStyle = this.window.getComputedStyle(image);
        let renderedWidth = parseFloat(computedStyle.getPropertyValue("width"));
        let renderedHeight = parseFloat(computedStyle.getPropertyValue("height"));
        const boxSizing = computedStyle.getPropertyValue("box-sizing");
        const objectFit = computedStyle.getPropertyValue("object-fit");
        if (objectFit === `cover`) {
          return false;
        }
        if (boxSizing === "border-box") {
          const paddingTop = computedStyle.getPropertyValue("padding-top");
          const paddingRight = computedStyle.getPropertyValue("padding-right");
          const paddingBottom = computedStyle.getPropertyValue("padding-bottom");
          const paddingLeft = computedStyle.getPropertyValue("padding-left");
          renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);
          renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);
        }
        const intrinsicWidth = image.naturalWidth;
        const intrinsicHeight = image.naturalHeight;
        const recommendedWidth = this.window.devicePixelRatio * renderedWidth;
        const recommendedHeight = this.window.devicePixelRatio * renderedHeight;
        const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE;
        const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE;
        return oversizedWidth || oversizedHeight;
      }
      static \u0275fac = function ImagePerformanceWarning_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ImagePerformanceWarning)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ImagePerformanceWarning, factory: _ImagePerformanceWarning.\u0275fac, providedIn: "root" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ImagePerformanceWarning, [{
        type: Injectable,
        args: [{ providedIn: "root" }]
      }], null, null);
    })();
    PLATFORM_DESTROY_LISTENERS = new InjectionToken(ngDevMode ? "PlatformDestroyListeners" : "");
    ENABLE_ROOT_COMPONENT_BOOTSTRAP = new InjectionToken(ngDevMode ? "ENABLE_ROOT_COMPONENT_BOOTSTRAP" : "");
    PlatformRef = class _PlatformRef {
      _injector;
      _modules = [];
      _destroyListeners = [];
      _destroyed = false;
      /** @internal */
      constructor(_injector) {
        this._injector = _injector;
      }
      /**
       * Creates an instance of an `@NgModule` for the given platform.
       *
       * @deprecated Passing NgModule factories as the `PlatformRef.bootstrapModuleFactory` function
       *     argument is deprecated. Use the `PlatformRef.bootstrapModule` API instead.
       */
      bootstrapModuleFactory(moduleFactory, options) {
        const scheduleInRootZone = options?.scheduleInRootZone;
        const ngZoneFactory = () => getNgZone(options?.ngZone, __spreadProps(__spreadValues({}, getNgZoneOptions({
          eventCoalescing: options?.ngZoneEventCoalescing,
          runCoalescing: options?.ngZoneRunCoalescing
        })), {
          scheduleInRootZone
        }));
        const ignoreChangesOutsideZone = options?.ignoreChangesOutsideZone;
        const allAppProviders = [
          internalProvideZoneChangeDetection({
            ngZoneFactory,
            ignoreChangesOutsideZone
          }),
          { provide: ChangeDetectionScheduler, useExisting: ChangeDetectionSchedulerImpl },
          errorHandlerEnvironmentInitializer
        ];
        const moduleRef = createNgModuleRefWithProviders(moduleFactory.moduleType, this.injector, allAppProviders);
        setModuleBootstrapImpl();
        return bootstrap({
          moduleRef,
          allPlatformModules: this._modules,
          platformInjector: this.injector
        });
      }
      /**
       * Creates an instance of an `@NgModule` for a given platform.
       *
       * @usageNotes
       * ### Simple Example
       *
       * ```ts
       * @NgModule({
       *   imports: [BrowserModule]
       * })
       * class MyModule {}
       *
       * let moduleRef = platformBrowser().bootstrapModule(MyModule);
       * ```
       *
       */
      bootstrapModule(moduleType, compilerOptions = []) {
        const options = optionsReducer({}, compilerOptions);
        setModuleBootstrapImpl();
        return compileNgModuleFactory(this.injector, options, moduleType).then((moduleFactory) => this.bootstrapModuleFactory(moduleFactory, options));
      }
      /**
       * Registers a listener to be called when the platform is destroyed.
       */
      onDestroy(callback) {
        this._destroyListeners.push(callback);
      }
      /**
       * Retrieves the platform {@link Injector}, which is the parent injector for
       * every Angular application on the page and provides singleton providers.
       */
      get injector() {
        return this._injector;
      }
      /**
       * Destroys the current Angular platform and all Angular applications on the page.
       * Destroys all modules and listeners registered with the platform.
       */
      destroy() {
        if (this._destroyed) {
          throw new RuntimeError(404, ngDevMode && "The platform has already been destroyed!");
        }
        this._modules.slice().forEach((module) => module.destroy());
        this._destroyListeners.forEach((listener) => listener());
        const destroyListeners = this._injector.get(PLATFORM_DESTROY_LISTENERS, null);
        if (destroyListeners) {
          destroyListeners.forEach((listener) => listener());
          destroyListeners.clear();
        }
        this._destroyed = true;
      }
      /**
       * Indicates whether this instance was destroyed.
       */
      get destroyed() {
        return this._destroyed;
      }
      static \u0275fac = function PlatformRef_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _PlatformRef)(\u0275\u0275inject(Injector));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _PlatformRef, factory: _PlatformRef.\u0275fac, providedIn: "platform" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformRef, [{
        type: Injectable,
        args: [{ providedIn: "platform" }]
      }], () => [{ type: Injector }], null);
    })();
    _platformInjector = null;
    ALLOW_MULTIPLE_PLATFORMS = new InjectionToken(ngDevMode ? "AllowMultipleToken" : "");
    ChangeDetectorRef = class {
      /**
       * @internal
       * @nocollapse
       */
      static __NG_ELEMENT_ID__ = injectChangeDetectorRef;
    };
    DefaultIterableDifferFactory = class {
      constructor() {
      }
      supports(obj) {
        return isListLikeIterable(obj);
      }
      create(trackByFn) {
        return new DefaultIterableDiffer(trackByFn);
      }
    };
    trackByIdentity = (index, item) => item;
    DefaultIterableDiffer = class {
      length = 0;
      // TODO: confirm the usage of `collection` as it's unused, readonly and on a non public API.
      collection;
      // Keeps track of the used records at any point in time (during & across `_check()` calls)
      _linkedRecords = null;
      // Keeps track of the removed records at any point in time during `_check()` calls.
      _unlinkedRecords = null;
      _previousItHead = null;
      _itHead = null;
      _itTail = null;
      _additionsHead = null;
      _additionsTail = null;
      _movesHead = null;
      _movesTail = null;
      _removalsHead = null;
      _removalsTail = null;
      // Keeps track of records where custom track by is the same, but item identity has changed
      _identityChangesHead = null;
      _identityChangesTail = null;
      _trackByFn;
      constructor(trackByFn) {
        this._trackByFn = trackByFn || trackByIdentity;
      }
      forEachItem(fn) {
        let record;
        for (record = this._itHead; record !== null; record = record._next) {
          fn(record);
        }
      }
      forEachOperation(fn) {
        let nextIt = this._itHead;
        let nextRemove = this._removalsHead;
        let addRemoveOffset = 0;
        let moveOffsets = null;
        while (nextIt || nextRemove) {
          const record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove;
          const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
          const currentIndex = record.currentIndex;
          if (record === nextRemove) {
            addRemoveOffset--;
            nextRemove = nextRemove._nextRemoved;
          } else {
            nextIt = nextIt._next;
            if (record.previousIndex == null) {
              addRemoveOffset++;
            } else {
              if (!moveOffsets)
                moveOffsets = [];
              const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
              const localCurrentIndex = currentIndex - addRemoveOffset;
              if (localMovePreviousIndex != localCurrentIndex) {
                for (let i = 0; i < localMovePreviousIndex; i++) {
                  const offset = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0;
                  const index = offset + i;
                  if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                    moveOffsets[i] = offset + 1;
                  }
                }
                const previousIndex = record.previousIndex;
                moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
              }
            }
          }
          if (adjPreviousIndex !== currentIndex) {
            fn(record, adjPreviousIndex, currentIndex);
          }
        }
      }
      forEachPreviousItem(fn) {
        let record;
        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
          fn(record);
        }
      }
      forEachAddedItem(fn) {
        let record;
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
          fn(record);
        }
      }
      forEachMovedItem(fn) {
        let record;
        for (record = this._movesHead; record !== null; record = record._nextMoved) {
          fn(record);
        }
      }
      forEachRemovedItem(fn) {
        let record;
        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
          fn(record);
        }
      }
      forEachIdentityChange(fn) {
        let record;
        for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
          fn(record);
        }
      }
      diff(collection) {
        if (collection == null)
          collection = [];
        if (!isListLikeIterable(collection)) {
          throw new RuntimeError(900, ngDevMode && `Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`);
        }
        if (this.check(collection)) {
          return this;
        } else {
          return null;
        }
      }
      onDestroy() {
      }
      check(collection) {
        this._reset();
        let record = this._itHead;
        let mayBeDirty = false;
        let index;
        let item;
        let itemTrackBy;
        if (Array.isArray(collection)) {
          this.length = collection.length;
          for (let index2 = 0; index2 < this.length; index2++) {
            item = collection[index2];
            itemTrackBy = this._trackByFn(index2, item);
            if (record === null || !Object.is(record.trackById, itemTrackBy)) {
              record = this._mismatch(record, item, itemTrackBy, index2);
              mayBeDirty = true;
            } else {
              if (mayBeDirty) {
                record = this._verifyReinsertion(record, item, itemTrackBy, index2);
              }
              if (!Object.is(record.item, item))
                this._addIdentityChange(record, item);
            }
            record = record._next;
          }
        } else {
          index = 0;
          iterateListLike(collection, (item2) => {
            itemTrackBy = this._trackByFn(index, item2);
            if (record === null || !Object.is(record.trackById, itemTrackBy)) {
              record = this._mismatch(record, item2, itemTrackBy, index);
              mayBeDirty = true;
            } else {
              if (mayBeDirty) {
                record = this._verifyReinsertion(record, item2, itemTrackBy, index);
              }
              if (!Object.is(record.item, item2))
                this._addIdentityChange(record, item2);
            }
            record = record._next;
            index++;
          });
          this.length = index;
        }
        this._truncate(record);
        this.collection = collection;
        return this.isDirty;
      }
      /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity
       * changes.
       */
      get isDirty() {
        return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
      }
      /**
       * Reset the state of the change objects to show no changes. This means set previousKey to
       * currentKey, and clear all of the queues (additions, moves, removals).
       * Set the previousIndexes of moved and added items to their currentIndexes
       * Reset the list of additions, moves and removals
       *
       * @internal
       */
      _reset() {
        if (this.isDirty) {
          let record;
          for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
            record._nextPrevious = record._next;
          }
          for (record = this._additionsHead; record !== null; record = record._nextAdded) {
            record.previousIndex = record.currentIndex;
          }
          this._additionsHead = this._additionsTail = null;
          for (record = this._movesHead; record !== null; record = record._nextMoved) {
            record.previousIndex = record.currentIndex;
          }
          this._movesHead = this._movesTail = null;
          this._removalsHead = this._removalsTail = null;
          this._identityChangesHead = this._identityChangesTail = null;
        }
      }
      /**
       * This is the core function which handles differences between collections.
       *
       * - `record` is the record which we saw at this position last time. If null then it is a new
       *   item.
       * - `item` is the current item in the collection
       * - `index` is the position of the item in the collection
       *
       * @internal
       */
      _mismatch(record, item, itemTrackBy, index) {
        let previousRecord;
        if (record === null) {
          previousRecord = this._itTail;
        } else {
          previousRecord = record._prev;
          this._remove(record);
        }
        record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
        if (record !== null) {
          if (!Object.is(record.item, item))
            this._addIdentityChange(record, item);
          this._reinsertAfter(record, previousRecord, index);
        } else {
          record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
          if (record !== null) {
            if (!Object.is(record.item, item))
              this._addIdentityChange(record, item);
            this._moveAfter(record, previousRecord, index);
          } else {
            record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
          }
        }
        return record;
      }
      /**
       * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
       *
       * Use case: `[a, a]` => `[b, a, a]`
       *
       * If we did not have this check then the insertion of `b` would:
       *   1) evict first `a`
       *   2) insert `b` at `0` index.
       *   3) leave `a` at index `1` as is. <-- this is wrong!
       *   3) reinsert `a` at index 2. <-- this is wrong!
       *
       * The correct behavior is:
       *   1) evict first `a`
       *   2) insert `b` at `0` index.
       *   3) reinsert `a` at index 1.
       *   3) move `a` at from `1` to `2`.
       *
       *
       * Double check that we have not evicted a duplicate item. We need to check if the item type may
       * have already been removed:
       * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
       * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
       * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
       * at the end.
       *
       * @internal
       */
      _verifyReinsertion(record, item, itemTrackBy, index) {
        let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
        if (reinsertRecord !== null) {
          record = this._reinsertAfter(reinsertRecord, record._prev, index);
        } else if (record.currentIndex != index) {
          record.currentIndex = index;
          this._addToMoves(record, index);
        }
        return record;
      }
      /**
       * Get rid of any excess {@link IterableChangeRecord_}s from the previous collection
       *
       * - `record` The first excess {@link IterableChangeRecord_}.
       *
       * @internal
       */
      _truncate(record) {
        while (record !== null) {
          const nextRecord = record._next;
          this._addToRemovals(this._unlink(record));
          record = nextRecord;
        }
        if (this._unlinkedRecords !== null) {
          this._unlinkedRecords.clear();
        }
        if (this._additionsTail !== null) {
          this._additionsTail._nextAdded = null;
        }
        if (this._movesTail !== null) {
          this._movesTail._nextMoved = null;
        }
        if (this._itTail !== null) {
          this._itTail._next = null;
        }
        if (this._removalsTail !== null) {
          this._removalsTail._nextRemoved = null;
        }
        if (this._identityChangesTail !== null) {
          this._identityChangesTail._nextIdentityChange = null;
        }
      }
      /** @internal */
      _reinsertAfter(record, prevRecord, index) {
        if (this._unlinkedRecords !== null) {
          this._unlinkedRecords.remove(record);
        }
        const prev = record._prevRemoved;
        const next = record._nextRemoved;
        if (prev === null) {
          this._removalsHead = next;
        } else {
          prev._nextRemoved = next;
        }
        if (next === null) {
          this._removalsTail = prev;
        } else {
          next._prevRemoved = prev;
        }
        this._insertAfter(record, prevRecord, index);
        this._addToMoves(record, index);
        return record;
      }
      /** @internal */
      _moveAfter(record, prevRecord, index) {
        this._unlink(record);
        this._insertAfter(record, prevRecord, index);
        this._addToMoves(record, index);
        return record;
      }
      /** @internal */
      _addAfter(record, prevRecord, index) {
        this._insertAfter(record, prevRecord, index);
        if (this._additionsTail === null) {
          this._additionsTail = this._additionsHead = record;
        } else {
          this._additionsTail = this._additionsTail._nextAdded = record;
        }
        return record;
      }
      /** @internal */
      _insertAfter(record, prevRecord, index) {
        const next = prevRecord === null ? this._itHead : prevRecord._next;
        record._next = next;
        record._prev = prevRecord;
        if (next === null) {
          this._itTail = record;
        } else {
          next._prev = record;
        }
        if (prevRecord === null) {
          this._itHead = record;
        } else {
          prevRecord._next = record;
        }
        if (this._linkedRecords === null) {
          this._linkedRecords = new _DuplicateMap();
        }
        this._linkedRecords.put(record);
        record.currentIndex = index;
        return record;
      }
      /** @internal */
      _remove(record) {
        return this._addToRemovals(this._unlink(record));
      }
      /** @internal */
      _unlink(record) {
        if (this._linkedRecords !== null) {
          this._linkedRecords.remove(record);
        }
        const prev = record._prev;
        const next = record._next;
        if (prev === null) {
          this._itHead = next;
        } else {
          prev._next = next;
        }
        if (next === null) {
          this._itTail = prev;
        } else {
          next._prev = prev;
        }
        return record;
      }
      /** @internal */
      _addToMoves(record, toIndex) {
        if (record.previousIndex === toIndex) {
          return record;
        }
        if (this._movesTail === null) {
          this._movesTail = this._movesHead = record;
        } else {
          this._movesTail = this._movesTail._nextMoved = record;
        }
        return record;
      }
      _addToRemovals(record) {
        if (this._unlinkedRecords === null) {
          this._unlinkedRecords = new _DuplicateMap();
        }
        this._unlinkedRecords.put(record);
        record.currentIndex = null;
        record._nextRemoved = null;
        if (this._removalsTail === null) {
          this._removalsTail = this._removalsHead = record;
          record._prevRemoved = null;
        } else {
          record._prevRemoved = this._removalsTail;
          this._removalsTail = this._removalsTail._nextRemoved = record;
        }
        return record;
      }
      /** @internal */
      _addIdentityChange(record, item) {
        record.item = item;
        if (this._identityChangesTail === null) {
          this._identityChangesTail = this._identityChangesHead = record;
        } else {
          this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
        }
        return record;
      }
    };
    IterableChangeRecord_ = class {
      item;
      trackById;
      currentIndex = null;
      previousIndex = null;
      /** @internal */
      _nextPrevious = null;
      /** @internal */
      _prev = null;
      /** @internal */
      _next = null;
      /** @internal */
      _prevDup = null;
      /** @internal */
      _nextDup = null;
      /** @internal */
      _prevRemoved = null;
      /** @internal */
      _nextRemoved = null;
      /** @internal */
      _nextAdded = null;
      /** @internal */
      _nextMoved = null;
      /** @internal */
      _nextIdentityChange = null;
      constructor(item, trackById) {
        this.item = item;
        this.trackById = trackById;
      }
    };
    _DuplicateItemRecordList = class {
      /** @internal */
      _head = null;
      /** @internal */
      _tail = null;
      /**
       * Append the record to the list of duplicates.
       *
       * Note: by design all records in the list of duplicates hold the same value in record.item.
       */
      add(record) {
        if (this._head === null) {
          this._head = this._tail = record;
          record._nextDup = null;
          record._prevDup = null;
        } else {
          this._tail._nextDup = record;
          record._prevDup = this._tail;
          record._nextDup = null;
          this._tail = record;
        }
      }
      // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and
      // IterableChangeRecord_.currentIndex >= atOrAfterIndex
      get(trackById, atOrAfterIndex) {
        let record;
        for (record = this._head; record !== null; record = record._nextDup) {
          if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) && Object.is(record.trackById, trackById)) {
            return record;
          }
        }
        return null;
      }
      /**
       * Remove one {@link IterableChangeRecord_} from the list of duplicates.
       *
       * Returns whether the list of duplicates is empty.
       */
      remove(record) {
        const prev = record._prevDup;
        const next = record._nextDup;
        if (prev === null) {
          this._head = next;
        } else {
          prev._nextDup = next;
        }
        if (next === null) {
          this._tail = prev;
        } else {
          next._prevDup = prev;
        }
        return this._head === null;
      }
    };
    _DuplicateMap = class {
      map = /* @__PURE__ */ new Map();
      put(record) {
        const key = record.trackById;
        let duplicates = this.map.get(key);
        if (!duplicates) {
          duplicates = new _DuplicateItemRecordList();
          this.map.set(key, duplicates);
        }
        duplicates.add(record);
      }
      /**
       * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we
       * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.
       *
       * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
       * have any more `a`s needs to return the second `a`.
       */
      get(trackById, atOrAfterIndex) {
        const key = trackById;
        const recordList = this.map.get(key);
        return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
      }
      /**
       * Removes a {@link IterableChangeRecord_} from the list of duplicates.
       *
       * The list of duplicates also is removed from the map if it gets empty.
       */
      remove(record) {
        const key = record.trackById;
        const recordList = this.map.get(key);
        if (recordList.remove(record)) {
          this.map.delete(key);
        }
        return record;
      }
      get isEmpty() {
        return this.map.size === 0;
      }
      clear() {
        this.map.clear();
      }
    };
    DefaultKeyValueDifferFactory = class {
      constructor() {
      }
      supports(obj) {
        return obj instanceof Map || isJsObject(obj);
      }
      create() {
        return new DefaultKeyValueDiffer();
      }
    };
    DefaultKeyValueDiffer = class {
      _records = /* @__PURE__ */ new Map();
      _mapHead = null;
      // _appendAfter is used in the check loop
      _appendAfter = null;
      _previousMapHead = null;
      _changesHead = null;
      _changesTail = null;
      _additionsHead = null;
      _additionsTail = null;
      _removalsHead = null;
      _removalsTail = null;
      get isDirty() {
        return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
      }
      forEachItem(fn) {
        let record;
        for (record = this._mapHead; record !== null; record = record._next) {
          fn(record);
        }
      }
      forEachPreviousItem(fn) {
        let record;
        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
          fn(record);
        }
      }
      forEachChangedItem(fn) {
        let record;
        for (record = this._changesHead; record !== null; record = record._nextChanged) {
          fn(record);
        }
      }
      forEachAddedItem(fn) {
        let record;
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
          fn(record);
        }
      }
      forEachRemovedItem(fn) {
        let record;
        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
          fn(record);
        }
      }
      diff(map2) {
        if (!map2) {
          map2 = /* @__PURE__ */ new Map();
        } else if (!(map2 instanceof Map || isJsObject(map2))) {
          throw new RuntimeError(900, ngDevMode && `Error trying to diff '${stringify(map2)}'. Only maps and objects are allowed`);
        }
        return this.check(map2) ? this : null;
      }
      onDestroy() {
      }
      /**
       * Check the current state of the map vs the previous.
       * The algorithm is optimised for when the keys do no change.
       */
      check(map2) {
        this._reset();
        let insertBefore = this._mapHead;
        this._appendAfter = null;
        this._forEach(map2, (value, key) => {
          if (insertBefore && insertBefore.key === key) {
            this._maybeAddToChanges(insertBefore, value);
            this._appendAfter = insertBefore;
            insertBefore = insertBefore._next;
          } else {
            const record = this._getOrCreateRecordForKey(key, value);
            insertBefore = this._insertBeforeOrAppend(insertBefore, record);
          }
        });
        if (insertBefore) {
          if (insertBefore._prev) {
            insertBefore._prev._next = null;
          }
          this._removalsHead = insertBefore;
          for (let record = insertBefore; record !== null; record = record._nextRemoved) {
            if (record === this._mapHead) {
              this._mapHead = null;
            }
            this._records.delete(record.key);
            record._nextRemoved = record._next;
            record.previousValue = record.currentValue;
            record.currentValue = null;
            record._prev = null;
            record._next = null;
          }
        }
        if (this._changesTail)
          this._changesTail._nextChanged = null;
        if (this._additionsTail)
          this._additionsTail._nextAdded = null;
        return this.isDirty;
      }
      /**
       * Inserts a record before `before` or append at the end of the list when `before` is null.
       *
       * Notes:
       * - This method appends at `this._appendAfter`,
       * - This method updates `this._appendAfter`,
       * - The return value is the new value for the insertion pointer.
       */
      _insertBeforeOrAppend(before, record) {
        if (before) {
          const prev = before._prev;
          record._next = before;
          record._prev = prev;
          before._prev = record;
          if (prev) {
            prev._next = record;
          }
          if (before === this._mapHead) {
            this._mapHead = record;
          }
          this._appendAfter = before;
          return before;
        }
        if (this._appendAfter) {
          this._appendAfter._next = record;
          record._prev = this._appendAfter;
        } else {
          this._mapHead = record;
        }
        this._appendAfter = record;
        return null;
      }
      _getOrCreateRecordForKey(key, value) {
        if (this._records.has(key)) {
          const record2 = this._records.get(key);
          this._maybeAddToChanges(record2, value);
          const prev = record2._prev;
          const next = record2._next;
          if (prev) {
            prev._next = next;
          }
          if (next) {
            next._prev = prev;
          }
          record2._next = null;
          record2._prev = null;
          return record2;
        }
        const record = new KeyValueChangeRecord_(key);
        this._records.set(key, record);
        record.currentValue = value;
        this._addToAdditions(record);
        return record;
      }
      /** @internal */
      _reset() {
        if (this.isDirty) {
          let record;
          this._previousMapHead = this._mapHead;
          for (record = this._previousMapHead; record !== null; record = record._next) {
            record._nextPrevious = record._next;
          }
          for (record = this._changesHead; record !== null; record = record._nextChanged) {
            record.previousValue = record.currentValue;
          }
          for (record = this._additionsHead; record != null; record = record._nextAdded) {
            record.previousValue = record.currentValue;
          }
          this._changesHead = this._changesTail = null;
          this._additionsHead = this._additionsTail = null;
          this._removalsHead = null;
        }
      }
      // Add the record or a given key to the list of changes only when the value has actually changed
      _maybeAddToChanges(record, newValue) {
        if (!Object.is(newValue, record.currentValue)) {
          record.previousValue = record.currentValue;
          record.currentValue = newValue;
          this._addToChanges(record);
        }
      }
      _addToAdditions(record) {
        if (this._additionsHead === null) {
          this._additionsHead = this._additionsTail = record;
        } else {
          this._additionsTail._nextAdded = record;
          this._additionsTail = record;
        }
      }
      _addToChanges(record) {
        if (this._changesHead === null) {
          this._changesHead = this._changesTail = record;
        } else {
          this._changesTail._nextChanged = record;
          this._changesTail = record;
        }
      }
      /** @internal */
      _forEach(obj, fn) {
        if (obj instanceof Map) {
          obj.forEach(fn);
        } else {
          Object.keys(obj).forEach((k) => fn(obj[k], k));
        }
      }
    };
    KeyValueChangeRecord_ = class {
      key;
      previousValue = null;
      currentValue = null;
      /** @internal */
      _nextPrevious = null;
      /** @internal */
      _next = null;
      /** @internal */
      _prev = null;
      /** @internal */
      _nextAdded = null;
      /** @internal */
      _nextRemoved = null;
      /** @internal */
      _nextChanged = null;
      constructor(key) {
        this.key = key;
      }
    };
    IterableDiffers = class _IterableDiffers {
      factories;
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _IterableDiffers,
          providedIn: "root",
          factory: defaultIterableDiffersFactory
        })
      );
      constructor(factories) {
        this.factories = factories;
      }
      static create(factories, parent) {
        if (parent != null) {
          const copied = parent.factories.slice();
          factories = factories.concat(copied);
        }
        return new _IterableDiffers(factories);
      }
      /**
       * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
       * inherited {@link IterableDiffers} instance with the provided factories and return a new
       * {@link IterableDiffers} instance.
       *
       * @usageNotes
       * ### Example
       *
       * The following example shows how to extend an existing list of factories,
       * which will only be applied to the injector for this component and its children.
       * This step is all that's required to make a new {@link IterableDiffer} available.
       *
       * ```ts
       * @Component({
       *   viewProviders: [
       *     IterableDiffers.extend([new ImmutableListDiffer()])
       *   ]
       * })
       * ```
       */
      static extend(factories) {
        return {
          provide: _IterableDiffers,
          useFactory: (parent) => {
            return _IterableDiffers.create(factories, parent || defaultIterableDiffersFactory());
          },
          // Dependency technically isn't optional, but we can provide a better error message this way.
          deps: [[_IterableDiffers, new SkipSelf(), new Optional()]]
        };
      }
      find(iterable) {
        const factory = this.factories.find((f) => f.supports(iterable));
        if (factory != null) {
          return factory;
        } else {
          throw new RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${iterable}' of type '${getTypeNameForDebugging(iterable)}'`);
        }
      }
    };
    KeyValueDiffers = class _KeyValueDiffers {
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _KeyValueDiffers,
          providedIn: "root",
          factory: defaultKeyValueDiffersFactory
        })
      );
      factories;
      constructor(factories) {
        this.factories = factories;
      }
      static create(factories, parent) {
        if (parent) {
          const copied = parent.factories.slice();
          factories = factories.concat(copied);
        }
        return new _KeyValueDiffers(factories);
      }
      /**
       * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
       * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
       * {@link KeyValueDiffers} instance.
       *
       * @usageNotes
       * ### Example
       *
       * The following example shows how to extend an existing list of factories,
       * which will only be applied to the injector for this component and its children.
       * This step is all that's required to make a new {@link KeyValueDiffer} available.
       *
       * ```ts
       * @Component({
       *   viewProviders: [
       *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
       *   ]
       * })
       * ```
       */
      static extend(factories) {
        return {
          provide: _KeyValueDiffers,
          useFactory: (parent) => {
            return _KeyValueDiffers.create(factories, parent || defaultKeyValueDiffersFactory());
          },
          // Dependency technically isn't optional, but we can provide a better error message this way.
          deps: [[_KeyValueDiffers, new SkipSelf(), new Optional()]]
        };
      }
      find(kv) {
        const factory = this.factories.find((f) => f.supports(kv));
        if (factory) {
          return factory;
        }
        throw new RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${kv}'`);
      }
    };
    keyValDiff = [new DefaultKeyValueDifferFactory()];
    iterableDiff = [new DefaultIterableDifferFactory()];
    defaultIterableDiffers = new IterableDiffers(iterableDiff);
    defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
    platformCore = createPlatformFactory(null, "core", []);
    ApplicationModule = class _ApplicationModule {
      // Inject ApplicationRef to make it eager...
      constructor(appRef) {
      }
      static \u0275fac = function ApplicationModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ApplicationModule)(\u0275\u0275inject(ApplicationRef));
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _ApplicationModule });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationModule, [{
        type: NgModule
      }], () => [{ type: ApplicationRef }], null);
    })();
    REQUEST = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "REQUEST" : "", {
      providedIn: "platform",
      factory: () => null
    });
    RESPONSE_INIT = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "RESPONSE_INIT" : "", {
      providedIn: "platform",
      factory: () => null
    });
    REQUEST_CONTEXT = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "REQUEST_CONTEXT" : "", {
      providedIn: "platform",
      factory: () => null
    });
  }
});

// node_modules/@angular/common/fesm2022/location.mjs
function getDOM() {
  return _DOM;
}
function setRootDomAdapter(adapter) {
  _DOM ??= adapter;
}
function joinWithSlash(start, end) {
  if (!start) return end;
  if (!end) return start;
  if (start.endsWith("/")) {
    return end.startsWith("/") ? start + end.slice(1) : start + end;
  }
  return end.startsWith("/") ? start + end : `${start}/${end}`;
}
function stripTrailingSlash(url) {
  const pathEndIdx = url.search(/#|\?|$/);
  return url[pathEndIdx - 1] === "/" ? url.slice(0, pathEndIdx - 1) + url.slice(pathEndIdx) : url;
}
function normalizeQueryParams(params) {
  return params && params[0] !== "?" ? `?${params}` : params;
}
function createLocation() {
  return new Location(\u0275\u0275inject(LocationStrategy));
}
function _stripBasePath(basePath, url) {
  if (!basePath || !url.startsWith(basePath)) {
    return url;
  }
  const strippedUrl = url.substring(basePath.length);
  if (strippedUrl === "" || ["/", ";", "?", "#"].includes(strippedUrl[0])) {
    return strippedUrl;
  }
  return url;
}
function _stripIndexHtml(url) {
  return url.replace(/\/index.html$/, "");
}
function _stripOrigin(baseHref) {
  const isAbsoluteUrl2 = new RegExp("^(https?:)?//").test(baseHref);
  if (isAbsoluteUrl2) {
    const [, pathname] = baseHref.split(/\/\/[^\/]+/);
    return pathname;
  }
  return baseHref;
}
var _DOM, DomAdapter, PlatformLocation, LOCATION_INITIALIZED, BrowserPlatformLocation, LocationStrategy, APP_BASE_HREF, PathLocationStrategy, Location;
var init_location = __esm({
  "node_modules/@angular/common/fesm2022/location.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_esm();
    _DOM = null;
    DomAdapter = class {
    };
    PlatformLocation = class _PlatformLocation {
      historyGo(relativePosition) {
        throw new Error(ngDevMode ? "Not implemented" : "");
      }
      static \u0275fac = function PlatformLocation_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _PlatformLocation)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _PlatformLocation,
        factory: () => (() => inject2(BrowserPlatformLocation))(),
        providedIn: "platform"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformLocation, [{
        type: Injectable,
        args: [{
          providedIn: "platform",
          useFactory: () => inject2(BrowserPlatformLocation)
        }]
      }], null, null);
    })();
    LOCATION_INITIALIZED = new InjectionToken(ngDevMode ? "Location Initialized" : "");
    BrowserPlatformLocation = class _BrowserPlatformLocation extends PlatformLocation {
      _location;
      _history;
      _doc = inject2(DOCUMENT);
      constructor() {
        super();
        this._location = window.location;
        this._history = window.history;
      }
      getBaseHrefFromDOM() {
        return getDOM().getBaseHref(this._doc);
      }
      onPopState(fn) {
        const window2 = getDOM().getGlobalEventTarget(this._doc, "window");
        window2.addEventListener("popstate", fn, false);
        return () => window2.removeEventListener("popstate", fn);
      }
      onHashChange(fn) {
        const window2 = getDOM().getGlobalEventTarget(this._doc, "window");
        window2.addEventListener("hashchange", fn, false);
        return () => window2.removeEventListener("hashchange", fn);
      }
      get href() {
        return this._location.href;
      }
      get protocol() {
        return this._location.protocol;
      }
      get hostname() {
        return this._location.hostname;
      }
      get port() {
        return this._location.port;
      }
      get pathname() {
        return this._location.pathname;
      }
      get search() {
        return this._location.search;
      }
      get hash() {
        return this._location.hash;
      }
      set pathname(newPath) {
        this._location.pathname = newPath;
      }
      pushState(state, title, url) {
        this._history.pushState(state, title, url);
      }
      replaceState(state, title, url) {
        this._history.replaceState(state, title, url);
      }
      forward() {
        this._history.forward();
      }
      back() {
        this._history.back();
      }
      historyGo(relativePosition = 0) {
        this._history.go(relativePosition);
      }
      getState() {
        return this._history.state;
      }
      static \u0275fac = function BrowserPlatformLocation_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _BrowserPlatformLocation)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _BrowserPlatformLocation,
        factory: () => (() => new _BrowserPlatformLocation())(),
        providedIn: "platform"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserPlatformLocation, [{
        type: Injectable,
        args: [{
          providedIn: "platform",
          useFactory: () => new BrowserPlatformLocation()
        }]
      }], () => [], null);
    })();
    LocationStrategy = class _LocationStrategy {
      historyGo(relativePosition) {
        throw new Error(ngDevMode ? "Not implemented" : "");
      }
      static \u0275fac = function LocationStrategy_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _LocationStrategy)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _LocationStrategy,
        factory: () => (() => inject2(PathLocationStrategy))(),
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocationStrategy, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: () => inject2(PathLocationStrategy)
        }]
      }], null, null);
    })();
    APP_BASE_HREF = new InjectionToken(ngDevMode ? "appBaseHref" : "");
    PathLocationStrategy = class _PathLocationStrategy extends LocationStrategy {
      _platformLocation;
      _baseHref;
      _removeListenerFns = [];
      constructor(_platformLocation, href) {
        super();
        this._platformLocation = _platformLocation;
        this._baseHref = href ?? this._platformLocation.getBaseHrefFromDOM() ?? inject2(DOCUMENT).location?.origin ?? "";
      }
      /** @docs-private */
      ngOnDestroy() {
        while (this._removeListenerFns.length) {
          this._removeListenerFns.pop()();
        }
      }
      onPopState(fn) {
        this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));
      }
      getBaseHref() {
        return this._baseHref;
      }
      prepareExternalUrl(internal) {
        return joinWithSlash(this._baseHref, internal);
      }
      path(includeHash = false) {
        const pathname = this._platformLocation.pathname + normalizeQueryParams(this._platformLocation.search);
        const hash3 = this._platformLocation.hash;
        return hash3 && includeHash ? `${pathname}${hash3}` : pathname;
      }
      pushState(state, title, url, queryParams) {
        const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
        this._platformLocation.pushState(state, title, externalUrl);
      }
      replaceState(state, title, url, queryParams) {
        const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
        this._platformLocation.replaceState(state, title, externalUrl);
      }
      forward() {
        this._platformLocation.forward();
      }
      back() {
        this._platformLocation.back();
      }
      getState() {
        return this._platformLocation.getState();
      }
      historyGo(relativePosition = 0) {
        this._platformLocation.historyGo?.(relativePosition);
      }
      static \u0275fac = function PathLocationStrategy_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _PathLocationStrategy)(\u0275\u0275inject(PlatformLocation), \u0275\u0275inject(APP_BASE_HREF, 8));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _PathLocationStrategy,
        factory: _PathLocationStrategy.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PathLocationStrategy, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [{
        type: PlatformLocation
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [APP_BASE_HREF]
        }]
      }], null);
    })();
    Location = class _Location {
      /** @internal */
      _subject = new Subject();
      /** @internal */
      _basePath;
      /** @internal */
      _locationStrategy;
      /** @internal */
      _urlChangeListeners = [];
      /** @internal */
      _urlChangeSubscription = null;
      constructor(locationStrategy) {
        this._locationStrategy = locationStrategy;
        const baseHref = this._locationStrategy.getBaseHref();
        this._basePath = _stripOrigin(stripTrailingSlash(_stripIndexHtml(baseHref)));
        this._locationStrategy.onPopState((ev) => {
          this._subject.next({
            "url": this.path(true),
            "pop": true,
            "state": ev.state,
            "type": ev.type
          });
        });
      }
      /** @docs-private */
      ngOnDestroy() {
        this._urlChangeSubscription?.unsubscribe();
        this._urlChangeListeners = [];
      }
      /**
       * Normalizes the URL path for this location.
       *
       * @param includeHash True to include an anchor fragment in the path.
       *
       * @returns The normalized URL path.
       */
      // TODO: vsavkin. Remove the boolean flag and always include hash once the deprecated router is
      // removed.
      path(includeHash = false) {
        return this.normalize(this._locationStrategy.path(includeHash));
      }
      /**
       * Reports the current state of the location history.
       * @returns The current value of the `history.state` object.
       */
      getState() {
        return this._locationStrategy.getState();
      }
      /**
       * Normalizes the given path and compares to the current normalized path.
       *
       * @param path The given URL path.
       * @param query Query parameters.
       *
       * @returns True if the given URL path is equal to the current normalized path, false
       * otherwise.
       */
      isCurrentPathEqualTo(path, query = "") {
        return this.path() == this.normalize(path + normalizeQueryParams(query));
      }
      /**
       * Normalizes a URL path by stripping any trailing slashes.
       *
       * @param url String representing a URL.
       *
       * @returns The normalized URL string.
       */
      normalize(url) {
        return _Location.stripTrailingSlash(_stripBasePath(this._basePath, _stripIndexHtml(url)));
      }
      /**
       * Normalizes an external URL path.
       * If the given URL doesn't begin with a leading slash (`'/'`), adds one
       * before normalizing. Adds a hash if `HashLocationStrategy` is
       * in use, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.
       *
       * @param url String representing a URL.
       *
       * @returns  A normalized platform-specific URL.
       */
      prepareExternalUrl(url) {
        if (url && url[0] !== "/") {
          url = "/" + url;
        }
        return this._locationStrategy.prepareExternalUrl(url);
      }
      // TODO: rename this method to pushState
      /**
       * Changes the browser's URL to a normalized version of a given URL, and pushes a
       * new item onto the platform's history.
       *
       * @param path  URL path to normalize.
       * @param query Query parameters.
       * @param state Location history state.
       *
       */
      go(path, query = "", state = null) {
        this._locationStrategy.pushState(state, "", path, query);
        this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
      }
      /**
       * Changes the browser's URL to a normalized version of the given URL, and replaces
       * the top item on the platform's history stack.
       *
       * @param path  URL path to normalize.
       * @param query Query parameters.
       * @param state Location history state.
       */
      replaceState(path, query = "", state = null) {
        this._locationStrategy.replaceState(state, "", path, query);
        this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
      }
      /**
       * Navigates forward in the platform's history.
       */
      forward() {
        this._locationStrategy.forward();
      }
      /**
       * Navigates back in the platform's history.
       */
      back() {
        this._locationStrategy.back();
      }
      /**
       * Navigate to a specific page from session history, identified by its relative position to the
       * current page.
       *
       * @param relativePosition  Position of the target page in the history relative to the current
       *     page.
       * A negative value moves backwards, a positive value moves forwards, e.g. `location.historyGo(2)`
       * moves forward two pages and `location.historyGo(-2)` moves back two pages. When we try to go
       * beyond what's stored in the history session, we stay in the current page. Same behaviour occurs
       * when `relativePosition` equals 0.
       * @see https://developer.mozilla.org/en-US/docs/Web/API/History_API#Moving_to_a_specific_point_in_history
       */
      historyGo(relativePosition = 0) {
        this._locationStrategy.historyGo?.(relativePosition);
      }
      /**
       * Registers a URL change listener. Use to catch updates performed by the Angular
       * framework that are not detectible through "popstate" or "hashchange" events.
       *
       * @param fn The change handler function, which take a URL and a location history state.
       * @returns A function that, when executed, unregisters a URL change listener.
       */
      onUrlChange(fn) {
        this._urlChangeListeners.push(fn);
        this._urlChangeSubscription ??= this.subscribe((v) => {
          this._notifyUrlChangeListeners(v.url, v.state);
        });
        return () => {
          const fnIndex = this._urlChangeListeners.indexOf(fn);
          this._urlChangeListeners.splice(fnIndex, 1);
          if (this._urlChangeListeners.length === 0) {
            this._urlChangeSubscription?.unsubscribe();
            this._urlChangeSubscription = null;
          }
        };
      }
      /** @internal */
      _notifyUrlChangeListeners(url = "", state) {
        this._urlChangeListeners.forEach((fn) => fn(url, state));
      }
      /**
       * Subscribes to the platform's `popState` events.
       *
       * Note: `Location.go()` does not trigger the `popState` event in the browser. Use
       * `Location.onUrlChange()` to subscribe to URL changes instead.
       *
       * @param value Event that is triggered when the state history changes.
       * @param exception The exception to throw.
       *
       * @see [onpopstate](https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate)
       *
       * @returns Subscribed events.
       */
      subscribe(onNext, onThrow, onReturn) {
        return this._subject.subscribe({
          next: onNext,
          error: onThrow ?? void 0,
          complete: onReturn ?? void 0
        });
      }
      /**
       * Normalizes URL parameters by prepending with `?` if needed.
       *
       * @param  params String of URL parameters.
       *
       * @returns The normalized URL parameters string.
       */
      static normalizeQueryParams = normalizeQueryParams;
      /**
       * Joins two parts of a URL with a slash if needed.
       *
       * @param start  URL string
       * @param end    URL string
       *
       *
       * @returns The joined URL string.
       */
      static joinWithSlash = joinWithSlash;
      /**
       * Removes a trailing slash from a URL string if needed.
       * Looks for the first occurrence of either `#`, `?`, or the end of the
       * line as `/` characters and removes the trailing slash if one exists.
       *
       * @param url URL string.
       *
       * @returns The URL string, modified if needed.
       */
      static stripTrailingSlash = stripTrailingSlash;
      static \u0275fac = function Location_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Location)(\u0275\u0275inject(LocationStrategy));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _Location,
        factory: () => createLocation(),
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Location, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          // See #23917
          useFactory: createLocation
        }]
      }], () => [{
        type: LocationStrategy
      }], null);
    })();
  }
});

// node_modules/@angular/common/fesm2022/common_module.mjs
function getLocaleId2(locale) {
  return findLocaleData(locale)[LocaleDataIndex.LocaleId];
}
function getLocaleDayPeriods(locale, formStyle, width) {
  const data2 = findLocaleData(locale);
  const amPmData = [data2[LocaleDataIndex.DayPeriodsFormat], data2[LocaleDataIndex.DayPeriodsStandalone]];
  const amPm = getLastDefinedValue(amPmData, formStyle);
  return getLastDefinedValue(amPm, width);
}
function getLocaleDayNames(locale, formStyle, width) {
  const data2 = findLocaleData(locale);
  const daysData = [data2[LocaleDataIndex.DaysFormat], data2[LocaleDataIndex.DaysStandalone]];
  const days = getLastDefinedValue(daysData, formStyle);
  return getLastDefinedValue(days, width);
}
function getLocaleMonthNames(locale, formStyle, width) {
  const data2 = findLocaleData(locale);
  const monthsData = [data2[LocaleDataIndex.MonthsFormat], data2[LocaleDataIndex.MonthsStandalone]];
  const months = getLastDefinedValue(monthsData, formStyle);
  return getLastDefinedValue(months, width);
}
function getLocaleEraNames(locale, width) {
  const data2 = findLocaleData(locale);
  const erasData = data2[LocaleDataIndex.Eras];
  return getLastDefinedValue(erasData, width);
}
function getLocaleDateFormat(locale, width) {
  const data2 = findLocaleData(locale);
  return getLastDefinedValue(data2[LocaleDataIndex.DateFormat], width);
}
function getLocaleTimeFormat(locale, width) {
  const data2 = findLocaleData(locale);
  return getLastDefinedValue(data2[LocaleDataIndex.TimeFormat], width);
}
function getLocaleDateTimeFormat(locale, width) {
  const data2 = findLocaleData(locale);
  const dateTimeFormatData = data2[LocaleDataIndex.DateTimeFormat];
  return getLastDefinedValue(dateTimeFormatData, width);
}
function getLocaleNumberSymbol(locale, symbol) {
  const data2 = findLocaleData(locale);
  const res = data2[LocaleDataIndex.NumberSymbols][symbol];
  if (typeof res === "undefined") {
    if (symbol === NumberSymbol.CurrencyDecimal) {
      return data2[LocaleDataIndex.NumberSymbols][NumberSymbol.Decimal];
    } else if (symbol === NumberSymbol.CurrencyGroup) {
      return data2[LocaleDataIndex.NumberSymbols][NumberSymbol.Group];
    }
  }
  return res;
}
function getLocaleNumberFormat(locale, type) {
  const data2 = findLocaleData(locale);
  return data2[LocaleDataIndex.NumberFormats][type];
}
function getLocaleCurrencies(locale) {
  const data2 = findLocaleData(locale);
  return data2[LocaleDataIndex.Currencies];
}
function checkFullData(data2) {
  if (!data2[LocaleDataIndex.ExtraData]) {
    throw new RuntimeError(2303, ngDevMode && `Missing extra locale data for the locale "${data2[LocaleDataIndex.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`);
  }
}
function getLocaleExtraDayPeriodRules(locale) {
  const data2 = findLocaleData(locale);
  checkFullData(data2);
  const rules = data2[LocaleDataIndex.ExtraData][
    2
    /* ExtraLocaleDataIndex.ExtraDayPeriodsRules */
  ] || [];
  return rules.map((rule) => {
    if (typeof rule === "string") {
      return extractTime(rule);
    }
    return [extractTime(rule[0]), extractTime(rule[1])];
  });
}
function getLocaleExtraDayPeriods(locale, formStyle, width) {
  const data2 = findLocaleData(locale);
  checkFullData(data2);
  const dayPeriodsData = [data2[LocaleDataIndex.ExtraData][
    0
    /* ExtraLocaleDataIndex.ExtraDayPeriodFormats */
  ], data2[LocaleDataIndex.ExtraData][
    1
    /* ExtraLocaleDataIndex.ExtraDayPeriodStandalone */
  ]];
  const dayPeriods = getLastDefinedValue(dayPeriodsData, formStyle) || [];
  return getLastDefinedValue(dayPeriods, width) || [];
}
function getLastDefinedValue(data2, index) {
  for (let i = index; i > -1; i--) {
    if (typeof data2[i] !== "undefined") {
      return data2[i];
    }
  }
  throw new RuntimeError(2304, ngDevMode && "Locale data API: locale data undefined");
}
function extractTime(time) {
  const [h, m] = time.split(":");
  return {
    hours: +h,
    minutes: +m
  };
}
function getCurrencySymbol(code, format, locale = "en") {
  const currency = getLocaleCurrencies(locale)[code] || CURRENCIES_EN[code] || [];
  const symbolNarrow = currency[
    1
    /* CurrencyIndex.SymbolNarrow */
  ];
  if (format === "narrow" && typeof symbolNarrow === "string") {
    return symbolNarrow;
  }
  return currency[
    0
    /* CurrencyIndex.Symbol */
  ] || code;
}
function getNumberOfCurrencyDigits(code) {
  let digits;
  const currency = CURRENCIES_EN[code];
  if (currency) {
    digits = currency[
      2
      /* CurrencyIndex.NbOfDigits */
    ];
  }
  return typeof digits === "number" ? digits : DEFAULT_NB_OF_CURRENCY_DIGITS;
}
function formatDate(value, format, locale, timezone) {
  let date = toDate(value);
  const namedFormat = getNamedFormat(locale, format);
  format = namedFormat || format;
  let parts = [];
  let match2;
  while (format) {
    match2 = DATE_FORMATS_SPLIT.exec(format);
    if (match2) {
      parts = parts.concat(match2.slice(1));
      const part = parts.pop();
      if (!part) {
        break;
      }
      format = part;
    } else {
      parts.push(format);
      break;
    }
  }
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    assertValidDateFormat(parts);
  }
  let dateTimezoneOffset = date.getTimezoneOffset();
  if (timezone) {
    dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
    date = convertTimezoneToLocal(date, timezone);
  }
  let text = "";
  parts.forEach((value2) => {
    const dateFormatter = getDateFormatter(value2);
    text += dateFormatter ? dateFormatter(date, locale, dateTimezoneOffset) : value2 === "''" ? "'" : value2.replace(/(^'|'$)/g, "").replace(/''/g, "'");
  });
  return text;
}
function assertValidDateFormat(parts) {
  if (parts.some((part) => /^Y+$/.test(part)) && !parts.some((part) => /^w+$/.test(part))) {
    const message = `Suspicious use of week-based year "Y" in date pattern "${parts.join("")}". Did you mean to use calendar year "y" instead?`;
    if (parts.length === 1) {
      console.error(formatRuntimeError(2300, message));
    } else {
      throw new RuntimeError(2300, message);
    }
  }
}
function createDate(year, month, date) {
  const newDate = /* @__PURE__ */ new Date(0);
  newDate.setFullYear(year, month, date);
  newDate.setHours(0, 0, 0);
  return newDate;
}
function getNamedFormat(locale, format) {
  const localeId = getLocaleId2(locale);
  NAMED_FORMATS[localeId] ??= {};
  if (NAMED_FORMATS[localeId][format]) {
    return NAMED_FORMATS[localeId][format];
  }
  let formatValue2 = "";
  switch (format) {
    case "shortDate":
      formatValue2 = getLocaleDateFormat(locale, FormatWidth.Short);
      break;
    case "mediumDate":
      formatValue2 = getLocaleDateFormat(locale, FormatWidth.Medium);
      break;
    case "longDate":
      formatValue2 = getLocaleDateFormat(locale, FormatWidth.Long);
      break;
    case "fullDate":
      formatValue2 = getLocaleDateFormat(locale, FormatWidth.Full);
      break;
    case "shortTime":
      formatValue2 = getLocaleTimeFormat(locale, FormatWidth.Short);
      break;
    case "mediumTime":
      formatValue2 = getLocaleTimeFormat(locale, FormatWidth.Medium);
      break;
    case "longTime":
      formatValue2 = getLocaleTimeFormat(locale, FormatWidth.Long);
      break;
    case "fullTime":
      formatValue2 = getLocaleTimeFormat(locale, FormatWidth.Full);
      break;
    case "short":
      const shortTime = getNamedFormat(locale, "shortTime");
      const shortDate = getNamedFormat(locale, "shortDate");
      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Short), [shortTime, shortDate]);
      break;
    case "medium":
      const mediumTime = getNamedFormat(locale, "mediumTime");
      const mediumDate = getNamedFormat(locale, "mediumDate");
      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Medium), [mediumTime, mediumDate]);
      break;
    case "long":
      const longTime = getNamedFormat(locale, "longTime");
      const longDate = getNamedFormat(locale, "longDate");
      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Long), [longTime, longDate]);
      break;
    case "full":
      const fullTime = getNamedFormat(locale, "fullTime");
      const fullDate = getNamedFormat(locale, "fullDate");
      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Full), [fullTime, fullDate]);
      break;
  }
  if (formatValue2) {
    NAMED_FORMATS[localeId][format] = formatValue2;
  }
  return formatValue2;
}
function formatDateTime(str, opt_values) {
  if (opt_values) {
    str = str.replace(/\{([^}]+)}/g, function(match2, key) {
      return opt_values != null && key in opt_values ? opt_values[key] : match2;
    });
  }
  return str;
}
function padNumber(num, digits, minusSign = "-", trim, negWrap) {
  let neg = "";
  if (num < 0 || negWrap && num <= 0) {
    if (negWrap) {
      num = -num + 1;
    } else {
      num = -num;
      neg = minusSign;
    }
  }
  let strNum = String(num);
  while (strNum.length < digits) {
    strNum = "0" + strNum;
  }
  if (trim) {
    strNum = strNum.slice(strNum.length - digits);
  }
  return neg + strNum;
}
function formatFractionalSeconds(milliseconds, digits) {
  const strMs = padNumber(milliseconds, 3);
  return strMs.substring(0, digits);
}
function dateGetter(name2, size, offset = 0, trim = false, negWrap = false) {
  return function(date, locale) {
    let part = getDatePart(name2, date);
    if (offset > 0 || part > -offset) {
      part += offset;
    }
    if (name2 === 3) {
      if (part === 0 && offset === -12) {
        part = 12;
      }
    } else if (name2 === 6) {
      return formatFractionalSeconds(part, size);
    }
    const localeMinus = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
    return padNumber(part, size, localeMinus, trim, negWrap);
  };
}
function getDatePart(part, date) {
  switch (part) {
    case 0:
      return date.getFullYear();
    case 1:
      return date.getMonth();
    case 2:
      return date.getDate();
    case 3:
      return date.getHours();
    case 4:
      return date.getMinutes();
    case 5:
      return date.getSeconds();
    case 6:
      return date.getMilliseconds();
    case 7:
      return date.getDay();
    default:
      throw new RuntimeError(2301, ngDevMode && `Unknown DateType value "${part}".`);
  }
}
function dateStrGetter(name2, width, form = FormStyle.Format, extended2 = false) {
  return function(date, locale) {
    return getDateTranslation(date, locale, name2, width, form, extended2);
  };
}
function getDateTranslation(date, locale, name2, width, form, extended2) {
  switch (name2) {
    case 2:
      return getLocaleMonthNames(locale, form, width)[date.getMonth()];
    case 1:
      return getLocaleDayNames(locale, form, width)[date.getDay()];
    case 0:
      const currentHours = date.getHours();
      const currentMinutes = date.getMinutes();
      if (extended2) {
        const rules = getLocaleExtraDayPeriodRules(locale);
        const dayPeriods = getLocaleExtraDayPeriods(locale, form, width);
        const index = rules.findIndex((rule) => {
          if (Array.isArray(rule)) {
            const [from2, to] = rule;
            const afterFrom = currentHours >= from2.hours && currentMinutes >= from2.minutes;
            const beforeTo = currentHours < to.hours || currentHours === to.hours && currentMinutes < to.minutes;
            if (from2.hours < to.hours) {
              if (afterFrom && beforeTo) {
                return true;
              }
            } else if (afterFrom || beforeTo) {
              return true;
            }
          } else {
            if (rule.hours === currentHours && rule.minutes === currentMinutes) {
              return true;
            }
          }
          return false;
        });
        if (index !== -1) {
          return dayPeriods[index];
        }
      }
      return getLocaleDayPeriods(locale, form, width)[currentHours < 12 ? 0 : 1];
    case 3:
      return getLocaleEraNames(locale, width)[date.getFullYear() <= 0 ? 0 : 1];
    default:
      const unexpected = name2;
      throw new RuntimeError(2302, ngDevMode && `unexpected translation type ${unexpected}`);
  }
}
function timeZoneGetter(width) {
  return function(date, locale, offset) {
    const zone = -1 * offset;
    const minusSign = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
    const hours = zone > 0 ? Math.floor(zone / 60) : Math.ceil(zone / 60);
    switch (width) {
      case 0:
        return (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + padNumber(Math.abs(zone % 60), 2, minusSign);
      case 1:
        return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours, 1, minusSign);
      case 2:
        return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
      case 3:
        if (offset === 0) {
          return "Z";
        } else {
          return (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
        }
      default:
        throw new RuntimeError(2302, ngDevMode && `Unknown zone width "${width}"`);
    }
  };
}
function getFirstThursdayOfYear(year) {
  const firstDayOfYear = createDate(year, JANUARY, 1).getDay();
  return createDate(year, 0, 1 + (firstDayOfYear <= THURSDAY ? THURSDAY : THURSDAY + 7) - firstDayOfYear);
}
function getThursdayThisIsoWeek(datetime) {
  const currentDay = datetime.getDay();
  const deltaToThursday = currentDay === 0 ? -3 : THURSDAY - currentDay;
  return createDate(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + deltaToThursday);
}
function weekGetter(size, monthBased = false) {
  return function(date, locale) {
    let result;
    if (monthBased) {
      const nbDaysBefore1stDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1).getDay() - 1;
      const today = date.getDate();
      result = 1 + Math.floor((today + nbDaysBefore1stDayOfMonth) / 7);
    } else {
      const thisThurs = getThursdayThisIsoWeek(date);
      const firstThurs = getFirstThursdayOfYear(thisThurs.getFullYear());
      const diff = thisThurs.getTime() - firstThurs.getTime();
      result = 1 + Math.round(diff / 6048e5);
    }
    return padNumber(result, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  };
}
function weekNumberingYearGetter(size, trim = false) {
  return function(date, locale) {
    const thisThurs = getThursdayThisIsoWeek(date);
    const weekNumberingYear = thisThurs.getFullYear();
    return padNumber(weekNumberingYear, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign), trim);
  };
}
function getDateFormatter(format) {
  if (DATE_FORMATS[format]) {
    return DATE_FORMATS[format];
  }
  let formatter;
  switch (format) {
    // Era name (AD/BC)
    case "G":
    case "GG":
    case "GGG":
      formatter = dateStrGetter(3, TranslationWidth.Abbreviated);
      break;
    case "GGGG":
      formatter = dateStrGetter(3, TranslationWidth.Wide);
      break;
    case "GGGGG":
      formatter = dateStrGetter(3, TranslationWidth.Narrow);
      break;
    // 1 digit representation of the year, e.g. (AD 1 => 1, AD 199 => 199)
    case "y":
      formatter = dateGetter(0, 1, 0, false, true);
      break;
    // 2 digit representation of the year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)
    case "yy":
      formatter = dateGetter(0, 2, 0, true, true);
      break;
    // 3 digit representation of the year, padded (000-999). (e.g. AD 2001 => 01, AD 2010 => 10)
    case "yyy":
      formatter = dateGetter(0, 3, 0, false, true);
      break;
    // 4 digit representation of the year (e.g. AD 1 => 0001, AD 2010 => 2010)
    case "yyyy":
      formatter = dateGetter(0, 4, 0, false, true);
      break;
    // 1 digit representation of the week-numbering year, e.g. (AD 1 => 1, AD 199 => 199)
    case "Y":
      formatter = weekNumberingYearGetter(1);
      break;
    // 2 digit representation of the week-numbering year, padded (00-99). (e.g. AD 2001 => 01, AD
    // 2010 => 10)
    case "YY":
      formatter = weekNumberingYearGetter(2, true);
      break;
    // 3 digit representation of the week-numbering year, padded (000-999). (e.g. AD 1 => 001, AD
    // 2010 => 2010)
    case "YYY":
      formatter = weekNumberingYearGetter(3);
      break;
    // 4 digit representation of the week-numbering year (e.g. AD 1 => 0001, AD 2010 => 2010)
    case "YYYY":
      formatter = weekNumberingYearGetter(4);
      break;
    // Month of the year (1-12), numeric
    case "M":
    case "L":
      formatter = dateGetter(1, 1, 1);
      break;
    case "MM":
    case "LL":
      formatter = dateGetter(1, 2, 1);
      break;
    // Month of the year (January, ...), string, format
    case "MMM":
      formatter = dateStrGetter(2, TranslationWidth.Abbreviated);
      break;
    case "MMMM":
      formatter = dateStrGetter(2, TranslationWidth.Wide);
      break;
    case "MMMMM":
      formatter = dateStrGetter(2, TranslationWidth.Narrow);
      break;
    // Month of the year (January, ...), string, standalone
    case "LLL":
      formatter = dateStrGetter(2, TranslationWidth.Abbreviated, FormStyle.Standalone);
      break;
    case "LLLL":
      formatter = dateStrGetter(2, TranslationWidth.Wide, FormStyle.Standalone);
      break;
    case "LLLLL":
      formatter = dateStrGetter(2, TranslationWidth.Narrow, FormStyle.Standalone);
      break;
    // Week of the year (1, ... 52)
    case "w":
      formatter = weekGetter(1);
      break;
    case "ww":
      formatter = weekGetter(2);
      break;
    // Week of the month (1, ...)
    case "W":
      formatter = weekGetter(1, true);
      break;
    // Day of the month (1-31)
    case "d":
      formatter = dateGetter(2, 1);
      break;
    case "dd":
      formatter = dateGetter(2, 2);
      break;
    // Day of the Week StandAlone (1, 1, Mon, Monday, M, Mo)
    case "c":
    case "cc":
      formatter = dateGetter(7, 1);
      break;
    case "ccc":
      formatter = dateStrGetter(1, TranslationWidth.Abbreviated, FormStyle.Standalone);
      break;
    case "cccc":
      formatter = dateStrGetter(1, TranslationWidth.Wide, FormStyle.Standalone);
      break;
    case "ccccc":
      formatter = dateStrGetter(1, TranslationWidth.Narrow, FormStyle.Standalone);
      break;
    case "cccccc":
      formatter = dateStrGetter(1, TranslationWidth.Short, FormStyle.Standalone);
      break;
    // Day of the Week
    case "E":
    case "EE":
    case "EEE":
      formatter = dateStrGetter(1, TranslationWidth.Abbreviated);
      break;
    case "EEEE":
      formatter = dateStrGetter(1, TranslationWidth.Wide);
      break;
    case "EEEEE":
      formatter = dateStrGetter(1, TranslationWidth.Narrow);
      break;
    case "EEEEEE":
      formatter = dateStrGetter(1, TranslationWidth.Short);
      break;
    // Generic period of the day (am-pm)
    case "a":
    case "aa":
    case "aaa":
      formatter = dateStrGetter(0, TranslationWidth.Abbreviated);
      break;
    case "aaaa":
      formatter = dateStrGetter(0, TranslationWidth.Wide);
      break;
    case "aaaaa":
      formatter = dateStrGetter(0, TranslationWidth.Narrow);
      break;
    // Extended period of the day (midnight, at night, ...), standalone
    case "b":
    case "bb":
    case "bbb":
      formatter = dateStrGetter(0, TranslationWidth.Abbreviated, FormStyle.Standalone, true);
      break;
    case "bbbb":
      formatter = dateStrGetter(0, TranslationWidth.Wide, FormStyle.Standalone, true);
      break;
    case "bbbbb":
      formatter = dateStrGetter(0, TranslationWidth.Narrow, FormStyle.Standalone, true);
      break;
    // Extended period of the day (midnight, night, ...), standalone
    case "B":
    case "BB":
    case "BBB":
      formatter = dateStrGetter(0, TranslationWidth.Abbreviated, FormStyle.Format, true);
      break;
    case "BBBB":
      formatter = dateStrGetter(0, TranslationWidth.Wide, FormStyle.Format, true);
      break;
    case "BBBBB":
      formatter = dateStrGetter(0, TranslationWidth.Narrow, FormStyle.Format, true);
      break;
    // Hour in AM/PM, (1-12)
    case "h":
      formatter = dateGetter(3, 1, -12);
      break;
    case "hh":
      formatter = dateGetter(3, 2, -12);
      break;
    // Hour of the day (0-23)
    case "H":
      formatter = dateGetter(3, 1);
      break;
    // Hour in day, padded (00-23)
    case "HH":
      formatter = dateGetter(3, 2);
      break;
    // Minute of the hour (0-59)
    case "m":
      formatter = dateGetter(4, 1);
      break;
    case "mm":
      formatter = dateGetter(4, 2);
      break;
    // Second of the minute (0-59)
    case "s":
      formatter = dateGetter(5, 1);
      break;
    case "ss":
      formatter = dateGetter(5, 2);
      break;
    // Fractional second
    case "S":
      formatter = dateGetter(6, 1);
      break;
    case "SS":
      formatter = dateGetter(6, 2);
      break;
    case "SSS":
      formatter = dateGetter(6, 3);
      break;
    // Timezone ISO8601 short format (-0430)
    case "Z":
    case "ZZ":
    case "ZZZ":
      formatter = timeZoneGetter(
        0
        /* ZoneWidth.Short */
      );
      break;
    // Timezone ISO8601 extended format (-04:30)
    case "ZZZZZ":
      formatter = timeZoneGetter(
        3
        /* ZoneWidth.Extended */
      );
      break;
    // Timezone GMT short format (GMT+4)
    case "O":
    case "OO":
    case "OOO":
    // Should be location, but fallback to format O instead because we don't have the data yet
    case "z":
    case "zz":
    case "zzz":
      formatter = timeZoneGetter(
        1
        /* ZoneWidth.ShortGMT */
      );
      break;
    // Timezone GMT long format (GMT+0430)
    case "OOOO":
    case "ZZZZ":
    // Should be location, but fallback to format O instead because we don't have the data yet
    case "zzzz":
      formatter = timeZoneGetter(
        2
        /* ZoneWidth.Long */
      );
      break;
    default:
      return null;
  }
  DATE_FORMATS[format] = formatter;
  return formatter;
}
function timezoneToOffset(timezone, fallback) {
  timezone = timezone.replace(/:/g, "");
  const requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
  return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
}
function addDateMinutes(date, minutes) {
  date = new Date(date.getTime());
  date.setMinutes(date.getMinutes() + minutes);
  return date;
}
function convertTimezoneToLocal(date, timezone, reverse) {
  const reverseValue = -1;
  const dateTimezoneOffset = date.getTimezoneOffset();
  const timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
  return addDateMinutes(date, reverseValue * (timezoneOffset - dateTimezoneOffset));
}
function toDate(value) {
  if (isDate(value)) {
    return value;
  }
  if (typeof value === "number" && !isNaN(value)) {
    return new Date(value);
  }
  if (typeof value === "string") {
    value = value.trim();
    if (/^(\d{4}(-\d{1,2}(-\d{1,2})?)?)$/.test(value)) {
      const [y, m = 1, d = 1] = value.split("-").map((val) => +val);
      return createDate(y, m - 1, d);
    }
    const parsedNb = parseFloat(value);
    if (!isNaN(value - parsedNb)) {
      return new Date(parsedNb);
    }
    let match2;
    if (match2 = value.match(ISO8601_DATE_REGEX)) {
      return isoStringToDate(match2);
    }
  }
  const date = new Date(value);
  if (!isDate(date)) {
    throw new RuntimeError(2302, ngDevMode && `Unable to convert "${value}" into a date`);
  }
  return date;
}
function isoStringToDate(match2) {
  const date = /* @__PURE__ */ new Date(0);
  let tzHour = 0;
  let tzMin = 0;
  const dateSetter = match2[8] ? date.setUTCFullYear : date.setFullYear;
  const timeSetter = match2[8] ? date.setUTCHours : date.setHours;
  if (match2[9]) {
    tzHour = Number(match2[9] + match2[10]);
    tzMin = Number(match2[9] + match2[11]);
  }
  dateSetter.call(date, Number(match2[1]), Number(match2[2]) - 1, Number(match2[3]));
  const h = Number(match2[4] || 0) - tzHour;
  const m = Number(match2[5] || 0) - tzMin;
  const s = Number(match2[6] || 0);
  const ms = Math.floor(parseFloat("0." + (match2[7] || 0)) * 1e3);
  timeSetter.call(date, h, m, s, ms);
  return date;
}
function isDate(value) {
  return value instanceof Date && !isNaN(value.valueOf());
}
function formatNumberToLocaleString(value, pattern, locale, groupSymbol, decimalSymbol, digitsInfo, isPercent = false) {
  let formattedText = "";
  let isZero = false;
  if (!isFinite(value)) {
    formattedText = getLocaleNumberSymbol(locale, NumberSymbol.Infinity);
  } else {
    let parsedNumber = parseNumber(value);
    if (isPercent) {
      parsedNumber = toPercent(parsedNumber);
    }
    let minInt = pattern.minInt;
    let minFraction = pattern.minFrac;
    let maxFraction = pattern.maxFrac;
    if (digitsInfo) {
      const parts = digitsInfo.match(NUMBER_FORMAT_REGEXP);
      if (parts === null) {
        throw new RuntimeError(2306, ngDevMode && `${digitsInfo} is not a valid digit info`);
      }
      const minIntPart = parts[1];
      const minFractionPart = parts[3];
      const maxFractionPart = parts[5];
      if (minIntPart != null) {
        minInt = parseIntAutoRadix(minIntPart);
      }
      if (minFractionPart != null) {
        minFraction = parseIntAutoRadix(minFractionPart);
      }
      if (maxFractionPart != null) {
        maxFraction = parseIntAutoRadix(maxFractionPart);
      } else if (minFractionPart != null && minFraction > maxFraction) {
        maxFraction = minFraction;
      }
    }
    roundNumber(parsedNumber, minFraction, maxFraction);
    let digits = parsedNumber.digits;
    let integerLen = parsedNumber.integerLen;
    const exponent = parsedNumber.exponent;
    let decimals = [];
    isZero = digits.every((d) => !d);
    for (; integerLen < minInt; integerLen++) {
      digits.unshift(0);
    }
    for (; integerLen < 0; integerLen++) {
      digits.unshift(0);
    }
    if (integerLen > 0) {
      decimals = digits.splice(integerLen, digits.length);
    } else {
      decimals = digits;
      digits = [0];
    }
    const groups = [];
    if (digits.length >= pattern.lgSize) {
      groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(""));
    }
    while (digits.length > pattern.gSize) {
      groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
    }
    if (digits.length) {
      groups.unshift(digits.join(""));
    }
    formattedText = groups.join(getLocaleNumberSymbol(locale, groupSymbol));
    if (decimals.length) {
      formattedText += getLocaleNumberSymbol(locale, decimalSymbol) + decimals.join("");
    }
    if (exponent) {
      formattedText += getLocaleNumberSymbol(locale, NumberSymbol.Exponential) + "+" + exponent;
    }
  }
  if (value < 0 && !isZero) {
    formattedText = pattern.negPre + formattedText + pattern.negSuf;
  } else {
    formattedText = pattern.posPre + formattedText + pattern.posSuf;
  }
  return formattedText;
}
function formatCurrency(value, locale, currency, currencyCode, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Currency);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  pattern.minFrac = getNumberOfCurrencyDigits(currencyCode);
  pattern.maxFrac = pattern.minFrac;
  const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.CurrencyGroup, NumberSymbol.CurrencyDecimal, digitsInfo);
  return res.replace(CURRENCY_CHAR, currency).replace(CURRENCY_CHAR, "").trim();
}
function formatPercent(value, locale, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Percent);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo, true);
  return res.replace(new RegExp(PERCENT_CHAR, "g"), getLocaleNumberSymbol(locale, NumberSymbol.PercentSign));
}
function formatNumber(value, locale, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Decimal);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  return formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo);
}
function parseNumberFormat(format, minusSign = "-") {
  const p = {
    minInt: 1,
    minFrac: 0,
    maxFrac: 0,
    posPre: "",
    posSuf: "",
    negPre: "",
    negSuf: "",
    gSize: 0,
    lgSize: 0
  };
  const patternParts = format.split(PATTERN_SEP);
  const positive = patternParts[0];
  const negative = patternParts[1];
  const positiveParts = positive.indexOf(DECIMAL_SEP) !== -1 ? positive.split(DECIMAL_SEP) : [positive.substring(0, positive.lastIndexOf(ZERO_CHAR) + 1), positive.substring(positive.lastIndexOf(ZERO_CHAR) + 1)], integer = positiveParts[0], fraction = positiveParts[1] || "";
  p.posPre = integer.substring(0, integer.indexOf(DIGIT_CHAR));
  for (let i = 0; i < fraction.length; i++) {
    const ch = fraction.charAt(i);
    if (ch === ZERO_CHAR) {
      p.minFrac = p.maxFrac = i + 1;
    } else if (ch === DIGIT_CHAR) {
      p.maxFrac = i + 1;
    } else {
      p.posSuf += ch;
    }
  }
  const groups = integer.split(GROUP_SEP);
  p.gSize = groups[1] ? groups[1].length : 0;
  p.lgSize = groups[2] || groups[1] ? (groups[2] || groups[1]).length : 0;
  if (negative) {
    const trunkLen = positive.length - p.posPre.length - p.posSuf.length, pos = negative.indexOf(DIGIT_CHAR);
    p.negPre = negative.substring(0, pos).replace(/'/g, "");
    p.negSuf = negative.slice(pos + trunkLen).replace(/'/g, "");
  } else {
    p.negPre = minusSign + p.posPre;
    p.negSuf = p.posSuf;
  }
  return p;
}
function toPercent(parsedNumber) {
  if (parsedNumber.digits[0] === 0) {
    return parsedNumber;
  }
  const fractionLen = parsedNumber.digits.length - parsedNumber.integerLen;
  if (parsedNumber.exponent) {
    parsedNumber.exponent += 2;
  } else {
    if (fractionLen === 0) {
      parsedNumber.digits.push(0, 0);
    } else if (fractionLen === 1) {
      parsedNumber.digits.push(0);
    }
    parsedNumber.integerLen += 2;
  }
  return parsedNumber;
}
function parseNumber(num) {
  let numStr = Math.abs(num) + "";
  let exponent = 0, digits, integerLen;
  let i, j, zeros;
  if ((integerLen = numStr.indexOf(DECIMAL_SEP)) > -1) {
    numStr = numStr.replace(DECIMAL_SEP, "");
  }
  if ((i = numStr.search(/e/i)) > 0) {
    if (integerLen < 0) integerLen = i;
    integerLen += +numStr.slice(i + 1);
    numStr = numStr.substring(0, i);
  } else if (integerLen < 0) {
    integerLen = numStr.length;
  }
  for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {
  }
  if (i === (zeros = numStr.length)) {
    digits = [0];
    integerLen = 1;
  } else {
    zeros--;
    while (numStr.charAt(zeros) === ZERO_CHAR) zeros--;
    integerLen -= i;
    digits = [];
    for (j = 0; i <= zeros; i++, j++) {
      digits[j] = Number(numStr.charAt(i));
    }
  }
  if (integerLen > MAX_DIGITS) {
    digits = digits.splice(0, MAX_DIGITS - 1);
    exponent = integerLen - 1;
    integerLen = 1;
  }
  return {
    digits,
    exponent,
    integerLen
  };
}
function roundNumber(parsedNumber, minFrac, maxFrac) {
  if (minFrac > maxFrac) {
    throw new RuntimeError(2307, ngDevMode && `The minimum number of digits after fraction (${minFrac}) is higher than the maximum (${maxFrac}).`);
  }
  let digits = parsedNumber.digits;
  let fractionLen = digits.length - parsedNumber.integerLen;
  const fractionSize = Math.min(Math.max(minFrac, fractionLen), maxFrac);
  let roundAt = fractionSize + parsedNumber.integerLen;
  let digit = digits[roundAt];
  if (roundAt > 0) {
    digits.splice(Math.max(parsedNumber.integerLen, roundAt));
    for (let j = roundAt; j < digits.length; j++) {
      digits[j] = 0;
    }
  } else {
    fractionLen = Math.max(0, fractionLen);
    parsedNumber.integerLen = 1;
    digits.length = Math.max(1, roundAt = fractionSize + 1);
    digits[0] = 0;
    for (let i = 1; i < roundAt; i++) digits[i] = 0;
  }
  if (digit >= 5) {
    if (roundAt - 1 < 0) {
      for (let k = 0; k > roundAt; k--) {
        digits.unshift(0);
        parsedNumber.integerLen++;
      }
      digits.unshift(1);
      parsedNumber.integerLen++;
    } else {
      digits[roundAt - 1]++;
    }
  }
  for (; fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
  let dropTrailingZeros = fractionSize !== 0;
  const minLen = minFrac + parsedNumber.integerLen;
  const carry = digits.reduceRight(function(carry2, d, i, digits2) {
    d = d + carry2;
    digits2[i] = d < 10 ? d : d - 10;
    if (dropTrailingZeros) {
      if (digits2[i] === 0 && i >= minLen) {
        digits2.pop();
      } else {
        dropTrailingZeros = false;
      }
    }
    return d >= 10 ? 1 : 0;
  }, 0);
  if (carry) {
    digits.unshift(carry);
    parsedNumber.integerLen++;
  }
}
function parseIntAutoRadix(text) {
  const result = parseInt(text);
  if (isNaN(result)) {
    throw new RuntimeError(2305, ngDevMode && "Invalid integer literal when parsing " + text);
  }
  return result;
}
function getPluralCategory(value, cases, ngLocalization, locale) {
  let key = `=${value}`;
  if (cases.indexOf(key) > -1) {
    return key;
  }
  key = ngLocalization.getPluralCategory(value, locale);
  if (cases.indexOf(key) > -1) {
    return key;
  }
  if (cases.indexOf("other") > -1) {
    return "other";
  }
  throw new RuntimeError(2308, ngDevMode && `No plural message found for value "${value}"`);
}
function getParentInjector(injector) {
  const parentNgModule = injector.get(NgModuleRef$1);
  return parentNgModule.injector;
}
function applyViewChange(view, record) {
  view.context.$implicit = record.item;
}
function getTypeName(type) {
  return type["name"] || typeof type;
}
function assertTemplate(templateRef, property) {
  if (templateRef && !templateRef.createEmbeddedView) {
    throw new RuntimeError(2020, (typeof ngDevMode === "undefined" || ngDevMode) && `${property} must be a TemplateRef, but received '${stringify(templateRef)}'.`);
  }
}
function throwNgSwitchProviderNotFoundError(attrName, directiveName) {
  throw new RuntimeError(2e3, `An element with the "${attrName}" attribute (matching the "${directiveName}" directive) must be located inside an element with the "ngSwitch" attribute (matching "NgSwitch" directive)`);
}
function invalidPipeArgumentError(type, value) {
  return new RuntimeError(2100, ngDevMode && `InvalidPipeArgument: '${value}' for pipe '${stringify(type)}'`);
}
function makeKeyValuePair(key, value) {
  return {
    key,
    value
  };
}
function defaultComparator(keyValueA, keyValueB) {
  const a = keyValueA.key;
  const b = keyValueB.key;
  if (a === b) return 0;
  if (a == null) return 1;
  if (b == null) return -1;
  if (typeof a == "string" && typeof b == "string") {
    return a < b ? -1 : 1;
  }
  if (typeof a == "number" && typeof b == "number") {
    return a - b;
  }
  if (typeof a == "boolean" && typeof b == "boolean") {
    return a < b ? -1 : 1;
  }
  const aString = String(a);
  const bString = String(b);
  return aString == bString ? 0 : aString < bString ? -1 : 1;
}
function isValue(value) {
  return !(value == null || value === "" || value !== value);
}
function strToNumber(value) {
  if (typeof value === "string" && !isNaN(Number(value) - parseFloat(value))) {
    return Number(value);
  }
  if (typeof value !== "number") {
    throw new RuntimeError(2309, ngDevMode && `${value} is not a number`);
  }
  return value;
}
var HashLocationStrategy, CURRENCIES_EN, NumberFormatStyle, Plural, FormStyle, TranslationWidth, FormatWidth, NumberSymbol, WeekDay, getLocalePluralCase2, DEFAULT_NB_OF_CURRENCY_DIGITS, ISO8601_DATE_REGEX, NAMED_FORMATS, DATE_FORMATS_SPLIT, JANUARY, THURSDAY, DATE_FORMATS, NUMBER_FORMAT_REGEXP, MAX_DIGITS, DECIMAL_SEP, ZERO_CHAR, PATTERN_SEP, GROUP_SEP, DIGIT_CHAR, CURRENCY_CHAR, PERCENT_CHAR, NgLocalization, NgLocaleLocalization, WS_REGEXP, EMPTY_ARRAY2, NgClass, NgComponentOutlet, NgForOfContext, NgForOf, NgIf, NgIfContext, SwitchView, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase, NgStyle, NgTemplateOutlet, COMMON_DIRECTIVES, SubscribableStrategy, PromiseStrategy, _promiseStrategy, _subscribableStrategy, AsyncPipe, LowerCasePipe, unicodeWordMatch, TitleCasePipe, UpperCasePipe, DEFAULT_DATE_FORMAT, DATE_PIPE_DEFAULT_TIMEZONE, DATE_PIPE_DEFAULT_OPTIONS, DatePipe, _INTERPOLATION_REGEXP, I18nPluralPipe, I18nSelectPipe, JsonPipe, KeyValuePipe, DecimalPipe, PercentPipe, CurrencyPipe, SlicePipe, COMMON_PIPES, CommonModule;
var init_common_module = __esm({
  "node_modules/@angular/common/fesm2022/common_module.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_location();
    HashLocationStrategy = class _HashLocationStrategy extends LocationStrategy {
      _platformLocation;
      _baseHref = "";
      _removeListenerFns = [];
      constructor(_platformLocation, _baseHref) {
        super();
        this._platformLocation = _platformLocation;
        if (_baseHref != null) {
          this._baseHref = _baseHref;
        }
      }
      /** @docs-private */
      ngOnDestroy() {
        while (this._removeListenerFns.length) {
          this._removeListenerFns.pop()();
        }
      }
      onPopState(fn) {
        this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));
      }
      getBaseHref() {
        return this._baseHref;
      }
      path(includeHash = false) {
        const path = this._platformLocation.hash ?? "#";
        return path.length > 0 ? path.substring(1) : path;
      }
      prepareExternalUrl(internal) {
        const url = joinWithSlash(this._baseHref, internal);
        return url.length > 0 ? "#" + url : url;
      }
      pushState(state, title, path, queryParams) {
        const url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams)) || this._platformLocation.pathname;
        this._platformLocation.pushState(state, title, url);
      }
      replaceState(state, title, path, queryParams) {
        const url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams)) || this._platformLocation.pathname;
        this._platformLocation.replaceState(state, title, url);
      }
      forward() {
        this._platformLocation.forward();
      }
      back() {
        this._platformLocation.back();
      }
      getState() {
        return this._platformLocation.getState();
      }
      historyGo(relativePosition = 0) {
        this._platformLocation.historyGo?.(relativePosition);
      }
      static \u0275fac = function HashLocationStrategy_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HashLocationStrategy)(\u0275\u0275inject(PlatformLocation), \u0275\u0275inject(APP_BASE_HREF, 8));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _HashLocationStrategy,
        factory: _HashLocationStrategy.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HashLocationStrategy, [{
        type: Injectable
      }], () => [{
        type: PlatformLocation
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [APP_BASE_HREF]
        }]
      }], null);
    })();
    CURRENCIES_EN = {
      "ADP": [void 0, void 0, 0],
      "AFN": [void 0, "\u060B", 0],
      "ALL": [void 0, void 0, 0],
      "AMD": [void 0, "\u058F", 2],
      "AOA": [void 0, "Kz"],
      "ARS": [void 0, "$"],
      "AUD": ["A$", "$"],
      "AZN": [void 0, "\u20BC"],
      "BAM": [void 0, "KM"],
      "BBD": [void 0, "$"],
      "BDT": [void 0, "\u09F3"],
      "BHD": [void 0, void 0, 3],
      "BIF": [void 0, void 0, 0],
      "BMD": [void 0, "$"],
      "BND": [void 0, "$"],
      "BOB": [void 0, "Bs"],
      "BRL": ["R$"],
      "BSD": [void 0, "$"],
      "BWP": [void 0, "P"],
      "BYN": [void 0, void 0, 2],
      "BYR": [void 0, void 0, 0],
      "BZD": [void 0, "$"],
      "CAD": ["CA$", "$", 2],
      "CHF": [void 0, void 0, 2],
      "CLF": [void 0, void 0, 4],
      "CLP": [void 0, "$", 0],
      "CNY": ["CN\xA5", "\xA5"],
      "COP": [void 0, "$", 2],
      "CRC": [void 0, "\u20A1", 2],
      "CUC": [void 0, "$"],
      "CUP": [void 0, "$"],
      "CZK": [void 0, "K\u010D", 2],
      "DJF": [void 0, void 0, 0],
      "DKK": [void 0, "kr", 2],
      "DOP": [void 0, "$"],
      "EGP": [void 0, "E\xA3"],
      "ESP": [void 0, "\u20A7", 0],
      "EUR": ["\u20AC"],
      "FJD": [void 0, "$"],
      "FKP": [void 0, "\xA3"],
      "GBP": ["\xA3"],
      "GEL": [void 0, "\u20BE"],
      "GHS": [void 0, "GH\u20B5"],
      "GIP": [void 0, "\xA3"],
      "GNF": [void 0, "FG", 0],
      "GTQ": [void 0, "Q"],
      "GYD": [void 0, "$", 2],
      "HKD": ["HK$", "$"],
      "HNL": [void 0, "L"],
      "HRK": [void 0, "kn"],
      "HUF": [void 0, "Ft", 2],
      "IDR": [void 0, "Rp", 2],
      "ILS": ["\u20AA"],
      "INR": ["\u20B9"],
      "IQD": [void 0, void 0, 0],
      "IRR": [void 0, void 0, 0],
      "ISK": [void 0, "kr", 0],
      "ITL": [void 0, void 0, 0],
      "JMD": [void 0, "$"],
      "JOD": [void 0, void 0, 3],
      "JPY": ["\xA5", void 0, 0],
      "KHR": [void 0, "\u17DB"],
      "KMF": [void 0, "CF", 0],
      "KPW": [void 0, "\u20A9", 0],
      "KRW": ["\u20A9", void 0, 0],
      "KWD": [void 0, void 0, 3],
      "KYD": [void 0, "$"],
      "KZT": [void 0, "\u20B8"],
      "LAK": [void 0, "\u20AD", 0],
      "LBP": [void 0, "L\xA3", 0],
      "LKR": [void 0, "Rs"],
      "LRD": [void 0, "$"],
      "LTL": [void 0, "Lt"],
      "LUF": [void 0, void 0, 0],
      "LVL": [void 0, "Ls"],
      "LYD": [void 0, void 0, 3],
      "MGA": [void 0, "Ar", 0],
      "MGF": [void 0, void 0, 0],
      "MMK": [void 0, "K", 0],
      "MNT": [void 0, "\u20AE", 2],
      "MRO": [void 0, void 0, 0],
      "MUR": [void 0, "Rs", 2],
      "MXN": ["MX$", "$"],
      "MYR": [void 0, "RM"],
      "NAD": [void 0, "$"],
      "NGN": [void 0, "\u20A6"],
      "NIO": [void 0, "C$"],
      "NOK": [void 0, "kr", 2],
      "NPR": [void 0, "Rs"],
      "NZD": ["NZ$", "$"],
      "OMR": [void 0, void 0, 3],
      "PHP": ["\u20B1"],
      "PKR": [void 0, "Rs", 2],
      "PLN": [void 0, "z\u0142"],
      "PYG": [void 0, "\u20B2", 0],
      "RON": [void 0, "lei"],
      "RSD": [void 0, void 0, 0],
      "RUB": [void 0, "\u20BD"],
      "RWF": [void 0, "RF", 0],
      "SBD": [void 0, "$"],
      "SEK": [void 0, "kr", 2],
      "SGD": [void 0, "$"],
      "SHP": [void 0, "\xA3"],
      "SLE": [void 0, void 0, 2],
      "SLL": [void 0, void 0, 0],
      "SOS": [void 0, void 0, 0],
      "SRD": [void 0, "$"],
      "SSP": [void 0, "\xA3"],
      "STD": [void 0, void 0, 0],
      "STN": [void 0, "Db"],
      "SYP": [void 0, "\xA3", 0],
      "THB": [void 0, "\u0E3F"],
      "TMM": [void 0, void 0, 0],
      "TND": [void 0, void 0, 3],
      "TOP": [void 0, "T$"],
      "TRL": [void 0, void 0, 0],
      "TRY": [void 0, "\u20BA"],
      "TTD": [void 0, "$"],
      "TWD": ["NT$", "$", 2],
      "TZS": [void 0, void 0, 2],
      "UAH": [void 0, "\u20B4"],
      "UGX": [void 0, void 0, 0],
      "USD": ["$"],
      "UYI": [void 0, void 0, 0],
      "UYU": [void 0, "$"],
      "UYW": [void 0, void 0, 4],
      "UZS": [void 0, void 0, 2],
      "VEF": [void 0, "Bs", 2],
      "VND": ["\u20AB", void 0, 0],
      "VUV": [void 0, void 0, 0],
      "XAF": ["FCFA", void 0, 0],
      "XCD": ["EC$", "$"],
      "XOF": ["F\u202FCFA", void 0, 0],
      "XPF": ["CFPF", void 0, 0],
      "XXX": ["\xA4"],
      "YER": [void 0, void 0, 0],
      "ZAR": [void 0, "R"],
      "ZMK": [void 0, void 0, 0],
      "ZMW": [void 0, "ZK"],
      "ZWD": [void 0, void 0, 0]
    };
    (function(NumberFormatStyle2) {
      NumberFormatStyle2[NumberFormatStyle2["Decimal"] = 0] = "Decimal";
      NumberFormatStyle2[NumberFormatStyle2["Percent"] = 1] = "Percent";
      NumberFormatStyle2[NumberFormatStyle2["Currency"] = 2] = "Currency";
      NumberFormatStyle2[NumberFormatStyle2["Scientific"] = 3] = "Scientific";
    })(NumberFormatStyle || (NumberFormatStyle = {}));
    (function(Plural2) {
      Plural2[Plural2["Zero"] = 0] = "Zero";
      Plural2[Plural2["One"] = 1] = "One";
      Plural2[Plural2["Two"] = 2] = "Two";
      Plural2[Plural2["Few"] = 3] = "Few";
      Plural2[Plural2["Many"] = 4] = "Many";
      Plural2[Plural2["Other"] = 5] = "Other";
    })(Plural || (Plural = {}));
    (function(FormStyle2) {
      FormStyle2[FormStyle2["Format"] = 0] = "Format";
      FormStyle2[FormStyle2["Standalone"] = 1] = "Standalone";
    })(FormStyle || (FormStyle = {}));
    (function(TranslationWidth2) {
      TranslationWidth2[TranslationWidth2["Narrow"] = 0] = "Narrow";
      TranslationWidth2[TranslationWidth2["Abbreviated"] = 1] = "Abbreviated";
      TranslationWidth2[TranslationWidth2["Wide"] = 2] = "Wide";
      TranslationWidth2[TranslationWidth2["Short"] = 3] = "Short";
    })(TranslationWidth || (TranslationWidth = {}));
    (function(FormatWidth2) {
      FormatWidth2[FormatWidth2["Short"] = 0] = "Short";
      FormatWidth2[FormatWidth2["Medium"] = 1] = "Medium";
      FormatWidth2[FormatWidth2["Long"] = 2] = "Long";
      FormatWidth2[FormatWidth2["Full"] = 3] = "Full";
    })(FormatWidth || (FormatWidth = {}));
    NumberSymbol = {
      /**
       * Decimal separator.
       * For `en-US`, the dot character.
       * Example: 2,345`.`67
       */
      Decimal: 0,
      /**
       * Grouping separator, typically for thousands.
       * For `en-US`, the comma character.
       * Example: 2`,`345.67
       */
      Group: 1,
      /**
       * List-item separator.
       * Example: "one, two, and three"
       */
      List: 2,
      /**
       * Sign for percentage (out of 100).
       * Example: 23.4%
       */
      PercentSign: 3,
      /**
       * Sign for positive numbers.
       * Example: +23
       */
      PlusSign: 4,
      /**
       * Sign for negative numbers.
       * Example: -23
       */
      MinusSign: 5,
      /**
       * Computer notation for exponential value (n times a power of 10).
       * Example: 1.2E3
       */
      Exponential: 6,
      /**
       * Human-readable format of exponential.
       * Example: 1.2x103
       */
      SuperscriptingExponent: 7,
      /**
       * Sign for permille (out of 1000).
       * Example: 23.4
       */
      PerMille: 8,
      /**
       * Infinity, can be used with plus and minus.
       * Example: , +, -
       */
      Infinity: 9,
      /**
       * Not a number.
       * Example: NaN
       */
      NaN: 10,
      /**
       * Symbol used between time units.
       * Example: 10:52
       */
      TimeSeparator: 11,
      /**
       * Decimal separator for currency values (fallback to `Decimal`).
       * Example: $2,345.67
       */
      CurrencyDecimal: 12,
      /**
       * Group separator for currency values (fallback to `Group`).
       * Example: $2,345.67
       */
      CurrencyGroup: 13
    };
    (function(WeekDay2) {
      WeekDay2[WeekDay2["Sunday"] = 0] = "Sunday";
      WeekDay2[WeekDay2["Monday"] = 1] = "Monday";
      WeekDay2[WeekDay2["Tuesday"] = 2] = "Tuesday";
      WeekDay2[WeekDay2["Wednesday"] = 3] = "Wednesday";
      WeekDay2[WeekDay2["Thursday"] = 4] = "Thursday";
      WeekDay2[WeekDay2["Friday"] = 5] = "Friday";
      WeekDay2[WeekDay2["Saturday"] = 6] = "Saturday";
    })(WeekDay || (WeekDay = {}));
    getLocalePluralCase2 = getLocalePluralCase;
    DEFAULT_NB_OF_CURRENCY_DIGITS = 2;
    ISO8601_DATE_REGEX = /^(\d{4,})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
    NAMED_FORMATS = {};
    DATE_FORMATS_SPLIT = /((?:[^BEGHLMOSWYZabcdhmswyz']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|c{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/;
    JANUARY = 0;
    THURSDAY = 4;
    DATE_FORMATS = {};
    NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
    MAX_DIGITS = 22;
    DECIMAL_SEP = ".";
    ZERO_CHAR = "0";
    PATTERN_SEP = ";";
    GROUP_SEP = ",";
    DIGIT_CHAR = "#";
    CURRENCY_CHAR = "\xA4";
    PERCENT_CHAR = "%";
    NgLocalization = class _NgLocalization {
      static \u0275fac = function NgLocalization_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgLocalization)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _NgLocalization,
        factory: function NgLocalization_Factory(__ngFactoryType__) {
          let __ngConditionalFactory__ = null;
          if (__ngFactoryType__) {
            __ngConditionalFactory__ = new __ngFactoryType__();
          } else {
            __ngConditionalFactory__ = ((locale) => new NgLocaleLocalization(locale))(\u0275\u0275inject(LOCALE_ID));
          }
          return __ngConditionalFactory__;
        },
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgLocalization, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: (locale) => new NgLocaleLocalization(locale),
          deps: [LOCALE_ID]
        }]
      }], null, null);
    })();
    NgLocaleLocalization = class _NgLocaleLocalization extends NgLocalization {
      locale;
      constructor(locale) {
        super();
        this.locale = locale;
      }
      getPluralCategory(value, locale) {
        const plural2 = getLocalePluralCase2(locale || this.locale)(value);
        switch (plural2) {
          case Plural.Zero:
            return "zero";
          case Plural.One:
            return "one";
          case Plural.Two:
            return "two";
          case Plural.Few:
            return "few";
          case Plural.Many:
            return "many";
          default:
            return "other";
        }
      }
      static \u0275fac = function NgLocaleLocalization_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgLocaleLocalization)(\u0275\u0275inject(LOCALE_ID));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _NgLocaleLocalization,
        factory: _NgLocaleLocalization.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgLocaleLocalization, [{
        type: Injectable
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [LOCALE_ID]
        }]
      }], null);
    })();
    WS_REGEXP = /\s+/;
    EMPTY_ARRAY2 = [];
    NgClass = class _NgClass {
      _ngEl;
      _renderer;
      initialClasses = EMPTY_ARRAY2;
      rawClass;
      stateMap = /* @__PURE__ */ new Map();
      constructor(_ngEl, _renderer) {
        this._ngEl = _ngEl;
        this._renderer = _renderer;
      }
      set klass(value) {
        this.initialClasses = value != null ? value.trim().split(WS_REGEXP) : EMPTY_ARRAY2;
      }
      set ngClass(value) {
        this.rawClass = typeof value === "string" ? value.trim().split(WS_REGEXP) : value;
      }
      /*
      The NgClass directive uses the custom change detection algorithm for its inputs. The custom
      algorithm is necessary since inputs are represented as complex object or arrays that need to be
      deeply-compared.
         This algorithm is perf-sensitive since NgClass is used very frequently and its poor performance
      might negatively impact runtime performance of the entire change detection cycle. The design of
      this algorithm is making sure that:
      - there is no unnecessary DOM manipulation (CSS classes are added / removed from the DOM only when
      needed), even if references to bound objects change;
      - there is no memory allocation if nothing changes (even relatively modest memory allocation
      during the change detection cycle can result in GC pauses for some of the CD cycles).
         The algorithm works by iterating over the set of bound classes, staring with [class] binding and
      then going over [ngClass] binding. For each CSS class name:
      - check if it was seen before (this information is tracked in the state map) and if its value
      changed;
      - mark it as "touched" - names that are not marked are not present in the latest set of binding
      and we can remove such class name from the internal data structures;
         After iteration over all the CSS class names we've got data structure with all the information
      necessary to synchronize changes to the DOM - it is enough to iterate over the state map, flush
      changes to the DOM and reset internal data structures so those are ready for the next change
      detection cycle.
       */
      ngDoCheck() {
        for (const klass of this.initialClasses) {
          this._updateState(klass, true);
        }
        const rawClass = this.rawClass;
        if (Array.isArray(rawClass) || rawClass instanceof Set) {
          for (const klass of rawClass) {
            this._updateState(klass, true);
          }
        } else if (rawClass != null) {
          for (const klass of Object.keys(rawClass)) {
            this._updateState(klass, Boolean(rawClass[klass]));
          }
        }
        this._applyStateDiff();
      }
      _updateState(klass, nextEnabled) {
        const state = this.stateMap.get(klass);
        if (state !== void 0) {
          if (state.enabled !== nextEnabled) {
            state.changed = true;
            state.enabled = nextEnabled;
          }
          state.touched = true;
        } else {
          this.stateMap.set(klass, {
            enabled: nextEnabled,
            changed: true,
            touched: true
          });
        }
      }
      _applyStateDiff() {
        for (const stateEntry of this.stateMap) {
          const klass = stateEntry[0];
          const state = stateEntry[1];
          if (state.changed) {
            this._toggleClass(klass, state.enabled);
            state.changed = false;
          } else if (!state.touched) {
            if (state.enabled) {
              this._toggleClass(klass, false);
            }
            this.stateMap.delete(klass);
          }
          state.touched = false;
        }
      }
      _toggleClass(klass, enabled) {
        if (ngDevMode) {
          if (typeof klass !== "string") {
            throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${stringify(klass)}`);
          }
        }
        klass = klass.trim();
        if (klass.length > 0) {
          klass.split(WS_REGEXP).forEach((klass2) => {
            if (enabled) {
              this._renderer.addClass(this._ngEl.nativeElement, klass2);
            } else {
              this._renderer.removeClass(this._ngEl.nativeElement, klass2);
            }
          });
        }
      }
      static \u0275fac = function NgClass_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgClass)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgClass,
        selectors: [["", "ngClass", ""]],
        inputs: {
          klass: [0, "class", "klass"],
          ngClass: "ngClass"
        }
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgClass, [{
        type: Directive,
        args: [{
          selector: "[ngClass]"
        }]
      }], () => [{
        type: ElementRef
      }, {
        type: Renderer2
      }], {
        klass: [{
          type: Input,
          args: ["class"]
        }],
        ngClass: [{
          type: Input,
          args: ["ngClass"]
        }]
      });
    })();
    NgComponentOutlet = class _NgComponentOutlet {
      _viewContainerRef;
      // TODO(crisbeto): this should be `Type<T>`, but doing so broke a few
      // targets in a TGP so we need to do it in a major version.
      /** Component that should be rendered in the outlet. */
      ngComponentOutlet = null;
      ngComponentOutletInputs;
      ngComponentOutletInjector;
      ngComponentOutletEnvironmentInjector;
      ngComponentOutletContent;
      ngComponentOutletNgModule;
      /**
       * @deprecated This input is deprecated, use `ngComponentOutletNgModule` instead.
       */
      ngComponentOutletNgModuleFactory;
      _componentRef;
      _moduleRef;
      /**
       * A helper data structure that allows us to track inputs that were part of the
       * ngComponentOutletInputs expression. Tracking inputs is necessary for proper removal of ones
       * that are no longer referenced.
       */
      _inputsUsed = /* @__PURE__ */ new Map();
      /**
       * Gets the instance of the currently-rendered component.
       * Will be null if no component has been rendered.
       */
      get componentInstance() {
        return this._componentRef?.instance ?? null;
      }
      constructor(_viewContainerRef) {
        this._viewContainerRef = _viewContainerRef;
      }
      _needToReCreateNgModuleInstance(changes) {
        return changes["ngComponentOutletNgModule"] !== void 0 || changes["ngComponentOutletNgModuleFactory"] !== void 0;
      }
      _needToReCreateComponentInstance(changes) {
        return changes["ngComponentOutlet"] !== void 0 || changes["ngComponentOutletContent"] !== void 0 || changes["ngComponentOutletInjector"] !== void 0 || changes["ngComponentOutletEnvironmentInjector"] !== void 0 || this._needToReCreateNgModuleInstance(changes);
      }
      /** @docs-private */
      ngOnChanges(changes) {
        if (this._needToReCreateComponentInstance(changes)) {
          this._viewContainerRef.clear();
          this._inputsUsed.clear();
          this._componentRef = void 0;
          if (this.ngComponentOutlet) {
            const injector = this.ngComponentOutletInjector || this._viewContainerRef.parentInjector;
            if (this._needToReCreateNgModuleInstance(changes)) {
              this._moduleRef?.destroy();
              if (this.ngComponentOutletNgModule) {
                this._moduleRef = createNgModule(this.ngComponentOutletNgModule, getParentInjector(injector));
              } else if (this.ngComponentOutletNgModuleFactory) {
                this._moduleRef = this.ngComponentOutletNgModuleFactory.create(getParentInjector(injector));
              } else {
                this._moduleRef = void 0;
              }
            }
            this._componentRef = this._viewContainerRef.createComponent(this.ngComponentOutlet, {
              injector,
              ngModuleRef: this._moduleRef,
              projectableNodes: this.ngComponentOutletContent,
              environmentInjector: this.ngComponentOutletEnvironmentInjector
            });
          }
        }
      }
      /** @docs-private */
      ngDoCheck() {
        if (this._componentRef) {
          if (this.ngComponentOutletInputs) {
            for (const inputName of Object.keys(this.ngComponentOutletInputs)) {
              this._inputsUsed.set(inputName, true);
            }
          }
          this._applyInputStateDiff(this._componentRef);
        }
      }
      /** @docs-private */
      ngOnDestroy() {
        this._moduleRef?.destroy();
      }
      _applyInputStateDiff(componentRef) {
        for (const [inputName, touched] of this._inputsUsed) {
          if (!touched) {
            componentRef.setInput(inputName, void 0);
            this._inputsUsed.delete(inputName);
          } else {
            componentRef.setInput(inputName, this.ngComponentOutletInputs[inputName]);
            this._inputsUsed.set(inputName, false);
          }
        }
      }
      static \u0275fac = function NgComponentOutlet_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgComponentOutlet)(\u0275\u0275directiveInject(ViewContainerRef));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgComponentOutlet,
        selectors: [["", "ngComponentOutlet", ""]],
        inputs: {
          ngComponentOutlet: "ngComponentOutlet",
          ngComponentOutletInputs: "ngComponentOutletInputs",
          ngComponentOutletInjector: "ngComponentOutletInjector",
          ngComponentOutletEnvironmentInjector: "ngComponentOutletEnvironmentInjector",
          ngComponentOutletContent: "ngComponentOutletContent",
          ngComponentOutletNgModule: "ngComponentOutletNgModule",
          ngComponentOutletNgModuleFactory: "ngComponentOutletNgModuleFactory"
        },
        exportAs: ["ngComponentOutlet"],
        features: [\u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgComponentOutlet, [{
        type: Directive,
        args: [{
          selector: "[ngComponentOutlet]",
          exportAs: "ngComponentOutlet"
        }]
      }], () => [{
        type: ViewContainerRef
      }], {
        ngComponentOutlet: [{
          type: Input
        }],
        ngComponentOutletInputs: [{
          type: Input
        }],
        ngComponentOutletInjector: [{
          type: Input
        }],
        ngComponentOutletEnvironmentInjector: [{
          type: Input
        }],
        ngComponentOutletContent: [{
          type: Input
        }],
        ngComponentOutletNgModule: [{
          type: Input
        }],
        ngComponentOutletNgModuleFactory: [{
          type: Input
        }]
      });
    })();
    NgForOfContext = class {
      $implicit;
      ngForOf;
      index;
      count;
      constructor($implicit, ngForOf, index, count2) {
        this.$implicit = $implicit;
        this.ngForOf = ngForOf;
        this.index = index;
        this.count = count2;
      }
      // Indicates whether this is the first item in the collection.
      get first() {
        return this.index === 0;
      }
      // Indicates whether this is the last item in the collection.
      get last() {
        return this.index === this.count - 1;
      }
      // Indicates whether an index of this item in the collection is even.
      get even() {
        return this.index % 2 === 0;
      }
      // Indicates whether an index of this item in the collection is odd.
      get odd() {
        return !this.even;
      }
    };
    NgForOf = class _NgForOf {
      _viewContainer;
      _template;
      _differs;
      /**
       * The value of the iterable expression, which can be used as a
       * [template input variable](guide/directives/structural-directives#shorthand).
       * @deprecated The `ngFor` directive is deprecated. Use the `@for` block instead.
       */
      set ngForOf(ngForOf) {
        this._ngForOf = ngForOf;
        this._ngForOfDirty = true;
      }
      /**
       * Specifies a custom `TrackByFunction` to compute the identity of items in an iterable.
       *
       * If a custom `TrackByFunction` is not provided, `NgForOf` will use the item's [object
       * identity](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)
       * as the key.
       *
       * `NgForOf` uses the computed key to associate items in an iterable with DOM elements
       * it produces for these items.
       *
       * A custom `TrackByFunction` is useful to provide good user experience in cases when items in an
       * iterable rendered using `NgForOf` have a natural identifier (for example, custom ID or a
       * primary key), and this iterable could be updated with new object instances that still
       * represent the same underlying entity (for example, when data is re-fetched from the server,
       * and the iterable is recreated and re-rendered, but most of the data is still the same).
       *
       * @see {@link TrackByFunction}
       * @deprecated The `ngFor` directive is deprecated. Use the `@for` block instead.
       */
      set ngForTrackBy(fn) {
        if ((typeof ngDevMode === "undefined" || ngDevMode) && fn != null && typeof fn !== "function") {
          console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}. See https://angular.dev/api/common/NgForOf#change-propagation for more information.`);
        }
        this._trackByFn = fn;
      }
      get ngForTrackBy() {
        return this._trackByFn;
      }
      _ngForOf = null;
      _ngForOfDirty = true;
      _differ = null;
      // waiting for microsoft/typescript#43662 to allow the return type `TrackByFunction|undefined` for
      // the getter
      _trackByFn;
      constructor(_viewContainer, _template, _differs) {
        this._viewContainer = _viewContainer;
        this._template = _template;
        this._differs = _differs;
      }
      /**
       * A reference to the template that is stamped out for each item in the iterable.
       * @see [template reference variable](guide/templates/variables#template-reference-variables)
       * @deprecated The `ngFor` directive is deprecated. Use the `@for` block instead.
       */
      set ngForTemplate(value) {
        if (value) {
          this._template = value;
        }
      }
      /**
       * Applies the changes when needed.
       * @docs-private
       */
      ngDoCheck() {
        if (this._ngForOfDirty) {
          this._ngForOfDirty = false;
          const value = this._ngForOf;
          if (!this._differ && value) {
            if (typeof ngDevMode === "undefined" || ngDevMode) {
              try {
                this._differ = this._differs.find(value).create(this.ngForTrackBy);
              } catch {
                let errorMessage = `Cannot find a differ supporting object '${value}' of type '${getTypeName(value)}'. NgFor only supports binding to Iterables, such as Arrays.`;
                if (typeof value === "object") {
                  errorMessage += " Did you mean to use the keyvalue pipe?";
                }
                throw new RuntimeError(-2200, errorMessage);
              }
            } else {
              this._differ = this._differs.find(value).create(this.ngForTrackBy);
            }
          }
        }
        if (this._differ) {
          const changes = this._differ.diff(this._ngForOf);
          if (changes) this._applyChanges(changes);
        }
      }
      _applyChanges(changes) {
        const viewContainer = this._viewContainer;
        changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
          if (item.previousIndex == null) {
            viewContainer.createEmbeddedView(this._template, new NgForOfContext(item.item, this._ngForOf, -1, -1), currentIndex === null ? void 0 : currentIndex);
          } else if (currentIndex == null) {
            viewContainer.remove(adjustedPreviousIndex === null ? void 0 : adjustedPreviousIndex);
          } else if (adjustedPreviousIndex !== null) {
            const view = viewContainer.get(adjustedPreviousIndex);
            viewContainer.move(view, currentIndex);
            applyViewChange(view, item);
          }
        });
        for (let i = 0, ilen = viewContainer.length; i < ilen; i++) {
          const viewRef = viewContainer.get(i);
          const context2 = viewRef.context;
          context2.index = i;
          context2.count = ilen;
          context2.ngForOf = this._ngForOf;
        }
        changes.forEachIdentityChange((record) => {
          const viewRef = viewContainer.get(record.currentIndex);
          applyViewChange(viewRef, record);
        });
      }
      /**
       * Asserts the correct type of the context for the template that `NgForOf` will render.
       *
       * The presence of this method is a signal to the Ivy template type-check compiler that the
       * `NgForOf` structural directive renders its template with a specific context type.
       */
      static ngTemplateContextGuard(dir, ctx) {
        return true;
      }
      static \u0275fac = function NgForOf_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgForOf)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(IterableDiffers));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgForOf,
        selectors: [["", "ngFor", "", "ngForOf", ""]],
        inputs: {
          ngForOf: "ngForOf",
          ngForTrackBy: "ngForTrackBy",
          ngForTemplate: "ngForTemplate"
        }
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgForOf, [{
        type: Directive,
        args: [{
          selector: "[ngFor][ngForOf]"
        }]
      }], () => [{
        type: ViewContainerRef
      }, {
        type: TemplateRef
      }, {
        type: IterableDiffers
      }], {
        ngForOf: [{
          type: Input
        }],
        ngForTrackBy: [{
          type: Input
        }],
        ngForTemplate: [{
          type: Input
        }]
      });
    })();
    NgIf = class _NgIf {
      _viewContainer;
      _context = new NgIfContext();
      _thenTemplateRef = null;
      _elseTemplateRef = null;
      _thenViewRef = null;
      _elseViewRef = null;
      constructor(_viewContainer, templateRef) {
        this._viewContainer = _viewContainer;
        this._thenTemplateRef = templateRef;
      }
      /**
       * The Boolean expression to evaluate as the condition for showing a template.
       * @deprecated Use the `@if` block instead. Intent to remove in v22
       */
      set ngIf(condition) {
        this._context.$implicit = this._context.ngIf = condition;
        this._updateView();
      }
      /**
       * A template to show if the condition expression evaluates to true.
       * @deprecated Use the `@if` block instead. Intent to remove in v22
       */
      set ngIfThen(templateRef) {
        assertTemplate(templateRef, (typeof ngDevMode === "undefined" || ngDevMode) && "ngIfThen");
        this._thenTemplateRef = templateRef;
        this._thenViewRef = null;
        this._updateView();
      }
      /**
       * A template to show if the condition expression evaluates to false.
       * @deprecated Use the `@if` block instead. Intent to remove in v22
       */
      set ngIfElse(templateRef) {
        assertTemplate(templateRef, (typeof ngDevMode === "undefined" || ngDevMode) && "ngIfElse");
        this._elseTemplateRef = templateRef;
        this._elseViewRef = null;
        this._updateView();
      }
      _updateView() {
        if (this._context.$implicit) {
          if (!this._thenViewRef) {
            this._viewContainer.clear();
            this._elseViewRef = null;
            if (this._thenTemplateRef) {
              this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context);
            }
          }
        } else {
          if (!this._elseViewRef) {
            this._viewContainer.clear();
            this._thenViewRef = null;
            if (this._elseTemplateRef) {
              this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context);
            }
          }
        }
      }
      /** @internal */
      static ngIfUseIfTypeGuard;
      /**
       * Assert the correct type of the expression bound to the `ngIf` input within the template.
       *
       * The presence of this static field is a signal to the Ivy template type check compiler that
       * when the `NgIf` structural directive renders its template, the type of the expression bound
       * to `ngIf` should be narrowed in some way. For `NgIf`, the binding expression itself is used to
       * narrow its type, which allows the strictNullChecks feature of TypeScript to work with `NgIf`.
       */
      static ngTemplateGuard_ngIf;
      /**
       * Asserts the correct type of the context for the template that `NgIf` will render.
       *
       * The presence of this method is a signal to the Ivy template type-check compiler that the
       * `NgIf` structural directive renders its template with a specific context type.
       */
      static ngTemplateContextGuard(dir, ctx) {
        return true;
      }
      static \u0275fac = function NgIf_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgIf)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgIf,
        selectors: [["", "ngIf", ""]],
        inputs: {
          ngIf: "ngIf",
          ngIfThen: "ngIfThen",
          ngIfElse: "ngIfElse"
        }
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgIf, [{
        type: Directive,
        args: [{
          selector: "[ngIf]"
        }]
      }], () => [{
        type: ViewContainerRef
      }, {
        type: TemplateRef
      }], {
        ngIf: [{
          type: Input
        }],
        ngIfThen: [{
          type: Input
        }],
        ngIfElse: [{
          type: Input
        }]
      });
    })();
    NgIfContext = class {
      $implicit = null;
      ngIf = null;
    };
    SwitchView = class {
      _viewContainerRef;
      _templateRef;
      _created = false;
      constructor(_viewContainerRef, _templateRef) {
        this._viewContainerRef = _viewContainerRef;
        this._templateRef = _templateRef;
      }
      create() {
        this._created = true;
        this._viewContainerRef.createEmbeddedView(this._templateRef);
      }
      destroy() {
        this._created = false;
        this._viewContainerRef.clear();
      }
      enforceState(created) {
        if (created && !this._created) {
          this.create();
        } else if (!created && this._created) {
          this.destroy();
        }
      }
    };
    NgSwitch = class _NgSwitch {
      _defaultViews = [];
      _defaultUsed = false;
      _caseCount = 0;
      _lastCaseCheckIndex = 0;
      _lastCasesMatched = false;
      _ngSwitch;
      /** @deprecated Use the `@switch` block instead. Intent to remove in v22 */
      set ngSwitch(newValue) {
        this._ngSwitch = newValue;
        if (this._caseCount === 0) {
          this._updateDefaultCases(true);
        }
      }
      /** @internal */
      _addCase() {
        return this._caseCount++;
      }
      /** @internal */
      _addDefault(view) {
        this._defaultViews.push(view);
      }
      /** @internal */
      _matchCase(value) {
        const matched = value === this._ngSwitch;
        this._lastCasesMatched ||= matched;
        this._lastCaseCheckIndex++;
        if (this._lastCaseCheckIndex === this._caseCount) {
          this._updateDefaultCases(!this._lastCasesMatched);
          this._lastCaseCheckIndex = 0;
          this._lastCasesMatched = false;
        }
        return matched;
      }
      _updateDefaultCases(useDefault) {
        if (this._defaultViews.length > 0 && useDefault !== this._defaultUsed) {
          this._defaultUsed = useDefault;
          for (const defaultView of this._defaultViews) {
            defaultView.enforceState(useDefault);
          }
        }
      }
      static \u0275fac = function NgSwitch_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgSwitch)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgSwitch,
        selectors: [["", "ngSwitch", ""]],
        inputs: {
          ngSwitch: "ngSwitch"
        }
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitch, [{
        type: Directive,
        args: [{
          selector: "[ngSwitch]"
        }]
      }], null, {
        ngSwitch: [{
          type: Input
        }]
      });
    })();
    NgSwitchCase = class _NgSwitchCase {
      ngSwitch;
      _view;
      /**
       * Stores the HTML template to be selected on match.
       * @deprecated Use the `@case` block within a `@switch` block instead. Intent to remove in v22
       */
      ngSwitchCase;
      constructor(viewContainer, templateRef, ngSwitch) {
        this.ngSwitch = ngSwitch;
        if ((typeof ngDevMode === "undefined" || ngDevMode) && !ngSwitch) {
          throwNgSwitchProviderNotFoundError("ngSwitchCase", "NgSwitchCase");
        }
        ngSwitch._addCase();
        this._view = new SwitchView(viewContainer, templateRef);
      }
      /**
       * Performs case matching. For internal use only.
       * @docs-private
       */
      ngDoCheck() {
        this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase));
      }
      static \u0275fac = function NgSwitchCase_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgSwitchCase)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(NgSwitch, 9));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgSwitchCase,
        selectors: [["", "ngSwitchCase", ""]],
        inputs: {
          ngSwitchCase: "ngSwitchCase"
        }
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitchCase, [{
        type: Directive,
        args: [{
          selector: "[ngSwitchCase]"
        }]
      }], () => [{
        type: ViewContainerRef
      }, {
        type: TemplateRef
      }, {
        type: NgSwitch,
        decorators: [{
          type: Optional
        }, {
          type: Host
        }]
      }], {
        ngSwitchCase: [{
          type: Input
        }]
      });
    })();
    NgSwitchDefault = class _NgSwitchDefault {
      constructor(viewContainer, templateRef, ngSwitch) {
        if ((typeof ngDevMode === "undefined" || ngDevMode) && !ngSwitch) {
          throwNgSwitchProviderNotFoundError("ngSwitchDefault", "NgSwitchDefault");
        }
        ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));
      }
      static \u0275fac = function NgSwitchDefault_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgSwitchDefault)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(NgSwitch, 9));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgSwitchDefault,
        selectors: [["", "ngSwitchDefault", ""]]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitchDefault, [{
        type: Directive,
        args: [{
          selector: "[ngSwitchDefault]"
        }]
      }], () => [{
        type: ViewContainerRef
      }, {
        type: TemplateRef
      }, {
        type: NgSwitch,
        decorators: [{
          type: Optional
        }, {
          type: Host
        }]
      }], null);
    })();
    NgPlural = class _NgPlural {
      _localization;
      _activeView;
      _caseViews = {};
      constructor(_localization) {
        this._localization = _localization;
      }
      set ngPlural(value) {
        this._updateView(value);
      }
      addCase(value, switchView) {
        this._caseViews[value] = switchView;
      }
      _updateView(switchValue) {
        this._clearViews();
        const cases = Object.keys(this._caseViews);
        const key = getPluralCategory(switchValue, cases, this._localization);
        this._activateView(this._caseViews[key]);
      }
      _clearViews() {
        if (this._activeView) this._activeView.destroy();
      }
      _activateView(view) {
        if (view) {
          this._activeView = view;
          this._activeView.create();
        }
      }
      static \u0275fac = function NgPlural_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgPlural)(\u0275\u0275directiveInject(NgLocalization));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgPlural,
        selectors: [["", "ngPlural", ""]],
        inputs: {
          ngPlural: "ngPlural"
        }
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgPlural, [{
        type: Directive,
        args: [{
          selector: "[ngPlural]"
        }]
      }], () => [{
        type: NgLocalization
      }], {
        ngPlural: [{
          type: Input
        }]
      });
    })();
    NgPluralCase = class _NgPluralCase {
      value;
      constructor(value, template, viewContainer, ngPlural) {
        this.value = value;
        const isANumber = !isNaN(Number(value));
        ngPlural.addCase(isANumber ? `=${value}` : value, new SwitchView(viewContainer, template));
      }
      static \u0275fac = function NgPluralCase_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgPluralCase)(\u0275\u0275injectAttribute("ngPluralCase"), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(NgPlural, 1));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgPluralCase,
        selectors: [["", "ngPluralCase", ""]]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgPluralCase, [{
        type: Directive,
        args: [{
          selector: "[ngPluralCase]"
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Attribute,
          args: ["ngPluralCase"]
        }]
      }, {
        type: TemplateRef
      }, {
        type: ViewContainerRef
      }, {
        type: NgPlural,
        decorators: [{
          type: Host
        }]
      }], null);
    })();
    NgStyle = class _NgStyle {
      _ngEl;
      _differs;
      _renderer;
      _ngStyle = null;
      _differ = null;
      constructor(_ngEl, _differs, _renderer) {
        this._ngEl = _ngEl;
        this._differs = _differs;
        this._renderer = _renderer;
      }
      set ngStyle(values2) {
        this._ngStyle = values2;
        if (!this._differ && values2) {
          this._differ = this._differs.find(values2).create();
        }
      }
      ngDoCheck() {
        if (this._differ) {
          const changes = this._differ.diff(this._ngStyle);
          if (changes) {
            this._applyChanges(changes);
          }
        }
      }
      _setStyle(nameAndUnit, value) {
        const [name2, unit] = nameAndUnit.split(".");
        const flags = name2.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
        if (value != null) {
          this._renderer.setStyle(this._ngEl.nativeElement, name2, unit ? `${value}${unit}` : value, flags);
        } else {
          this._renderer.removeStyle(this._ngEl.nativeElement, name2, flags);
        }
      }
      _applyChanges(changes) {
        changes.forEachRemovedItem((record) => this._setStyle(record.key, null));
        changes.forEachAddedItem((record) => this._setStyle(record.key, record.currentValue));
        changes.forEachChangedItem((record) => this._setStyle(record.key, record.currentValue));
      }
      static \u0275fac = function NgStyle_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgStyle)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(KeyValueDiffers), \u0275\u0275directiveInject(Renderer2));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgStyle,
        selectors: [["", "ngStyle", ""]],
        inputs: {
          ngStyle: "ngStyle"
        }
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgStyle, [{
        type: Directive,
        args: [{
          selector: "[ngStyle]"
        }]
      }], () => [{
        type: ElementRef
      }, {
        type: KeyValueDiffers
      }, {
        type: Renderer2
      }], {
        ngStyle: [{
          type: Input,
          args: ["ngStyle"]
        }]
      });
    })();
    NgTemplateOutlet = class _NgTemplateOutlet {
      _viewContainerRef;
      _viewRef = null;
      /**
       * A context object to attach to the {@link EmbeddedViewRef}. This should be an
       * object, the object's keys will be available for binding by the local template `let`
       * declarations.
       * Using the key `$implicit` in the context object will set its value as default.
       */
      ngTemplateOutletContext = null;
      /**
       * A string defining the template reference and optionally the context object for the template.
       */
      ngTemplateOutlet = null;
      /** Injector to be used within the embedded view. */
      ngTemplateOutletInjector = null;
      constructor(_viewContainerRef) {
        this._viewContainerRef = _viewContainerRef;
      }
      ngOnChanges(changes) {
        if (this._shouldRecreateView(changes)) {
          const viewContainerRef = this._viewContainerRef;
          if (this._viewRef) {
            viewContainerRef.remove(viewContainerRef.indexOf(this._viewRef));
          }
          if (!this.ngTemplateOutlet) {
            this._viewRef = null;
            return;
          }
          const viewContext = this._createContextForwardProxy();
          this._viewRef = viewContainerRef.createEmbeddedView(this.ngTemplateOutlet, viewContext, {
            injector: this.ngTemplateOutletInjector ?? void 0
          });
        }
      }
      /**
       * We need to re-create existing embedded view if either is true:
       * - the outlet changed.
       * - the injector changed.
       */
      _shouldRecreateView(changes) {
        return !!changes["ngTemplateOutlet"] || !!changes["ngTemplateOutletInjector"];
      }
      /**
       * For a given outlet instance, we create a proxy object that delegates
       * to the user-specified context. This allows changing, or swapping out
       * the context object completely without having to destroy/re-create the view.
       */
      _createContextForwardProxy() {
        return new Proxy({}, {
          set: (_target, prop, newValue) => {
            if (!this.ngTemplateOutletContext) {
              return false;
            }
            return Reflect.set(this.ngTemplateOutletContext, prop, newValue);
          },
          get: (_target, prop, receiver) => {
            if (!this.ngTemplateOutletContext) {
              return void 0;
            }
            return Reflect.get(this.ngTemplateOutletContext, prop, receiver);
          }
        });
      }
      static \u0275fac = function NgTemplateOutlet_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgTemplateOutlet)(\u0275\u0275directiveInject(ViewContainerRef));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgTemplateOutlet,
        selectors: [["", "ngTemplateOutlet", ""]],
        inputs: {
          ngTemplateOutletContext: "ngTemplateOutletContext",
          ngTemplateOutlet: "ngTemplateOutlet",
          ngTemplateOutletInjector: "ngTemplateOutletInjector"
        },
        features: [\u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgTemplateOutlet, [{
        type: Directive,
        args: [{
          selector: "[ngTemplateOutlet]"
        }]
      }], () => [{
        type: ViewContainerRef
      }], {
        ngTemplateOutletContext: [{
          type: Input
        }],
        ngTemplateOutlet: [{
          type: Input
        }],
        ngTemplateOutletInjector: [{
          type: Input
        }]
      });
    })();
    COMMON_DIRECTIVES = [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase];
    SubscribableStrategy = class {
      createSubscription(async2, updateLatestValue, onError) {
        return untracked2(() => async2.subscribe({
          next: updateLatestValue,
          error: onError
        }));
      }
      dispose(subscription) {
        untracked2(() => subscription.unsubscribe());
      }
    };
    PromiseStrategy = class {
      createSubscription(async2, updateLatestValue, onError) {
        async2.then(
          // Using optional chaining because we may have set it to `null`; since the promise
          // is async, the view might be destroyed by the time the promise resolves.
          (v) => updateLatestValue?.(v),
          (e) => onError?.(e)
        );
        return {
          unsubscribe: () => {
            updateLatestValue = null;
            onError = null;
          }
        };
      }
      dispose(subscription) {
        subscription.unsubscribe();
      }
    };
    _promiseStrategy = new PromiseStrategy();
    _subscribableStrategy = new SubscribableStrategy();
    AsyncPipe = class _AsyncPipe {
      _ref;
      _latestValue = null;
      markForCheckOnValueUpdate = true;
      _subscription = null;
      _obj = null;
      _strategy = null;
      applicationErrorHandler = inject2(INTERNAL_APPLICATION_ERROR_HANDLER);
      constructor(ref) {
        this._ref = ref;
      }
      ngOnDestroy() {
        if (this._subscription) {
          this._dispose();
        }
        this._ref = null;
      }
      transform(obj) {
        if (!this._obj) {
          if (obj) {
            try {
              this.markForCheckOnValueUpdate = false;
              this._subscribe(obj);
            } finally {
              this.markForCheckOnValueUpdate = true;
            }
          }
          return this._latestValue;
        }
        if (obj !== this._obj) {
          this._dispose();
          return this.transform(obj);
        }
        return this._latestValue;
      }
      _subscribe(obj) {
        this._obj = obj;
        this._strategy = this._selectStrategy(obj);
        this._subscription = this._strategy.createSubscription(obj, (value) => this._updateLatestValue(obj, value), (e) => this.applicationErrorHandler(e));
      }
      _selectStrategy(obj) {
        if (isPromise2(obj)) {
          return _promiseStrategy;
        }
        if (isSubscribable(obj)) {
          return _subscribableStrategy;
        }
        throw invalidPipeArgumentError(_AsyncPipe, obj);
      }
      _dispose() {
        this._strategy.dispose(this._subscription);
        this._latestValue = null;
        this._subscription = null;
        this._obj = null;
      }
      _updateLatestValue(async2, value) {
        if (async2 === this._obj) {
          this._latestValue = value;
          if (this.markForCheckOnValueUpdate) {
            this._ref?.markForCheck();
          }
        }
      }
      static \u0275fac = function AsyncPipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _AsyncPipe)(\u0275\u0275directiveInject(ChangeDetectorRef, 16));
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "async",
        type: _AsyncPipe,
        pure: false
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AsyncPipe, [{
        type: Pipe,
        args: [{
          name: "async",
          pure: false
        }]
      }], () => [{
        type: ChangeDetectorRef
      }], null);
    })();
    LowerCasePipe = class _LowerCasePipe {
      transform(value) {
        if (value == null) return null;
        if (typeof value !== "string") {
          throw invalidPipeArgumentError(_LowerCasePipe, value);
        }
        return value.toLowerCase();
      }
      static \u0275fac = function LowerCasePipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _LowerCasePipe)();
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "lowercase",
        type: _LowerCasePipe,
        pure: true
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LowerCasePipe, [{
        type: Pipe,
        args: [{
          name: "lowercase"
        }]
      }], null, null);
    })();
    unicodeWordMatch = /(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])\S*/g;
    TitleCasePipe = class _TitleCasePipe {
      transform(value) {
        if (value == null) return null;
        if (typeof value !== "string") {
          throw invalidPipeArgumentError(_TitleCasePipe, value);
        }
        return value.replace(unicodeWordMatch, (txt) => txt[0].toUpperCase() + txt.slice(1).toLowerCase());
      }
      static \u0275fac = function TitleCasePipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _TitleCasePipe)();
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "titlecase",
        type: _TitleCasePipe,
        pure: true
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TitleCasePipe, [{
        type: Pipe,
        args: [{
          name: "titlecase"
        }]
      }], null, null);
    })();
    UpperCasePipe = class _UpperCasePipe {
      transform(value) {
        if (value == null) return null;
        if (typeof value !== "string") {
          throw invalidPipeArgumentError(_UpperCasePipe, value);
        }
        return value.toUpperCase();
      }
      static \u0275fac = function UpperCasePipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _UpperCasePipe)();
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "uppercase",
        type: _UpperCasePipe,
        pure: true
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UpperCasePipe, [{
        type: Pipe,
        args: [{
          name: "uppercase"
        }]
      }], null, null);
    })();
    DEFAULT_DATE_FORMAT = "mediumDate";
    DATE_PIPE_DEFAULT_TIMEZONE = new InjectionToken(ngDevMode ? "DATE_PIPE_DEFAULT_TIMEZONE" : "");
    DATE_PIPE_DEFAULT_OPTIONS = new InjectionToken(ngDevMode ? "DATE_PIPE_DEFAULT_OPTIONS" : "");
    DatePipe = class _DatePipe {
      locale;
      defaultTimezone;
      defaultOptions;
      constructor(locale, defaultTimezone, defaultOptions) {
        this.locale = locale;
        this.defaultTimezone = defaultTimezone;
        this.defaultOptions = defaultOptions;
      }
      transform(value, format, timezone, locale) {
        if (value == null || value === "" || value !== value) return null;
        try {
          const _format = format ?? this.defaultOptions?.dateFormat ?? DEFAULT_DATE_FORMAT;
          const _timezone = timezone ?? this.defaultOptions?.timezone ?? this.defaultTimezone ?? void 0;
          return formatDate(value, _format, locale || this.locale, _timezone);
        } catch (error) {
          throw invalidPipeArgumentError(_DatePipe, error.message);
        }
      }
      static \u0275fac = function DatePipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DatePipe)(\u0275\u0275directiveInject(LOCALE_ID, 16), \u0275\u0275directiveInject(DATE_PIPE_DEFAULT_TIMEZONE, 24), \u0275\u0275directiveInject(DATE_PIPE_DEFAULT_OPTIONS, 24));
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "date",
        type: _DatePipe,
        pure: true
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePipe, [{
        type: Pipe,
        args: [{
          name: "date"
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [LOCALE_ID]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DATE_PIPE_DEFAULT_TIMEZONE]
        }, {
          type: Optional
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DATE_PIPE_DEFAULT_OPTIONS]
        }, {
          type: Optional
        }]
      }], null);
    })();
    _INTERPOLATION_REGEXP = /#/g;
    I18nPluralPipe = class _I18nPluralPipe {
      _localization;
      constructor(_localization) {
        this._localization = _localization;
      }
      /**
       * @param value the number to be formatted
       * @param pluralMap an object that mimics the ICU format, see
       * https://unicode-org.github.io/icu/userguide/format_parse/messages/.
       * @param locale a `string` defining the locale to use (uses the current {@link LOCALE_ID} by
       * default).
       */
      transform(value, pluralMap, locale) {
        if (value == null) return "";
        if (typeof pluralMap !== "object" || pluralMap === null) {
          throw invalidPipeArgumentError(_I18nPluralPipe, pluralMap);
        }
        const key = getPluralCategory(value, Object.keys(pluralMap), this._localization, locale);
        return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());
      }
      static \u0275fac = function I18nPluralPipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _I18nPluralPipe)(\u0275\u0275directiveInject(NgLocalization, 16));
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "i18nPlural",
        type: _I18nPluralPipe,
        pure: true
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(I18nPluralPipe, [{
        type: Pipe,
        args: [{
          name: "i18nPlural"
        }]
      }], () => [{
        type: NgLocalization
      }], null);
    })();
    I18nSelectPipe = class _I18nSelectPipe {
      /**
       * @param value a string to be internationalized.
       * @param mapping an object that indicates the text that should be displayed
       * for different values of the provided `value`.
       */
      transform(value, mapping) {
        if (value == null) return "";
        if (typeof mapping !== "object" || typeof value !== "string") {
          throw invalidPipeArgumentError(_I18nSelectPipe, mapping);
        }
        if (mapping.hasOwnProperty(value)) {
          return mapping[value];
        }
        if (mapping.hasOwnProperty("other")) {
          return mapping["other"];
        }
        return "";
      }
      static \u0275fac = function I18nSelectPipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _I18nSelectPipe)();
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "i18nSelect",
        type: _I18nSelectPipe,
        pure: true
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(I18nSelectPipe, [{
        type: Pipe,
        args: [{
          name: "i18nSelect"
        }]
      }], null, null);
    })();
    JsonPipe = class _JsonPipe {
      /**
       * @param value A value of any type to convert into a JSON-format string.
       */
      transform(value) {
        return JSON.stringify(value, null, 2);
      }
      static \u0275fac = function JsonPipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _JsonPipe)();
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "json",
        type: _JsonPipe,
        pure: false
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonPipe, [{
        type: Pipe,
        args: [{
          name: "json",
          pure: false
        }]
      }], null, null);
    })();
    KeyValuePipe = class _KeyValuePipe {
      differs;
      constructor(differs) {
        this.differs = differs;
      }
      differ;
      keyValues = [];
      compareFn = defaultComparator;
      transform(input2, compareFn = defaultComparator) {
        if (!input2 || !(input2 instanceof Map) && typeof input2 !== "object") {
          return null;
        }
        this.differ ??= this.differs.find(input2).create();
        const differChanges = this.differ.diff(input2);
        const compareFnChanged = compareFn !== this.compareFn;
        if (differChanges) {
          this.keyValues = [];
          differChanges.forEachItem((r) => {
            this.keyValues.push(makeKeyValuePair(r.key, r.currentValue));
          });
        }
        if (differChanges || compareFnChanged) {
          if (compareFn) {
            this.keyValues.sort(compareFn);
          }
          this.compareFn = compareFn;
        }
        return this.keyValues;
      }
      static \u0275fac = function KeyValuePipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _KeyValuePipe)(\u0275\u0275directiveInject(KeyValueDiffers, 16));
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "keyvalue",
        type: _KeyValuePipe,
        pure: false
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyValuePipe, [{
        type: Pipe,
        args: [{
          name: "keyvalue",
          pure: false
        }]
      }], () => [{
        type: KeyValueDiffers
      }], null);
    })();
    DecimalPipe = class _DecimalPipe {
      _locale;
      constructor(_locale) {
        this._locale = _locale;
      }
      transform(value, digitsInfo, locale) {
        if (!isValue(value)) return null;
        locale ||= this._locale;
        try {
          const num = strToNumber(value);
          return formatNumber(num, locale, digitsInfo);
        } catch (error) {
          throw invalidPipeArgumentError(_DecimalPipe, error.message);
        }
      }
      static \u0275fac = function DecimalPipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DecimalPipe)(\u0275\u0275directiveInject(LOCALE_ID, 16));
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "number",
        type: _DecimalPipe,
        pure: true
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DecimalPipe, [{
        type: Pipe,
        args: [{
          name: "number"
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [LOCALE_ID]
        }]
      }], null);
    })();
    PercentPipe = class _PercentPipe {
      _locale;
      constructor(_locale) {
        this._locale = _locale;
      }
      /**
       *
       * @param value The number to be formatted as a percentage.
       * @param digitsInfo Decimal representation options, specified by a string
       * in the following format:<br>
       * <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>.
       *   - `minIntegerDigits`: The minimum number of integer digits before the decimal point.
       * Default is `1`.
       *   - `minFractionDigits`: The minimum number of digits after the decimal point.
       * Default is `0`.
       *   - `maxFractionDigits`: The maximum number of digits after the decimal point.
       * Default is `0`.
       * @param locale A locale code for the locale format rules to use.
       * When not supplied, uses the value of `LOCALE_ID`, which is `en-US` by default.
       * See [Setting your app locale](guide/i18n/locale-id).
       */
      transform(value, digitsInfo, locale) {
        if (!isValue(value)) return null;
        locale ||= this._locale;
        try {
          const num = strToNumber(value);
          return formatPercent(num, locale, digitsInfo);
        } catch (error) {
          throw invalidPipeArgumentError(_PercentPipe, error.message);
        }
      }
      static \u0275fac = function PercentPipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _PercentPipe)(\u0275\u0275directiveInject(LOCALE_ID, 16));
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "percent",
        type: _PercentPipe,
        pure: true
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PercentPipe, [{
        type: Pipe,
        args: [{
          name: "percent"
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [LOCALE_ID]
        }]
      }], null);
    })();
    CurrencyPipe = class _CurrencyPipe {
      _locale;
      _defaultCurrencyCode;
      constructor(_locale, _defaultCurrencyCode = "USD") {
        this._locale = _locale;
        this._defaultCurrencyCode = _defaultCurrencyCode;
      }
      transform(value, currencyCode = this._defaultCurrencyCode, display = "symbol", digitsInfo, locale) {
        if (!isValue(value)) return null;
        locale ||= this._locale;
        if (typeof display === "boolean") {
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            console.warn(`Warning: the currency pipe has been changed in Angular v5. The symbolDisplay option (third parameter) is now a string instead of a boolean. The accepted values are "code", "symbol" or "symbol-narrow".`);
          }
          display = display ? "symbol" : "code";
        }
        let currency = currencyCode || this._defaultCurrencyCode;
        if (display !== "code") {
          if (display === "symbol" || display === "symbol-narrow") {
            currency = getCurrencySymbol(currency, display === "symbol" ? "wide" : "narrow", locale);
          } else {
            currency = display;
          }
        }
        try {
          const num = strToNumber(value);
          return formatCurrency(num, locale, currency, currencyCode, digitsInfo);
        } catch (error) {
          throw invalidPipeArgumentError(_CurrencyPipe, error.message);
        }
      }
      static \u0275fac = function CurrencyPipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CurrencyPipe)(\u0275\u0275directiveInject(LOCALE_ID, 16), \u0275\u0275directiveInject(DEFAULT_CURRENCY_CODE, 16));
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "currency",
        type: _CurrencyPipe,
        pure: true
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CurrencyPipe, [{
        type: Pipe,
        args: [{
          name: "currency"
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [LOCALE_ID]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DEFAULT_CURRENCY_CODE]
        }]
      }], null);
    })();
    SlicePipe = class _SlicePipe {
      transform(value, start, end) {
        if (value == null) return null;
        const supports = typeof value === "string" || Array.isArray(value);
        if (!supports) {
          throw invalidPipeArgumentError(_SlicePipe, value);
        }
        return value.slice(start, end);
      }
      static \u0275fac = function SlicePipe_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _SlicePipe)();
      };
      static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
        name: "slice",
        type: _SlicePipe,
        pure: false
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SlicePipe, [{
        type: Pipe,
        args: [{
          name: "slice",
          pure: false
        }]
      }], null, null);
    })();
    COMMON_PIPES = [AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe];
    CommonModule = class _CommonModule {
      static \u0275fac = function CommonModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CommonModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _CommonModule,
        imports: [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase, AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe],
        exports: [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase, AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe]
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CommonModule, [{
        type: NgModule,
        args: [{
          imports: [COMMON_DIRECTIVES, COMMON_PIPES],
          exports: [COMMON_DIRECTIVES, COMMON_PIPES]
        }]
      }], null, null);
    })();
  }
});

// node_modules/@angular/common/fesm2022/xhr.mjs
function parseCookieValue(cookieStr, name2) {
  name2 = encodeURIComponent(name2);
  for (const cookie of cookieStr.split(";")) {
    const eqIndex = cookie.indexOf("=");
    const [cookieName, cookieValue] = eqIndex == -1 ? [cookie, ""] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)];
    if (cookieName.trim() === name2) {
      return decodeURIComponent(cookieValue);
    }
  }
  return null;
}
var XhrFactory;
var init_xhr = __esm({
  "node_modules/@angular/common/fesm2022/xhr.mjs"() {
    "use strict";
    XhrFactory = class {
    };
  }
});

// node_modules/@angular/common/fesm2022/common.mjs
function isPlatformBrowser(platformId) {
  return platformId === PLATFORM_BROWSER_ID;
}
function findAnchorFromDocument(document2, target) {
  const documentResult = document2.getElementById(target) || document2.getElementsByName(target)[0];
  if (documentResult) {
    return documentResult;
  }
  if (typeof document2.createTreeWalker === "function" && document2.body && typeof document2.body.attachShadow === "function") {
    const treeWalker = document2.createTreeWalker(document2.body, NodeFilter.SHOW_ELEMENT);
    let currentNode = treeWalker.currentNode;
    while (currentNode) {
      const shadowRoot = currentNode.shadowRoot;
      if (shadowRoot) {
        const result = shadowRoot.getElementById(target) || shadowRoot.querySelector(`[name="${target}"]`);
        if (result) {
          return result;
        }
      }
      currentNode = treeWalker.nextNode();
    }
  }
  return null;
}
function getUrl(src, win) {
  return isAbsoluteUrl(src) ? new URL(src) : new URL(src, win.location.href);
}
function isAbsoluteUrl(src) {
  return /^https?:\/\//.test(src);
}
function extractHostname(url) {
  return isAbsoluteUrl(url) ? new URL(url).hostname : url;
}
function isValidPath(path) {
  const isString = typeof path === "string";
  if (!isString || path.trim() === "") {
    return false;
  }
  try {
    const url = new URL(path);
    return true;
  } catch {
    return false;
  }
}
function normalizePath(path) {
  return path.endsWith("/") ? path.slice(0, -1) : path;
}
function normalizeSrc(src) {
  return src.startsWith("/") ? src.slice(1) : src;
}
function createImageLoader(buildUrlFn, exampleUrls) {
  return function provideImageLoader(path) {
    if (!isValidPath(path)) {
      throwInvalidPathError(path, exampleUrls || []);
    }
    path = normalizePath(path);
    const loaderFn = (config3) => {
      if (isAbsoluteUrl(config3.src)) {
        throwUnexpectedAbsoluteUrlError(path, config3.src);
      }
      return buildUrlFn(path, __spreadProps(__spreadValues({}, config3), {
        src: normalizeSrc(config3.src)
      }));
    };
    const providers = [{
      provide: IMAGE_LOADER,
      useValue: loaderFn
    }];
    return providers;
  };
}
function throwInvalidPathError(path, exampleUrls) {
  throw new RuntimeError(2959, ngDevMode && `Image loader has detected an invalid path (\`${path}\`). To fix this, supply a path using one of the following formats: ${exampleUrls.join(" or ")}`);
}
function throwUnexpectedAbsoluteUrlError(path, url) {
  throw new RuntimeError(2959, ngDevMode && `Image loader has detected a \`<img>\` tag with an invalid \`ngSrc\` attribute: ${url}. This image loader expects \`ngSrc\` to be a relative URL - however the provided value is an absolute URL. To fix this, provide \`ngSrc\` as a path relative to the base URL configured for this loader (\`${path}\`).`);
}
function createCloudflareUrl(path, config3) {
  let params = `format=auto`;
  if (config3.width) {
    params += `,width=${config3.width}`;
  }
  if (config3.isPlaceholder) {
    params += `,quality=${PLACEHOLDER_QUALITY}`;
  }
  return `${path}/cdn-cgi/image/${params}/${config3.src}`;
}
function isCloudinaryUrl(url) {
  return CLOUDINARY_LOADER_REGEX.test(url);
}
function createCloudinaryUrl(path, config3) {
  const quality = config3.isPlaceholder ? "q_auto:low" : "q_auto";
  let params = `f_auto,${quality}`;
  if (config3.width) {
    params += `,w_${config3.width}`;
  }
  if (config3.loaderParams?.["rounded"]) {
    params += `,r_max`;
  }
  return `${path}/image/upload/${params}/${config3.src}`;
}
function isImageKitUrl(url) {
  return IMAGE_KIT_LOADER_REGEX.test(url);
}
function createImagekitUrl(path, config3) {
  const {
    src,
    width
  } = config3;
  const params = [];
  if (width) {
    params.push(`w-${width}`);
  }
  if (config3.isPlaceholder) {
    params.push(`q-${PLACEHOLDER_QUALITY}`);
  }
  const urlSegments = params.length ? [path, `tr:${params.join(",")}`, src] : [path, src];
  const url = new URL(urlSegments.join("/"));
  return url.href;
}
function isImgixUrl(url) {
  return IMGIX_LOADER_REGEX.test(url);
}
function createImgixUrl(path, config3) {
  const url = new URL(`${path}/${config3.src}`);
  url.searchParams.set("auto", "format");
  if (config3.width) {
    url.searchParams.set("w", config3.width.toString());
  }
  if (config3.isPlaceholder) {
    url.searchParams.set("q", PLACEHOLDER_QUALITY);
  }
  return url.href;
}
function isNetlifyUrl(url) {
  return NETLIFY_LOADER_REGEX.test(url);
}
function imgDirectiveDetails(ngSrc, includeNgSrc = true) {
  const ngSrcInfo = includeNgSrc ? `(activated on an <img> element with the \`ngSrc="${ngSrc}"\`) ` : "";
  return `The NgOptimizedImage directive ${ngSrcInfo}has detected that`;
}
function assertDevMode(checkName) {
  if (!ngDevMode) {
    throw new RuntimeError(2958, `Unexpected invocation of the ${checkName} in the prod mode. Please make sure that the prod mode is enabled for production builds.`);
  }
}
function logMissingPriorityError(ngSrc) {
  const directiveDetails = imgDirectiveDetails(ngSrc);
  console.error(formatRuntimeError(2955, `${directiveDetails} this image is the Largest Contentful Paint (LCP) element but was not marked "priority". This image should be marked "priority" in order to prioritize its loading. To fix this, add the "priority" attribute.`));
}
function logModifiedWarning(ngSrc) {
  const directiveDetails = imgDirectiveDetails(ngSrc);
  console.warn(formatRuntimeError(2964, `${directiveDetails} this image is the Largest Contentful Paint (LCP) element and has had its "ngSrc" attribute modified. This can cause slower loading performance. It is recommended not to modify the "ngSrc" property on any image which could be the LCP element.`));
}
function deepForEach2(input2, fn) {
  for (let value of input2) {
    Array.isArray(value) ? deepForEach2(value, fn) : fn(value);
  }
}
function processConfig(config3) {
  let sortedBreakpoints = {};
  if (config3.breakpoints) {
    sortedBreakpoints.breakpoints = config3.breakpoints.sort((a, b) => a - b);
  }
  return Object.assign({}, IMAGE_CONFIG_DEFAULTS, config3, sortedBreakpoints);
}
function assertNoConflictingSrc(dir) {
  if (dir.src) {
    throw new RuntimeError(2950, `${imgDirectiveDetails(dir.ngSrc)} both \`src\` and \`ngSrc\` have been set. Supplying both of these attributes breaks lazy loading. The NgOptimizedImage directive sets \`src\` itself based on the value of \`ngSrc\`. To fix this, please remove the \`src\` attribute.`);
  }
}
function assertNoConflictingSrcset(dir) {
  if (dir.srcset) {
    throw new RuntimeError(2951, `${imgDirectiveDetails(dir.ngSrc)} both \`srcset\` and \`ngSrcset\` have been set. Supplying both of these attributes breaks lazy loading. The NgOptimizedImage directive sets \`srcset\` itself based on the value of \`ngSrcset\`. To fix this, please remove the \`srcset\` attribute.`);
  }
}
function assertNotBase64Image(dir) {
  let ngSrc = dir.ngSrc.trim();
  if (ngSrc.startsWith("data:")) {
    if (ngSrc.length > BASE64_IMG_MAX_LENGTH_IN_ERROR) {
      ngSrc = ngSrc.substring(0, BASE64_IMG_MAX_LENGTH_IN_ERROR) + "...";
    }
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`ngSrc\` is a Base64-encoded string (${ngSrc}). NgOptimizedImage does not support Base64-encoded strings. To fix this, disable the NgOptimizedImage directive for this element by removing \`ngSrc\` and using a standard \`src\` attribute instead.`);
  }
}
function assertNoComplexSizes(dir) {
  let sizes = dir.sizes;
  if (sizes?.match(/((\)|,)\s|^)\d+px/)) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`sizes\` was set to a string including pixel values. For automatic \`srcset\` generation, \`sizes\` must only include responsive values, such as \`sizes="50vw"\` or \`sizes="(min-width: 768px) 50vw, 100vw"\`. To fix this, modify the \`sizes\` attribute, or provide your own \`ngSrcset\` value directly.`);
  }
}
function assertValidPlaceholder(dir, imageLoader) {
  assertNoPlaceholderConfigWithoutPlaceholder(dir);
  assertNoRelativePlaceholderWithoutLoader(dir, imageLoader);
  assertNoOversizedDataUrl(dir);
}
function assertNoPlaceholderConfigWithoutPlaceholder(dir) {
  if (dir.placeholderConfig && !dir.placeholder) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`placeholderConfig\` options were provided for an image that does not use the \`placeholder\` attribute, and will have no effect.`);
  }
}
function assertNoRelativePlaceholderWithoutLoader(dir, imageLoader) {
  if (dir.placeholder === true && imageLoader === noopImageLoader) {
    throw new RuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to true but no image loader is configured (i.e. the default one is being used), which would result in the same image being used for the primary image and its placeholder. To fix this, provide a loader or remove the \`placeholder\` attribute from the image.`);
  }
}
function assertNoOversizedDataUrl(dir) {
  if (dir.placeholder && typeof dir.placeholder === "string" && dir.placeholder.startsWith("data:")) {
    if (dir.placeholder.length > DATA_URL_ERROR_LIMIT) {
      throw new RuntimeError(2965, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to a data URL which is longer than ${DATA_URL_ERROR_LIMIT} characters. This is strongly discouraged, as large inline placeholders directly increase the bundle size of Angular and hurt page load performance. To fix this, generate a smaller data URL placeholder.`);
    }
    if (dir.placeholder.length > DATA_URL_WARN_LIMIT) {
      console.warn(formatRuntimeError(2965, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to a data URL which is longer than ${DATA_URL_WARN_LIMIT} characters. This is discouraged, as large inline placeholders directly increase the bundle size of Angular and hurt page load performance. For better loading performance, generate a smaller data URL placeholder.`));
    }
  }
}
function assertNotBlobUrl(dir) {
  const ngSrc = dir.ngSrc.trim();
  if (ngSrc.startsWith("blob:")) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`ngSrc\` was set to a blob URL (${ngSrc}). Blob URLs are not supported by the NgOptimizedImage directive. To fix this, disable the NgOptimizedImage directive for this element by removing \`ngSrc\` and using a regular \`src\` attribute instead.`);
  }
}
function assertNonEmptyInput(dir, name2, value) {
  const isString = typeof value === "string";
  const isEmptyString = isString && value.trim() === "";
  if (!isString || isEmptyString) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`${name2}\` has an invalid value (\`${value}\`). To fix this, change the value to a non-empty string.`);
  }
}
function assertValidNgSrcset(dir, value) {
  if (value == null) return;
  assertNonEmptyInput(dir, "ngSrcset", value);
  const stringVal = value;
  const isValidWidthDescriptor = VALID_WIDTH_DESCRIPTOR_SRCSET.test(stringVal);
  const isValidDensityDescriptor = VALID_DENSITY_DESCRIPTOR_SRCSET.test(stringVal);
  if (isValidDensityDescriptor) {
    assertUnderDensityCap(dir, stringVal);
  }
  const isValidSrcset = isValidWidthDescriptor || isValidDensityDescriptor;
  if (!isValidSrcset) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`ngSrcset\` has an invalid value (\`${value}\`). To fix this, supply \`ngSrcset\` using a comma-separated list of one or more width descriptors (e.g. "100w, 200w") or density descriptors (e.g. "1x, 2x").`);
  }
}
function assertUnderDensityCap(dir, value) {
  const underDensityCap = value.split(",").every((num) => num === "" || parseFloat(num) <= ABSOLUTE_SRCSET_DENSITY_CAP);
  if (!underDensityCap) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`ngSrcset\` contains an unsupported image density:\`${value}\`. NgOptimizedImage generally recommends a max image density of ${RECOMMENDED_SRCSET_DENSITY_CAP}x but supports image densities up to ${ABSOLUTE_SRCSET_DENSITY_CAP}x. The human eye cannot distinguish between image densities greater than ${RECOMMENDED_SRCSET_DENSITY_CAP}x - which makes them unnecessary for most use cases. Images that will be pinch-zoomed are typically the primary use case for ${ABSOLUTE_SRCSET_DENSITY_CAP}x images. Please remove the high density descriptor and try again.`);
  }
}
function postInitInputChangeError(dir, inputName) {
  let reason;
  if (inputName === "width" || inputName === "height") {
    reason = `Changing \`${inputName}\` may result in different attribute value applied to the underlying image element and cause layout shifts on a page.`;
  } else {
    reason = `Changing the \`${inputName}\` would have no effect on the underlying image element, because the resource loading has already occurred.`;
  }
  return new RuntimeError(2953, `${imgDirectiveDetails(dir.ngSrc)} \`${inputName}\` was updated after initialization. The NgOptimizedImage directive will not react to this input change. ${reason} To fix this, either switch \`${inputName}\` to a static value or wrap the image element in an @if that is gated on the necessary value.`);
}
function assertNoPostInitInputChange(dir, changes, inputs) {
  inputs.forEach((input2) => {
    const isUpdated = changes.hasOwnProperty(input2);
    if (isUpdated && !changes[input2].isFirstChange()) {
      if (input2 === "ngSrc") {
        dir = {
          ngSrc: changes[input2].previousValue
        };
      }
      throw postInitInputChangeError(dir, input2);
    }
  });
}
function assertGreaterThanZero(dir, inputValue, inputName) {
  const validNumber = typeof inputValue === "number" && inputValue > 0;
  const validString = typeof inputValue === "string" && /^\d+$/.test(inputValue.trim()) && parseInt(inputValue) > 0;
  if (!validNumber && !validString) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`${inputName}\` has an invalid value. To fix this, provide \`${inputName}\` as a number greater than 0.`);
  }
}
function assertNoImageDistortion(dir, img, renderer) {
  const callback = () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
    const computedStyle = window.getComputedStyle(img);
    let renderedWidth = parseFloat(computedStyle.getPropertyValue("width"));
    let renderedHeight = parseFloat(computedStyle.getPropertyValue("height"));
    const boxSizing = computedStyle.getPropertyValue("box-sizing");
    if (boxSizing === "border-box") {
      const paddingTop = computedStyle.getPropertyValue("padding-top");
      const paddingRight = computedStyle.getPropertyValue("padding-right");
      const paddingBottom = computedStyle.getPropertyValue("padding-bottom");
      const paddingLeft = computedStyle.getPropertyValue("padding-left");
      renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);
      renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);
    }
    const renderedAspectRatio = renderedWidth / renderedHeight;
    const nonZeroRenderedDimensions = renderedWidth !== 0 && renderedHeight !== 0;
    const intrinsicWidth = img.naturalWidth;
    const intrinsicHeight = img.naturalHeight;
    const intrinsicAspectRatio = intrinsicWidth / intrinsicHeight;
    const suppliedWidth = dir.width;
    const suppliedHeight = dir.height;
    const suppliedAspectRatio = suppliedWidth / suppliedHeight;
    const inaccurateDimensions = Math.abs(suppliedAspectRatio - intrinsicAspectRatio) > ASPECT_RATIO_TOLERANCE;
    const stylingDistortion = nonZeroRenderedDimensions && Math.abs(intrinsicAspectRatio - renderedAspectRatio) > ASPECT_RATIO_TOLERANCE;
    if (inaccurateDimensions) {
      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the image does not match the aspect ratio indicated by the width and height attributes. 
Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h (aspect-ratio: ${round(intrinsicAspectRatio)}). 
Supplied width and height attributes: ${suppliedWidth}w x ${suppliedHeight}h (aspect-ratio: ${round(suppliedAspectRatio)}). 
To fix this, update the width and height attributes.`));
    } else if (stylingDistortion) {
      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the rendered image does not match the image's intrinsic aspect ratio. 
Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h (aspect-ratio: ${round(intrinsicAspectRatio)}). 
Rendered image size: ${renderedWidth}w x ${renderedHeight}h (aspect-ratio: ${round(renderedAspectRatio)}). 
This issue can occur if "width" and "height" attributes are added to an image without updating the corresponding image styling. To fix this, adjust image styling. In most cases, adding "height: auto" or "width: auto" to the image styling will fix this issue.`));
    } else if (!dir.ngSrcset && nonZeroRenderedDimensions) {
      const recommendedWidth = RECOMMENDED_SRCSET_DENSITY_CAP * renderedWidth;
      const recommendedHeight = RECOMMENDED_SRCSET_DENSITY_CAP * renderedHeight;
      const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE2;
      const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE2;
      if (oversizedWidth || oversizedHeight) {
        console.warn(formatRuntimeError(2960, `${imgDirectiveDetails(dir.ngSrc)} the intrinsic image is significantly larger than necessary. 
Rendered image size: ${renderedWidth}w x ${renderedHeight}h. 
Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h. 
Recommended intrinsic image size: ${recommendedWidth}w x ${recommendedHeight}h. 
Note: Recommended intrinsic image size is calculated assuming a maximum DPR of ${RECOMMENDED_SRCSET_DENSITY_CAP}. To improve loading time, resize the image or consider using the "ngSrcset" and "sizes" attributes.`));
      }
    }
  };
  const removeLoadListenerFn = renderer.listen(img, "load", callback);
  const removeErrorListenerFn = renderer.listen(img, "error", () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
  });
  callOnLoadIfImageIsLoaded(img, callback);
}
function assertNonEmptyWidthAndHeight(dir) {
  let missingAttributes = [];
  if (dir.width === void 0) missingAttributes.push("width");
  if (dir.height === void 0) missingAttributes.push("height");
  if (missingAttributes.length > 0) {
    throw new RuntimeError(2954, `${imgDirectiveDetails(dir.ngSrc)} these required attributes are missing: ${missingAttributes.map((attr) => `"${attr}"`).join(", ")}. Including "width" and "height" attributes will prevent image-related layout shifts. To fix this, include "width" and "height" attributes on the image tag or turn on "fill" mode with the \`fill\` attribute.`);
  }
}
function assertEmptyWidthAndHeight(dir) {
  if (dir.width || dir.height) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the attributes \`height\` and/or \`width\` are present along with the \`fill\` attribute. Because \`fill\` mode causes an image to fill its containing element, the size attributes have no effect and should be removed.`);
  }
}
function assertNonZeroRenderedHeight(dir, img, renderer) {
  const callback = () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
    const renderedHeight = img.clientHeight;
    if (dir.fill && renderedHeight === 0) {
      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the height of the fill-mode image is zero. This is likely because the containing element does not have the CSS 'position' property set to one of the following: "relative", "fixed", or "absolute". To fix this problem, make sure the container element has the CSS 'position' property defined and the height of the element is not zero.`));
    }
  };
  const removeLoadListenerFn = renderer.listen(img, "load", callback);
  const removeErrorListenerFn = renderer.listen(img, "error", () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
  });
  callOnLoadIfImageIsLoaded(img, callback);
}
function assertValidLoadingInput(dir) {
  if (dir.loading && dir.priority) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`loading\` attribute was used on an image that was marked "priority". Setting \`loading\` on priority images is not allowed because these images will always be eagerly loaded. To fix this, remove the \u201Cloading\u201D attribute from the priority image.`);
  }
  const validInputs = ["auto", "eager", "lazy"];
  if (typeof dir.loading === "string" && !validInputs.includes(dir.loading)) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`loading\` attribute has an invalid value (\`${dir.loading}\`). To fix this, provide a valid value ("lazy", "eager", or "auto").`);
  }
}
function assertValidDecodingInput(dir) {
  const validInputs = ["sync", "async", "auto"];
  if (typeof dir.decoding === "string" && !validInputs.includes(dir.decoding)) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`decoding\` attribute has an invalid value (\`${dir.decoding}\`). To fix this, provide a valid value ("sync", "async", or "auto").`);
  }
}
function assertNotMissingBuiltInLoader(ngSrc, imageLoader) {
  if (imageLoader === noopImageLoader) {
    let builtInLoaderName = "";
    for (const loader of BUILT_IN_LOADERS) {
      if (loader.testUrl(ngSrc)) {
        builtInLoaderName = loader.name;
        break;
      }
    }
    if (builtInLoaderName) {
      console.warn(formatRuntimeError(2962, `NgOptimizedImage: It looks like your images may be hosted on the ${builtInLoaderName} CDN, but your app is not using Angular's built-in loader for that CDN. We recommend switching to use the built-in by calling \`provide${builtInLoaderName}Loader()\` in your \`providers\` and passing it your instance's base URL. If you don't want to use the built-in loader, define a custom loader function using IMAGE_LOADER to silence this warning.`));
    }
  }
}
function assertNoNgSrcsetWithoutLoader(dir, imageLoader) {
  if (dir.ngSrcset && imageLoader === noopImageLoader) {
    console.warn(formatRuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`ngSrcset\` attribute is present but no image loader is configured (i.e. the default one is being used), which would result in the same image being used for all configured sizes. To fix this, provide a loader or remove the \`ngSrcset\` attribute from the image.`));
  }
}
function assertNoLoaderParamsWithoutLoader(dir, imageLoader) {
  if (dir.loaderParams && imageLoader === noopImageLoader) {
    console.warn(formatRuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`loaderParams\` attribute is present but no image loader is configured (i.e. the default one is being used), which means that the loaderParams data will not be consumed and will not affect the URL. To fix this, provide a custom loader or remove the \`loaderParams\` attribute from the image.`));
  }
}
function assetPriorityCountBelowThreshold(appRef) {
  return __async(this, null, function* () {
    if (IMGS_WITH_PRIORITY_ATTR_COUNT === 0) {
      IMGS_WITH_PRIORITY_ATTR_COUNT++;
      yield appRef.whenStable();
      if (IMGS_WITH_PRIORITY_ATTR_COUNT > PRIORITY_COUNT_THRESHOLD) {
        console.warn(formatRuntimeError(2966, `NgOptimizedImage: The "priority" attribute is set to true more than ${PRIORITY_COUNT_THRESHOLD} times (${IMGS_WITH_PRIORITY_ATTR_COUNT} times). Marking too many images as "high" priority can hurt your application's LCP (https://web.dev/lcp). "Priority" should only be set on the image expected to be the page's LCP element.`));
      }
    } else {
      IMGS_WITH_PRIORITY_ATTR_COUNT++;
    }
  });
}
function assertPlaceholderDimensions(dir, imgElement) {
  const computedStyle = window.getComputedStyle(imgElement);
  let renderedWidth = parseFloat(computedStyle.getPropertyValue("width"));
  let renderedHeight = parseFloat(computedStyle.getPropertyValue("height"));
  if (renderedWidth > PLACEHOLDER_DIMENSION_LIMIT || renderedHeight > PLACEHOLDER_DIMENSION_LIMIT) {
    console.warn(formatRuntimeError(2967, `${imgDirectiveDetails(dir.ngSrc)} it uses a placeholder image, but at least one of the dimensions attribute (height or width) exceeds the limit of ${PLACEHOLDER_DIMENSION_LIMIT}px. To fix this, use a smaller image as a placeholder.`));
  }
}
function callOnLoadIfImageIsLoaded(img, callback) {
  if (img.complete && img.naturalWidth) {
    callback();
  }
}
function round(input2) {
  return Number.isInteger(input2) ? input2 : input2.toFixed(2);
}
function unwrapSafeUrl(value) {
  if (typeof value === "string") {
    return value;
  }
  return unwrapSafeValue(value);
}
function booleanOrUrlAttribute(value) {
  if (typeof value === "string" && value !== "true" && value !== "false" && value !== "") {
    return value;
  }
  return booleanAttribute(value);
}
var PLATFORM_BROWSER_ID, VERSION2, ViewportScroller, BrowserViewportScroller, PLACEHOLDER_QUALITY, noopImageLoader, IMAGE_LOADER, provideCloudflareLoader, cloudinaryLoaderInfo, CLOUDINARY_LOADER_REGEX, provideCloudinaryLoader, imageKitLoaderInfo, IMAGE_KIT_LOADER_REGEX, provideImageKitLoader, imgixLoaderInfo, IMGIX_LOADER_REGEX, provideImgixLoader, netlifyLoaderInfo, NETLIFY_LOADER_REGEX, LCPImageObserver, INTERNAL_PRECONNECT_CHECK_BLOCKLIST, PRECONNECT_CHECK_BLOCKLIST, PreconnectLinkChecker, DEFAULT_PRELOADED_IMAGES_LIMIT, PRELOADED_IMAGES, PreloadLinkCreator, BASE64_IMG_MAX_LENGTH_IN_ERROR, VALID_WIDTH_DESCRIPTOR_SRCSET, VALID_DENSITY_DESCRIPTOR_SRCSET, ABSOLUTE_SRCSET_DENSITY_CAP, RECOMMENDED_SRCSET_DENSITY_CAP, DENSITY_SRCSET_MULTIPLIERS, VIEWPORT_BREAKPOINT_CUTOFF, ASPECT_RATIO_TOLERANCE, OVERSIZED_IMAGE_TOLERANCE2, FIXED_SRCSET_WIDTH_LIMIT, FIXED_SRCSET_HEIGHT_LIMIT, PLACEHOLDER_DIMENSION_LIMIT, DATA_URL_WARN_LIMIT, DATA_URL_ERROR_LIMIT, BUILT_IN_LOADERS, PRIORITY_COUNT_THRESHOLD, IMGS_WITH_PRIORITY_ATTR_COUNT, NgOptimizedImage;
var init_common = __esm({
  "node_modules/@angular/common/fesm2022/common.mjs"() {
    "use strict";
    init_common_module();
    init_core();
    init_core();
    init_core();
    init_xhr();
    init_location();
    PLATFORM_BROWSER_ID = "browser";
    VERSION2 = new Version("20.1.7");
    ViewportScroller = class _ViewportScroller {
      // De-sugared tree-shakable injection
      // See #23917
      /** @nocollapse */
      static \u0275prov = (
        /** @pureOrBreakMyCode */
        /* @__PURE__ */ \u0275\u0275defineInjectable({
          token: _ViewportScroller,
          providedIn: "root",
          factory: () => false ? new NullViewportScroller() : new BrowserViewportScroller(inject2(DOCUMENT), window)
        })
      );
    };
    BrowserViewportScroller = class {
      document;
      window;
      offset = () => [0, 0];
      constructor(document2, window2) {
        this.document = document2;
        this.window = window2;
      }
      /**
       * Configures the top offset used when scrolling to an anchor.
       * @param offset A position in screen coordinates (a tuple with x and y values)
       * or a function that returns the top offset position.
       *
       */
      setOffset(offset) {
        if (Array.isArray(offset)) {
          this.offset = () => offset;
        } else {
          this.offset = offset;
        }
      }
      /**
       * Retrieves the current scroll position.
       * @returns The position in screen coordinates.
       */
      getScrollPosition() {
        return [this.window.scrollX, this.window.scrollY];
      }
      /**
       * Sets the scroll position.
       * @param position The new position in screen coordinates.
       */
      scrollToPosition(position, options) {
        this.window.scrollTo(__spreadProps(__spreadValues({}, options), {
          left: position[0],
          top: position[1]
        }));
      }
      /**
       * Scrolls to an element and attempts to focus the element.
       *
       * Note that the function name here is misleading in that the target string may be an ID for a
       * non-anchor element.
       *
       * @param target The ID of an element or name of the anchor.
       *
       * @see https://html.spec.whatwg.org/#the-indicated-part-of-the-document
       * @see https://html.spec.whatwg.org/#scroll-to-fragid
       */
      scrollToAnchor(target, options) {
        const elSelected = findAnchorFromDocument(this.document, target);
        if (elSelected) {
          this.scrollToElement(elSelected, options);
          elSelected.focus();
        }
      }
      /**
       * Disables automatic scroll restoration provided by the browser.
       */
      setHistoryScrollRestoration(scrollRestoration) {
        try {
          this.window.history.scrollRestoration = scrollRestoration;
        } catch {
          console.warn(formatRuntimeError(2400, ngDevMode && "Failed to set `window.history.scrollRestoration`. This may occur when:\n\u2022 The script is running inside a sandboxed iframe\n\u2022 The window is partially navigated or inactive\n\u2022 The script is executed in an untrusted or special context (e.g., test runners, browser extensions, or content previews)\nScroll position may not be preserved across navigation."));
        }
      }
      /**
       * Scrolls to an element using the native offset and the specified offset set on this scroller.
       *
       * The offset can be used when we know that there is a floating header and scrolling naively to an
       * element (ex: `scrollIntoView`) leaves the element hidden behind the floating header.
       */
      scrollToElement(el, options) {
        const rect = el.getBoundingClientRect();
        const left = rect.left + this.window.pageXOffset;
        const top2 = rect.top + this.window.pageYOffset;
        const offset = this.offset();
        this.window.scrollTo(__spreadProps(__spreadValues({}, options), {
          left: left - offset[0],
          top: top2 - offset[1]
        }));
      }
    };
    PLACEHOLDER_QUALITY = "20";
    noopImageLoader = (config3) => config3.src;
    IMAGE_LOADER = new InjectionToken(ngDevMode ? "ImageLoader" : "", {
      providedIn: "root",
      factory: () => noopImageLoader
    });
    provideCloudflareLoader = createImageLoader(createCloudflareUrl, ngDevMode ? ["https://<ZONE>/cdn-cgi/image/<OPTIONS>/<SOURCE-IMAGE>"] : void 0);
    cloudinaryLoaderInfo = {
      name: "Cloudinary",
      testUrl: isCloudinaryUrl
    };
    CLOUDINARY_LOADER_REGEX = /https?\:\/\/[^\/]+\.cloudinary\.com\/.+/;
    provideCloudinaryLoader = createImageLoader(createCloudinaryUrl, ngDevMode ? ["https://res.cloudinary.com/mysite", "https://mysite.cloudinary.com", "https://subdomain.mysite.com"] : void 0);
    imageKitLoaderInfo = {
      name: "ImageKit",
      testUrl: isImageKitUrl
    };
    IMAGE_KIT_LOADER_REGEX = /https?\:\/\/[^\/]+\.imagekit\.io\/.+/;
    provideImageKitLoader = createImageLoader(createImagekitUrl, ngDevMode ? ["https://ik.imagekit.io/mysite", "https://subdomain.mysite.com"] : void 0);
    imgixLoaderInfo = {
      name: "Imgix",
      testUrl: isImgixUrl
    };
    IMGIX_LOADER_REGEX = /https?\:\/\/[^\/]+\.imgix\.net\/.+/;
    provideImgixLoader = createImageLoader(createImgixUrl, ngDevMode ? ["https://somepath.imgix.net/"] : void 0);
    netlifyLoaderInfo = {
      name: "Netlify",
      testUrl: isNetlifyUrl
    };
    NETLIFY_LOADER_REGEX = /https?\:\/\/[^\/]+\.netlify\.app\/.+/;
    LCPImageObserver = class _LCPImageObserver {
      // Map of full image URLs -> original `ngSrc` values.
      images = /* @__PURE__ */ new Map();
      window = inject2(DOCUMENT).defaultView;
      observer = null;
      constructor() {
        assertDevMode("LCP checker");
        if (typeof PerformanceObserver !== "undefined") {
          this.observer = this.initPerformanceObserver();
        }
      }
      /**
       * Inits PerformanceObserver and subscribes to LCP events.
       * Based on https://web.dev/lcp/#measure-lcp-in-javascript
       */
      initPerformanceObserver() {
        const observer = new PerformanceObserver((entryList) => {
          const entries = entryList.getEntries();
          if (entries.length === 0) return;
          const lcpElement = entries[entries.length - 1];
          const imgSrc = lcpElement.element?.src ?? "";
          if (imgSrc.startsWith("data:") || imgSrc.startsWith("blob:")) return;
          const img = this.images.get(imgSrc);
          if (!img) return;
          if (!img.priority && !img.alreadyWarnedPriority) {
            img.alreadyWarnedPriority = true;
            logMissingPriorityError(imgSrc);
          }
          if (img.modified && !img.alreadyWarnedModified) {
            img.alreadyWarnedModified = true;
            logModifiedWarning(imgSrc);
          }
        });
        observer.observe({
          type: "largest-contentful-paint",
          buffered: true
        });
        return observer;
      }
      registerImage(rewrittenSrc, originalNgSrc, isPriority) {
        if (!this.observer) return;
        const newObservedImageState = {
          priority: isPriority,
          modified: false,
          alreadyWarnedModified: false,
          alreadyWarnedPriority: false
        };
        this.images.set(getUrl(rewrittenSrc, this.window).href, newObservedImageState);
      }
      unregisterImage(rewrittenSrc) {
        if (!this.observer) return;
        this.images.delete(getUrl(rewrittenSrc, this.window).href);
      }
      updateImage(originalSrc, newSrc) {
        if (!this.observer) return;
        const originalUrl = getUrl(originalSrc, this.window).href;
        const img = this.images.get(originalUrl);
        if (img) {
          img.modified = true;
          this.images.set(getUrl(newSrc, this.window).href, img);
          this.images.delete(originalUrl);
        }
      }
      ngOnDestroy() {
        if (!this.observer) return;
        this.observer.disconnect();
        this.images.clear();
      }
      static \u0275fac = function LCPImageObserver_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _LCPImageObserver)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _LCPImageObserver,
        factory: _LCPImageObserver.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LCPImageObserver, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [], null);
    })();
    INTERNAL_PRECONNECT_CHECK_BLOCKLIST = /* @__PURE__ */ new Set(["localhost", "127.0.0.1", "0.0.0.0"]);
    PRECONNECT_CHECK_BLOCKLIST = new InjectionToken(ngDevMode ? "PRECONNECT_CHECK_BLOCKLIST" : "");
    PreconnectLinkChecker = class _PreconnectLinkChecker {
      document = inject2(DOCUMENT);
      /**
       * Set of <link rel="preconnect"> tags found on this page.
       * The `null` value indicates that there was no DOM query operation performed.
       */
      preconnectLinks = null;
      /*
       * Keep track of all already seen origin URLs to avoid repeating the same check.
       */
      alreadySeen = /* @__PURE__ */ new Set();
      window = this.document.defaultView;
      blocklist = new Set(INTERNAL_PRECONNECT_CHECK_BLOCKLIST);
      constructor() {
        assertDevMode("preconnect link checker");
        const blocklist = inject2(PRECONNECT_CHECK_BLOCKLIST, {
          optional: true
        });
        if (blocklist) {
          this.populateBlocklist(blocklist);
        }
      }
      populateBlocklist(origins) {
        if (Array.isArray(origins)) {
          deepForEach2(origins, (origin) => {
            this.blocklist.add(extractHostname(origin));
          });
        } else {
          this.blocklist.add(extractHostname(origins));
        }
      }
      /**
       * Checks that a preconnect resource hint exists in the head for the
       * given src.
       *
       * @param rewrittenSrc src formatted with loader
       * @param originalNgSrc ngSrc value
       */
      assertPreconnect(rewrittenSrc, originalNgSrc) {
        if (false) return;
        const imgUrl = getUrl(rewrittenSrc, this.window);
        if (this.blocklist.has(imgUrl.hostname) || this.alreadySeen.has(imgUrl.origin)) return;
        this.alreadySeen.add(imgUrl.origin);
        this.preconnectLinks ??= this.queryPreconnectLinks();
        if (!this.preconnectLinks.has(imgUrl.origin)) {
          console.warn(formatRuntimeError(2956, `${imgDirectiveDetails(originalNgSrc)} there is no preconnect tag present for this image. Preconnecting to the origin(s) that serve priority images ensures that these images are delivered as soon as possible. To fix this, please add the following element into the <head> of the document:
  <link rel="preconnect" href="${imgUrl.origin}">`));
        }
      }
      queryPreconnectLinks() {
        const preconnectUrls = /* @__PURE__ */ new Set();
        const links = this.document.querySelectorAll("link[rel=preconnect]");
        for (const link of links) {
          const url = getUrl(link.href, this.window);
          preconnectUrls.add(url.origin);
        }
        return preconnectUrls;
      }
      ngOnDestroy() {
        this.preconnectLinks?.clear();
        this.alreadySeen.clear();
      }
      static \u0275fac = function PreconnectLinkChecker_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _PreconnectLinkChecker)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _PreconnectLinkChecker,
        factory: _PreconnectLinkChecker.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreconnectLinkChecker, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [], null);
    })();
    DEFAULT_PRELOADED_IMAGES_LIMIT = 5;
    PRELOADED_IMAGES = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "NG_OPTIMIZED_PRELOADED_IMAGES" : "", {
      providedIn: "root",
      factory: () => /* @__PURE__ */ new Set()
    });
    PreloadLinkCreator = class _PreloadLinkCreator {
      preloadedImages = inject2(PRELOADED_IMAGES);
      document = inject2(DOCUMENT);
      errorShown = false;
      /**
       * @description Add a preload `<link>` to the `<head>` of the `index.html` that is served from the
       * server while using Angular Universal and SSR to kick off image loads for high priority images.
       *
       * The `sizes` (passed in from the user) and `srcset` (parsed and formatted from `ngSrcset`)
       * properties used to set the corresponding attributes, `imagesizes` and `imagesrcset`
       * respectively, on the preload `<link>` tag so that the correctly sized image is preloaded from
       * the CDN.
       *
       * {@link https://web.dev/preload-responsive-images/#imagesrcset-and-imagesizes}
       *
       * @param renderer The `Renderer2` passed in from the directive
       * @param src The original src of the image that is set on the `ngSrc` input.
       * @param srcset The parsed and formatted srcset created from the `ngSrcset` input
       * @param sizes The value of the `sizes` attribute passed in to the `<img>` tag
       */
      createPreloadLinkTag(renderer, src, srcset, sizes) {
        if (ngDevMode && !this.errorShown && this.preloadedImages.size >= DEFAULT_PRELOADED_IMAGES_LIMIT) {
          this.errorShown = true;
          console.warn(formatRuntimeError(2961, `The \`NgOptimizedImage\` directive has detected that more than ${DEFAULT_PRELOADED_IMAGES_LIMIT} images were marked as priority. This might negatively affect an overall performance of the page. To fix this, remove the "priority" attribute from images with less priority.`));
        }
        if (this.preloadedImages.has(src)) {
          return;
        }
        this.preloadedImages.add(src);
        const preload = renderer.createElement("link");
        renderer.setAttribute(preload, "as", "image");
        renderer.setAttribute(preload, "href", src);
        renderer.setAttribute(preload, "rel", "preload");
        renderer.setAttribute(preload, "fetchpriority", "high");
        if (sizes) {
          renderer.setAttribute(preload, "imageSizes", sizes);
        }
        if (srcset) {
          renderer.setAttribute(preload, "imageSrcset", srcset);
        }
        renderer.appendChild(this.document.head, preload);
      }
      static \u0275fac = function PreloadLinkCreator_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _PreloadLinkCreator)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _PreloadLinkCreator,
        factory: _PreloadLinkCreator.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreloadLinkCreator, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    BASE64_IMG_MAX_LENGTH_IN_ERROR = 50;
    VALID_WIDTH_DESCRIPTOR_SRCSET = /^((\s*\d+w\s*(,|$)){1,})$/;
    VALID_DENSITY_DESCRIPTOR_SRCSET = /^((\s*\d+(\.\d+)?x\s*(,|$)){1,})$/;
    ABSOLUTE_SRCSET_DENSITY_CAP = 3;
    RECOMMENDED_SRCSET_DENSITY_CAP = 2;
    DENSITY_SRCSET_MULTIPLIERS = [1, 2];
    VIEWPORT_BREAKPOINT_CUTOFF = 640;
    ASPECT_RATIO_TOLERANCE = 0.1;
    OVERSIZED_IMAGE_TOLERANCE2 = 1e3;
    FIXED_SRCSET_WIDTH_LIMIT = 1920;
    FIXED_SRCSET_HEIGHT_LIMIT = 1080;
    PLACEHOLDER_DIMENSION_LIMIT = 1e3;
    DATA_URL_WARN_LIMIT = 4e3;
    DATA_URL_ERROR_LIMIT = 1e4;
    BUILT_IN_LOADERS = [imgixLoaderInfo, imageKitLoaderInfo, cloudinaryLoaderInfo, netlifyLoaderInfo];
    PRIORITY_COUNT_THRESHOLD = 10;
    IMGS_WITH_PRIORITY_ATTR_COUNT = 0;
    NgOptimizedImage = class _NgOptimizedImage {
      imageLoader = inject2(IMAGE_LOADER);
      config = processConfig(inject2(IMAGE_CONFIG));
      renderer = inject2(Renderer2);
      imgElement = inject2(ElementRef).nativeElement;
      injector = inject2(Injector);
      // An LCP image observer should be injected only in development mode.
      // Do not assign it to `null` to avoid having a redundant property in the production bundle.
      lcpObserver;
      /**
       * Calculate the rewritten `src` once and store it.
       * This is needed to avoid repetitive calculations and make sure the directive cleanup in the
       * `ngOnDestroy` does not rely on the `IMAGE_LOADER` logic (which in turn can rely on some other
       * instance that might be already destroyed).
       */
      _renderedSrc = null;
      /**
       * Name of the source image.
       * Image name will be processed by the image loader and the final URL will be applied as the `src`
       * property of the image.
       */
      ngSrc;
      /**
       * A comma separated list of width or density descriptors.
       * The image name will be taken from `ngSrc` and combined with the list of width or density
       * descriptors to generate the final `srcset` property of the image.
       *
       * Example:
       * ```html
       * <img ngSrc="hello.jpg" ngSrcset="100w, 200w" />  =>
       * <img src="path/hello.jpg" srcset="path/hello.jpg?w=100 100w, path/hello.jpg?w=200 200w" />
       * ```
       */
      ngSrcset;
      /**
       * The base `sizes` attribute passed through to the `<img>` element.
       * Providing sizes causes the image to create an automatic responsive srcset.
       */
      sizes;
      /**
       * For responsive images: the intrinsic width of the image in pixels.
       * For fixed size images: the desired rendered width of the image in pixels.
       */
      width;
      /**
       * For responsive images: the intrinsic height of the image in pixels.
       * For fixed size images: the desired rendered height of the image in pixels.
       */
      height;
      /**
       * The desired decoding behavior for the image. Defaults to `auto`
       * if not explicitly set, matching native browser behavior.
       *
       * Use `async` to decode the image off the main thread (non-blocking),
       * `sync` for immediate decoding (blocking), or `auto` to let the
       * browser decide the optimal strategy.
       *
       * [Spec](https://html.spec.whatwg.org/multipage/images.html#image-decoding-hint)
       */
      decoding;
      /**
       * The desired loading behavior (lazy, eager, or auto). Defaults to `lazy`,
       * which is recommended for most images.
       *
       * Warning: Setting images as loading="eager" or loading="auto" marks them
       * as non-priority images and can hurt loading performance. For images which
       * may be the LCP element, use the `priority` attribute instead of `loading`.
       */
      loading;
      /**
       * Indicates whether this image should have a high priority.
       */
      priority = false;
      /**
       * Data to pass through to custom loaders.
       */
      loaderParams;
      /**
       * Disables automatic srcset generation for this image.
       */
      disableOptimizedSrcset = false;
      /**
       * Sets the image to "fill mode", which eliminates the height/width requirement and adds
       * styles such that the image fills its containing element.
       */
      fill = false;
      /**
       * A URL or data URL for an image to be used as a placeholder while this image loads.
       */
      placeholder;
      /**
       * Configuration object for placeholder settings. Options:
       *   * blur: Setting this to false disables the automatic CSS blur.
       */
      placeholderConfig;
      /**
       * Value of the `src` attribute if set on the host `<img>` element.
       * This input is exclusively read to assert that `src` is not set in conflict
       * with `ngSrc` and that images don't start to load until a lazy loading strategy is set.
       * @internal
       */
      src;
      /**
       * Value of the `srcset` attribute if set on the host `<img>` element.
       * This input is exclusively read to assert that `srcset` is not set in conflict
       * with `ngSrcset` and that images don't start to load until a lazy loading strategy is set.
       * @internal
       */
      srcset;
      constructor() {
        if (ngDevMode) {
          this.lcpObserver = this.injector.get(LCPImageObserver);
          const destroyRef = inject2(DestroyRef);
          destroyRef.onDestroy(() => {
            if (!this.priority && this._renderedSrc !== null) {
              this.lcpObserver.unregisterImage(this._renderedSrc);
            }
          });
        }
      }
      /** @docs-private */
      ngOnInit() {
        performanceMarkFeature("NgOptimizedImage");
        if (ngDevMode) {
          const ngZone = this.injector.get(NgZone);
          assertNonEmptyInput(this, "ngSrc", this.ngSrc);
          assertValidNgSrcset(this, this.ngSrcset);
          assertNoConflictingSrc(this);
          if (this.ngSrcset) {
            assertNoConflictingSrcset(this);
          }
          assertNotBase64Image(this);
          assertNotBlobUrl(this);
          if (this.fill) {
            assertEmptyWidthAndHeight(this);
            ngZone.runOutsideAngular(() => assertNonZeroRenderedHeight(this, this.imgElement, this.renderer));
          } else {
            assertNonEmptyWidthAndHeight(this);
            if (this.height !== void 0) {
              assertGreaterThanZero(this, this.height, "height");
            }
            if (this.width !== void 0) {
              assertGreaterThanZero(this, this.width, "width");
            }
            ngZone.runOutsideAngular(() => assertNoImageDistortion(this, this.imgElement, this.renderer));
          }
          assertValidLoadingInput(this);
          assertValidDecodingInput(this);
          if (!this.ngSrcset) {
            assertNoComplexSizes(this);
          }
          assertValidPlaceholder(this, this.imageLoader);
          assertNotMissingBuiltInLoader(this.ngSrc, this.imageLoader);
          assertNoNgSrcsetWithoutLoader(this, this.imageLoader);
          assertNoLoaderParamsWithoutLoader(this, this.imageLoader);
          ngZone.runOutsideAngular(() => {
            this.lcpObserver.registerImage(this.getRewrittenSrc(), this.ngSrc, this.priority);
          });
          if (this.priority) {
            const checker = this.injector.get(PreconnectLinkChecker);
            checker.assertPreconnect(this.getRewrittenSrc(), this.ngSrc);
            if (true) {
              const applicationRef = this.injector.get(ApplicationRef);
              assetPriorityCountBelowThreshold(applicationRef);
            }
          }
        }
        if (this.placeholder) {
          this.removePlaceholderOnLoad(this.imgElement);
        }
        this.setHostAttributes();
      }
      setHostAttributes() {
        if (this.fill) {
          this.sizes ||= "100vw";
        } else {
          this.setHostAttribute("width", this.width.toString());
          this.setHostAttribute("height", this.height.toString());
        }
        this.setHostAttribute("loading", this.getLoadingBehavior());
        this.setHostAttribute("fetchpriority", this.getFetchPriority());
        this.setHostAttribute("decoding", this.getDecoding());
        this.setHostAttribute("ng-img", "true");
        const rewrittenSrcset = this.updateSrcAndSrcset();
        if (this.sizes) {
          if (this.getLoadingBehavior() === "lazy") {
            this.setHostAttribute("sizes", "auto, " + this.sizes);
          } else {
            this.setHostAttribute("sizes", this.sizes);
          }
        } else {
          if (this.ngSrcset && VALID_WIDTH_DESCRIPTOR_SRCSET.test(this.ngSrcset) && this.getLoadingBehavior() === "lazy") {
            this.setHostAttribute("sizes", "auto, 100vw");
          }
        }
        if (false) {
          const preloadLinkCreator = this.injector.get(PreloadLinkCreator);
          preloadLinkCreator.createPreloadLinkTag(this.renderer, this.getRewrittenSrc(), rewrittenSrcset, this.sizes);
        }
      }
      /** @docs-private */
      ngOnChanges(changes) {
        if (ngDevMode) {
          assertNoPostInitInputChange(this, changes, ["ngSrcset", "width", "height", "priority", "fill", "loading", "sizes", "loaderParams", "disableOptimizedSrcset"]);
        }
        if (changes["ngSrc"] && !changes["ngSrc"].isFirstChange()) {
          const oldSrc = this._renderedSrc;
          this.updateSrcAndSrcset(true);
          if (ngDevMode) {
            const newSrc = this._renderedSrc;
            if (oldSrc && newSrc && oldSrc !== newSrc) {
              const ngZone = this.injector.get(NgZone);
              ngZone.runOutsideAngular(() => {
                this.lcpObserver.updateImage(oldSrc, newSrc);
              });
            }
          }
        }
        if (ngDevMode && changes["placeholder"]?.currentValue && true && true) {
          assertPlaceholderDimensions(this, this.imgElement);
        }
      }
      callImageLoader(configWithoutCustomParams) {
        let augmentedConfig = configWithoutCustomParams;
        if (this.loaderParams) {
          augmentedConfig.loaderParams = this.loaderParams;
        }
        return this.imageLoader(augmentedConfig);
      }
      getLoadingBehavior() {
        if (!this.priority && this.loading !== void 0) {
          return this.loading;
        }
        return this.priority ? "eager" : "lazy";
      }
      getFetchPriority() {
        return this.priority ? "high" : "auto";
      }
      getDecoding() {
        if (this.priority) {
          return "sync";
        }
        return this.decoding ?? "auto";
      }
      getRewrittenSrc() {
        if (!this._renderedSrc) {
          const imgConfig = {
            src: this.ngSrc
          };
          this._renderedSrc = this.callImageLoader(imgConfig);
        }
        return this._renderedSrc;
      }
      getRewrittenSrcset() {
        const widthSrcSet = VALID_WIDTH_DESCRIPTOR_SRCSET.test(this.ngSrcset);
        const finalSrcs = this.ngSrcset.split(",").filter((src) => src !== "").map((srcStr) => {
          srcStr = srcStr.trim();
          const width = widthSrcSet ? parseFloat(srcStr) : parseFloat(srcStr) * this.width;
          return `${this.callImageLoader({
            src: this.ngSrc,
            width
          })} ${srcStr}`;
        });
        return finalSrcs.join(", ");
      }
      getAutomaticSrcset() {
        if (this.sizes) {
          return this.getResponsiveSrcset();
        } else {
          return this.getFixedSrcset();
        }
      }
      getResponsiveSrcset() {
        const {
          breakpoints
        } = this.config;
        let filteredBreakpoints = breakpoints;
        if (this.sizes?.trim() === "100vw") {
          filteredBreakpoints = breakpoints.filter((bp) => bp >= VIEWPORT_BREAKPOINT_CUTOFF);
        }
        const finalSrcs = filteredBreakpoints.map((bp) => `${this.callImageLoader({
          src: this.ngSrc,
          width: bp
        })} ${bp}w`);
        return finalSrcs.join(", ");
      }
      updateSrcAndSrcset(forceSrcRecalc = false) {
        if (forceSrcRecalc) {
          this._renderedSrc = null;
        }
        const rewrittenSrc = this.getRewrittenSrc();
        this.setHostAttribute("src", rewrittenSrc);
        let rewrittenSrcset = void 0;
        if (this.ngSrcset) {
          rewrittenSrcset = this.getRewrittenSrcset();
        } else if (this.shouldGenerateAutomaticSrcset()) {
          rewrittenSrcset = this.getAutomaticSrcset();
        }
        if (rewrittenSrcset) {
          this.setHostAttribute("srcset", rewrittenSrcset);
        }
        return rewrittenSrcset;
      }
      getFixedSrcset() {
        const finalSrcs = DENSITY_SRCSET_MULTIPLIERS.map((multiplier) => `${this.callImageLoader({
          src: this.ngSrc,
          width: this.width * multiplier
        })} ${multiplier}x`);
        return finalSrcs.join(", ");
      }
      shouldGenerateAutomaticSrcset() {
        let oversizedImage = false;
        if (!this.sizes) {
          oversizedImage = this.width > FIXED_SRCSET_WIDTH_LIMIT || this.height > FIXED_SRCSET_HEIGHT_LIMIT;
        }
        return !this.disableOptimizedSrcset && !this.srcset && this.imageLoader !== noopImageLoader && !oversizedImage;
      }
      /**
       * Returns an image url formatted for use with the CSS background-image property. Expects one of:
       * * A base64 encoded image, which is wrapped and passed through.
       * * A boolean. If true, calls the image loader to generate a small placeholder url.
       */
      generatePlaceholder(placeholderInput) {
        const {
          placeholderResolution
        } = this.config;
        if (placeholderInput === true) {
          return `url(${this.callImageLoader({
            src: this.ngSrc,
            width: placeholderResolution,
            isPlaceholder: true
          })})`;
        } else if (typeof placeholderInput === "string") {
          return `url(${placeholderInput})`;
        }
        return null;
      }
      /**
       * Determines if blur should be applied, based on an optional boolean
       * property `blur` within the optional configuration object `placeholderConfig`.
       */
      shouldBlurPlaceholder(placeholderConfig) {
        if (!placeholderConfig || !placeholderConfig.hasOwnProperty("blur")) {
          return true;
        }
        return Boolean(placeholderConfig.blur);
      }
      removePlaceholderOnLoad(img) {
        const callback = () => {
          const changeDetectorRef = this.injector.get(ChangeDetectorRef);
          removeLoadListenerFn();
          removeErrorListenerFn();
          this.placeholder = false;
          changeDetectorRef.markForCheck();
        };
        const removeLoadListenerFn = this.renderer.listen(img, "load", callback);
        const removeErrorListenerFn = this.renderer.listen(img, "error", callback);
        callOnLoadIfImageIsLoaded(img, callback);
      }
      setHostAttribute(name2, value) {
        this.renderer.setAttribute(this.imgElement, name2, value);
      }
      static \u0275fac = function NgOptimizedImage_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgOptimizedImage)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgOptimizedImage,
        selectors: [["img", "ngSrc", ""]],
        hostVars: 18,
        hostBindings: function NgOptimizedImage_HostBindings(rf, ctx) {
          if (rf & 2) {
            \u0275\u0275styleProp("position", ctx.fill ? "absolute" : null)("width", ctx.fill ? "100%" : null)("height", ctx.fill ? "100%" : null)("inset", ctx.fill ? "0" : null)("background-size", ctx.placeholder ? "cover" : null)("background-position", ctx.placeholder ? "50% 50%" : null)("background-repeat", ctx.placeholder ? "no-repeat" : null)("background-image", ctx.placeholder ? ctx.generatePlaceholder(ctx.placeholder) : null)("filter", ctx.placeholder && ctx.shouldBlurPlaceholder(ctx.placeholderConfig) ? "blur(15px)" : null);
          }
        },
        inputs: {
          ngSrc: [2, "ngSrc", "ngSrc", unwrapSafeUrl],
          ngSrcset: "ngSrcset",
          sizes: "sizes",
          width: [2, "width", "width", numberAttribute],
          height: [2, "height", "height", numberAttribute],
          decoding: "decoding",
          loading: "loading",
          priority: [2, "priority", "priority", booleanAttribute],
          loaderParams: "loaderParams",
          disableOptimizedSrcset: [2, "disableOptimizedSrcset", "disableOptimizedSrcset", booleanAttribute],
          fill: [2, "fill", "fill", booleanAttribute],
          placeholder: [2, "placeholder", "placeholder", booleanOrUrlAttribute],
          placeholderConfig: "placeholderConfig",
          src: "src",
          srcset: "srcset"
        },
        features: [\u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgOptimizedImage, [{
        type: Directive,
        args: [{
          selector: "img[ngSrc]",
          host: {
            "[style.position]": 'fill ? "absolute" : null',
            "[style.width]": 'fill ? "100%" : null',
            "[style.height]": 'fill ? "100%" : null',
            "[style.inset]": 'fill ? "0" : null',
            "[style.background-size]": 'placeholder ? "cover" : null',
            "[style.background-position]": 'placeholder ? "50% 50%" : null',
            "[style.background-repeat]": 'placeholder ? "no-repeat" : null',
            "[style.background-image]": "placeholder ? generatePlaceholder(placeholder) : null",
            "[style.filter]": 'placeholder && shouldBlurPlaceholder(placeholderConfig) ? "blur(15px)" : null'
          }
        }]
      }], () => [], {
        ngSrc: [{
          type: Input,
          args: [{
            required: true,
            transform: unwrapSafeUrl
          }]
        }],
        ngSrcset: [{
          type: Input
        }],
        sizes: [{
          type: Input
        }],
        width: [{
          type: Input,
          args: [{
            transform: numberAttribute
          }]
        }],
        height: [{
          type: Input,
          args: [{
            transform: numberAttribute
          }]
        }],
        decoding: [{
          type: Input
        }],
        loading: [{
          type: Input
        }],
        priority: [{
          type: Input,
          args: [{
            transform: booleanAttribute
          }]
        }],
        loaderParams: [{
          type: Input
        }],
        disableOptimizedSrcset: [{
          type: Input,
          args: [{
            transform: booleanAttribute
          }]
        }],
        fill: [{
          type: Input,
          args: [{
            transform: booleanAttribute
          }]
        }],
        placeholder: [{
          type: Input,
          args: [{
            transform: booleanOrUrlAttribute
          }]
        }],
        placeholderConfig: [{
          type: Input
        }],
        src: [{
          type: Input
        }],
        srcset: [{
          type: Input
        }]
      });
    })();
  }
});

// node_modules/@angular/platform-browser/fesm2022/dom_renderer.mjs
function removeElements(elements) {
  for (const element of elements) {
    element.remove();
  }
}
function createStyleElement(style, doc2) {
  const styleElement = doc2.createElement("style");
  styleElement.textContent = style;
  return styleElement;
}
function addServerStyles(doc2, appId, inline, external) {
  const elements = doc2.head?.querySelectorAll(`style[${APP_ID_ATTRIBUTE_NAME}="${appId}"],link[${APP_ID_ATTRIBUTE_NAME}="${appId}"]`);
  if (elements) {
    for (const styleElement of elements) {
      styleElement.removeAttribute(APP_ID_ATTRIBUTE_NAME);
      if (styleElement instanceof HTMLLinkElement) {
        external.set(styleElement.href.slice(styleElement.href.lastIndexOf("/") + 1), {
          usage: 0,
          elements: [styleElement]
        });
      } else if (styleElement.textContent) {
        inline.set(styleElement.textContent, {
          usage: 0,
          elements: [styleElement]
        });
      }
    }
  }
}
function createLinkElement(url, doc2) {
  const linkElement = doc2.createElement("link");
  linkElement.setAttribute("rel", "stylesheet");
  linkElement.setAttribute("href", url);
  return linkElement;
}
function shimContentAttribute(componentShortId) {
  return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function shimHostAttribute(componentShortId) {
  return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function shimStylesContent(compId, styles) {
  return styles.map((s) => s.replace(COMPONENT_REGEX, compId));
}
function addBaseHrefToCssSourceMap(baseHref, styles) {
  if (!baseHref) {
    return styles;
  }
  const absoluteBaseHrefUrl = new URL(baseHref, "http://localhost");
  return styles.map((cssContent) => {
    if (!cssContent.includes("sourceMappingURL=")) {
      return cssContent;
    }
    return cssContent.replace(SOURCEMAP_URL_REGEXP, (_, sourceMapUrl) => {
      if (sourceMapUrl[0] === "/" || sourceMapUrl.startsWith("data:") || PROTOCOL_REGEXP.test(sourceMapUrl)) {
        return `/*# sourceMappingURL=${sourceMapUrl} */`;
      }
      const {
        pathname: resolvedSourceMapUrl
      } = new URL(sourceMapUrl, absoluteBaseHrefUrl);
      return `/*# sourceMappingURL=${resolvedSourceMapUrl} */`;
    });
  });
}
function checkNoSyntheticProp(name2, nameKind) {
  if (name2.charCodeAt(0) === AT_CHARCODE) {
    throw new RuntimeError(5105, `Unexpected synthetic ${nameKind} ${name2} found. Please make sure that:
  - Make sure \`provideAnimationsAsync()\`, \`provideAnimations()\` or \`provideNoopAnimations()\` call was added to a list of providers used to bootstrap an application.
  - There is a corresponding animation configuration named \`${name2}\` defined in the \`animations\` field of the \`@Component\` decorator (see https://angular.dev/api/core/Component#animations).`);
  }
}
function isTemplateNode(node) {
  return node.tagName === "TEMPLATE" && node.content !== void 0;
}
var EVENT_MANAGER_PLUGINS, EventManager, EventManagerPlugin, APP_ID_ATTRIBUTE_NAME, SharedStylesHost, NAMESPACE_URIS, COMPONENT_REGEX, SOURCEMAP_URL_REGEXP, PROTOCOL_REGEXP, COMPONENT_VARIABLE, HOST_ATTR, CONTENT_ATTR, REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT, REMOVE_STYLES_ON_COMPONENT_DESTROY, DomRendererFactory2, DefaultDomRenderer2, AT_CHARCODE, ShadowDomRenderer, NoneEncapsulationDomRenderer, EmulatedEncapsulationDomRenderer2;
var init_dom_renderer = __esm({
  "node_modules/@angular/platform-browser/fesm2022/dom_renderer.mjs"() {
    "use strict";
    init_common();
    init_core();
    init_core();
    EVENT_MANAGER_PLUGINS = new InjectionToken(ngDevMode ? "EventManagerPlugins" : "");
    EventManager = class _EventManager {
      _zone;
      _plugins;
      _eventNameToPlugin = /* @__PURE__ */ new Map();
      /**
       * Initializes an instance of the event-manager service.
       */
      constructor(plugins, _zone) {
        this._zone = _zone;
        plugins.forEach((plugin) => {
          plugin.manager = this;
        });
        this._plugins = plugins.slice().reverse();
      }
      /**
       * Registers a handler for a specific element and event.
       *
       * @param element The HTML element to receive event notifications.
       * @param eventName The name of the event to listen for.
       * @param handler A function to call when the notification occurs. Receives the
       * event object as an argument.
       * @param options Options that configure how the event listener is bound.
       * @returns  A callback function that can be used to remove the handler.
       */
      addEventListener(element, eventName, handler, options) {
        const plugin = this._findPluginFor(eventName);
        return plugin.addEventListener(element, eventName, handler, options);
      }
      /**
       * Retrieves the compilation zone in which event listeners are registered.
       */
      getZone() {
        return this._zone;
      }
      /** @internal */
      _findPluginFor(eventName) {
        let plugin = this._eventNameToPlugin.get(eventName);
        if (plugin) {
          return plugin;
        }
        const plugins = this._plugins;
        plugin = plugins.find((plugin2) => plugin2.supports(eventName));
        if (!plugin) {
          throw new RuntimeError(5101, (typeof ngDevMode === "undefined" || ngDevMode) && `No event manager plugin found for event ${eventName}`);
        }
        this._eventNameToPlugin.set(eventName, plugin);
        return plugin;
      }
      static \u0275fac = function EventManager_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _EventManager)(\u0275\u0275inject(EVENT_MANAGER_PLUGINS), \u0275\u0275inject(NgZone));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _EventManager,
        factory: _EventManager.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EventManager, [{
        type: Injectable
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [EVENT_MANAGER_PLUGINS]
        }]
      }, {
        type: NgZone
      }], null);
    })();
    EventManagerPlugin = class {
      _doc;
      // TODO: remove (has some usage in G3)
      constructor(_doc) {
        this._doc = _doc;
      }
      // Using non-null assertion because it's set by EventManager's constructor
      manager;
    };
    APP_ID_ATTRIBUTE_NAME = "ng-app-id";
    SharedStylesHost = class _SharedStylesHost {
      doc;
      appId;
      nonce;
      /**
       * Provides usage information for active inline style content and associated HTML <style> elements.
       * Embedded styles typically originate from the `styles` metadata of a rendered component.
       */
      inline = /* @__PURE__ */ new Map();
      /**
       * Provides usage information for active external style URLs and the associated HTML <link> elements.
       * External styles typically originate from the `ExternalStylesFeature` of a rendered component.
       */
      external = /* @__PURE__ */ new Map();
      /**
       * Set of host DOM nodes that will have styles attached.
       */
      hosts = /* @__PURE__ */ new Set();
      constructor(doc2, appId, nonce, platformId = {}) {
        this.doc = doc2;
        this.appId = appId;
        this.nonce = nonce;
        addServerStyles(doc2, appId, this.inline, this.external);
        this.hosts.add(doc2.head);
      }
      /**
       * Adds embedded styles to the DOM via HTML `style` elements.
       * @param styles An array of style content strings.
       */
      addStyles(styles, urls) {
        for (const value of styles) {
          this.addUsage(value, this.inline, createStyleElement);
        }
        urls?.forEach((value) => this.addUsage(value, this.external, createLinkElement));
      }
      /**
       * Removes embedded styles from the DOM that were added as HTML `style` elements.
       * @param styles An array of style content strings.
       */
      removeStyles(styles, urls) {
        for (const value of styles) {
          this.removeUsage(value, this.inline);
        }
        urls?.forEach((value) => this.removeUsage(value, this.external));
      }
      addUsage(value, usages, creator) {
        const record = usages.get(value);
        if (record) {
          if ((typeof ngDevMode === "undefined" || ngDevMode) && record.usage === 0) {
            record.elements.forEach((element) => element.setAttribute("ng-style-reused", ""));
          }
          record.usage++;
        } else {
          usages.set(value, {
            usage: 1,
            elements: [...this.hosts].map((host) => this.addElement(host, creator(value, this.doc)))
          });
        }
      }
      removeUsage(value, usages) {
        const record = usages.get(value);
        if (record) {
          record.usage--;
          if (record.usage <= 0) {
            removeElements(record.elements);
            usages.delete(value);
          }
        }
      }
      ngOnDestroy() {
        for (const [, {
          elements
        }] of [...this.inline, ...this.external]) {
          removeElements(elements);
        }
        this.hosts.clear();
      }
      /**
       * Adds a host node to the set of style hosts and adds all existing style usage to
       * the newly added host node.
       *
       * This is currently only used for Shadow DOM encapsulation mode.
       */
      addHost(hostNode) {
        this.hosts.add(hostNode);
        for (const [style, {
          elements
        }] of this.inline) {
          elements.push(this.addElement(hostNode, createStyleElement(style, this.doc)));
        }
        for (const [url, {
          elements
        }] of this.external) {
          elements.push(this.addElement(hostNode, createLinkElement(url, this.doc)));
        }
      }
      removeHost(hostNode) {
        this.hosts.delete(hostNode);
      }
      addElement(host, element) {
        if (this.nonce) {
          element.setAttribute("nonce", this.nonce);
        }
        if (false) {
          element.setAttribute(APP_ID_ATTRIBUTE_NAME, this.appId);
        }
        return host.appendChild(element);
      }
      static \u0275fac = function SharedStylesHost_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _SharedStylesHost)(\u0275\u0275inject(DOCUMENT), \u0275\u0275inject(APP_ID), \u0275\u0275inject(CSP_NONCE, 8), \u0275\u0275inject(PLATFORM_ID));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _SharedStylesHost,
        factory: _SharedStylesHost.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SharedStylesHost, [{
        type: Injectable
      }], () => [{
        type: Document,
        decorators: [{
          type: Inject,
          args: [DOCUMENT]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [APP_ID]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [CSP_NONCE]
        }, {
          type: Optional
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [PLATFORM_ID]
        }]
      }], null);
    })();
    NAMESPACE_URIS = {
      "svg": "http://www.w3.org/2000/svg",
      "xhtml": "http://www.w3.org/1999/xhtml",
      "xlink": "http://www.w3.org/1999/xlink",
      "xml": "http://www.w3.org/XML/1998/namespace",
      "xmlns": "http://www.w3.org/2000/xmlns/",
      "math": "http://www.w3.org/1998/Math/MathML"
    };
    COMPONENT_REGEX = /%COMP%/g;
    SOURCEMAP_URL_REGEXP = /\/\*#\s*sourceMappingURL=(.+?)\s*\*\//;
    PROTOCOL_REGEXP = /^https?:/;
    COMPONENT_VARIABLE = "%COMP%";
    HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
    CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
    REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT = true;
    REMOVE_STYLES_ON_COMPONENT_DESTROY = new InjectionToken(ngDevMode ? "RemoveStylesOnCompDestroy" : "", {
      providedIn: "root",
      factory: () => REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT
    });
    DomRendererFactory2 = class _DomRendererFactory2 {
      eventManager;
      sharedStylesHost;
      appId;
      removeStylesOnCompDestroy;
      doc;
      platformId;
      ngZone;
      nonce;
      tracingService;
      rendererByCompId = /* @__PURE__ */ new Map();
      defaultRenderer;
      platformIsServer;
      constructor(eventManager, sharedStylesHost, appId, removeStylesOnCompDestroy, doc2, platformId, ngZone, nonce = null, tracingService = null) {
        this.eventManager = eventManager;
        this.sharedStylesHost = sharedStylesHost;
        this.appId = appId;
        this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;
        this.doc = doc2;
        this.platformId = platformId;
        this.ngZone = ngZone;
        this.nonce = nonce;
        this.tracingService = tracingService;
        this.platformIsServer = false;
        this.defaultRenderer = new DefaultDomRenderer2(eventManager, doc2, ngZone, this.platformIsServer, this.tracingService);
      }
      createRenderer(element, type) {
        if (!element || !type) {
          return this.defaultRenderer;
        }
        if (false) {
          type = __spreadProps(__spreadValues({}, type), {
            encapsulation: ViewEncapsulation.Emulated
          });
        }
        const renderer = this.getOrCreateRenderer(element, type);
        if (renderer instanceof EmulatedEncapsulationDomRenderer2) {
          renderer.applyToHost(element);
        } else if (renderer instanceof NoneEncapsulationDomRenderer) {
          renderer.applyStyles();
        }
        return renderer;
      }
      getOrCreateRenderer(element, type) {
        const rendererByCompId = this.rendererByCompId;
        let renderer = rendererByCompId.get(type.id);
        if (!renderer) {
          const doc2 = this.doc;
          const ngZone = this.ngZone;
          const eventManager = this.eventManager;
          const sharedStylesHost = this.sharedStylesHost;
          const removeStylesOnCompDestroy = this.removeStylesOnCompDestroy;
          const platformIsServer = this.platformIsServer;
          const tracingService = this.tracingService;
          switch (type.encapsulation) {
            case ViewEncapsulation.Emulated:
              renderer = new EmulatedEncapsulationDomRenderer2(eventManager, sharedStylesHost, type, this.appId, removeStylesOnCompDestroy, doc2, ngZone, platformIsServer, tracingService);
              break;
            case ViewEncapsulation.ShadowDom:
              return new ShadowDomRenderer(eventManager, sharedStylesHost, element, type, doc2, ngZone, this.nonce, platformIsServer, tracingService);
            default:
              renderer = new NoneEncapsulationDomRenderer(eventManager, sharedStylesHost, type, removeStylesOnCompDestroy, doc2, ngZone, platformIsServer, tracingService);
              break;
          }
          rendererByCompId.set(type.id, renderer);
        }
        return renderer;
      }
      ngOnDestroy() {
        this.rendererByCompId.clear();
      }
      /**
       * Used during HMR to clear any cached data about a component.
       * @param componentId ID of the component that is being replaced.
       */
      componentReplaced(componentId) {
        this.rendererByCompId.delete(componentId);
      }
      static \u0275fac = function DomRendererFactory2_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DomRendererFactory2)(\u0275\u0275inject(EventManager), \u0275\u0275inject(SharedStylesHost), \u0275\u0275inject(APP_ID), \u0275\u0275inject(REMOVE_STYLES_ON_COMPONENT_DESTROY), \u0275\u0275inject(DOCUMENT), \u0275\u0275inject(PLATFORM_ID), \u0275\u0275inject(NgZone), \u0275\u0275inject(CSP_NONCE), \u0275\u0275inject(TracingService, 8));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _DomRendererFactory2,
        factory: _DomRendererFactory2.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomRendererFactory2, [{
        type: Injectable
      }], () => [{
        type: EventManager
      }, {
        type: SharedStylesHost
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [APP_ID]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [REMOVE_STYLES_ON_COMPONENT_DESTROY]
        }]
      }, {
        type: Document,
        decorators: [{
          type: Inject,
          args: [DOCUMENT]
        }]
      }, {
        type: Object,
        decorators: [{
          type: Inject,
          args: [PLATFORM_ID]
        }]
      }, {
        type: NgZone
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [CSP_NONCE]
        }]
      }, {
        type: TracingService,
        decorators: [{
          type: Inject,
          args: [TracingService]
        }, {
          type: Optional
        }]
      }], null);
    })();
    DefaultDomRenderer2 = class {
      eventManager;
      doc;
      ngZone;
      platformIsServer;
      tracingService;
      data = /* @__PURE__ */ Object.create(null);
      /**
       * By default this renderer throws when encountering synthetic properties
       * This can be disabled for example by the AsyncAnimationRendererFactory
       */
      throwOnSyntheticProps = true;
      constructor(eventManager, doc2, ngZone, platformIsServer, tracingService) {
        this.eventManager = eventManager;
        this.doc = doc2;
        this.ngZone = ngZone;
        this.platformIsServer = platformIsServer;
        this.tracingService = tracingService;
      }
      destroy() {
      }
      destroyNode = null;
      createElement(name2, namespace) {
        if (namespace) {
          return this.doc.createElementNS(NAMESPACE_URIS[namespace] || namespace, name2);
        }
        return this.doc.createElement(name2);
      }
      createComment(value) {
        return this.doc.createComment(value);
      }
      createText(value) {
        return this.doc.createTextNode(value);
      }
      appendChild(parent, newChild) {
        const targetParent = isTemplateNode(parent) ? parent.content : parent;
        targetParent.appendChild(newChild);
      }
      insertBefore(parent, newChild, refChild) {
        if (parent) {
          const targetParent = isTemplateNode(parent) ? parent.content : parent;
          targetParent.insertBefore(newChild, refChild);
        }
      }
      removeChild(_parent, oldChild) {
        oldChild.remove();
      }
      selectRootElement(selectorOrNode, preserveContent) {
        let el = typeof selectorOrNode === "string" ? this.doc.querySelector(selectorOrNode) : selectorOrNode;
        if (!el) {
          throw new RuntimeError(-5104, (typeof ngDevMode === "undefined" || ngDevMode) && `The selector "${selectorOrNode}" did not match any elements`);
        }
        if (!preserveContent) {
          el.textContent = "";
        }
        return el;
      }
      parentNode(node) {
        return node.parentNode;
      }
      nextSibling(node) {
        return node.nextSibling;
      }
      setAttribute(el, name2, value, namespace) {
        if (namespace) {
          name2 = namespace + ":" + name2;
          const namespaceUri = NAMESPACE_URIS[namespace];
          if (namespaceUri) {
            el.setAttributeNS(namespaceUri, name2, value);
          } else {
            el.setAttribute(name2, value);
          }
        } else {
          el.setAttribute(name2, value);
        }
      }
      removeAttribute(el, name2, namespace) {
        if (namespace) {
          const namespaceUri = NAMESPACE_URIS[namespace];
          if (namespaceUri) {
            el.removeAttributeNS(namespaceUri, name2);
          } else {
            el.removeAttribute(`${namespace}:${name2}`);
          }
        } else {
          el.removeAttribute(name2);
        }
      }
      addClass(el, name2) {
        el.classList.add(name2);
      }
      removeClass(el, name2) {
        el.classList.remove(name2);
      }
      setStyle(el, style, value, flags) {
        if (flags & (RendererStyleFlags2.DashCase | RendererStyleFlags2.Important)) {
          el.style.setProperty(style, value, flags & RendererStyleFlags2.Important ? "important" : "");
        } else {
          el.style[style] = value;
        }
      }
      removeStyle(el, style, flags) {
        if (flags & RendererStyleFlags2.DashCase) {
          el.style.removeProperty(style);
        } else {
          el.style[style] = "";
        }
      }
      setProperty(el, name2, value) {
        if (el == null) {
          return;
        }
        (typeof ngDevMode === "undefined" || ngDevMode) && this.throwOnSyntheticProps && checkNoSyntheticProp(name2, "property");
        el[name2] = value;
      }
      setValue(node, value) {
        node.nodeValue = value;
      }
      listen(target, event, callback, options) {
        (typeof ngDevMode === "undefined" || ngDevMode) && this.throwOnSyntheticProps && checkNoSyntheticProp(event, "listener");
        if (typeof target === "string") {
          target = getDOM().getGlobalEventTarget(this.doc, target);
          if (!target) {
            throw new RuntimeError(5102, (typeof ngDevMode === "undefined" || ngDevMode) && `Unsupported event target ${target} for event ${event}`);
          }
        }
        let wrappedCallback = this.decoratePreventDefault(callback);
        if (this.tracingService?.wrapEventListener) {
          wrappedCallback = this.tracingService.wrapEventListener(target, event, wrappedCallback);
        }
        return this.eventManager.addEventListener(target, event, wrappedCallback, options);
      }
      decoratePreventDefault(eventHandler) {
        return (event) => {
          if (event === "__ngUnwrap__") {
            return eventHandler;
          }
          const allowDefaultBehavior = false ? this.ngZone.runGuarded(() => eventHandler(event)) : eventHandler(event);
          if (allowDefaultBehavior === false) {
            event.preventDefault();
          }
          return void 0;
        };
      }
    };
    AT_CHARCODE = (() => "@".charCodeAt(0))();
    ShadowDomRenderer = class extends DefaultDomRenderer2 {
      sharedStylesHost;
      hostEl;
      shadowRoot;
      constructor(eventManager, sharedStylesHost, hostEl, component, doc2, ngZone, nonce, platformIsServer, tracingService) {
        super(eventManager, doc2, ngZone, platformIsServer, tracingService);
        this.sharedStylesHost = sharedStylesHost;
        this.hostEl = hostEl;
        this.shadowRoot = hostEl.attachShadow({
          mode: "open"
        });
        this.sharedStylesHost.addHost(this.shadowRoot);
        let styles = component.styles;
        if (ngDevMode) {
          const baseHref = getDOM().getBaseHref(doc2) ?? "";
          styles = addBaseHrefToCssSourceMap(baseHref, styles);
        }
        styles = shimStylesContent(component.id, styles);
        for (const style of styles) {
          const styleEl = document.createElement("style");
          if (nonce) {
            styleEl.setAttribute("nonce", nonce);
          }
          styleEl.textContent = style;
          this.shadowRoot.appendChild(styleEl);
        }
        const styleUrls = component.getExternalStyles?.();
        if (styleUrls) {
          for (const styleUrl of styleUrls) {
            const linkEl = createLinkElement(styleUrl, doc2);
            if (nonce) {
              linkEl.setAttribute("nonce", nonce);
            }
            this.shadowRoot.appendChild(linkEl);
          }
        }
      }
      nodeOrShadowRoot(node) {
        return node === this.hostEl ? this.shadowRoot : node;
      }
      appendChild(parent, newChild) {
        return super.appendChild(this.nodeOrShadowRoot(parent), newChild);
      }
      insertBefore(parent, newChild, refChild) {
        return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);
      }
      removeChild(_parent, oldChild) {
        return super.removeChild(null, oldChild);
      }
      parentNode(node) {
        return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));
      }
      destroy() {
        this.sharedStylesHost.removeHost(this.shadowRoot);
      }
    };
    NoneEncapsulationDomRenderer = class extends DefaultDomRenderer2 {
      sharedStylesHost;
      removeStylesOnCompDestroy;
      styles;
      styleUrls;
      constructor(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc2, ngZone, platformIsServer, tracingService, compId) {
        super(eventManager, doc2, ngZone, platformIsServer, tracingService);
        this.sharedStylesHost = sharedStylesHost;
        this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;
        let styles = component.styles;
        if (ngDevMode) {
          const baseHref = getDOM().getBaseHref(doc2) ?? "";
          styles = addBaseHrefToCssSourceMap(baseHref, styles);
        }
        this.styles = compId ? shimStylesContent(compId, styles) : styles;
        this.styleUrls = component.getExternalStyles?.(compId);
      }
      applyStyles() {
        this.sharedStylesHost.addStyles(this.styles, this.styleUrls);
      }
      destroy() {
        if (!this.removeStylesOnCompDestroy) {
          return;
        }
        this.sharedStylesHost.removeStyles(this.styles, this.styleUrls);
      }
    };
    EmulatedEncapsulationDomRenderer2 = class extends NoneEncapsulationDomRenderer {
      contentAttr;
      hostAttr;
      constructor(eventManager, sharedStylesHost, component, appId, removeStylesOnCompDestroy, doc2, ngZone, platformIsServer, tracingService) {
        const compId = appId + "-" + component.id;
        super(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc2, ngZone, platformIsServer, tracingService, compId);
        this.contentAttr = shimContentAttribute(compId);
        this.hostAttr = shimHostAttribute(compId);
      }
      applyToHost(element) {
        this.applyStyles();
        this.setAttribute(element, this.hostAttr, "");
      }
      createElement(parent, name2) {
        const el = super.createElement(parent, name2);
        super.setAttribute(el, this.contentAttr, "");
        return el;
      }
    };
  }
});

// node_modules/@angular/platform-browser/fesm2022/browser.mjs
function getBaseElementHref() {
  baseElement = baseElement || document.head.querySelector("base");
  return baseElement ? baseElement.getAttribute("href") : null;
}
function relativePath(url) {
  return new URL(url, document.baseURI).pathname;
}
function bootstrapApplication(rootComponent, options) {
  const config3 = __spreadValues({
    rootComponent
  }, createProvidersConfig(options));
  if (false) {
    return resolveComponentResources(fetch).catch((error) => {
      console.error(error);
      return Promise.resolve();
    }).then(() => internalCreateApplication(config3));
  }
  return internalCreateApplication(config3);
}
function createProvidersConfig(options) {
  return {
    appProviders: [...BROWSER_MODULE_PROVIDERS, ...options?.providers ?? []],
    platformProviders: INTERNAL_BROWSER_PLATFORM_PROVIDERS
  };
}
function initDomAdapter() {
  BrowserDomAdapter.makeCurrent();
}
function errorHandler() {
  return new ErrorHandler();
}
function _document() {
  setDocument(document);
  return document;
}
var BrowserDomAdapter, baseElement, BrowserGetTestability, BrowserXhr, DomEventsPlugin, MODIFIER_KEYS, _keyMap, MODIFIER_KEY_GETTERS, KeyEventsPlugin, INTERNAL_BROWSER_PLATFORM_PROVIDERS, platformBrowser, BROWSER_MODULE_PROVIDERS_MARKER, TESTABILITY_PROVIDERS, BROWSER_MODULE_PROVIDERS, BrowserModule;
var init_browser = __esm({
  "node_modules/@angular/platform-browser/fesm2022/browser.mjs"() {
    "use strict";
    init_common();
    init_core();
    init_core();
    init_dom_renderer();
    BrowserDomAdapter = class _BrowserDomAdapter extends DomAdapter {
      supportsDOMEvents = true;
      static makeCurrent() {
        setRootDomAdapter(new _BrowserDomAdapter());
      }
      onAndCancel(el, evt, listener, options) {
        el.addEventListener(evt, listener, options);
        return () => {
          el.removeEventListener(evt, listener, options);
        };
      }
      dispatchEvent(el, evt) {
        el.dispatchEvent(evt);
      }
      remove(node) {
        node.remove();
      }
      createElement(tagName, doc2) {
        doc2 = doc2 || this.getDefaultDocument();
        return doc2.createElement(tagName);
      }
      createHtmlDocument() {
        return document.implementation.createHTMLDocument("fakeTitle");
      }
      getDefaultDocument() {
        return document;
      }
      isElementNode(node) {
        return node.nodeType === Node.ELEMENT_NODE;
      }
      isShadowRoot(node) {
        return node instanceof DocumentFragment;
      }
      /** @deprecated No longer being used in Ivy code. To be removed in version 14. */
      getGlobalEventTarget(doc2, target) {
        if (target === "window") {
          return window;
        }
        if (target === "document") {
          return doc2;
        }
        if (target === "body") {
          return doc2.body;
        }
        return null;
      }
      getBaseHref(doc2) {
        const href = getBaseElementHref();
        return href == null ? null : relativePath(href);
      }
      resetBaseElement() {
        baseElement = null;
      }
      getUserAgent() {
        return window.navigator.userAgent;
      }
      getCookie(name2) {
        return parseCookieValue(document.cookie, name2);
      }
    };
    baseElement = null;
    BrowserGetTestability = class {
      addToWindow(registry) {
        _global["getAngularTestability"] = (elem, findInAncestors = true) => {
          const testability = registry.findTestabilityInTree(elem, findInAncestors);
          if (testability == null) {
            throw new RuntimeError(5103, (typeof ngDevMode === "undefined" || ngDevMode) && "Could not find testability for element.");
          }
          return testability;
        };
        _global["getAllAngularTestabilities"] = () => registry.getAllTestabilities();
        _global["getAllAngularRootElements"] = () => registry.getAllRootElements();
        const whenAllStable = (callback) => {
          const testabilities = _global["getAllAngularTestabilities"]();
          let count2 = testabilities.length;
          const decrement = function() {
            count2--;
            if (count2 == 0) {
              callback();
            }
          };
          testabilities.forEach((testability) => {
            testability.whenStable(decrement);
          });
        };
        if (!_global["frameworkStabilizers"]) {
          _global["frameworkStabilizers"] = [];
        }
        _global["frameworkStabilizers"].push(whenAllStable);
      }
      findTestabilityInTree(registry, elem, findInAncestors) {
        if (elem == null) {
          return null;
        }
        const t2 = registry.getTestability(elem);
        if (t2 != null) {
          return t2;
        } else if (!findInAncestors) {
          return null;
        }
        if (getDOM().isShadowRoot(elem)) {
          return this.findTestabilityInTree(registry, elem.host, true);
        }
        return this.findTestabilityInTree(registry, elem.parentElement, true);
      }
    };
    BrowserXhr = class _BrowserXhr {
      build() {
        return new XMLHttpRequest();
      }
      static \u0275fac = function BrowserXhr_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _BrowserXhr)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _BrowserXhr,
        factory: _BrowserXhr.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserXhr, [{
        type: Injectable
      }], null, null);
    })();
    DomEventsPlugin = class _DomEventsPlugin extends EventManagerPlugin {
      constructor(doc2) {
        super(doc2);
      }
      // This plugin should come last in the list of plugins, because it accepts all
      // events.
      supports(eventName) {
        return true;
      }
      addEventListener(element, eventName, handler, options) {
        element.addEventListener(eventName, handler, options);
        return () => this.removeEventListener(element, eventName, handler, options);
      }
      removeEventListener(target, eventName, callback, options) {
        return target.removeEventListener(eventName, callback, options);
      }
      static \u0275fac = function DomEventsPlugin_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DomEventsPlugin)(\u0275\u0275inject(DOCUMENT));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _DomEventsPlugin,
        factory: _DomEventsPlugin.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomEventsPlugin, [{
        type: Injectable
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DOCUMENT]
        }]
      }], null);
    })();
    MODIFIER_KEYS = ["alt", "control", "meta", "shift"];
    _keyMap = {
      "\b": "Backspace",
      "	": "Tab",
      "\x7F": "Delete",
      "\x1B": "Escape",
      "Del": "Delete",
      "Esc": "Escape",
      "Left": "ArrowLeft",
      "Right": "ArrowRight",
      "Up": "ArrowUp",
      "Down": "ArrowDown",
      "Menu": "ContextMenu",
      "Scroll": "ScrollLock",
      "Win": "OS"
    };
    MODIFIER_KEY_GETTERS = {
      "alt": (event) => event.altKey,
      "control": (event) => event.ctrlKey,
      "meta": (event) => event.metaKey,
      "shift": (event) => event.shiftKey
    };
    KeyEventsPlugin = class _KeyEventsPlugin extends EventManagerPlugin {
      /**
       * Initializes an instance of the browser plug-in.
       * @param doc The document in which key events will be detected.
       */
      constructor(doc2) {
        super(doc2);
      }
      /**
       * Reports whether a named key event is supported.
       * @param eventName The event name to query.
       * @return True if the named key event is supported.
       */
      supports(eventName) {
        return _KeyEventsPlugin.parseEventName(eventName) != null;
      }
      /**
       * Registers a handler for a specific element and key event.
       * @param element The HTML element to receive event notifications.
       * @param eventName The name of the key event to listen for.
       * @param handler A function to call when the notification occurs. Receives the
       * event object as an argument.
       * @returns The key event that was registered.
       */
      addEventListener(element, eventName, handler, options) {
        const parsedEvent = _KeyEventsPlugin.parseEventName(eventName);
        const outsideHandler = _KeyEventsPlugin.eventCallback(parsedEvent["fullKey"], handler, this.manager.getZone());
        return this.manager.getZone().runOutsideAngular(() => {
          return getDOM().onAndCancel(element, parsedEvent["domEventName"], outsideHandler, options);
        });
      }
      /**
       * Parses the user provided full keyboard event definition and normalizes it for
       * later internal use. It ensures the string is all lowercase, converts special
       * characters to a standard spelling, and orders all the values consistently.
       *
       * @param eventName The name of the key event to listen for.
       * @returns an object with the full, normalized string, and the dom event name
       * or null in the case when the event doesn't match a keyboard event.
       */
      static parseEventName(eventName) {
        const parts = eventName.toLowerCase().split(".");
        const domEventName = parts.shift();
        if (parts.length === 0 || !(domEventName === "keydown" || domEventName === "keyup")) {
          return null;
        }
        const key = _KeyEventsPlugin._normalizeKey(parts.pop());
        let fullKey = "";
        let codeIX = parts.indexOf("code");
        if (codeIX > -1) {
          parts.splice(codeIX, 1);
          fullKey = "code.";
        }
        MODIFIER_KEYS.forEach((modifierName) => {
          const index = parts.indexOf(modifierName);
          if (index > -1) {
            parts.splice(index, 1);
            fullKey += modifierName + ".";
          }
        });
        fullKey += key;
        if (parts.length != 0 || key.length === 0) {
          return null;
        }
        const result = {};
        result["domEventName"] = domEventName;
        result["fullKey"] = fullKey;
        return result;
      }
      /**
       * Determines whether the actual keys pressed match the configured key code string.
       * The `fullKeyCode` event is normalized in the `parseEventName` method when the
       * event is attached to the DOM during the `addEventListener` call. This is unseen
       * by the end user and is normalized for internal consistency and parsing.
       *
       * @param event The keyboard event.
       * @param fullKeyCode The normalized user defined expected key event string
       * @returns boolean.
       */
      static matchEventFullKeyCode(event, fullKeyCode) {
        let keycode = _keyMap[event.key] || event.key;
        let key = "";
        if (fullKeyCode.indexOf("code.") > -1) {
          keycode = event.code;
          key = "code.";
        }
        if (keycode == null || !keycode) return false;
        keycode = keycode.toLowerCase();
        if (keycode === " ") {
          keycode = "space";
        } else if (keycode === ".") {
          keycode = "dot";
        }
        MODIFIER_KEYS.forEach((modifierName) => {
          if (modifierName !== keycode) {
            const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
            if (modifierGetter(event)) {
              key += modifierName + ".";
            }
          }
        });
        key += keycode;
        return key === fullKeyCode;
      }
      /**
       * Configures a handler callback for a key event.
       * @param fullKey The event name that combines all simultaneous keystrokes.
       * @param handler The function that responds to the key event.
       * @param zone The zone in which the event occurred.
       * @returns A callback function.
       */
      static eventCallback(fullKey, handler, zone) {
        return (event) => {
          if (_KeyEventsPlugin.matchEventFullKeyCode(event, fullKey)) {
            zone.runGuarded(() => handler(event));
          }
        };
      }
      /** @internal */
      static _normalizeKey(keyName2) {
        return keyName2 === "esc" ? "escape" : keyName2;
      }
      static \u0275fac = function KeyEventsPlugin_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _KeyEventsPlugin)(\u0275\u0275inject(DOCUMENT));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _KeyEventsPlugin,
        factory: _KeyEventsPlugin.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyEventsPlugin, [{
        type: Injectable
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DOCUMENT]
        }]
      }], null);
    })();
    INTERNAL_BROWSER_PLATFORM_PROVIDERS = [{
      provide: PLATFORM_ID,
      useValue: PLATFORM_BROWSER_ID
    }, {
      provide: PLATFORM_INITIALIZER,
      useValue: initDomAdapter,
      multi: true
    }, {
      provide: DOCUMENT,
      useFactory: _document
    }];
    platformBrowser = createPlatformFactory(platformCore, "browser", INTERNAL_BROWSER_PLATFORM_PROVIDERS);
    BROWSER_MODULE_PROVIDERS_MARKER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "BrowserModule Providers Marker" : "");
    TESTABILITY_PROVIDERS = [{
      provide: TESTABILITY_GETTER,
      useClass: BrowserGetTestability
    }, {
      provide: TESTABILITY,
      useClass: Testability,
      deps: [NgZone, TestabilityRegistry, TESTABILITY_GETTER]
    }, {
      provide: Testability,
      // Also provide as `Testability` for backwards-compatibility.
      useClass: Testability,
      deps: [NgZone, TestabilityRegistry, TESTABILITY_GETTER]
    }];
    BROWSER_MODULE_PROVIDERS = [{
      provide: INJECTOR_SCOPE,
      useValue: "root"
    }, {
      provide: ErrorHandler,
      useFactory: errorHandler
    }, {
      provide: EVENT_MANAGER_PLUGINS,
      useClass: DomEventsPlugin,
      multi: true,
      deps: [DOCUMENT]
    }, {
      provide: EVENT_MANAGER_PLUGINS,
      useClass: KeyEventsPlugin,
      multi: true,
      deps: [DOCUMENT]
    }, DomRendererFactory2, SharedStylesHost, EventManager, {
      provide: RendererFactory2,
      useExisting: DomRendererFactory2
    }, {
      provide: XhrFactory,
      useClass: BrowserXhr
    }, typeof ngDevMode === "undefined" || ngDevMode ? {
      provide: BROWSER_MODULE_PROVIDERS_MARKER,
      useValue: true
    } : []];
    BrowserModule = class _BrowserModule {
      constructor() {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          const providersAlreadyPresent = inject2(BROWSER_MODULE_PROVIDERS_MARKER, {
            optional: true,
            skipSelf: true
          });
          if (providersAlreadyPresent) {
            throw new RuntimeError(5100, `Providers from the \`BrowserModule\` have already been loaded. If you need access to common directives such as NgIf and NgFor, import the \`CommonModule\` instead.`);
          }
        }
      }
      static \u0275fac = function BrowserModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _BrowserModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _BrowserModule,
        exports: [CommonModule, ApplicationModule]
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
        providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],
        imports: [CommonModule, ApplicationModule]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserModule, [{
        type: NgModule,
        args: [{
          providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],
          exports: [CommonModule, ApplicationModule]
        }]
      }], () => [], null);
    })();
  }
});

// node_modules/@angular/common/fesm2022/module.mjs
function assertValidHeaders(headers) {
  for (const [key, value] of Object.entries(headers)) {
    if (!(typeof value === "string" || typeof value === "number") && !Array.isArray(value)) {
      throw new Error(`Unexpected value of the \`${key}\` header provided. Expecting either a string, a number or an array, but got: \`${value}\`.`);
    }
  }
}
function paramParser(rawParams, codec) {
  const map2 = /* @__PURE__ */ new Map();
  if (rawParams.length > 0) {
    const params = rawParams.replace(/^\?/, "").split("&");
    params.forEach((param) => {
      const eqIdx = param.indexOf("=");
      const [key, val] = eqIdx == -1 ? [codec.decodeKey(param), ""] : [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))];
      const list = map2.get(key) || [];
      list.push(val);
      map2.set(key, list);
    });
  }
  return map2;
}
function standardEncoding(v) {
  return encodeURIComponent(v).replace(STANDARD_ENCODING_REGEX, (s, t2) => STANDARD_ENCODING_REPLACEMENTS[t2] ?? s);
}
function valueToString(value) {
  return `${value}`;
}
function mightHaveBody(method) {
  switch (method) {
    case "DELETE":
    case "GET":
    case "HEAD":
    case "OPTIONS":
    case "JSONP":
      return false;
    default:
      return true;
  }
}
function isArrayBuffer(value) {
  return typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer;
}
function isBlob(value) {
  return typeof Blob !== "undefined" && value instanceof Blob;
}
function isFormData(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}
function isUrlSearchParams(value) {
  return typeof URLSearchParams !== "undefined" && value instanceof URLSearchParams;
}
function addBody(options, body) {
  return {
    body,
    headers: options.headers,
    context: options.context,
    observe: options.observe,
    params: options.params,
    reportProgress: options.reportProgress,
    responseType: options.responseType,
    withCredentials: options.withCredentials,
    transferCache: options.transferCache,
    keepalive: options.keepalive,
    priority: options.priority,
    cache: options.cache,
    mode: options.mode,
    redirect: options.redirect
  };
}
function getResponseUrl$1(response) {
  if (response.url) {
    return response.url;
  }
  const xRequestUrl = X_REQUEST_URL_HEADER.toLocaleLowerCase();
  return response.headers.get(xRequestUrl);
}
function noop3() {
}
function warningOptionsMessage(req) {
  if (req.credentials && req.withCredentials) {
    console.warn(formatRuntimeError(2819, `Angular detected that a \`HttpClient\` request has both \`withCredentials: true\` and \`credentials: '${req.credentials}'\` options. The \`withCredentials\` option is overriding the explicit \`credentials\` setting to 'include'. Consider removing \`withCredentials\` and using \`credentials: '${req.credentials}'\` directly for clarity.`));
  }
}
function silenceSuperfluousUnhandledPromiseRejection(promise) {
  promise.then(noop3, noop3);
}
function interceptorChainEndFn(req, finalHandlerFn) {
  return finalHandlerFn(req);
}
function adaptLegacyInterceptorToChain(chainTailFn, interceptor) {
  return (initialRequest, finalHandlerFn) => interceptor.intercept(initialRequest, {
    handle: (downstreamRequest) => chainTailFn(downstreamRequest, finalHandlerFn)
  });
}
function chainedInterceptorFn(chainTailFn, interceptorFn, injector) {
  return (initialRequest, finalHandlerFn) => runInInjectionContext(injector, () => interceptorFn(initialRequest, (downstreamRequest) => chainTailFn(downstreamRequest, finalHandlerFn)));
}
function legacyInterceptorFnFactory() {
  let chain = null;
  return (req, handler) => {
    if (chain === null) {
      const interceptors = inject2(HTTP_INTERCEPTORS, {
        optional: true
      }) ?? [];
      chain = interceptors.reduceRight(adaptLegacyInterceptorToChain, interceptorChainEndFn);
    }
    const pendingTasks = inject2(PendingTasks);
    const contributeToStability = inject2(REQUESTS_CONTRIBUTE_TO_STABILITY);
    if (contributeToStability) {
      const removeTask = pendingTasks.add();
      return chain(req, handler).pipe(finalize(removeTask));
    } else {
      return chain(req, handler);
    }
  };
}
function jsonpCallbackContext() {
  if (typeof window === "object") {
    return window;
  }
  return {};
}
function jsonpInterceptorFn(req, next) {
  if (req.method === "JSONP") {
    return inject2(JsonpClientBackend).handle(req);
  }
  return next(req);
}
function getResponseUrl(xhr) {
  if ("responseURL" in xhr && xhr.responseURL) {
    return xhr.responseURL;
  }
  if (X_REQUEST_URL_REGEXP.test(xhr.getAllResponseHeaders())) {
    return xhr.getResponseHeader(X_REQUEST_URL_HEADER);
  }
  return null;
}
function validateXhrCompatibility(req) {
  const unsupportedOptions = [{
    property: "keepalive",
    errorCode: 2813
    /* RuntimeErrorCode.KEEPALIVE_NOT_SUPPORTED_WITH_XHR */
  }, {
    property: "cache",
    errorCode: 2814
    /* RuntimeErrorCode.CACHE_NOT_SUPPORTED_WITH_XHR */
  }, {
    property: "priority",
    errorCode: 2815
    /* RuntimeErrorCode.PRIORITY_NOT_SUPPORTED_WITH_XHR */
  }, {
    property: "mode",
    errorCode: 2816
    /* RuntimeErrorCode.MODE_NOT_SUPPORTED_WITH_XHR */
  }, {
    property: "redirect",
    errorCode: 2817
    /* RuntimeErrorCode.REDIRECT_NOT_SUPPORTED_WITH_XHR */
  }, {
    property: "credentials",
    errorCode: 2818
    /* RuntimeErrorCode.CREDENTIALS_NOT_SUPPORTED_WITH_XHR */
  }];
  for (const {
    property,
    errorCode
  } of unsupportedOptions) {
    if (req[property]) {
      console.warn(formatRuntimeError(errorCode, `Angular detected that a \`HttpClient\` request with the \`${property}\` option was sent using XHR, which does not support it. To use the \`${property}\` option, enable Fetch API support by passing \`withFetch()\` as an argument to \`provideHttpClient()\`.`));
    }
  }
}
function xsrfInterceptorFn(req, next) {
  const lcUrl = req.url.toLowerCase();
  if (!inject2(XSRF_ENABLED) || req.method === "GET" || req.method === "HEAD" || lcUrl.startsWith("http://") || lcUrl.startsWith("https://")) {
    return next(req);
  }
  const token = inject2(HttpXsrfTokenExtractor).getToken();
  const headerName = inject2(XSRF_HEADER_NAME);
  if (token != null && !req.headers.has(headerName)) {
    req = req.clone({
      headers: req.headers.set(headerName, token)
    });
  }
  return next(req);
}
function makeHttpFeature(kind, providers) {
  return {
    \u0275kind: kind,
    \u0275providers: providers
  };
}
function provideHttpClient(...features) {
  if (ngDevMode) {
    const featureKinds = new Set(features.map((f) => f.\u0275kind));
    if (featureKinds.has(HttpFeatureKind.NoXsrfProtection) && featureKinds.has(HttpFeatureKind.CustomXsrfConfiguration)) {
      throw new Error(ngDevMode ? `Configuration error: found both withXsrfConfiguration() and withNoXsrfProtection() in the same call to provideHttpClient(), which is a contradiction.` : "");
    }
  }
  const providers = [HttpClient, HttpXhrBackend, HttpInterceptorHandler, {
    provide: HttpHandler,
    useExisting: HttpInterceptorHandler
  }, {
    provide: HttpBackend,
    useFactory: () => {
      return inject2(FETCH_BACKEND, {
        optional: true
      }) ?? inject2(HttpXhrBackend);
    }
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useValue: xsrfInterceptorFn,
    multi: true
  }, {
    provide: XSRF_ENABLED,
    useValue: true
  }, {
    provide: HttpXsrfTokenExtractor,
    useClass: HttpXsrfCookieExtractor
  }];
  for (const feature of features) {
    providers.push(...feature.\u0275providers);
  }
  return makeEnvironmentProviders(providers);
}
function withInterceptorsFromDi() {
  return makeHttpFeature(HttpFeatureKind.LegacyInterceptors, [{
    provide: LEGACY_INTERCEPTOR_FN,
    useFactory: legacyInterceptorFnFactory
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useExisting: LEGACY_INTERCEPTOR_FN,
    multi: true
  }]);
}
function withXsrfConfiguration({
  cookieName,
  headerName
}) {
  const providers = [];
  if (cookieName !== void 0) {
    providers.push({
      provide: XSRF_COOKIE_NAME,
      useValue: cookieName
    });
  }
  if (headerName !== void 0) {
    providers.push({
      provide: XSRF_HEADER_NAME,
      useValue: headerName
    });
  }
  return makeHttpFeature(HttpFeatureKind.CustomXsrfConfiguration, providers);
}
function withNoXsrfProtection() {
  return makeHttpFeature(HttpFeatureKind.NoXsrfProtection, [{
    provide: XSRF_ENABLED,
    useValue: false
  }]);
}
function withJsonpSupport() {
  return makeHttpFeature(HttpFeatureKind.JsonpSupport, [JsonpClientBackend, {
    provide: JsonpCallbackContext,
    useFactory: jsonpCallbackContext
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useValue: jsonpInterceptorFn,
    multi: true
  }]);
}
var HttpHandler, HttpBackend, HttpHeaders, HttpUrlEncodingCodec, STANDARD_ENCODING_REGEX, STANDARD_ENCODING_REPLACEMENTS, HttpParams, HttpContext, CONTENT_TYPE_HEADER, ACCEPT_HEADER, X_REQUEST_URL_HEADER, TEXT_CONTENT_TYPE, JSON_CONTENT_TYPE, ACCEPT_HEADER_VALUE, HttpRequest, HttpEventType, HttpResponseBase, HttpHeaderResponse, HttpResponse, HttpErrorResponse, HTTP_STATUS_CODE_OK, HTTP_STATUS_CODE_NO_CONTENT, HttpStatusCode, HttpClient, XSSI_PREFIX$1, FETCH_BACKEND, FetchBackend, FetchFactory, HTTP_INTERCEPTORS, HTTP_INTERCEPTOR_FNS, HTTP_ROOT_INTERCEPTOR_FNS, REQUESTS_CONTRIBUTE_TO_STABILITY, fetchBackendWarningDisplayed, HttpInterceptorHandler, nextRequestId, foreignDocument, JSONP_ERR_NO_CALLBACK, JSONP_ERR_WRONG_METHOD, JSONP_ERR_WRONG_RESPONSE_TYPE, JSONP_ERR_HEADERS_NOT_SUPPORTED, JsonpCallbackContext, JsonpClientBackend, JsonpInterceptor, XSSI_PREFIX, X_REQUEST_URL_REGEXP, HttpXhrBackend, XSRF_ENABLED, XSRF_DEFAULT_COOKIE_NAME, XSRF_COOKIE_NAME, XSRF_DEFAULT_HEADER_NAME, XSRF_HEADER_NAME, HttpXsrfTokenExtractor, HttpXsrfCookieExtractor, HttpXsrfInterceptor, HttpFeatureKind, LEGACY_INTERCEPTOR_FN, HttpClientXsrfModule, HttpClientModule, HttpClientJsonpModule;
var init_module = __esm({
  "node_modules/@angular/common/fesm2022/module.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_operators();
    init_esm();
    init_xhr();
    HttpHandler = class {
    };
    HttpBackend = class {
    };
    HttpHeaders = class _HttpHeaders {
      /**
       * Internal map of lowercase header names to values.
       */
      headers;
      /**
       * Internal map of lowercased header names to the normalized
       * form of the name (the form seen first).
       */
      normalizedNames = /* @__PURE__ */ new Map();
      /**
       * Complete the lazy initialization of this object (needed before reading).
       */
      lazyInit;
      /**
       * Queued updates to be materialized the next initialization.
       */
      lazyUpdate = null;
      /**  Constructs a new HTTP header object with the given values.*/
      constructor(headers) {
        if (!headers) {
          this.headers = /* @__PURE__ */ new Map();
        } else if (typeof headers === "string") {
          this.lazyInit = () => {
            this.headers = /* @__PURE__ */ new Map();
            headers.split("\n").forEach((line) => {
              const index = line.indexOf(":");
              if (index > 0) {
                const name2 = line.slice(0, index);
                const value = line.slice(index + 1).trim();
                this.addHeaderEntry(name2, value);
              }
            });
          };
        } else if (typeof Headers !== "undefined" && headers instanceof Headers) {
          this.headers = /* @__PURE__ */ new Map();
          headers.forEach((value, name2) => {
            this.addHeaderEntry(name2, value);
          });
        } else {
          this.lazyInit = () => {
            if (typeof ngDevMode === "undefined" || ngDevMode) {
              assertValidHeaders(headers);
            }
            this.headers = /* @__PURE__ */ new Map();
            Object.entries(headers).forEach(([name2, values2]) => {
              this.setHeaderEntries(name2, values2);
            });
          };
        }
      }
      /**
       * Checks for existence of a given header.
       *
       * @param name The header name to check for existence.
       *
       * @returns True if the header exists, false otherwise.
       */
      has(name2) {
        this.init();
        return this.headers.has(name2.toLowerCase());
      }
      /**
       * Retrieves the first value of a given header.
       *
       * @param name The header name.
       *
       * @returns The value string if the header exists, null otherwise
       */
      get(name2) {
        this.init();
        const values2 = this.headers.get(name2.toLowerCase());
        return values2 && values2.length > 0 ? values2[0] : null;
      }
      /**
       * Retrieves the names of the headers.
       *
       * @returns A list of header names.
       */
      keys() {
        this.init();
        return Array.from(this.normalizedNames.values());
      }
      /**
       * Retrieves a list of values for a given header.
       *
       * @param name The header name from which to retrieve values.
       *
       * @returns A string of values if the header exists, null otherwise.
       */
      getAll(name2) {
        this.init();
        return this.headers.get(name2.toLowerCase()) || null;
      }
      /**
       * Appends a new value to the existing set of values for a header
       * and returns them in a clone of the original instance.
       *
       * @param name The header name for which to append the values.
       * @param value The value to append.
       *
       * @returns A clone of the HTTP headers object with the value appended to the given header.
       */
      append(name2, value) {
        return this.clone({
          name: name2,
          value,
          op: "a"
        });
      }
      /**
       * Sets or modifies a value for a given header in a clone of the original instance.
       * If the header already exists, its value is replaced with the given value
       * in the returned object.
       *
       * @param name The header name.
       * @param value The value or values to set or override for the given header.
       *
       * @returns A clone of the HTTP headers object with the newly set header value.
       */
      set(name2, value) {
        return this.clone({
          name: name2,
          value,
          op: "s"
        });
      }
      /**
       * Deletes values for a given header in a clone of the original instance.
       *
       * @param name The header name.
       * @param value The value or values to delete for the given header.
       *
       * @returns A clone of the HTTP headers object with the given value deleted.
       */
      delete(name2, value) {
        return this.clone({
          name: name2,
          value,
          op: "d"
        });
      }
      maybeSetNormalizedName(name2, lcName) {
        if (!this.normalizedNames.has(lcName)) {
          this.normalizedNames.set(lcName, name2);
        }
      }
      init() {
        if (!!this.lazyInit) {
          if (this.lazyInit instanceof _HttpHeaders) {
            this.copyFrom(this.lazyInit);
          } else {
            this.lazyInit();
          }
          this.lazyInit = null;
          if (!!this.lazyUpdate) {
            this.lazyUpdate.forEach((update) => this.applyUpdate(update));
            this.lazyUpdate = null;
          }
        }
      }
      copyFrom(other) {
        other.init();
        Array.from(other.headers.keys()).forEach((key) => {
          this.headers.set(key, other.headers.get(key));
          this.normalizedNames.set(key, other.normalizedNames.get(key));
        });
      }
      clone(update) {
        const clone = new _HttpHeaders();
        clone.lazyInit = !!this.lazyInit && this.lazyInit instanceof _HttpHeaders ? this.lazyInit : this;
        clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);
        return clone;
      }
      applyUpdate(update) {
        const key = update.name.toLowerCase();
        switch (update.op) {
          case "a":
          case "s":
            let value = update.value;
            if (typeof value === "string") {
              value = [value];
            }
            if (value.length === 0) {
              return;
            }
            this.maybeSetNormalizedName(update.name, key);
            const base2 = (update.op === "a" ? this.headers.get(key) : void 0) || [];
            base2.push(...value);
            this.headers.set(key, base2);
            break;
          case "d":
            const toDelete = update.value;
            if (!toDelete) {
              this.headers.delete(key);
              this.normalizedNames.delete(key);
            } else {
              let existing = this.headers.get(key);
              if (!existing) {
                return;
              }
              existing = existing.filter((value2) => toDelete.indexOf(value2) === -1);
              if (existing.length === 0) {
                this.headers.delete(key);
                this.normalizedNames.delete(key);
              } else {
                this.headers.set(key, existing);
              }
            }
            break;
        }
      }
      addHeaderEntry(name2, value) {
        const key = name2.toLowerCase();
        this.maybeSetNormalizedName(name2, key);
        if (this.headers.has(key)) {
          this.headers.get(key).push(value);
        } else {
          this.headers.set(key, [value]);
        }
      }
      setHeaderEntries(name2, values2) {
        const headerValues = (Array.isArray(values2) ? values2 : [values2]).map((value) => value.toString());
        const key = name2.toLowerCase();
        this.headers.set(key, headerValues);
        this.maybeSetNormalizedName(name2, key);
      }
      /**
       * @internal
       */
      forEach(fn) {
        this.init();
        Array.from(this.normalizedNames.keys()).forEach((key) => fn(this.normalizedNames.get(key), this.headers.get(key)));
      }
    };
    HttpUrlEncodingCodec = class {
      /**
       * Encodes a key name for a URL parameter or query-string.
       * @param key The key name.
       * @returns The encoded key name.
       */
      encodeKey(key) {
        return standardEncoding(key);
      }
      /**
       * Encodes the value of a URL parameter or query-string.
       * @param value The value.
       * @returns The encoded value.
       */
      encodeValue(value) {
        return standardEncoding(value);
      }
      /**
       * Decodes an encoded URL parameter or query-string key.
       * @param key The encoded key name.
       * @returns The decoded key name.
       */
      decodeKey(key) {
        return decodeURIComponent(key);
      }
      /**
       * Decodes an encoded URL parameter or query-string value.
       * @param value The encoded value.
       * @returns The decoded value.
       */
      decodeValue(value) {
        return decodeURIComponent(value);
      }
    };
    STANDARD_ENCODING_REGEX = /%(\d[a-f0-9])/gi;
    STANDARD_ENCODING_REPLACEMENTS = {
      "40": "@",
      "3A": ":",
      "24": "$",
      "2C": ",",
      "3B": ";",
      "3D": "=",
      "3F": "?",
      "2F": "/"
    };
    HttpParams = class _HttpParams {
      map;
      encoder;
      updates = null;
      cloneFrom = null;
      constructor(options = {}) {
        this.encoder = options.encoder || new HttpUrlEncodingCodec();
        if (options.fromString) {
          if (options.fromObject) {
            throw new RuntimeError(2805, ngDevMode && "Cannot specify both fromString and fromObject.");
          }
          this.map = paramParser(options.fromString, this.encoder);
        } else if (!!options.fromObject) {
          this.map = /* @__PURE__ */ new Map();
          Object.keys(options.fromObject).forEach((key) => {
            const value = options.fromObject[key];
            const values2 = Array.isArray(value) ? value.map(valueToString) : [valueToString(value)];
            this.map.set(key, values2);
          });
        } else {
          this.map = null;
        }
      }
      /**
       * Reports whether the body includes one or more values for a given parameter.
       * @param param The parameter name.
       * @returns True if the parameter has one or more values,
       * false if it has no value or is not present.
       */
      has(param) {
        this.init();
        return this.map.has(param);
      }
      /**
       * Retrieves the first value for a parameter.
       * @param param The parameter name.
       * @returns The first value of the given parameter,
       * or `null` if the parameter is not present.
       */
      get(param) {
        this.init();
        const res = this.map.get(param);
        return !!res ? res[0] : null;
      }
      /**
       * Retrieves all values for a  parameter.
       * @param param The parameter name.
       * @returns All values in a string array,
       * or `null` if the parameter not present.
       */
      getAll(param) {
        this.init();
        return this.map.get(param) || null;
      }
      /**
       * Retrieves all the parameters for this body.
       * @returns The parameter names in a string array.
       */
      keys() {
        this.init();
        return Array.from(this.map.keys());
      }
      /**
       * Appends a new value to existing values for a parameter.
       * @param param The parameter name.
       * @param value The new value to add.
       * @return A new body with the appended value.
       */
      append(param, value) {
        return this.clone({
          param,
          value,
          op: "a"
        });
      }
      /**
       * Constructs a new body with appended values for the given parameter name.
       * @param params parameters and values
       * @return A new body with the new value.
       */
      appendAll(params) {
        const updates = [];
        Object.keys(params).forEach((param) => {
          const value = params[param];
          if (Array.isArray(value)) {
            value.forEach((_value) => {
              updates.push({
                param,
                value: _value,
                op: "a"
              });
            });
          } else {
            updates.push({
              param,
              value,
              op: "a"
            });
          }
        });
        return this.clone(updates);
      }
      /**
       * Replaces the value for a parameter.
       * @param param The parameter name.
       * @param value The new value.
       * @return A new body with the new value.
       */
      set(param, value) {
        return this.clone({
          param,
          value,
          op: "s"
        });
      }
      /**
       * Removes a given value or all values from a parameter.
       * @param param The parameter name.
       * @param value The value to remove, if provided.
       * @return A new body with the given value removed, or with all values
       * removed if no value is specified.
       */
      delete(param, value) {
        return this.clone({
          param,
          value,
          op: "d"
        });
      }
      /**
       * Serializes the body to an encoded string, where key-value pairs (separated by `=`) are
       * separated by `&`s.
       */
      toString() {
        this.init();
        return this.keys().map((key) => {
          const eKey = this.encoder.encodeKey(key);
          return this.map.get(key).map((value) => eKey + "=" + this.encoder.encodeValue(value)).join("&");
        }).filter((param) => param !== "").join("&");
      }
      clone(update) {
        const clone = new _HttpParams({
          encoder: this.encoder
        });
        clone.cloneFrom = this.cloneFrom || this;
        clone.updates = (this.updates || []).concat(update);
        return clone;
      }
      init() {
        if (this.map === null) {
          this.map = /* @__PURE__ */ new Map();
        }
        if (this.cloneFrom !== null) {
          this.cloneFrom.init();
          this.cloneFrom.keys().forEach((key) => this.map.set(key, this.cloneFrom.map.get(key)));
          this.updates.forEach((update) => {
            switch (update.op) {
              case "a":
              case "s":
                const base2 = (update.op === "a" ? this.map.get(update.param) : void 0) || [];
                base2.push(valueToString(update.value));
                this.map.set(update.param, base2);
                break;
              case "d":
                if (update.value !== void 0) {
                  let base3 = this.map.get(update.param) || [];
                  const idx = base3.indexOf(valueToString(update.value));
                  if (idx !== -1) {
                    base3.splice(idx, 1);
                  }
                  if (base3.length > 0) {
                    this.map.set(update.param, base3);
                  } else {
                    this.map.delete(update.param);
                  }
                } else {
                  this.map.delete(update.param);
                  break;
                }
            }
          });
          this.cloneFrom = this.updates = null;
        }
      }
    };
    HttpContext = class {
      map = /* @__PURE__ */ new Map();
      /**
       * Store a value in the context. If a value is already present it will be overwritten.
       *
       * @param token The reference to an instance of `HttpContextToken`.
       * @param value The value to store.
       *
       * @returns A reference to itself for easy chaining.
       */
      set(token, value) {
        this.map.set(token, value);
        return this;
      }
      /**
       * Retrieve the value associated with the given token.
       *
       * @param token The reference to an instance of `HttpContextToken`.
       *
       * @returns The stored value or default if one is defined.
       */
      get(token) {
        if (!this.map.has(token)) {
          this.map.set(token, token.defaultValue());
        }
        return this.map.get(token);
      }
      /**
       * Delete the value associated with the given token.
       *
       * @param token The reference to an instance of `HttpContextToken`.
       *
       * @returns A reference to itself for easy chaining.
       */
      delete(token) {
        this.map.delete(token);
        return this;
      }
      /**
       * Checks for existence of a given token.
       *
       * @param token The reference to an instance of `HttpContextToken`.
       *
       * @returns True if the token exists, false otherwise.
       */
      has(token) {
        return this.map.has(token);
      }
      /**
       * @returns a list of tokens currently stored in the context.
       */
      keys() {
        return this.map.keys();
      }
    };
    CONTENT_TYPE_HEADER = "Content-Type";
    ACCEPT_HEADER = "Accept";
    X_REQUEST_URL_HEADER = "X-Request-URL";
    TEXT_CONTENT_TYPE = "text/plain";
    JSON_CONTENT_TYPE = "application/json";
    ACCEPT_HEADER_VALUE = `${JSON_CONTENT_TYPE}, ${TEXT_CONTENT_TYPE}, */*`;
    HttpRequest = class _HttpRequest {
      url;
      /**
       * The request body, or `null` if one isn't set.
       *
       * Bodies are not enforced to be immutable, as they can include a reference to any
       * user-defined data type. However, interceptors should take care to preserve
       * idempotence by treating them as such.
       */
      body = null;
      /**
       * Outgoing headers for this request.
       */
      headers;
      /**
       * Shared and mutable context that can be used by interceptors
       */
      context;
      /**
       * Whether this request should be made in a way that exposes progress events.
       *
       * Progress events are expensive (change detection runs on each event) and so
       * they should only be requested if the consumer intends to monitor them.
       *
       * Note: The `FetchBackend` doesn't support progress report on uploads.
       */
      reportProgress = false;
      /**
       * Whether this request should be sent with outgoing credentials (cookies).
       */
      withCredentials = false;
      /**
       *  The credentials mode of the request, which determines how cookies and HTTP authentication are handled.
       *  This can affect whether cookies are sent with the request, and how authentication is handled.
       */
      credentials;
      /**
       * When using the fetch implementation and set to `true`, the browser will not abort the associated request if the page that initiated it is unloaded before the request is complete.
       */
      keepalive = false;
      /**
       * Controls how the request will interact with the browser's HTTP cache.
       * This affects whether a response is retrieved from the cache, how it is stored, or if it bypasses the cache altogether.
       */
      cache;
      /**
       * Indicates the relative priority of the request. This may be used by the browser to decide the order in which requests are dispatched and resources fetched.
       */
      priority;
      /**
       * The mode of the request, which determines how the request will interact with the browser's security model.
       * This can affect things like CORS (Cross-Origin Resource Sharing) and same-origin policies.
       */
      mode;
      /**
       * The redirect mode of the request, which determines how redirects are handled.
       * This can affect whether the request follows redirects automatically, or if it fails when a redirect occurs.
       */
      redirect;
      /**
       * The expected response type of the server.
       *
       * This is used to parse the response appropriately before returning it to
       * the requestee.
       */
      responseType = "json";
      /**
       * The outgoing HTTP request method.
       */
      method;
      /**
       * Outgoing URL parameters.
       *
       * To pass a string representation of HTTP parameters in the URL-query-string format,
       * the `HttpParamsOptions`' `fromString` may be used. For example:
       *
       * ```ts
       * new HttpParams({fromString: 'angular=awesome'})
       * ```
       */
      params;
      /**
       * The outgoing URL with all URL parameters set.
       */
      urlWithParams;
      /**
       * The HttpTransferCache option for the request
       */
      transferCache;
      /**
       * The timeout for the backend HTTP request in ms.
       */
      timeout;
      constructor(method, url, third, fourth) {
        this.url = url;
        this.method = method.toUpperCase();
        let options;
        if (mightHaveBody(this.method) || !!fourth) {
          this.body = third !== void 0 ? third : null;
          options = fourth;
        } else {
          options = third;
        }
        if (options) {
          this.reportProgress = !!options.reportProgress;
          this.withCredentials = !!options.withCredentials;
          this.keepalive = !!options.keepalive;
          if (!!options.responseType) {
            this.responseType = options.responseType;
          }
          if (options.headers) {
            this.headers = options.headers;
          }
          if (options.context) {
            this.context = options.context;
          }
          if (options.params) {
            this.params = options.params;
          }
          if (options.priority) {
            this.priority = options.priority;
          }
          if (options.cache) {
            this.cache = options.cache;
          }
          if (options.credentials) {
            this.credentials = options.credentials;
          }
          if (typeof options.timeout === "number") {
            if (options.timeout < 1 || !Number.isInteger(options.timeout)) {
              throw new Error(ngDevMode ? "`timeout` must be a positive integer value" : "");
            }
            this.timeout = options.timeout;
          }
          if (options.mode) {
            this.mode = options.mode;
          }
          if (options.redirect) {
            this.redirect = options.redirect;
          }
          this.transferCache = options.transferCache;
        }
        this.headers ??= new HttpHeaders();
        this.context ??= new HttpContext();
        if (!this.params) {
          this.params = new HttpParams();
          this.urlWithParams = url;
        } else {
          const params = this.params.toString();
          if (params.length === 0) {
            this.urlWithParams = url;
          } else {
            const qIdx = url.indexOf("?");
            const sep = qIdx === -1 ? "?" : qIdx < url.length - 1 ? "&" : "";
            this.urlWithParams = url + sep + params;
          }
        }
      }
      /**
       * Transform the free-form body into a serialized format suitable for
       * transmission to the server.
       */
      serializeBody() {
        if (this.body === null) {
          return null;
        }
        if (typeof this.body === "string" || isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) || isUrlSearchParams(this.body)) {
          return this.body;
        }
        if (this.body instanceof HttpParams) {
          return this.body.toString();
        }
        if (typeof this.body === "object" || typeof this.body === "boolean" || Array.isArray(this.body)) {
          return JSON.stringify(this.body);
        }
        return this.body.toString();
      }
      /**
       * Examine the body and attempt to infer an appropriate MIME type
       * for it.
       *
       * If no such type can be inferred, this method will return `null`.
       */
      detectContentTypeHeader() {
        if (this.body === null) {
          return null;
        }
        if (isFormData(this.body)) {
          return null;
        }
        if (isBlob(this.body)) {
          return this.body.type || null;
        }
        if (isArrayBuffer(this.body)) {
          return null;
        }
        if (typeof this.body === "string") {
          return TEXT_CONTENT_TYPE;
        }
        if (this.body instanceof HttpParams) {
          return "application/x-www-form-urlencoded;charset=UTF-8";
        }
        if (typeof this.body === "object" || typeof this.body === "number" || typeof this.body === "boolean") {
          return JSON_CONTENT_TYPE;
        }
        return null;
      }
      clone(update = {}) {
        const method = update.method || this.method;
        const url = update.url || this.url;
        const responseType = update.responseType || this.responseType;
        const keepalive = update.keepalive ?? this.keepalive;
        const priority = update.priority || this.priority;
        const cache3 = update.cache || this.cache;
        const mode = update.mode || this.mode;
        const redirect = update.redirect || this.redirect;
        const credentials = update.credentials || this.credentials;
        const transferCache = update.transferCache ?? this.transferCache;
        const timeout = update.timeout ?? this.timeout;
        const body = update.body !== void 0 ? update.body : this.body;
        const withCredentials = update.withCredentials ?? this.withCredentials;
        const reportProgress = update.reportProgress ?? this.reportProgress;
        let headers = update.headers || this.headers;
        let params = update.params || this.params;
        const context2 = update.context ?? this.context;
        if (update.setHeaders !== void 0) {
          headers = Object.keys(update.setHeaders).reduce((headers2, name2) => headers2.set(name2, update.setHeaders[name2]), headers);
        }
        if (update.setParams) {
          params = Object.keys(update.setParams).reduce((params2, param) => params2.set(param, update.setParams[param]), params);
        }
        return new _HttpRequest(method, url, body, {
          params,
          headers,
          context: context2,
          reportProgress,
          responseType,
          withCredentials,
          transferCache,
          keepalive,
          cache: cache3,
          priority,
          timeout,
          mode,
          redirect,
          credentials
        });
      }
    };
    (function(HttpEventType2) {
      HttpEventType2[HttpEventType2["Sent"] = 0] = "Sent";
      HttpEventType2[HttpEventType2["UploadProgress"] = 1] = "UploadProgress";
      HttpEventType2[HttpEventType2["ResponseHeader"] = 2] = "ResponseHeader";
      HttpEventType2[HttpEventType2["DownloadProgress"] = 3] = "DownloadProgress";
      HttpEventType2[HttpEventType2["Response"] = 4] = "Response";
      HttpEventType2[HttpEventType2["User"] = 5] = "User";
    })(HttpEventType || (HttpEventType = {}));
    HttpResponseBase = class {
      /**
       * All response headers.
       */
      headers;
      /**
       * Response status code.
       */
      status;
      /**
       * Textual description of response status code, defaults to OK.
       *
       * Do not depend on this.
       */
      statusText;
      /**
       * URL of the resource retrieved, or null if not available.
       */
      url;
      /**
       * Whether the status code falls in the 2xx range.
       */
      ok;
      /**
       * Type of the response, narrowed to either the full response or the header.
       */
      type;
      /**
       * Super-constructor for all responses.
       *
       * The single parameter accepted is an initialization hash. Any properties
       * of the response passed there will override the default values.
       */
      constructor(init, defaultStatus = 200, defaultStatusText = "OK") {
        this.headers = init.headers || new HttpHeaders();
        this.status = init.status !== void 0 ? init.status : defaultStatus;
        this.statusText = init.statusText || defaultStatusText;
        this.url = init.url || null;
        this.ok = this.status >= 200 && this.status < 300;
      }
    };
    HttpHeaderResponse = class _HttpHeaderResponse extends HttpResponseBase {
      /**
       * Create a new `HttpHeaderResponse` with the given parameters.
       */
      constructor(init = {}) {
        super(init);
      }
      type = HttpEventType.ResponseHeader;
      /**
       * Copy this `HttpHeaderResponse`, overriding its contents with the
       * given parameter hash.
       */
      clone(update = {}) {
        return new _HttpHeaderResponse({
          headers: update.headers || this.headers,
          status: update.status !== void 0 ? update.status : this.status,
          statusText: update.statusText || this.statusText,
          url: update.url || this.url || void 0
        });
      }
    };
    HttpResponse = class _HttpResponse extends HttpResponseBase {
      /**
       * The response body, or `null` if one was not returned.
       */
      body;
      /**
       * Construct a new `HttpResponse`.
       */
      constructor(init = {}) {
        super(init);
        this.body = init.body !== void 0 ? init.body : null;
      }
      type = HttpEventType.Response;
      clone(update = {}) {
        return new _HttpResponse({
          body: update.body !== void 0 ? update.body : this.body,
          headers: update.headers || this.headers,
          status: update.status !== void 0 ? update.status : this.status,
          statusText: update.statusText || this.statusText,
          url: update.url || this.url || void 0
        });
      }
    };
    HttpErrorResponse = class extends HttpResponseBase {
      name = "HttpErrorResponse";
      message;
      error;
      /**
       * Errors are never okay, even when the status code is in the 2xx success range.
       */
      ok = false;
      constructor(init) {
        super(init, 0, "Unknown Error");
        if (this.status >= 200 && this.status < 300) {
          this.message = `Http failure during parsing for ${init.url || "(unknown url)"}`;
        } else {
          this.message = `Http failure response for ${init.url || "(unknown url)"}: ${init.status} ${init.statusText}`;
        }
        this.error = init.error || null;
      }
    };
    HTTP_STATUS_CODE_OK = 200;
    HTTP_STATUS_CODE_NO_CONTENT = 204;
    (function(HttpStatusCode2) {
      HttpStatusCode2[HttpStatusCode2["Continue"] = 100] = "Continue";
      HttpStatusCode2[HttpStatusCode2["SwitchingProtocols"] = 101] = "SwitchingProtocols";
      HttpStatusCode2[HttpStatusCode2["Processing"] = 102] = "Processing";
      HttpStatusCode2[HttpStatusCode2["EarlyHints"] = 103] = "EarlyHints";
      HttpStatusCode2[HttpStatusCode2["Ok"] = 200] = "Ok";
      HttpStatusCode2[HttpStatusCode2["Created"] = 201] = "Created";
      HttpStatusCode2[HttpStatusCode2["Accepted"] = 202] = "Accepted";
      HttpStatusCode2[HttpStatusCode2["NonAuthoritativeInformation"] = 203] = "NonAuthoritativeInformation";
      HttpStatusCode2[HttpStatusCode2["NoContent"] = 204] = "NoContent";
      HttpStatusCode2[HttpStatusCode2["ResetContent"] = 205] = "ResetContent";
      HttpStatusCode2[HttpStatusCode2["PartialContent"] = 206] = "PartialContent";
      HttpStatusCode2[HttpStatusCode2["MultiStatus"] = 207] = "MultiStatus";
      HttpStatusCode2[HttpStatusCode2["AlreadyReported"] = 208] = "AlreadyReported";
      HttpStatusCode2[HttpStatusCode2["ImUsed"] = 226] = "ImUsed";
      HttpStatusCode2[HttpStatusCode2["MultipleChoices"] = 300] = "MultipleChoices";
      HttpStatusCode2[HttpStatusCode2["MovedPermanently"] = 301] = "MovedPermanently";
      HttpStatusCode2[HttpStatusCode2["Found"] = 302] = "Found";
      HttpStatusCode2[HttpStatusCode2["SeeOther"] = 303] = "SeeOther";
      HttpStatusCode2[HttpStatusCode2["NotModified"] = 304] = "NotModified";
      HttpStatusCode2[HttpStatusCode2["UseProxy"] = 305] = "UseProxy";
      HttpStatusCode2[HttpStatusCode2["Unused"] = 306] = "Unused";
      HttpStatusCode2[HttpStatusCode2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
      HttpStatusCode2[HttpStatusCode2["PermanentRedirect"] = 308] = "PermanentRedirect";
      HttpStatusCode2[HttpStatusCode2["BadRequest"] = 400] = "BadRequest";
      HttpStatusCode2[HttpStatusCode2["Unauthorized"] = 401] = "Unauthorized";
      HttpStatusCode2[HttpStatusCode2["PaymentRequired"] = 402] = "PaymentRequired";
      HttpStatusCode2[HttpStatusCode2["Forbidden"] = 403] = "Forbidden";
      HttpStatusCode2[HttpStatusCode2["NotFound"] = 404] = "NotFound";
      HttpStatusCode2[HttpStatusCode2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
      HttpStatusCode2[HttpStatusCode2["NotAcceptable"] = 406] = "NotAcceptable";
      HttpStatusCode2[HttpStatusCode2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
      HttpStatusCode2[HttpStatusCode2["RequestTimeout"] = 408] = "RequestTimeout";
      HttpStatusCode2[HttpStatusCode2["Conflict"] = 409] = "Conflict";
      HttpStatusCode2[HttpStatusCode2["Gone"] = 410] = "Gone";
      HttpStatusCode2[HttpStatusCode2["LengthRequired"] = 411] = "LengthRequired";
      HttpStatusCode2[HttpStatusCode2["PreconditionFailed"] = 412] = "PreconditionFailed";
      HttpStatusCode2[HttpStatusCode2["PayloadTooLarge"] = 413] = "PayloadTooLarge";
      HttpStatusCode2[HttpStatusCode2["UriTooLong"] = 414] = "UriTooLong";
      HttpStatusCode2[HttpStatusCode2["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
      HttpStatusCode2[HttpStatusCode2["RangeNotSatisfiable"] = 416] = "RangeNotSatisfiable";
      HttpStatusCode2[HttpStatusCode2["ExpectationFailed"] = 417] = "ExpectationFailed";
      HttpStatusCode2[HttpStatusCode2["ImATeapot"] = 418] = "ImATeapot";
      HttpStatusCode2[HttpStatusCode2["MisdirectedRequest"] = 421] = "MisdirectedRequest";
      HttpStatusCode2[HttpStatusCode2["UnprocessableEntity"] = 422] = "UnprocessableEntity";
      HttpStatusCode2[HttpStatusCode2["Locked"] = 423] = "Locked";
      HttpStatusCode2[HttpStatusCode2["FailedDependency"] = 424] = "FailedDependency";
      HttpStatusCode2[HttpStatusCode2["TooEarly"] = 425] = "TooEarly";
      HttpStatusCode2[HttpStatusCode2["UpgradeRequired"] = 426] = "UpgradeRequired";
      HttpStatusCode2[HttpStatusCode2["PreconditionRequired"] = 428] = "PreconditionRequired";
      HttpStatusCode2[HttpStatusCode2["TooManyRequests"] = 429] = "TooManyRequests";
      HttpStatusCode2[HttpStatusCode2["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
      HttpStatusCode2[HttpStatusCode2["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
      HttpStatusCode2[HttpStatusCode2["InternalServerError"] = 500] = "InternalServerError";
      HttpStatusCode2[HttpStatusCode2["NotImplemented"] = 501] = "NotImplemented";
      HttpStatusCode2[HttpStatusCode2["BadGateway"] = 502] = "BadGateway";
      HttpStatusCode2[HttpStatusCode2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
      HttpStatusCode2[HttpStatusCode2["GatewayTimeout"] = 504] = "GatewayTimeout";
      HttpStatusCode2[HttpStatusCode2["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
      HttpStatusCode2[HttpStatusCode2["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
      HttpStatusCode2[HttpStatusCode2["InsufficientStorage"] = 507] = "InsufficientStorage";
      HttpStatusCode2[HttpStatusCode2["LoopDetected"] = 508] = "LoopDetected";
      HttpStatusCode2[HttpStatusCode2["NotExtended"] = 510] = "NotExtended";
      HttpStatusCode2[HttpStatusCode2["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
    })(HttpStatusCode || (HttpStatusCode = {}));
    HttpClient = class _HttpClient {
      handler;
      constructor(handler) {
        this.handler = handler;
      }
      /**
       * Constructs an observable for a generic HTTP request that, when subscribed,
       * fires the request through the chain of registered interceptors and on to the
       * server.
       *
       * You can pass an `HttpRequest` directly as the only parameter. In this case,
       * the call returns an observable of the raw `HttpEvent` stream.
       *
       * Alternatively you can pass an HTTP method as the first parameter,
       * a URL string as the second, and an options hash containing the request body as the third.
       * See `addBody()`. In this case, the specified `responseType` and `observe` options determine the
       * type of returned observable.
       *   * The `responseType` value determines how a successful response body is parsed.
       *   * If `responseType` is the default `json`, you can pass a type interface for the resulting
       * object as a type parameter to the call.
       *
       * The `observe` value determines the return type, according to what you are interested in
       * observing.
       *   * An `observe` value of events returns an observable of the raw `HttpEvent` stream, including
       * progress events by default.
       *   * An `observe` value of response returns an observable of `HttpResponse<T>`,
       * where the `T` parameter depends on the `responseType` and any optionally provided type
       * parameter.
       *   * An `observe` value of body returns an observable of `<T>` with the same `T` body type.
       *
       */
      request(first2, url, options = {}) {
        let req;
        if (first2 instanceof HttpRequest) {
          req = first2;
        } else {
          let headers = void 0;
          if (options.headers instanceof HttpHeaders) {
            headers = options.headers;
          } else {
            headers = new HttpHeaders(options.headers);
          }
          let params = void 0;
          if (!!options.params) {
            if (options.params instanceof HttpParams) {
              params = options.params;
            } else {
              params = new HttpParams({
                fromObject: options.params
              });
            }
          }
          req = new HttpRequest(first2, url, options.body !== void 0 ? options.body : null, {
            headers,
            context: options.context,
            params,
            reportProgress: options.reportProgress,
            // By default, JSON is assumed to be returned for all calls.
            responseType: options.responseType || "json",
            withCredentials: options.withCredentials,
            transferCache: options.transferCache,
            keepalive: options.keepalive,
            priority: options.priority,
            cache: options.cache,
            mode: options.mode,
            redirect: options.redirect,
            credentials: options.credentials
          });
        }
        const events$ = of(req).pipe(concatMap((req2) => this.handler.handle(req2)));
        if (first2 instanceof HttpRequest || options.observe === "events") {
          return events$;
        }
        const res$ = events$.pipe(filter((event) => event instanceof HttpResponse));
        switch (options.observe || "body") {
          case "body":
            switch (req.responseType) {
              case "arraybuffer":
                return res$.pipe(map((res) => {
                  if (res.body !== null && !(res.body instanceof ArrayBuffer)) {
                    throw new RuntimeError(2806, ngDevMode && "Response is not an ArrayBuffer.");
                  }
                  return res.body;
                }));
              case "blob":
                return res$.pipe(map((res) => {
                  if (res.body !== null && !(res.body instanceof Blob)) {
                    throw new RuntimeError(2807, ngDevMode && "Response is not a Blob.");
                  }
                  return res.body;
                }));
              case "text":
                return res$.pipe(map((res) => {
                  if (res.body !== null && typeof res.body !== "string") {
                    throw new RuntimeError(2808, ngDevMode && "Response is not a string.");
                  }
                  return res.body;
                }));
              case "json":
              default:
                return res$.pipe(map((res) => res.body));
            }
          case "response":
            return res$;
          default:
            throw new RuntimeError(2809, ngDevMode && `Unreachable: unhandled observe type ${options.observe}}`);
        }
      }
      /**
       * Constructs an observable that, when subscribed, causes the configured
       * `DELETE` request to execute on the server. See the individual overloads for
       * details on the return type.
       *
       * @param url     The endpoint URL.
       * @param options The HTTP options to send with the request.
       *
       */
      delete(url, options = {}) {
        return this.request("DELETE", url, options);
      }
      /**
       * Constructs an observable that, when subscribed, causes the configured
       * `GET` request to execute on the server. See the individual overloads for
       * details on the return type.
       */
      get(url, options = {}) {
        return this.request("GET", url, options);
      }
      /**
       * Constructs an observable that, when subscribed, causes the configured
       * `HEAD` request to execute on the server. The `HEAD` method returns
       * meta information about the resource without transferring the
       * resource itself. See the individual overloads for
       * details on the return type.
       */
      head(url, options = {}) {
        return this.request("HEAD", url, options);
      }
      /**
       * Constructs an `Observable` that, when subscribed, causes a request with the special method
       * `JSONP` to be dispatched via the interceptor pipeline.
       * The [JSONP pattern](https://en.wikipedia.org/wiki/JSONP) works around limitations of certain
       * API endpoints that don't support newer,
       * and preferable [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) protocol.
       * JSONP treats the endpoint API as a JavaScript file and tricks the browser to process the
       * requests even if the API endpoint is not located on the same domain (origin) as the client-side
       * application making the request.
       * The endpoint API must support JSONP callback for JSONP requests to work.
       * The resource API returns the JSON response wrapped in a callback function.
       * You can pass the callback function name as one of the query parameters.
       * Note that JSONP requests can only be used with `GET` requests.
       *
       * @param url The resource URL.
       * @param callbackParam The callback function name.
       *
       */
      jsonp(url, callbackParam) {
        return this.request("JSONP", url, {
          params: new HttpParams().append(callbackParam, "JSONP_CALLBACK"),
          observe: "body",
          responseType: "json"
        });
      }
      /**
       * Constructs an `Observable` that, when subscribed, causes the configured
       * `OPTIONS` request to execute on the server. This method allows the client
       * to determine the supported HTTP methods and other capabilities of an endpoint,
       * without implying a resource action. See the individual overloads for
       * details on the return type.
       */
      options(url, options = {}) {
        return this.request("OPTIONS", url, options);
      }
      /**
       * Constructs an observable that, when subscribed, causes the configured
       * `PATCH` request to execute on the server. See the individual overloads for
       * details on the return type.
       */
      patch(url, body, options = {}) {
        return this.request("PATCH", url, addBody(options, body));
      }
      /**
       * Constructs an observable that, when subscribed, causes the configured
       * `POST` request to execute on the server. The server responds with the location of
       * the replaced resource. See the individual overloads for
       * details on the return type.
       */
      post(url, body, options = {}) {
        return this.request("POST", url, addBody(options, body));
      }
      /**
       * Constructs an observable that, when subscribed, causes the configured
       * `PUT` request to execute on the server. The `PUT` method replaces an existing resource
       * with a new set of values.
       * See the individual overloads for details on the return type.
       */
      put(url, body, options = {}) {
        return this.request("PUT", url, addBody(options, body));
      }
      static \u0275fac = function HttpClient_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HttpClient)(\u0275\u0275inject(HttpHandler));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _HttpClient,
        factory: _HttpClient.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClient, [{
        type: Injectable
      }], () => [{
        type: HttpHandler
      }], null);
    })();
    XSSI_PREFIX$1 = /^\)\]\}',?\n/;
    FETCH_BACKEND = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "FETCH_BACKEND" : "");
    FetchBackend = class _FetchBackend {
      // We use an arrow function to always reference the current global implementation of `fetch`.
      // This is helpful for cases when the global `fetch` implementation is modified by external code,
      // see https://github.com/angular/angular/issues/57527.
      fetchImpl = inject2(FetchFactory, {
        optional: true
      })?.fetch ?? ((...args) => globalThis.fetch(...args));
      ngZone = inject2(NgZone);
      destroyRef = inject2(DestroyRef);
      destroyed = false;
      constructor() {
        this.destroyRef.onDestroy(() => {
          this.destroyed = true;
        });
      }
      handle(request) {
        return new Observable((observer) => {
          const aborter = new AbortController();
          this.doRequest(request, aborter.signal, observer).then(noop3, (error) => observer.error(new HttpErrorResponse({
            error
          })));
          let timeoutId;
          if (request.timeout) {
            timeoutId = this.ngZone.runOutsideAngular(() => setTimeout(() => {
              if (!aborter.signal.aborted) {
                aborter.abort(new DOMException("signal timed out", "TimeoutError"));
              }
            }, request.timeout));
          }
          return () => {
            if (timeoutId !== void 0) {
              clearTimeout(timeoutId);
            }
            aborter.abort();
          };
        });
      }
      doRequest(request, signal2, observer) {
        return __async(this, null, function* () {
          const init = this.createRequestInit(request);
          let response;
          try {
            const fetchPromise = this.ngZone.runOutsideAngular(() => this.fetchImpl(request.urlWithParams, __spreadValues({
              signal: signal2
            }, init)));
            silenceSuperfluousUnhandledPromiseRejection(fetchPromise);
            observer.next({
              type: HttpEventType.Sent
            });
            response = yield fetchPromise;
          } catch (error) {
            observer.error(new HttpErrorResponse({
              error,
              status: error.status ?? 0,
              statusText: error.statusText,
              url: request.urlWithParams,
              headers: error.headers
            }));
            return;
          }
          const headers = new HttpHeaders(response.headers);
          const statusText = response.statusText;
          const url = getResponseUrl$1(response) ?? request.urlWithParams;
          let status = response.status;
          let body = null;
          if (request.reportProgress) {
            observer.next(new HttpHeaderResponse({
              headers,
              status,
              statusText,
              url
            }));
          }
          if (response.body) {
            const contentLength = response.headers.get("content-length");
            const chunks = [];
            const reader = response.body.getReader();
            let receivedLength = 0;
            let decoder;
            let partialText;
            const reqZone = typeof Zone !== "undefined" && Zone.current;
            let canceled = false;
            yield this.ngZone.runOutsideAngular(() => __async(this, null, function* () {
              while (true) {
                if (this.destroyed) {
                  yield reader.cancel();
                  canceled = true;
                  break;
                }
                const {
                  done,
                  value
                } = yield reader.read();
                if (done) {
                  break;
                }
                chunks.push(value);
                receivedLength += value.length;
                if (request.reportProgress) {
                  partialText = request.responseType === "text" ? (partialText ?? "") + (decoder ??= new TextDecoder()).decode(value, {
                    stream: true
                  }) : void 0;
                  const reportProgress = () => observer.next({
                    type: HttpEventType.DownloadProgress,
                    total: contentLength ? +contentLength : void 0,
                    loaded: receivedLength,
                    partialText
                  });
                  reqZone ? reqZone.run(reportProgress) : reportProgress();
                }
              }
            }));
            if (canceled) {
              observer.complete();
              return;
            }
            const chunksAll = this.concatChunks(chunks, receivedLength);
            try {
              const contentType = response.headers.get(CONTENT_TYPE_HEADER) ?? "";
              body = this.parseBody(request, chunksAll, contentType, status);
            } catch (error) {
              observer.error(new HttpErrorResponse({
                error,
                headers: new HttpHeaders(response.headers),
                status: response.status,
                statusText: response.statusText,
                url: getResponseUrl$1(response) ?? request.urlWithParams
              }));
              return;
            }
          }
          if (status === 0) {
            status = body ? HTTP_STATUS_CODE_OK : 0;
          }
          const ok = status >= 200 && status < 300;
          if (ok) {
            observer.next(new HttpResponse({
              body,
              headers,
              status,
              statusText,
              url
            }));
            observer.complete();
          } else {
            observer.error(new HttpErrorResponse({
              error: body,
              headers,
              status,
              statusText,
              url
            }));
          }
        });
      }
      parseBody(request, binContent, contentType, status) {
        switch (request.responseType) {
          case "json":
            const text = new TextDecoder().decode(binContent).replace(XSSI_PREFIX$1, "");
            if (text === "") {
              return null;
            }
            try {
              return JSON.parse(text);
            } catch (e) {
              if (status < 200 || status >= 300) {
                return text;
              }
              throw e;
            }
          case "text":
            return new TextDecoder().decode(binContent);
          case "blob":
            return new Blob([binContent], {
              type: contentType
            });
          case "arraybuffer":
            return binContent.buffer;
        }
      }
      createRequestInit(req) {
        const headers = {};
        let credentials;
        credentials = req.credentials;
        if (req.withCredentials) {
          (typeof ngDevMode === "undefined" || ngDevMode) && warningOptionsMessage(req);
          credentials = "include";
        }
        req.headers.forEach((name2, values2) => headers[name2] = values2.join(","));
        if (!req.headers.has(ACCEPT_HEADER)) {
          headers[ACCEPT_HEADER] = ACCEPT_HEADER_VALUE;
        }
        if (!req.headers.has(CONTENT_TYPE_HEADER)) {
          const detectedType = req.detectContentTypeHeader();
          if (detectedType !== null) {
            headers[CONTENT_TYPE_HEADER] = detectedType;
          }
        }
        return {
          body: req.serializeBody(),
          method: req.method,
          headers,
          credentials,
          keepalive: req.keepalive,
          cache: req.cache,
          priority: req.priority,
          mode: req.mode,
          redirect: req.redirect
        };
      }
      concatChunks(chunks, totalLength) {
        const chunksAll = new Uint8Array(totalLength);
        let position = 0;
        for (const chunk of chunks) {
          chunksAll.set(chunk, position);
          position += chunk.length;
        }
        return chunksAll;
      }
      static \u0275fac = function FetchBackend_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _FetchBackend)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _FetchBackend,
        factory: _FetchBackend.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FetchBackend, [{
        type: Injectable
      }], () => [], null);
    })();
    FetchFactory = class {
    };
    HTTP_INTERCEPTORS = new InjectionToken(ngDevMode ? "HTTP_INTERCEPTORS" : "");
    HTTP_INTERCEPTOR_FNS = new InjectionToken(ngDevMode ? "HTTP_INTERCEPTOR_FNS" : "");
    HTTP_ROOT_INTERCEPTOR_FNS = new InjectionToken(ngDevMode ? "HTTP_ROOT_INTERCEPTOR_FNS" : "");
    REQUESTS_CONTRIBUTE_TO_STABILITY = new InjectionToken(ngDevMode ? "REQUESTS_CONTRIBUTE_TO_STABILITY" : "", {
      providedIn: "root",
      factory: () => true
    });
    fetchBackendWarningDisplayed = false;
    HttpInterceptorHandler = class _HttpInterceptorHandler extends HttpHandler {
      backend;
      injector;
      chain = null;
      pendingTasks = inject2(PendingTasks);
      contributeToStability = inject2(REQUESTS_CONTRIBUTE_TO_STABILITY);
      constructor(backend, injector) {
        super();
        this.backend = backend;
        this.injector = injector;
        if ((typeof ngDevMode === "undefined" || ngDevMode) && !fetchBackendWarningDisplayed) {
          const isTestingBackend = this.backend.isTestingBackend;
          if (false) {
            fetchBackendWarningDisplayed = true;
            injector.get(Console).warn(formatRuntimeError(2801, "Angular detected that `HttpClient` is not configured to use `fetch` APIs. It's strongly recommended to enable `fetch` for applications that use Server-Side Rendering for better performance and compatibility. To enable `fetch`, add the `withFetch()` to the `provideHttpClient()` call at the root of the application."));
          }
        }
      }
      handle(initialRequest) {
        if (this.chain === null) {
          const dedupedInterceptorFns = Array.from(/* @__PURE__ */ new Set([...this.injector.get(HTTP_INTERCEPTOR_FNS), ...this.injector.get(HTTP_ROOT_INTERCEPTOR_FNS, [])]));
          this.chain = dedupedInterceptorFns.reduceRight((nextSequencedFn, interceptorFn) => chainedInterceptorFn(nextSequencedFn, interceptorFn, this.injector), interceptorChainEndFn);
        }
        if (this.contributeToStability) {
          const removeTask = this.pendingTasks.add();
          return this.chain(initialRequest, (downstreamRequest) => this.backend.handle(downstreamRequest)).pipe(finalize(removeTask));
        } else {
          return this.chain(initialRequest, (downstreamRequest) => this.backend.handle(downstreamRequest));
        }
      }
      static \u0275fac = function HttpInterceptorHandler_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HttpInterceptorHandler)(\u0275\u0275inject(HttpBackend), \u0275\u0275inject(EnvironmentInjector));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _HttpInterceptorHandler,
        factory: _HttpInterceptorHandler.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpInterceptorHandler, [{
        type: Injectable
      }], () => [{
        type: HttpBackend
      }, {
        type: EnvironmentInjector
      }], null);
    })();
    nextRequestId = 0;
    JSONP_ERR_NO_CALLBACK = "JSONP injected script did not invoke callback.";
    JSONP_ERR_WRONG_METHOD = "JSONP requests must use JSONP request method.";
    JSONP_ERR_WRONG_RESPONSE_TYPE = "JSONP requests must use Json response type.";
    JSONP_ERR_HEADERS_NOT_SUPPORTED = "JSONP requests do not support headers.";
    JsonpCallbackContext = class {
    };
    JsonpClientBackend = class _JsonpClientBackend {
      callbackMap;
      document;
      /**
       * A resolved promise that can be used to schedule microtasks in the event handlers.
       */
      resolvedPromise = Promise.resolve();
      constructor(callbackMap, document2) {
        this.callbackMap = callbackMap;
        this.document = document2;
      }
      /**
       * Get the name of the next callback method, by incrementing the global `nextRequestId`.
       */
      nextCallback() {
        return `ng_jsonp_callback_${nextRequestId++}`;
      }
      /**
       * Processes a JSONP request and returns an event stream of the results.
       * @param req The request object.
       * @returns An observable of the response events.
       *
       */
      handle(req) {
        if (req.method !== "JSONP") {
          throw new RuntimeError(2810, ngDevMode && JSONP_ERR_WRONG_METHOD);
        } else if (req.responseType !== "json") {
          throw new RuntimeError(2811, ngDevMode && JSONP_ERR_WRONG_RESPONSE_TYPE);
        }
        if (req.headers.keys().length > 0) {
          throw new RuntimeError(2812, ngDevMode && JSONP_ERR_HEADERS_NOT_SUPPORTED);
        }
        return new Observable((observer) => {
          const callback = this.nextCallback();
          const url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);
          const node = this.document.createElement("script");
          node.src = url;
          let body = null;
          let finished = false;
          this.callbackMap[callback] = (data2) => {
            delete this.callbackMap[callback];
            body = data2;
            finished = true;
          };
          const cleanup = () => {
            node.removeEventListener("load", onLoad);
            node.removeEventListener("error", onError);
            node.remove();
            delete this.callbackMap[callback];
          };
          const onLoad = () => {
            this.resolvedPromise.then(() => {
              cleanup();
              if (!finished) {
                observer.error(new HttpErrorResponse({
                  url,
                  status: 0,
                  statusText: "JSONP Error",
                  error: new Error(JSONP_ERR_NO_CALLBACK)
                }));
                return;
              }
              observer.next(new HttpResponse({
                body,
                status: HTTP_STATUS_CODE_OK,
                statusText: "OK",
                url
              }));
              observer.complete();
            });
          };
          const onError = (error) => {
            cleanup();
            observer.error(new HttpErrorResponse({
              error,
              status: 0,
              statusText: "JSONP Error",
              url
            }));
          };
          node.addEventListener("load", onLoad);
          node.addEventListener("error", onError);
          this.document.body.appendChild(node);
          observer.next({
            type: HttpEventType.Sent
          });
          return () => {
            if (!finished) {
              this.removeListeners(node);
            }
            cleanup();
          };
        });
      }
      removeListeners(script) {
        foreignDocument ??= this.document.implementation.createHTMLDocument();
        foreignDocument.adoptNode(script);
      }
      static \u0275fac = function JsonpClientBackend_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _JsonpClientBackend)(\u0275\u0275inject(JsonpCallbackContext), \u0275\u0275inject(DOCUMENT));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _JsonpClientBackend,
        factory: _JsonpClientBackend.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonpClientBackend, [{
        type: Injectable
      }], () => [{
        type: JsonpCallbackContext
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DOCUMENT]
        }]
      }], null);
    })();
    JsonpInterceptor = class _JsonpInterceptor {
      injector;
      constructor(injector) {
        this.injector = injector;
      }
      /**
       * Identifies and handles a given JSONP request.
       * @param initialRequest The outgoing request object to handle.
       * @param next The next interceptor in the chain, or the backend
       * if no interceptors remain in the chain.
       * @returns An observable of the event stream.
       */
      intercept(initialRequest, next) {
        return runInInjectionContext(this.injector, () => jsonpInterceptorFn(initialRequest, (downstreamRequest) => next.handle(downstreamRequest)));
      }
      static \u0275fac = function JsonpInterceptor_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _JsonpInterceptor)(\u0275\u0275inject(EnvironmentInjector));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _JsonpInterceptor,
        factory: _JsonpInterceptor.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonpInterceptor, [{
        type: Injectable
      }], () => [{
        type: EnvironmentInjector
      }], null);
    })();
    XSSI_PREFIX = /^\)\]\}',?\n/;
    X_REQUEST_URL_REGEXP = RegExp(`^${X_REQUEST_URL_HEADER}:`, "m");
    HttpXhrBackend = class _HttpXhrBackend {
      xhrFactory;
      constructor(xhrFactory) {
        this.xhrFactory = xhrFactory;
      }
      /**
       * Processes a request and returns a stream of response events.
       * @param req The request object.
       * @returns An observable of the response events.
       */
      handle(req) {
        if (req.method === "JSONP") {
          throw new RuntimeError(-2800, (typeof ngDevMode === "undefined" || ngDevMode) && `Cannot make a JSONP request without JSONP support. To fix the problem, either add the \`withJsonpSupport()\` call (if \`provideHttpClient()\` is used) or import the \`HttpClientJsonpModule\` in the root NgModule.`);
        }
        ngDevMode && validateXhrCompatibility(req);
        const xhrFactory = this.xhrFactory;
        const source = (
          // Note that `loadImpl` is never defined in client bundles and can be
          // safely dropped whenever we're running in the browser.
          // This branching is redundant.
          // The `ngServerMode` guard also enables tree-shaking of the `from()`
          // function from the common bundle, as it's only used in server code.
          false ? from(xhrFactory.\u0275loadImpl()) : of(null)
        );
        return source.pipe(switchMap(() => {
          return new Observable((observer) => {
            const xhr = xhrFactory.build();
            xhr.open(req.method, req.urlWithParams);
            if (req.withCredentials) {
              xhr.withCredentials = true;
            }
            req.headers.forEach((name2, values2) => xhr.setRequestHeader(name2, values2.join(",")));
            if (!req.headers.has(ACCEPT_HEADER)) {
              xhr.setRequestHeader(ACCEPT_HEADER, ACCEPT_HEADER_VALUE);
            }
            if (!req.headers.has(CONTENT_TYPE_HEADER)) {
              const detectedType = req.detectContentTypeHeader();
              if (detectedType !== null) {
                xhr.setRequestHeader(CONTENT_TYPE_HEADER, detectedType);
              }
            }
            if (req.timeout) {
              xhr.timeout = req.timeout;
            }
            if (req.responseType) {
              const responseType = req.responseType.toLowerCase();
              xhr.responseType = responseType !== "json" ? responseType : "text";
            }
            const reqBody = req.serializeBody();
            let headerResponse = null;
            const partialFromXhr = () => {
              if (headerResponse !== null) {
                return headerResponse;
              }
              const statusText = xhr.statusText || "OK";
              const headers = new HttpHeaders(xhr.getAllResponseHeaders());
              const url = getResponseUrl(xhr) || req.url;
              headerResponse = new HttpHeaderResponse({
                headers,
                status: xhr.status,
                statusText,
                url
              });
              return headerResponse;
            };
            const onLoad = () => {
              let {
                headers,
                status,
                statusText,
                url
              } = partialFromXhr();
              let body = null;
              if (status !== HTTP_STATUS_CODE_NO_CONTENT) {
                body = typeof xhr.response === "undefined" ? xhr.responseText : xhr.response;
              }
              if (status === 0) {
                status = !!body ? HTTP_STATUS_CODE_OK : 0;
              }
              let ok = status >= 200 && status < 300;
              if (req.responseType === "json" && typeof body === "string") {
                const originalBody = body;
                body = body.replace(XSSI_PREFIX, "");
                try {
                  body = body !== "" ? JSON.parse(body) : null;
                } catch (error) {
                  body = originalBody;
                  if (ok) {
                    ok = false;
                    body = {
                      error,
                      text: body
                    };
                  }
                }
              }
              if (ok) {
                observer.next(new HttpResponse({
                  body,
                  headers,
                  status,
                  statusText,
                  url: url || void 0
                }));
                observer.complete();
              } else {
                observer.error(new HttpErrorResponse({
                  // The error in this case is the response body (error from the server).
                  error: body,
                  headers,
                  status,
                  statusText,
                  url: url || void 0
                }));
              }
            };
            const onError = (error) => {
              const {
                url
              } = partialFromXhr();
              const res = new HttpErrorResponse({
                error,
                status: xhr.status || 0,
                statusText: xhr.statusText || "Unknown Error",
                url: url || void 0
              });
              observer.error(res);
            };
            let onTimeout = onError;
            if (req.timeout) {
              onTimeout = (_) => {
                const {
                  url
                } = partialFromXhr();
                const res = new HttpErrorResponse({
                  error: new DOMException("Request timed out", "TimeoutError"),
                  status: xhr.status || 0,
                  statusText: xhr.statusText || "Request timeout",
                  url: url || void 0
                });
                observer.error(res);
              };
            }
            let sentHeaders = false;
            const onDownProgress = (event) => {
              if (!sentHeaders) {
                observer.next(partialFromXhr());
                sentHeaders = true;
              }
              let progressEvent = {
                type: HttpEventType.DownloadProgress,
                loaded: event.loaded
              };
              if (event.lengthComputable) {
                progressEvent.total = event.total;
              }
              if (req.responseType === "text" && !!xhr.responseText) {
                progressEvent.partialText = xhr.responseText;
              }
              observer.next(progressEvent);
            };
            const onUpProgress = (event) => {
              let progress = {
                type: HttpEventType.UploadProgress,
                loaded: event.loaded
              };
              if (event.lengthComputable) {
                progress.total = event.total;
              }
              observer.next(progress);
            };
            xhr.addEventListener("load", onLoad);
            xhr.addEventListener("error", onError);
            xhr.addEventListener("timeout", onTimeout);
            xhr.addEventListener("abort", onError);
            if (req.reportProgress) {
              xhr.addEventListener("progress", onDownProgress);
              if (reqBody !== null && xhr.upload) {
                xhr.upload.addEventListener("progress", onUpProgress);
              }
            }
            xhr.send(reqBody);
            observer.next({
              type: HttpEventType.Sent
            });
            return () => {
              xhr.removeEventListener("error", onError);
              xhr.removeEventListener("abort", onError);
              xhr.removeEventListener("load", onLoad);
              xhr.removeEventListener("timeout", onTimeout);
              if (req.reportProgress) {
                xhr.removeEventListener("progress", onDownProgress);
                if (reqBody !== null && xhr.upload) {
                  xhr.upload.removeEventListener("progress", onUpProgress);
                }
              }
              if (xhr.readyState !== xhr.DONE) {
                xhr.abort();
              }
            };
          });
        }));
      }
      static \u0275fac = function HttpXhrBackend_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HttpXhrBackend)(\u0275\u0275inject(XhrFactory));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _HttpXhrBackend,
        factory: _HttpXhrBackend.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpXhrBackend, [{
        type: Injectable
      }], () => [{
        type: XhrFactory
      }], null);
    })();
    XSRF_ENABLED = new InjectionToken(ngDevMode ? "XSRF_ENABLED" : "");
    XSRF_DEFAULT_COOKIE_NAME = "XSRF-TOKEN";
    XSRF_COOKIE_NAME = new InjectionToken(ngDevMode ? "XSRF_COOKIE_NAME" : "", {
      providedIn: "root",
      factory: () => XSRF_DEFAULT_COOKIE_NAME
    });
    XSRF_DEFAULT_HEADER_NAME = "X-XSRF-TOKEN";
    XSRF_HEADER_NAME = new InjectionToken(ngDevMode ? "XSRF_HEADER_NAME" : "", {
      providedIn: "root",
      factory: () => XSRF_DEFAULT_HEADER_NAME
    });
    HttpXsrfTokenExtractor = class {
    };
    HttpXsrfCookieExtractor = class _HttpXsrfCookieExtractor {
      doc;
      cookieName;
      lastCookieString = "";
      lastToken = null;
      /**
       * @internal for testing
       */
      parseCount = 0;
      constructor(doc2, cookieName) {
        this.doc = doc2;
        this.cookieName = cookieName;
      }
      getToken() {
        if (false) {
          return null;
        }
        const cookieString = this.doc.cookie || "";
        if (cookieString !== this.lastCookieString) {
          this.parseCount++;
          this.lastToken = parseCookieValue(cookieString, this.cookieName);
          this.lastCookieString = cookieString;
        }
        return this.lastToken;
      }
      static \u0275fac = function HttpXsrfCookieExtractor_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HttpXsrfCookieExtractor)(\u0275\u0275inject(DOCUMENT), \u0275\u0275inject(XSRF_COOKIE_NAME));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _HttpXsrfCookieExtractor,
        factory: _HttpXsrfCookieExtractor.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpXsrfCookieExtractor, [{
        type: Injectable
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DOCUMENT]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Inject,
          args: [XSRF_COOKIE_NAME]
        }]
      }], null);
    })();
    HttpXsrfInterceptor = class _HttpXsrfInterceptor {
      injector;
      constructor(injector) {
        this.injector = injector;
      }
      intercept(initialRequest, next) {
        return runInInjectionContext(this.injector, () => xsrfInterceptorFn(initialRequest, (downstreamRequest) => next.handle(downstreamRequest)));
      }
      static \u0275fac = function HttpXsrfInterceptor_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HttpXsrfInterceptor)(\u0275\u0275inject(EnvironmentInjector));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _HttpXsrfInterceptor,
        factory: _HttpXsrfInterceptor.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpXsrfInterceptor, [{
        type: Injectable
      }], () => [{
        type: EnvironmentInjector
      }], null);
    })();
    (function(HttpFeatureKind2) {
      HttpFeatureKind2[HttpFeatureKind2["Interceptors"] = 0] = "Interceptors";
      HttpFeatureKind2[HttpFeatureKind2["LegacyInterceptors"] = 1] = "LegacyInterceptors";
      HttpFeatureKind2[HttpFeatureKind2["CustomXsrfConfiguration"] = 2] = "CustomXsrfConfiguration";
      HttpFeatureKind2[HttpFeatureKind2["NoXsrfProtection"] = 3] = "NoXsrfProtection";
      HttpFeatureKind2[HttpFeatureKind2["JsonpSupport"] = 4] = "JsonpSupport";
      HttpFeatureKind2[HttpFeatureKind2["RequestsMadeViaParent"] = 5] = "RequestsMadeViaParent";
      HttpFeatureKind2[HttpFeatureKind2["Fetch"] = 6] = "Fetch";
    })(HttpFeatureKind || (HttpFeatureKind = {}));
    LEGACY_INTERCEPTOR_FN = new InjectionToken(ngDevMode ? "LEGACY_INTERCEPTOR_FN" : "");
    HttpClientXsrfModule = class _HttpClientXsrfModule {
      /**
       * Disable the default XSRF protection.
       */
      static disable() {
        return {
          ngModule: _HttpClientXsrfModule,
          providers: [withNoXsrfProtection().\u0275providers]
        };
      }
      /**
       * Configure XSRF protection.
       * @param options An object that can specify either or both
       * cookie name or header name.
       * - Cookie name default is `XSRF-TOKEN`.
       * - Header name default is `X-XSRF-TOKEN`.
       *
       */
      static withOptions(options = {}) {
        return {
          ngModule: _HttpClientXsrfModule,
          providers: withXsrfConfiguration(options).\u0275providers
        };
      }
      static \u0275fac = function HttpClientXsrfModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HttpClientXsrfModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _HttpClientXsrfModule
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
        providers: [HttpXsrfInterceptor, {
          provide: HTTP_INTERCEPTORS,
          useExisting: HttpXsrfInterceptor,
          multi: true
        }, {
          provide: HttpXsrfTokenExtractor,
          useClass: HttpXsrfCookieExtractor
        }, withXsrfConfiguration({
          cookieName: XSRF_DEFAULT_COOKIE_NAME,
          headerName: XSRF_DEFAULT_HEADER_NAME
        }).\u0275providers, {
          provide: XSRF_ENABLED,
          useValue: true
        }]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClientXsrfModule, [{
        type: NgModule,
        args: [{
          providers: [HttpXsrfInterceptor, {
            provide: HTTP_INTERCEPTORS,
            useExisting: HttpXsrfInterceptor,
            multi: true
          }, {
            provide: HttpXsrfTokenExtractor,
            useClass: HttpXsrfCookieExtractor
          }, withXsrfConfiguration({
            cookieName: XSRF_DEFAULT_COOKIE_NAME,
            headerName: XSRF_DEFAULT_HEADER_NAME
          }).\u0275providers, {
            provide: XSRF_ENABLED,
            useValue: true
          }]
        }]
      }], null, null);
    })();
    HttpClientModule = class _HttpClientModule {
      static \u0275fac = function HttpClientModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HttpClientModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _HttpClientModule
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
        providers: [provideHttpClient(withInterceptorsFromDi())]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClientModule, [{
        type: NgModule,
        args: [{
          /**
           * Configures the dependency injector where it is imported
           * with supporting services for HTTP communications.
           */
          providers: [provideHttpClient(withInterceptorsFromDi())]
        }]
      }], null, null);
    })();
    HttpClientJsonpModule = class _HttpClientJsonpModule {
      static \u0275fac = function HttpClientJsonpModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HttpClientJsonpModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _HttpClientJsonpModule
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
        providers: [withJsonpSupport().\u0275providers]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClientJsonpModule, [{
        type: NgModule,
        args: [{
          providers: [withJsonpSupport().\u0275providers]
        }]
      }], null, null);
    })();
  }
});

// node_modules/@angular/common/fesm2022/http.mjs
function makeHttpResourceFn(responseType) {
  return function httpResource2(request, options) {
    if (ngDevMode && !options?.injector) {
      assertInInjectionContext(httpResource2);
    }
    const injector = options?.injector ?? inject2(Injector);
    return new HttpResourceImpl(injector, () => normalizeRequest(request, responseType), options?.defaultValue, options?.parse, options?.equal);
  };
}
function normalizeRequest(request, responseType) {
  let unwrappedRequest = typeof request === "function" ? request() : request;
  if (unwrappedRequest === void 0) {
    return void 0;
  } else if (typeof unwrappedRequest === "string") {
    unwrappedRequest = { url: unwrappedRequest };
  }
  const headers = unwrappedRequest.headers instanceof HttpHeaders ? unwrappedRequest.headers : new HttpHeaders(unwrappedRequest.headers);
  const params = unwrappedRequest.params instanceof HttpParams ? unwrappedRequest.params : new HttpParams({ fromObject: unwrappedRequest.params });
  return new HttpRequest(unwrappedRequest.method ?? "GET", unwrappedRequest.url, unwrappedRequest.body ?? null, {
    headers,
    params,
    reportProgress: unwrappedRequest.reportProgress,
    withCredentials: unwrappedRequest.withCredentials,
    keepalive: unwrappedRequest.keepalive,
    cache: unwrappedRequest.cache,
    priority: unwrappedRequest.priority,
    mode: unwrappedRequest.mode,
    redirect: unwrappedRequest.redirect,
    responseType,
    context: unwrappedRequest.context,
    transferCache: unwrappedRequest.transferCache,
    credentials: unwrappedRequest.credentials,
    timeout: unwrappedRequest.timeout
  });
}
var httpResource, HttpResourceImpl, HTTP_TRANSFER_CACHE_ORIGIN_MAP, CACHE_OPTIONS;
var init_http = __esm({
  "node_modules/@angular/common/fesm2022/http.mjs"() {
    "use strict";
    init_module();
    init_module();
    init_core();
    httpResource = (() => {
      const jsonFn = makeHttpResourceFn("json");
      jsonFn.arrayBuffer = makeHttpResourceFn("arraybuffer");
      jsonFn.blob = makeHttpResourceFn("blob");
      jsonFn.text = makeHttpResourceFn("text");
      return jsonFn;
    })();
    HttpResourceImpl = class extends ResourceImpl {
      client;
      _headers = linkedSignal({
        source: this.extRequest,
        computation: () => void 0
      });
      _progress = linkedSignal({
        source: this.extRequest,
        computation: () => void 0
      });
      _statusCode = linkedSignal({
        source: this.extRequest,
        computation: () => void 0
      });
      headers = computed(() => this.status() === "resolved" || this.status() === "error" ? this._headers() : void 0, ...ngDevMode ? [{ debugName: "headers" }] : []);
      progress = this._progress.asReadonly();
      statusCode = this._statusCode.asReadonly();
      constructor(injector, request, defaultValue, parse, equal) {
        super(request, ({ params: request2, abortSignal }) => {
          let sub;
          const onAbort = () => sub.unsubscribe();
          abortSignal.addEventListener("abort", onAbort);
          const stream = signal({ value: void 0 }, ...ngDevMode ? [{ debugName: "stream" }] : []);
          let resolve;
          const promise = new Promise((r) => resolve = r);
          const send = (value) => {
            stream.set(value);
            resolve?.(stream);
            resolve = void 0;
          };
          sub = this.client.request(request2).subscribe({
            next: (event) => {
              switch (event.type) {
                case HttpEventType.Response:
                  this._headers.set(event.headers);
                  this._statusCode.set(event.status);
                  try {
                    send({ value: parse ? parse(event.body) : event.body });
                  } catch (error) {
                    send({ error: encapsulateResourceError(error) });
                  }
                  break;
                case HttpEventType.DownloadProgress:
                  this._progress.set(event);
                  break;
              }
            },
            error: (error) => {
              if (error instanceof HttpErrorResponse) {
                this._headers.set(error.headers);
                this._statusCode.set(error.status);
              }
              send({ error });
              abortSignal.removeEventListener("abort", onAbort);
            },
            complete: () => {
              if (resolve) {
                send({
                  error: new RuntimeError(991, ngDevMode && "Resource completed before producing a value")
                });
              }
              abortSignal.removeEventListener("abort", onAbort);
            }
          });
          return promise;
        }, defaultValue, equal, injector);
        this.client = injector.get(HttpClient);
      }
      set(value) {
        super.set(value);
        this._headers.set(void 0);
        this._progress.set(void 0);
        this._statusCode.set(void 0);
      }
    };
    HTTP_TRANSFER_CACHE_ORIGIN_MAP = new InjectionToken(ngDevMode ? "HTTP_TRANSFER_CACHE_ORIGIN_MAP" : "");
    CACHE_OPTIONS = new InjectionToken(ngDevMode ? "HTTP_TRANSFER_STATE_CACHE_OPTIONS" : "");
  }
});

// node_modules/@angular/platform-browser/fesm2022/platform-browser.mjs
var Meta, META_KEYS_MAP, Title, EVENT_NAMES, HAMMER_GESTURE_CONFIG, HAMMER_LOADER, HammerGestureConfig, HammerGesturesPlugin, HammerModule, DomSanitizer, DomSanitizerImpl, HydrationFeatureKind, VERSION3;
var init_platform_browser = __esm({
  "node_modules/@angular/platform-browser/fesm2022/platform-browser.mjs"() {
    "use strict";
    init_browser();
    init_common();
    init_core();
    init_core();
    init_dom_renderer();
    Meta = class _Meta {
      _doc;
      _dom;
      constructor(_doc) {
        this._doc = _doc;
        this._dom = getDOM();
      }
      /**
       * Retrieves or creates a specific `<meta>` tag element in the current HTML document.
       * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute
       * values in the provided tag definition, and verifies that all other attribute values are equal.
       * If an existing element is found, it is returned and is not modified in any way.
       * @param tag The definition of a `<meta>` element to match or create.
       * @param forceCreation True to create a new element without checking whether one already exists.
       * @returns The existing element with the same attributes and values if found,
       * the new element if no match is found, or `null` if the tag parameter is not defined.
       */
      addTag(tag, forceCreation = false) {
        if (!tag) return null;
        return this._getOrCreateElement(tag, forceCreation);
      }
      /**
       * Retrieves or creates a set of `<meta>` tag elements in the current HTML document.
       * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute
       * values in the provided tag definition, and verifies that all other attribute values are equal.
       * @param tags An array of tag definitions to match or create.
       * @param forceCreation True to create new elements without checking whether they already exist.
       * @returns The matching elements if found, or the new elements.
       */
      addTags(tags3, forceCreation = false) {
        if (!tags3) return [];
        return tags3.reduce((result, tag) => {
          if (tag) {
            result.push(this._getOrCreateElement(tag, forceCreation));
          }
          return result;
        }, []);
      }
      /**
       * Retrieves a `<meta>` tag element in the current HTML document.
       * @param attrSelector The tag attribute and value to match against, in the format
       * `"tag_attribute='value string'"`.
       * @returns The matching element, if any.
       */
      getTag(attrSelector) {
        if (!attrSelector) return null;
        return this._doc.querySelector(`meta[${attrSelector}]`) || null;
      }
      /**
       * Retrieves a set of `<meta>` tag elements in the current HTML document.
       * @param attrSelector The tag attribute and value to match against, in the format
       * `"tag_attribute='value string'"`.
       * @returns The matching elements, if any.
       */
      getTags(attrSelector) {
        if (!attrSelector) return [];
        const list = this._doc.querySelectorAll(`meta[${attrSelector}]`);
        return list ? [].slice.call(list) : [];
      }
      /**
       * Modifies an existing `<meta>` tag element in the current HTML document.
       * @param tag The tag description with which to replace the existing tag content.
       * @param selector A tag attribute and value to match against, to identify
       * an existing tag. A string in the format `"tag_attribute=`value string`"`.
       * If not supplied, matches a tag with the same `name` or `property` attribute value as the
       * replacement tag.
       * @return The modified element.
       */
      updateTag(tag, selector) {
        if (!tag) return null;
        selector = selector || this._parseSelector(tag);
        const meta2 = this.getTag(selector);
        if (meta2) {
          return this._setMetaElementAttributes(tag, meta2);
        }
        return this._getOrCreateElement(tag, true);
      }
      /**
       * Removes an existing `<meta>` tag element from the current HTML document.
       * @param attrSelector A tag attribute and value to match against, to identify
       * an existing tag. A string in the format `"tag_attribute=`value string`"`.
       */
      removeTag(attrSelector) {
        this.removeTagElement(this.getTag(attrSelector));
      }
      /**
       * Removes an existing `<meta>` tag element from the current HTML document.
       * @param meta The tag definition to match against to identify an existing tag.
       */
      removeTagElement(meta2) {
        if (meta2) {
          this._dom.remove(meta2);
        }
      }
      _getOrCreateElement(meta2, forceCreation = false) {
        if (!forceCreation) {
          const selector = this._parseSelector(meta2);
          const elem = this.getTags(selector).filter((elem2) => this._containsAttributes(meta2, elem2))[0];
          if (elem !== void 0) return elem;
        }
        const element = this._dom.createElement("meta");
        this._setMetaElementAttributes(meta2, element);
        const head = this._doc.getElementsByTagName("head")[0];
        head.appendChild(element);
        return element;
      }
      _setMetaElementAttributes(tag, el) {
        Object.keys(tag).forEach((prop) => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));
        return el;
      }
      _parseSelector(tag) {
        const attr = tag.name ? "name" : "property";
        return `${attr}="${tag[attr]}"`;
      }
      _containsAttributes(tag, elem) {
        return Object.keys(tag).every((key) => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);
      }
      _getMetaKeyMap(prop) {
        return META_KEYS_MAP[prop] || prop;
      }
      static \u0275fac = function Meta_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Meta)(\u0275\u0275inject(DOCUMENT));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _Meta,
        factory: _Meta.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Meta, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DOCUMENT]
        }]
      }], null);
    })();
    META_KEYS_MAP = {
      httpEquiv: "http-equiv"
    };
    Title = class _Title {
      _doc;
      constructor(_doc) {
        this._doc = _doc;
      }
      /**
       * Get the title of the current HTML document.
       */
      getTitle() {
        return this._doc.title;
      }
      /**
       * Set the title of the current HTML document.
       * @param newTitle
       */
      setTitle(newTitle) {
        this._doc.title = newTitle || "";
      }
      static \u0275fac = function Title_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Title)(\u0275\u0275inject(DOCUMENT));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _Title,
        factory: _Title.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Title, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DOCUMENT]
        }]
      }], null);
    })();
    EVENT_NAMES = {
      // pan
      "pan": true,
      "panstart": true,
      "panmove": true,
      "panend": true,
      "pancancel": true,
      "panleft": true,
      "panright": true,
      "panup": true,
      "pandown": true,
      // pinch
      "pinch": true,
      "pinchstart": true,
      "pinchmove": true,
      "pinchend": true,
      "pinchcancel": true,
      "pinchin": true,
      "pinchout": true,
      // press
      "press": true,
      "pressup": true,
      // rotate
      "rotate": true,
      "rotatestart": true,
      "rotatemove": true,
      "rotateend": true,
      "rotatecancel": true,
      // swipe
      "swipe": true,
      "swipeleft": true,
      "swiperight": true,
      "swipeup": true,
      "swipedown": true,
      // tap
      "tap": true,
      "doubletap": true
    };
    HAMMER_GESTURE_CONFIG = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "HammerGestureConfig" : "");
    HAMMER_LOADER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "HammerLoader" : "");
    HammerGestureConfig = class _HammerGestureConfig {
      /**
       * A set of supported event names for gestures to be used in Angular.
       * Angular supports all built-in recognizers, as listed in
       * [HammerJS documentation](https://hammerjs.github.io/).
       */
      events = [];
      /**
       * Maps gesture event names to a set of configuration options
       * that specify overrides to the default values for specific properties.
       *
       * The key is a supported event name to be configured,
       * and the options object contains a set of properties, with override values
       * to be applied to the named recognizer event.
       * For example, to disable recognition of the rotate event, specify
       *  `{"rotate": {"enable": false}}`.
       *
       * Properties that are not present take the HammerJS default values.
       * For information about which properties are supported for which events,
       * and their allowed and default values, see
       * [HammerJS documentation](https://hammerjs.github.io/).
       *
       */
      overrides = {};
      /**
       * Properties whose default values can be overridden for a given event.
       * Different sets of properties apply to different events.
       * For information about which properties are supported for which events,
       * and their allowed and default values, see
       * [HammerJS documentation](https://hammerjs.github.io/).
       */
      options;
      /**
       * Creates a [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)
       * and attaches it to a given HTML element.
       * @param element The element that will recognize gestures.
       * @returns A HammerJS event-manager object.
       */
      buildHammer(element) {
        const mc = new Hammer(element, this.options);
        mc.get("pinch").set({
          enable: true
        });
        mc.get("rotate").set({
          enable: true
        });
        for (const eventName in this.overrides) {
          mc.get(eventName).set(this.overrides[eventName]);
        }
        return mc;
      }
      static \u0275fac = function HammerGestureConfig_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HammerGestureConfig)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _HammerGestureConfig,
        factory: _HammerGestureConfig.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerGestureConfig, [{
        type: Injectable
      }], null, null);
    })();
    HammerGesturesPlugin = class _HammerGesturesPlugin extends EventManagerPlugin {
      _config;
      _injector;
      loader;
      _loaderPromise = null;
      constructor(doc2, _config, _injector, loader) {
        super(doc2);
        this._config = _config;
        this._injector = _injector;
        this.loader = loader;
      }
      supports(eventName) {
        if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
          return false;
        }
        if (!window.Hammer && !this.loader) {
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            const _console = this._injector.get(Console);
            _console.warn(`The "${eventName}" event cannot be bound because Hammer.JS is not loaded and no custom loader has been specified.`);
          }
          return false;
        }
        return true;
      }
      addEventListener(element, eventName, handler) {
        const zone = this.manager.getZone();
        eventName = eventName.toLowerCase();
        if (!window.Hammer && this.loader) {
          this._loaderPromise = this._loaderPromise || zone.runOutsideAngular(() => this.loader());
          let cancelRegistration = false;
          let deregister = () => {
            cancelRegistration = true;
          };
          zone.runOutsideAngular(() => this._loaderPromise.then(() => {
            if (!window.Hammer) {
              if (typeof ngDevMode === "undefined" || ngDevMode) {
                const _console = this._injector.get(Console);
                _console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);
              }
              deregister = () => {
              };
              return;
            }
            if (!cancelRegistration) {
              deregister = this.addEventListener(element, eventName, handler);
            }
          }).catch(() => {
            if (typeof ngDevMode === "undefined" || ngDevMode) {
              const _console = this._injector.get(Console);
              _console.warn(`The "${eventName}" event cannot be bound because the custom Hammer.JS loader failed.`);
            }
            deregister = () => {
            };
          }));
          return () => {
            deregister();
          };
        }
        return zone.runOutsideAngular(() => {
          const mc = this._config.buildHammer(element);
          const callback = function(eventObj) {
            zone.runGuarded(function() {
              handler(eventObj);
            });
          };
          mc.on(eventName, callback);
          return () => {
            mc.off(eventName, callback);
            if (typeof mc.destroy === "function") {
              mc.destroy();
            }
          };
        });
      }
      isCustomEvent(eventName) {
        return this._config.events.indexOf(eventName) > -1;
      }
      static \u0275fac = function HammerGesturesPlugin_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HammerGesturesPlugin)(\u0275\u0275inject(DOCUMENT), \u0275\u0275inject(HAMMER_GESTURE_CONFIG), \u0275\u0275inject(Injector), \u0275\u0275inject(HAMMER_LOADER, 8));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _HammerGesturesPlugin,
        factory: _HammerGesturesPlugin.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerGesturesPlugin, [{
        type: Injectable
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DOCUMENT]
        }]
      }, {
        type: HammerGestureConfig,
        decorators: [{
          type: Inject,
          args: [HAMMER_GESTURE_CONFIG]
        }]
      }, {
        type: Injector
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [HAMMER_LOADER]
        }]
      }], null);
    })();
    HammerModule = class _HammerModule {
      static \u0275fac = function HammerModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _HammerModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _HammerModule
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
        providers: [{
          provide: EVENT_MANAGER_PLUGINS,
          useClass: HammerGesturesPlugin,
          multi: true,
          deps: [DOCUMENT, HAMMER_GESTURE_CONFIG, Injector, [new Optional(), HAMMER_LOADER]]
        }, {
          provide: HAMMER_GESTURE_CONFIG,
          useClass: HammerGestureConfig
        }]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerModule, [{
        type: NgModule,
        args: [{
          providers: [{
            provide: EVENT_MANAGER_PLUGINS,
            useClass: HammerGesturesPlugin,
            multi: true,
            deps: [DOCUMENT, HAMMER_GESTURE_CONFIG, Injector, [new Optional(), HAMMER_LOADER]]
          }, {
            provide: HAMMER_GESTURE_CONFIG,
            useClass: HammerGestureConfig
          }]
        }]
      }], null, null);
    })();
    DomSanitizer = class _DomSanitizer {
      static \u0275fac = function DomSanitizer_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DomSanitizer)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _DomSanitizer,
        factory: function DomSanitizer_Factory(__ngFactoryType__) {
          let __ngConditionalFactory__ = null;
          if (__ngFactoryType__) {
            __ngConditionalFactory__ = new (__ngFactoryType__ || _DomSanitizer)();
          } else {
            __ngConditionalFactory__ = \u0275\u0275inject(DomSanitizerImpl);
          }
          return __ngConditionalFactory__;
        },
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomSanitizer, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useExisting: forwardRef(() => DomSanitizerImpl)
        }]
      }], null, null);
    })();
    DomSanitizerImpl = class _DomSanitizerImpl extends DomSanitizer {
      _doc;
      constructor(_doc) {
        super();
        this._doc = _doc;
      }
      sanitize(ctx, value) {
        if (value == null) return null;
        switch (ctx) {
          case SecurityContext.NONE:
            return value;
          case SecurityContext.HTML:
            if (allowSanitizationBypassAndThrow(
              value,
              "HTML"
              /* BypassType.Html */
            )) {
              return unwrapSafeValue(value);
            }
            return _sanitizeHtml(this._doc, String(value)).toString();
          case SecurityContext.STYLE:
            if (allowSanitizationBypassAndThrow(
              value,
              "Style"
              /* BypassType.Style */
            )) {
              return unwrapSafeValue(value);
            }
            return value;
          case SecurityContext.SCRIPT:
            if (allowSanitizationBypassAndThrow(
              value,
              "Script"
              /* BypassType.Script */
            )) {
              return unwrapSafeValue(value);
            }
            throw new RuntimeError(5200, (typeof ngDevMode === "undefined" || ngDevMode) && "unsafe value used in a script context");
          case SecurityContext.URL:
            if (allowSanitizationBypassAndThrow(
              value,
              "URL"
              /* BypassType.Url */
            )) {
              return unwrapSafeValue(value);
            }
            return _sanitizeUrl(String(value));
          case SecurityContext.RESOURCE_URL:
            if (allowSanitizationBypassAndThrow(
              value,
              "ResourceURL"
              /* BypassType.ResourceUrl */
            )) {
              return unwrapSafeValue(value);
            }
            throw new RuntimeError(5201, (typeof ngDevMode === "undefined" || ngDevMode) && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);
          default:
            throw new RuntimeError(5202, (typeof ngDevMode === "undefined" || ngDevMode) && `Unexpected SecurityContext ${ctx} (see ${XSS_SECURITY_URL})`);
        }
      }
      bypassSecurityTrustHtml(value) {
        return bypassSanitizationTrustHtml(value);
      }
      bypassSecurityTrustStyle(value) {
        return bypassSanitizationTrustStyle(value);
      }
      bypassSecurityTrustScript(value) {
        return bypassSanitizationTrustScript(value);
      }
      bypassSecurityTrustUrl(value) {
        return bypassSanitizationTrustUrl(value);
      }
      bypassSecurityTrustResourceUrl(value) {
        return bypassSanitizationTrustResourceUrl(value);
      }
      static \u0275fac = function DomSanitizerImpl_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DomSanitizerImpl)(\u0275\u0275inject(DOCUMENT));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _DomSanitizerImpl,
        factory: _DomSanitizerImpl.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomSanitizerImpl, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Inject,
          args: [DOCUMENT]
        }]
      }], null);
    })();
    (function(HydrationFeatureKind2) {
      HydrationFeatureKind2[HydrationFeatureKind2["NoHttpTransferCache"] = 0] = "NoHttpTransferCache";
      HydrationFeatureKind2[HydrationFeatureKind2["HttpTransferCacheOptions"] = 1] = "HttpTransferCacheOptions";
      HydrationFeatureKind2[HydrationFeatureKind2["I18nSupport"] = 2] = "I18nSupport";
      HydrationFeatureKind2[HydrationFeatureKind2["EventReplay"] = 3] = "EventReplay";
      HydrationFeatureKind2[HydrationFeatureKind2["IncrementalHydration"] = 4] = "IncrementalHydration";
    })(HydrationFeatureKind || (HydrationFeatureKind = {}));
    VERSION3 = new Version("20.1.7");
  }
});

// node_modules/@angular/router/fesm2022/router2.mjs
function convertToParamMap(params) {
  return new ParamsAsMap(params);
}
function defaultUrlMatcher(segments, segmentGroup, route) {
  const parts = route.path.split("/");
  if (parts.length > segments.length) {
    return null;
  }
  if (route.pathMatch === "full" && (segmentGroup.hasChildren() || parts.length < segments.length)) {
    return null;
  }
  const posParams = {};
  for (let index = 0; index < parts.length; index++) {
    const part = parts[index];
    const segment = segments[index];
    const isParameter = part[0] === ":";
    if (isParameter) {
      posParams[part.substring(1)] = segment;
    } else if (part !== segment.path) {
      return null;
    }
  }
  return {
    consumed: segments.slice(0, parts.length),
    posParams
  };
}
function shallowEqualArrays(a, b) {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; ++i) {
    if (!shallowEqual(a[i], b[i])) return false;
  }
  return true;
}
function shallowEqual(a, b) {
  const k1 = a ? getDataKeys(a) : void 0;
  const k2 = b ? getDataKeys(b) : void 0;
  if (!k1 || !k2 || k1.length != k2.length) {
    return false;
  }
  let key;
  for (let i = 0; i < k1.length; i++) {
    key = k1[i];
    if (!equalArraysOrString(a[key], b[key])) {
      return false;
    }
  }
  return true;
}
function getDataKeys(obj) {
  return [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];
}
function equalArraysOrString(a, b) {
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    const aSorted = [...a].sort();
    const bSorted = [...b].sort();
    return aSorted.every((val, index) => bSorted[index] === val);
  } else {
    return a === b;
  }
}
function last3(a) {
  return a.length > 0 ? a[a.length - 1] : null;
}
function wrapIntoObservable(value) {
  if (isObservable(value)) {
    return value;
  }
  if (isPromise2(value)) {
    return from(Promise.resolve(value));
  }
  return of(value);
}
function containsTree(container, containee, options) {
  return pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) && paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) && !(options.fragment === "exact" && container.fragment !== containee.fragment);
}
function equalParams(container, containee) {
  return shallowEqual(container, containee);
}
function equalSegmentGroups(container, containee, matrixParams) {
  if (!equalPath(container.segments, containee.segments)) return false;
  if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {
    return false;
  }
  if (container.numberOfChildren !== containee.numberOfChildren) return false;
  for (const c in containee.children) {
    if (!container.children[c]) return false;
    if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams)) return false;
  }
  return true;
}
function containsParams(container, containee) {
  return Object.keys(containee).length <= Object.keys(container).length && Object.keys(containee).every((key) => equalArraysOrString(container[key], containee[key]));
}
function containsSegmentGroup(container, containee, matrixParams) {
  return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);
}
function containsSegmentGroupHelper(container, containee, containeePaths, matrixParams) {
  if (container.segments.length > containeePaths.length) {
    const current = container.segments.slice(0, containeePaths.length);
    if (!equalPath(current, containeePaths)) return false;
    if (containee.hasChildren()) return false;
    if (!matrixParamsMatch(current, containeePaths, matrixParams)) return false;
    return true;
  } else if (container.segments.length === containeePaths.length) {
    if (!equalPath(container.segments, containeePaths)) return false;
    if (!matrixParamsMatch(container.segments, containeePaths, matrixParams)) return false;
    for (const c in containee.children) {
      if (!container.children[c]) return false;
      if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {
        return false;
      }
    }
    return true;
  } else {
    const current = containeePaths.slice(0, container.segments.length);
    const next = containeePaths.slice(container.segments.length);
    if (!equalPath(container.segments, current)) return false;
    if (!matrixParamsMatch(container.segments, current, matrixParams)) return false;
    if (!container.children[PRIMARY_OUTLET]) return false;
    return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next, matrixParams);
  }
}
function matrixParamsMatch(containerPaths, containeePaths, options) {
  return containeePaths.every((containeeSegment, i) => {
    return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);
  });
}
function equalSegments(as, bs) {
  return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));
}
function equalPath(as, bs) {
  if (as.length !== bs.length) return false;
  return as.every((a, i) => a.path === bs[i].path);
}
function mapChildrenIntoArray(segment, fn) {
  let res = [];
  Object.entries(segment.children).forEach(([childOutlet, child]) => {
    if (childOutlet === PRIMARY_OUTLET) {
      res = res.concat(fn(child, childOutlet));
    }
  });
  Object.entries(segment.children).forEach(([childOutlet, child]) => {
    if (childOutlet !== PRIMARY_OUTLET) {
      res = res.concat(fn(child, childOutlet));
    }
  });
  return res;
}
function serializePaths(segment) {
  return segment.segments.map((p) => serializePath(p)).join("/");
}
function serializeSegment(segment, root) {
  if (!segment.hasChildren()) {
    return serializePaths(segment);
  }
  if (root) {
    const primary = segment.children[PRIMARY_OUTLET] ? serializeSegment(segment.children[PRIMARY_OUTLET], false) : "";
    const children = [];
    Object.entries(segment.children).forEach(([k, v]) => {
      if (k !== PRIMARY_OUTLET) {
        children.push(`${k}:${serializeSegment(v, false)}`);
      }
    });
    return children.length > 0 ? `${primary}(${children.join("//")})` : primary;
  } else {
    const children = mapChildrenIntoArray(segment, (v, k) => {
      if (k === PRIMARY_OUTLET) {
        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];
      }
      return [`${k}:${serializeSegment(v, false)}`];
    });
    if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {
      return `${serializePaths(segment)}/${children[0]}`;
    }
    return `${serializePaths(segment)}/(${children.join("//")})`;
  }
}
function encodeUriString(s) {
  return encodeURIComponent(s).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",");
}
function encodeUriQuery(s) {
  return encodeUriString(s).replace(/%3B/gi, ";");
}
function encodeUriFragment(s) {
  return encodeURI(s);
}
function encodeUriSegment(s) {
  return encodeUriString(s).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&");
}
function decode(s) {
  return decodeURIComponent(s);
}
function decodeQuery(s) {
  return decode(s.replace(/\+/g, "%20"));
}
function serializePath(path) {
  return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;
}
function serializeMatrixParams(params) {
  return Object.entries(params).map(([key, value]) => `;${encodeUriSegment(key)}=${encodeUriSegment(value)}`).join("");
}
function serializeQueryParams(params) {
  const strParams = Object.entries(params).map(([name2, value]) => {
    return Array.isArray(value) ? value.map((v) => `${encodeUriQuery(name2)}=${encodeUriQuery(v)}`).join("&") : `${encodeUriQuery(name2)}=${encodeUriQuery(value)}`;
  }).filter((s) => s);
  return strParams.length ? `?${strParams.join("&")}` : "";
}
function matchSegments(str) {
  const match2 = str.match(SEGMENT_RE);
  return match2 ? match2[0] : "";
}
function matchMatrixKeySegments(str) {
  const match2 = str.match(MATRIX_PARAM_SEGMENT_RE);
  return match2 ? match2[0] : "";
}
function matchQueryParams(str) {
  const match2 = str.match(QUERY_PARAM_RE);
  return match2 ? match2[0] : "";
}
function matchUrlQueryParamValue(str) {
  const match2 = str.match(QUERY_PARAM_VALUE_RE);
  return match2 ? match2[0] : "";
}
function createRoot(rootCandidate) {
  return rootCandidate.segments.length > 0 ? new UrlSegmentGroup([], {
    [PRIMARY_OUTLET]: rootCandidate
  }) : rootCandidate;
}
function squashSegmentGroup(segmentGroup) {
  const newChildren = {};
  for (const [childOutlet, child] of Object.entries(segmentGroup.children)) {
    const childCandidate = squashSegmentGroup(child);
    if (childOutlet === PRIMARY_OUTLET && childCandidate.segments.length === 0 && childCandidate.hasChildren()) {
      for (const [grandChildOutlet, grandChild] of Object.entries(childCandidate.children)) {
        newChildren[grandChildOutlet] = grandChild;
      }
    } else if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {
      newChildren[childOutlet] = childCandidate;
    }
  }
  const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);
  return mergeTrivialChildren(s);
}
function mergeTrivialChildren(s) {
  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {
    const c = s.children[PRIMARY_OUTLET];
    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);
  }
  return s;
}
function isUrlTree(v) {
  return v instanceof UrlTree;
}
function createUrlTreeFromSnapshot(relativeTo, commands, queryParams = null, fragment = null) {
  const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);
  return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment);
}
function createSegmentGroupFromRoute(route) {
  let targetGroup;
  function createSegmentGroupFromRouteRecursive(currentRoute) {
    const childOutlets = {};
    for (const childSnapshot of currentRoute.children) {
      const root = createSegmentGroupFromRouteRecursive(childSnapshot);
      childOutlets[childSnapshot.outlet] = root;
    }
    const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);
    if (currentRoute === route) {
      targetGroup = segmentGroup;
    }
    return segmentGroup;
  }
  const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);
  const rootSegmentGroup = createRoot(rootCandidate);
  return targetGroup ?? rootSegmentGroup;
}
function createUrlTreeFromSegmentGroup(relativeTo, commands, queryParams, fragment) {
  let root = relativeTo;
  while (root.parent) {
    root = root.parent;
  }
  if (commands.length === 0) {
    return tree(root, root, root, queryParams, fragment);
  }
  const nav2 = computeNavigation(commands);
  if (nav2.toRoot()) {
    return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment);
  }
  const position = findStartingPositionForTargetGroup(nav2, root, relativeTo);
  const newSegmentGroup = position.processChildren ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav2.commands) : updateSegmentGroup(position.segmentGroup, position.index, nav2.commands);
  return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment);
}
function isMatrixParams(command2) {
  return typeof command2 === "object" && command2 != null && !command2.outlets && !command2.segmentPath;
}
function isCommandWithOutlets(command2) {
  return typeof command2 === "object" && command2 != null && command2.outlets;
}
function tree(oldRoot, oldSegmentGroup, newSegmentGroup, queryParams, fragment) {
  let qp = {};
  if (queryParams) {
    Object.entries(queryParams).forEach(([name2, value]) => {
      qp[name2] = Array.isArray(value) ? value.map((v) => `${v}`) : `${value}`;
    });
  }
  let rootCandidate;
  if (oldRoot === oldSegmentGroup) {
    rootCandidate = newSegmentGroup;
  } else {
    rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);
  }
  const newRoot = createRoot(squashSegmentGroup(rootCandidate));
  return new UrlTree(newRoot, qp, fragment);
}
function replaceSegment(current, oldSegment, newSegment) {
  const children = {};
  Object.entries(current.children).forEach(([outletName, c]) => {
    if (c === oldSegment) {
      children[outletName] = newSegment;
    } else {
      children[outletName] = replaceSegment(c, oldSegment, newSegment);
    }
  });
  return new UrlSegmentGroup(current.segments, children);
}
function computeNavigation(commands) {
  if (typeof commands[0] === "string" && commands.length === 1 && commands[0] === "/") {
    return new Navigation(true, 0, commands);
  }
  let numberOfDoubleDots = 0;
  let isAbsolute = false;
  const res = commands.reduce((res2, cmd2, cmdIdx) => {
    if (typeof cmd2 === "object" && cmd2 != null) {
      if (cmd2.outlets) {
        const outlets = {};
        Object.entries(cmd2.outlets).forEach(([name2, commands2]) => {
          outlets[name2] = typeof commands2 === "string" ? commands2.split("/") : commands2;
        });
        return [...res2, {
          outlets
        }];
      }
      if (cmd2.segmentPath) {
        return [...res2, cmd2.segmentPath];
      }
    }
    if (!(typeof cmd2 === "string")) {
      return [...res2, cmd2];
    }
    if (cmdIdx === 0) {
      cmd2.split("/").forEach((urlPart, partIndex) => {
        if (partIndex == 0 && urlPart === ".") ;
        else if (partIndex == 0 && urlPart === "") {
          isAbsolute = true;
        } else if (urlPart === "..") {
          numberOfDoubleDots++;
        } else if (urlPart != "") {
          res2.push(urlPart);
        }
      });
      return res2;
    }
    return [...res2, cmd2];
  }, []);
  return new Navigation(isAbsolute, numberOfDoubleDots, res);
}
function findStartingPositionForTargetGroup(nav2, root, target) {
  if (nav2.isAbsolute) {
    return new Position(root, true, 0);
  }
  if (!target) {
    return new Position(root, false, NaN);
  }
  if (target.parent === null) {
    return new Position(target, true, 0);
  }
  const modifier = isMatrixParams(nav2.commands[0]) ? 0 : 1;
  const index = target.segments.length - 1 + modifier;
  return createPositionApplyingDoubleDots(target, index, nav2.numberOfDoubleDots);
}
function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {
  let g = group;
  let ci = index;
  let dd = numberOfDoubleDots;
  while (dd > ci) {
    dd -= ci;
    g = g.parent;
    if (!g) {
      throw new RuntimeError(4005, (typeof ngDevMode === "undefined" || ngDevMode) && "Invalid number of '../'");
    }
    ci = g.segments.length;
  }
  return new Position(g, false, ci - dd);
}
function getOutlets(commands) {
  if (isCommandWithOutlets(commands[0])) {
    return commands[0].outlets;
  }
  return {
    [PRIMARY_OUTLET]: commands
  };
}
function updateSegmentGroup(segmentGroup, startIndex, commands) {
  segmentGroup ??= new UrlSegmentGroup([], {});
  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);
  }
  const m = prefixedWith(segmentGroup, startIndex, commands);
  const slicedCommands = commands.slice(m.commandIndex);
  if (m.match && m.pathIndex < segmentGroup.segments.length) {
    const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});
    g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);
    return updateSegmentGroupChildren(g, 0, slicedCommands);
  } else if (m.match && slicedCommands.length === 0) {
    return new UrlSegmentGroup(segmentGroup.segments, {});
  } else if (m.match && !segmentGroup.hasChildren()) {
    return createNewSegmentGroup(segmentGroup, startIndex, commands);
  } else if (m.match) {
    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);
  } else {
    return createNewSegmentGroup(segmentGroup, startIndex, commands);
  }
}
function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {
  if (commands.length === 0) {
    return new UrlSegmentGroup(segmentGroup.segments, {});
  } else {
    const outlets = getOutlets(commands);
    const children = {};
    if (Object.keys(outlets).some((o) => o !== PRIMARY_OUTLET) && segmentGroup.children[PRIMARY_OUTLET] && segmentGroup.numberOfChildren === 1 && segmentGroup.children[PRIMARY_OUTLET].segments.length === 0) {
      const childrenOfEmptyChild = updateSegmentGroupChildren(segmentGroup.children[PRIMARY_OUTLET], startIndex, commands);
      return new UrlSegmentGroup(segmentGroup.segments, childrenOfEmptyChild.children);
    }
    Object.entries(outlets).forEach(([outlet, commands2]) => {
      if (typeof commands2 === "string") {
        commands2 = [commands2];
      }
      if (commands2 !== null) {
        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands2);
      }
    });
    Object.entries(segmentGroup.children).forEach(([childOutlet, child]) => {
      if (outlets[childOutlet] === void 0) {
        children[childOutlet] = child;
      }
    });
    return new UrlSegmentGroup(segmentGroup.segments, children);
  }
}
function prefixedWith(segmentGroup, startIndex, commands) {
  let currentCommandIndex = 0;
  let currentPathIndex = startIndex;
  const noMatch2 = {
    match: false,
    pathIndex: 0,
    commandIndex: 0
  };
  while (currentPathIndex < segmentGroup.segments.length) {
    if (currentCommandIndex >= commands.length) return noMatch2;
    const path = segmentGroup.segments[currentPathIndex];
    const command2 = commands[currentCommandIndex];
    if (isCommandWithOutlets(command2)) {
      break;
    }
    const curr = `${command2}`;
    const next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;
    if (currentPathIndex > 0 && curr === void 0) break;
    if (curr && next && typeof next === "object" && next.outlets === void 0) {
      if (!compare(curr, next, path)) return noMatch2;
      currentCommandIndex += 2;
    } else {
      if (!compare(curr, {}, path)) return noMatch2;
      currentCommandIndex++;
    }
    currentPathIndex++;
  }
  return {
    match: true,
    pathIndex: currentPathIndex,
    commandIndex: currentCommandIndex
  };
}
function createNewSegmentGroup(segmentGroup, startIndex, commands) {
  const paths = segmentGroup.segments.slice(0, startIndex);
  let i = 0;
  while (i < commands.length) {
    const command2 = commands[i];
    if (isCommandWithOutlets(command2)) {
      const children = createNewSegmentChildren(command2.outlets);
      return new UrlSegmentGroup(paths, children);
    }
    if (i === 0 && isMatrixParams(commands[0])) {
      const p = segmentGroup.segments[startIndex];
      paths.push(new UrlSegment(p.path, stringify2(commands[0])));
      i++;
      continue;
    }
    const curr = isCommandWithOutlets(command2) ? command2.outlets[PRIMARY_OUTLET] : `${command2}`;
    const next = i < commands.length - 1 ? commands[i + 1] : null;
    if (curr && next && isMatrixParams(next)) {
      paths.push(new UrlSegment(curr, stringify2(next)));
      i += 2;
    } else {
      paths.push(new UrlSegment(curr, {}));
      i++;
    }
  }
  return new UrlSegmentGroup(paths, {});
}
function createNewSegmentChildren(outlets) {
  const children = {};
  Object.entries(outlets).forEach(([outlet, commands]) => {
    if (typeof commands === "string") {
      commands = [commands];
    }
    if (commands !== null) {
      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);
    }
  });
  return children;
}
function stringify2(params) {
  const res = {};
  Object.entries(params).forEach(([k, v]) => res[k] = `${v}`);
  return res;
}
function compare(path, params, segment) {
  return path == segment.path && shallowEqual(params, segment.parameters);
}
function isPublicRouterEvent(e) {
  return !(e instanceof BeforeActivateRoutes) && !(e instanceof RedirectRequest);
}
function stringifyEvent(routerEvent) {
  switch (routerEvent.type) {
    case EventType.ActivationEnd:
      return `ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.ActivationStart:
      return `ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.ChildActivationEnd:
      return `ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.ChildActivationStart:
      return `ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.GuardsCheckEnd:
      return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;
    case EventType.GuardsCheckStart:
      return `GuardsCheckStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.NavigationCancel:
      return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.NavigationSkipped:
      return `NavigationSkipped(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.NavigationEnd:
      return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}')`;
    case EventType.NavigationError:
      return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${routerEvent.error})`;
    case EventType.NavigationStart:
      return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.ResolveEnd:
      return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.ResolveStart:
      return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.RouteConfigLoadEnd:
      return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;
    case EventType.RouteConfigLoadStart:
      return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;
    case EventType.RoutesRecognized:
      return `RoutesRecognized(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.Scroll:
      const pos = routerEvent.position ? `${routerEvent.position[0]}, ${routerEvent.position[1]}` : null;
      return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;
  }
}
function getOrCreateRouteInjectorIfNeeded(route, currentInjector) {
  if (route.providers && !route._injector) {
    route._injector = createEnvironmentInjector(route.providers, currentInjector, `Route: ${route.path}`);
  }
  return route._injector ?? currentInjector;
}
function validateConfig(config3, parentPath = "", requireStandaloneComponents = false) {
  for (let i = 0; i < config3.length; i++) {
    const route = config3[i];
    const fullPath = getFullPath(parentPath, route);
    validateNode(route, fullPath, requireStandaloneComponents);
  }
}
function assertStandalone(fullPath, component) {
  if (component && isNgModule(component)) {
    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. You are using 'loadComponent' with a module, but it must be used with standalone components. Use 'loadChildren' instead.`);
  } else if (component && !isStandalone(component)) {
    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. The component must be standalone.`);
  }
}
function validateNode(route, fullPath, requireStandaloneComponents) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (!route) {
      throw new RuntimeError(4014, `
      Invalid configuration of route '${fullPath}': Encountered undefined route.
      The reason might be an extra comma.

      Example:
      const routes: Routes = [
        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },
        { path: 'dashboard',  component: DashboardComponent },, << two commas
        { path: 'detail/:id', component: HeroDetailComponent }
      ];
    `);
    }
    if (Array.isArray(route)) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': Array cannot be specified`);
    }
    if (!route.redirectTo && !route.component && !route.loadComponent && !route.children && !route.loadChildren && route.outlet && route.outlet !== PRIMARY_OUTLET) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);
    }
    if (route.redirectTo && route.children) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);
    }
    if (route.redirectTo && route.loadChildren) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);
    }
    if (route.children && route.loadChildren) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);
    }
    if (route.component && route.loadComponent) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': component and loadComponent cannot be used together`);
    }
    if (route.redirectTo) {
      if (route.component || route.loadComponent) {
        throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and component/loadComponent cannot be used together`);
      }
      if (route.canMatch || route.canActivate) {
        throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and ${route.canMatch ? "canMatch" : "canActivate"} cannot be used together.Redirects happen before guards are executed.`);
      }
    }
    if (route.path && route.matcher) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);
    }
    if (route.redirectTo === void 0 && !route.component && !route.loadComponent && !route.children && !route.loadChildren) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`);
    }
    if (route.path === void 0 && route.matcher === void 0) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);
    }
    if (typeof route.path === "string" && route.path.charAt(0) === "/") {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': path cannot start with a slash`);
    }
    if (route.path === "" && route.redirectTo !== void 0 && route.pathMatch === void 0) {
      const exp = `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;
      throw new RuntimeError(4014, `Invalid configuration of route '{path: "${fullPath}", redirectTo: "${route.redirectTo}"}': please provide 'pathMatch'. ${exp}`);
    }
    if (requireStandaloneComponents) {
      assertStandalone(fullPath, route.component);
    }
  }
  if (route.children) {
    validateConfig(route.children, fullPath, requireStandaloneComponents);
  }
}
function getFullPath(parentPath, currentRoute) {
  if (!currentRoute) {
    return parentPath;
  }
  if (!parentPath && !currentRoute.path) {
    return "";
  } else if (parentPath && !currentRoute.path) {
    return `${parentPath}/`;
  } else if (!parentPath && currentRoute.path) {
    return currentRoute.path;
  } else {
    return `${parentPath}/${currentRoute.path}`;
  }
}
function getOutlet(route) {
  return route.outlet || PRIMARY_OUTLET;
}
function sortByMatchingOutlets(routes2, outletName) {
  const sortedConfig = routes2.filter((r) => getOutlet(r) === outletName);
  sortedConfig.push(...routes2.filter((r) => getOutlet(r) !== outletName));
  return sortedConfig;
}
function getClosestRouteInjector(snapshot) {
  if (!snapshot) return null;
  if (snapshot.routeConfig?._injector) {
    return snapshot.routeConfig._injector;
  }
  for (let s = snapshot.parent; s; s = s.parent) {
    const route = s.routeConfig;
    if (route?._loadedInjector) return route._loadedInjector;
    if (route?._injector) return route._injector;
  }
  return null;
}
function findNode(value, node) {
  if (value === node.value) return node;
  for (const child of node.children) {
    const node2 = findNode(value, child);
    if (node2) return node2;
  }
  return null;
}
function findPath(value, node) {
  if (value === node.value) return [node];
  for (const child of node.children) {
    const path = findPath(value, child);
    if (path.length) {
      path.unshift(node);
      return path;
    }
  }
  return [];
}
function nodeChildrenAsMap(node) {
  const map2 = {};
  if (node) {
    node.children.forEach((child) => map2[child.value.outlet] = child);
  }
  return map2;
}
function createEmptyState(rootComponent) {
  const snapshot = createEmptyStateSnapshot(rootComponent);
  const emptyUrl = new BehaviorSubject([new UrlSegment("", {})]);
  const emptyParams = new BehaviorSubject({});
  const emptyData = new BehaviorSubject({});
  const emptyQueryParams = new BehaviorSubject({});
  const fragment = new BehaviorSubject("");
  const activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);
  activated.snapshot = snapshot.root;
  return new RouterState(new TreeNode(activated, []), snapshot);
}
function createEmptyStateSnapshot(rootComponent) {
  const emptyParams = {};
  const emptyData = {};
  const emptyQueryParams = {};
  const fragment = "";
  const activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, {});
  return new RouterStateSnapshot("", new TreeNode(activated, []));
}
function getInherited(route, parent, paramsInheritanceStrategy = "emptyOnly") {
  let inherited;
  const {
    routeConfig
  } = route;
  if (parent !== null && (paramsInheritanceStrategy === "always" || // inherit parent data if route is empty path
  routeConfig?.path === "" || // inherit parent data if parent was componentless
  !parent.component && !parent.routeConfig?.loadComponent)) {
    inherited = {
      params: __spreadValues(__spreadValues({}, parent.params), route.params),
      data: __spreadValues(__spreadValues({}, parent.data), route.data),
      resolve: __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, route.data), parent.data), routeConfig?.data), route._resolvedData)
    };
  } else {
    inherited = {
      params: __spreadValues({}, route.params),
      data: __spreadValues({}, route.data),
      resolve: __spreadValues(__spreadValues({}, route.data), route._resolvedData ?? {})
    };
  }
  if (routeConfig && hasStaticTitle(routeConfig)) {
    inherited.resolve[RouteTitleKey] = routeConfig.title;
  }
  return inherited;
}
function setRouterState(state, node) {
  node.value._routerState = state;
  node.children.forEach((c) => setRouterState(state, c));
}
function serializeNode(node) {
  const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(", ")} } ` : "";
  return `${node.value}${c}`;
}
function advanceActivatedRoute(route) {
  if (route.snapshot) {
    const currentSnapshot = route.snapshot;
    const nextSnapshot = route._futureSnapshot;
    route.snapshot = nextSnapshot;
    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {
      route.queryParamsSubject.next(nextSnapshot.queryParams);
    }
    if (currentSnapshot.fragment !== nextSnapshot.fragment) {
      route.fragmentSubject.next(nextSnapshot.fragment);
    }
    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {
      route.paramsSubject.next(nextSnapshot.params);
    }
    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {
      route.urlSubject.next(nextSnapshot.url);
    }
    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {
      route.dataSubject.next(nextSnapshot.data);
    }
  } else {
    route.snapshot = route._futureSnapshot;
    route.dataSubject.next(route._futureSnapshot.data);
  }
}
function equalParamsAndUrlSegments(a, b) {
  const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);
  const parentsMismatch = !a.parent !== !b.parent;
  return equalUrlParams && !parentsMismatch && (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent));
}
function hasStaticTitle(config3) {
  return typeof config3.title === "string" || config3.title === null;
}
function standardizeConfig(r) {
  const children = r.children && r.children.map(standardizeConfig);
  const c = children ? __spreadProps(__spreadValues({}, r), {
    children
  }) : __spreadValues({}, r);
  if (!c.component && !c.loadComponent && (children || c.loadChildren) && c.outlet && c.outlet !== PRIMARY_OUTLET) {
    c.component = \u0275EmptyOutletComponent;
  }
  return c;
}
function createRouterState(routeReuseStrategy, curr, prevState) {
  const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : void 0);
  return new RouterState(root, curr);
}
function createNode(routeReuseStrategy, curr, prevState) {
  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {
    const value = prevState.value;
    value._futureSnapshot = curr.value;
    const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);
    return new TreeNode(value, children);
  } else {
    if (routeReuseStrategy.shouldAttach(curr.value)) {
      const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);
      if (detachedRouteHandle !== null) {
        const tree2 = detachedRouteHandle.route;
        tree2.value._futureSnapshot = curr.value;
        tree2.children = curr.children.map((c) => createNode(routeReuseStrategy, c));
        return tree2;
      }
    }
    const value = createActivatedRoute(curr.value);
    const children = curr.children.map((c) => createNode(routeReuseStrategy, c));
    return new TreeNode(value, children);
  }
}
function createOrReuseChildren(routeReuseStrategy, curr, prevState) {
  return curr.children.map((child) => {
    for (const p of prevState.children) {
      if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {
        return createNode(routeReuseStrategy, child, p);
      }
    }
    return createNode(routeReuseStrategy, child);
  });
}
function createActivatedRoute(c) {
  return new ActivatedRoute(new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);
}
function redirectingNavigationError(urlSerializer, redirect) {
  const {
    redirectTo,
    navigationBehaviorOptions
  } = isUrlTree(redirect) ? {
    redirectTo: redirect,
    navigationBehaviorOptions: void 0
  } : redirect;
  const error = navigationCancelingError(ngDevMode && `Redirecting to "${urlSerializer.serialize(redirectTo)}"`, NavigationCancellationCode.Redirect);
  error.url = redirectTo;
  error.navigationBehaviorOptions = navigationBehaviorOptions;
  return error;
}
function navigationCancelingError(message, code) {
  const error = new Error(`NavigationCancelingError: ${message || ""}`);
  error[NAVIGATION_CANCELING_ERROR] = true;
  error.cancellationCode = code;
  return error;
}
function isRedirectingNavigationCancelingError(error) {
  return isNavigationCancelingError(error) && isUrlTree(error.url);
}
function isNavigationCancelingError(error) {
  return !!error && error[NAVIGATION_CANCELING_ERROR];
}
function getAllRouteGuards(future, curr, parentContexts) {
  const futureRoot = future._root;
  const currRoot = curr ? curr._root : null;
  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);
}
function getCanActivateChild(p) {
  const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;
  if (!canActivateChild || canActivateChild.length === 0) return null;
  return {
    node: p,
    guards: canActivateChild
  };
}
function getTokenOrFunctionIdentity(tokenOrFunction, injector) {
  const NOT_FOUND3 = Symbol();
  const result = injector.get(tokenOrFunction, NOT_FOUND3);
  if (result === NOT_FOUND3) {
    if (typeof tokenOrFunction === "function" && !isInjectable(tokenOrFunction)) {
      return tokenOrFunction;
    } else {
      return injector.get(tokenOrFunction);
    }
  }
  return result;
}
function getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks = {
  canDeactivateChecks: [],
  canActivateChecks: []
}) {
  const prevChildren = nodeChildrenAsMap(currNode);
  futureNode.children.forEach((c) => {
    getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);
    delete prevChildren[c.value.outlet];
  });
  Object.entries(prevChildren).forEach(([k, v]) => deactivateRouteAndItsChildren(v, contexts.getContext(k), checks));
  return checks;
}
function getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks = {
  canDeactivateChecks: [],
  canActivateChecks: []
}) {
  const future = futureNode.value;
  const curr = currNode ? currNode.value : null;
  const context2 = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;
  if (curr && future.routeConfig === curr.routeConfig) {
    const shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);
    if (shouldRun) {
      checks.canActivateChecks.push(new CanActivate(futurePath));
    } else {
      future.data = curr.data;
      future._resolvedData = curr._resolvedData;
    }
    if (future.component) {
      getChildRouteGuards(futureNode, currNode, context2 ? context2.children : null, futurePath, checks);
    } else {
      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);
    }
    if (shouldRun && context2 && context2.outlet && context2.outlet.isActivated) {
      checks.canDeactivateChecks.push(new CanDeactivate(context2.outlet.component, curr));
    }
  } else {
    if (curr) {
      deactivateRouteAndItsChildren(currNode, context2, checks);
    }
    checks.canActivateChecks.push(new CanActivate(futurePath));
    if (future.component) {
      getChildRouteGuards(futureNode, null, context2 ? context2.children : null, futurePath, checks);
    } else {
      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);
    }
  }
  return checks;
}
function shouldRunGuardsAndResolvers(curr, future, mode) {
  if (typeof mode === "function") {
    return mode(curr, future);
  }
  switch (mode) {
    case "pathParamsChange":
      return !equalPath(curr.url, future.url);
    case "pathParamsOrQueryParamsChange":
      return !equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams);
    case "always":
      return true;
    case "paramsOrQueryParamsChange":
      return !equalParamsAndUrlSegments(curr, future) || !shallowEqual(curr.queryParams, future.queryParams);
    case "paramsChange":
    default:
      return !equalParamsAndUrlSegments(curr, future);
  }
}
function deactivateRouteAndItsChildren(route, context2, checks) {
  const children = nodeChildrenAsMap(route);
  const r = route.value;
  Object.entries(children).forEach(([childName, node]) => {
    if (!r.component) {
      deactivateRouteAndItsChildren(node, context2, checks);
    } else if (context2) {
      deactivateRouteAndItsChildren(node, context2.children.getContext(childName), checks);
    } else {
      deactivateRouteAndItsChildren(node, null, checks);
    }
  });
  if (!r.component) {
    checks.canDeactivateChecks.push(new CanDeactivate(null, r));
  } else if (context2 && context2.outlet && context2.outlet.isActivated) {
    checks.canDeactivateChecks.push(new CanDeactivate(context2.outlet.component, r));
  } else {
    checks.canDeactivateChecks.push(new CanDeactivate(null, r));
  }
}
function isFunction2(v) {
  return typeof v === "function";
}
function isBoolean(v) {
  return typeof v === "boolean";
}
function isCanLoad(guard) {
  return guard && isFunction2(guard.canLoad);
}
function isCanActivate(guard) {
  return guard && isFunction2(guard.canActivate);
}
function isCanActivateChild(guard) {
  return guard && isFunction2(guard.canActivateChild);
}
function isCanDeactivate(guard) {
  return guard && isFunction2(guard.canDeactivate);
}
function isCanMatch(guard) {
  return guard && isFunction2(guard.canMatch);
}
function isEmptyError(e) {
  return e instanceof EmptyError || e?.name === "EmptyError";
}
function prioritizedGuardValue() {
  return switchMap((obs) => {
    return combineLatest(obs.map((o) => o.pipe(take(1), startWith(INITIAL_VALUE)))).pipe(map((results) => {
      for (const result of results) {
        if (result === true) {
          continue;
        } else if (result === INITIAL_VALUE) {
          return INITIAL_VALUE;
        } else if (result === false || isRedirect(result)) {
          return result;
        }
      }
      return true;
    }), filter((item) => item !== INITIAL_VALUE), take(1));
  });
}
function isRedirect(val) {
  return isUrlTree(val) || val instanceof RedirectCommand;
}
function checkGuards(injector, forwardEvent) {
  return mergeMap((t2) => {
    const {
      targetSnapshot,
      currentSnapshot,
      guards: {
        canActivateChecks,
        canDeactivateChecks
      }
    } = t2;
    if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {
      return of(__spreadProps(__spreadValues({}, t2), {
        guardsResult: true
      }));
    }
    return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, injector).pipe(mergeMap((canDeactivate) => {
      return canDeactivate && isBoolean(canDeactivate) ? runCanActivateChecks(targetSnapshot, canActivateChecks, injector, forwardEvent) : of(canDeactivate);
    }), map((guardsResult) => __spreadProps(__spreadValues({}, t2), {
      guardsResult
    })));
  });
}
function runCanDeactivateChecks(checks, futureRSS, currRSS, injector) {
  return from(checks).pipe(mergeMap((check) => runCanDeactivate(check.component, check.route, currRSS, futureRSS, injector)), first((result) => {
    return result !== true;
  }, true));
}
function runCanActivateChecks(futureSnapshot, checks, injector, forwardEvent) {
  return from(checks).pipe(concatMap((check) => {
    return concat(fireChildActivationStart(check.route.parent, forwardEvent), fireActivationStart(check.route, forwardEvent), runCanActivateChild(futureSnapshot, check.path, injector), runCanActivate(futureSnapshot, check.route, injector));
  }), first((result) => {
    return result !== true;
  }, true));
}
function fireActivationStart(snapshot, forwardEvent) {
  if (snapshot !== null && forwardEvent) {
    forwardEvent(new ActivationStart(snapshot));
  }
  return of(true);
}
function fireChildActivationStart(snapshot, forwardEvent) {
  if (snapshot !== null && forwardEvent) {
    forwardEvent(new ChildActivationStart(snapshot));
  }
  return of(true);
}
function runCanActivate(futureRSS, futureARS, injector) {
  const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;
  if (!canActivate || canActivate.length === 0) return of(true);
  const canActivateObservables = canActivate.map((canActivate2) => {
    return defer(() => {
      const closestInjector = getClosestRouteInjector(futureARS) ?? injector;
      const guard = getTokenOrFunctionIdentity(canActivate2, closestInjector);
      const guardVal = isCanActivate(guard) ? guard.canActivate(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));
      return wrapIntoObservable(guardVal).pipe(first());
    });
  });
  return of(canActivateObservables).pipe(prioritizedGuardValue());
}
function runCanActivateChild(futureRSS, path, injector) {
  const futureARS = path[path.length - 1];
  const canActivateChildGuards = path.slice(0, path.length - 1).reverse().map((p) => getCanActivateChild(p)).filter((_) => _ !== null);
  const canActivateChildGuardsMapped = canActivateChildGuards.map((d) => {
    return defer(() => {
      const guardsMapped = d.guards.map((canActivateChild) => {
        const closestInjector = getClosestRouteInjector(d.node) ?? injector;
        const guard = getTokenOrFunctionIdentity(canActivateChild, closestInjector);
        const guardVal = isCanActivateChild(guard) ? guard.canActivateChild(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));
        return wrapIntoObservable(guardVal).pipe(first());
      });
      return of(guardsMapped).pipe(prioritizedGuardValue());
    });
  });
  return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());
}
function runCanDeactivate(component, currARS, currRSS, futureRSS, injector) {
  const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;
  if (!canDeactivate || canDeactivate.length === 0) return of(true);
  const canDeactivateObservables = canDeactivate.map((c) => {
    const closestInjector = getClosestRouteInjector(currARS) ?? injector;
    const guard = getTokenOrFunctionIdentity(c, closestInjector);
    const guardVal = isCanDeactivate(guard) ? guard.canDeactivate(component, currARS, currRSS, futureRSS) : runInInjectionContext(closestInjector, () => guard(component, currARS, currRSS, futureRSS));
    return wrapIntoObservable(guardVal).pipe(first());
  });
  return of(canDeactivateObservables).pipe(prioritizedGuardValue());
}
function runCanLoadGuards(injector, route, segments, urlSerializer) {
  const canLoad = route.canLoad;
  if (canLoad === void 0 || canLoad.length === 0) {
    return of(true);
  }
  const canLoadObservables = canLoad.map((injectionToken) => {
    const guard = getTokenOrFunctionIdentity(injectionToken, injector);
    const guardVal = isCanLoad(guard) ? guard.canLoad(route, segments) : runInInjectionContext(injector, () => guard(route, segments));
    return wrapIntoObservable(guardVal);
  });
  return of(canLoadObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));
}
function redirectIfUrlTree(urlSerializer) {
  return pipe(tap((result) => {
    if (typeof result === "boolean") return;
    throw redirectingNavigationError(urlSerializer, result);
  }), map((result) => result === true));
}
function runCanMatchGuards(injector, route, segments, urlSerializer) {
  const canMatch = route.canMatch;
  if (!canMatch || canMatch.length === 0) return of(true);
  const canMatchObservables = canMatch.map((injectionToken) => {
    const guard = getTokenOrFunctionIdentity(injectionToken, injector);
    const guardVal = isCanMatch(guard) ? guard.canMatch(route, segments) : runInInjectionContext(injector, () => guard(route, segments));
    return wrapIntoObservable(guardVal);
  });
  return of(canMatchObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));
}
function noMatch$1(segmentGroup) {
  return throwError(new NoMatch(segmentGroup));
}
function namedOutletsRedirect(redirectTo) {
  return throwError(new RuntimeError(4e3, (typeof ngDevMode === "undefined" || ngDevMode) && `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`));
}
function canLoadFails(route) {
  return throwError(navigationCancelingError((typeof ngDevMode === "undefined" || ngDevMode) && `Cannot load children because the guard of the route "path: '${route.path}'" returned false`, NavigationCancellationCode.GuardRejected));
}
function getRedirectResult(redirectTo, currentSnapshot, injector) {
  if (typeof redirectTo === "string") {
    return of(redirectTo);
  }
  const redirectToFn = redirectTo;
  const {
    queryParams,
    fragment,
    routeConfig,
    url,
    outlet,
    params,
    data: data2,
    title
  } = currentSnapshot;
  return wrapIntoObservable(runInInjectionContext(injector, () => redirectToFn({
    params,
    data: data2,
    queryParams,
    fragment,
    routeConfig,
    url,
    outlet,
    title
  })));
}
function matchWithChecks(segmentGroup, route, segments, injector, urlSerializer) {
  const result = match(segmentGroup, route, segments);
  if (!result.matched) {
    return of(result);
  }
  injector = getOrCreateRouteInjectorIfNeeded(route, injector);
  return runCanMatchGuards(injector, route, segments, urlSerializer).pipe(map((v) => v === true ? result : __spreadValues({}, noMatch)));
}
function match(segmentGroup, route, segments) {
  if (route.path === "**") {
    return createWildcardMatchResult(segments);
  }
  if (route.path === "") {
    if (route.pathMatch === "full" && (segmentGroup.hasChildren() || segments.length > 0)) {
      return __spreadValues({}, noMatch);
    }
    return {
      matched: true,
      consumedSegments: [],
      remainingSegments: segments,
      parameters: {},
      positionalParamSegments: {}
    };
  }
  const matcher = route.matcher || defaultUrlMatcher;
  const res = matcher(segments, segmentGroup, route);
  if (!res) return __spreadValues({}, noMatch);
  const posParams = {};
  Object.entries(res.posParams ?? {}).forEach(([k, v]) => {
    posParams[k] = v.path;
  });
  const parameters = res.consumed.length > 0 ? __spreadValues(__spreadValues({}, posParams), res.consumed[res.consumed.length - 1].parameters) : posParams;
  return {
    matched: true,
    consumedSegments: res.consumed,
    remainingSegments: segments.slice(res.consumed.length),
    // TODO(atscott): investigate combining parameters and positionalParamSegments
    parameters,
    positionalParamSegments: res.posParams ?? {}
  };
}
function createWildcardMatchResult(segments) {
  return {
    matched: true,
    parameters: segments.length > 0 ? last3(segments).parameters : {},
    consumedSegments: segments,
    remainingSegments: [],
    positionalParamSegments: {}
  };
}
function split(segmentGroup, consumedSegments, slicedSegments, config3) {
  if (slicedSegments.length > 0 && containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config3)) {
    const s2 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(config3, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
    return {
      segmentGroup: s2,
      slicedSegments: []
    };
  }
  if (slicedSegments.length === 0 && containsEmptyPathMatches(segmentGroup, slicedSegments, config3)) {
    const s2 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config3, segmentGroup.children));
    return {
      segmentGroup: s2,
      slicedSegments
    };
  }
  const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);
  return {
    segmentGroup: s,
    slicedSegments
  };
}
function addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes2, children) {
  const res = {};
  for (const r of routes2) {
    if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {
      const s = new UrlSegmentGroup([], {});
      res[getOutlet(r)] = s;
    }
  }
  return __spreadValues(__spreadValues({}, children), res);
}
function createChildrenForEmptyPaths(routes2, primarySegment) {
  const res = {};
  res[PRIMARY_OUTLET] = primarySegment;
  for (const r of routes2) {
    if (r.path === "" && getOutlet(r) !== PRIMARY_OUTLET) {
      const s = new UrlSegmentGroup([], {});
      res[getOutlet(r)] = s;
    }
  }
  return res;
}
function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes2) {
  return routes2.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET);
}
function containsEmptyPathMatches(segmentGroup, slicedSegments, routes2) {
  return routes2.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r));
}
function emptyPathMatch(segmentGroup, slicedSegments, r) {
  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === "full") {
    return false;
  }
  return r.path === "";
}
function noLeftoversInUrl(segmentGroup, segments, outlet) {
  return segments.length === 0 && !segmentGroup.children[outlet];
}
function recognize$1(injector, configLoader, rootComponentType, config3, urlTree, urlSerializer, paramsInheritanceStrategy = "emptyOnly") {
  return new Recognizer(injector, configLoader, rootComponentType, config3, urlTree, paramsInheritanceStrategy, urlSerializer).recognize();
}
function sortActivatedRouteSnapshots(nodes) {
  nodes.sort((a, b) => {
    if (a.value.outlet === PRIMARY_OUTLET) return -1;
    if (b.value.outlet === PRIMARY_OUTLET) return 1;
    return a.value.outlet.localeCompare(b.value.outlet);
  });
}
function hasEmptyPathConfig(node) {
  const config3 = node.value.routeConfig;
  return config3 && config3.path === "";
}
function mergeEmptyPathMatches(nodes) {
  const result = [];
  const mergedNodes = /* @__PURE__ */ new Set();
  for (const node of nodes) {
    if (!hasEmptyPathConfig(node)) {
      result.push(node);
      continue;
    }
    const duplicateEmptyPathNode = result.find((resultNode) => node.value.routeConfig === resultNode.value.routeConfig);
    if (duplicateEmptyPathNode !== void 0) {
      duplicateEmptyPathNode.children.push(...node.children);
      mergedNodes.add(duplicateEmptyPathNode);
    } else {
      result.push(node);
    }
  }
  for (const mergedNode of mergedNodes) {
    const mergedChildren = mergeEmptyPathMatches(mergedNode.children);
    result.push(new TreeNode(mergedNode.value, mergedChildren));
  }
  return result.filter((n) => !mergedNodes.has(n));
}
function checkOutletNameUniqueness(nodes) {
  const names = {};
  nodes.forEach((n) => {
    const routeWithSameOutletName = names[n.value.outlet];
    if (routeWithSameOutletName) {
      const p = routeWithSameOutletName.url.map((s) => s.toString()).join("/");
      const c = n.value.url.map((s) => s.toString()).join("/");
      throw new RuntimeError(4006, (typeof ngDevMode === "undefined" || ngDevMode) && `Two segments cannot have the same outlet name: '${p}' and '${c}'.`);
    }
    names[n.value.outlet] = n.value;
  });
}
function getData(route) {
  return route.data || {};
}
function getResolve(route) {
  return route.resolve || {};
}
function recognize(injector, configLoader, rootComponentType, config3, serializer, paramsInheritanceStrategy) {
  return mergeMap((t2) => recognize$1(injector, configLoader, rootComponentType, config3, t2.extractedUrl, serializer, paramsInheritanceStrategy).pipe(map(({
    state: targetSnapshot,
    tree: urlAfterRedirects
  }) => {
    return __spreadProps(__spreadValues({}, t2), {
      targetSnapshot,
      urlAfterRedirects
    });
  })));
}
function resolveData(paramsInheritanceStrategy, injector) {
  return mergeMap((t2) => {
    const {
      targetSnapshot,
      guards: {
        canActivateChecks
      }
    } = t2;
    if (!canActivateChecks.length) {
      return of(t2);
    }
    const routesWithResolversToRun = new Set(canActivateChecks.map((check) => check.route));
    const routesNeedingDataUpdates = /* @__PURE__ */ new Set();
    for (const route of routesWithResolversToRun) {
      if (routesNeedingDataUpdates.has(route)) {
        continue;
      }
      for (const newRoute of flattenRouteTree(route)) {
        routesNeedingDataUpdates.add(newRoute);
      }
    }
    let routesProcessed = 0;
    return from(routesNeedingDataUpdates).pipe(concatMap((route) => {
      if (routesWithResolversToRun.has(route)) {
        return runResolve(route, targetSnapshot, paramsInheritanceStrategy, injector);
      } else {
        route.data = getInherited(route, route.parent, paramsInheritanceStrategy).resolve;
        return of(void 0);
      }
    }), tap(() => routesProcessed++), takeLast(1), mergeMap((_) => routesProcessed === routesNeedingDataUpdates.size ? of(t2) : EMPTY));
  });
}
function flattenRouteTree(route) {
  const descendants = route.children.map((child) => flattenRouteTree(child)).flat();
  return [route, ...descendants];
}
function runResolve(futureARS, futureRSS, paramsInheritanceStrategy, injector) {
  const config3 = futureARS.routeConfig;
  const resolve = futureARS._resolve;
  if (config3?.title !== void 0 && !hasStaticTitle(config3)) {
    resolve[RouteTitleKey] = config3.title;
  }
  return defer(() => {
    futureARS.data = getInherited(futureARS, futureARS.parent, paramsInheritanceStrategy).resolve;
    return resolveNode(resolve, futureARS, futureRSS, injector).pipe(map((resolvedData) => {
      futureARS._resolvedData = resolvedData;
      futureARS.data = __spreadValues(__spreadValues({}, futureARS.data), resolvedData);
      return null;
    }));
  });
}
function resolveNode(resolve, futureARS, futureRSS, injector) {
  const keys2 = getDataKeys(resolve);
  if (keys2.length === 0) {
    return of({});
  }
  const data2 = {};
  return from(keys2).pipe(mergeMap((key) => getResolver(resolve[key], futureARS, futureRSS, injector).pipe(first(), tap((value) => {
    if (value instanceof RedirectCommand) {
      throw redirectingNavigationError(new DefaultUrlSerializer(), value);
    }
    data2[key] = value;
  }))), takeLast(1), map(() => data2), catchError((e) => isEmptyError(e) ? EMPTY : throwError(e)));
}
function getResolver(injectionToken, futureARS, futureRSS, injector) {
  const closestInjector = getClosestRouteInjector(futureARS) ?? injector;
  const resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);
  const resolverValue = resolver.resolve ? resolver.resolve(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => resolver(futureARS, futureRSS));
  return wrapIntoObservable(resolverValue);
}
function switchTap(next) {
  return switchMap((v) => {
    const nextResult = next(v);
    if (nextResult) {
      return from(nextResult).pipe(map(() => v));
    }
    return of(v);
  });
}
function loadChildren(route, compiler, parentInjector, onLoadEndListener) {
  return wrapIntoObservable(runInInjectionContext(parentInjector, () => route.loadChildren())).pipe(map(maybeUnwrapDefaultExport), switchMap(maybeResolveResources), mergeMap((t2) => {
    if (t2 instanceof NgModuleFactory$1 || Array.isArray(t2)) {
      return of(t2);
    } else {
      return from(compiler.compileModuleAsync(t2));
    }
  }), map((factoryOrRoutes) => {
    if (onLoadEndListener) {
      onLoadEndListener(route);
    }
    let injector;
    let rawRoutes;
    let requireStandaloneComponents = false;
    if (Array.isArray(factoryOrRoutes)) {
      rawRoutes = factoryOrRoutes;
      requireStandaloneComponents = true;
    } else {
      injector = factoryOrRoutes.create(parentInjector).injector;
      rawRoutes = injector.get(ROUTES, [], {
        optional: true,
        self: true
      }).flat();
    }
    const routes2 = rawRoutes.map(standardizeConfig);
    (typeof ngDevMode === "undefined" || ngDevMode) && validateConfig(routes2, route.path, requireStandaloneComponents);
    return {
      routes: routes2,
      injector
    };
  }));
}
function isWrappedDefaultExport(value) {
  return value && typeof value === "object" && "default" in value;
}
function maybeUnwrapDefaultExport(input2) {
  return isWrappedDefaultExport(input2) ? input2["default"] : input2;
}
function maybeResolveResources(value) {
  if (false) {
    return resolveComponentResources(fetch).catch((error) => {
      console.error(error);
      return Promise.resolve();
    }).then(() => value);
  }
  return of(value);
}
function createViewTransition(injector, from2, to) {
  const transitionOptions = injector.get(VIEW_TRANSITION_OPTIONS);
  const document2 = injector.get(DOCUMENT);
  if (!document2.startViewTransition || transitionOptions.skipNextTransition) {
    transitionOptions.skipNextTransition = false;
    return new Promise((resolve) => setTimeout(resolve));
  }
  let resolveViewTransitionStarted;
  const viewTransitionStarted = new Promise((resolve) => {
    resolveViewTransitionStarted = resolve;
  });
  const transition = document2.startViewTransition(() => {
    resolveViewTransitionStarted();
    return createRenderPromise(injector);
  });
  transition.ready.catch((error) => {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.error(error);
    }
  });
  const {
    onViewTransitionCreated
  } = transitionOptions;
  if (onViewTransitionCreated) {
    runInInjectionContext(injector, () => onViewTransitionCreated({
      transition,
      from: from2,
      to
    }));
  }
  return viewTransitionStarted;
}
function createRenderPromise(injector) {
  return new Promise((resolve) => {
    afterNextRender({
      read: () => setTimeout(resolve)
    }, {
      injector
    });
  });
}
function isBrowserTriggeredNavigation(source) {
  return source !== IMPERATIVE_NAVIGATION;
}
function afterNextNavigation(router, action) {
  router.events.pipe(filter((e) => e instanceof NavigationEnd || e instanceof NavigationCancel || e instanceof NavigationError || e instanceof NavigationSkipped), map((e) => {
    if (e instanceof NavigationEnd || e instanceof NavigationSkipped) {
      return 0;
    }
    const redirecting = e instanceof NavigationCancel ? e.code === NavigationCancellationCode.Redirect || e.code === NavigationCancellationCode.SupersededByNewNavigation : false;
    return redirecting ? 2 : 1;
  }), filter(
    (result) => result !== 2
    /* NavigationResult.REDIRECTING */
  ), take(1)).subscribe(() => {
    action();
  });
}
function validateCommands(commands) {
  for (let i = 0; i < commands.length; i++) {
    const cmd2 = commands[i];
    if (cmd2 == null) {
      throw new RuntimeError(4008, (typeof ngDevMode === "undefined" || ngDevMode) && `The requested path contains ${cmd2} segment at index ${i}`);
    }
  }
}
var PRIMARY_OUTLET, RouteTitleKey, ParamsAsMap, pathCompareMap, paramCompareMap, UrlTree, UrlSegmentGroup, UrlSegment, UrlSerializer, DefaultUrlSerializer, DEFAULT_SERIALIZER, SEGMENT_RE, MATRIX_PARAM_SEGMENT_RE, QUERY_PARAM_RE, QUERY_PARAM_VALUE_RE, UrlParser, Navigation, Position, IMPERATIVE_NAVIGATION, EventType, RouterEvent, NavigationStart, NavigationEnd, NavigationCancellationCode, NavigationSkippedCode, NavigationCancel, NavigationSkipped, NavigationError, RoutesRecognized, GuardsCheckStart, GuardsCheckEnd, ResolveStart, ResolveEnd, RouteConfigLoadStart, RouteConfigLoadEnd, ChildActivationStart, ChildActivationEnd, ActivationStart, ActivationEnd, Scroll, BeforeActivateRoutes, RedirectRequest, OutletContext, ChildrenOutletContexts, Tree, TreeNode, RouterState, ActivatedRoute, ActivatedRouteSnapshot, RouterStateSnapshot, ROUTER_OUTLET_DATA, RouterOutlet, OutletInjector, INPUT_BINDER, RoutedComponentInputBinder, \u0275EmptyOutletComponent, RedirectCommand, NAVIGATION_CANCELING_ERROR, warnedAboutUnsupportedInputBinding, activateRoutes, ActivateRoutes, CanActivate, CanDeactivate, INITIAL_VALUE, NoMatch, AbsoluteRedirect, ApplyRedirects, noMatch, NoLeftoversInUrl, MAX_ALLOWED_REDIRECTS, Recognizer, TitleStrategy, DefaultTitleStrategy, ROUTER_CONFIGURATION, ROUTES, RouterConfigLoader, UrlHandlingStrategy, DefaultUrlHandlingStrategy, CREATE_VIEW_TRANSITION, VIEW_TRANSITION_OPTIONS, NAVIGATION_ERROR_HANDLER, NavigationTransitions, RouteReuseStrategy, BaseRouteReuseStrategy, DefaultRouteReuseStrategy, StateManager, HistoryStateManager, exactMatchOptions, subsetMatchOptions, Router;
var init_router2 = __esm({
  "node_modules/@angular/router/fesm2022/router2.mjs"() {
    "use strict";
    init_common();
    init_core();
    init_core();
    init_esm();
    init_operators();
    init_platform_browser();
    PRIMARY_OUTLET = "primary";
    RouteTitleKey = /* @__PURE__ */ Symbol("RouteTitle");
    ParamsAsMap = class {
      params;
      constructor(params) {
        this.params = params || {};
      }
      has(name2) {
        return Object.prototype.hasOwnProperty.call(this.params, name2);
      }
      get(name2) {
        if (this.has(name2)) {
          const v = this.params[name2];
          return Array.isArray(v) ? v[0] : v;
        }
        return null;
      }
      getAll(name2) {
        if (this.has(name2)) {
          const v = this.params[name2];
          return Array.isArray(v) ? v : [v];
        }
        return [];
      }
      get keys() {
        return Object.keys(this.params);
      }
    };
    pathCompareMap = {
      "exact": equalSegmentGroups,
      "subset": containsSegmentGroup
    };
    paramCompareMap = {
      "exact": equalParams,
      "subset": containsParams,
      "ignored": () => true
    };
    UrlTree = class {
      root;
      queryParams;
      fragment;
      /** @internal */
      _queryParamMap;
      constructor(root = new UrlSegmentGroup([], {}), queryParams = {}, fragment = null) {
        this.root = root;
        this.queryParams = queryParams;
        this.fragment = fragment;
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          if (root.segments.length > 0) {
            throw new RuntimeError(4015, "The root `UrlSegmentGroup` should not contain `segments`. Instead, these segments belong in the `children` so they can be associated with a named outlet.");
          }
        }
      }
      get queryParamMap() {
        this._queryParamMap ??= convertToParamMap(this.queryParams);
        return this._queryParamMap;
      }
      /** @docsNotRequired */
      toString() {
        return DEFAULT_SERIALIZER.serialize(this);
      }
    };
    UrlSegmentGroup = class {
      segments;
      children;
      /** The parent node in the url tree */
      parent = null;
      constructor(segments, children) {
        this.segments = segments;
        this.children = children;
        Object.values(children).forEach((v) => v.parent = this);
      }
      /** Whether the segment has child segments */
      hasChildren() {
        return this.numberOfChildren > 0;
      }
      /** Number of child segments */
      get numberOfChildren() {
        return Object.keys(this.children).length;
      }
      /** @docsNotRequired */
      toString() {
        return serializePaths(this);
      }
    };
    UrlSegment = class {
      path;
      parameters;
      /** @internal */
      _parameterMap;
      constructor(path, parameters) {
        this.path = path;
        this.parameters = parameters;
      }
      get parameterMap() {
        this._parameterMap ??= convertToParamMap(this.parameters);
        return this._parameterMap;
      }
      /** @docsNotRequired */
      toString() {
        return serializePath(this);
      }
    };
    UrlSerializer = class _UrlSerializer {
      static \u0275fac = function UrlSerializer_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _UrlSerializer)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _UrlSerializer,
        factory: () => (() => new DefaultUrlSerializer())(),
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UrlSerializer, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: () => new DefaultUrlSerializer()
        }]
      }], null, null);
    })();
    DefaultUrlSerializer = class {
      /** Parses a url into a `UrlTree` */
      parse(url) {
        const p = new UrlParser(url);
        return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());
      }
      /** Converts a `UrlTree` into a url */
      serialize(tree2) {
        const segment = `/${serializeSegment(tree2.root, true)}`;
        const query = serializeQueryParams(tree2.queryParams);
        const fragment = typeof tree2.fragment === `string` ? `#${encodeUriFragment(tree2.fragment)}` : "";
        return `${segment}${query}${fragment}`;
      }
    };
    DEFAULT_SERIALIZER = new DefaultUrlSerializer();
    SEGMENT_RE = /^[^\/()?;#]+/;
    MATRIX_PARAM_SEGMENT_RE = /^[^\/()?;=#]+/;
    QUERY_PARAM_RE = /^[^=?&#]+/;
    QUERY_PARAM_VALUE_RE = /^[^&#]+/;
    UrlParser = class {
      url;
      remaining;
      constructor(url) {
        this.url = url;
        this.remaining = url;
      }
      parseRootSegment() {
        this.consumeOptional("/");
        if (this.remaining === "" || this.peekStartsWith("?") || this.peekStartsWith("#")) {
          return new UrlSegmentGroup([], {});
        }
        return new UrlSegmentGroup([], this.parseChildren());
      }
      parseQueryParams() {
        const params = {};
        if (this.consumeOptional("?")) {
          do {
            this.parseQueryParam(params);
          } while (this.consumeOptional("&"));
        }
        return params;
      }
      parseFragment() {
        return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null;
      }
      parseChildren() {
        if (this.remaining === "") {
          return {};
        }
        this.consumeOptional("/");
        const segments = [];
        if (!this.peekStartsWith("(")) {
          segments.push(this.parseSegment());
        }
        while (this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(")) {
          this.capture("/");
          segments.push(this.parseSegment());
        }
        let children = {};
        if (this.peekStartsWith("/(")) {
          this.capture("/");
          children = this.parseParens(true);
        }
        let res = {};
        if (this.peekStartsWith("(")) {
          res = this.parseParens(false);
        }
        if (segments.length > 0 || Object.keys(children).length > 0) {
          res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);
        }
        return res;
      }
      // parse a segment with its matrix parameters
      // ie `name;k1=v1;k2`
      parseSegment() {
        const path = matchSegments(this.remaining);
        if (path === "" && this.peekStartsWith(";")) {
          throw new RuntimeError(4009, (typeof ngDevMode === "undefined" || ngDevMode) && `Empty path url segment cannot have parameters: '${this.remaining}'.`);
        }
        this.capture(path);
        return new UrlSegment(decode(path), this.parseMatrixParams());
      }
      parseMatrixParams() {
        const params = {};
        while (this.consumeOptional(";")) {
          this.parseParam(params);
        }
        return params;
      }
      parseParam(params) {
        const key = matchMatrixKeySegments(this.remaining);
        if (!key) {
          return;
        }
        this.capture(key);
        let value = "";
        if (this.consumeOptional("=")) {
          const valueMatch = matchSegments(this.remaining);
          if (valueMatch) {
            value = valueMatch;
            this.capture(value);
          }
        }
        params[decode(key)] = decode(value);
      }
      // Parse a single query parameter `name[=value]`
      parseQueryParam(params) {
        const key = matchQueryParams(this.remaining);
        if (!key) {
          return;
        }
        this.capture(key);
        let value = "";
        if (this.consumeOptional("=")) {
          const valueMatch = matchUrlQueryParamValue(this.remaining);
          if (valueMatch) {
            value = valueMatch;
            this.capture(value);
          }
        }
        const decodedKey = decodeQuery(key);
        const decodedVal = decodeQuery(value);
        if (params.hasOwnProperty(decodedKey)) {
          let currentVal = params[decodedKey];
          if (!Array.isArray(currentVal)) {
            currentVal = [currentVal];
            params[decodedKey] = currentVal;
          }
          currentVal.push(decodedVal);
        } else {
          params[decodedKey] = decodedVal;
        }
      }
      // parse `(a/b//outlet_name:c/d)`
      parseParens(allowPrimary) {
        const segments = {};
        this.capture("(");
        while (!this.consumeOptional(")") && this.remaining.length > 0) {
          const path = matchSegments(this.remaining);
          const next = this.remaining[path.length];
          if (next !== "/" && next !== ")" && next !== ";") {
            throw new RuntimeError(4010, (typeof ngDevMode === "undefined" || ngDevMode) && `Cannot parse url '${this.url}'`);
          }
          let outletName = void 0;
          if (path.indexOf(":") > -1) {
            outletName = path.slice(0, path.indexOf(":"));
            this.capture(outletName);
            this.capture(":");
          } else if (allowPrimary) {
            outletName = PRIMARY_OUTLET;
          }
          const children = this.parseChildren();
          segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] : new UrlSegmentGroup([], children);
          this.consumeOptional("//");
        }
        return segments;
      }
      peekStartsWith(str) {
        return this.remaining.startsWith(str);
      }
      // Consumes the prefix when it is present and returns whether it has been consumed
      consumeOptional(str) {
        if (this.peekStartsWith(str)) {
          this.remaining = this.remaining.substring(str.length);
          return true;
        }
        return false;
      }
      capture(str) {
        if (!this.consumeOptional(str)) {
          throw new RuntimeError(4011, (typeof ngDevMode === "undefined" || ngDevMode) && `Expected "${str}".`);
        }
      }
    };
    Navigation = class {
      isAbsolute;
      numberOfDoubleDots;
      commands;
      constructor(isAbsolute, numberOfDoubleDots, commands) {
        this.isAbsolute = isAbsolute;
        this.numberOfDoubleDots = numberOfDoubleDots;
        this.commands = commands;
        if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {
          throw new RuntimeError(4003, (typeof ngDevMode === "undefined" || ngDevMode) && "Root segment cannot have matrix parameters");
        }
        const cmdWithOutlet = commands.find(isCommandWithOutlets);
        if (cmdWithOutlet && cmdWithOutlet !== last3(commands)) {
          throw new RuntimeError(4004, (typeof ngDevMode === "undefined" || ngDevMode) && "{outlets:{}} has to be the last command");
        }
      }
      toRoot() {
        return this.isAbsolute && this.commands.length === 1 && this.commands[0] == "/";
      }
    };
    Position = class {
      segmentGroup;
      processChildren;
      index;
      constructor(segmentGroup, processChildren, index) {
        this.segmentGroup = segmentGroup;
        this.processChildren = processChildren;
        this.index = index;
      }
    };
    IMPERATIVE_NAVIGATION = "imperative";
    (function(EventType2) {
      EventType2[EventType2["NavigationStart"] = 0] = "NavigationStart";
      EventType2[EventType2["NavigationEnd"] = 1] = "NavigationEnd";
      EventType2[EventType2["NavigationCancel"] = 2] = "NavigationCancel";
      EventType2[EventType2["NavigationError"] = 3] = "NavigationError";
      EventType2[EventType2["RoutesRecognized"] = 4] = "RoutesRecognized";
      EventType2[EventType2["ResolveStart"] = 5] = "ResolveStart";
      EventType2[EventType2["ResolveEnd"] = 6] = "ResolveEnd";
      EventType2[EventType2["GuardsCheckStart"] = 7] = "GuardsCheckStart";
      EventType2[EventType2["GuardsCheckEnd"] = 8] = "GuardsCheckEnd";
      EventType2[EventType2["RouteConfigLoadStart"] = 9] = "RouteConfigLoadStart";
      EventType2[EventType2["RouteConfigLoadEnd"] = 10] = "RouteConfigLoadEnd";
      EventType2[EventType2["ChildActivationStart"] = 11] = "ChildActivationStart";
      EventType2[EventType2["ChildActivationEnd"] = 12] = "ChildActivationEnd";
      EventType2[EventType2["ActivationStart"] = 13] = "ActivationStart";
      EventType2[EventType2["ActivationEnd"] = 14] = "ActivationEnd";
      EventType2[EventType2["Scroll"] = 15] = "Scroll";
      EventType2[EventType2["NavigationSkipped"] = 16] = "NavigationSkipped";
    })(EventType || (EventType = {}));
    RouterEvent = class {
      id;
      url;
      constructor(id2, url) {
        this.id = id2;
        this.url = url;
      }
    };
    NavigationStart = class extends RouterEvent {
      type = EventType.NavigationStart;
      /**
       * Identifies the call or event that triggered the navigation.
       * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.
       *
       * @see {@link NavigationEnd}
       * @see {@link NavigationCancel}
       * @see {@link NavigationError}
       */
      navigationTrigger;
      /**
       * The navigation state that was previously supplied to the `pushState` call,
       * when the navigation is triggered by a `popstate` event. Otherwise null.
       *
       * The state object is defined by `NavigationExtras`, and contains any
       * developer-defined state value, as well as a unique ID that
       * the router assigns to every router transition/navigation.
       *
       * From the perspective of the router, the router never "goes back".
       * When the user clicks on the back button in the browser,
       * a new navigation ID is created.
       *
       * Use the ID in this previous-state object to differentiate between a newly created
       * state and one returned to by a `popstate` event, so that you can restore some
       * remembered state, such as scroll position.
       *
       */
      restoredState;
      constructor(id2, url, navigationTrigger = "imperative", restoredState = null) {
        super(id2, url);
        this.navigationTrigger = navigationTrigger;
        this.restoredState = restoredState;
      }
      /** @docsNotRequired */
      toString() {
        return `NavigationStart(id: ${this.id}, url: '${this.url}')`;
      }
    };
    NavigationEnd = class extends RouterEvent {
      urlAfterRedirects;
      type = EventType.NavigationEnd;
      constructor(id2, url, urlAfterRedirects) {
        super(id2, url);
        this.urlAfterRedirects = urlAfterRedirects;
      }
      /** @docsNotRequired */
      toString() {
        return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;
      }
    };
    (function(NavigationCancellationCode2) {
      NavigationCancellationCode2[NavigationCancellationCode2["Redirect"] = 0] = "Redirect";
      NavigationCancellationCode2[NavigationCancellationCode2["SupersededByNewNavigation"] = 1] = "SupersededByNewNavigation";
      NavigationCancellationCode2[NavigationCancellationCode2["NoDataFromResolver"] = 2] = "NoDataFromResolver";
      NavigationCancellationCode2[NavigationCancellationCode2["GuardRejected"] = 3] = "GuardRejected";
      NavigationCancellationCode2[NavigationCancellationCode2["Aborted"] = 4] = "Aborted";
    })(NavigationCancellationCode || (NavigationCancellationCode = {}));
    (function(NavigationSkippedCode2) {
      NavigationSkippedCode2[NavigationSkippedCode2["IgnoredSameUrlNavigation"] = 0] = "IgnoredSameUrlNavigation";
      NavigationSkippedCode2[NavigationSkippedCode2["IgnoredByUrlHandlingStrategy"] = 1] = "IgnoredByUrlHandlingStrategy";
    })(NavigationSkippedCode || (NavigationSkippedCode = {}));
    NavigationCancel = class extends RouterEvent {
      reason;
      code;
      type = EventType.NavigationCancel;
      constructor(id2, url, reason, code) {
        super(id2, url);
        this.reason = reason;
        this.code = code;
      }
      /** @docsNotRequired */
      toString() {
        return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;
      }
    };
    NavigationSkipped = class extends RouterEvent {
      reason;
      code;
      type = EventType.NavigationSkipped;
      constructor(id2, url, reason, code) {
        super(id2, url);
        this.reason = reason;
        this.code = code;
      }
    };
    NavigationError = class extends RouterEvent {
      error;
      target;
      type = EventType.NavigationError;
      constructor(id2, url, error, target) {
        super(id2, url);
        this.error = error;
        this.target = target;
      }
      /** @docsNotRequired */
      toString() {
        return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;
      }
    };
    RoutesRecognized = class extends RouterEvent {
      urlAfterRedirects;
      state;
      type = EventType.RoutesRecognized;
      constructor(id2, url, urlAfterRedirects, state) {
        super(id2, url);
        this.urlAfterRedirects = urlAfterRedirects;
        this.state = state;
      }
      /** @docsNotRequired */
      toString() {
        return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
      }
    };
    GuardsCheckStart = class extends RouterEvent {
      urlAfterRedirects;
      state;
      type = EventType.GuardsCheckStart;
      constructor(id2, url, urlAfterRedirects, state) {
        super(id2, url);
        this.urlAfterRedirects = urlAfterRedirects;
        this.state = state;
      }
      toString() {
        return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
      }
    };
    GuardsCheckEnd = class extends RouterEvent {
      urlAfterRedirects;
      state;
      shouldActivate;
      type = EventType.GuardsCheckEnd;
      constructor(id2, url, urlAfterRedirects, state, shouldActivate) {
        super(id2, url);
        this.urlAfterRedirects = urlAfterRedirects;
        this.state = state;
        this.shouldActivate = shouldActivate;
      }
      toString() {
        return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;
      }
    };
    ResolveStart = class extends RouterEvent {
      urlAfterRedirects;
      state;
      type = EventType.ResolveStart;
      constructor(id2, url, urlAfterRedirects, state) {
        super(id2, url);
        this.urlAfterRedirects = urlAfterRedirects;
        this.state = state;
      }
      toString() {
        return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
      }
    };
    ResolveEnd = class extends RouterEvent {
      urlAfterRedirects;
      state;
      type = EventType.ResolveEnd;
      constructor(id2, url, urlAfterRedirects, state) {
        super(id2, url);
        this.urlAfterRedirects = urlAfterRedirects;
        this.state = state;
      }
      toString() {
        return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
      }
    };
    RouteConfigLoadStart = class {
      route;
      type = EventType.RouteConfigLoadStart;
      constructor(route) {
        this.route = route;
      }
      toString() {
        return `RouteConfigLoadStart(path: ${this.route.path})`;
      }
    };
    RouteConfigLoadEnd = class {
      route;
      type = EventType.RouteConfigLoadEnd;
      constructor(route) {
        this.route = route;
      }
      toString() {
        return `RouteConfigLoadEnd(path: ${this.route.path})`;
      }
    };
    ChildActivationStart = class {
      snapshot;
      type = EventType.ChildActivationStart;
      constructor(snapshot) {
        this.snapshot = snapshot;
      }
      toString() {
        const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
        return `ChildActivationStart(path: '${path}')`;
      }
    };
    ChildActivationEnd = class {
      snapshot;
      type = EventType.ChildActivationEnd;
      constructor(snapshot) {
        this.snapshot = snapshot;
      }
      toString() {
        const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
        return `ChildActivationEnd(path: '${path}')`;
      }
    };
    ActivationStart = class {
      snapshot;
      type = EventType.ActivationStart;
      constructor(snapshot) {
        this.snapshot = snapshot;
      }
      toString() {
        const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
        return `ActivationStart(path: '${path}')`;
      }
    };
    ActivationEnd = class {
      snapshot;
      type = EventType.ActivationEnd;
      constructor(snapshot) {
        this.snapshot = snapshot;
      }
      toString() {
        const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
        return `ActivationEnd(path: '${path}')`;
      }
    };
    Scroll = class {
      routerEvent;
      position;
      anchor;
      type = EventType.Scroll;
      constructor(routerEvent, position, anchor) {
        this.routerEvent = routerEvent;
        this.position = position;
        this.anchor = anchor;
      }
      toString() {
        const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;
        return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;
      }
    };
    BeforeActivateRoutes = class {
    };
    RedirectRequest = class {
      url;
      navigationBehaviorOptions;
      constructor(url, navigationBehaviorOptions) {
        this.url = url;
        this.navigationBehaviorOptions = navigationBehaviorOptions;
      }
    };
    OutletContext = class {
      rootInjector;
      outlet = null;
      route = null;
      children;
      attachRef = null;
      get injector() {
        return getClosestRouteInjector(this.route?.snapshot) ?? this.rootInjector;
      }
      constructor(rootInjector) {
        this.rootInjector = rootInjector;
        this.children = new ChildrenOutletContexts(this.rootInjector);
      }
    };
    ChildrenOutletContexts = class _ChildrenOutletContexts {
      rootInjector;
      // contexts for child outlets, by name.
      contexts = /* @__PURE__ */ new Map();
      /** @docs-private */
      constructor(rootInjector) {
        this.rootInjector = rootInjector;
      }
      /** Called when a `RouterOutlet` directive is instantiated */
      onChildOutletCreated(childName, outlet) {
        const context2 = this.getOrCreateContext(childName);
        context2.outlet = outlet;
        this.contexts.set(childName, context2);
      }
      /**
       * Called when a `RouterOutlet` directive is destroyed.
       * We need to keep the context as the outlet could be destroyed inside a NgIf and might be
       * re-created later.
       */
      onChildOutletDestroyed(childName) {
        const context2 = this.getContext(childName);
        if (context2) {
          context2.outlet = null;
          context2.attachRef = null;
        }
      }
      /**
       * Called when the corresponding route is deactivated during navigation.
       * Because the component get destroyed, all children outlet are destroyed.
       */
      onOutletDeactivated() {
        const contexts = this.contexts;
        this.contexts = /* @__PURE__ */ new Map();
        return contexts;
      }
      onOutletReAttached(contexts) {
        this.contexts = contexts;
      }
      getOrCreateContext(childName) {
        let context2 = this.getContext(childName);
        if (!context2) {
          context2 = new OutletContext(this.rootInjector);
          this.contexts.set(childName, context2);
        }
        return context2;
      }
      getContext(childName) {
        return this.contexts.get(childName) || null;
      }
      static \u0275fac = function ChildrenOutletContexts_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ChildrenOutletContexts)(\u0275\u0275inject(EnvironmentInjector));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _ChildrenOutletContexts,
        factory: _ChildrenOutletContexts.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChildrenOutletContexts, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [{
        type: EnvironmentInjector
      }], null);
    })();
    Tree = class {
      /** @internal */
      _root;
      constructor(root) {
        this._root = root;
      }
      get root() {
        return this._root.value;
      }
      /**
       * @internal
       */
      parent(t2) {
        const p = this.pathFromRoot(t2);
        return p.length > 1 ? p[p.length - 2] : null;
      }
      /**
       * @internal
       */
      children(t2) {
        const n = findNode(t2, this._root);
        return n ? n.children.map((t3) => t3.value) : [];
      }
      /**
       * @internal
       */
      firstChild(t2) {
        const n = findNode(t2, this._root);
        return n && n.children.length > 0 ? n.children[0].value : null;
      }
      /**
       * @internal
       */
      siblings(t2) {
        const p = findPath(t2, this._root);
        if (p.length < 2) return [];
        const c = p[p.length - 2].children.map((c2) => c2.value);
        return c.filter((cc) => cc !== t2);
      }
      /**
       * @internal
       */
      pathFromRoot(t2) {
        return findPath(t2, this._root).map((s) => s.value);
      }
    };
    TreeNode = class {
      value;
      children;
      constructor(value, children) {
        this.value = value;
        this.children = children;
      }
      toString() {
        return `TreeNode(${this.value})`;
      }
    };
    RouterState = class extends Tree {
      snapshot;
      /** @internal */
      constructor(root, snapshot) {
        super(root);
        this.snapshot = snapshot;
        setRouterState(this, root);
      }
      toString() {
        return this.snapshot.toString();
      }
    };
    ActivatedRoute = class {
      urlSubject;
      paramsSubject;
      queryParamsSubject;
      fragmentSubject;
      dataSubject;
      outlet;
      component;
      /** The current snapshot of this route */
      snapshot;
      /** @internal */
      _futureSnapshot;
      /** @internal */
      _routerState;
      /** @internal */
      _paramMap;
      /** @internal */
      _queryParamMap;
      /** An Observable of the resolved route title */
      title;
      /** An observable of the URL segments matched by this route. */
      url;
      /** An observable of the matrix parameters scoped to this route. */
      params;
      /** An observable of the query parameters shared by all the routes. */
      queryParams;
      /** An observable of the URL fragment shared by all the routes. */
      fragment;
      /** An observable of the static and resolved data of this route. */
      data;
      /** @internal */
      constructor(urlSubject, paramsSubject, queryParamsSubject, fragmentSubject, dataSubject, outlet, component, futureSnapshot) {
        this.urlSubject = urlSubject;
        this.paramsSubject = paramsSubject;
        this.queryParamsSubject = queryParamsSubject;
        this.fragmentSubject = fragmentSubject;
        this.dataSubject = dataSubject;
        this.outlet = outlet;
        this.component = component;
        this._futureSnapshot = futureSnapshot;
        this.title = this.dataSubject?.pipe(map((d) => d[RouteTitleKey])) ?? of(void 0);
        this.url = urlSubject;
        this.params = paramsSubject;
        this.queryParams = queryParamsSubject;
        this.fragment = fragmentSubject;
        this.data = dataSubject;
      }
      /** The configuration used to match this route. */
      get routeConfig() {
        return this._futureSnapshot.routeConfig;
      }
      /** The root of the router state. */
      get root() {
        return this._routerState.root;
      }
      /** The parent of this route in the router state tree. */
      get parent() {
        return this._routerState.parent(this);
      }
      /** The first child of this route in the router state tree. */
      get firstChild() {
        return this._routerState.firstChild(this);
      }
      /** The children of this route in the router state tree. */
      get children() {
        return this._routerState.children(this);
      }
      /** The path from the root of the router state tree to this route. */
      get pathFromRoot() {
        return this._routerState.pathFromRoot(this);
      }
      /**
       * An Observable that contains a map of the required and optional parameters
       * specific to the route.
       * The map supports retrieving single and multiple values from the same parameter.
       */
      get paramMap() {
        this._paramMap ??= this.params.pipe(map((p) => convertToParamMap(p)));
        return this._paramMap;
      }
      /**
       * An Observable that contains a map of the query parameters available to all routes.
       * The map supports retrieving single and multiple values from the query parameter.
       */
      get queryParamMap() {
        this._queryParamMap ??= this.queryParams.pipe(map((p) => convertToParamMap(p)));
        return this._queryParamMap;
      }
      toString() {
        return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;
      }
    };
    ActivatedRouteSnapshot = class {
      url;
      params;
      queryParams;
      fragment;
      data;
      outlet;
      component;
      /** The configuration used to match this route **/
      routeConfig;
      /** @internal */
      _resolve;
      /** @internal */
      _resolvedData;
      /** @internal */
      _routerState;
      /** @internal */
      _paramMap;
      /** @internal */
      _queryParamMap;
      /** The resolved route title */
      get title() {
        return this.data?.[RouteTitleKey];
      }
      /** @internal */
      constructor(url, params, queryParams, fragment, data2, outlet, component, routeConfig, resolve) {
        this.url = url;
        this.params = params;
        this.queryParams = queryParams;
        this.fragment = fragment;
        this.data = data2;
        this.outlet = outlet;
        this.component = component;
        this.routeConfig = routeConfig;
        this._resolve = resolve;
      }
      /** The root of the router state */
      get root() {
        return this._routerState.root;
      }
      /** The parent of this route in the router state tree */
      get parent() {
        return this._routerState.parent(this);
      }
      /** The first child of this route in the router state tree */
      get firstChild() {
        return this._routerState.firstChild(this);
      }
      /** The children of this route in the router state tree */
      get children() {
        return this._routerState.children(this);
      }
      /** The path from the root of the router state tree to this route */
      get pathFromRoot() {
        return this._routerState.pathFromRoot(this);
      }
      get paramMap() {
        this._paramMap ??= convertToParamMap(this.params);
        return this._paramMap;
      }
      get queryParamMap() {
        this._queryParamMap ??= convertToParamMap(this.queryParams);
        return this._queryParamMap;
      }
      toString() {
        const url = this.url.map((segment) => segment.toString()).join("/");
        const matched = this.routeConfig ? this.routeConfig.path : "";
        return `Route(url:'${url}', path:'${matched}')`;
      }
    };
    RouterStateSnapshot = class extends Tree {
      url;
      /** @internal */
      constructor(url, root) {
        super(root);
        this.url = url;
        setRouterState(this, root);
      }
      toString() {
        return serializeNode(this._root);
      }
    };
    ROUTER_OUTLET_DATA = new InjectionToken(ngDevMode ? "RouterOutlet data" : "");
    RouterOutlet = class _RouterOutlet {
      activated = null;
      /** @internal */
      get activatedComponentRef() {
        return this.activated;
      }
      _activatedRoute = null;
      /**
       * The name of the outlet
       *
       */
      name = PRIMARY_OUTLET;
      activateEvents = new EventEmitter();
      deactivateEvents = new EventEmitter();
      /**
       * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a
       * previously detached subtree.
       **/
      attachEvents = new EventEmitter();
      /**
       * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the
       * subtree.
       */
      detachEvents = new EventEmitter();
      /**
       * Data that will be provided to the child injector through the `ROUTER_OUTLET_DATA` token.
       *
       * When unset, the value of the token is `undefined` by default.
       */
      routerOutletData = input(void 0, ...ngDevMode ? [{
        debugName: "routerOutletData"
      }] : []);
      parentContexts = inject2(ChildrenOutletContexts);
      location = inject2(ViewContainerRef);
      changeDetector = inject2(ChangeDetectorRef);
      inputBinder = inject2(INPUT_BINDER, {
        optional: true
      });
      /** @docs-private */
      supportsBindingToComponentInputs = true;
      /** @docs-private */
      ngOnChanges(changes) {
        if (changes["name"]) {
          const {
            firstChange,
            previousValue
          } = changes["name"];
          if (firstChange) {
            return;
          }
          if (this.isTrackedInParentContexts(previousValue)) {
            this.deactivate();
            this.parentContexts.onChildOutletDestroyed(previousValue);
          }
          this.initializeOutletWithName();
        }
      }
      /** @docs-private */
      ngOnDestroy() {
        if (this.isTrackedInParentContexts(this.name)) {
          this.parentContexts.onChildOutletDestroyed(this.name);
        }
        this.inputBinder?.unsubscribeFromRouteData(this);
      }
      isTrackedInParentContexts(outletName) {
        return this.parentContexts.getContext(outletName)?.outlet === this;
      }
      /** @docs-private */
      ngOnInit() {
        this.initializeOutletWithName();
      }
      initializeOutletWithName() {
        this.parentContexts.onChildOutletCreated(this.name, this);
        if (this.activated) {
          return;
        }
        const context2 = this.parentContexts.getContext(this.name);
        if (context2?.route) {
          if (context2.attachRef) {
            this.attach(context2.attachRef, context2.route);
          } else {
            this.activateWith(context2.route, context2.injector);
          }
        }
      }
      get isActivated() {
        return !!this.activated;
      }
      /**
       * @returns The currently activated component instance.
       * @throws An error if the outlet is not activated.
       */
      get component() {
        if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === "undefined" || ngDevMode) && "Outlet is not activated");
        return this.activated.instance;
      }
      get activatedRoute() {
        if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === "undefined" || ngDevMode) && "Outlet is not activated");
        return this._activatedRoute;
      }
      get activatedRouteData() {
        if (this._activatedRoute) {
          return this._activatedRoute.snapshot.data;
        }
        return {};
      }
      /**
       * Called when the `RouteReuseStrategy` instructs to detach the subtree
       */
      detach() {
        if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === "undefined" || ngDevMode) && "Outlet is not activated");
        this.location.detach();
        const cmp = this.activated;
        this.activated = null;
        this._activatedRoute = null;
        this.detachEvents.emit(cmp.instance);
        return cmp;
      }
      /**
       * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
       */
      attach(ref, activatedRoute) {
        this.activated = ref;
        this._activatedRoute = activatedRoute;
        this.location.insert(ref.hostView);
        this.inputBinder?.bindActivatedRouteToOutletComponent(this);
        this.attachEvents.emit(ref.instance);
      }
      deactivate() {
        if (this.activated) {
          const c = this.component;
          this.activated.destroy();
          this.activated = null;
          this._activatedRoute = null;
          this.deactivateEvents.emit(c);
        }
      }
      activateWith(activatedRoute, environmentInjector) {
        if (this.isActivated) {
          throw new RuntimeError(4013, (typeof ngDevMode === "undefined" || ngDevMode) && "Cannot activate an already activated outlet");
        }
        this._activatedRoute = activatedRoute;
        const location2 = this.location;
        const snapshot = activatedRoute.snapshot;
        const component = snapshot.component;
        const childContexts = this.parentContexts.getOrCreateContext(this.name).children;
        const injector = new OutletInjector(activatedRoute, childContexts, location2.injector, this.routerOutletData);
        this.activated = location2.createComponent(component, {
          index: location2.length,
          injector,
          environmentInjector
        });
        this.changeDetector.markForCheck();
        this.inputBinder?.bindActivatedRouteToOutletComponent(this);
        this.activateEvents.emit(this.activated.instance);
      }
      static \u0275fac = function RouterOutlet_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _RouterOutlet)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _RouterOutlet,
        selectors: [["router-outlet"]],
        inputs: {
          name: "name",
          routerOutletData: [1, "routerOutletData"]
        },
        outputs: {
          activateEvents: "activate",
          deactivateEvents: "deactivate",
          attachEvents: "attach",
          detachEvents: "detach"
        },
        exportAs: ["outlet"],
        features: [\u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterOutlet, [{
        type: Directive,
        args: [{
          selector: "router-outlet",
          exportAs: "outlet"
        }]
      }], null, {
        name: [{
          type: Input
        }],
        activateEvents: [{
          type: Output,
          args: ["activate"]
        }],
        deactivateEvents: [{
          type: Output,
          args: ["deactivate"]
        }],
        attachEvents: [{
          type: Output,
          args: ["attach"]
        }],
        detachEvents: [{
          type: Output,
          args: ["detach"]
        }]
      });
    })();
    OutletInjector = class {
      route;
      childContexts;
      parent;
      outletData;
      constructor(route, childContexts, parent, outletData) {
        this.route = route;
        this.childContexts = childContexts;
        this.parent = parent;
        this.outletData = outletData;
      }
      get(token, notFoundValue) {
        if (token === ActivatedRoute) {
          return this.route;
        }
        if (token === ChildrenOutletContexts) {
          return this.childContexts;
        }
        if (token === ROUTER_OUTLET_DATA) {
          return this.outletData;
        }
        return this.parent.get(token, notFoundValue);
      }
    };
    INPUT_BINDER = new InjectionToken("");
    RoutedComponentInputBinder = class _RoutedComponentInputBinder {
      outletDataSubscriptions = /* @__PURE__ */ new Map();
      bindActivatedRouteToOutletComponent(outlet) {
        this.unsubscribeFromRouteData(outlet);
        this.subscribeToRouteData(outlet);
      }
      unsubscribeFromRouteData(outlet) {
        this.outletDataSubscriptions.get(outlet)?.unsubscribe();
        this.outletDataSubscriptions.delete(outlet);
      }
      subscribeToRouteData(outlet) {
        const {
          activatedRoute
        } = outlet;
        const dataSubscription = combineLatest([activatedRoute.queryParams, activatedRoute.params, activatedRoute.data]).pipe(switchMap(([queryParams, params, data2], index) => {
          data2 = __spreadValues(__spreadValues(__spreadValues({}, queryParams), params), data2);
          if (index === 0) {
            return of(data2);
          }
          return Promise.resolve(data2);
        })).subscribe((data2) => {
          if (!outlet.isActivated || !outlet.activatedComponentRef || outlet.activatedRoute !== activatedRoute || activatedRoute.component === null) {
            this.unsubscribeFromRouteData(outlet);
            return;
          }
          const mirror = reflectComponentType(activatedRoute.component);
          if (!mirror) {
            this.unsubscribeFromRouteData(outlet);
            return;
          }
          for (const {
            templateName
          } of mirror.inputs) {
            outlet.activatedComponentRef.setInput(templateName, data2[templateName]);
          }
        });
        this.outletDataSubscriptions.set(outlet, dataSubscription);
      }
      static \u0275fac = function RoutedComponentInputBinder_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _RoutedComponentInputBinder)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _RoutedComponentInputBinder,
        factory: _RoutedComponentInputBinder.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RoutedComponentInputBinder, [{
        type: Injectable
      }], null, null);
    })();
    \u0275EmptyOutletComponent = class _\u0275EmptyOutletComponent {
      static \u0275fac = function \u0275EmptyOutletComponent_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _\u0275EmptyOutletComponent)();
      };
      static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
        type: _\u0275EmptyOutletComponent,
        selectors: [["ng-component"]],
        exportAs: ["emptyRouterOutlet"],
        decls: 1,
        vars: 0,
        template: function _EmptyOutletComponent_Template(rf, ctx) {
          if (rf & 1) {
            \u0275\u0275element(0, "router-outlet");
          }
        },
        dependencies: [RouterOutlet],
        encapsulation: 2
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275EmptyOutletComponent, [{
        type: Component,
        args: [{
          template: `<router-outlet/>`,
          imports: [RouterOutlet],
          // Used to avoid component ID collisions with user code.
          exportAs: "emptyRouterOutlet"
        }]
      }], null, null);
    })();
    RedirectCommand = class {
      redirectTo;
      navigationBehaviorOptions;
      constructor(redirectTo, navigationBehaviorOptions) {
        this.redirectTo = redirectTo;
        this.navigationBehaviorOptions = navigationBehaviorOptions;
      }
    };
    NAVIGATION_CANCELING_ERROR = "ngNavigationCancelingError";
    warnedAboutUnsupportedInputBinding = false;
    activateRoutes = (rootContexts, routeReuseStrategy, forwardEvent, inputBindingEnabled) => map((t2) => {
      new ActivateRoutes(routeReuseStrategy, t2.targetRouterState, t2.currentRouterState, forwardEvent, inputBindingEnabled).activate(rootContexts);
      return t2;
    });
    ActivateRoutes = class {
      routeReuseStrategy;
      futureState;
      currState;
      forwardEvent;
      inputBindingEnabled;
      constructor(routeReuseStrategy, futureState, currState, forwardEvent, inputBindingEnabled) {
        this.routeReuseStrategy = routeReuseStrategy;
        this.futureState = futureState;
        this.currState = currState;
        this.forwardEvent = forwardEvent;
        this.inputBindingEnabled = inputBindingEnabled;
      }
      activate(parentContexts) {
        const futureRoot = this.futureState._root;
        const currRoot = this.currState ? this.currState._root : null;
        this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);
        advanceActivatedRoute(this.futureState.root);
        this.activateChildRoutes(futureRoot, currRoot, parentContexts);
      }
      // De-activate the child route that are not re-used for the future state
      deactivateChildRoutes(futureNode, currNode, contexts) {
        const children = nodeChildrenAsMap(currNode);
        futureNode.children.forEach((futureChild) => {
          const childOutletName = futureChild.value.outlet;
          this.deactivateRoutes(futureChild, children[childOutletName], contexts);
          delete children[childOutletName];
        });
        Object.values(children).forEach((v) => {
          this.deactivateRouteAndItsChildren(v, contexts);
        });
      }
      deactivateRoutes(futureNode, currNode, parentContext) {
        const future = futureNode.value;
        const curr = currNode ? currNode.value : null;
        if (future === curr) {
          if (future.component) {
            const context2 = parentContext.getContext(future.outlet);
            if (context2) {
              this.deactivateChildRoutes(futureNode, currNode, context2.children);
            }
          } else {
            this.deactivateChildRoutes(futureNode, currNode, parentContext);
          }
        } else {
          if (curr) {
            this.deactivateRouteAndItsChildren(currNode, parentContext);
          }
        }
      }
      deactivateRouteAndItsChildren(route, parentContexts) {
        if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {
          this.detachAndStoreRouteSubtree(route, parentContexts);
        } else {
          this.deactivateRouteAndOutlet(route, parentContexts);
        }
      }
      detachAndStoreRouteSubtree(route, parentContexts) {
        const context2 = parentContexts.getContext(route.value.outlet);
        const contexts = context2 && route.value.component ? context2.children : parentContexts;
        const children = nodeChildrenAsMap(route);
        for (const treeNode of Object.values(children)) {
          this.deactivateRouteAndItsChildren(treeNode, contexts);
        }
        if (context2 && context2.outlet) {
          const componentRef = context2.outlet.detach();
          const contexts2 = context2.children.onOutletDeactivated();
          this.routeReuseStrategy.store(route.value.snapshot, {
            componentRef,
            route,
            contexts: contexts2
          });
        }
      }
      deactivateRouteAndOutlet(route, parentContexts) {
        const context2 = parentContexts.getContext(route.value.outlet);
        const contexts = context2 && route.value.component ? context2.children : parentContexts;
        const children = nodeChildrenAsMap(route);
        for (const treeNode of Object.values(children)) {
          this.deactivateRouteAndItsChildren(treeNode, contexts);
        }
        if (context2) {
          if (context2.outlet) {
            context2.outlet.deactivate();
            context2.children.onOutletDeactivated();
          }
          context2.attachRef = null;
          context2.route = null;
        }
      }
      activateChildRoutes(futureNode, currNode, contexts) {
        const children = nodeChildrenAsMap(currNode);
        futureNode.children.forEach((c) => {
          this.activateRoutes(c, children[c.value.outlet], contexts);
          this.forwardEvent(new ActivationEnd(c.value.snapshot));
        });
        if (futureNode.children.length) {
          this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));
        }
      }
      activateRoutes(futureNode, currNode, parentContexts) {
        const future = futureNode.value;
        const curr = currNode ? currNode.value : null;
        advanceActivatedRoute(future);
        if (future === curr) {
          if (future.component) {
            const context2 = parentContexts.getOrCreateContext(future.outlet);
            this.activateChildRoutes(futureNode, currNode, context2.children);
          } else {
            this.activateChildRoutes(futureNode, currNode, parentContexts);
          }
        } else {
          if (future.component) {
            const context2 = parentContexts.getOrCreateContext(future.outlet);
            if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {
              const stored = this.routeReuseStrategy.retrieve(future.snapshot);
              this.routeReuseStrategy.store(future.snapshot, null);
              context2.children.onOutletReAttached(stored.contexts);
              context2.attachRef = stored.componentRef;
              context2.route = stored.route.value;
              if (context2.outlet) {
                context2.outlet.attach(stored.componentRef, stored.route.value);
              }
              advanceActivatedRoute(stored.route.value);
              this.activateChildRoutes(futureNode, null, context2.children);
            } else {
              context2.attachRef = null;
              context2.route = future;
              if (context2.outlet) {
                context2.outlet.activateWith(future, context2.injector);
              }
              this.activateChildRoutes(futureNode, null, context2.children);
            }
          } else {
            this.activateChildRoutes(futureNode, null, parentContexts);
          }
        }
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          const context2 = parentContexts.getOrCreateContext(future.outlet);
          const outlet = context2.outlet;
          if (outlet && this.inputBindingEnabled && !outlet.supportsBindingToComponentInputs && !warnedAboutUnsupportedInputBinding) {
            console.warn(`'withComponentInputBinding' feature is enabled but this application is using an outlet that may not support binding to component inputs.`);
            warnedAboutUnsupportedInputBinding = true;
          }
        }
      }
    };
    CanActivate = class {
      path;
      route;
      constructor(path) {
        this.path = path;
        this.route = this.path[this.path.length - 1];
      }
    };
    CanDeactivate = class {
      component;
      route;
      constructor(component, route) {
        this.component = component;
        this.route = route;
      }
    };
    INITIAL_VALUE = /* @__PURE__ */ Symbol("INITIAL_VALUE");
    NoMatch = class {
      segmentGroup;
      constructor(segmentGroup) {
        this.segmentGroup = segmentGroup || null;
      }
    };
    AbsoluteRedirect = class extends Error {
      urlTree;
      constructor(urlTree) {
        super();
        this.urlTree = urlTree;
      }
    };
    ApplyRedirects = class {
      urlSerializer;
      urlTree;
      constructor(urlSerializer, urlTree) {
        this.urlSerializer = urlSerializer;
        this.urlTree = urlTree;
      }
      lineralizeSegments(route, urlTree) {
        let res = [];
        let c = urlTree.root;
        while (true) {
          res = res.concat(c.segments);
          if (c.numberOfChildren === 0) {
            return of(res);
          }
          if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {
            return namedOutletsRedirect(`${route.redirectTo}`);
          }
          c = c.children[PRIMARY_OUTLET];
        }
      }
      applyRedirectCommands(segments, redirectTo, posParams, currentSnapshot, injector) {
        return getRedirectResult(redirectTo, currentSnapshot, injector).pipe(map((redirect) => {
          if (redirect instanceof UrlTree) {
            throw new AbsoluteRedirect(redirect);
          }
          const newTree = this.applyRedirectCreateUrlTree(redirect, this.urlSerializer.parse(redirect), segments, posParams);
          if (redirect[0] === "/") {
            throw new AbsoluteRedirect(newTree);
          }
          return newTree;
        }));
      }
      applyRedirectCreateUrlTree(redirectTo, urlTree, segments, posParams) {
        const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);
        return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);
      }
      createQueryParams(redirectToParams, actualParams) {
        const res = {};
        Object.entries(redirectToParams).forEach(([k, v]) => {
          const copySourceValue = typeof v === "string" && v[0] === ":";
          if (copySourceValue) {
            const sourceName = v.substring(1);
            res[k] = actualParams[sourceName];
          } else {
            res[k] = v;
          }
        });
        return res;
      }
      createSegmentGroup(redirectTo, group, segments, posParams) {
        const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);
        let children = {};
        Object.entries(group.children).forEach(([name2, child]) => {
          children[name2] = this.createSegmentGroup(redirectTo, child, segments, posParams);
        });
        return new UrlSegmentGroup(updatedSegments, children);
      }
      createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {
        return redirectToSegments.map((s) => s.path[0] === ":" ? this.findPosParam(redirectTo, s, posParams) : this.findOrReturn(s, actualSegments));
      }
      findPosParam(redirectTo, redirectToUrlSegment, posParams) {
        const pos = posParams[redirectToUrlSegment.path.substring(1)];
        if (!pos) throw new RuntimeError(4001, (typeof ngDevMode === "undefined" || ngDevMode) && `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);
        return pos;
      }
      findOrReturn(redirectToUrlSegment, actualSegments) {
        let idx = 0;
        for (const s of actualSegments) {
          if (s.path === redirectToUrlSegment.path) {
            actualSegments.splice(idx);
            return s;
          }
          idx++;
        }
        return redirectToUrlSegment;
      }
    };
    noMatch = {
      matched: false,
      consumedSegments: [],
      remainingSegments: [],
      parameters: {},
      positionalParamSegments: {}
    };
    NoLeftoversInUrl = class {
    };
    MAX_ALLOWED_REDIRECTS = 31;
    Recognizer = class {
      injector;
      configLoader;
      rootComponentType;
      config;
      urlTree;
      paramsInheritanceStrategy;
      urlSerializer;
      applyRedirects;
      absoluteRedirectCount = 0;
      allowRedirects = true;
      constructor(injector, configLoader, rootComponentType, config3, urlTree, paramsInheritanceStrategy, urlSerializer) {
        this.injector = injector;
        this.configLoader = configLoader;
        this.rootComponentType = rootComponentType;
        this.config = config3;
        this.urlTree = urlTree;
        this.paramsInheritanceStrategy = paramsInheritanceStrategy;
        this.urlSerializer = urlSerializer;
        this.applyRedirects = new ApplyRedirects(this.urlSerializer, this.urlTree);
      }
      noMatchError(e) {
        return new RuntimeError(4002, typeof ngDevMode === "undefined" || ngDevMode ? `Cannot match any routes. URL Segment: '${e.segmentGroup}'` : `'${e.segmentGroup}'`);
      }
      recognize() {
        const rootSegmentGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;
        return this.match(rootSegmentGroup).pipe(map(({
          children,
          rootSnapshot
        }) => {
          const rootNode = new TreeNode(rootSnapshot, children);
          const routeState = new RouterStateSnapshot("", rootNode);
          const tree2 = createUrlTreeFromSnapshot(rootSnapshot, [], this.urlTree.queryParams, this.urlTree.fragment);
          tree2.queryParams = this.urlTree.queryParams;
          routeState.url = this.urlSerializer.serialize(tree2);
          return {
            state: routeState,
            tree: tree2
          };
        }));
      }
      match(rootSegmentGroup) {
        const rootSnapshot = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, Object.freeze({}), PRIMARY_OUTLET, this.rootComponentType, null, {});
        return this.processSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET, rootSnapshot).pipe(map((children) => {
          return {
            children,
            rootSnapshot
          };
        }), catchError((e) => {
          if (e instanceof AbsoluteRedirect) {
            this.urlTree = e.urlTree;
            return this.match(e.urlTree.root);
          }
          if (e instanceof NoMatch) {
            throw this.noMatchError(e);
          }
          throw e;
        }));
      }
      processSegmentGroup(injector, config3, segmentGroup, outlet, parentRoute) {
        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
          return this.processChildren(injector, config3, segmentGroup, parentRoute);
        }
        return this.processSegment(injector, config3, segmentGroup, segmentGroup.segments, outlet, true, parentRoute).pipe(map((child) => child instanceof TreeNode ? [child] : []));
      }
      /**
       * Matches every child outlet in the `segmentGroup` to a `Route` in the config. Returns `null` if
       * we cannot find a match for _any_ of the children.
       *
       * @param config - The `Routes` to match against
       * @param segmentGroup - The `UrlSegmentGroup` whose children need to be matched against the
       *     config.
       */
      processChildren(injector, config3, segmentGroup, parentRoute) {
        const childOutlets = [];
        for (const child of Object.keys(segmentGroup.children)) {
          if (child === "primary") {
            childOutlets.unshift(child);
          } else {
            childOutlets.push(child);
          }
        }
        return from(childOutlets).pipe(concatMap((childOutlet) => {
          const child = segmentGroup.children[childOutlet];
          const sortedConfig = sortByMatchingOutlets(config3, childOutlet);
          return this.processSegmentGroup(injector, sortedConfig, child, childOutlet, parentRoute);
        }), scan((children, outletChildren) => {
          children.push(...outletChildren);
          return children;
        }), defaultIfEmpty(null), last2(), mergeMap((children) => {
          if (children === null) return noMatch$1(segmentGroup);
          const mergedChildren = mergeEmptyPathMatches(children);
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            checkOutletNameUniqueness(mergedChildren);
          }
          sortActivatedRouteSnapshots(mergedChildren);
          return of(mergedChildren);
        }));
      }
      processSegment(injector, routes2, segmentGroup, segments, outlet, allowRedirects, parentRoute) {
        return from(routes2).pipe(concatMap((r) => {
          return this.processSegmentAgainstRoute(r._injector ?? injector, routes2, r, segmentGroup, segments, outlet, allowRedirects, parentRoute).pipe(catchError((e) => {
            if (e instanceof NoMatch) {
              return of(null);
            }
            throw e;
          }));
        }), first((x) => !!x), catchError((e) => {
          if (isEmptyError(e)) {
            if (noLeftoversInUrl(segmentGroup, segments, outlet)) {
              return of(new NoLeftoversInUrl());
            }
            return noMatch$1(segmentGroup);
          }
          throw e;
        }));
      }
      processSegmentAgainstRoute(injector, routes2, route, rawSegment, segments, outlet, allowRedirects, parentRoute) {
        if (getOutlet(route) !== outlet && (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {
          return noMatch$1(rawSegment);
        }
        if (route.redirectTo === void 0) {
          return this.matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute);
        }
        if (this.allowRedirects && allowRedirects) {
          return this.expandSegmentAgainstRouteUsingRedirect(injector, rawSegment, routes2, route, segments, outlet, parentRoute);
        }
        return noMatch$1(rawSegment);
      }
      expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes2, route, segments, outlet, parentRoute) {
        const {
          matched,
          parameters,
          consumedSegments,
          positionalParamSegments,
          remainingSegments
        } = match(segmentGroup, route, segments);
        if (!matched) return noMatch$1(segmentGroup);
        if (typeof route.redirectTo === "string" && route.redirectTo[0] === "/") {
          this.absoluteRedirectCount++;
          if (this.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS) {
            if (ngDevMode) {
              throw new RuntimeError(4016, `Detected possible infinite redirect when redirecting from '${this.urlTree}' to '${route.redirectTo}'.
This is currently a dev mode only error but will become a call stack size exceeded error in production in a future major version.`);
            }
            this.allowRedirects = false;
          }
        }
        const currentSnapshot = new ActivatedRouteSnapshot(segments, parameters, Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));
        const inherited = getInherited(currentSnapshot, parentRoute, this.paramsInheritanceStrategy);
        currentSnapshot.params = Object.freeze(inherited.params);
        currentSnapshot.data = Object.freeze(inherited.data);
        const newTree$ = this.applyRedirects.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments, currentSnapshot, injector);
        return newTree$.pipe(switchMap((newTree) => this.applyRedirects.lineralizeSegments(route, newTree)), mergeMap((newSegments) => {
          return this.processSegment(injector, routes2, segmentGroup, newSegments.concat(remainingSegments), outlet, false, parentRoute);
        }));
      }
      matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute) {
        const matchResult = matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer);
        if (route.path === "**") {
          rawSegment.children = {};
        }
        return matchResult.pipe(switchMap((result) => {
          if (!result.matched) {
            return noMatch$1(rawSegment);
          }
          injector = route._injector ?? injector;
          return this.getChildConfig(injector, route, segments).pipe(switchMap(({
            routes: childConfig
          }) => {
            const childInjector = route._loadedInjector ?? injector;
            const {
              parameters,
              consumedSegments,
              remainingSegments
            } = result;
            const snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));
            const inherited = getInherited(snapshot, parentRoute, this.paramsInheritanceStrategy);
            snapshot.params = Object.freeze(inherited.params);
            snapshot.data = Object.freeze(inherited.data);
            const {
              segmentGroup,
              slicedSegments
            } = split(rawSegment, consumedSegments, remainingSegments, childConfig);
            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
              return this.processChildren(childInjector, childConfig, segmentGroup, snapshot).pipe(map((children) => {
                return new TreeNode(snapshot, children);
              }));
            }
            if (childConfig.length === 0 && slicedSegments.length === 0) {
              return of(new TreeNode(snapshot, []));
            }
            const matchedOnOutlet = getOutlet(route) === outlet;
            return this.processSegment(childInjector, childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet, true, snapshot).pipe(map((child) => {
              return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);
            }));
          }));
        }));
      }
      getChildConfig(injector, route, segments) {
        if (route.children) {
          return of({
            routes: route.children,
            injector
          });
        }
        if (route.loadChildren) {
          if (route._loadedRoutes !== void 0) {
            return of({
              routes: route._loadedRoutes,
              injector: route._loadedInjector
            });
          }
          return runCanLoadGuards(injector, route, segments, this.urlSerializer).pipe(mergeMap((shouldLoadResult) => {
            if (shouldLoadResult) {
              return this.configLoader.loadChildren(injector, route).pipe(tap((cfg) => {
                route._loadedRoutes = cfg.routes;
                route._loadedInjector = cfg.injector;
              }));
            }
            return canLoadFails(route);
          }));
        }
        return of({
          routes: [],
          injector
        });
      }
    };
    TitleStrategy = class _TitleStrategy {
      /**
       * @returns The `title` of the deepest primary route.
       */
      buildTitle(snapshot) {
        let pageTitle;
        let route = snapshot.root;
        while (route !== void 0) {
          pageTitle = this.getResolvedTitleForRoute(route) ?? pageTitle;
          route = route.children.find((child) => child.outlet === PRIMARY_OUTLET);
        }
        return pageTitle;
      }
      /**
       * Given an `ActivatedRouteSnapshot`, returns the final value of the
       * `Route.title` property, which can either be a static string or a resolved value.
       */
      getResolvedTitleForRoute(snapshot) {
        return snapshot.data[RouteTitleKey];
      }
      static \u0275fac = function TitleStrategy_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _TitleStrategy)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _TitleStrategy,
        factory: () => (() => inject2(DefaultTitleStrategy))(),
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TitleStrategy, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: () => inject2(DefaultTitleStrategy)
        }]
      }], null, null);
    })();
    DefaultTitleStrategy = class _DefaultTitleStrategy extends TitleStrategy {
      title;
      constructor(title) {
        super();
        this.title = title;
      }
      /**
       * Sets the title of the browser to the given value.
       *
       * @param title The `pageTitle` from the deepest primary route.
       */
      updateTitle(snapshot) {
        const title = this.buildTitle(snapshot);
        if (title !== void 0) {
          this.title.setTitle(title);
        }
      }
      static \u0275fac = function DefaultTitleStrategy_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DefaultTitleStrategy)(\u0275\u0275inject(Title));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _DefaultTitleStrategy,
        factory: _DefaultTitleStrategy.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultTitleStrategy, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [{
        type: Title
      }], null);
    })();
    ROUTER_CONFIGURATION = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "router config" : "", {
      providedIn: "root",
      factory: () => ({})
    });
    ROUTES = new InjectionToken(ngDevMode ? "ROUTES" : "");
    RouterConfigLoader = class _RouterConfigLoader {
      componentLoaders = /* @__PURE__ */ new WeakMap();
      childrenLoaders = /* @__PURE__ */ new WeakMap();
      onLoadStartListener;
      onLoadEndListener;
      compiler = inject2(Compiler);
      loadComponent(injector, route) {
        if (this.componentLoaders.get(route)) {
          return this.componentLoaders.get(route);
        } else if (route._loadedComponent) {
          return of(route._loadedComponent);
        }
        if (this.onLoadStartListener) {
          this.onLoadStartListener(route);
        }
        const loadRunner = wrapIntoObservable(runInInjectionContext(injector, () => route.loadComponent())).pipe(map(maybeUnwrapDefaultExport), switchMap(maybeResolveResources), tap((component) => {
          if (this.onLoadEndListener) {
            this.onLoadEndListener(route);
          }
          (typeof ngDevMode === "undefined" || ngDevMode) && assertStandalone(route.path ?? "", component);
          route._loadedComponent = component;
        }), finalize(() => {
          this.componentLoaders.delete(route);
        }));
        const loader = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());
        this.componentLoaders.set(route, loader);
        return loader;
      }
      loadChildren(parentInjector, route) {
        if (this.childrenLoaders.get(route)) {
          return this.childrenLoaders.get(route);
        } else if (route._loadedRoutes) {
          return of({
            routes: route._loadedRoutes,
            injector: route._loadedInjector
          });
        }
        if (this.onLoadStartListener) {
          this.onLoadStartListener(route);
        }
        const moduleFactoryOrRoutes$ = loadChildren(route, this.compiler, parentInjector, this.onLoadEndListener);
        const loadRunner = moduleFactoryOrRoutes$.pipe(finalize(() => {
          this.childrenLoaders.delete(route);
        }));
        const loader = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());
        this.childrenLoaders.set(route, loader);
        return loader;
      }
      static \u0275fac = function RouterConfigLoader_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _RouterConfigLoader)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _RouterConfigLoader,
        factory: _RouterConfigLoader.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterConfigLoader, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    UrlHandlingStrategy = class _UrlHandlingStrategy {
      static \u0275fac = function UrlHandlingStrategy_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _UrlHandlingStrategy)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _UrlHandlingStrategy,
        factory: () => (() => inject2(DefaultUrlHandlingStrategy))(),
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UrlHandlingStrategy, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: () => inject2(DefaultUrlHandlingStrategy)
        }]
      }], null, null);
    })();
    DefaultUrlHandlingStrategy = class _DefaultUrlHandlingStrategy {
      shouldProcessUrl(url) {
        return true;
      }
      extract(url) {
        return url;
      }
      merge(newUrlPart, wholeUrl) {
        return newUrlPart;
      }
      static \u0275fac = function DefaultUrlHandlingStrategy_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DefaultUrlHandlingStrategy)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _DefaultUrlHandlingStrategy,
        factory: _DefaultUrlHandlingStrategy.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultUrlHandlingStrategy, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    CREATE_VIEW_TRANSITION = new InjectionToken(ngDevMode ? "view transition helper" : "");
    VIEW_TRANSITION_OPTIONS = new InjectionToken(ngDevMode ? "view transition options" : "");
    NAVIGATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "navigation error handler" : "");
    NavigationTransitions = class _NavigationTransitions {
      currentNavigation = null;
      currentTransition = null;
      lastSuccessfulNavigation = null;
      /**
       * These events are used to communicate back to the Router about the state of the transition. The
       * Router wants to respond to these events in various ways. Because the `NavigationTransition`
       * class is not public, this event subject is not publicly exposed.
       */
      events = new Subject();
      /**
       * Used to abort the current transition with an error.
       */
      transitionAbortWithErrorSubject = new Subject();
      configLoader = inject2(RouterConfigLoader);
      environmentInjector = inject2(EnvironmentInjector);
      destroyRef = inject2(DestroyRef);
      urlSerializer = inject2(UrlSerializer);
      rootContexts = inject2(ChildrenOutletContexts);
      location = inject2(Location);
      inputBindingEnabled = inject2(INPUT_BINDER, {
        optional: true
      }) !== null;
      titleStrategy = inject2(TitleStrategy);
      options = inject2(ROUTER_CONFIGURATION, {
        optional: true
      }) || {};
      paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly";
      urlHandlingStrategy = inject2(UrlHandlingStrategy);
      createViewTransition = inject2(CREATE_VIEW_TRANSITION, {
        optional: true
      });
      navigationErrorHandler = inject2(NAVIGATION_ERROR_HANDLER, {
        optional: true
      });
      navigationId = 0;
      get hasRequestedNavigation() {
        return this.navigationId !== 0;
      }
      transitions;
      /**
       * Hook that enables you to pause navigation after the preactivation phase.
       * Used by `RouterModule`.
       *
       * @internal
       */
      afterPreactivation = () => of(void 0);
      /** @internal */
      rootComponentType = null;
      destroyed = false;
      constructor() {
        const onLoadStart = (r) => this.events.next(new RouteConfigLoadStart(r));
        const onLoadEnd = (r) => this.events.next(new RouteConfigLoadEnd(r));
        this.configLoader.onLoadEndListener = onLoadEnd;
        this.configLoader.onLoadStartListener = onLoadStart;
        this.destroyRef.onDestroy(() => {
          this.destroyed = true;
        });
      }
      complete() {
        this.transitions?.complete();
      }
      handleNavigationRequest(request) {
        const id2 = ++this.navigationId;
        this.transitions?.next(__spreadProps(__spreadValues({}, request), {
          extractedUrl: this.urlHandlingStrategy.extract(request.rawUrl),
          targetSnapshot: null,
          targetRouterState: null,
          guards: {
            canActivateChecks: [],
            canDeactivateChecks: []
          },
          guardsResult: null,
          abortController: new AbortController(),
          id: id2
        }));
      }
      setupNavigations(router) {
        this.transitions = new BehaviorSubject(null);
        return this.transitions.pipe(
          filter((t2) => t2 !== null),
          // Using switchMap so we cancel executing navigations when a new one comes in
          switchMap((overallTransitionState) => {
            let completedOrAborted = false;
            return of(overallTransitionState).pipe(
              switchMap((t2) => {
                if (this.navigationId > overallTransitionState.id) {
                  const cancellationReason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : "";
                  this.cancelNavigationTransition(overallTransitionState, cancellationReason, NavigationCancellationCode.SupersededByNewNavigation);
                  return EMPTY;
                }
                this.currentTransition = overallTransitionState;
                this.currentNavigation = {
                  id: t2.id,
                  initialUrl: t2.rawUrl,
                  extractedUrl: t2.extractedUrl,
                  targetBrowserUrl: typeof t2.extras.browserUrl === "string" ? this.urlSerializer.parse(t2.extras.browserUrl) : t2.extras.browserUrl,
                  trigger: t2.source,
                  extras: t2.extras,
                  previousNavigation: !this.lastSuccessfulNavigation ? null : __spreadProps(__spreadValues({}, this.lastSuccessfulNavigation), {
                    previousNavigation: null
                  }),
                  abort: () => t2.abortController.abort()
                };
                const urlTransition = !router.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl();
                const onSameUrlNavigation = t2.extras.onSameUrlNavigation ?? router.onSameUrlNavigation;
                if (!urlTransition && onSameUrlNavigation !== "reload") {
                  const reason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation to ${t2.rawUrl} was ignored because it is the same as the current Router URL.` : "";
                  this.events.next(new NavigationSkipped(t2.id, this.urlSerializer.serialize(t2.rawUrl), reason, NavigationSkippedCode.IgnoredSameUrlNavigation));
                  t2.resolve(false);
                  return EMPTY;
                }
                if (this.urlHandlingStrategy.shouldProcessUrl(t2.rawUrl)) {
                  return of(t2).pipe(
                    // Fire NavigationStart event
                    switchMap((t3) => {
                      this.events.next(new NavigationStart(t3.id, this.urlSerializer.serialize(t3.extractedUrl), t3.source, t3.restoredState));
                      if (t3.id !== this.navigationId) {
                        return EMPTY;
                      }
                      return Promise.resolve(t3);
                    }),
                    // Recognize
                    recognize(this.environmentInjector, this.configLoader, this.rootComponentType, router.config, this.urlSerializer, this.paramsInheritanceStrategy),
                    // Update URL if in `eager` update mode
                    tap((t3) => {
                      overallTransitionState.targetSnapshot = t3.targetSnapshot;
                      overallTransitionState.urlAfterRedirects = t3.urlAfterRedirects;
                      this.currentNavigation = __spreadProps(__spreadValues({}, this.currentNavigation), {
                        finalUrl: t3.urlAfterRedirects
                      });
                      const routesRecognized = new RoutesRecognized(t3.id, this.urlSerializer.serialize(t3.extractedUrl), this.urlSerializer.serialize(t3.urlAfterRedirects), t3.targetSnapshot);
                      this.events.next(routesRecognized);
                    })
                  );
                } else if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(t2.currentRawUrl)) {
                  const {
                    id: id2,
                    extractedUrl,
                    source,
                    restoredState,
                    extras
                  } = t2;
                  const navStart = new NavigationStart(id2, this.urlSerializer.serialize(extractedUrl), source, restoredState);
                  this.events.next(navStart);
                  const targetSnapshot = createEmptyState(this.rootComponentType).snapshot;
                  this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t2), {
                    targetSnapshot,
                    urlAfterRedirects: extractedUrl,
                    extras: __spreadProps(__spreadValues({}, extras), {
                      skipLocationChange: false,
                      replaceUrl: false
                    })
                  });
                  this.currentNavigation.finalUrl = extractedUrl;
                  return of(overallTransitionState);
                } else {
                  const reason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation was ignored because the UrlHandlingStrategy indicated neither the current URL ${t2.currentRawUrl} nor target URL ${t2.rawUrl} should be processed.` : "";
                  this.events.next(new NavigationSkipped(t2.id, this.urlSerializer.serialize(t2.extractedUrl), reason, NavigationSkippedCode.IgnoredByUrlHandlingStrategy));
                  t2.resolve(false);
                  return EMPTY;
                }
              }),
              // --- GUARDS ---
              tap((t2) => {
                const guardsStart = new GuardsCheckStart(t2.id, this.urlSerializer.serialize(t2.extractedUrl), this.urlSerializer.serialize(t2.urlAfterRedirects), t2.targetSnapshot);
                this.events.next(guardsStart);
              }),
              map((t2) => {
                this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t2), {
                  guards: getAllRouteGuards(t2.targetSnapshot, t2.currentSnapshot, this.rootContexts)
                });
                return overallTransitionState;
              }),
              checkGuards(this.environmentInjector, (evt) => this.events.next(evt)),
              tap((t2) => {
                overallTransitionState.guardsResult = t2.guardsResult;
                if (t2.guardsResult && typeof t2.guardsResult !== "boolean") {
                  throw redirectingNavigationError(this.urlSerializer, t2.guardsResult);
                }
                const guardsEnd = new GuardsCheckEnd(t2.id, this.urlSerializer.serialize(t2.extractedUrl), this.urlSerializer.serialize(t2.urlAfterRedirects), t2.targetSnapshot, !!t2.guardsResult);
                this.events.next(guardsEnd);
              }),
              filter((t2) => {
                if (!t2.guardsResult) {
                  this.cancelNavigationTransition(t2, "", NavigationCancellationCode.GuardRejected);
                  return false;
                }
                return true;
              }),
              // --- RESOLVE ---
              switchTap((t2) => {
                if (t2.guards.canActivateChecks.length === 0) {
                  return void 0;
                }
                return of(t2).pipe(tap((t3) => {
                  const resolveStart = new ResolveStart(t3.id, this.urlSerializer.serialize(t3.extractedUrl), this.urlSerializer.serialize(t3.urlAfterRedirects), t3.targetSnapshot);
                  this.events.next(resolveStart);
                }), switchMap((t3) => {
                  let dataResolved = false;
                  return of(t3).pipe(resolveData(this.paramsInheritanceStrategy, this.environmentInjector), tap({
                    next: () => dataResolved = true,
                    complete: () => {
                      if (!dataResolved) {
                        this.cancelNavigationTransition(t3, typeof ngDevMode === "undefined" || ngDevMode ? `At least one route resolver didn't emit any value.` : "", NavigationCancellationCode.NoDataFromResolver);
                      }
                    }
                  }));
                }), tap((t3) => {
                  const resolveEnd = new ResolveEnd(t3.id, this.urlSerializer.serialize(t3.extractedUrl), this.urlSerializer.serialize(t3.urlAfterRedirects), t3.targetSnapshot);
                  this.events.next(resolveEnd);
                }));
              }),
              // --- LOAD COMPONENTS ---
              switchTap((t2) => {
                const loadComponents = (route) => {
                  const loaders = [];
                  if (route.routeConfig?.loadComponent && !route.routeConfig._loadedComponent) {
                    const injector = getClosestRouteInjector(route) ?? this.environmentInjector;
                    loaders.push(this.configLoader.loadComponent(injector, route.routeConfig).pipe(tap((loadedComponent) => {
                      route.component = loadedComponent;
                    }), map(() => void 0)));
                  }
                  for (const child of route.children) {
                    loaders.push(...loadComponents(child));
                  }
                  return loaders;
                };
                return combineLatest(loadComponents(t2.targetSnapshot.root)).pipe(defaultIfEmpty(null), take(1));
              }),
              switchTap(() => this.afterPreactivation()),
              switchMap(() => {
                const {
                  currentSnapshot,
                  targetSnapshot
                } = overallTransitionState;
                const viewTransitionStarted = this.createViewTransition?.(this.environmentInjector, currentSnapshot.root, targetSnapshot.root);
                return viewTransitionStarted ? from(viewTransitionStarted).pipe(map(() => overallTransitionState)) : of(overallTransitionState);
              }),
              map((t2) => {
                const targetRouterState = createRouterState(router.routeReuseStrategy, t2.targetSnapshot, t2.currentRouterState);
                this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t2), {
                  targetRouterState
                });
                this.currentNavigation.targetRouterState = targetRouterState;
                return overallTransitionState;
              }),
              tap(() => {
                this.events.next(new BeforeActivateRoutes());
              }),
              activateRoutes(this.rootContexts, router.routeReuseStrategy, (evt) => this.events.next(evt), this.inputBindingEnabled),
              // Ensure that if some observable used to drive the transition doesn't
              // complete, the navigation still finalizes This should never happen, but
              // this is done as a safety measure to avoid surfacing this error (#49567).
              take(1),
              takeUntil(new Observable((subscriber) => {
                const abortSignal = overallTransitionState.abortController.signal;
                const handler = () => subscriber.next();
                abortSignal.addEventListener("abort", handler);
                return () => abortSignal.removeEventListener("abort", handler);
              }).pipe(
                // Ignore aborts if we are already completed, canceled, or are in the activation stage (we have targetRouterState)
                filter(() => !completedOrAborted && !overallTransitionState.targetRouterState),
                tap(() => {
                  this.cancelNavigationTransition(overallTransitionState, overallTransitionState.abortController.signal.reason + "", NavigationCancellationCode.Aborted);
                })
              )),
              tap({
                next: (t2) => {
                  completedOrAborted = true;
                  this.lastSuccessfulNavigation = this.currentNavigation;
                  this.events.next(new NavigationEnd(t2.id, this.urlSerializer.serialize(t2.extractedUrl), this.urlSerializer.serialize(t2.urlAfterRedirects)));
                  this.titleStrategy?.updateTitle(t2.targetRouterState.snapshot);
                  t2.resolve(true);
                },
                complete: () => {
                  completedOrAborted = true;
                }
              }),
              // There used to be a lot more logic happening directly within the
              // transition Observable. Some of this logic has been refactored out to
              // other places but there may still be errors that happen there. This gives
              // us a way to cancel the transition from the outside. This may also be
              // required in the future to support something like the abort signal of the
              // Navigation API where the navigation gets aborted from outside the
              // transition.
              takeUntil(this.transitionAbortWithErrorSubject.pipe(tap((err) => {
                throw err;
              }))),
              finalize(() => {
                if (!completedOrAborted) {
                  const cancelationReason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : "";
                  this.cancelNavigationTransition(overallTransitionState, cancelationReason, NavigationCancellationCode.SupersededByNewNavigation);
                }
                if (this.currentTransition?.id === overallTransitionState.id) {
                  this.currentNavigation = null;
                  this.currentTransition = null;
                }
              }),
              catchError((e) => {
                if (this.destroyed) {
                  overallTransitionState.resolve(false);
                  return EMPTY;
                }
                completedOrAborted = true;
                if (isNavigationCancelingError(e)) {
                  this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e.message, e.cancellationCode));
                  if (!isRedirectingNavigationCancelingError(e)) {
                    overallTransitionState.resolve(false);
                  } else {
                    this.events.next(new RedirectRequest(e.url, e.navigationBehaviorOptions));
                  }
                } else {
                  const navigationError = new NavigationError(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e, overallTransitionState.targetSnapshot ?? void 0);
                  try {
                    const navigationErrorHandlerResult = runInInjectionContext(this.environmentInjector, () => this.navigationErrorHandler?.(navigationError));
                    if (navigationErrorHandlerResult instanceof RedirectCommand) {
                      const {
                        message,
                        cancellationCode
                      } = redirectingNavigationError(this.urlSerializer, navigationErrorHandlerResult);
                      this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), message, cancellationCode));
                      this.events.next(new RedirectRequest(navigationErrorHandlerResult.redirectTo, navigationErrorHandlerResult.navigationBehaviorOptions));
                    } else {
                      this.events.next(navigationError);
                      throw e;
                    }
                  } catch (ee) {
                    if (this.options.resolveNavigationPromiseOnError) {
                      overallTransitionState.resolve(false);
                    } else {
                      overallTransitionState.reject(ee);
                    }
                  }
                }
                return EMPTY;
              })
            );
          })
        );
      }
      cancelNavigationTransition(t2, reason, code) {
        const navCancel = new NavigationCancel(t2.id, this.urlSerializer.serialize(t2.extractedUrl), reason, code);
        this.events.next(navCancel);
        t2.resolve(false);
      }
      /**
       * @returns Whether we're navigating to somewhere that is not what the Router is
       * currently set to.
       */
      isUpdatingInternalState() {
        return this.currentTransition?.extractedUrl.toString() !== this.currentTransition?.currentUrlTree.toString();
      }
      /**
       * @returns Whether we're updating the browser URL to something new (navigation is going
       * to somewhere not displayed in the URL bar and we will update the URL
       * bar if navigation succeeds).
       */
      isUpdatedBrowserUrl() {
        const currentBrowserUrl = this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(true)));
        const targetBrowserUrl = this.currentNavigation?.targetBrowserUrl ?? this.currentNavigation?.extractedUrl;
        return currentBrowserUrl.toString() !== targetBrowserUrl?.toString() && !this.currentNavigation?.extras.skipLocationChange;
      }
      static \u0275fac = function NavigationTransitions_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NavigationTransitions)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _NavigationTransitions,
        factory: _NavigationTransitions.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationTransitions, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [], null);
    })();
    RouteReuseStrategy = class _RouteReuseStrategy {
      static \u0275fac = function RouteReuseStrategy_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _RouteReuseStrategy)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _RouteReuseStrategy,
        factory: () => (() => inject2(DefaultRouteReuseStrategy))(),
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouteReuseStrategy, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: () => inject2(DefaultRouteReuseStrategy)
        }]
      }], null, null);
    })();
    BaseRouteReuseStrategy = class {
      /**
       * Whether the given route should detach for later reuse.
       * Always returns false for `BaseRouteReuseStrategy`.
       * */
      shouldDetach(route) {
        return false;
      }
      /**
       * A no-op; the route is never stored since this strategy never detaches routes for later re-use.
       */
      store(route, detachedTree) {
      }
      /** Returns `false`, meaning the route (and its subtree) is never reattached */
      shouldAttach(route) {
        return false;
      }
      /** Returns `null` because this strategy does not store routes for later re-use. */
      retrieve(route) {
        return null;
      }
      /**
       * Determines if a route should be reused.
       * This strategy returns `true` when the future route config and current route config are
       * identical.
       */
      shouldReuseRoute(future, curr) {
        return future.routeConfig === curr.routeConfig;
      }
    };
    DefaultRouteReuseStrategy = class _DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275DefaultRouteReuseStrategy_BaseFactory;
        return function DefaultRouteReuseStrategy_Factory(__ngFactoryType__) {
          return (\u0275DefaultRouteReuseStrategy_BaseFactory || (\u0275DefaultRouteReuseStrategy_BaseFactory = \u0275\u0275getInheritedFactory(_DefaultRouteReuseStrategy)))(__ngFactoryType__ || _DefaultRouteReuseStrategy);
        };
      })();
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _DefaultRouteReuseStrategy,
        factory: _DefaultRouteReuseStrategy.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultRouteReuseStrategy, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    StateManager = class _StateManager {
      urlSerializer = inject2(UrlSerializer);
      options = inject2(ROUTER_CONFIGURATION, {
        optional: true
      }) || {};
      canceledNavigationResolution = this.options.canceledNavigationResolution || "replace";
      location = inject2(Location);
      urlHandlingStrategy = inject2(UrlHandlingStrategy);
      urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred";
      currentUrlTree = new UrlTree();
      /**
       * Returns the currently activated `UrlTree`.
       *
       * This `UrlTree` shows only URLs that the `Router` is configured to handle (through
       * `UrlHandlingStrategy`).
       *
       * The value is set after finding the route config tree to activate but before activating the
       * route.
       */
      getCurrentUrlTree() {
        return this.currentUrlTree;
      }
      rawUrlTree = this.currentUrlTree;
      /**
       * Returns a `UrlTree` that is represents what the browser is actually showing.
       *
       * In the life of a navigation transition:
       * 1. When a navigation begins, the raw `UrlTree` is updated to the full URL that's being
       * navigated to.
       * 2. During a navigation, redirects are applied, which might only apply to _part_ of the URL (due
       * to `UrlHandlingStrategy`).
       * 3. Just before activation, the raw `UrlTree` is updated to include the redirects on top of the
       * original raw URL.
       *
       * Note that this is _only_ here to support `UrlHandlingStrategy.extract` and
       * `UrlHandlingStrategy.shouldProcessUrl`. Without those APIs, the current `UrlTree` would not
       * deviated from the raw `UrlTree`.
       *
       * For `extract`, a raw `UrlTree` is needed because `extract` may only return part
       * of the navigation URL. Thus, the current `UrlTree` may only represent _part_ of the browser
       * URL. When a navigation gets cancelled and the router needs to reset the URL or a new navigation
       * occurs, it needs to know the _whole_ browser URL, not just the part handled by
       * `UrlHandlingStrategy`.
       * For `shouldProcessUrl`, when the return is `false`, the router ignores the navigation but
       * still updates the raw `UrlTree` with the assumption that the navigation was caused by the
       * location change listener due to a URL update by the AngularJS router. In this case, the router
       * still need to know what the browser's URL is for future navigations.
       */
      getRawUrlTree() {
        return this.rawUrlTree;
      }
      createBrowserPath({
        finalUrl,
        initialUrl,
        targetBrowserUrl
      }) {
        const rawUrl = finalUrl !== void 0 ? this.urlHandlingStrategy.merge(finalUrl, initialUrl) : initialUrl;
        const url = targetBrowserUrl ?? rawUrl;
        const path = url instanceof UrlTree ? this.urlSerializer.serialize(url) : url;
        return path;
      }
      commitTransition({
        targetRouterState,
        finalUrl,
        initialUrl
      }) {
        if (finalUrl && targetRouterState) {
          this.currentUrlTree = finalUrl;
          this.rawUrlTree = this.urlHandlingStrategy.merge(finalUrl, initialUrl);
          this.routerState = targetRouterState;
        } else {
          this.rawUrlTree = initialUrl;
        }
      }
      routerState = createEmptyState(null);
      /** Returns the current RouterState. */
      getRouterState() {
        return this.routerState;
      }
      stateMemento = this.createStateMemento();
      updateStateMemento() {
        this.stateMemento = this.createStateMemento();
      }
      createStateMemento() {
        return {
          rawUrlTree: this.rawUrlTree,
          currentUrlTree: this.currentUrlTree,
          routerState: this.routerState
        };
      }
      resetInternalState({
        finalUrl
      }) {
        this.routerState = this.stateMemento.routerState;
        this.currentUrlTree = this.stateMemento.currentUrlTree;
        this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, finalUrl ?? this.rawUrlTree);
      }
      static \u0275fac = function StateManager_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _StateManager)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _StateManager,
        factory: () => (() => inject2(HistoryStateManager))(),
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StateManager, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: () => inject2(HistoryStateManager)
        }]
      }], null, null);
    })();
    HistoryStateManager = class _HistoryStateManager extends StateManager {
      /**
       * The id of the currently active page in the router.
       * Updated to the transition's target id on a successful navigation.
       *
       * This is used to track what page the router last activated. When an attempted navigation fails,
       * the router can then use this to compute how to restore the state back to the previously active
       * page.
       */
      currentPageId = 0;
      lastSuccessfulId = -1;
      restoredState() {
        return this.location.getState();
      }
      /**
       * The routerPageId of whatever page is currently active in the browser history. This is
       * important for computing the target page id for new navigations because we need to ensure each
       * page id in the browser history is 1 more than the previous entry.
       */
      get browserPageId() {
        if (this.canceledNavigationResolution !== "computed") {
          return this.currentPageId;
        }
        return this.restoredState()?.\u0275routerPageId ?? this.currentPageId;
      }
      registerNonRouterCurrentEntryChangeListener(listener) {
        return this.location.subscribe((event) => {
          if (event["type"] === "popstate") {
            setTimeout(() => {
              listener(event["url"], event.state, "popstate");
            });
          }
        });
      }
      handleRouterEvent(e, currentTransition) {
        if (e instanceof NavigationStart) {
          this.updateStateMemento();
        } else if (e instanceof NavigationSkipped) {
          this.commitTransition(currentTransition);
        } else if (e instanceof RoutesRecognized) {
          if (this.urlUpdateStrategy === "eager") {
            if (!currentTransition.extras.skipLocationChange) {
              this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);
            }
          }
        } else if (e instanceof BeforeActivateRoutes) {
          this.commitTransition(currentTransition);
          if (this.urlUpdateStrategy === "deferred" && !currentTransition.extras.skipLocationChange) {
            this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);
          }
        } else if (e instanceof NavigationCancel && e.code !== NavigationCancellationCode.SupersededByNewNavigation && e.code !== NavigationCancellationCode.Redirect) {
          this.restoreHistory(currentTransition);
        } else if (e instanceof NavigationError) {
          this.restoreHistory(currentTransition, true);
        } else if (e instanceof NavigationEnd) {
          this.lastSuccessfulId = e.id;
          this.currentPageId = this.browserPageId;
        }
      }
      setBrowserUrl(path, {
        extras,
        id: id2
      }) {
        const {
          replaceUrl,
          state
        } = extras;
        if (this.location.isCurrentPathEqualTo(path) || !!replaceUrl) {
          const currentBrowserPageId = this.browserPageId;
          const newState = __spreadValues(__spreadValues({}, state), this.generateNgRouterState(id2, currentBrowserPageId));
          this.location.replaceState(path, "", newState);
        } else {
          const newState = __spreadValues(__spreadValues({}, state), this.generateNgRouterState(id2, this.browserPageId + 1));
          this.location.go(path, "", newState);
        }
      }
      /**
       * Performs the necessary rollback action to restore the browser URL to the
       * state before the transition.
       */
      restoreHistory(navigation, restoringFromCaughtError = false) {
        if (this.canceledNavigationResolution === "computed") {
          const currentBrowserPageId = this.browserPageId;
          const targetPagePosition = this.currentPageId - currentBrowserPageId;
          if (targetPagePosition !== 0) {
            this.location.historyGo(targetPagePosition);
          } else if (this.getCurrentUrlTree() === navigation.finalUrl && targetPagePosition === 0) {
            this.resetInternalState(navigation);
            this.resetUrlToCurrentUrlTree();
          } else ;
        } else if (this.canceledNavigationResolution === "replace") {
          if (restoringFromCaughtError) {
            this.resetInternalState(navigation);
          }
          this.resetUrlToCurrentUrlTree();
        }
      }
      resetUrlToCurrentUrlTree() {
        this.location.replaceState(this.urlSerializer.serialize(this.getRawUrlTree()), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));
      }
      generateNgRouterState(navigationId, routerPageId) {
        if (this.canceledNavigationResolution === "computed") {
          return {
            navigationId,
            \u0275routerPageId: routerPageId
          };
        }
        return {
          navigationId
        };
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275HistoryStateManager_BaseFactory;
        return function HistoryStateManager_Factory(__ngFactoryType__) {
          return (\u0275HistoryStateManager_BaseFactory || (\u0275HistoryStateManager_BaseFactory = \u0275\u0275getInheritedFactory(_HistoryStateManager)))(__ngFactoryType__ || _HistoryStateManager);
        };
      })();
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _HistoryStateManager,
        factory: _HistoryStateManager.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HistoryStateManager, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    exactMatchOptions = {
      paths: "exact",
      fragment: "ignored",
      matrixParams: "ignored",
      queryParams: "exact"
    };
    subsetMatchOptions = {
      paths: "subset",
      fragment: "ignored",
      matrixParams: "ignored",
      queryParams: "subset"
    };
    Router = class _Router {
      get currentUrlTree() {
        return this.stateManager.getCurrentUrlTree();
      }
      get rawUrlTree() {
        return this.stateManager.getRawUrlTree();
      }
      disposed = false;
      nonRouterCurrentEntryChangeSubscription;
      console = inject2(Console);
      stateManager = inject2(StateManager);
      options = inject2(ROUTER_CONFIGURATION, {
        optional: true
      }) || {};
      pendingTasks = inject2(PendingTasksInternal);
      urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred";
      navigationTransitions = inject2(NavigationTransitions);
      urlSerializer = inject2(UrlSerializer);
      location = inject2(Location);
      urlHandlingStrategy = inject2(UrlHandlingStrategy);
      injector = inject2(EnvironmentInjector);
      /**
       * The private `Subject` type for the public events exposed in the getter. This is used internally
       * to push events to. The separate field allows us to expose separate types in the public API
       * (i.e., an Observable rather than the Subject).
       */
      _events = new Subject();
      /**
       * An event stream for routing events.
       */
      get events() {
        return this._events;
      }
      /**
       * The current state of routing in this NgModule.
       */
      get routerState() {
        return this.stateManager.getRouterState();
      }
      /**
       * True if at least one navigation event has occurred,
       * false otherwise.
       */
      navigated = false;
      /**
       * A strategy for re-using routes.
       *
       * @deprecated Configure using `providers` instead:
       *   `{provide: RouteReuseStrategy, useClass: MyStrategy}`.
       */
      routeReuseStrategy = inject2(RouteReuseStrategy);
      /**
       * How to handle a navigation request to the current URL.
       *
       *
       * @deprecated Configure this through `provideRouter` or `RouterModule.forRoot` instead.
       * @see {@link withRouterConfig}
       * @see {@link provideRouter}
       * @see {@link RouterModule}
       */
      onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore";
      config = inject2(ROUTES, {
        optional: true
      })?.flat() ?? [];
      /**
       * Indicates whether the application has opted in to binding Router data to component inputs.
       *
       * This option is enabled by the `withComponentInputBinding` feature of `provideRouter` or
       * `bindToComponentInputs` in the `ExtraOptions` of `RouterModule.forRoot`.
       */
      componentInputBindingEnabled = !!inject2(INPUT_BINDER, {
        optional: true
      });
      constructor() {
        this.resetConfig(this.config);
        this.navigationTransitions.setupNavigations(this).subscribe({
          error: (e) => {
            this.console.warn(ngDevMode ? `Unhandled Navigation Error: ${e}` : e);
          }
        });
        this.subscribeToNavigationEvents();
      }
      eventsSubscription = new Subscription();
      subscribeToNavigationEvents() {
        const subscription = this.navigationTransitions.events.subscribe((e) => {
          try {
            const currentTransition = this.navigationTransitions.currentTransition;
            const currentNavigation = this.navigationTransitions.currentNavigation;
            if (currentTransition !== null && currentNavigation !== null) {
              this.stateManager.handleRouterEvent(e, currentNavigation);
              if (e instanceof NavigationCancel && e.code !== NavigationCancellationCode.Redirect && e.code !== NavigationCancellationCode.SupersededByNewNavigation) {
                this.navigated = true;
              } else if (e instanceof NavigationEnd) {
                this.navigated = true;
              } else if (e instanceof RedirectRequest) {
                const opts = e.navigationBehaviorOptions;
                const mergedTree = this.urlHandlingStrategy.merge(e.url, currentTransition.currentRawUrl);
                const extras = __spreadValues({
                  browserUrl: currentTransition.extras.browserUrl,
                  info: currentTransition.extras.info,
                  skipLocationChange: currentTransition.extras.skipLocationChange,
                  // The URL is already updated at this point if we have 'eager' URL
                  // updates or if the navigation was triggered by the browser (back
                  // button, URL bar, etc). We want to replace that item in history
                  // if the navigation is rejected.
                  replaceUrl: currentTransition.extras.replaceUrl || this.urlUpdateStrategy === "eager" || isBrowserTriggeredNavigation(currentTransition.source)
                }, opts);
                this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras, {
                  resolve: currentTransition.resolve,
                  reject: currentTransition.reject,
                  promise: currentTransition.promise
                });
              }
            }
            if (isPublicRouterEvent(e)) {
              this._events.next(e);
            }
          } catch (e2) {
            this.navigationTransitions.transitionAbortWithErrorSubject.next(e2);
          }
        });
        this.eventsSubscription.add(subscription);
      }
      /** @internal */
      resetRootComponentType(rootComponentType) {
        this.routerState.root.component = rootComponentType;
        this.navigationTransitions.rootComponentType = rootComponentType;
      }
      /**
       * Sets up the location change listener and performs the initial navigation.
       */
      initialNavigation() {
        this.setUpLocationChangeListener();
        if (!this.navigationTransitions.hasRequestedNavigation) {
          this.navigateToSyncWithBrowser(this.location.path(true), IMPERATIVE_NAVIGATION, this.stateManager.restoredState());
        }
      }
      /**
       * Sets up the location change listener. This listener detects navigations triggered from outside
       * the Router (the browser back/forward buttons, for example) and schedules a corresponding Router
       * navigation so that the correct events, guards, etc. are triggered.
       */
      setUpLocationChangeListener() {
        this.nonRouterCurrentEntryChangeSubscription ??= this.stateManager.registerNonRouterCurrentEntryChangeListener((url, state, source) => {
          this.navigateToSyncWithBrowser(url, source, state);
        });
      }
      /**
       * Schedules a router navigation to synchronize Router state with the browser state.
       *
       * This is done as a response to a popstate event and the initial navigation. These
       * two scenarios represent times when the browser URL/state has been updated and
       * the Router needs to respond to ensure its internal state matches.
       */
      navigateToSyncWithBrowser(url, source, state) {
        const extras = {
          replaceUrl: true
        };
        const restoredState = state?.navigationId ? state : null;
        if (state) {
          const stateCopy = __spreadValues({}, state);
          delete stateCopy.navigationId;
          delete stateCopy.\u0275routerPageId;
          if (Object.keys(stateCopy).length !== 0) {
            extras.state = stateCopy;
          }
        }
        const urlTree = this.parseUrl(url);
        this.scheduleNavigation(urlTree, source, restoredState, extras).catch((e) => {
          if (this.disposed) {
            return;
          }
          this.injector.get(INTERNAL_APPLICATION_ERROR_HANDLER)(e);
        });
      }
      /** The current URL. */
      get url() {
        return this.serializeUrl(this.currentUrlTree);
      }
      /**
       * Returns the current `Navigation` object when the router is navigating,
       * and `null` when idle.
       */
      getCurrentNavigation() {
        return this.navigationTransitions.currentNavigation;
      }
      /**
       * The `Navigation` object of the most recent navigation to succeed and `null` if there
       *     has not been a successful navigation yet.
       */
      get lastSuccessfulNavigation() {
        return this.navigationTransitions.lastSuccessfulNavigation;
      }
      /**
       * Resets the route configuration used for navigation and generating links.
       *
       * @param config The route array for the new configuration.
       *
       * @usageNotes
       *
       * ```ts
       * router.resetConfig([
       *  { path: 'team/:id', component: TeamCmp, children: [
       *    { path: 'simple', component: SimpleCmp },
       *    { path: 'user/:name', component: UserCmp }
       *  ]}
       * ]);
       * ```
       */
      resetConfig(config3) {
        (typeof ngDevMode === "undefined" || ngDevMode) && validateConfig(config3);
        this.config = config3.map(standardizeConfig);
        this.navigated = false;
      }
      /** @docs-private */
      ngOnDestroy() {
        this.dispose();
      }
      /** Disposes of the router. */
      dispose() {
        this._events.unsubscribe();
        this.navigationTransitions.complete();
        if (this.nonRouterCurrentEntryChangeSubscription) {
          this.nonRouterCurrentEntryChangeSubscription.unsubscribe();
          this.nonRouterCurrentEntryChangeSubscription = void 0;
        }
        this.disposed = true;
        this.eventsSubscription.unsubscribe();
      }
      /**
       * Appends URL segments to the current URL tree to create a new URL tree.
       *
       * @param commands An array of URL fragments with which to construct the new URL tree.
       * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path
       * segments, followed by the parameters for each segment.
       * The fragments are applied to the current URL tree or the one provided  in the `relativeTo`
       * property of the options object, if supplied.
       * @param navigationExtras Options that control the navigation strategy.
       * @returns The new URL tree.
       *
       * @usageNotes
       *
       * ```
       * // create /team/33/user/11
       * router.createUrlTree(['/team', 33, 'user', 11]);
       *
       * // create /team/33;expand=true/user/11
       * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);
       *
       * // you can collapse static segments like this (this works only with the first passed-in value):
       * router.createUrlTree(['/team/33/user', userId]);
       *
       * // If the first segment can contain slashes, and you do not want the router to split it,
       * // you can do the following:
       * router.createUrlTree([{segmentPath: '/one/two'}]);
       *
       * // create /team/33/(user/11//right:chat)
       * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);
       *
       * // remove the right secondary node
       * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);
       *
       * // assuming the current url is `/team/33/user/11` and the route points to `user/11`
       *
       * // navigate to /team/33/user/11/details
       * router.createUrlTree(['details'], {relativeTo: route});
       *
       * // navigate to /team/33/user/22
       * router.createUrlTree(['../22'], {relativeTo: route});
       *
       * // navigate to /team/44/user/22
       * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});
       *
       * Note that a value of `null` or `undefined` for `relativeTo` indicates that the
       * tree should be created relative to the root.
       * ```
       */
      createUrlTree(commands, navigationExtras = {}) {
        const {
          relativeTo,
          queryParams,
          fragment,
          queryParamsHandling,
          preserveFragment
        } = navigationExtras;
        const f = preserveFragment ? this.currentUrlTree.fragment : fragment;
        let q = null;
        switch (queryParamsHandling ?? this.options.defaultQueryParamsHandling) {
          case "merge":
            q = __spreadValues(__spreadValues({}, this.currentUrlTree.queryParams), queryParams);
            break;
          case "preserve":
            q = this.currentUrlTree.queryParams;
            break;
          default:
            q = queryParams || null;
        }
        if (q !== null) {
          q = this.removeEmptyProps(q);
        }
        let relativeToUrlSegmentGroup;
        try {
          const relativeToSnapshot = relativeTo ? relativeTo.snapshot : this.routerState.snapshot.root;
          relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeToSnapshot);
        } catch (e) {
          if (typeof commands[0] !== "string" || commands[0][0] !== "/") {
            commands = [];
          }
          relativeToUrlSegmentGroup = this.currentUrlTree.root;
        }
        return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, q, f ?? null);
      }
      /**
       * Navigates to a view using an absolute route path.
       *
       * @param url An absolute path for a defined route. The function does not apply any delta to the
       *     current URL.
       * @param extras An object containing properties that modify the navigation strategy.
       *
       * @returns A Promise that resolves to 'true' when navigation succeeds,
       * to 'false' when navigation fails, or is rejected on error.
       *
       * @usageNotes
       *
       * The following calls request navigation to an absolute path.
       *
       * ```ts
       * router.navigateByUrl("/team/33/user/11");
       *
       * // Navigate without updating the URL
       * router.navigateByUrl("/team/33/user/11", { skipLocationChange: true });
       * ```
       *
       * @see [Routing and Navigation guide](guide/routing/common-router-tasks)
       *
       */
      navigateByUrl(url, extras = {
        skipLocationChange: false
      }) {
        const urlTree = isUrlTree(url) ? url : this.parseUrl(url);
        const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);
        return this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras);
      }
      /**
       * Navigate based on the provided array of commands and a starting point.
       * If no starting route is provided, the navigation is absolute.
       *
       * @param commands An array of URL fragments with which to construct the target URL.
       * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path
       * segments, followed by the parameters for each segment.
       * The fragments are applied to the current URL or the one provided  in the `relativeTo` property
       * of the options object, if supplied.
       * @param extras An options object that determines how the URL should be constructed or
       *     interpreted.
       *
       * @returns A Promise that resolves to `true` when navigation succeeds, or `false` when navigation
       *     fails. The Promise is rejected when an error occurs if `resolveNavigationPromiseOnError` is
       * not `true`.
       *
       * @usageNotes
       *
       * The following calls request navigation to a dynamic route path relative to the current URL.
       *
       * ```ts
       * router.navigate(['team', 33, 'user', 11], {relativeTo: route});
       *
       * // Navigate without updating the URL, overriding the default behavior
       * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});
       * ```
       *
       * @see [Routing and Navigation guide](guide/routing/common-router-tasks)
       *
       */
      navigate(commands, extras = {
        skipLocationChange: false
      }) {
        validateCommands(commands);
        return this.navigateByUrl(this.createUrlTree(commands, extras), extras);
      }
      /** Serializes a `UrlTree` into a string */
      serializeUrl(url) {
        return this.urlSerializer.serialize(url);
      }
      /** Parses a string into a `UrlTree` */
      parseUrl(url) {
        try {
          return this.urlSerializer.parse(url);
        } catch {
          return this.urlSerializer.parse("/");
        }
      }
      isActive(url, matchOptions) {
        let options;
        if (matchOptions === true) {
          options = __spreadValues({}, exactMatchOptions);
        } else if (matchOptions === false) {
          options = __spreadValues({}, subsetMatchOptions);
        } else {
          options = matchOptions;
        }
        if (isUrlTree(url)) {
          return containsTree(this.currentUrlTree, url, options);
        }
        const urlTree = this.parseUrl(url);
        return containsTree(this.currentUrlTree, urlTree, options);
      }
      removeEmptyProps(params) {
        return Object.entries(params).reduce((result, [key, value]) => {
          if (value !== null && value !== void 0) {
            result[key] = value;
          }
          return result;
        }, {});
      }
      scheduleNavigation(rawUrl, source, restoredState, extras, priorPromise) {
        if (this.disposed) {
          return Promise.resolve(false);
        }
        let resolve;
        let reject;
        let promise;
        if (priorPromise) {
          resolve = priorPromise.resolve;
          reject = priorPromise.reject;
          promise = priorPromise.promise;
        } else {
          promise = new Promise((res, rej) => {
            resolve = res;
            reject = rej;
          });
        }
        const taskId = this.pendingTasks.add();
        afterNextNavigation(this, () => {
          queueMicrotask(() => this.pendingTasks.remove(taskId));
        });
        this.navigationTransitions.handleNavigationRequest({
          source,
          restoredState,
          currentUrlTree: this.currentUrlTree,
          currentRawUrl: this.currentUrlTree,
          rawUrl,
          extras,
          resolve,
          reject,
          promise,
          currentSnapshot: this.routerState.snapshot,
          currentRouterState: this.routerState
        });
        return promise.catch((e) => {
          return Promise.reject(e);
        });
      }
      static \u0275fac = function Router_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Router)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _Router,
        factory: _Router.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Router, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [], null);
    })();
  }
});

// node_modules/@angular/router/fesm2022/router_module.mjs
function isActiveMatchOptions(options) {
  return !!options.paths;
}
function provideRouter(routes2, ...features) {
  return makeEnvironmentProviders([{
    provide: ROUTES,
    multi: true,
    useValue: routes2
  }, typeof ngDevMode === "undefined" || ngDevMode ? {
    provide: ROUTER_IS_PROVIDED,
    useValue: true
  } : [], {
    provide: ActivatedRoute,
    useFactory: rootRoute,
    deps: [Router]
  }, {
    provide: APP_BOOTSTRAP_LISTENER,
    multi: true,
    useFactory: getBootstrapListener
  }, features.map((feature) => feature.\u0275providers)]);
}
function rootRoute(router) {
  return router.routerState.root;
}
function routerFeature(kind, providers) {
  return {
    \u0275kind: kind,
    \u0275providers: providers
  };
}
function getBootstrapListener() {
  const injector = inject2(Injector);
  return (bootstrappedComponentRef) => {
    const ref = injector.get(ApplicationRef);
    if (bootstrappedComponentRef !== ref.components[0]) {
      return;
    }
    const router = injector.get(Router);
    const bootstrapDone = injector.get(BOOTSTRAP_DONE);
    if (injector.get(INITIAL_NAVIGATION) === 1) {
      router.initialNavigation();
    }
    injector.get(ROUTER_PRELOADER, null, {
      optional: true
    })?.setUpPreloading();
    injector.get(ROUTER_SCROLLER, null, {
      optional: true
    })?.init();
    router.resetRootComponentType(ref.componentTypes[0]);
    if (!bootstrapDone.closed) {
      bootstrapDone.next();
      bootstrapDone.complete();
      bootstrapDone.unsubscribe();
    }
  };
}
function withEnabledBlockingInitialNavigation() {
  const providers = [{
    provide: INITIAL_NAVIGATION,
    useValue: 0
    /* InitialNavigation.EnabledBlocking */
  }, provideAppInitializer(() => {
    const injector = inject2(Injector);
    const locationInitialized = injector.get(LOCATION_INITIALIZED, Promise.resolve());
    return locationInitialized.then(() => {
      return new Promise((resolve) => {
        const router = injector.get(Router);
        const bootstrapDone = injector.get(BOOTSTRAP_DONE);
        afterNextNavigation(router, () => {
          resolve(true);
        });
        injector.get(NavigationTransitions).afterPreactivation = () => {
          resolve(true);
          return bootstrapDone.closed ? of(void 0) : bootstrapDone;
        };
        router.initialNavigation();
      });
    });
  })];
  return routerFeature(2, providers);
}
function withDisabledInitialNavigation() {
  const providers = [provideAppInitializer(() => {
    inject2(Router).setUpLocationChangeListener();
  }), {
    provide: INITIAL_NAVIGATION,
    useValue: 2
    /* InitialNavigation.Disabled */
  }];
  return routerFeature(3, providers);
}
function withDebugTracing() {
  let providers = [];
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    providers = [{
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const router = inject2(Router);
        return () => router.events.subscribe((e) => {
          console.group?.(`Router Event: ${e.constructor.name}`);
          console.log(stringifyEvent(e));
          console.log(e);
          console.groupEnd?.();
        });
      }
    }];
  } else {
    providers = [];
  }
  return routerFeature(1, providers);
}
function withPreloading(preloadingStrategy) {
  const providers = [{
    provide: ROUTER_PRELOADER,
    useExisting: RouterPreloader
  }, {
    provide: PreloadingStrategy,
    useExisting: preloadingStrategy
  }];
  return routerFeature(0, providers);
}
function withComponentInputBinding() {
  const providers = [RoutedComponentInputBinder, {
    provide: INPUT_BINDER,
    useExisting: RoutedComponentInputBinder
  }];
  return routerFeature(8, providers);
}
function withViewTransitions(options) {
  performanceMarkFeature("NgRouterViewTransitions");
  const providers = [{
    provide: CREATE_VIEW_TRANSITION,
    useValue: createViewTransition
  }, {
    provide: VIEW_TRANSITION_OPTIONS,
    useValue: __spreadValues({
      skipNextTransition: !!options?.skipInitialTransition
    }, options)
  }];
  return routerFeature(9, providers);
}
function provideRouterScroller() {
  return {
    provide: ROUTER_SCROLLER,
    useFactory: () => {
      const viewportScroller = inject2(ViewportScroller);
      const zone = inject2(NgZone);
      const config3 = inject2(ROUTER_CONFIGURATION);
      const transitions = inject2(NavigationTransitions);
      const urlSerializer = inject2(UrlSerializer);
      if (config3.scrollOffset) {
        viewportScroller.setOffset(config3.scrollOffset);
      }
      return new RouterScroller(urlSerializer, transitions, viewportScroller, zone, config3);
    }
  };
}
function provideHashLocationStrategy() {
  return {
    provide: LocationStrategy,
    useClass: HashLocationStrategy
  };
}
function providePathLocationStrategy() {
  return {
    provide: LocationStrategy,
    useClass: PathLocationStrategy
  };
}
function provideForRootGuard(router) {
  if (router) {
    throw new RuntimeError(4007, `The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector. Lazy loaded modules should use RouterModule.forChild() instead.`);
  }
  return "guarded";
}
function provideInitialNavigation(config3) {
  return [config3.initialNavigation === "disabled" ? withDisabledInitialNavigation().\u0275providers : [], config3.initialNavigation === "enabledBlocking" ? withEnabledBlockingInitialNavigation().\u0275providers : []];
}
function provideRouterInitializer() {
  return [
    // ROUTER_INITIALIZER token should be removed. It's public API but shouldn't be. We can just
    // have `getBootstrapListener` directly attached to APP_BOOTSTRAP_LISTENER.
    {
      provide: ROUTER_INITIALIZER,
      useFactory: getBootstrapListener
    },
    {
      provide: APP_BOOTSTRAP_LISTENER,
      multi: true,
      useExisting: ROUTER_INITIALIZER
    }
  ];
}
var RouterLink, RouterLinkActive, PreloadingStrategy, PreloadAllModules, NoPreloading, RouterPreloader, ROUTER_SCROLLER, RouterScroller, ROUTER_IS_PROVIDED, BOOTSTRAP_DONE, INITIAL_NAVIGATION, ROUTER_PRELOADER, ROUTER_DIRECTIVES, ROUTER_FORROOT_GUARD, ROUTER_PROVIDERS, RouterModule, ROUTER_INITIALIZER;
var init_router_module = __esm({
  "node_modules/@angular/router/fesm2022/router_module.mjs"() {
    "use strict";
    init_common();
    init_common();
    init_core();
    init_core();
    init_router2();
    init_esm();
    init_operators();
    RouterLink = class _RouterLink {
      router;
      route;
      tabIndexAttribute;
      renderer;
      el;
      locationStrategy;
      /** @nodoc */
      reactiveHref = signal(null, ...ngDevMode ? [{
        debugName: "reactiveHref"
      }] : []);
      /**
       * Represents an `href` attribute value applied to a host element,
       * when a host element is an `<a>`/`<area>` tag or a compatible custom element.
       * For other tags, the value is `null`.
       */
      get href() {
        return untracked2(this.reactiveHref);
      }
      /** @deprecated */
      set href(value) {
        this.reactiveHref.set(value);
      }
      /**
       * Represents the `target` attribute on a host element.
       * This is only used when the host element is
       * an `<a>`/`<area>` tag or a compatible custom element.
       */
      target;
      /**
       * Passed to {@link Router#createUrlTree} as part of the
       * `UrlCreationOptions`.
       * @see {@link UrlCreationOptions#queryParams}
       * @see {@link Router#createUrlTree}
       */
      queryParams;
      /**
       * Passed to {@link Router#createUrlTree} as part of the
       * `UrlCreationOptions`.
       * @see {@link UrlCreationOptions#fragment}
       * @see {@link Router#createUrlTree}
       */
      fragment;
      /**
       * Passed to {@link Router#createUrlTree} as part of the
       * `UrlCreationOptions`.
       * @see {@link UrlCreationOptions#queryParamsHandling}
       * @see {@link Router#createUrlTree}
       */
      queryParamsHandling;
      /**
       * Passed to {@link Router#navigateByUrl} as part of the
       * `NavigationBehaviorOptions`.
       * @see {@link NavigationBehaviorOptions#state}
       * @see {@link Router#navigateByUrl}
       */
      state;
      /**
       * Passed to {@link Router#navigateByUrl} as part of the
       * `NavigationBehaviorOptions`.
       * @see {@link NavigationBehaviorOptions#info}
       * @see {@link Router#navigateByUrl}
       */
      info;
      /**
       * Passed to {@link Router#createUrlTree} as part of the
       * `UrlCreationOptions`.
       * Specify a value here when you do not want to use the default value
       * for `routerLink`, which is the current activated route.
       * Note that a value of `undefined` here will use the `routerLink` default.
       * @see {@link UrlCreationOptions#relativeTo}
       * @see {@link Router#createUrlTree}
       */
      relativeTo;
      /** Whether a host element is an `<a>`/`<area>` tag or a compatible custom element. */
      isAnchorElement;
      subscription;
      /** @internal */
      onChanges = new Subject();
      applicationErrorHandler = inject2(INTERNAL_APPLICATION_ERROR_HANDLER);
      options = inject2(ROUTER_CONFIGURATION, {
        optional: true
      });
      constructor(router, route, tabIndexAttribute, renderer, el, locationStrategy) {
        this.router = router;
        this.route = route;
        this.tabIndexAttribute = tabIndexAttribute;
        this.renderer = renderer;
        this.el = el;
        this.locationStrategy = locationStrategy;
        this.reactiveHref.set(inject2(new HostAttributeToken("href"), {
          optional: true
        }));
        const tagName = el.nativeElement.tagName?.toLowerCase();
        this.isAnchorElement = tagName === "a" || tagName === "area" || !!// Avoid breaking in an SSR context where customElements might not be defined.
        (typeof customElements === "object" && // observedAttributes is an optional static property/getter on a custom element.
        // The spec states that this must be an array of strings.
        customElements.get(tagName)?.observedAttributes?.includes?.("href"));
        if (!this.isAnchorElement) {
          this.subscribeToNavigationEventsIfNecessary();
        } else {
          this.setTabIndexIfNotOnNativeEl("0");
        }
      }
      subscribeToNavigationEventsIfNecessary() {
        if (this.subscription !== void 0 || !this.isAnchorElement) {
          return;
        }
        let createSubcription = this.preserveFragment;
        const dependsOnRouterState = (handling) => handling === "merge" || handling === "preserve";
        createSubcription ||= dependsOnRouterState(this.queryParamsHandling);
        createSubcription ||= !this.queryParamsHandling && !dependsOnRouterState(this.options?.defaultQueryParamsHandling);
        if (!createSubcription) {
          return;
        }
        this.subscription = this.router.events.subscribe((s) => {
          if (s instanceof NavigationEnd) {
            this.updateHref();
          }
        });
      }
      /**
       * Passed to {@link Router#createUrlTree} as part of the
       * `UrlCreationOptions`.
       * @see {@link UrlCreationOptions#preserveFragment}
       * @see {@link Router#createUrlTree}
       */
      preserveFragment = false;
      /**
       * Passed to {@link Router#navigateByUrl} as part of the
       * `NavigationBehaviorOptions`.
       * @see {@link NavigationBehaviorOptions#skipLocationChange}
       * @see {@link Router#navigateByUrl}
       */
      skipLocationChange = false;
      /**
       * Passed to {@link Router#navigateByUrl} as part of the
       * `NavigationBehaviorOptions`.
       * @see {@link NavigationBehaviorOptions#replaceUrl}
       * @see {@link Router#navigateByUrl}
       */
      replaceUrl = false;
      /**
       * Modifies the tab index if there was not a tabindex attribute on the element during
       * instantiation.
       */
      setTabIndexIfNotOnNativeEl(newTabIndex) {
        if (this.tabIndexAttribute != null || this.isAnchorElement) {
          return;
        }
        this.applyAttributeValue("tabindex", newTabIndex);
      }
      /** @docs-private */
      // TODO(atscott): Remove changes parameter in major version as a breaking change.
      ngOnChanges(changes) {
        if (ngDevMode && isUrlTree(this.routerLinkInput) && (this.fragment !== void 0 || this.queryParams || this.queryParamsHandling || this.preserveFragment || this.relativeTo)) {
          throw new RuntimeError(4016, "Cannot configure queryParams or fragment when using a UrlTree as the routerLink input value.");
        }
        if (this.isAnchorElement) {
          this.updateHref();
          this.subscribeToNavigationEventsIfNecessary();
        }
        this.onChanges.next(this);
      }
      routerLinkInput = null;
      /**
       * Commands to pass to {@link Router#createUrlTree} or a `UrlTree`.
       *   - **array**: commands to pass to {@link Router#createUrlTree}.
       *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`
       *   - **UrlTree**: a `UrlTree` for this link rather than creating one from the commands
       *     and other inputs that correspond to properties of `UrlCreationOptions`.
       *   - **null|undefined**: effectively disables the `routerLink`
       * @see {@link Router#createUrlTree}
       */
      set routerLink(commandsOrUrlTree) {
        if (commandsOrUrlTree == null) {
          this.routerLinkInput = null;
          this.setTabIndexIfNotOnNativeEl(null);
        } else {
          if (isUrlTree(commandsOrUrlTree)) {
            this.routerLinkInput = commandsOrUrlTree;
          } else {
            this.routerLinkInput = Array.isArray(commandsOrUrlTree) ? commandsOrUrlTree : [commandsOrUrlTree];
          }
          this.setTabIndexIfNotOnNativeEl("0");
        }
      }
      /** @docs-private */
      onClick(button, ctrlKey, shiftKey, altKey, metaKey) {
        const urlTree = this.urlTree;
        if (urlTree === null) {
          return true;
        }
        if (this.isAnchorElement) {
          if (button !== 0 || ctrlKey || shiftKey || altKey || metaKey) {
            return true;
          }
          if (typeof this.target === "string" && this.target != "_self") {
            return true;
          }
        }
        const extras = {
          skipLocationChange: this.skipLocationChange,
          replaceUrl: this.replaceUrl,
          state: this.state,
          info: this.info
        };
        this.router.navigateByUrl(urlTree, extras)?.catch((e) => {
          this.applicationErrorHandler(e);
        });
        return !this.isAnchorElement;
      }
      /** @docs-private */
      ngOnDestroy() {
        this.subscription?.unsubscribe();
      }
      updateHref() {
        const urlTree = this.urlTree;
        this.reactiveHref.set(urlTree !== null && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(urlTree)) ?? "" : null);
      }
      applyAttributeValue(attrName, attrValue) {
        const renderer = this.renderer;
        const nativeElement = this.el.nativeElement;
        if (attrValue !== null) {
          renderer.setAttribute(nativeElement, attrName, attrValue);
        } else {
          renderer.removeAttribute(nativeElement, attrName);
        }
      }
      get urlTree() {
        if (this.routerLinkInput === null) {
          return null;
        } else if (isUrlTree(this.routerLinkInput)) {
          return this.routerLinkInput;
        }
        return this.router.createUrlTree(this.routerLinkInput, {
          // If the `relativeTo` input is not defined, we want to use `this.route` by default.
          // Otherwise, we should use the value provided by the user in the input.
          relativeTo: this.relativeTo !== void 0 ? this.relativeTo : this.route,
          queryParams: this.queryParams,
          fragment: this.fragment,
          queryParamsHandling: this.queryParamsHandling,
          preserveFragment: this.preserveFragment
        });
      }
      static \u0275fac = function RouterLink_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _RouterLink)(\u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275injectAttribute("tabindex"), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(LocationStrategy));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _RouterLink,
        selectors: [["", "routerLink", ""]],
        hostVars: 2,
        hostBindings: function RouterLink_HostBindings(rf, ctx) {
          if (rf & 1) {
            \u0275\u0275listener("click", function RouterLink_click_HostBindingHandler($event) {
              return ctx.onClick($event.button, $event.ctrlKey, $event.shiftKey, $event.altKey, $event.metaKey);
            });
          }
          if (rf & 2) {
            \u0275\u0275attribute("href", ctx.reactiveHref(), \u0275\u0275sanitizeUrlOrResourceUrl)("target", ctx.target);
          }
        },
        inputs: {
          target: "target",
          queryParams: "queryParams",
          fragment: "fragment",
          queryParamsHandling: "queryParamsHandling",
          state: "state",
          info: "info",
          relativeTo: "relativeTo",
          preserveFragment: [2, "preserveFragment", "preserveFragment", booleanAttribute],
          skipLocationChange: [2, "skipLocationChange", "skipLocationChange", booleanAttribute],
          replaceUrl: [2, "replaceUrl", "replaceUrl", booleanAttribute],
          routerLink: "routerLink"
        },
        features: [\u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterLink, [{
        type: Directive,
        args: [{
          selector: "[routerLink]",
          host: {
            "[attr.href]": "reactiveHref()"
          }
        }]
      }], () => [{
        type: Router
      }, {
        type: ActivatedRoute
      }, {
        type: void 0,
        decorators: [{
          type: Attribute,
          args: ["tabindex"]
        }]
      }, {
        type: Renderer2
      }, {
        type: ElementRef
      }, {
        type: LocationStrategy
      }], {
        target: [{
          type: HostBinding,
          args: ["attr.target"]
        }, {
          type: Input
        }],
        queryParams: [{
          type: Input
        }],
        fragment: [{
          type: Input
        }],
        queryParamsHandling: [{
          type: Input
        }],
        state: [{
          type: Input
        }],
        info: [{
          type: Input
        }],
        relativeTo: [{
          type: Input
        }],
        preserveFragment: [{
          type: Input,
          args: [{
            transform: booleanAttribute
          }]
        }],
        skipLocationChange: [{
          type: Input,
          args: [{
            transform: booleanAttribute
          }]
        }],
        replaceUrl: [{
          type: Input,
          args: [{
            transform: booleanAttribute
          }]
        }],
        routerLink: [{
          type: Input
        }],
        onClick: [{
          type: HostListener,
          args: ["click", ["$event.button", "$event.ctrlKey", "$event.shiftKey", "$event.altKey", "$event.metaKey"]]
        }]
      });
    })();
    RouterLinkActive = class _RouterLinkActive {
      router;
      element;
      renderer;
      cdr;
      link;
      links;
      classes = [];
      routerEventsSubscription;
      linkInputChangesSubscription;
      _isActive = false;
      get isActive() {
        return this._isActive;
      }
      /**
       * Options to configure how to determine if the router link is active.
       *
       * These options are passed to the `Router.isActive()` function.
       *
       * @see {@link Router#isActive}
       */
      routerLinkActiveOptions = {
        exact: false
      };
      /**
       * Aria-current attribute to apply when the router link is active.
       *
       * Possible values: `'page'` | `'step'` | `'location'` | `'date'` | `'time'` | `true` | `false`.
       *
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-current}
       */
      ariaCurrentWhenActive;
      /**
       *
       * You can use the output `isActiveChange` to get notified each time the link becomes
       * active or inactive.
       *
       * Emits:
       * true  -> Route is active
       * false -> Route is inactive
       *
       * ```html
       * <a
       *  routerLink="/user/bob"
       *  routerLinkActive="active-link"
       *  (isActiveChange)="this.onRouterLinkActive($event)">Bob</a>
       * ```
       */
      isActiveChange = new EventEmitter();
      constructor(router, element, renderer, cdr, link) {
        this.router = router;
        this.element = element;
        this.renderer = renderer;
        this.cdr = cdr;
        this.link = link;
        this.routerEventsSubscription = router.events.subscribe((s) => {
          if (s instanceof NavigationEnd) {
            this.update();
          }
        });
      }
      /** @docs-private */
      ngAfterContentInit() {
        of(this.links.changes, of(null)).pipe(mergeAll()).subscribe((_) => {
          this.update();
          this.subscribeToEachLinkOnChanges();
        });
      }
      subscribeToEachLinkOnChanges() {
        this.linkInputChangesSubscription?.unsubscribe();
        const allLinkChanges = [...this.links.toArray(), this.link].filter((link) => !!link).map((link) => link.onChanges);
        this.linkInputChangesSubscription = from(allLinkChanges).pipe(mergeAll()).subscribe((link) => {
          if (this._isActive !== this.isLinkActive(this.router)(link)) {
            this.update();
          }
        });
      }
      set routerLinkActive(data2) {
        const classes = Array.isArray(data2) ? data2 : data2.split(" ");
        this.classes = classes.filter((c) => !!c);
      }
      /** @docs-private */
      ngOnChanges(changes) {
        this.update();
      }
      /** @docs-private */
      ngOnDestroy() {
        this.routerEventsSubscription.unsubscribe();
        this.linkInputChangesSubscription?.unsubscribe();
      }
      update() {
        if (!this.links || !this.router.navigated) return;
        queueMicrotask(() => {
          const hasActiveLinks = this.hasActiveLinks();
          this.classes.forEach((c) => {
            if (hasActiveLinks) {
              this.renderer.addClass(this.element.nativeElement, c);
            } else {
              this.renderer.removeClass(this.element.nativeElement, c);
            }
          });
          if (hasActiveLinks && this.ariaCurrentWhenActive !== void 0) {
            this.renderer.setAttribute(this.element.nativeElement, "aria-current", this.ariaCurrentWhenActive.toString());
          } else {
            this.renderer.removeAttribute(this.element.nativeElement, "aria-current");
          }
          if (this._isActive !== hasActiveLinks) {
            this._isActive = hasActiveLinks;
            this.cdr.markForCheck();
            this.isActiveChange.emit(hasActiveLinks);
          }
        });
      }
      isLinkActive(router) {
        const options = isActiveMatchOptions(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : (
          // While the types should disallow `undefined` here, it's possible without strict inputs
          this.routerLinkActiveOptions.exact || false
        );
        return (link) => {
          const urlTree = link.urlTree;
          return urlTree ? router.isActive(urlTree, options) : false;
        };
      }
      hasActiveLinks() {
        const isActiveCheckFn = this.isLinkActive(this.router);
        return this.link && isActiveCheckFn(this.link) || this.links.some(isActiveCheckFn);
      }
      static \u0275fac = function RouterLinkActive_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _RouterLinkActive)(\u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(RouterLink, 8));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _RouterLinkActive,
        selectors: [["", "routerLinkActive", ""]],
        contentQueries: function RouterLinkActive_ContentQueries(rf, ctx, dirIndex) {
          if (rf & 1) {
            \u0275\u0275contentQuery(dirIndex, RouterLink, 5);
          }
          if (rf & 2) {
            let _t;
            \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.links = _t);
          }
        },
        inputs: {
          routerLinkActiveOptions: "routerLinkActiveOptions",
          ariaCurrentWhenActive: "ariaCurrentWhenActive",
          routerLinkActive: "routerLinkActive"
        },
        outputs: {
          isActiveChange: "isActiveChange"
        },
        exportAs: ["routerLinkActive"],
        features: [\u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterLinkActive, [{
        type: Directive,
        args: [{
          selector: "[routerLinkActive]",
          exportAs: "routerLinkActive"
        }]
      }], () => [{
        type: Router
      }, {
        type: ElementRef
      }, {
        type: Renderer2
      }, {
        type: ChangeDetectorRef
      }, {
        type: RouterLink,
        decorators: [{
          type: Optional
        }]
      }], {
        links: [{
          type: ContentChildren,
          args: [RouterLink, {
            descendants: true
          }]
        }],
        routerLinkActiveOptions: [{
          type: Input
        }],
        ariaCurrentWhenActive: [{
          type: Input
        }],
        isActiveChange: [{
          type: Output
        }],
        routerLinkActive: [{
          type: Input
        }]
      });
    })();
    PreloadingStrategy = class {
    };
    PreloadAllModules = class _PreloadAllModules {
      preload(route, fn) {
        return fn().pipe(catchError(() => of(null)));
      }
      static \u0275fac = function PreloadAllModules_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _PreloadAllModules)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _PreloadAllModules,
        factory: _PreloadAllModules.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreloadAllModules, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    NoPreloading = class _NoPreloading {
      preload(route, fn) {
        return of(null);
      }
      static \u0275fac = function NoPreloading_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NoPreloading)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _NoPreloading,
        factory: _NoPreloading.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoPreloading, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    RouterPreloader = class _RouterPreloader {
      router;
      injector;
      preloadingStrategy;
      loader;
      subscription;
      constructor(router, injector, preloadingStrategy, loader) {
        this.router = router;
        this.injector = injector;
        this.preloadingStrategy = preloadingStrategy;
        this.loader = loader;
      }
      setUpPreloading() {
        this.subscription = this.router.events.pipe(filter((e) => e instanceof NavigationEnd), concatMap(() => this.preload())).subscribe(() => {
        });
      }
      preload() {
        return this.processRoutes(this.injector, this.router.config);
      }
      /** @docs-private */
      ngOnDestroy() {
        if (this.subscription) {
          this.subscription.unsubscribe();
        }
      }
      processRoutes(injector, routes2) {
        const res = [];
        for (const route of routes2) {
          if (route.providers && !route._injector) {
            route._injector = createEnvironmentInjector(route.providers, injector, `Route: ${route.path}`);
          }
          const injectorForCurrentRoute = route._injector ?? injector;
          const injectorForChildren = route._loadedInjector ?? injectorForCurrentRoute;
          if (route.loadChildren && !route._loadedRoutes && route.canLoad === void 0 || route.loadComponent && !route._loadedComponent) {
            res.push(this.preloadConfig(injectorForCurrentRoute, route));
          }
          if (route.children || route._loadedRoutes) {
            res.push(this.processRoutes(injectorForChildren, route.children ?? route._loadedRoutes));
          }
        }
        return from(res).pipe(mergeAll());
      }
      preloadConfig(injector, route) {
        return this.preloadingStrategy.preload(route, () => {
          let loadedChildren$;
          if (route.loadChildren && route.canLoad === void 0) {
            loadedChildren$ = this.loader.loadChildren(injector, route);
          } else {
            loadedChildren$ = of(null);
          }
          const recursiveLoadChildren$ = loadedChildren$.pipe(mergeMap((config3) => {
            if (config3 === null) {
              return of(void 0);
            }
            route._loadedRoutes = config3.routes;
            route._loadedInjector = config3.injector;
            return this.processRoutes(config3.injector ?? injector, config3.routes);
          }));
          if (route.loadComponent && !route._loadedComponent) {
            const loadComponent$ = this.loader.loadComponent(injector, route);
            return from([recursiveLoadChildren$, loadComponent$]).pipe(mergeAll());
          } else {
            return recursiveLoadChildren$;
          }
        });
      }
      static \u0275fac = function RouterPreloader_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _RouterPreloader)(\u0275\u0275inject(Router), \u0275\u0275inject(EnvironmentInjector), \u0275\u0275inject(PreloadingStrategy), \u0275\u0275inject(RouterConfigLoader));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _RouterPreloader,
        factory: _RouterPreloader.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterPreloader, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [{
        type: Router
      }, {
        type: EnvironmentInjector
      }, {
        type: PreloadingStrategy
      }, {
        type: RouterConfigLoader
      }], null);
    })();
    ROUTER_SCROLLER = new InjectionToken("");
    RouterScroller = class _RouterScroller {
      urlSerializer;
      transitions;
      viewportScroller;
      zone;
      options;
      routerEventsSubscription;
      scrollEventsSubscription;
      lastId = 0;
      lastSource = IMPERATIVE_NAVIGATION;
      restoredId = 0;
      store = {};
      /** @docs-private */
      constructor(urlSerializer, transitions, viewportScroller, zone, options = {}) {
        this.urlSerializer = urlSerializer;
        this.transitions = transitions;
        this.viewportScroller = viewportScroller;
        this.zone = zone;
        this.options = options;
        options.scrollPositionRestoration ||= "disabled";
        options.anchorScrolling ||= "disabled";
      }
      init() {
        if (this.options.scrollPositionRestoration !== "disabled") {
          this.viewportScroller.setHistoryScrollRestoration("manual");
        }
        this.routerEventsSubscription = this.createScrollEvents();
        this.scrollEventsSubscription = this.consumeScrollEvents();
      }
      createScrollEvents() {
        return this.transitions.events.subscribe((e) => {
          if (e instanceof NavigationStart) {
            this.store[this.lastId] = this.viewportScroller.getScrollPosition();
            this.lastSource = e.navigationTrigger;
            this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;
          } else if (e instanceof NavigationEnd) {
            this.lastId = e.id;
            this.scheduleScrollEvent(e, this.urlSerializer.parse(e.urlAfterRedirects).fragment);
          } else if (e instanceof NavigationSkipped && e.code === NavigationSkippedCode.IgnoredSameUrlNavigation) {
            this.lastSource = void 0;
            this.restoredId = 0;
            this.scheduleScrollEvent(e, this.urlSerializer.parse(e.url).fragment);
          }
        });
      }
      consumeScrollEvents() {
        return this.transitions.events.subscribe((e) => {
          if (!(e instanceof Scroll)) return;
          if (e.position) {
            if (this.options.scrollPositionRestoration === "top") {
              this.viewportScroller.scrollToPosition([0, 0]);
            } else if (this.options.scrollPositionRestoration === "enabled") {
              this.viewportScroller.scrollToPosition(e.position);
            }
          } else {
            if (e.anchor && this.options.anchorScrolling === "enabled") {
              this.viewportScroller.scrollToAnchor(e.anchor);
            } else if (this.options.scrollPositionRestoration !== "disabled") {
              this.viewportScroller.scrollToPosition([0, 0]);
            }
          }
        });
      }
      scheduleScrollEvent(routerEvent, anchor) {
        this.zone.runOutsideAngular(() => __async(this, null, function* () {
          yield new Promise((resolve) => {
            setTimeout(resolve);
            if (typeof requestAnimationFrame !== "undefined") {
              requestAnimationFrame(resolve);
            }
          });
          this.zone.run(() => {
            this.transitions.events.next(new Scroll(routerEvent, this.lastSource === "popstate" ? this.store[this.restoredId] : null, anchor));
          });
        }));
      }
      /** @docs-private */
      ngOnDestroy() {
        this.routerEventsSubscription?.unsubscribe();
        this.scrollEventsSubscription?.unsubscribe();
      }
      static \u0275fac = function RouterScroller_Factory(__ngFactoryType__) {
        \u0275\u0275invalidFactory();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _RouterScroller,
        factory: _RouterScroller.\u0275fac
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterScroller, [{
        type: Injectable
      }], () => [{
        type: UrlSerializer
      }, {
        type: NavigationTransitions
      }, {
        type: ViewportScroller
      }, {
        type: NgZone
      }, {
        type: void 0
      }], null);
    })();
    ROUTER_IS_PROVIDED = new InjectionToken("", {
      providedIn: "root",
      factory: () => false
    });
    BOOTSTRAP_DONE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "bootstrap done indicator" : "", {
      factory: () => {
        return new Subject();
      }
    });
    INITIAL_NAVIGATION = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "initial navigation" : "", {
      providedIn: "root",
      factory: () => 1
      /* InitialNavigation.EnabledNonBlocking */
    });
    ROUTER_PRELOADER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "router preloader" : "");
    ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkActive, \u0275EmptyOutletComponent];
    ROUTER_FORROOT_GUARD = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "router duplicate forRoot guard" : "");
    ROUTER_PROVIDERS = [
      Location,
      {
        provide: UrlSerializer,
        useClass: DefaultUrlSerializer
      },
      Router,
      ChildrenOutletContexts,
      {
        provide: ActivatedRoute,
        useFactory: rootRoute,
        deps: [Router]
      },
      RouterConfigLoader,
      // Only used to warn when `provideRoutes` is used without `RouterModule` or `provideRouter`. Can
      // be removed when `provideRoutes` is removed.
      typeof ngDevMode === "undefined" || ngDevMode ? {
        provide: ROUTER_IS_PROVIDED,
        useValue: true
      } : []
    ];
    RouterModule = class _RouterModule {
      constructor() {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          inject2(ROUTER_FORROOT_GUARD, {
            optional: true
          });
        }
      }
      /**
       * Creates and configures a module with all the router providers and directives.
       * Optionally sets up an application listener to perform an initial navigation.
       *
       * When registering the NgModule at the root, import as follows:
       *
       * ```ts
       * @NgModule({
       *   imports: [RouterModule.forRoot(ROUTES)]
       * })
       * class MyNgModule {}
       * ```
       *
       * @param routes An array of `Route` objects that define the navigation paths for the application.
       * @param config An `ExtraOptions` configuration object that controls how navigation is performed.
       * @return The new `NgModule`.
       *
       */
      static forRoot(routes2, config3) {
        return {
          ngModule: _RouterModule,
          providers: [ROUTER_PROVIDERS, typeof ngDevMode === "undefined" || ngDevMode ? config3?.enableTracing ? withDebugTracing().\u0275providers : [] : [], {
            provide: ROUTES,
            multi: true,
            useValue: routes2
          }, typeof ngDevMode === "undefined" || ngDevMode ? {
            provide: ROUTER_FORROOT_GUARD,
            useFactory: provideForRootGuard,
            deps: [[Router, new Optional(), new SkipSelf()]]
          } : [], config3?.errorHandler ? {
            provide: NAVIGATION_ERROR_HANDLER,
            useValue: config3.errorHandler
          } : [], {
            provide: ROUTER_CONFIGURATION,
            useValue: config3 ? config3 : {}
          }, config3?.useHash ? provideHashLocationStrategy() : providePathLocationStrategy(), provideRouterScroller(), config3?.preloadingStrategy ? withPreloading(config3.preloadingStrategy).\u0275providers : [], config3?.initialNavigation ? provideInitialNavigation(config3) : [], config3?.bindToComponentInputs ? withComponentInputBinding().\u0275providers : [], config3?.enableViewTransitions ? withViewTransitions().\u0275providers : [], provideRouterInitializer()]
        };
      }
      /**
       * Creates a module with all the router directives and a provider registering routes,
       * without creating a new Router service.
       * When registering for submodules and lazy-loaded submodules, create the NgModule as follows:
       *
       * ```ts
       * @NgModule({
       *   imports: [RouterModule.forChild(ROUTES)]
       * })
       * class MyNgModule {}
       * ```
       *
       * @param routes An array of `Route` objects that define the navigation paths for the submodule.
       * @return The new NgModule.
       *
       */
      static forChild(routes2) {
        return {
          ngModule: _RouterModule,
          providers: [{
            provide: ROUTES,
            multi: true,
            useValue: routes2
          }]
        };
      }
      static \u0275fac = function RouterModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _RouterModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _RouterModule,
        imports: [RouterOutlet, RouterLink, RouterLinkActive, \u0275EmptyOutletComponent],
        exports: [RouterOutlet, RouterLink, RouterLinkActive, \u0275EmptyOutletComponent]
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterModule, [{
        type: NgModule,
        args: [{
          imports: ROUTER_DIRECTIVES,
          exports: ROUTER_DIRECTIVES
        }]
      }], () => [], null);
    })();
    ROUTER_INITIALIZER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "Router Initializer" : "");
  }
});

// node_modules/@angular/router/fesm2022/router.mjs
var VERSION4;
var init_router = __esm({
  "node_modules/@angular/router/fesm2022/router.mjs"() {
    "use strict";
    init_router_module();
    init_core();
    VERSION4 = new Version("20.1.7");
  }
});

// node_modules/@angular/forms/fesm2022/forms.mjs
function _isAndroid() {
  const userAgent = getDOM() ? getDOM().getUserAgent() : "";
  return /android (\d+)/.test(userAgent.toLowerCase());
}
function isEmptyInputValue(value) {
  return value == null || lengthOrSize(value) === 0;
}
function lengthOrSize(value) {
  if (value == null) {
    return null;
  } else if (Array.isArray(value) || typeof value === "string") {
    return value.length;
  } else if (value instanceof Set) {
    return value.size;
  }
  return null;
}
function minValidator(min) {
  return (control) => {
    if (control.value == null || min == null) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value < min ? {
      "min": {
        "min": min,
        "actual": control.value
      }
    } : null;
  };
}
function maxValidator(max) {
  return (control) => {
    if (control.value == null || max == null) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value > max ? {
      "max": {
        "max": max,
        "actual": control.value
      }
    } : null;
  };
}
function requiredValidator(control) {
  return isEmptyInputValue(control.value) ? {
    "required": true
  } : null;
}
function requiredTrueValidator(control) {
  return control.value === true ? null : {
    "required": true
  };
}
function emailValidator(control) {
  if (isEmptyInputValue(control.value)) {
    return null;
  }
  return EMAIL_REGEXP.test(control.value) ? null : {
    "email": true
  };
}
function minLengthValidator(minLength) {
  return (control) => {
    const length = control.value?.length ?? lengthOrSize(control.value);
    if (length === null || length === 0) {
      return null;
    }
    return length < minLength ? {
      "minlength": {
        "requiredLength": minLength,
        "actualLength": length
      }
    } : null;
  };
}
function maxLengthValidator(maxLength) {
  return (control) => {
    const length = control.value?.length ?? lengthOrSize(control.value);
    if (length !== null && length > maxLength) {
      return {
        "maxlength": {
          "requiredLength": maxLength,
          "actualLength": length
        }
      };
    }
    return null;
  };
}
function patternValidator(pattern) {
  if (!pattern) return nullValidator;
  let regex;
  let regexStr;
  if (typeof pattern === "string") {
    regexStr = "";
    if (pattern.charAt(0) !== "^") regexStr += "^";
    regexStr += pattern;
    if (pattern.charAt(pattern.length - 1) !== "$") regexStr += "$";
    regex = new RegExp(regexStr);
  } else {
    regexStr = pattern.toString();
    regex = pattern;
  }
  return (control) => {
    if (isEmptyInputValue(control.value)) {
      return null;
    }
    const value = control.value;
    return regex.test(value) ? null : {
      "pattern": {
        "requiredPattern": regexStr,
        "actualValue": value
      }
    };
  };
}
function nullValidator(control) {
  return null;
}
function isPresent(o) {
  return o != null;
}
function toObservable(value) {
  const obs = isPromise2(value) ? from(value) : value;
  if ((typeof ngDevMode === "undefined" || ngDevMode) && !isSubscribable(obs)) {
    let errorMessage = `Expected async validator to return Promise or Observable.`;
    if (typeof value === "object") {
      errorMessage += " Are you using a synchronous validator where an async validator is expected?";
    }
    throw new RuntimeError(-1101, errorMessage);
  }
  return obs;
}
function mergeErrors(arrayOfErrors) {
  let res = {};
  arrayOfErrors.forEach((errors) => {
    res = errors != null ? __spreadValues(__spreadValues({}, res), errors) : res;
  });
  return Object.keys(res).length === 0 ? null : res;
}
function executeValidators(control, validators) {
  return validators.map((validator) => validator(control));
}
function isValidatorFn(validator) {
  return !validator.validate;
}
function normalizeValidators(validators) {
  return validators.map((validator) => {
    return isValidatorFn(validator) ? validator : (c) => validator.validate(c);
  });
}
function compose(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function(control) {
    return mergeErrors(executeValidators(control, presentValidators));
  };
}
function composeValidators(validators) {
  return validators != null ? compose(normalizeValidators(validators)) : null;
}
function composeAsync(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function(control) {
    const observables = executeValidators(control, presentValidators).map(toObservable);
    return forkJoin(observables).pipe(map(mergeErrors));
  };
}
function composeAsyncValidators(validators) {
  return validators != null ? composeAsync(normalizeValidators(validators)) : null;
}
function mergeValidators(controlValidators, dirValidator) {
  if (controlValidators === null) return [dirValidator];
  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] : [controlValidators, dirValidator];
}
function getControlValidators(control) {
  return control._rawValidators;
}
function getControlAsyncValidators(control) {
  return control._rawAsyncValidators;
}
function makeValidatorsArray(validators) {
  if (!validators) return [];
  return Array.isArray(validators) ? validators : [validators];
}
function hasValidator(validators, validator) {
  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;
}
function addValidators(validators, currentValidators) {
  const current = makeValidatorsArray(currentValidators);
  const validatorsToAdd = makeValidatorsArray(validators);
  validatorsToAdd.forEach((v) => {
    if (!hasValidator(current, v)) {
      current.push(v);
    }
  });
  return current;
}
function removeValidators(validators, currentValidators) {
  return makeValidatorsArray(currentValidators).filter((v) => !hasValidator(validators, v));
}
function controlParentException(nameOrIndex) {
  return new RuntimeError(1050, `formControlName must be used with a parent formGroup directive. You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      ${describeFormControl(nameOrIndex)}

    Example:

    ${formControlNameExample}`);
}
function describeFormControl(nameOrIndex) {
  if (nameOrIndex == null || nameOrIndex === "") {
    return "";
  }
  const valueType = typeof nameOrIndex === "string" ? "name" : "index";
  return `Affected Form Control ${valueType}: "${nameOrIndex}"`;
}
function ngModelGroupException() {
  return new RuntimeError(1051, `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents
      that also have a "form" prefix: formGroupName, formArrayName, or formGroup.

      Option 1:  Update the parent to be formGroupName (reactive form strategy)

      ${formGroupNameExample}

      Option 2: Use ngModel instead of formControlName (template-driven strategy)

      ${ngModelGroupExample}`);
}
function missingFormException() {
  return new RuntimeError(1052, `formGroup expects a FormGroup instance. Please pass one in.

      Example:

      ${formControlNameExample}`);
}
function groupParentException() {
  return new RuntimeError(1053, `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup
    directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formGroupNameExample}`);
}
function arrayParentException() {
  return new RuntimeError(1054, `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      Example:

      ${formArrayNameExample}`);
}
function ngModelWarning(directiveName) {
  return `
  It looks like you're using ngModel on the same form field as ${directiveName}.
  Support for using the ngModel input property and ngModelChange event with
  reactive form directives has been deprecated in Angular v6 and will be removed
  in a future version of Angular.

  For more information on this, see our API docs here:
  https://angular.io/api/forms/${directiveName === "formControl" ? "FormControlDirective" : "FormControlName"}#use-with-ngmodel
  `;
}
function describeKey(isFormGroup, key) {
  return isFormGroup ? `with name: '${key}'` : `at index: ${key}`;
}
function noControlsError(isFormGroup) {
  return `
    There are no form controls registered with this ${isFormGroup ? "group" : "array"} yet. If you're using ngModel,
    you may want to check next tick (e.g. use setTimeout).
  `;
}
function missingControlError(isFormGroup, key) {
  return `Cannot find form control ${describeKey(isFormGroup, key)}`;
}
function missingControlValueError(isFormGroup, key) {
  return `Must supply a value for form control ${describeKey(isFormGroup, key)}`;
}
function pickValidators(validatorOrOpts) {
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;
}
function coerceToValidator(validator) {
  return Array.isArray(validator) ? composeValidators(validator) : validator || null;
}
function pickAsyncValidators(asyncValidator, validatorOrOpts) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (isOptionsObj(validatorOrOpts) && asyncValidator) {
      console.warn(asyncValidatorsDroppedWithOptsWarning);
    }
  }
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;
}
function coerceToAsyncValidator(asyncValidator) {
  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator || null;
}
function isOptionsObj(validatorOrOpts) {
  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) && typeof validatorOrOpts === "object";
}
function assertControlPresent(parent, isGroup, key) {
  const controls = parent.controls;
  const collection = isGroup ? Object.keys(controls) : controls;
  if (!collection.length) {
    throw new RuntimeError(1e3, typeof ngDevMode === "undefined" || ngDevMode ? noControlsError(isGroup) : "");
  }
  if (!controls[key]) {
    throw new RuntimeError(1001, typeof ngDevMode === "undefined" || ngDevMode ? missingControlError(isGroup, key) : "");
  }
}
function assertAllValuesPresent(control, isGroup, value) {
  control._forEachChild((_, key) => {
    if (value[key] === void 0) {
      throw new RuntimeError(1002, typeof ngDevMode === "undefined" || ngDevMode ? missingControlValueError(isGroup, key) : "");
    }
  });
}
function validateFormGroupControls(controls) {
  const invalidKeys = Object.keys(controls).filter((key) => key.includes("."));
  if (invalidKeys.length > 0) {
    console.warn(`FormGroup keys cannot include \`.\`, please replace the keys for: ${invalidKeys.join(",")}.`);
  }
}
function controlPath(name2, parent) {
  return [...parent.path, name2];
}
function setUpControl(control, dir, callSetDisabledState = setDisabledStateDefault) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (!control) _throwError(dir, "Cannot find control with");
    if (!dir.valueAccessor) _throwMissingValueAccessorError(dir);
  }
  setUpValidators(control, dir);
  dir.valueAccessor.writeValue(control.value);
  if (control.disabled || callSetDisabledState === "always") {
    dir.valueAccessor.setDisabledState?.(control.disabled);
  }
  setUpViewChangePipeline(control, dir);
  setUpModelChangePipeline(control, dir);
  setUpBlurPipeline(control, dir);
  setUpDisabledChangeHandler(control, dir);
}
function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {
  const noop4 = () => {
    if (validateControlPresenceOnChange && (typeof ngDevMode === "undefined" || ngDevMode)) {
      _noControlError(dir);
    }
  };
  if (dir.valueAccessor) {
    dir.valueAccessor.registerOnChange(noop4);
    dir.valueAccessor.registerOnTouched(noop4);
  }
  cleanUpValidators(control, dir);
  if (control) {
    dir._invokeOnDestroyCallbacks();
    control._registerOnCollectionChange(() => {
    });
  }
}
function registerOnValidatorChange(validators, onChange) {
  validators.forEach((validator) => {
    if (validator.registerOnValidatorChange) validator.registerOnValidatorChange(onChange);
  });
}
function setUpDisabledChangeHandler(control, dir) {
  if (dir.valueAccessor.setDisabledState) {
    const onDisabledChange = (isDisabled) => {
      dir.valueAccessor.setDisabledState(isDisabled);
    };
    control.registerOnDisabledChange(onDisabledChange);
    dir._registerOnDestroy(() => {
      control._unregisterOnDisabledChange(onDisabledChange);
    });
  }
}
function setUpValidators(control, dir) {
  const validators = getControlValidators(control);
  if (dir.validator !== null) {
    control.setValidators(mergeValidators(validators, dir.validator));
  } else if (typeof validators === "function") {
    control.setValidators([validators]);
  }
  const asyncValidators = getControlAsyncValidators(control);
  if (dir.asyncValidator !== null) {
    control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));
  } else if (typeof asyncValidators === "function") {
    control.setAsyncValidators([asyncValidators]);
  }
  const onValidatorChange = () => control.updateValueAndValidity();
  registerOnValidatorChange(dir._rawValidators, onValidatorChange);
  registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);
}
function cleanUpValidators(control, dir) {
  let isControlUpdated = false;
  if (control !== null) {
    if (dir.validator !== null) {
      const validators = getControlValidators(control);
      if (Array.isArray(validators) && validators.length > 0) {
        const updatedValidators = validators.filter((validator) => validator !== dir.validator);
        if (updatedValidators.length !== validators.length) {
          isControlUpdated = true;
          control.setValidators(updatedValidators);
        }
      }
    }
    if (dir.asyncValidator !== null) {
      const asyncValidators = getControlAsyncValidators(control);
      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {
        const updatedAsyncValidators = asyncValidators.filter((asyncValidator) => asyncValidator !== dir.asyncValidator);
        if (updatedAsyncValidators.length !== asyncValidators.length) {
          isControlUpdated = true;
          control.setAsyncValidators(updatedAsyncValidators);
        }
      }
    }
  }
  const noop4 = () => {
  };
  registerOnValidatorChange(dir._rawValidators, noop4);
  registerOnValidatorChange(dir._rawAsyncValidators, noop4);
  return isControlUpdated;
}
function setUpViewChangePipeline(control, dir) {
  dir.valueAccessor.registerOnChange((newValue) => {
    control._pendingValue = newValue;
    control._pendingChange = true;
    control._pendingDirty = true;
    if (control.updateOn === "change") updateControl(control, dir);
  });
}
function setUpBlurPipeline(control, dir) {
  dir.valueAccessor.registerOnTouched(() => {
    control._pendingTouched = true;
    if (control.updateOn === "blur" && control._pendingChange) updateControl(control, dir);
    if (control.updateOn !== "submit") control.markAsTouched();
  });
}
function updateControl(control, dir) {
  if (control._pendingDirty) control.markAsDirty();
  control.setValue(control._pendingValue, {
    emitModelToViewChange: false
  });
  dir.viewToModelUpdate(control._pendingValue);
  control._pendingChange = false;
}
function setUpModelChangePipeline(control, dir) {
  const onChange = (newValue, emitModelEvent) => {
    dir.valueAccessor.writeValue(newValue);
    if (emitModelEvent) dir.viewToModelUpdate(newValue);
  };
  control.registerOnChange(onChange);
  dir._registerOnDestroy(() => {
    control._unregisterOnChange(onChange);
  });
}
function setUpFormContainer(control, dir) {
  if (control == null && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "Cannot find control with");
  setUpValidators(control, dir);
}
function cleanUpFormContainer(control, dir) {
  return cleanUpValidators(control, dir);
}
function _noControlError(dir) {
  return _throwError(dir, "There is no FormControl instance attached to form control element with");
}
function _throwError(dir, message) {
  const messageEnd = _describeControlLocation(dir);
  throw new Error(`${message} ${messageEnd}`);
}
function _describeControlLocation(dir) {
  const path = dir.path;
  if (path && path.length > 1) return `path: '${path.join(" -> ")}'`;
  if (path?.[0]) return `name: '${path}'`;
  return "unspecified name attribute";
}
function _throwMissingValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(-1203, `No value accessor for form control ${loc}.`);
}
function _throwInvalidValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(1200, `Value accessor was not provided as an array for form control with ${loc}. Check that the \`NG_VALUE_ACCESSOR\` token is configured as a \`multi: true\` provider.`);
}
function isPropertyUpdated(changes, viewModel) {
  if (!changes.hasOwnProperty("model")) return false;
  const change = changes["model"];
  if (change.isFirstChange()) return true;
  return !Object.is(viewModel, change.currentValue);
}
function isBuiltInAccessor(valueAccessor) {
  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;
}
function syncPendingControls(form, directives) {
  form._syncPendingControls();
  directives.forEach((dir) => {
    const control = dir.control;
    if (control.updateOn === "submit" && control._pendingChange) {
      dir.viewToModelUpdate(control._pendingValue);
      control._pendingChange = false;
    }
  });
}
function selectValueAccessor(dir, valueAccessors) {
  if (!valueAccessors) return null;
  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === "undefined" || ngDevMode)) _throwInvalidValueAccessorError(dir);
  let defaultAccessor = void 0;
  let builtinAccessor = void 0;
  let customAccessor = void 0;
  valueAccessors.forEach((v) => {
    if (v.constructor === DefaultValueAccessor) {
      defaultAccessor = v;
    } else if (isBuiltInAccessor(v)) {
      if (builtinAccessor && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "More than one built-in value accessor matches form control with");
      builtinAccessor = v;
    } else {
      if (customAccessor && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "More than one custom value accessor matches form control with");
      customAccessor = v;
    }
  });
  if (customAccessor) return customAccessor;
  if (builtinAccessor) return builtinAccessor;
  if (defaultAccessor) return defaultAccessor;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    _throwError(dir, "No valid value accessor for form control with");
  }
  return null;
}
function removeListItem$1(list, el) {
  const index = list.indexOf(el);
  if (index > -1) list.splice(index, 1);
}
function _ngModelWarning(name2, type, instance, warningConfig) {
  if (warningConfig === "never") return;
  if ((warningConfig === null || warningConfig === "once") && !type._ngModelWarningSentOnce || warningConfig === "always" && !instance._ngModelWarningSent) {
    console.warn(ngModelWarning(name2));
    type._ngModelWarningSentOnce = true;
    instance._ngModelWarningSent = true;
  }
}
function removeListItem(list, el) {
  const index = list.indexOf(el);
  if (index > -1) list.splice(index, 1);
}
function isFormControlState(formState) {
  return typeof formState === "object" && formState !== null && Object.keys(formState).length === 2 && "value" in formState && "disabled" in formState;
}
function modelParentException() {
  return new RuntimeError(1350, `
    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using
    formGroup's partner directive "formControlName" instead.  Example:

    ${formControlNameExample}

    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:

    Example:

    ${ngModelWithFormGroupExample}`);
}
function formGroupNameException() {
  return new RuntimeError(1351, `
    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.

    Option 1: Use formControlName instead of ngModel (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):

    ${ngModelGroupExample}`);
}
function missingNameException() {
  return new RuntimeError(1352, `If ngModel is used within a form tag, either the name attribute must be set or the form
    control must be defined as 'standalone' in ngModelOptions.

    Example 1: <input [(ngModel)]="person.firstName" name="first">
    Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">`);
}
function modelGroupParentException() {
  return new RuntimeError(1353, `
    ngModelGroup cannot be used with a parent formGroup directive.

    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):

    ${ngModelGroupExample}`);
}
function checkParentType$1(parent) {
  if (!(parent instanceof NgModelGroup) && parent instanceof AbstractFormGroupDirective) {
    throw formGroupNameException();
  } else if (!(parent instanceof NgModelGroup) && !(parent instanceof NgForm)) {
    throw modelParentException();
  }
}
function throwNameError() {
  throw new RuntimeError(1202, `
      If you define both a name and a formControlName attribute on your radio button, their values
      must match. Ex: <input type="radio" formControlName="food" name="food">
    `);
}
function hasInvalidParent(parent) {
  return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName);
}
function checkParentType(parent, name2) {
  if (!(parent instanceof FormGroupName) && parent instanceof AbstractFormGroupDirective) {
    throw ngModelGroupException();
  } else if (!(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName)) {
    throw controlParentException(name2);
  }
}
function _buildValueString$1(id2, value) {
  if (id2 == null) return `${value}`;
  if (value && typeof value === "object") value = "Object";
  return `${id2}: ${value}`.slice(0, 50);
}
function _extractId$1(valueString) {
  return valueString.split(":")[0];
}
function _buildValueString(id2, value) {
  if (id2 == null) return `${value}`;
  if (typeof value === "string") value = `'${value}'`;
  if (value && typeof value === "object") value = "Object";
  return `${id2}: ${value}`.slice(0, 50);
}
function _extractId(valueString) {
  return valueString.split(":")[0];
}
function toInteger(value) {
  return typeof value === "number" ? value : parseInt(value, 10);
}
function toFloat(value) {
  return typeof value === "number" ? value : parseFloat(value);
}
function isAbstractControlOptions(options) {
  return !!options && (options.asyncValidators !== void 0 || options.validators !== void 0 || options.updateOn !== void 0);
}
var BaseControlValueAccessor, BuiltInControlValueAccessor, NG_VALUE_ACCESSOR, CHECKBOX_VALUE_ACCESSOR, CheckboxControlValueAccessor, DEFAULT_VALUE_ACCESSOR, COMPOSITION_BUFFER_MODE, DefaultValueAccessor, NG_VALIDATORS, NG_ASYNC_VALIDATORS, EMAIL_REGEXP, AbstractControlDirective, ControlContainer, NgControl, AbstractControlStatus, ngControlStatusHost, ngGroupStatusHost, NgControlStatus, NgControlStatusGroup, formControlNameExample, formGroupNameExample, formArrayNameExample, ngModelGroupExample, ngModelWithFormGroupExample, disabledAttrWarning, asyncValidatorsDroppedWithOptsWarning, VALID, INVALID, PENDING, DISABLED, ControlEvent, ValueChangeEvent, PristineChangeEvent, TouchedChangeEvent, StatusChangeEvent, FormSubmittedEvent, FormResetEvent, AbstractControl, FormGroup, FormRecord, CALL_SET_DISABLED_STATE, setDisabledStateDefault, formDirectiveProvider$1, resolvedPromise$1, NgForm, FormControl, isFormControl, AbstractFormGroupDirective, modelGroupProvider, NgModelGroup, formControlBinding$1, resolvedPromise, NgModel, \u0275NgNoValidate, NUMBER_VALUE_ACCESSOR, NumberValueAccessor, RADIO_VALUE_ACCESSOR, RadioControlRegistry, RadioControlValueAccessor, RANGE_VALUE_ACCESSOR, RangeValueAccessor, NG_MODEL_WITH_FORM_CONTROL_WARNING, formControlBinding, FormControlDirective, formDirectiveProvider, FormGroupDirective, formGroupNameProvider, FormGroupName, formArrayNameProvider, FormArrayName, controlNameBinding, FormControlName, SELECT_VALUE_ACCESSOR, SelectControlValueAccessor, NgSelectOption, SELECT_MULTIPLE_VALUE_ACCESSOR, SelectMultipleControlValueAccessor, \u0275NgSelectMultipleOption, AbstractValidatorDirective, MAX_VALIDATOR, MaxValidator, MIN_VALIDATOR, MinValidator, REQUIRED_VALIDATOR, CHECKBOX_REQUIRED_VALIDATOR, RequiredValidator, CheckboxRequiredValidator, EMAIL_VALIDATOR, EmailValidator, MIN_LENGTH_VALIDATOR, MinLengthValidator, MAX_LENGTH_VALIDATOR, MaxLengthValidator, PATTERN_VALIDATOR, PatternValidator, SHARED_FORM_DIRECTIVES, TEMPLATE_DRIVEN_DIRECTIVES, REACTIVE_DRIVEN_DIRECTIVES, \u0275InternalFormsSharedModule, FormArray, FormBuilder, NonNullableFormBuilder, UntypedFormBuilder, VERSION5, FormsModule, ReactiveFormsModule;
var init_forms = __esm({
  "node_modules/@angular/forms/fesm2022/forms.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_common();
    init_esm();
    init_operators();
    BaseControlValueAccessor = class _BaseControlValueAccessor {
      _renderer;
      _elementRef;
      /**
       * The registered callback function called when a change or input event occurs on the input
       * element.
       * @docs-private
       */
      onChange = (_) => {
      };
      /**
       * The registered callback function called when a blur event occurs on the input element.
       * @docs-private
       */
      onTouched = () => {
      };
      constructor(_renderer, _elementRef) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
      }
      /**
       * Helper method that sets a property on a target element using the current Renderer
       * implementation.
       * @docs-private
       */
      setProperty(key, value) {
        this._renderer.setProperty(this._elementRef.nativeElement, key, value);
      }
      /**
       * Registers a function called when the control is touched.
       * @docs-private
       */
      registerOnTouched(fn) {
        this.onTouched = fn;
      }
      /**
       * Registers a function called when the control value changes.
       * @docs-private
       */
      registerOnChange(fn) {
        this.onChange = fn;
      }
      /**
       * Sets the "disabled" property on the range input element.
       * @docs-private
       */
      setDisabledState(isDisabled) {
        this.setProperty("disabled", isDisabled);
      }
      static \u0275fac = function BaseControlValueAccessor_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _BaseControlValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _BaseControlValueAccessor
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseControlValueAccessor, [{
        type: Directive
      }], () => [{
        type: Renderer2
      }, {
        type: ElementRef
      }], null);
    })();
    BuiltInControlValueAccessor = class _BuiltInControlValueAccessor extends BaseControlValueAccessor {
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275BuiltInControlValueAccessor_BaseFactory;
        return function BuiltInControlValueAccessor_Factory(__ngFactoryType__) {
          return (\u0275BuiltInControlValueAccessor_BaseFactory || (\u0275BuiltInControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_BuiltInControlValueAccessor)))(__ngFactoryType__ || _BuiltInControlValueAccessor);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _BuiltInControlValueAccessor,
        features: [\u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BuiltInControlValueAccessor, [{
        type: Directive
      }], null, null);
    })();
    NG_VALUE_ACCESSOR = new InjectionToken(ngDevMode ? "NgValueAccessor" : "");
    CHECKBOX_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => CheckboxControlValueAccessor),
      multi: true
    };
    CheckboxControlValueAccessor = class _CheckboxControlValueAccessor extends BuiltInControlValueAccessor {
      /**
       * Sets the "checked" property on the input element.
       * @docs-private
       */
      writeValue(value) {
        this.setProperty("checked", value);
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275CheckboxControlValueAccessor_BaseFactory;
        return function CheckboxControlValueAccessor_Factory(__ngFactoryType__) {
          return (\u0275CheckboxControlValueAccessor_BaseFactory || (\u0275CheckboxControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_CheckboxControlValueAccessor)))(__ngFactoryType__ || _CheckboxControlValueAccessor);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CheckboxControlValueAccessor,
        selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]],
        hostBindings: function CheckboxControlValueAccessor_HostBindings(rf, ctx) {
          if (rf & 1) {
            \u0275\u0275listener("change", function CheckboxControlValueAccessor_change_HostBindingHandler($event) {
              return ctx.onChange($event.target.checked);
            })("blur", function CheckboxControlValueAccessor_blur_HostBindingHandler() {
              return ctx.onTouched();
            });
          }
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([CHECKBOX_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxControlValueAccessor, [{
        type: Directive,
        args: [{
          selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]",
          host: {
            "(change)": "onChange($any($event.target).checked)",
            "(blur)": "onTouched()"
          },
          providers: [CHECKBOX_VALUE_ACCESSOR],
          standalone: false
        }]
      }], null, null);
    })();
    DEFAULT_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => DefaultValueAccessor),
      multi: true
    };
    COMPOSITION_BUFFER_MODE = new InjectionToken(ngDevMode ? "CompositionEventMode" : "");
    DefaultValueAccessor = class _DefaultValueAccessor extends BaseControlValueAccessor {
      _compositionMode;
      /** Whether the user is creating a composition string (IME events). */
      _composing = false;
      constructor(renderer, elementRef, _compositionMode) {
        super(renderer, elementRef);
        this._compositionMode = _compositionMode;
        if (this._compositionMode == null) {
          this._compositionMode = !_isAndroid();
        }
      }
      /**
       * Sets the "value" property on the input element.
       * @docs-private
       */
      writeValue(value) {
        const normalizedValue = value == null ? "" : value;
        this.setProperty("value", normalizedValue);
      }
      /** @internal */
      _handleInput(value) {
        if (!this._compositionMode || this._compositionMode && !this._composing) {
          this.onChange(value);
        }
      }
      /** @internal */
      _compositionStart() {
        this._composing = true;
      }
      /** @internal */
      _compositionEnd(value) {
        this._composing = false;
        this._compositionMode && this.onChange(value);
      }
      static \u0275fac = function DefaultValueAccessor_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DefaultValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(COMPOSITION_BUFFER_MODE, 8));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _DefaultValueAccessor,
        selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]],
        hostBindings: function DefaultValueAccessor_HostBindings(rf, ctx) {
          if (rf & 1) {
            \u0275\u0275listener("input", function DefaultValueAccessor_input_HostBindingHandler($event) {
              return ctx._handleInput($event.target.value);
            })("blur", function DefaultValueAccessor_blur_HostBindingHandler() {
              return ctx.onTouched();
            })("compositionstart", function DefaultValueAccessor_compositionstart_HostBindingHandler() {
              return ctx._compositionStart();
            })("compositionend", function DefaultValueAccessor_compositionend_HostBindingHandler($event) {
              return ctx._compositionEnd($event.target.value);
            });
          }
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([DEFAULT_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultValueAccessor, [{
        type: Directive,
        args: [{
          selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]",
          // TODO: vsavkin replace the above selector with the one below it once
          // https://github.com/angular/angular/issues/3011 is implemented
          // selector: '[ngModel],[formControl],[formControlName]',
          host: {
            "(input)": "_handleInput($any($event.target).value)",
            "(blur)": "onTouched()",
            "(compositionstart)": "_compositionStart()",
            "(compositionend)": "_compositionEnd($any($event.target).value)"
          },
          providers: [DEFAULT_VALUE_ACCESSOR],
          standalone: false
        }]
      }], () => [{
        type: Renderer2
      }, {
        type: ElementRef
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [COMPOSITION_BUFFER_MODE]
        }]
      }], null);
    })();
    NG_VALIDATORS = new InjectionToken(ngDevMode ? "NgValidators" : "");
    NG_ASYNC_VALIDATORS = new InjectionToken(ngDevMode ? "NgAsyncValidators" : "");
    EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    AbstractControlDirective = class {
      /**
       * @description
       * Reports the value of the control if it is present, otherwise null.
       */
      get value() {
        return this.control ? this.control.value : null;
      }
      /**
       * @description
       * Reports whether the control is valid. A control is considered valid if no
       * validation errors exist with the current value.
       * If the control is not present, null is returned.
       */
      get valid() {
        return this.control ? this.control.valid : null;
      }
      /**
       * @description
       * Reports whether the control is invalid, meaning that an error exists in the input value.
       * If the control is not present, null is returned.
       */
      get invalid() {
        return this.control ? this.control.invalid : null;
      }
      /**
       * @description
       * Reports whether a control is pending, meaning that async validation is occurring and
       * errors are not yet available for the input value. If the control is not present, null is
       * returned.
       */
      get pending() {
        return this.control ? this.control.pending : null;
      }
      /**
       * @description
       * Reports whether the control is disabled, meaning that the control is disabled
       * in the UI and is exempt from validation checks and excluded from aggregate
       * values of ancestor controls. If the control is not present, null is returned.
       */
      get disabled() {
        return this.control ? this.control.disabled : null;
      }
      /**
       * @description
       * Reports whether the control is enabled, meaning that the control is included in ancestor
       * calculations of validity or value. If the control is not present, null is returned.
       */
      get enabled() {
        return this.control ? this.control.enabled : null;
      }
      /**
       * @description
       * Reports the control's validation errors. If the control is not present, null is returned.
       */
      get errors() {
        return this.control ? this.control.errors : null;
      }
      /**
       * @description
       * Reports whether the control is pristine, meaning that the user has not yet changed
       * the value in the UI. If the control is not present, null is returned.
       */
      get pristine() {
        return this.control ? this.control.pristine : null;
      }
      /**
       * @description
       * Reports whether the control is dirty, meaning that the user has changed
       * the value in the UI. If the control is not present, null is returned.
       */
      get dirty() {
        return this.control ? this.control.dirty : null;
      }
      /**
       * @description
       * Reports whether the control is touched, meaning that the user has triggered
       * a `blur` event on it. If the control is not present, null is returned.
       */
      get touched() {
        return this.control ? this.control.touched : null;
      }
      /**
       * @description
       * Reports the validation status of the control. Possible values include:
       * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.
       * If the control is not present, null is returned.
       */
      get status() {
        return this.control ? this.control.status : null;
      }
      /**
       * @description
       * Reports whether the control is untouched, meaning that the user has not yet triggered
       * a `blur` event on it. If the control is not present, null is returned.
       */
      get untouched() {
        return this.control ? this.control.untouched : null;
      }
      /**
       * @description
       * Returns a multicasting observable that emits a validation status whenever it is
       * calculated for the control. If the control is not present, null is returned.
       */
      get statusChanges() {
        return this.control ? this.control.statusChanges : null;
      }
      /**
       * @description
       * Returns a multicasting observable of value changes for the control that emits every time the
       * value of the control changes in the UI or programmatically.
       * If the control is not present, null is returned.
       */
      get valueChanges() {
        return this.control ? this.control.valueChanges : null;
      }
      /**
       * @description
       * Returns an array that represents the path from the top-level form to this control.
       * Each index is the string name of the control on that level.
       */
      get path() {
        return null;
      }
      /**
       * Contains the result of merging synchronous validators into a single validator function
       * (combined using `Validators.compose`).
       */
      _composedValidatorFn;
      /**
       * Contains the result of merging asynchronous validators into a single validator function
       * (combined using `Validators.composeAsync`).
       */
      _composedAsyncValidatorFn;
      /**
       * Set of synchronous validators as they were provided while calling `setValidators` function.
       * @internal
       */
      _rawValidators = [];
      /**
       * Set of asynchronous validators as they were provided while calling `setAsyncValidators`
       * function.
       * @internal
       */
      _rawAsyncValidators = [];
      /**
       * Sets synchronous validators for this directive.
       * @internal
       */
      _setValidators(validators) {
        this._rawValidators = validators || [];
        this._composedValidatorFn = composeValidators(this._rawValidators);
      }
      /**
       * Sets asynchronous validators for this directive.
       * @internal
       */
      _setAsyncValidators(validators) {
        this._rawAsyncValidators = validators || [];
        this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);
      }
      /**
       * @description
       * Synchronous validator function composed of all the synchronous validators registered with this
       * directive.
       */
      get validator() {
        return this._composedValidatorFn || null;
      }
      /**
       * @description
       * Asynchronous validator function composed of all the asynchronous validators registered with
       * this directive.
       */
      get asyncValidator() {
        return this._composedAsyncValidatorFn || null;
      }
      /*
       * The set of callbacks to be invoked when directive instance is being destroyed.
       */
      _onDestroyCallbacks = [];
      /**
       * Internal function to register callbacks that should be invoked
       * when directive instance is being destroyed.
       * @internal
       */
      _registerOnDestroy(fn) {
        this._onDestroyCallbacks.push(fn);
      }
      /**
       * Internal function to invoke all registered "on destroy" callbacks.
       * Note: calling this function also clears the list of callbacks.
       * @internal
       */
      _invokeOnDestroyCallbacks() {
        this._onDestroyCallbacks.forEach((fn) => fn());
        this._onDestroyCallbacks = [];
      }
      /**
       * @description
       * Resets the control with the provided value if the control is present.
       */
      reset(value = void 0) {
        if (this.control) this.control.reset(value);
      }
      /**
       * @description
       * Reports whether the control with the given path has the error specified.
       *
       * @param errorCode The code of the error to check
       * @param path A list of control names that designates how to move from the current control
       * to the control that should be queried for errors.
       *
       * @usageNotes
       * For example, for the following `FormGroup`:
       *
       * ```ts
       * form = new FormGroup({
       *   address: new FormGroup({ street: new FormControl() })
       * });
       * ```
       *
       * The path to the 'street' control from the root form would be 'address' -> 'street'.
       *
       * It can be provided to this method in one of two formats:
       *
       * 1. An array of string control names, e.g. `['address', 'street']`
       * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
       *
       * If no path is given, this method checks for the error on the current control.
       *
       * @returns whether the given error is present in the control at the given path.
       *
       * If the control is not present, false is returned.
       */
      hasError(errorCode, path) {
        return this.control ? this.control.hasError(errorCode, path) : false;
      }
      /**
       * @description
       * Reports error data for the control with the given path.
       *
       * @param errorCode The code of the error to check
       * @param path A list of control names that designates how to move from the current control
       * to the control that should be queried for errors.
       *
       * @usageNotes
       * For example, for the following `FormGroup`:
       *
       * ```ts
       * form = new FormGroup({
       *   address: new FormGroup({ street: new FormControl() })
       * });
       * ```
       *
       * The path to the 'street' control from the root form would be 'address' -> 'street'.
       *
       * It can be provided to this method in one of two formats:
       *
       * 1. An array of string control names, e.g. `['address', 'street']`
       * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
       *
       * @returns error data for that particular error. If the control or error is not present,
       * null is returned.
       */
      getError(errorCode, path) {
        return this.control ? this.control.getError(errorCode, path) : null;
      }
    };
    ControlContainer = class extends AbstractControlDirective {
      /**
       * @description
       * The name for the control
       */
      name;
      /**
       * @description
       * The top-level form directive for the control.
       */
      get formDirective() {
        return null;
      }
      /**
       * @description
       * The path to this group.
       */
      get path() {
        return null;
      }
    };
    NgControl = class extends AbstractControlDirective {
      /**
       * @description
       * The parent form for the control.
       *
       * @internal
       */
      _parent = null;
      /**
       * @description
       * The name for the control
       */
      name = null;
      /**
       * @description
       * The value accessor for the control
       */
      valueAccessor = null;
    };
    AbstractControlStatus = class {
      _cd;
      constructor(cd) {
        this._cd = cd;
      }
      get isTouched() {
        this._cd?.control?._touched?.();
        return !!this._cd?.control?.touched;
      }
      get isUntouched() {
        return !!this._cd?.control?.untouched;
      }
      get isPristine() {
        this._cd?.control?._pristine?.();
        return !!this._cd?.control?.pristine;
      }
      get isDirty() {
        return !!this._cd?.control?.dirty;
      }
      get isValid() {
        this._cd?.control?._status?.();
        return !!this._cd?.control?.valid;
      }
      get isInvalid() {
        return !!this._cd?.control?.invalid;
      }
      get isPending() {
        return !!this._cd?.control?.pending;
      }
      get isSubmitted() {
        this._cd?._submitted?.();
        return !!this._cd?.submitted;
      }
    };
    ngControlStatusHost = {
      "[class.ng-untouched]": "isUntouched",
      "[class.ng-touched]": "isTouched",
      "[class.ng-pristine]": "isPristine",
      "[class.ng-dirty]": "isDirty",
      "[class.ng-valid]": "isValid",
      "[class.ng-invalid]": "isInvalid",
      "[class.ng-pending]": "isPending"
    };
    ngGroupStatusHost = __spreadProps(__spreadValues({}, ngControlStatusHost), {
      "[class.ng-submitted]": "isSubmitted"
    });
    NgControlStatus = class _NgControlStatus extends AbstractControlStatus {
      constructor(cd) {
        super(cd);
      }
      static \u0275fac = function NgControlStatus_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgControlStatus)(\u0275\u0275directiveInject(NgControl, 2));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgControlStatus,
        selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]],
        hostVars: 14,
        hostBindings: function NgControlStatus_HostBindings(rf, ctx) {
          if (rf & 2) {
            \u0275\u0275classProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending);
          }
        },
        standalone: false,
        features: [\u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatus, [{
        type: Directive,
        args: [{
          selector: "[formControlName],[ngModel],[formControl]",
          host: ngControlStatusHost,
          standalone: false
        }]
      }], () => [{
        type: NgControl,
        decorators: [{
          type: Self
        }]
      }], null);
    })();
    NgControlStatusGroup = class _NgControlStatusGroup extends AbstractControlStatus {
      constructor(cd) {
        super(cd);
      }
      static \u0275fac = function NgControlStatusGroup_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgControlStatusGroup)(\u0275\u0275directiveInject(ControlContainer, 10));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgControlStatusGroup,
        selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]],
        hostVars: 16,
        hostBindings: function NgControlStatusGroup_HostBindings(rf, ctx) {
          if (rf & 2) {
            \u0275\u0275classProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending)("ng-submitted", ctx.isSubmitted);
          }
        },
        standalone: false,
        features: [\u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatusGroup, [{
        type: Directive,
        args: [{
          selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]",
          host: ngGroupStatusHost,
          standalone: false
        }]
      }], () => [{
        type: ControlContainer,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }]
      }], null);
    })();
    formControlNameExample = `
  <div [formGroup]="myGroup">
    <input formControlName="firstName">
  </div>

  In your class:

  this.myGroup = new FormGroup({
      firstName: new FormControl()
  });`;
    formGroupNameExample = `
  <div [formGroup]="myGroup">
      <div formGroupName="person">
        <input formControlName="firstName">
      </div>
  </div>

  In your class:

  this.myGroup = new FormGroup({
      person: new FormGroup({ firstName: new FormControl() })
  });`;
    formArrayNameExample = `
  <div [formGroup]="myGroup">
    <div formArrayName="cities">
      <div *ngFor="let city of cityArray.controls; index as i">
        <input [formControlName]="i">
      </div>
    </div>
  </div>

  In your class:

  this.cityArray = new FormArray([new FormControl('SF')]);
  this.myGroup = new FormGroup({
    cities: this.cityArray
  });`;
    ngModelGroupExample = `
  <form>
      <div ngModelGroup="person">
        <input [(ngModel)]="person.name" name="firstName">
      </div>
  </form>`;
    ngModelWithFormGroupExample = `
  <div [formGroup]="myGroup">
      <input formControlName="firstName">
      <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">
  </div>
`;
    disabledAttrWarning = `
  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true
  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for
  you. We recommend using this approach to avoid 'changed after checked' errors.

  Example:
  // Specify the \`disabled\` property at control creation time:
  form = new FormGroup({
    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),
    last: new FormControl('Drew', Validators.required)
  });

  // Controls can also be enabled/disabled after creation:
  form.get('first')?.enable();
  form.get('last')?.disable();
`;
    asyncValidatorsDroppedWithOptsWarning = `
  It looks like you're constructing using a FormControl with both an options argument and an
  async validators argument. Mixing these arguments will cause your async validators to be dropped.
  You should either put all your validators in the options object, or in separate validators
  arguments. For example:

  // Using validators arguments
  fc = new FormControl(42, Validators.required, myAsyncValidator);

  // Using AbstractControlOptions
  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});

  // Do NOT mix them: async validators will be dropped!
  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);
`;
    VALID = "VALID";
    INVALID = "INVALID";
    PENDING = "PENDING";
    DISABLED = "DISABLED";
    ControlEvent = class {
    };
    ValueChangeEvent = class extends ControlEvent {
      value;
      source;
      constructor(value, source) {
        super();
        this.value = value;
        this.source = source;
      }
    };
    PristineChangeEvent = class extends ControlEvent {
      pristine;
      source;
      constructor(pristine, source) {
        super();
        this.pristine = pristine;
        this.source = source;
      }
    };
    TouchedChangeEvent = class extends ControlEvent {
      touched;
      source;
      constructor(touched, source) {
        super();
        this.touched = touched;
        this.source = source;
      }
    };
    StatusChangeEvent = class extends ControlEvent {
      status;
      source;
      constructor(status, source) {
        super();
        this.status = status;
        this.source = source;
      }
    };
    FormSubmittedEvent = class extends ControlEvent {
      source;
      constructor(source) {
        super();
        this.source = source;
      }
    };
    FormResetEvent = class extends ControlEvent {
      source;
      constructor(source) {
        super();
        this.source = source;
      }
    };
    AbstractControl = class {
      /** @internal */
      _pendingDirty = false;
      /**
       * Indicates that a control has its own pending asynchronous validation in progress.
       * It also stores if the control should emit events when the validation status changes.
       *
       * @internal
       */
      _hasOwnPendingAsyncValidator = null;
      /** @internal */
      _pendingTouched = false;
      /** @internal */
      _onCollectionChange = () => {
      };
      /** @internal */
      _updateOn;
      _parent = null;
      _asyncValidationSubscription;
      /**
       * Contains the result of merging synchronous validators into a single validator function
       * (combined using `Validators.compose`).
       *
       * @internal
       */
      _composedValidatorFn;
      /**
       * Contains the result of merging asynchronous validators into a single validator function
       * (combined using `Validators.composeAsync`).
       *
       * @internal
       */
      _composedAsyncValidatorFn;
      /**
       * Synchronous validators as they were provided:
       *  - in `AbstractControl` constructor
       *  - as an argument while calling `setValidators` function
       *  - while calling the setter on the `validator` field (e.g. `control.validator = validatorFn`)
       *
       * @internal
       */
      _rawValidators;
      /**
       * Asynchronous validators as they were provided:
       *  - in `AbstractControl` constructor
       *  - as an argument while calling `setAsyncValidators` function
       *  - while calling the setter on the `asyncValidator` field (e.g. `control.asyncValidator =
       * asyncValidatorFn`)
       *
       * @internal
       */
      _rawAsyncValidators;
      /**
       * The current value of the control.
       *
       * * For a `FormControl`, the current value.
       * * For an enabled `FormGroup`, the values of enabled controls as an object
       * with a key-value pair for each member of the group.
       * * For a disabled `FormGroup`, the values of all controls as an object
       * with a key-value pair for each member of the group.
       * * For a `FormArray`, the values of enabled controls as an array.
       *
       */
      value;
      /**
       * Initialize the AbstractControl instance.
       *
       * @param validators The function or array of functions that is used to determine the validity of
       *     this control synchronously.
       * @param asyncValidators The function or array of functions that is used to determine validity of
       *     this control asynchronously.
       */
      constructor(validators, asyncValidators) {
        this._assignValidators(validators);
        this._assignAsyncValidators(asyncValidators);
      }
      /**
       * Returns the function that is used to determine the validity of this control synchronously.
       * If multiple validators have been added, this will be a single composed function.
       * See `Validators.compose()` for additional information.
       */
      get validator() {
        return this._composedValidatorFn;
      }
      set validator(validatorFn) {
        this._rawValidators = this._composedValidatorFn = validatorFn;
      }
      /**
       * Returns the function that is used to determine the validity of this control asynchronously.
       * If multiple validators have been added, this will be a single composed function.
       * See `Validators.compose()` for additional information.
       */
      get asyncValidator() {
        return this._composedAsyncValidatorFn;
      }
      set asyncValidator(asyncValidatorFn) {
        this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;
      }
      /**
       * The parent control.
       */
      get parent() {
        return this._parent;
      }
      /**
       * The validation status of the control.
       *
       * @see {@link FormControlStatus}
       *
       * These status values are mutually exclusive, so a control cannot be
       * both valid AND invalid or invalid AND disabled.
       */
      get status() {
        return untracked2(this.statusReactive);
      }
      set status(v) {
        untracked2(() => this.statusReactive.set(v));
      }
      /** @internal */
      _status = computed(() => this.statusReactive(), ...ngDevMode ? [{
        debugName: "_status"
      }] : []);
      statusReactive = signal(void 0, ...ngDevMode ? [{
        debugName: "statusReactive"
      }] : []);
      /**
       * A control is `valid` when its `status` is `VALID`.
       *
       * @see {@link AbstractControl.status}
       *
       * @returns True if the control has passed all of its validation tests,
       * false otherwise.
       */
      get valid() {
        return this.status === VALID;
      }
      /**
       * A control is `invalid` when its `status` is `INVALID`.
       *
       * @see {@link AbstractControl.status}
       *
       * @returns True if this control has failed one or more of its validation checks,
       * false otherwise.
       */
      get invalid() {
        return this.status === INVALID;
      }
      /**
       * A control is `pending` when its `status` is `PENDING`.
       *
       * @see {@link AbstractControl.status}
       *
       * @returns True if this control is in the process of conducting a validation check,
       * false otherwise.
       */
      get pending() {
        return this.status == PENDING;
      }
      /**
       * A control is `disabled` when its `status` is `DISABLED`.
       *
       * Disabled controls are exempt from validation checks and
       * are not included in the aggregate value of their ancestor
       * controls.
       *
       * @see {@link AbstractControl.status}
       *
       * @returns True if the control is disabled, false otherwise.
       */
      get disabled() {
        return this.status === DISABLED;
      }
      /**
       * A control is `enabled` as long as its `status` is not `DISABLED`.
       *
       * @returns True if the control has any status other than 'DISABLED',
       * false if the status is 'DISABLED'.
       *
       * @see {@link AbstractControl.status}
       *
       */
      get enabled() {
        return this.status !== DISABLED;
      }
      /**
       * An object containing any errors generated by failing validation,
       * or null if there are no errors.
       */
      errors;
      /**
       * A control is `pristine` if the user has not yet changed
       * the value in the UI.
       *
       * @returns True if the user has not yet changed the value in the UI; compare `dirty`.
       * Programmatic changes to a control's value do not mark it dirty.
       */
      get pristine() {
        return untracked2(this.pristineReactive);
      }
      set pristine(v) {
        untracked2(() => this.pristineReactive.set(v));
      }
      /** @internal */
      _pristine = computed(() => this.pristineReactive(), ...ngDevMode ? [{
        debugName: "_pristine"
      }] : []);
      pristineReactive = signal(true, ...ngDevMode ? [{
        debugName: "pristineReactive"
      }] : []);
      /**
       * A control is `dirty` if the user has changed the value
       * in the UI.
       *
       * @returns True if the user has changed the value of this control in the UI; compare `pristine`.
       * Programmatic changes to a control's value do not mark it dirty.
       */
      get dirty() {
        return !this.pristine;
      }
      /**
       * True if the control is marked as `touched`.
       *
       * A control is marked `touched` once the user has triggered
       * a `blur` event on it.
       */
      get touched() {
        return untracked2(this.touchedReactive);
      }
      set touched(v) {
        untracked2(() => this.touchedReactive.set(v));
      }
      /** @internal */
      _touched = computed(() => this.touchedReactive(), ...ngDevMode ? [{
        debugName: "_touched"
      }] : []);
      touchedReactive = signal(false, ...ngDevMode ? [{
        debugName: "touchedReactive"
      }] : []);
      /**
       * True if the control has not been marked as touched
       *
       * A control is `untouched` if the user has not yet triggered
       * a `blur` event on it.
       */
      get untouched() {
        return !this.touched;
      }
      /**
       * Exposed as observable, see below.
       *
       * @internal
       */
      _events = new Subject();
      /**
       * A multicasting observable that emits an event every time the state of the control changes.
       * It emits for value, status, pristine or touched changes.
       *
       * **Note**: On value change, the emit happens right after a value of this control is updated. The
       * value of a parent control (for example if this FormControl is a part of a FormGroup) is updated
       * later, so accessing a value of a parent control (using the `value` property) from the callback
       * of this event might result in getting a value that has not been updated yet. Subscribe to the
       * `events` of the parent control instead.
       * For other event types, the events are emitted after the parent control has been updated.
       *
       */
      events = this._events.asObservable();
      /**
       * A multicasting observable that emits an event every time the value of the control changes, in
       * the UI or programmatically. It also emits an event each time you call enable() or disable()
       * without passing along {emitEvent: false} as a function argument.
       *
       * **Note**: the emit happens right after a value of this control is updated. The value of a
       * parent control (for example if this FormControl is a part of a FormGroup) is updated later, so
       * accessing a value of a parent control (using the `value` property) from the callback of this
       * event might result in getting a value that has not been updated yet. Subscribe to the
       * `valueChanges` event of the parent control instead.
       */
      valueChanges;
      /**
       * A multicasting observable that emits an event every time the validation `status` of the control
       * recalculates.
       *
       * @see {@link FormControlStatus}
       * @see {@link AbstractControl.status}
       */
      statusChanges;
      /**
       * Reports the update strategy of the `AbstractControl` (meaning
       * the event on which the control updates itself).
       * Possible values: `'change'` | `'blur'` | `'submit'`
       * Default value: `'change'`
       */
      get updateOn() {
        return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change";
      }
      /**
       * Sets the synchronous validators that are active on this control.  Calling
       * this overwrites any existing synchronous validators.
       *
       * When you add or remove a validator at run time, you must call
       * `updateValueAndValidity()` for the new validation to take effect.
       *
       * If you want to add a new validator without affecting existing ones, consider
       * using `addValidators()` method instead.
       */
      setValidators(validators) {
        this._assignValidators(validators);
      }
      /**
       * Sets the asynchronous validators that are active on this control. Calling this
       * overwrites any existing asynchronous validators.
       *
       * When you add or remove a validator at run time, you must call
       * `updateValueAndValidity()` for the new validation to take effect.
       *
       * If you want to add a new validator without affecting existing ones, consider
       * using `addAsyncValidators()` method instead.
       */
      setAsyncValidators(validators) {
        this._assignAsyncValidators(validators);
      }
      /**
       * Add a synchronous validator or validators to this control, without affecting other validators.
       *
       * When you add or remove a validator at run time, you must call
       * `updateValueAndValidity()` for the new validation to take effect.
       *
       * Adding a validator that already exists will have no effect. If duplicate validator functions
       * are present in the `validators` array, only the first instance would be added to a form
       * control.
       *
       * @param validators The new validator function or functions to add to this control.
       */
      addValidators(validators) {
        this.setValidators(addValidators(validators, this._rawValidators));
      }
      /**
       * Add an asynchronous validator or validators to this control, without affecting other
       * validators.
       *
       * When you add or remove a validator at run time, you must call
       * `updateValueAndValidity()` for the new validation to take effect.
       *
       * Adding a validator that already exists will have no effect.
       *
       * @param validators The new asynchronous validator function or functions to add to this control.
       */
      addAsyncValidators(validators) {
        this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));
      }
      /**
       * Remove a synchronous validator from this control, without affecting other validators.
       * Validators are compared by function reference; you must pass a reference to the exact same
       * validator function as the one that was originally set. If a provided validator is not found,
       * it is ignored.
       *
       * @usageNotes
       *
       * ### Reference to a ValidatorFn
       *
       * ```
       * // Reference to the RequiredValidator
       * const ctrl = new FormControl<string | null>('', Validators.required);
       * ctrl.removeValidators(Validators.required);
       *
       * // Reference to anonymous function inside MinValidator
       * const minValidator = Validators.min(3);
       * const ctrl = new FormControl<string | null>('', minValidator);
       * expect(ctrl.hasValidator(minValidator)).toEqual(true)
       * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
       *
       * ctrl.removeValidators(minValidator);
       * ```
       *
       * When you add or remove a validator at run time, you must call
       * `updateValueAndValidity()` for the new validation to take effect.
       *
       * @param validators The validator or validators to remove.
       */
      removeValidators(validators) {
        this.setValidators(removeValidators(validators, this._rawValidators));
      }
      /**
       * Remove an asynchronous validator from this control, without affecting other validators.
       * Validators are compared by function reference; you must pass a reference to the exact same
       * validator function as the one that was originally set. If a provided validator is not found, it
       * is ignored.
       *
       * When you add or remove a validator at run time, you must call
       * `updateValueAndValidity()` for the new validation to take effect.
       *
       * @param validators The asynchronous validator or validators to remove.
       */
      removeAsyncValidators(validators) {
        this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));
      }
      /**
       * Check whether a synchronous validator function is present on this control. The provided
       * validator must be a reference to the exact same function that was provided.
       *
       * @usageNotes
       *
       * ### Reference to a ValidatorFn
       *
       * ```
       * // Reference to the RequiredValidator
       * const ctrl = new FormControl<number | null>(0, Validators.required);
       * expect(ctrl.hasValidator(Validators.required)).toEqual(true)
       *
       * // Reference to anonymous function inside MinValidator
       * const minValidator = Validators.min(3);
       * const ctrl = new FormControl<number | null>(0, minValidator);
       * expect(ctrl.hasValidator(minValidator)).toEqual(true)
       * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
       * ```
       *
       * @param validator The validator to check for presence. Compared by function reference.
       * @returns Whether the provided validator was found on this control.
       */
      hasValidator(validator) {
        return hasValidator(this._rawValidators, validator);
      }
      /**
       * Check whether an asynchronous validator function is present on this control. The provided
       * validator must be a reference to the exact same function that was provided.
       *
       * @param validator The asynchronous validator to check for presence. Compared by function
       *     reference.
       * @returns Whether the provided asynchronous validator was found on this control.
       */
      hasAsyncValidator(validator) {
        return hasValidator(this._rawAsyncValidators, validator);
      }
      /**
       * Empties out the synchronous validator list.
       *
       * When you add or remove a validator at run time, you must call
       * `updateValueAndValidity()` for the new validation to take effect.
       *
       */
      clearValidators() {
        this.validator = null;
      }
      /**
       * Empties out the async validator list.
       *
       * When you add or remove a validator at run time, you must call
       * `updateValueAndValidity()` for the new validation to take effect.
       *
       */
      clearAsyncValidators() {
        this.asyncValidator = null;
      }
      markAsTouched(opts = {}) {
        const changed = this.touched === false;
        this.touched = true;
        const sourceControl = opts.sourceControl ?? this;
        if (this._parent && !opts.onlySelf) {
          this._parent.markAsTouched(__spreadProps(__spreadValues({}, opts), {
            sourceControl
          }));
        }
        if (changed && opts.emitEvent !== false) {
          this._events.next(new TouchedChangeEvent(true, sourceControl));
        }
      }
      /**
       * Marks the control and all its descendant controls as `dirty`.
       * @see {@link markAsDirty()}
       *
       * @param opts Configuration options that determine how the control propagates changes
       * and emits events after marking is applied.
       * * `emitEvent`: When true or not supplied (the default), the `events`
       * observable emits a `PristineChangeEvent` with the `pristine` property being `false`.
       * When false, no events are emitted.
       */
      markAllAsDirty(opts = {}) {
        this.markAsDirty({
          onlySelf: true,
          emitEvent: opts.emitEvent,
          sourceControl: this
        });
        this._forEachChild((control) => control.markAllAsDirty(opts));
      }
      /**
       * Marks the control and all its descendant controls as `touched`.
       * @see {@link markAsTouched()}
       *
       * @param opts Configuration options that determine how the control propagates changes
       * and emits events after marking is applied.
       * * `emitEvent`: When true or not supplied (the default), the `events`
       * observable emits a `TouchedChangeEvent` with the `touched` property being `true`.
       * When false, no events are emitted.
       */
      markAllAsTouched(opts = {}) {
        this.markAsTouched({
          onlySelf: true,
          emitEvent: opts.emitEvent,
          sourceControl: this
        });
        this._forEachChild((control) => control.markAllAsTouched(opts));
      }
      markAsUntouched(opts = {}) {
        const changed = this.touched === true;
        this.touched = false;
        this._pendingTouched = false;
        const sourceControl = opts.sourceControl ?? this;
        this._forEachChild((control) => {
          control.markAsUntouched({
            onlySelf: true,
            emitEvent: opts.emitEvent,
            sourceControl
          });
        });
        if (this._parent && !opts.onlySelf) {
          this._parent._updateTouched(opts, sourceControl);
        }
        if (changed && opts.emitEvent !== false) {
          this._events.next(new TouchedChangeEvent(false, sourceControl));
        }
      }
      markAsDirty(opts = {}) {
        const changed = this.pristine === true;
        this.pristine = false;
        const sourceControl = opts.sourceControl ?? this;
        if (this._parent && !opts.onlySelf) {
          this._parent.markAsDirty(__spreadProps(__spreadValues({}, opts), {
            sourceControl
          }));
        }
        if (changed && opts.emitEvent !== false) {
          this._events.next(new PristineChangeEvent(false, sourceControl));
        }
      }
      markAsPristine(opts = {}) {
        const changed = this.pristine === false;
        this.pristine = true;
        this._pendingDirty = false;
        const sourceControl = opts.sourceControl ?? this;
        this._forEachChild((control) => {
          control.markAsPristine({
            onlySelf: true,
            emitEvent: opts.emitEvent
          });
        });
        if (this._parent && !opts.onlySelf) {
          this._parent._updatePristine(opts, sourceControl);
        }
        if (changed && opts.emitEvent !== false) {
          this._events.next(new PristineChangeEvent(true, sourceControl));
        }
      }
      markAsPending(opts = {}) {
        this.status = PENDING;
        const sourceControl = opts.sourceControl ?? this;
        if (opts.emitEvent !== false) {
          this._events.next(new StatusChangeEvent(this.status, sourceControl));
          this.statusChanges.emit(this.status);
        }
        if (this._parent && !opts.onlySelf) {
          this._parent.markAsPending(__spreadProps(__spreadValues({}, opts), {
            sourceControl
          }));
        }
      }
      disable(opts = {}) {
        const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
        this.status = DISABLED;
        this.errors = null;
        this._forEachChild((control) => {
          control.disable(__spreadProps(__spreadValues({}, opts), {
            onlySelf: true
          }));
        });
        this._updateValue();
        const sourceControl = opts.sourceControl ?? this;
        if (opts.emitEvent !== false) {
          this._events.next(new ValueChangeEvent(this.value, sourceControl));
          this._events.next(new StatusChangeEvent(this.status, sourceControl));
          this.valueChanges.emit(this.value);
          this.statusChanges.emit(this.status);
        }
        this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
          skipPristineCheck
        }), this);
        this._onDisabledChange.forEach((changeFn) => changeFn(true));
      }
      /**
       * Enables the control. This means the control is included in validation checks and
       * the aggregate value of its parent. Its status recalculates based on its value and
       * its validators.
       *
       * By default, if the control has children, all children are enabled.
       *
       * @see {@link AbstractControl.status}
       *
       * @param opts Configure options that control how the control propagates changes and
       * emits events when marked as untouched
       * * `onlySelf`: When true, mark only this control. When false or not supplied,
       * marks all direct ancestors. Default is false.
       * * `emitEvent`: When true or not supplied (the default), the `statusChanges`,
       * `valueChanges` and `events`
       * observables emit events with the latest status and value when the control is enabled.
       * When false, no events are emitted.
       */
      enable(opts = {}) {
        const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
        this.status = VALID;
        this._forEachChild((control) => {
          control.enable(__spreadProps(__spreadValues({}, opts), {
            onlySelf: true
          }));
        });
        this.updateValueAndValidity({
          onlySelf: true,
          emitEvent: opts.emitEvent
        });
        this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
          skipPristineCheck
        }), this);
        this._onDisabledChange.forEach((changeFn) => changeFn(false));
      }
      _updateAncestors(opts, sourceControl) {
        if (this._parent && !opts.onlySelf) {
          this._parent.updateValueAndValidity(opts);
          if (!opts.skipPristineCheck) {
            this._parent._updatePristine({}, sourceControl);
          }
          this._parent._updateTouched({}, sourceControl);
        }
      }
      /**
       * Sets the parent of the control
       *
       * @param parent The new parent.
       */
      setParent(parent) {
        this._parent = parent;
      }
      /**
       * The raw value of this control. For most control implementations, the raw value will include
       * disabled children.
       */
      getRawValue() {
        return this.value;
      }
      updateValueAndValidity(opts = {}) {
        this._setInitialStatus();
        this._updateValue();
        if (this.enabled) {
          const shouldHaveEmitted = this._cancelExistingSubscription();
          this.errors = this._runValidator();
          this.status = this._calculateStatus();
          if (this.status === VALID || this.status === PENDING) {
            this._runAsyncValidator(shouldHaveEmitted, opts.emitEvent);
          }
        }
        const sourceControl = opts.sourceControl ?? this;
        if (opts.emitEvent !== false) {
          this._events.next(new ValueChangeEvent(this.value, sourceControl));
          this._events.next(new StatusChangeEvent(this.status, sourceControl));
          this.valueChanges.emit(this.value);
          this.statusChanges.emit(this.status);
        }
        if (this._parent && !opts.onlySelf) {
          this._parent.updateValueAndValidity(__spreadProps(__spreadValues({}, opts), {
            sourceControl
          }));
        }
      }
      /** @internal */
      _updateTreeValidity(opts = {
        emitEvent: true
      }) {
        this._forEachChild((ctrl) => ctrl._updateTreeValidity(opts));
        this.updateValueAndValidity({
          onlySelf: true,
          emitEvent: opts.emitEvent
        });
      }
      _setInitialStatus() {
        this.status = this._allControlsDisabled() ? DISABLED : VALID;
      }
      _runValidator() {
        return this.validator ? this.validator(this) : null;
      }
      _runAsyncValidator(shouldHaveEmitted, emitEvent) {
        if (this.asyncValidator) {
          this.status = PENDING;
          this._hasOwnPendingAsyncValidator = {
            emitEvent: emitEvent !== false,
            shouldHaveEmitted: shouldHaveEmitted !== false
          };
          const obs = toObservable(this.asyncValidator(this));
          this._asyncValidationSubscription = obs.subscribe((errors) => {
            this._hasOwnPendingAsyncValidator = null;
            this.setErrors(errors, {
              emitEvent,
              shouldHaveEmitted
            });
          });
        }
      }
      _cancelExistingSubscription() {
        if (this._asyncValidationSubscription) {
          this._asyncValidationSubscription.unsubscribe();
          const shouldHaveEmitted = (this._hasOwnPendingAsyncValidator?.emitEvent || this._hasOwnPendingAsyncValidator?.shouldHaveEmitted) ?? false;
          this._hasOwnPendingAsyncValidator = null;
          return shouldHaveEmitted;
        }
        return false;
      }
      setErrors(errors, opts = {}) {
        this.errors = errors;
        this._updateControlsErrors(opts.emitEvent !== false, this, opts.shouldHaveEmitted);
      }
      /**
       * Retrieves a child control given the control's name or path.
       *
       * @param path A dot-delimited string or array of string/number values that define the path to the
       * control. If a string is provided, passing it as a string literal will result in improved type
       * information. Likewise, if an array is provided, passing it `as const` will cause improved type
       * information to be available.
       *
       * @usageNotes
       * ### Retrieve a nested control
       *
       * For example, to get a `name` control nested within a `person` sub-group:
       *
       * * `this.form.get('person.name');`
       *
       * -OR-
       *
       * * `this.form.get(['person', 'name'] as const);` // `as const` gives improved typings
       *
       * ### Retrieve a control in a FormArray
       *
       * When accessing an element inside a FormArray, you can use an element index.
       * For example, to get a `price` control from the first element in an `items` array you can use:
       *
       * * `this.form.get('items.0.price');`
       *
       * -OR-
       *
       * * `this.form.get(['items', 0, 'price']);`
       */
      get(path) {
        let currPath = path;
        if (currPath == null) return null;
        if (!Array.isArray(currPath)) currPath = currPath.split(".");
        if (currPath.length === 0) return null;
        return currPath.reduce((control, name2) => control && control._find(name2), this);
      }
      /**
       * @description
       * Reports error data for the control with the given path.
       *
       * @param errorCode The code of the error to check
       * @param path A list of control names that designates how to move from the current control
       * to the control that should be queried for errors.
       *
       * @usageNotes
       * For example, for the following `FormGroup`:
       *
       * ```ts
       * form = new FormGroup({
       *   address: new FormGroup({ street: new FormControl() })
       * });
       * ```
       *
       * The path to the 'street' control from the root form would be 'address' -> 'street'.
       *
       * It can be provided to this method in one of two formats:
       *
       * 1. An array of string control names, e.g. `['address', 'street']`
       * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
       *
       * @returns error data for that particular error. If the control or error is not present,
       * null is returned.
       */
      getError(errorCode, path) {
        const control = path ? this.get(path) : this;
        return control && control.errors ? control.errors[errorCode] : null;
      }
      /**
       * @description
       * Reports whether the control with the given path has the error specified.
       *
       * @param errorCode The code of the error to check
       * @param path A list of control names that designates how to move from the current control
       * to the control that should be queried for errors.
       *
       * @usageNotes
       * For example, for the following `FormGroup`:
       *
       * ```ts
       * form = new FormGroup({
       *   address: new FormGroup({ street: new FormControl() })
       * });
       * ```
       *
       * The path to the 'street' control from the root form would be 'address' -> 'street'.
       *
       * It can be provided to this method in one of two formats:
       *
       * 1. An array of string control names, e.g. `['address', 'street']`
       * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
       *
       * If no path is given, this method checks for the error on the current control.
       *
       * @returns whether the given error is present in the control at the given path.
       *
       * If the control is not present, false is returned.
       */
      hasError(errorCode, path) {
        return !!this.getError(errorCode, path);
      }
      /**
       * Retrieves the top-level ancestor of this control.
       */
      get root() {
        let x = this;
        while (x._parent) {
          x = x._parent;
        }
        return x;
      }
      /** @internal */
      _updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted) {
        this.status = this._calculateStatus();
        if (emitEvent) {
          this.statusChanges.emit(this.status);
        }
        if (emitEvent || shouldHaveEmitted) {
          this._events.next(new StatusChangeEvent(this.status, changedControl));
        }
        if (this._parent) {
          this._parent._updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted);
        }
      }
      /** @internal */
      _initObservables() {
        this.valueChanges = new EventEmitter();
        this.statusChanges = new EventEmitter();
      }
      _calculateStatus() {
        if (this._allControlsDisabled()) return DISABLED;
        if (this.errors) return INVALID;
        if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) return PENDING;
        if (this._anyControlsHaveStatus(INVALID)) return INVALID;
        return VALID;
      }
      /** @internal */
      _anyControlsHaveStatus(status) {
        return this._anyControls((control) => control.status === status);
      }
      /** @internal */
      _anyControlsDirty() {
        return this._anyControls((control) => control.dirty);
      }
      /** @internal */
      _anyControlsTouched() {
        return this._anyControls((control) => control.touched);
      }
      /** @internal */
      _updatePristine(opts, changedControl) {
        const newPristine = !this._anyControlsDirty();
        const changed = this.pristine !== newPristine;
        this.pristine = newPristine;
        if (this._parent && !opts.onlySelf) {
          this._parent._updatePristine(opts, changedControl);
        }
        if (changed) {
          this._events.next(new PristineChangeEvent(this.pristine, changedControl));
        }
      }
      /** @internal */
      _updateTouched(opts = {}, changedControl) {
        this.touched = this._anyControlsTouched();
        this._events.next(new TouchedChangeEvent(this.touched, changedControl));
        if (this._parent && !opts.onlySelf) {
          this._parent._updateTouched(opts, changedControl);
        }
      }
      /** @internal */
      _onDisabledChange = [];
      /** @internal */
      _registerOnCollectionChange(fn) {
        this._onCollectionChange = fn;
      }
      /** @internal */
      _setUpdateStrategy(opts) {
        if (isOptionsObj(opts) && opts.updateOn != null) {
          this._updateOn = opts.updateOn;
        }
      }
      /**
       * Check to see if parent has been marked artificially dirty.
       *
       * @internal
       */
      _parentMarkedDirty(onlySelf) {
        const parentDirty = this._parent && this._parent.dirty;
        return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();
      }
      /** @internal */
      _find(name2) {
        return null;
      }
      /**
       * Internal implementation of the `setValidators` method. Needs to be separated out into a
       * different method, because it is called in the constructor and it can break cases where
       * a control is extended.
       */
      _assignValidators(validators) {
        this._rawValidators = Array.isArray(validators) ? validators.slice() : validators;
        this._composedValidatorFn = coerceToValidator(this._rawValidators);
      }
      /**
       * Internal implementation of the `setAsyncValidators` method. Needs to be separated out into a
       * different method, because it is called in the constructor and it can break cases where
       * a control is extended.
       */
      _assignAsyncValidators(validators) {
        this._rawAsyncValidators = Array.isArray(validators) ? validators.slice() : validators;
        this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);
      }
    };
    FormGroup = class extends AbstractControl {
      /**
       * Creates a new `FormGroup` instance.
       *
       * @param controls A collection of child controls. The key for each child is the name
       * under which it is registered.
       *
       * @param validatorOrOpts A synchronous validator function, or an array of
       * such functions, or an `AbstractControlOptions` object that contains validation functions
       * and a validation trigger.
       *
       * @param asyncValidator A single async validator or array of async validator functions
       *
       */
      constructor(controls, validatorOrOpts, asyncValidator) {
        super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
        (typeof ngDevMode === "undefined" || ngDevMode) && validateFormGroupControls(controls);
        this.controls = controls;
        this._initObservables();
        this._setUpdateStrategy(validatorOrOpts);
        this._setUpControls();
        this.updateValueAndValidity({
          onlySelf: true,
          // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
          // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,
          // so we set `emitEvent` to `true` to allow that during the control creation process.
          emitEvent: !!this.asyncValidator
        });
      }
      controls;
      registerControl(name2, control) {
        if (this.controls[name2]) return this.controls[name2];
        this.controls[name2] = control;
        control.setParent(this);
        control._registerOnCollectionChange(this._onCollectionChange);
        return control;
      }
      addControl(name2, control, options = {}) {
        this.registerControl(name2, control);
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
        this._onCollectionChange();
      }
      /**
       * Remove a control from this group. In a strongly-typed group, required controls cannot be
       * removed.
       *
       * This method also updates the value and validity of the control.
       *
       * @param name The control name to remove from the collection
       * @param options Specifies whether this FormGroup instance should emit events after a
       *     control is removed.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges` observables emit events with the latest status and value when the control is
       * removed. When false, no events are emitted.
       */
      removeControl(name2, options = {}) {
        if (this.controls[name2]) this.controls[name2]._registerOnCollectionChange(() => {
        });
        delete this.controls[name2];
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
        this._onCollectionChange();
      }
      setControl(name2, control, options = {}) {
        if (this.controls[name2]) this.controls[name2]._registerOnCollectionChange(() => {
        });
        delete this.controls[name2];
        if (control) this.registerControl(name2, control);
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
        this._onCollectionChange();
      }
      contains(controlName) {
        return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
      }
      /**
       * Sets the value of the `FormGroup`. It accepts an object that matches
       * the structure of the group, with control names as keys.
       *
       * @usageNotes
       * ### Set the complete value for the form group
       *
       * ```ts
       * const form = new FormGroup({
       *   first: new FormControl(),
       *   last: new FormControl()
       * });
       *
       * console.log(form.value);   // {first: null, last: null}
       *
       * form.setValue({first: 'Nancy', last: 'Drew'});
       * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
       * ```
       *
       * @throws When strict checks fail, such as setting the value of a control
       * that doesn't exist or if you exclude a value of a control that does exist.
       *
       * @param value The new value for the control that matches the structure of the group.
       * @param options Configuration options that determine how the control propagates changes
       * and emits events after the value changes.
       * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
       * updateValueAndValidity} method.
       *
       * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
       * false.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges`
       * observables emit events with the latest status and value when the control value is updated.
       * When false, no events are emitted.
       */
      setValue(value, options = {}) {
        assertAllValuesPresent(this, true, value);
        Object.keys(value).forEach((name2) => {
          assertControlPresent(this, true, name2);
          this.controls[name2].setValue(value[name2], {
            onlySelf: true,
            emitEvent: options.emitEvent
          });
        });
        this.updateValueAndValidity(options);
      }
      /**
       * Patches the value of the `FormGroup`. It accepts an object with control
       * names as keys, and does its best to match the values to the correct controls
       * in the group.
       *
       * It accepts both super-sets and sub-sets of the group without throwing an error.
       *
       * @usageNotes
       * ### Patch the value for a form group
       *
       * ```ts
       * const form = new FormGroup({
       *    first: new FormControl(),
       *    last: new FormControl()
       * });
       * console.log(form.value);   // {first: null, last: null}
       *
       * form.patchValue({first: 'Nancy'});
       * console.log(form.value);   // {first: 'Nancy', last: null}
       * ```
       *
       * @param value The object that matches the structure of the group.
       * @param options Configuration options that determine how the control propagates changes and
       * emits events after the value is patched.
       * * `onlySelf`: When true, each change only affects this control and not its parent. Default is
       * true.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges` observables emit events with the latest status and value when the control value
       * is updated. When false, no events are emitted. The configuration options are passed to
       * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
       */
      patchValue(value, options = {}) {
        if (value == null) return;
        Object.keys(value).forEach((name2) => {
          const control = this.controls[name2];
          if (control) {
            control.patchValue(
              /* Guaranteed to be present, due to the outer forEach. */
              value[name2],
              {
                onlySelf: true,
                emitEvent: options.emitEvent
              }
            );
          }
        });
        this.updateValueAndValidity(options);
      }
      /**
       * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets
       * the value of all descendants to their default values, or null if no defaults were provided.
       *
       * You reset to a specific form state by passing in a map of states
       * that matches the structure of your form, with control names as keys. The state
       * is a standalone value or a form state object with both a value and a disabled
       * status.
       *
       * @param value Resets the control with an initial value,
       * or an object that defines the initial value and disabled state.
       *
       * @param options Configuration options that determine how the control propagates changes
       * and emits events when the group is reset.
       * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
       * false.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges`
       * observables emit events with the latest status and value when the control is reset.
       * When false, no events are emitted.
       * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
       * updateValueAndValidity} method.
       *
       * @usageNotes
       *
       * ### Reset the form group values
       *
       * ```ts
       * const form = new FormGroup({
       *   first: new FormControl('first name'),
       *   last: new FormControl('last name')
       * });
       *
       * console.log(form.value);  // {first: 'first name', last: 'last name'}
       *
       * form.reset({ first: 'name', last: 'last name' });
       *
       * console.log(form.value);  // {first: 'name', last: 'last name'}
       * ```
       *
       * ### Reset the form group values and disabled status
       *
       * ```ts
       * const form = new FormGroup({
       *   first: new FormControl('first name'),
       *   last: new FormControl('last name')
       * });
       *
       * form.reset({
       *   first: {value: 'name', disabled: true},
       *   last: 'last'
       * });
       *
       * console.log(form.value);  // {last: 'last'}
       * console.log(form.get('first').status);  // 'DISABLED'
       * ```
       */
      reset(value = {}, options = {}) {
        this._forEachChild((control, name2) => {
          control.reset(value ? value[name2] : null, {
            onlySelf: true,
            emitEvent: options.emitEvent
          });
        });
        this._updatePristine(options, this);
        this._updateTouched(options, this);
        this.updateValueAndValidity(options);
      }
      /**
       * The aggregate value of the `FormGroup`, including any disabled controls.
       *
       * Retrieves all values regardless of disabled status.
       */
      getRawValue() {
        return this._reduceChildren({}, (acc, control, name2) => {
          acc[name2] = control.getRawValue();
          return acc;
        });
      }
      /** @internal */
      _syncPendingControls() {
        let subtreeUpdated = this._reduceChildren(false, (updated, child) => {
          return child._syncPendingControls() ? true : updated;
        });
        if (subtreeUpdated) this.updateValueAndValidity({
          onlySelf: true
        });
        return subtreeUpdated;
      }
      /** @internal */
      _forEachChild(cb) {
        Object.keys(this.controls).forEach((key) => {
          const control = this.controls[key];
          control && cb(control, key);
        });
      }
      /** @internal */
      _setUpControls() {
        this._forEachChild((control) => {
          control.setParent(this);
          control._registerOnCollectionChange(this._onCollectionChange);
        });
      }
      /** @internal */
      _updateValue() {
        this.value = this._reduceValue();
      }
      /** @internal */
      _anyControls(condition) {
        for (const [controlName, control] of Object.entries(this.controls)) {
          if (this.contains(controlName) && condition(control)) {
            return true;
          }
        }
        return false;
      }
      /** @internal */
      _reduceValue() {
        let acc = {};
        return this._reduceChildren(acc, (acc2, control, name2) => {
          if (control.enabled || this.disabled) {
            acc2[name2] = control.value;
          }
          return acc2;
        });
      }
      /** @internal */
      _reduceChildren(initValue, fn) {
        let res = initValue;
        this._forEachChild((control, name2) => {
          res = fn(res, control, name2);
        });
        return res;
      }
      /** @internal */
      _allControlsDisabled() {
        for (const controlName of Object.keys(this.controls)) {
          if (this.controls[controlName].enabled) {
            return false;
          }
        }
        return Object.keys(this.controls).length > 0 || this.disabled;
      }
      /** @internal */
      _find(name2) {
        return this.controls.hasOwnProperty(name2) ? this.controls[name2] : null;
      }
    };
    FormRecord = class extends FormGroup {
    };
    CALL_SET_DISABLED_STATE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "CallSetDisabledState" : "", {
      providedIn: "root",
      factory: () => setDisabledStateDefault
    });
    setDisabledStateDefault = "always";
    formDirectiveProvider$1 = {
      provide: ControlContainer,
      useExisting: forwardRef(() => NgForm)
    };
    resolvedPromise$1 = (() => Promise.resolve())();
    NgForm = class _NgForm extends ControlContainer {
      callSetDisabledState;
      /**
       * @description
       * Returns whether the form submission has been triggered.
       */
      get submitted() {
        return untracked2(this.submittedReactive);
      }
      /** @internal */
      _submitted = computed(() => this.submittedReactive(), ...ngDevMode ? [{
        debugName: "_submitted"
      }] : []);
      submittedReactive = signal(false, ...ngDevMode ? [{
        debugName: "submittedReactive"
      }] : []);
      _directives = /* @__PURE__ */ new Set();
      /**
       * @description
       * The `FormGroup` instance created for this form.
       */
      form;
      /**
       * @description
       * Event emitter for the "ngSubmit" event
       */
      ngSubmit = new EventEmitter();
      /**
       * @description
       * Tracks options for the `NgForm` instance.
       *
       * **updateOn**: Sets the default `updateOn` value for all child `NgModels` below it
       * unless explicitly set by a child `NgModel` using `ngModelOptions`). Defaults to 'change'.
       * Possible values: `'change'` | `'blur'` | `'submit'`.
       *
       */
      options;
      constructor(validators, asyncValidators, callSetDisabledState) {
        super();
        this.callSetDisabledState = callSetDisabledState;
        this.form = new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
      }
      /** @docs-private */
      ngAfterViewInit() {
        this._setUpdateStrategy();
      }
      /**
       * @description
       * The directive instance.
       */
      get formDirective() {
        return this;
      }
      /**
       * @description
       * The internal `FormGroup` instance.
       */
      get control() {
        return this.form;
      }
      /**
       * @description
       * Returns an array representing the path to this group. Because this directive
       * always lives at the top level of a form, it is always an empty array.
       */
      get path() {
        return [];
      }
      /**
       * @description
       * Returns a map of the controls in this group.
       */
      get controls() {
        return this.form.controls;
      }
      /**
       * @description
       * Method that sets up the control directive in this group, re-calculates its value
       * and validity, and adds the instance to the internal list of directives.
       *
       * @param dir The `NgModel` directive instance.
       */
      addControl(dir) {
        resolvedPromise$1.then(() => {
          const container = this._findContainer(dir.path);
          dir.control = container.registerControl(dir.name, dir.control);
          setUpControl(dir.control, dir, this.callSetDisabledState);
          dir.control.updateValueAndValidity({
            emitEvent: false
          });
          this._directives.add(dir);
        });
      }
      /**
       * @description
       * Retrieves the `FormControl` instance from the provided `NgModel` directive.
       *
       * @param dir The `NgModel` directive instance.
       */
      getControl(dir) {
        return this.form.get(dir.path);
      }
      /**
       * @description
       * Removes the `NgModel` instance from the internal list of directives
       *
       * @param dir The `NgModel` directive instance.
       */
      removeControl(dir) {
        resolvedPromise$1.then(() => {
          const container = this._findContainer(dir.path);
          if (container) {
            container.removeControl(dir.name);
          }
          this._directives.delete(dir);
        });
      }
      /**
       * @description
       * Adds a new `NgModelGroup` directive instance to the form.
       *
       * @param dir The `NgModelGroup` directive instance.
       */
      addFormGroup(dir) {
        resolvedPromise$1.then(() => {
          const container = this._findContainer(dir.path);
          const group = new FormGroup({});
          setUpFormContainer(group, dir);
          container.registerControl(dir.name, group);
          group.updateValueAndValidity({
            emitEvent: false
          });
        });
      }
      /**
       * @description
       * Removes the `NgModelGroup` directive instance from the form.
       *
       * @param dir The `NgModelGroup` directive instance.
       */
      removeFormGroup(dir) {
        resolvedPromise$1.then(() => {
          const container = this._findContainer(dir.path);
          if (container) {
            container.removeControl(dir.name);
          }
        });
      }
      /**
       * @description
       * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance
       *
       * @param dir The `NgModelGroup` directive instance.
       */
      getFormGroup(dir) {
        return this.form.get(dir.path);
      }
      /**
       * Sets the new value for the provided `NgControl` directive.
       *
       * @param dir The `NgControl` directive instance.
       * @param value The new value for the directive's control.
       */
      updateModel(dir, value) {
        resolvedPromise$1.then(() => {
          const ctrl = this.form.get(dir.path);
          ctrl.setValue(value);
        });
      }
      /**
       * @description
       * Sets the value for this `FormGroup`.
       *
       * @param value The new value
       */
      setValue(value) {
        this.control.setValue(value);
      }
      /**
       * @description
       * Method called when the "submit" event is triggered on the form.
       * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
       *
       * @param $event The "submit" event object
       */
      onSubmit($event) {
        this.submittedReactive.set(true);
        syncPendingControls(this.form, this._directives);
        this.ngSubmit.emit($event);
        this.form._events.next(new FormSubmittedEvent(this.control));
        return $event?.target?.method === "dialog";
      }
      /**
       * @description
       * Method called when the "reset" event is triggered on the form.
       */
      onReset() {
        this.resetForm();
      }
      /**
       * @description
       * Resets the form to an initial value and resets its submitted status.
       *
       * @param value The new value for the form.
       */
      resetForm(value = void 0) {
        this.form.reset(value);
        this.submittedReactive.set(false);
        this.form._events.next(new FormResetEvent(this.form));
      }
      _setUpdateStrategy() {
        if (this.options && this.options.updateOn != null) {
          this.form._updateOn = this.options.updateOn;
        }
      }
      _findContainer(path) {
        path.pop();
        return path.length ? this.form.get(path) : this.form;
      }
      static \u0275fac = function NgForm_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgForm)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgForm,
        selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]],
        hostBindings: function NgForm_HostBindings(rf, ctx) {
          if (rf & 1) {
            \u0275\u0275listener("submit", function NgForm_submit_HostBindingHandler($event) {
              return ctx.onSubmit($event);
            })("reset", function NgForm_reset_HostBindingHandler() {
              return ctx.onReset();
            });
          }
        },
        inputs: {
          options: [0, "ngFormOptions", "options"]
        },
        outputs: {
          ngSubmit: "ngSubmit"
        },
        exportAs: ["ngForm"],
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([formDirectiveProvider$1]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgForm, [{
        type: Directive,
        args: [{
          selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]",
          providers: [formDirectiveProvider$1],
          host: {
            "(submit)": "onSubmit($event)",
            "(reset)": "onReset()"
          },
          outputs: ["ngSubmit"],
          exportAs: "ngForm",
          standalone: false
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_ASYNC_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [CALL_SET_DISABLED_STATE]
        }]
      }], {
        options: [{
          type: Input,
          args: ["ngFormOptions"]
        }]
      });
    })();
    FormControl = class FormControl2 extends AbstractControl {
      /** @publicApi */
      defaultValue = null;
      /** @internal */
      _onChange = [];
      /** @internal */
      _pendingValue;
      /** @internal */
      _pendingChange = false;
      constructor(formState = null, validatorOrOpts, asyncValidator) {
        super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
        this._applyFormState(formState);
        this._setUpdateStrategy(validatorOrOpts);
        this._initObservables();
        this.updateValueAndValidity({
          onlySelf: true,
          // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
          // `VALID` or `INVALID`.
          // The status should be broadcasted via the `statusChanges` observable, so we set
          // `emitEvent` to `true` to allow that during the control creation process.
          emitEvent: !!this.asyncValidator
        });
        if (isOptionsObj(validatorOrOpts) && (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)) {
          if (isFormControlState(formState)) {
            this.defaultValue = formState.value;
          } else {
            this.defaultValue = formState;
          }
        }
      }
      setValue(value, options = {}) {
        this.value = this._pendingValue = value;
        if (this._onChange.length && options.emitModelToViewChange !== false) {
          this._onChange.forEach((changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));
        }
        this.updateValueAndValidity(options);
      }
      patchValue(value, options = {}) {
        this.setValue(value, options);
      }
      reset(formState = this.defaultValue, options = {}) {
        this._applyFormState(formState);
        this.markAsPristine(options);
        this.markAsUntouched(options);
        this.setValue(this.value, options);
        this._pendingChange = false;
      }
      /**  @internal */
      _updateValue() {
      }
      /**  @internal */
      _anyControls(condition) {
        return false;
      }
      /**  @internal */
      _allControlsDisabled() {
        return this.disabled;
      }
      registerOnChange(fn) {
        this._onChange.push(fn);
      }
      /** @internal */
      _unregisterOnChange(fn) {
        removeListItem(this._onChange, fn);
      }
      registerOnDisabledChange(fn) {
        this._onDisabledChange.push(fn);
      }
      /** @internal */
      _unregisterOnDisabledChange(fn) {
        removeListItem(this._onDisabledChange, fn);
      }
      /** @internal */
      _forEachChild(cb) {
      }
      /** @internal */
      _syncPendingControls() {
        if (this.updateOn === "submit") {
          if (this._pendingDirty) this.markAsDirty();
          if (this._pendingTouched) this.markAsTouched();
          if (this._pendingChange) {
            this.setValue(this._pendingValue, {
              onlySelf: true,
              emitModelToViewChange: false
            });
            return true;
          }
        }
        return false;
      }
      _applyFormState(formState) {
        if (isFormControlState(formState)) {
          this.value = this._pendingValue = formState.value;
          formState.disabled ? this.disable({
            onlySelf: true,
            emitEvent: false
          }) : this.enable({
            onlySelf: true,
            emitEvent: false
          });
        } else {
          this.value = this._pendingValue = formState;
        }
      }
    };
    isFormControl = (control) => control instanceof FormControl;
    AbstractFormGroupDirective = class _AbstractFormGroupDirective extends ControlContainer {
      /**
       * @description
       * The parent control for the group
       *
       * @internal
       */
      _parent;
      /** @docs-private */
      ngOnInit() {
        this._checkParentType();
        this.formDirective.addFormGroup(this);
      }
      /** @docs-private */
      ngOnDestroy() {
        if (this.formDirective) {
          this.formDirective.removeFormGroup(this);
        }
      }
      /**
       * @description
       * The `FormGroup` bound to this directive.
       */
      get control() {
        return this.formDirective.getFormGroup(this);
      }
      /**
       * @description
       * The path to this group from the top-level directive.
       */
      get path() {
        return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
      }
      /**
       * @description
       * The top-level directive for this group if present, otherwise null.
       */
      get formDirective() {
        return this._parent ? this._parent.formDirective : null;
      }
      /** @internal */
      _checkParentType() {
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275AbstractFormGroupDirective_BaseFactory;
        return function AbstractFormGroupDirective_Factory(__ngFactoryType__) {
          return (\u0275AbstractFormGroupDirective_BaseFactory || (\u0275AbstractFormGroupDirective_BaseFactory = \u0275\u0275getInheritedFactory(_AbstractFormGroupDirective)))(__ngFactoryType__ || _AbstractFormGroupDirective);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _AbstractFormGroupDirective,
        standalone: false,
        features: [\u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractFormGroupDirective, [{
        type: Directive,
        args: [{
          standalone: false
        }]
      }], null, null);
    })();
    modelGroupProvider = {
      provide: ControlContainer,
      useExisting: forwardRef(() => NgModelGroup)
    };
    NgModelGroup = class _NgModelGroup extends AbstractFormGroupDirective {
      /**
       * @description
       * Tracks the name of the `NgModelGroup` bound to the directive. The name corresponds
       * to a key in the parent `NgForm`.
       */
      name = "";
      constructor(parent, validators, asyncValidators) {
        super();
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
      }
      /** @internal */
      _checkParentType() {
        if (!(this._parent instanceof _NgModelGroup) && !(this._parent instanceof NgForm) && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw modelGroupParentException();
        }
      }
      static \u0275fac = function NgModelGroup_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgModelGroup)(\u0275\u0275directiveInject(ControlContainer, 5), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgModelGroup,
        selectors: [["", "ngModelGroup", ""]],
        inputs: {
          name: [0, "ngModelGroup", "name"]
        },
        exportAs: ["ngModelGroup"],
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([modelGroupProvider]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModelGroup, [{
        type: Directive,
        args: [{
          selector: "[ngModelGroup]",
          providers: [modelGroupProvider],
          exportAs: "ngModelGroup",
          standalone: false
        }]
      }], () => [{
        type: ControlContainer,
        decorators: [{
          type: Host
        }, {
          type: SkipSelf
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_ASYNC_VALIDATORS]
        }]
      }], {
        name: [{
          type: Input,
          args: ["ngModelGroup"]
        }]
      });
    })();
    formControlBinding$1 = {
      provide: NgControl,
      useExisting: forwardRef(() => NgModel)
    };
    resolvedPromise = (() => Promise.resolve())();
    NgModel = class _NgModel extends NgControl {
      _changeDetectorRef;
      callSetDisabledState;
      control = new FormControl();
      // At runtime we coerce arbitrary values assigned to the "disabled" input to a "boolean".
      // This is not reflected in the type of the property because outside of templates, consumers
      // should only deal with booleans. In templates, a string is allowed for convenience and to
      // match the native "disabled attribute" semantics which can be observed on input elements.
      // This static member tells the compiler that values of type "string" can also be assigned
      // to the input in a template.
      /** @docs-private */
      static ngAcceptInputType_isDisabled;
      /** @internal */
      _registered = false;
      /**
       * Internal reference to the view model value.
       * @docs-private
       */
      viewModel;
      /**
       * @description
       * Tracks the name bound to the directive. If a parent form exists, it
       * uses this name as a key to retrieve this control's value.
       */
      name = "";
      /**
       * @description
       * Tracks whether the control is disabled.
       */
      isDisabled;
      /**
       * @description
       * Tracks the value bound to this directive.
       */
      model;
      /**
       * @description
       * Tracks the configuration options for this `ngModel` instance.
       *
       * **name**: An alternative to setting the name attribute on the form control element. See
       * the [example](api/forms/NgModel#using-ngmodel-on-a-standalone-control) for using `NgModel`
       * as a standalone control.
       *
       * **standalone**: When set to true, the `ngModel` will not register itself with its parent form,
       * and acts as if it's not in the form. Defaults to false. If no parent form exists, this option
       * has no effect.
       *
       * **updateOn**: Defines the event upon which the form control value and validity update.
       * Defaults to 'change'. Possible values: `'change'` | `'blur'` | `'submit'`.
       *
       */
      options;
      /**
       * @description
       * Event emitter for producing the `ngModelChange` event after
       * the view model updates.
       */
      update = new EventEmitter();
      constructor(parent, validators, asyncValidators, valueAccessors, _changeDetectorRef, callSetDisabledState) {
        super();
        this._changeDetectorRef = _changeDetectorRef;
        this.callSetDisabledState = callSetDisabledState;
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
        this.valueAccessor = selectValueAccessor(this, valueAccessors);
      }
      /** @docs-private */
      ngOnChanges(changes) {
        this._checkForErrors();
        if (!this._registered || "name" in changes) {
          if (this._registered) {
            this._checkName();
            if (this.formDirective) {
              const oldName = changes["name"].previousValue;
              this.formDirective.removeControl({
                name: oldName,
                path: this._getPath(oldName)
              });
            }
          }
          this._setUpControl();
        }
        if ("isDisabled" in changes) {
          this._updateDisabled(changes);
        }
        if (isPropertyUpdated(changes, this.viewModel)) {
          this._updateValue(this.model);
          this.viewModel = this.model;
        }
      }
      /** @docs-private */
      ngOnDestroy() {
        this.formDirective && this.formDirective.removeControl(this);
      }
      /**
       * @description
       * Returns an array that represents the path from the top-level form to this control.
       * Each index is the string name of the control on that level.
       */
      get path() {
        return this._getPath(this.name);
      }
      /**
       * @description
       * The top-level directive for this control if present, otherwise null.
       */
      get formDirective() {
        return this._parent ? this._parent.formDirective : null;
      }
      /**
       * @description
       * Sets the new value for the view model and emits an `ngModelChange` event.
       *
       * @param newValue The new value emitted by `ngModelChange`.
       */
      viewToModelUpdate(newValue) {
        this.viewModel = newValue;
        this.update.emit(newValue);
      }
      _setUpControl() {
        this._setUpdateStrategy();
        this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
        this._registered = true;
      }
      _setUpdateStrategy() {
        if (this.options && this.options.updateOn != null) {
          this.control._updateOn = this.options.updateOn;
        }
      }
      _isStandalone() {
        return !this._parent || !!(this.options && this.options.standalone);
      }
      _setUpStandalone() {
        setUpControl(this.control, this, this.callSetDisabledState);
        this.control.updateValueAndValidity({
          emitEvent: false
        });
      }
      _checkForErrors() {
        if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._isStandalone()) {
          checkParentType$1(this._parent);
        }
        this._checkName();
      }
      _checkName() {
        if (this.options && this.options.name) this.name = this.options.name;
        if (!this._isStandalone() && !this.name && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw missingNameException();
        }
      }
      _updateValue(value) {
        resolvedPromise.then(() => {
          this.control.setValue(value, {
            emitViewToModelChange: false
          });
          this._changeDetectorRef?.markForCheck();
        });
      }
      _updateDisabled(changes) {
        const disabledValue = changes["isDisabled"].currentValue;
        const isDisabled = disabledValue !== 0 && booleanAttribute(disabledValue);
        resolvedPromise.then(() => {
          if (isDisabled && !this.control.disabled) {
            this.control.disable();
          } else if (!isDisabled && this.control.disabled) {
            this.control.enable();
          }
          this._changeDetectorRef?.markForCheck();
        });
      }
      _getPath(controlName) {
        return this._parent ? controlPath(controlName, this._parent) : [controlName];
      }
      static \u0275fac = function NgModel_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgModel)(\u0275\u0275directiveInject(ControlContainer, 9), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(ChangeDetectorRef, 8), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgModel,
        selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]],
        inputs: {
          name: "name",
          isDisabled: [0, "disabled", "isDisabled"],
          model: [0, "ngModel", "model"],
          options: [0, "ngModelOptions", "options"]
        },
        outputs: {
          update: "ngModelChange"
        },
        exportAs: ["ngModel"],
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([formControlBinding$1]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModel, [{
        type: Directive,
        args: [{
          selector: "[ngModel]:not([formControlName]):not([formControl])",
          providers: [formControlBinding$1],
          exportAs: "ngModel",
          standalone: false
        }]
      }], () => [{
        type: ControlContainer,
        decorators: [{
          type: Optional
        }, {
          type: Host
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_ASYNC_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALUE_ACCESSOR]
        }]
      }, {
        type: ChangeDetectorRef,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [ChangeDetectorRef]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [CALL_SET_DISABLED_STATE]
        }]
      }], {
        name: [{
          type: Input
        }],
        isDisabled: [{
          type: Input,
          args: ["disabled"]
        }],
        model: [{
          type: Input,
          args: ["ngModel"]
        }],
        options: [{
          type: Input,
          args: ["ngModelOptions"]
        }],
        update: [{
          type: Output,
          args: ["ngModelChange"]
        }]
      });
    })();
    \u0275NgNoValidate = class _\u0275NgNoValidate {
      static \u0275fac = function \u0275NgNoValidate_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _\u0275NgNoValidate)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _\u0275NgNoValidate,
        selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]],
        hostAttrs: ["novalidate", ""],
        standalone: false
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275NgNoValidate, [{
        type: Directive,
        args: [{
          selector: "form:not([ngNoForm]):not([ngNativeValidate])",
          host: {
            "novalidate": ""
          },
          standalone: false
        }]
      }], null, null);
    })();
    NUMBER_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => NumberValueAccessor),
      multi: true
    };
    NumberValueAccessor = class _NumberValueAccessor extends BuiltInControlValueAccessor {
      /**
       * Sets the "value" property on the input element.
       * @docs-private
       */
      writeValue(value) {
        const normalizedValue = value == null ? "" : value;
        this.setProperty("value", normalizedValue);
      }
      /**
       * Registers a function called when the control value changes.
       * @docs-private
       */
      registerOnChange(fn) {
        this.onChange = (value) => {
          fn(value == "" ? null : parseFloat(value));
        };
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275NumberValueAccessor_BaseFactory;
        return function NumberValueAccessor_Factory(__ngFactoryType__) {
          return (\u0275NumberValueAccessor_BaseFactory || (\u0275NumberValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_NumberValueAccessor)))(__ngFactoryType__ || _NumberValueAccessor);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NumberValueAccessor,
        selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]],
        hostBindings: function NumberValueAccessor_HostBindings(rf, ctx) {
          if (rf & 1) {
            \u0275\u0275listener("input", function NumberValueAccessor_input_HostBindingHandler($event) {
              return ctx.onChange($event.target.value);
            })("blur", function NumberValueAccessor_blur_HostBindingHandler() {
              return ctx.onTouched();
            });
          }
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([NUMBER_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberValueAccessor, [{
        type: Directive,
        args: [{
          selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]",
          host: {
            "(input)": "onChange($any($event.target).value)",
            "(blur)": "onTouched()"
          },
          providers: [NUMBER_VALUE_ACCESSOR],
          standalone: false
        }]
      }], null, null);
    })();
    RADIO_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => RadioControlValueAccessor),
      multi: true
    };
    RadioControlRegistry = class _RadioControlRegistry {
      _accessors = [];
      /**
       * @description
       * Adds a control to the internal registry. For internal use only.
       */
      add(control, accessor) {
        this._accessors.push([control, accessor]);
      }
      /**
       * @description
       * Removes a control from the internal registry. For internal use only.
       */
      remove(accessor) {
        for (let i = this._accessors.length - 1; i >= 0; --i) {
          if (this._accessors[i][1] === accessor) {
            this._accessors.splice(i, 1);
            return;
          }
        }
      }
      /**
       * @description
       * Selects a radio button. For internal use only.
       */
      select(accessor) {
        this._accessors.forEach((c) => {
          if (this._isSameGroup(c, accessor) && c[1] !== accessor) {
            c[1].fireUncheck(accessor.value);
          }
        });
      }
      _isSameGroup(controlPair, accessor) {
        if (!controlPair[0].control) return false;
        return controlPair[0]._parent === accessor._control._parent && controlPair[1].name === accessor.name;
      }
      static \u0275fac = function RadioControlRegistry_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _RadioControlRegistry)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _RadioControlRegistry,
        factory: _RadioControlRegistry.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlRegistry, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    RadioControlValueAccessor = class _RadioControlValueAccessor extends BuiltInControlValueAccessor {
      _registry;
      _injector;
      /** @internal */
      _state;
      /** @internal */
      _control;
      /** @internal */
      _fn;
      setDisabledStateFired = false;
      /**
       * The registered callback function called when a change event occurs on the input element.
       * Note: we declare `onChange` here (also used as host listener) as a function with no arguments
       * to override the `onChange` function (which expects 1 argument) in the parent
       * `BaseControlValueAccessor` class.
       * @docs-private
       */
      onChange = () => {
      };
      /**
       * @description
       * Tracks the name of the radio input element.
       */
      name;
      /**
       * @description
       * Tracks the name of the `FormControl` bound to the directive. The name corresponds
       * to a key in the parent `FormGroup` or `FormArray`.
       */
      formControlName;
      /**
       * @description
       * Tracks the value of the radio input element
       */
      value;
      callSetDisabledState = inject2(CALL_SET_DISABLED_STATE, {
        optional: true
      }) ?? setDisabledStateDefault;
      constructor(renderer, elementRef, _registry, _injector) {
        super(renderer, elementRef);
        this._registry = _registry;
        this._injector = _injector;
      }
      /** @docs-private */
      ngOnInit() {
        this._control = this._injector.get(NgControl);
        this._checkName();
        this._registry.add(this._control, this);
      }
      /** @docs-private */
      ngOnDestroy() {
        this._registry.remove(this);
      }
      /**
       * Sets the "checked" property value on the radio input element.
       * @docs-private
       */
      writeValue(value) {
        this._state = value === this.value;
        this.setProperty("checked", this._state);
      }
      /**
       * Registers a function called when the control value changes.
       * @docs-private
       */
      registerOnChange(fn) {
        this._fn = fn;
        this.onChange = () => {
          fn(this.value);
          this._registry.select(this);
        };
      }
      /** @docs-private */
      setDisabledState(isDisabled) {
        if (this.setDisabledStateFired || isDisabled || this.callSetDisabledState === "whenDisabledForLegacyCode") {
          this.setProperty("disabled", isDisabled);
        }
        this.setDisabledStateFired = true;
      }
      /**
       * Sets the "value" on the radio input element and unchecks it.
       *
       * @param value
       */
      fireUncheck(value) {
        this.writeValue(value);
      }
      _checkName() {
        if (this.name && this.formControlName && this.name !== this.formControlName && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throwNameError();
        }
        if (!this.name && this.formControlName) this.name = this.formControlName;
      }
      static \u0275fac = function RadioControlValueAccessor_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _RadioControlValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(RadioControlRegistry), \u0275\u0275directiveInject(Injector));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _RadioControlValueAccessor,
        selectors: [["input", "type", "radio", "formControlName", ""], ["input", "type", "radio", "formControl", ""], ["input", "type", "radio", "ngModel", ""]],
        hostBindings: function RadioControlValueAccessor_HostBindings(rf, ctx) {
          if (rf & 1) {
            \u0275\u0275listener("change", function RadioControlValueAccessor_change_HostBindingHandler() {
              return ctx.onChange();
            })("blur", function RadioControlValueAccessor_blur_HostBindingHandler() {
              return ctx.onTouched();
            });
          }
        },
        inputs: {
          name: "name",
          formControlName: "formControlName",
          value: "value"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([RADIO_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlValueAccessor, [{
        type: Directive,
        args: [{
          selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]",
          host: {
            "(change)": "onChange()",
            "(blur)": "onTouched()"
          },
          providers: [RADIO_VALUE_ACCESSOR],
          standalone: false
        }]
      }], () => [{
        type: Renderer2
      }, {
        type: ElementRef
      }, {
        type: RadioControlRegistry
      }, {
        type: Injector
      }], {
        name: [{
          type: Input
        }],
        formControlName: [{
          type: Input
        }],
        value: [{
          type: Input
        }]
      });
    })();
    RANGE_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => RangeValueAccessor),
      multi: true
    };
    RangeValueAccessor = class _RangeValueAccessor extends BuiltInControlValueAccessor {
      /**
       * Sets the "value" property on the input element.
       * @docs-private
       */
      writeValue(value) {
        this.setProperty("value", parseFloat(value));
      }
      /**
       * Registers a function called when the control value changes.
       * @docs-private
       */
      registerOnChange(fn) {
        this.onChange = (value) => {
          fn(value == "" ? null : parseFloat(value));
        };
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275RangeValueAccessor_BaseFactory;
        return function RangeValueAccessor_Factory(__ngFactoryType__) {
          return (\u0275RangeValueAccessor_BaseFactory || (\u0275RangeValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_RangeValueAccessor)))(__ngFactoryType__ || _RangeValueAccessor);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _RangeValueAccessor,
        selectors: [["input", "type", "range", "formControlName", ""], ["input", "type", "range", "formControl", ""], ["input", "type", "range", "ngModel", ""]],
        hostBindings: function RangeValueAccessor_HostBindings(rf, ctx) {
          if (rf & 1) {
            \u0275\u0275listener("change", function RangeValueAccessor_change_HostBindingHandler($event) {
              return ctx.onChange($event.target.value);
            })("input", function RangeValueAccessor_input_HostBindingHandler($event) {
              return ctx.onChange($event.target.value);
            })("blur", function RangeValueAccessor_blur_HostBindingHandler() {
              return ctx.onTouched();
            });
          }
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([RANGE_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeValueAccessor, [{
        type: Directive,
        args: [{
          selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]",
          host: {
            "(change)": "onChange($any($event.target).value)",
            "(input)": "onChange($any($event.target).value)",
            "(blur)": "onTouched()"
          },
          providers: [RANGE_VALUE_ACCESSOR],
          standalone: false
        }]
      }], null, null);
    })();
    NG_MODEL_WITH_FORM_CONTROL_WARNING = new InjectionToken(ngDevMode ? "NgModelWithFormControlWarning" : "");
    formControlBinding = {
      provide: NgControl,
      useExisting: forwardRef(() => FormControlDirective)
    };
    FormControlDirective = class _FormControlDirective extends NgControl {
      _ngModelWarningConfig;
      callSetDisabledState;
      /**
       * Internal reference to the view model value.
       * @docs-private
       */
      viewModel;
      /**
       * @description
       * Tracks the `FormControl` instance bound to the directive.
       */
      form;
      /**
       * @description
       * Triggers a warning in dev mode that this input should not be used with reactive forms.
       */
      set isDisabled(isDisabled) {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          console.warn(disabledAttrWarning);
        }
      }
      // TODO(kara): remove next 4 properties once deprecation period is over
      /** @deprecated as of v6 */
      model;
      /** @deprecated as of v6 */
      update = new EventEmitter();
      /**
       * @description
       * Static property used to track whether any ngModel warnings have been sent across
       * all instances of FormControlDirective. Used to support warning config of "once".
       *
       * @internal
       */
      static _ngModelWarningSentOnce = false;
      /**
       * @description
       * Instance property used to track whether an ngModel warning has been sent out for this
       * particular `FormControlDirective` instance. Used to support warning config of "always".
       *
       * @internal
       */
      _ngModelWarningSent = false;
      constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig, callSetDisabledState) {
        super();
        this._ngModelWarningConfig = _ngModelWarningConfig;
        this.callSetDisabledState = callSetDisabledState;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
        this.valueAccessor = selectValueAccessor(this, valueAccessors);
      }
      /** @docs-private */
      ngOnChanges(changes) {
        if (this._isControlChanged(changes)) {
          const previousForm = changes["form"].previousValue;
          if (previousForm) {
            cleanUpControl(
              previousForm,
              this,
              /* validateControlPresenceOnChange */
              false
            );
          }
          setUpControl(this.form, this, this.callSetDisabledState);
          this.form.updateValueAndValidity({
            emitEvent: false
          });
        }
        if (isPropertyUpdated(changes, this.viewModel)) {
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            _ngModelWarning("formControl", _FormControlDirective, this, this._ngModelWarningConfig);
          }
          this.form.setValue(this.model);
          this.viewModel = this.model;
        }
      }
      /** @docs-private */
      ngOnDestroy() {
        if (this.form) {
          cleanUpControl(
            this.form,
            this,
            /* validateControlPresenceOnChange */
            false
          );
        }
      }
      /**
       * @description
       * Returns an array that represents the path from the top-level form to this control.
       * Each index is the string name of the control on that level.
       */
      get path() {
        return [];
      }
      /**
       * @description
       * The `FormControl` bound to this directive.
       */
      get control() {
        return this.form;
      }
      /**
       * @description
       * Sets the new value for the view model and emits an `ngModelChange` event.
       *
       * @param newValue The new value for the view model.
       */
      viewToModelUpdate(newValue) {
        this.viewModel = newValue;
        this.update.emit(newValue);
      }
      _isControlChanged(changes) {
        return changes.hasOwnProperty("form");
      }
      static \u0275fac = function FormControlDirective_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _FormControlDirective)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _FormControlDirective,
        selectors: [["", "formControl", ""]],
        inputs: {
          form: [0, "formControl", "form"],
          isDisabled: [0, "disabled", "isDisabled"],
          model: [0, "ngModel", "model"]
        },
        outputs: {
          update: "ngModelChange"
        },
        exportAs: ["ngForm"],
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([formControlBinding]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlDirective, [{
        type: Directive,
        args: [{
          selector: "[formControl]",
          providers: [formControlBinding],
          exportAs: "ngForm",
          standalone: false
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_ASYNC_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALUE_ACCESSOR]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [CALL_SET_DISABLED_STATE]
        }]
      }], {
        form: [{
          type: Input,
          args: ["formControl"]
        }],
        isDisabled: [{
          type: Input,
          args: ["disabled"]
        }],
        model: [{
          type: Input,
          args: ["ngModel"]
        }],
        update: [{
          type: Output,
          args: ["ngModelChange"]
        }]
      });
    })();
    formDirectiveProvider = {
      provide: ControlContainer,
      useExisting: forwardRef(() => FormGroupDirective)
    };
    FormGroupDirective = class _FormGroupDirective extends ControlContainer {
      callSetDisabledState;
      /**
       * @description
       * Reports whether the form submission has been triggered.
       */
      get submitted() {
        return untracked2(this._submittedReactive);
      }
      // TODO(atscott): Remove once invalid API usage is cleaned up internally
      set submitted(value) {
        this._submittedReactive.set(value);
      }
      /** @internal */
      _submitted = computed(() => this._submittedReactive(), ...ngDevMode ? [{
        debugName: "_submitted"
      }] : []);
      _submittedReactive = signal(false, ...ngDevMode ? [{
        debugName: "_submittedReactive"
      }] : []);
      /**
       * Reference to an old form group input value, which is needed to cleanup
       * old instance in case it was replaced with a new one.
       */
      _oldForm;
      /**
       * Callback that should be invoked when controls in FormGroup or FormArray collection change
       * (added or removed). This callback triggers corresponding DOM updates.
       */
      _onCollectionChange = () => this._updateDomValue();
      /**
       * @description
       * Tracks the list of added `FormControlName` instances
       */
      directives = [];
      /**
       * @description
       * Tracks the `FormGroup` bound to this directive.
       */
      form = null;
      /**
       * @description
       * Emits an event when the form submission has been triggered.
       */
      ngSubmit = new EventEmitter();
      constructor(validators, asyncValidators, callSetDisabledState) {
        super();
        this.callSetDisabledState = callSetDisabledState;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
      }
      /** @docs-private */
      ngOnChanges(changes) {
        if ((typeof ngDevMode === "undefined" || ngDevMode) && !this.form) {
          throw missingFormException();
        }
        if (changes.hasOwnProperty("form")) {
          this._updateValidators();
          this._updateDomValue();
          this._updateRegistrations();
          this._oldForm = this.form;
        }
      }
      /** @docs-private */
      ngOnDestroy() {
        if (this.form) {
          cleanUpValidators(this.form, this);
          if (this.form._onCollectionChange === this._onCollectionChange) {
            this.form._registerOnCollectionChange(() => {
            });
          }
        }
      }
      /**
       * @description
       * Returns this directive's instance.
       */
      get formDirective() {
        return this;
      }
      /**
       * @description
       * Returns the `FormGroup` bound to this directive.
       */
      get control() {
        return this.form;
      }
      /**
       * @description
       * Returns an array representing the path to this group. Because this directive
       * always lives at the top level of a form, it always an empty array.
       */
      get path() {
        return [];
      }
      /**
       * @description
       * Method that sets up the control directive in this group, re-calculates its value
       * and validity, and adds the instance to the internal list of directives.
       *
       * @param dir The `FormControlName` directive instance.
       */
      addControl(dir) {
        const ctrl = this.form.get(dir.path);
        setUpControl(ctrl, dir, this.callSetDisabledState);
        ctrl.updateValueAndValidity({
          emitEvent: false
        });
        this.directives.push(dir);
        return ctrl;
      }
      /**
       * @description
       * Retrieves the `FormControl` instance from the provided `FormControlName` directive
       *
       * @param dir The `FormControlName` directive instance.
       */
      getControl(dir) {
        return this.form.get(dir.path);
      }
      /**
       * @description
       * Removes the `FormControlName` instance from the internal list of directives
       *
       * @param dir The `FormControlName` directive instance.
       */
      removeControl(dir) {
        cleanUpControl(
          dir.control || null,
          dir,
          /* validateControlPresenceOnChange */
          false
        );
        removeListItem$1(this.directives, dir);
      }
      /**
       * Adds a new `FormGroupName` directive instance to the form.
       *
       * @param dir The `FormGroupName` directive instance.
       */
      addFormGroup(dir) {
        this._setUpFormContainer(dir);
      }
      /**
       * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the
       * view.
       *
       * @param dir The `FormGroupName` directive instance.
       */
      removeFormGroup(dir) {
        this._cleanUpFormContainer(dir);
      }
      /**
       * @description
       * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance
       *
       * @param dir The `FormGroupName` directive instance.
       */
      getFormGroup(dir) {
        return this.form.get(dir.path);
      }
      /**
       * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.
       *
       * @param dir The `FormArrayName` directive instance.
       */
      addFormArray(dir) {
        this._setUpFormContainer(dir);
      }
      /**
       * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the
       * view.
       *
       * @param dir The `FormArrayName` directive instance.
       */
      removeFormArray(dir) {
        this._cleanUpFormContainer(dir);
      }
      /**
       * @description
       * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.
       *
       * @param dir The `FormArrayName` directive instance.
       */
      getFormArray(dir) {
        return this.form.get(dir.path);
      }
      /**
       * Sets the new value for the provided `FormControlName` directive.
       *
       * @param dir The `FormControlName` directive instance.
       * @param value The new value for the directive's control.
       */
      updateModel(dir, value) {
        const ctrl = this.form.get(dir.path);
        ctrl.setValue(value);
      }
      /**
       * @description
       * Method called with the "submit" event is triggered on the form.
       * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
       *
       * @param $event The "submit" event object
       */
      onSubmit($event) {
        this._submittedReactive.set(true);
        syncPendingControls(this.form, this.directives);
        this.ngSubmit.emit($event);
        this.form._events.next(new FormSubmittedEvent(this.control));
        return $event?.target?.method === "dialog";
      }
      /**
       * @description
       * Method called when the "reset" event is triggered on the form.
       */
      onReset() {
        this.resetForm();
      }
      /**
       * @description
       * Resets the form to an initial value and resets its submitted status.
       *
       * @param value The new value for the form, `undefined` by default
       */
      resetForm(value = void 0, options = {}) {
        this.form.reset(value, options);
        this._submittedReactive.set(false);
        if (options?.emitEvent !== false) {
          this.form._events.next(new FormResetEvent(this.form));
        }
      }
      /** @internal */
      _updateDomValue() {
        this.directives.forEach((dir) => {
          const oldCtrl = dir.control;
          const newCtrl = this.form.get(dir.path);
          if (oldCtrl !== newCtrl) {
            cleanUpControl(oldCtrl || null, dir);
            if (isFormControl(newCtrl)) {
              setUpControl(newCtrl, dir, this.callSetDisabledState);
              dir.control = newCtrl;
            }
          }
        });
        this.form._updateTreeValidity({
          emitEvent: false
        });
      }
      _setUpFormContainer(dir) {
        const ctrl = this.form.get(dir.path);
        setUpFormContainer(ctrl, dir);
        ctrl.updateValueAndValidity({
          emitEvent: false
        });
      }
      _cleanUpFormContainer(dir) {
        if (this.form) {
          const ctrl = this.form.get(dir.path);
          if (ctrl) {
            const isControlUpdated = cleanUpFormContainer(ctrl, dir);
            if (isControlUpdated) {
              ctrl.updateValueAndValidity({
                emitEvent: false
              });
            }
          }
        }
      }
      _updateRegistrations() {
        this.form._registerOnCollectionChange(this._onCollectionChange);
        if (this._oldForm) {
          this._oldForm._registerOnCollectionChange(() => {
          });
        }
      }
      _updateValidators() {
        setUpValidators(this.form, this);
        if (this._oldForm) {
          cleanUpValidators(this._oldForm, this);
        }
      }
      static \u0275fac = function FormGroupDirective_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _FormGroupDirective)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _FormGroupDirective,
        selectors: [["", "formGroup", ""]],
        hostBindings: function FormGroupDirective_HostBindings(rf, ctx) {
          if (rf & 1) {
            \u0275\u0275listener("submit", function FormGroupDirective_submit_HostBindingHandler($event) {
              return ctx.onSubmit($event);
            })("reset", function FormGroupDirective_reset_HostBindingHandler() {
              return ctx.onReset();
            });
          }
        },
        inputs: {
          form: [0, "formGroup", "form"]
        },
        outputs: {
          ngSubmit: "ngSubmit"
        },
        exportAs: ["ngForm"],
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([formDirectiveProvider]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupDirective, [{
        type: Directive,
        args: [{
          selector: "[formGroup]",
          providers: [formDirectiveProvider],
          host: {
            "(submit)": "onSubmit($event)",
            "(reset)": "onReset()"
          },
          exportAs: "ngForm",
          standalone: false
        }]
      }], () => [{
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_ASYNC_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [CALL_SET_DISABLED_STATE]
        }]
      }], {
        form: [{
          type: Input,
          args: ["formGroup"]
        }],
        ngSubmit: [{
          type: Output
        }]
      });
    })();
    formGroupNameProvider = {
      provide: ControlContainer,
      useExisting: forwardRef(() => FormGroupName)
    };
    FormGroupName = class _FormGroupName extends AbstractFormGroupDirective {
      /**
       * @description
       * Tracks the name of the `FormGroup` bound to the directive. The name corresponds
       * to a key in the parent `FormGroup` or `FormArray`.
       * Accepts a name as a string or a number.
       * The name in the form of a string is useful for individual forms,
       * while the numerical form allows for form groups to be bound
       * to indices when iterating over groups in a `FormArray`.
       */
      name = null;
      constructor(parent, validators, asyncValidators) {
        super();
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
      }
      /** @internal */
      _checkParentType() {
        if (hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw groupParentException();
        }
      }
      static \u0275fac = function FormGroupName_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _FormGroupName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _FormGroupName,
        selectors: [["", "formGroupName", ""]],
        inputs: {
          name: [0, "formGroupName", "name"]
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([formGroupNameProvider]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupName, [{
        type: Directive,
        args: [{
          selector: "[formGroupName]",
          providers: [formGroupNameProvider],
          standalone: false
        }]
      }], () => [{
        type: ControlContainer,
        decorators: [{
          type: Optional
        }, {
          type: Host
        }, {
          type: SkipSelf
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_ASYNC_VALIDATORS]
        }]
      }], {
        name: [{
          type: Input,
          args: ["formGroupName"]
        }]
      });
    })();
    formArrayNameProvider = {
      provide: ControlContainer,
      useExisting: forwardRef(() => FormArrayName)
    };
    FormArrayName = class _FormArrayName extends ControlContainer {
      /** @internal */
      _parent;
      /**
       * @description
       * Tracks the name of the `FormArray` bound to the directive. The name corresponds
       * to a key in the parent `FormGroup` or `FormArray`.
       * Accepts a name as a string or a number.
       * The name in the form of a string is useful for individual forms,
       * while the numerical form allows for form arrays to be bound
       * to indices when iterating over arrays in a `FormArray`.
       */
      name = null;
      constructor(parent, validators, asyncValidators) {
        super();
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
      }
      /**
       * A lifecycle method called when the directive's inputs are initialized. For internal use only.
       * @throws If the directive does not have a valid parent.
       * @docs-private
       */
      ngOnInit() {
        if (hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw arrayParentException();
        }
        this.formDirective.addFormArray(this);
      }
      /**
       * A lifecycle method called before the directive's instance is destroyed. For internal use only.
       * @docs-private
       */
      ngOnDestroy() {
        this.formDirective?.removeFormArray(this);
      }
      /**
       * @description
       * The `FormArray` bound to this directive.
       */
      get control() {
        return this.formDirective.getFormArray(this);
      }
      /**
       * @description
       * The top-level directive for this group if present, otherwise null.
       */
      get formDirective() {
        return this._parent ? this._parent.formDirective : null;
      }
      /**
       * @description
       * Returns an array that represents the path from the top-level form to this control.
       * Each index is the string name of the control on that level.
       */
      get path() {
        return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
      }
      static \u0275fac = function FormArrayName_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _FormArrayName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _FormArrayName,
        selectors: [["", "formArrayName", ""]],
        inputs: {
          name: [0, "formArrayName", "name"]
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([formArrayNameProvider]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormArrayName, [{
        type: Directive,
        args: [{
          selector: "[formArrayName]",
          providers: [formArrayNameProvider],
          standalone: false
        }]
      }], () => [{
        type: ControlContainer,
        decorators: [{
          type: Optional
        }, {
          type: Host
        }, {
          type: SkipSelf
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_ASYNC_VALIDATORS]
        }]
      }], {
        name: [{
          type: Input,
          args: ["formArrayName"]
        }]
      });
    })();
    controlNameBinding = {
      provide: NgControl,
      useExisting: forwardRef(() => FormControlName)
    };
    FormControlName = class _FormControlName extends NgControl {
      _ngModelWarningConfig;
      _added = false;
      /**
       * Internal reference to the view model value.
       * @internal
       */
      viewModel;
      /**
       * @description
       * Tracks the `FormControl` instance bound to the directive.
       */
      control;
      /**
       * @description
       * Tracks the name of the `FormControl` bound to the directive. The name corresponds
       * to a key in the parent `FormGroup` or `FormArray`.
       * Accepts a name as a string or a number.
       * The name in the form of a string is useful for individual forms,
       * while the numerical form allows for form controls to be bound
       * to indices when iterating over controls in a `FormArray`.
       */
      name = null;
      /**
       * @description
       * Triggers a warning in dev mode that this input should not be used with reactive forms.
       */
      set isDisabled(isDisabled) {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          console.warn(disabledAttrWarning);
        }
      }
      // TODO(kara): remove next 4 properties once deprecation period is over
      /** @deprecated as of v6 */
      model;
      /** @deprecated as of v6 */
      update = new EventEmitter();
      /**
       * @description
       * Static property used to track whether any ngModel warnings have been sent across
       * all instances of FormControlName. Used to support warning config of "once".
       *
       * @internal
       */
      static _ngModelWarningSentOnce = false;
      /**
       * @description
       * Instance property used to track whether an ngModel warning has been sent out for this
       * particular FormControlName instance. Used to support warning config of "always".
       *
       * @internal
       */
      _ngModelWarningSent = false;
      constructor(parent, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
        super();
        this._ngModelWarningConfig = _ngModelWarningConfig;
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
        this.valueAccessor = selectValueAccessor(this, valueAccessors);
      }
      /** @docs-private */
      ngOnChanges(changes) {
        if (!this._added) this._setUpControl();
        if (isPropertyUpdated(changes, this.viewModel)) {
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            _ngModelWarning("formControlName", _FormControlName, this, this._ngModelWarningConfig);
          }
          this.viewModel = this.model;
          this.formDirective.updateModel(this, this.model);
        }
      }
      /** @docs-private */
      ngOnDestroy() {
        if (this.formDirective) {
          this.formDirective.removeControl(this);
        }
      }
      /**
       * @description
       * Sets the new value for the view model and emits an `ngModelChange` event.
       *
       * @param newValue The new value for the view model.
       */
      viewToModelUpdate(newValue) {
        this.viewModel = newValue;
        this.update.emit(newValue);
      }
      /**
       * @description
       * Returns an array that represents the path from the top-level form to this control.
       * Each index is the string name of the control on that level.
       */
      get path() {
        return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
      }
      /**
       * @description
       * The top-level directive for this group if present, otherwise null.
       */
      get formDirective() {
        return this._parent ? this._parent.formDirective : null;
      }
      _setUpControl() {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          checkParentType(this._parent, this.name);
        }
        this.control = this.formDirective.addControl(this);
        this._added = true;
      }
      static \u0275fac = function FormControlName_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _FormControlName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _FormControlName,
        selectors: [["", "formControlName", ""]],
        inputs: {
          name: [0, "formControlName", "name"],
          isDisabled: [0, "disabled", "isDisabled"],
          model: [0, "ngModel", "model"]
        },
        outputs: {
          update: "ngModelChange"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([controlNameBinding]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlName, [{
        type: Directive,
        args: [{
          selector: "[formControlName]",
          providers: [controlNameBinding],
          standalone: false
        }]
      }], () => [{
        type: ControlContainer,
        decorators: [{
          type: Optional
        }, {
          type: Host
        }, {
          type: SkipSelf
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_ASYNC_VALIDATORS]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Self
        }, {
          type: Inject,
          args: [NG_VALUE_ACCESSOR]
        }]
      }, {
        type: void 0,
        decorators: [{
          type: Optional
        }, {
          type: Inject,
          args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
        }]
      }], {
        name: [{
          type: Input,
          args: ["formControlName"]
        }],
        isDisabled: [{
          type: Input,
          args: ["disabled"]
        }],
        model: [{
          type: Input,
          args: ["ngModel"]
        }],
        update: [{
          type: Output,
          args: ["ngModelChange"]
        }]
      });
    })();
    SELECT_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => SelectControlValueAccessor),
      multi: true
    };
    SelectControlValueAccessor = class _SelectControlValueAccessor extends BuiltInControlValueAccessor {
      /** @docs-private */
      value;
      /** @internal */
      _optionMap = /* @__PURE__ */ new Map();
      /** @internal */
      _idCounter = 0;
      /**
       * @description
       * Tracks the option comparison algorithm for tracking identities when
       * checking for changes.
       */
      set compareWith(fn) {
        if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
        }
        this._compareWith = fn;
      }
      _compareWith = Object.is;
      // We need this because we might be in the process of destroying the root
      // injector, which is marked as destroyed before running destroy hooks.
      // Attempting to use afterNextRender with the node injector would evntually
      // run into that already destroyed injector.
      appRefInjector = inject2(ApplicationRef).injector;
      destroyRef = inject2(DestroyRef);
      cdr = inject2(ChangeDetectorRef);
      _queuedWrite = false;
      /**
       * This is needed to efficiently set the select value when adding/removing options. If
       * writeValue is instead called for every added/removed option, this results in exponentially
       * more _compareValue calls than the number of option elements (issue #41330).
       *
       * Secondly, calling writeValue when rendering individual option elements instead of after they
       * are all rendered caused an issue in Safari and IE 11 where the first option element failed
       * to be deselected when no option matched the select ngModel. This was because Angular would
       * set the select element's value property before appending the option's child text node to the
       * DOM (issue #14505).
       *
       * Finally, this approach is necessary to avoid an issue with delayed element removal when
       * using the animations module (in all browsers). Otherwise when a selected option is removed
       * (so no option matches the ngModel anymore), Angular would change the select element value
       * before actually removing the option from the DOM. Then when the option is finally removed
       * from the DOM, the browser would change the select value to that of the first option, even
       * though it doesn't match the ngModel (issue #18430).
       *
       * @internal
       */
      _writeValueAfterRender() {
        if (this._queuedWrite || this.appRefInjector.destroyed) {
          return;
        }
        this._queuedWrite = true;
        afterNextRender({
          write: () => {
            if (this.destroyRef.destroyed) {
              return;
            }
            this._queuedWrite = false;
            this.writeValue(this.value);
          }
        }, {
          injector: this.appRefInjector
        });
      }
      /**
       * Sets the "value" property on the select element.
       * @docs-private
       */
      writeValue(value) {
        this.cdr.markForCheck();
        this.value = value;
        const id2 = this._getOptionId(value);
        const valueString = _buildValueString$1(id2, value);
        this.setProperty("value", valueString);
      }
      /**
       * Registers a function called when the control value changes.
       * @docs-private
       */
      registerOnChange(fn) {
        this.onChange = (valueString) => {
          this.value = this._getOptionValue(valueString);
          fn(this.value);
        };
      }
      /** @internal */
      _registerOption() {
        return (this._idCounter++).toString();
      }
      /** @internal */
      _getOptionId(value) {
        for (const id2 of this._optionMap.keys()) {
          if (this._compareWith(this._optionMap.get(id2), value)) return id2;
        }
        return null;
      }
      /** @internal */
      _getOptionValue(valueString) {
        const id2 = _extractId$1(valueString);
        return this._optionMap.has(id2) ? this._optionMap.get(id2) : valueString;
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275SelectControlValueAccessor_BaseFactory;
        return function SelectControlValueAccessor_Factory(__ngFactoryType__) {
          return (\u0275SelectControlValueAccessor_BaseFactory || (\u0275SelectControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_SelectControlValueAccessor)))(__ngFactoryType__ || _SelectControlValueAccessor);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _SelectControlValueAccessor,
        selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]],
        hostBindings: function SelectControlValueAccessor_HostBindings(rf, ctx) {
          if (rf & 1) {
            \u0275\u0275listener("change", function SelectControlValueAccessor_change_HostBindingHandler($event) {
              return ctx.onChange($event.target.value);
            })("blur", function SelectControlValueAccessor_blur_HostBindingHandler() {
              return ctx.onTouched();
            });
          }
        },
        inputs: {
          compareWith: "compareWith"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([SELECT_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectControlValueAccessor, [{
        type: Directive,
        args: [{
          selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]",
          host: {
            "(change)": "onChange($any($event.target).value)",
            "(blur)": "onTouched()"
          },
          providers: [SELECT_VALUE_ACCESSOR],
          standalone: false
        }]
      }], null, {
        compareWith: [{
          type: Input
        }]
      });
    })();
    NgSelectOption = class _NgSelectOption {
      _element;
      _renderer;
      _select;
      /**
       * @description
       * ID of the option element
       */
      id;
      constructor(_element, _renderer, _select) {
        this._element = _element;
        this._renderer = _renderer;
        this._select = _select;
        if (this._select) this.id = this._select._registerOption();
      }
      /**
       * @description
       * Tracks the value bound to the option element. Unlike the value binding,
       * ngValue supports binding to objects.
       */
      set ngValue(value) {
        if (this._select == null) return;
        this._select._optionMap.set(this.id, value);
        this._setElementValue(_buildValueString$1(this.id, value));
        this._select._writeValueAfterRender();
      }
      /**
       * @description
       * Tracks simple string values bound to the option element.
       * For objects, use the `ngValue` input binding.
       */
      set value(value) {
        this._setElementValue(value);
        if (this._select) this._select._writeValueAfterRender();
      }
      /** @internal */
      _setElementValue(value) {
        this._renderer.setProperty(this._element.nativeElement, "value", value);
      }
      /** @docs-private */
      ngOnDestroy() {
        if (this._select) {
          this._select._optionMap.delete(this.id);
          this._select._writeValueAfterRender();
        }
      }
      static \u0275fac = function NgSelectOption_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NgSelectOption)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(SelectControlValueAccessor, 9));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _NgSelectOption,
        selectors: [["option"]],
        inputs: {
          ngValue: "ngValue",
          value: "value"
        },
        standalone: false
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSelectOption, [{
        type: Directive,
        args: [{
          selector: "option",
          standalone: false
        }]
      }], () => [{
        type: ElementRef
      }, {
        type: Renderer2
      }, {
        type: SelectControlValueAccessor,
        decorators: [{
          type: Optional
        }, {
          type: Host
        }]
      }], {
        ngValue: [{
          type: Input,
          args: ["ngValue"]
        }],
        value: [{
          type: Input,
          args: ["value"]
        }]
      });
    })();
    SELECT_MULTIPLE_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => SelectMultipleControlValueAccessor),
      multi: true
    };
    SelectMultipleControlValueAccessor = class _SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor {
      /**
       * The current value.
       * @docs-private
       */
      value;
      /** @internal */
      _optionMap = /* @__PURE__ */ new Map();
      /** @internal */
      _idCounter = 0;
      /**
       * @description
       * Tracks the option comparison algorithm for tracking identities when
       * checking for changes.
       */
      set compareWith(fn) {
        if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
        }
        this._compareWith = fn;
      }
      _compareWith = Object.is;
      /**
       * Sets the "value" property on one or of more of the select's options.
       * @docs-private
       */
      writeValue(value) {
        this.value = value;
        let optionSelectedStateSetter;
        if (Array.isArray(value)) {
          const ids = value.map((v) => this._getOptionId(v));
          optionSelectedStateSetter = (opt, o) => {
            opt._setSelected(ids.indexOf(o.toString()) > -1);
          };
        } else {
          optionSelectedStateSetter = (opt, o) => {
            opt._setSelected(false);
          };
        }
        this._optionMap.forEach(optionSelectedStateSetter);
      }
      /**
       * Registers a function called when the control value changes
       * and writes an array of the selected options.
       * @docs-private
       */
      registerOnChange(fn) {
        this.onChange = (element) => {
          const selected = [];
          const selectedOptions = element.selectedOptions;
          if (selectedOptions !== void 0) {
            const options = selectedOptions;
            for (let i = 0; i < options.length; i++) {
              const opt = options[i];
              const val = this._getOptionValue(opt.value);
              selected.push(val);
            }
          } else {
            const options = element.options;
            for (let i = 0; i < options.length; i++) {
              const opt = options[i];
              if (opt.selected) {
                const val = this._getOptionValue(opt.value);
                selected.push(val);
              }
            }
          }
          this.value = selected;
          fn(selected);
        };
      }
      /** @internal */
      _registerOption(value) {
        const id2 = (this._idCounter++).toString();
        this._optionMap.set(id2, value);
        return id2;
      }
      /** @internal */
      _getOptionId(value) {
        for (const id2 of this._optionMap.keys()) {
          if (this._compareWith(this._optionMap.get(id2)._value, value)) return id2;
        }
        return null;
      }
      /** @internal */
      _getOptionValue(valueString) {
        const id2 = _extractId(valueString);
        return this._optionMap.has(id2) ? this._optionMap.get(id2)._value : valueString;
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275SelectMultipleControlValueAccessor_BaseFactory;
        return function SelectMultipleControlValueAccessor_Factory(__ngFactoryType__) {
          return (\u0275SelectMultipleControlValueAccessor_BaseFactory || (\u0275SelectMultipleControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_SelectMultipleControlValueAccessor)))(__ngFactoryType__ || _SelectMultipleControlValueAccessor);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _SelectMultipleControlValueAccessor,
        selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]],
        hostBindings: function SelectMultipleControlValueAccessor_HostBindings(rf, ctx) {
          if (rf & 1) {
            \u0275\u0275listener("change", function SelectMultipleControlValueAccessor_change_HostBindingHandler($event) {
              return ctx.onChange($event.target);
            })("blur", function SelectMultipleControlValueAccessor_blur_HostBindingHandler() {
              return ctx.onTouched();
            });
          }
        },
        inputs: {
          compareWith: "compareWith"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([SELECT_MULTIPLE_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectMultipleControlValueAccessor, [{
        type: Directive,
        args: [{
          selector: "select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]",
          host: {
            "(change)": "onChange($event.target)",
            "(blur)": "onTouched()"
          },
          providers: [SELECT_MULTIPLE_VALUE_ACCESSOR],
          standalone: false
        }]
      }], null, {
        compareWith: [{
          type: Input
        }]
      });
    })();
    \u0275NgSelectMultipleOption = class _\u0275NgSelectMultipleOption {
      _element;
      _renderer;
      _select;
      id;
      /** @internal */
      _value;
      constructor(_element, _renderer, _select) {
        this._element = _element;
        this._renderer = _renderer;
        this._select = _select;
        if (this._select) {
          this.id = this._select._registerOption(this);
        }
      }
      /**
       * @description
       * Tracks the value bound to the option element. Unlike the value binding,
       * ngValue supports binding to objects.
       */
      set ngValue(value) {
        if (this._select == null) return;
        this._value = value;
        this._setElementValue(_buildValueString(this.id, value));
        this._select.writeValue(this._select.value);
      }
      /**
       * @description
       * Tracks simple string values bound to the option element.
       * For objects, use the `ngValue` input binding.
       */
      set value(value) {
        if (this._select) {
          this._value = value;
          this._setElementValue(_buildValueString(this.id, value));
          this._select.writeValue(this._select.value);
        } else {
          this._setElementValue(value);
        }
      }
      /** @internal */
      _setElementValue(value) {
        this._renderer.setProperty(this._element.nativeElement, "value", value);
      }
      /** @internal */
      _setSelected(selected) {
        this._renderer.setProperty(this._element.nativeElement, "selected", selected);
      }
      /** @docs-private */
      ngOnDestroy() {
        if (this._select) {
          this._select._optionMap.delete(this.id);
          this._select.writeValue(this._select.value);
        }
      }
      static \u0275fac = function \u0275NgSelectMultipleOption_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _\u0275NgSelectMultipleOption)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(SelectMultipleControlValueAccessor, 9));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _\u0275NgSelectMultipleOption,
        selectors: [["option"]],
        inputs: {
          ngValue: "ngValue",
          value: "value"
        },
        standalone: false
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275NgSelectMultipleOption, [{
        type: Directive,
        args: [{
          selector: "option",
          standalone: false
        }]
      }], () => [{
        type: ElementRef
      }, {
        type: Renderer2
      }, {
        type: SelectMultipleControlValueAccessor,
        decorators: [{
          type: Optional
        }, {
          type: Host
        }]
      }], {
        ngValue: [{
          type: Input,
          args: ["ngValue"]
        }],
        value: [{
          type: Input,
          args: ["value"]
        }]
      });
    })();
    AbstractValidatorDirective = class _AbstractValidatorDirective {
      _validator = nullValidator;
      _onChange;
      /**
       * A flag that tracks whether this validator is enabled.
       *
       * Marking it `internal` (vs `protected`), so that this flag can be used in host bindings of
       * directive classes that extend this base class.
       * @internal
       */
      _enabled;
      /** @docs-private */
      ngOnChanges(changes) {
        if (this.inputName in changes) {
          const input2 = this.normalizeInput(changes[this.inputName].currentValue);
          this._enabled = this.enabled(input2);
          this._validator = this._enabled ? this.createValidator(input2) : nullValidator;
          if (this._onChange) {
            this._onChange();
          }
        }
      }
      /** @docs-private */
      validate(control) {
        return this._validator(control);
      }
      /** @docs-private */
      registerOnValidatorChange(fn) {
        this._onChange = fn;
      }
      /**
       * @description
       * Determines whether this validator should be active or not based on an input.
       * Base class implementation checks whether an input is defined (if the value is different from
       * `null` and `undefined`). Validator classes that extend this base class can override this
       * function with the logic specific to a particular validator directive.
       */
      enabled(input2) {
        return input2 != null;
      }
      static \u0275fac = function AbstractValidatorDirective_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _AbstractValidatorDirective)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _AbstractValidatorDirective,
        features: [\u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractValidatorDirective, [{
        type: Directive
      }], null, null);
    })();
    MAX_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => MaxValidator),
      multi: true
    };
    MaxValidator = class _MaxValidator extends AbstractValidatorDirective {
      /**
       * @description
       * Tracks changes to the max bound to this directive.
       */
      max;
      /** @internal */
      inputName = "max";
      /** @internal */
      normalizeInput = (input2) => toFloat(input2);
      /** @internal */
      createValidator = (max) => maxValidator(max);
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275MaxValidator_BaseFactory;
        return function MaxValidator_Factory(__ngFactoryType__) {
          return (\u0275MaxValidator_BaseFactory || (\u0275MaxValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MaxValidator)))(__ngFactoryType__ || _MaxValidator);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _MaxValidator,
        selectors: [["input", "type", "number", "max", "", "formControlName", ""], ["input", "type", "number", "max", "", "formControl", ""], ["input", "type", "number", "max", "", "ngModel", ""]],
        hostVars: 1,
        hostBindings: function MaxValidator_HostBindings(rf, ctx) {
          if (rf & 2) {
            \u0275\u0275attribute("max", ctx._enabled ? ctx.max : null);
          }
        },
        inputs: {
          max: "max"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([MAX_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxValidator, [{
        type: Directive,
        args: [{
          selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]",
          providers: [MAX_VALIDATOR],
          host: {
            "[attr.max]": "_enabled ? max : null"
          },
          standalone: false
        }]
      }], null, {
        max: [{
          type: Input
        }]
      });
    })();
    MIN_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => MinValidator),
      multi: true
    };
    MinValidator = class _MinValidator extends AbstractValidatorDirective {
      /**
       * @description
       * Tracks changes to the min bound to this directive.
       */
      min;
      /** @internal */
      inputName = "min";
      /** @internal */
      normalizeInput = (input2) => toFloat(input2);
      /** @internal */
      createValidator = (min) => minValidator(min);
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275MinValidator_BaseFactory;
        return function MinValidator_Factory(__ngFactoryType__) {
          return (\u0275MinValidator_BaseFactory || (\u0275MinValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MinValidator)))(__ngFactoryType__ || _MinValidator);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _MinValidator,
        selectors: [["input", "type", "number", "min", "", "formControlName", ""], ["input", "type", "number", "min", "", "formControl", ""], ["input", "type", "number", "min", "", "ngModel", ""]],
        hostVars: 1,
        hostBindings: function MinValidator_HostBindings(rf, ctx) {
          if (rf & 2) {
            \u0275\u0275attribute("min", ctx._enabled ? ctx.min : null);
          }
        },
        inputs: {
          min: "min"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([MIN_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinValidator, [{
        type: Directive,
        args: [{
          selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]",
          providers: [MIN_VALIDATOR],
          host: {
            "[attr.min]": "_enabled ? min : null"
          },
          standalone: false
        }]
      }], null, {
        min: [{
          type: Input
        }]
      });
    })();
    REQUIRED_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => RequiredValidator),
      multi: true
    };
    CHECKBOX_REQUIRED_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => CheckboxRequiredValidator),
      multi: true
    };
    RequiredValidator = class _RequiredValidator extends AbstractValidatorDirective {
      /**
       * @description
       * Tracks changes to the required attribute bound to this directive.
       */
      required;
      /** @internal */
      inputName = "required";
      /** @internal */
      normalizeInput = booleanAttribute;
      /** @internal */
      createValidator = (input2) => requiredValidator;
      /** @docs-private */
      enabled(input2) {
        return input2;
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275RequiredValidator_BaseFactory;
        return function RequiredValidator_Factory(__ngFactoryType__) {
          return (\u0275RequiredValidator_BaseFactory || (\u0275RequiredValidator_BaseFactory = \u0275\u0275getInheritedFactory(_RequiredValidator)))(__ngFactoryType__ || _RequiredValidator);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _RequiredValidator,
        selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]],
        hostVars: 1,
        hostBindings: function RequiredValidator_HostBindings(rf, ctx) {
          if (rf & 2) {
            \u0275\u0275attribute("required", ctx._enabled ? "" : null);
          }
        },
        inputs: {
          required: "required"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([REQUIRED_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RequiredValidator, [{
        type: Directive,
        args: [{
          selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]",
          providers: [REQUIRED_VALIDATOR],
          host: {
            "[attr.required]": '_enabled ? "" : null'
          },
          standalone: false
        }]
      }], null, {
        required: [{
          type: Input
        }]
      });
    })();
    CheckboxRequiredValidator = class _CheckboxRequiredValidator extends RequiredValidator {
      /** @internal */
      createValidator = (input2) => requiredTrueValidator;
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275CheckboxRequiredValidator_BaseFactory;
        return function CheckboxRequiredValidator_Factory(__ngFactoryType__) {
          return (\u0275CheckboxRequiredValidator_BaseFactory || (\u0275CheckboxRequiredValidator_BaseFactory = \u0275\u0275getInheritedFactory(_CheckboxRequiredValidator)))(__ngFactoryType__ || _CheckboxRequiredValidator);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CheckboxRequiredValidator,
        selectors: [["input", "type", "checkbox", "required", "", "formControlName", ""], ["input", "type", "checkbox", "required", "", "formControl", ""], ["input", "type", "checkbox", "required", "", "ngModel", ""]],
        hostVars: 1,
        hostBindings: function CheckboxRequiredValidator_HostBindings(rf, ctx) {
          if (rf & 2) {
            \u0275\u0275attribute("required", ctx._enabled ? "" : null);
          }
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([CHECKBOX_REQUIRED_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxRequiredValidator, [{
        type: Directive,
        args: [{
          selector: "input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]",
          providers: [CHECKBOX_REQUIRED_VALIDATOR],
          host: {
            "[attr.required]": '_enabled ? "" : null'
          },
          standalone: false
        }]
      }], null, null);
    })();
    EMAIL_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => EmailValidator),
      multi: true
    };
    EmailValidator = class _EmailValidator extends AbstractValidatorDirective {
      /**
       * @description
       * Tracks changes to the email attribute bound to this directive.
       */
      email;
      /** @internal */
      inputName = "email";
      /** @internal */
      normalizeInput = booleanAttribute;
      /** @internal */
      createValidator = (input2) => emailValidator;
      /** @docs-private */
      enabled(input2) {
        return input2;
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275EmailValidator_BaseFactory;
        return function EmailValidator_Factory(__ngFactoryType__) {
          return (\u0275EmailValidator_BaseFactory || (\u0275EmailValidator_BaseFactory = \u0275\u0275getInheritedFactory(_EmailValidator)))(__ngFactoryType__ || _EmailValidator);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _EmailValidator,
        selectors: [["", "email", "", "formControlName", ""], ["", "email", "", "formControl", ""], ["", "email", "", "ngModel", ""]],
        inputs: {
          email: "email"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([EMAIL_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EmailValidator, [{
        type: Directive,
        args: [{
          selector: "[email][formControlName],[email][formControl],[email][ngModel]",
          providers: [EMAIL_VALIDATOR],
          standalone: false
        }]
      }], null, {
        email: [{
          type: Input
        }]
      });
    })();
    MIN_LENGTH_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => MinLengthValidator),
      multi: true
    };
    MinLengthValidator = class _MinLengthValidator extends AbstractValidatorDirective {
      /**
       * @description
       * Tracks changes to the minimum length bound to this directive.
       */
      minlength;
      /** @internal */
      inputName = "minlength";
      /** @internal */
      normalizeInput = (input2) => toInteger(input2);
      /** @internal */
      createValidator = (minlength) => minLengthValidator(minlength);
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275MinLengthValidator_BaseFactory;
        return function MinLengthValidator_Factory(__ngFactoryType__) {
          return (\u0275MinLengthValidator_BaseFactory || (\u0275MinLengthValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MinLengthValidator)))(__ngFactoryType__ || _MinLengthValidator);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _MinLengthValidator,
        selectors: [["", "minlength", "", "formControlName", ""], ["", "minlength", "", "formControl", ""], ["", "minlength", "", "ngModel", ""]],
        hostVars: 1,
        hostBindings: function MinLengthValidator_HostBindings(rf, ctx) {
          if (rf & 2) {
            \u0275\u0275attribute("minlength", ctx._enabled ? ctx.minlength : null);
          }
        },
        inputs: {
          minlength: "minlength"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([MIN_LENGTH_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinLengthValidator, [{
        type: Directive,
        args: [{
          selector: "[minlength][formControlName],[minlength][formControl],[minlength][ngModel]",
          providers: [MIN_LENGTH_VALIDATOR],
          host: {
            "[attr.minlength]": "_enabled ? minlength : null"
          },
          standalone: false
        }]
      }], null, {
        minlength: [{
          type: Input
        }]
      });
    })();
    MAX_LENGTH_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => MaxLengthValidator),
      multi: true
    };
    MaxLengthValidator = class _MaxLengthValidator extends AbstractValidatorDirective {
      /**
       * @description
       * Tracks changes to the maximum length bound to this directive.
       */
      maxlength;
      /** @internal */
      inputName = "maxlength";
      /** @internal */
      normalizeInput = (input2) => toInteger(input2);
      /** @internal */
      createValidator = (maxlength) => maxLengthValidator(maxlength);
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275MaxLengthValidator_BaseFactory;
        return function MaxLengthValidator_Factory(__ngFactoryType__) {
          return (\u0275MaxLengthValidator_BaseFactory || (\u0275MaxLengthValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MaxLengthValidator)))(__ngFactoryType__ || _MaxLengthValidator);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _MaxLengthValidator,
        selectors: [["", "maxlength", "", "formControlName", ""], ["", "maxlength", "", "formControl", ""], ["", "maxlength", "", "ngModel", ""]],
        hostVars: 1,
        hostBindings: function MaxLengthValidator_HostBindings(rf, ctx) {
          if (rf & 2) {
            \u0275\u0275attribute("maxlength", ctx._enabled ? ctx.maxlength : null);
          }
        },
        inputs: {
          maxlength: "maxlength"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([MAX_LENGTH_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxLengthValidator, [{
        type: Directive,
        args: [{
          selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]",
          providers: [MAX_LENGTH_VALIDATOR],
          host: {
            "[attr.maxlength]": "_enabled ? maxlength : null"
          },
          standalone: false
        }]
      }], null, {
        maxlength: [{
          type: Input
        }]
      });
    })();
    PATTERN_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => PatternValidator),
      multi: true
    };
    PatternValidator = class _PatternValidator extends AbstractValidatorDirective {
      /**
       * @description
       * Tracks changes to the pattern bound to this directive.
       */
      pattern;
      // This input is always defined, since the name matches selector.
      /** @internal */
      inputName = "pattern";
      /** @internal */
      normalizeInput = (input2) => input2;
      /** @internal */
      createValidator = (input2) => patternValidator(input2);
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275PatternValidator_BaseFactory;
        return function PatternValidator_Factory(__ngFactoryType__) {
          return (\u0275PatternValidator_BaseFactory || (\u0275PatternValidator_BaseFactory = \u0275\u0275getInheritedFactory(_PatternValidator)))(__ngFactoryType__ || _PatternValidator);
        };
      })();
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _PatternValidator,
        selectors: [["", "pattern", "", "formControlName", ""], ["", "pattern", "", "formControl", ""], ["", "pattern", "", "ngModel", ""]],
        hostVars: 1,
        hostBindings: function PatternValidator_HostBindings(rf, ctx) {
          if (rf & 2) {
            \u0275\u0275attribute("pattern", ctx._enabled ? ctx.pattern : null);
          }
        },
        inputs: {
          pattern: "pattern"
        },
        standalone: false,
        features: [\u0275\u0275ProvidersFeature([PATTERN_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PatternValidator, [{
        type: Directive,
        args: [{
          selector: "[pattern][formControlName],[pattern][formControl],[pattern][ngModel]",
          providers: [PATTERN_VALIDATOR],
          host: {
            "[attr.pattern]": "_enabled ? pattern : null"
          },
          standalone: false
        }]
      }], null, {
        pattern: [{
          type: Input
        }]
      });
    })();
    SHARED_FORM_DIRECTIVES = [\u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator];
    TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
    REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
    \u0275InternalFormsSharedModule = class _\u0275InternalFormsSharedModule {
      static \u0275fac = function \u0275InternalFormsSharedModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _\u0275InternalFormsSharedModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _\u0275InternalFormsSharedModule,
        declarations: [\u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator],
        exports: [\u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator]
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275InternalFormsSharedModule, [{
        type: NgModule,
        args: [{
          declarations: SHARED_FORM_DIRECTIVES,
          exports: SHARED_FORM_DIRECTIVES
        }]
      }], null, null);
    })();
    FormArray = class extends AbstractControl {
      /**
       * Creates a new `FormArray` instance.
       *
       * @param controls An array of child controls. Each child control is given an index
       * where it is registered.
       *
       * @param validatorOrOpts A synchronous validator function, or an array of
       * such functions, or an `AbstractControlOptions` object that contains validation functions
       * and a validation trigger.
       *
       * @param asyncValidator A single async validator or array of async validator functions
       *
       */
      constructor(controls, validatorOrOpts, asyncValidator) {
        super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
        this.controls = controls;
        this._initObservables();
        this._setUpdateStrategy(validatorOrOpts);
        this._setUpControls();
        this.updateValueAndValidity({
          onlySelf: true,
          // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
          // `VALID` or `INVALID`.
          // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`
          // to `true` to allow that during the control creation process.
          emitEvent: !!this.asyncValidator
        });
      }
      controls;
      /**
       * Get the `AbstractControl` at the given `index` in the array.
       *
       * @param index Index in the array to retrieve the control. If `index` is negative, it will wrap
       *     around from the back, and if index is greatly negative (less than `-length`), the result is
       * undefined. This behavior is the same as `Array.at(index)`.
       */
      at(index) {
        return this.controls[this._adjustIndex(index)];
      }
      /**
       * Insert a new `AbstractControl` at the end of the array.
       *
       * @param control Form control to be inserted
       * @param options Specifies whether this FormArray instance should emit events after a new
       *     control is added.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges` observables emit events with the latest status and value when the control is
       * inserted. When false, no events are emitted.
       */
      push(control, options = {}) {
        this.controls.push(control);
        this._registerControl(control);
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
        this._onCollectionChange();
      }
      /**
       * Insert a new `AbstractControl` at the given `index` in the array.
       *
       * @param index Index in the array to insert the control. If `index` is negative, wraps around
       *     from the back. If `index` is greatly negative (less than `-length`), prepends to the array.
       * This behavior is the same as `Array.splice(index, 0, control)`.
       * @param control Form control to be inserted
       * @param options Specifies whether this FormArray instance should emit events after a new
       *     control is inserted.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges` observables emit events with the latest status and value when the control is
       * inserted. When false, no events are emitted.
       */
      insert(index, control, options = {}) {
        this.controls.splice(index, 0, control);
        this._registerControl(control);
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
      }
      /**
       * Remove the control at the given `index` in the array.
       *
       * @param index Index in the array to remove the control.  If `index` is negative, wraps around
       *     from the back. If `index` is greatly negative (less than `-length`), removes the first
       *     element. This behavior is the same as `Array.splice(index, 1)`.
       * @param options Specifies whether this FormArray instance should emit events after a
       *     control is removed.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges` observables emit events with the latest status and value when the control is
       * removed. When false, no events are emitted.
       */
      removeAt(index, options = {}) {
        let adjustedIndex = this._adjustIndex(index);
        if (adjustedIndex < 0) adjustedIndex = 0;
        if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {
        });
        this.controls.splice(adjustedIndex, 1);
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
      }
      /**
       * Replace an existing control.
       *
       * @param index Index in the array to replace the control. If `index` is negative, wraps around
       *     from the back. If `index` is greatly negative (less than `-length`), replaces the first
       *     element. This behavior is the same as `Array.splice(index, 1, control)`.
       * @param control The `AbstractControl` control to replace the existing control
       * @param options Specifies whether this FormArray instance should emit events after an
       *     existing control is replaced with a new one.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges` observables emit events with the latest status and value when the control is
       * replaced with a new one. When false, no events are emitted.
       */
      setControl(index, control, options = {}) {
        let adjustedIndex = this._adjustIndex(index);
        if (adjustedIndex < 0) adjustedIndex = 0;
        if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {
        });
        this.controls.splice(adjustedIndex, 1);
        if (control) {
          this.controls.splice(adjustedIndex, 0, control);
          this._registerControl(control);
        }
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
        this._onCollectionChange();
      }
      /**
       * Length of the control array.
       */
      get length() {
        return this.controls.length;
      }
      /**
       * Sets the value of the `FormArray`. It accepts an array that matches
       * the structure of the control.
       *
       * This method performs strict checks, and throws an error if you try
       * to set the value of a control that doesn't exist or if you exclude the
       * value of a control.
       *
       * @usageNotes
       * ### Set the values for the controls in the form array
       *
       * ```ts
       * const arr = new FormArray([
       *   new FormControl(),
       *   new FormControl()
       * ]);
       * console.log(arr.value);   // [null, null]
       *
       * arr.setValue(['Nancy', 'Drew']);
       * console.log(arr.value);   // ['Nancy', 'Drew']
       * ```
       *
       * @param value Array of values for the controls
       * @param options Configure options that determine how the control propagates changes and
       * emits events after the value changes
       *
       * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
       * is false.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges`
       * observables emit events with the latest status and value when the control value is updated.
       * When false, no events are emitted.
       * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
       * updateValueAndValidity} method.
       */
      setValue(value, options = {}) {
        assertAllValuesPresent(this, false, value);
        value.forEach((newValue, index) => {
          assertControlPresent(this, false, index);
          this.at(index).setValue(newValue, {
            onlySelf: true,
            emitEvent: options.emitEvent
          });
        });
        this.updateValueAndValidity(options);
      }
      /**
       * Patches the value of the `FormArray`. It accepts an array that matches the
       * structure of the control, and does its best to match the values to the correct
       * controls in the group.
       *
       * It accepts both super-sets and sub-sets of the array without throwing an error.
       *
       * @usageNotes
       * ### Patch the values for controls in a form array
       *
       * ```ts
       * const arr = new FormArray([
       *    new FormControl(),
       *    new FormControl()
       * ]);
       * console.log(arr.value);   // [null, null]
       *
       * arr.patchValue(['Nancy']);
       * console.log(arr.value);   // ['Nancy', null]
       * ```
       *
       * @param value Array of latest values for the controls
       * @param options Configure options that determine how the control propagates changes and
       * emits events after the value changes
       *
       * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
       * is false.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges` observables emit events with the latest status and value when the control
       * value is updated. When false, no events are emitted. The configuration options are passed to
       * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
       */
      patchValue(value, options = {}) {
        if (value == null) return;
        value.forEach((newValue, index) => {
          if (this.at(index)) {
            this.at(index).patchValue(newValue, {
              onlySelf: true,
              emitEvent: options.emitEvent
            });
          }
        });
        this.updateValueAndValidity(options);
      }
      /**
       * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the
       * value of all descendants to null or null maps.
       *
       * You reset to a specific form state by passing in an array of states
       * that matches the structure of the control. The state is a standalone value
       * or a form state object with both a value and a disabled status.
       *
       * @usageNotes
       * ### Reset the values in a form array
       *
       * ```ts
       * const arr = new FormArray([
       *    new FormControl(),
       *    new FormControl()
       * ]);
       * arr.reset(['name', 'last name']);
       *
       * console.log(arr.value);  // ['name', 'last name']
       * ```
       *
       * ### Reset the values in a form array and the disabled status for the first control
       *
       * ```ts
       * arr.reset([
       *   {value: 'name', disabled: true},
       *   'last'
       * ]);
       *
       * console.log(arr.value);  // ['last']
       * console.log(arr.at(0).status);  // 'DISABLED'
       * ```
       *
       * @param value Array of values for the controls
       * @param options Configure options that determine how the control propagates changes and
       * emits events after the value changes
       *
       * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
       * is false.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges`
       * observables emit events with the latest status and value when the control is reset.
       * When false, no events are emitted.
       * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
       * updateValueAndValidity} method.
       */
      reset(value = [], options = {}) {
        this._forEachChild((control, index) => {
          control.reset(value[index], {
            onlySelf: true,
            emitEvent: options.emitEvent
          });
        });
        this._updatePristine(options, this);
        this._updateTouched(options, this);
        this.updateValueAndValidity(options);
      }
      /**
       * The aggregate value of the array, including any disabled controls.
       *
       * Reports all values regardless of disabled status.
       */
      getRawValue() {
        return this.controls.map((control) => control.getRawValue());
      }
      /**
       * Remove all controls in the `FormArray`.
       *
       * @param options Specifies whether this FormArray instance should emit events after all
       *     controls are removed.
       * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
       * `valueChanges` observables emit events with the latest status and value when all controls
       * in this FormArray instance are removed. When false, no events are emitted.
       *
       * @usageNotes
       * ### Remove all elements from a FormArray
       *
       * ```ts
       * const arr = new FormArray([
       *    new FormControl(),
       *    new FormControl()
       * ]);
       * console.log(arr.length);  // 2
       *
       * arr.clear();
       * console.log(arr.length);  // 0
       * ```
       *
       * It's a simpler and more efficient alternative to removing all elements one by one:
       *
       * ```ts
       * const arr = new FormArray([
       *    new FormControl(),
       *    new FormControl()
       * ]);
       *
       * while (arr.length) {
       *    arr.removeAt(0);
       * }
       * ```
       */
      clear(options = {}) {
        if (this.controls.length < 1) return;
        this._forEachChild((control) => control._registerOnCollectionChange(() => {
        }));
        this.controls.splice(0);
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
      }
      /**
       * Adjusts a negative index by summing it with the length of the array. For very negative
       * indices, the result may remain negative.
       * @internal
       */
      _adjustIndex(index) {
        return index < 0 ? index + this.length : index;
      }
      /** @internal */
      _syncPendingControls() {
        let subtreeUpdated = this.controls.reduce((updated, child) => {
          return child._syncPendingControls() ? true : updated;
        }, false);
        if (subtreeUpdated) this.updateValueAndValidity({
          onlySelf: true
        });
        return subtreeUpdated;
      }
      /** @internal */
      _forEachChild(cb) {
        this.controls.forEach((control, index) => {
          cb(control, index);
        });
      }
      /** @internal */
      _updateValue() {
        this.value = this.controls.filter((control) => control.enabled || this.disabled).map((control) => control.value);
      }
      /** @internal */
      _anyControls(condition) {
        return this.controls.some((control) => control.enabled && condition(control));
      }
      /** @internal */
      _setUpControls() {
        this._forEachChild((control) => this._registerControl(control));
      }
      /** @internal */
      _allControlsDisabled() {
        for (const control of this.controls) {
          if (control.enabled) return false;
        }
        return this.controls.length > 0 || this.disabled;
      }
      _registerControl(control) {
        control.setParent(this);
        control._registerOnCollectionChange(this._onCollectionChange);
      }
      /** @internal */
      _find(name2) {
        return this.at(name2) ?? null;
      }
    };
    FormBuilder = class _FormBuilder {
      useNonNullable = false;
      /**
       * @description
       * Returns a FormBuilder in which automatically constructed `FormControl` elements
       * have `{nonNullable: true}` and are non-nullable.
       *
       * **Constructing non-nullable controls**
       *
       * When constructing a control, it will be non-nullable, and will reset to its initial value.
       *
       * ```ts
       * let nnfb = new FormBuilder().nonNullable;
       * let name = nnfb.control('Alex'); // FormControl<string>
       * name.reset();
       * console.log(name); // 'Alex'
       * ```
       *
       * **Constructing non-nullable groups or arrays**
       *
       * When constructing a group or array, all automatically created inner controls will be
       * non-nullable, and will reset to their initial values.
       *
       * ```ts
       * let nnfb = new FormBuilder().nonNullable;
       * let name = nnfb.group({who: 'Alex'}); // FormGroup<{who: FormControl<string>}>
       * name.reset();
       * console.log(name); // {who: 'Alex'}
       * ```
       * **Constructing *nullable* fields on groups or arrays**
       *
       * It is still possible to have a nullable field. In particular, any `FormControl` which is
       * *already* constructed will not be altered. For example:
       *
       * ```ts
       * let nnfb = new FormBuilder().nonNullable;
       * // FormGroup<{who: FormControl<string|null>}>
       * let name = nnfb.group({who: new FormControl('Alex')});
       * name.reset(); console.log(name); // {who: null}
       * ```
       *
       * Because the inner control is constructed explicitly by the caller, the builder has
       * no control over how it is created, and cannot exclude the `null`.
       */
      get nonNullable() {
        const nnfb = new _FormBuilder();
        nnfb.useNonNullable = true;
        return nnfb;
      }
      group(controls, options = null) {
        const reducedControls = this._reduceControls(controls);
        let newOptions = {};
        if (isAbstractControlOptions(options)) {
          newOptions = options;
        } else if (options !== null) {
          newOptions.validators = options.validator;
          newOptions.asyncValidators = options.asyncValidator;
        }
        return new FormGroup(reducedControls, newOptions);
      }
      /**
       * @description
       * Constructs a new `FormRecord` instance. Accepts a single generic argument, which is an object
       * containing all the keys and corresponding inner control types.
       *
       * @param controls A collection of child controls. The key for each child is the name
       * under which it is registered.
       *
       * @param options Configuration options object for the `FormRecord`. The object should have the
       * `AbstractControlOptions` type and might contain the following fields:
       * * `validators`: A synchronous validator function, or an array of validator functions.
       * * `asyncValidators`: A single async validator or array of async validator functions.
       * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur'
       * | submit').
       */
      record(controls, options = null) {
        const reducedControls = this._reduceControls(controls);
        return new FormRecord(reducedControls, options);
      }
      /**
       * @description
       * Constructs a new `FormControl` with the given state, validators and options. Sets
       * `{nonNullable: true}` in the options to get a non-nullable control. Otherwise, the
       * control will be nullable. Accepts a single generic argument, which is the type  of the
       * control's value.
       *
       * @param formState Initializes the control with an initial state value, or
       * with an object that contains both a value and a disabled status.
       *
       * @param validatorOrOpts A synchronous validator function, or an array of
       * such functions, or a `FormControlOptions` object that contains
       * validation functions and a validation trigger.
       *
       * @param asyncValidator A single async validator or array of async validator
       * functions.
       *
       * @usageNotes
       *
       * ### Initialize a control as disabled
       *
       * The following example returns a control with an initial value in a disabled state.
       *
       * {@example forms/ts/formBuilder/form_builder_example.ts region='disabled-control'}
       */
      control(formState, validatorOrOpts, asyncValidator) {
        let newOptions = {};
        if (!this.useNonNullable) {
          return new FormControl(formState, validatorOrOpts, asyncValidator);
        }
        if (isAbstractControlOptions(validatorOrOpts)) {
          newOptions = validatorOrOpts;
        } else {
          newOptions.validators = validatorOrOpts;
          newOptions.asyncValidators = asyncValidator;
        }
        return new FormControl(formState, __spreadProps(__spreadValues({}, newOptions), {
          nonNullable: true
        }));
      }
      /**
       * Constructs a new `FormArray` from the given array of configurations,
       * validators and options. Accepts a single generic argument, which is the type of each control
       * inside the array.
       *
       * @param controls An array of child controls or control configs. Each child control is given an
       *     index when it is registered.
       *
       * @param validatorOrOpts A synchronous validator function, or an array of such functions, or an
       *     `AbstractControlOptions` object that contains
       * validation functions and a validation trigger.
       *
       * @param asyncValidator A single async validator or array of async validator functions.
       */
      array(controls, validatorOrOpts, asyncValidator) {
        const createdControls = controls.map((c) => this._createControl(c));
        return new FormArray(createdControls, validatorOrOpts, asyncValidator);
      }
      /** @internal */
      _reduceControls(controls) {
        const createdControls = {};
        Object.keys(controls).forEach((controlName) => {
          createdControls[controlName] = this._createControl(controls[controlName]);
        });
        return createdControls;
      }
      /** @internal */
      _createControl(controls) {
        if (controls instanceof FormControl) {
          return controls;
        } else if (controls instanceof AbstractControl) {
          return controls;
        } else if (Array.isArray(controls)) {
          const value = controls[0];
          const validator = controls.length > 1 ? controls[1] : null;
          const asyncValidator = controls.length > 2 ? controls[2] : null;
          return this.control(value, validator, asyncValidator);
        } else {
          return this.control(controls);
        }
      }
      static \u0275fac = function FormBuilder_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _FormBuilder)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _FormBuilder,
        factory: _FormBuilder.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormBuilder, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    NonNullableFormBuilder = class _NonNullableFormBuilder {
      static \u0275fac = function NonNullableFormBuilder_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NonNullableFormBuilder)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _NonNullableFormBuilder,
        factory: () => (() => inject2(FormBuilder).nonNullable)(),
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NonNullableFormBuilder, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: () => inject2(FormBuilder).nonNullable
        }]
      }], null, null);
    })();
    UntypedFormBuilder = class _UntypedFormBuilder extends FormBuilder {
      group(controlsConfig, options = null) {
        return super.group(controlsConfig, options);
      }
      /**
       * Like `FormBuilder#control`, except the resulting control is untyped.
       */
      control(formState, validatorOrOpts, asyncValidator) {
        return super.control(formState, validatorOrOpts, asyncValidator);
      }
      /**
       * Like `FormBuilder#array`, except the resulting array is untyped.
       */
      array(controlsConfig, validatorOrOpts, asyncValidator) {
        return super.array(controlsConfig, validatorOrOpts, asyncValidator);
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let \u0275UntypedFormBuilder_BaseFactory;
        return function UntypedFormBuilder_Factory(__ngFactoryType__) {
          return (\u0275UntypedFormBuilder_BaseFactory || (\u0275UntypedFormBuilder_BaseFactory = \u0275\u0275getInheritedFactory(_UntypedFormBuilder)))(__ngFactoryType__ || _UntypedFormBuilder);
        };
      })();
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _UntypedFormBuilder,
        factory: _UntypedFormBuilder.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UntypedFormBuilder, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    VERSION5 = new Version("20.1.7");
    FormsModule = class _FormsModule {
      /**
       * @description
       * Provides options for configuring the forms module.
       *
       * @param opts An object of configuration options
       * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
       * correct, or to only call it `whenDisabled`, which is the legacy behavior.
       */
      static withConfig(opts) {
        return {
          ngModule: _FormsModule,
          providers: [{
            provide: CALL_SET_DISABLED_STATE,
            useValue: opts.callSetDisabledState ?? setDisabledStateDefault
          }]
        };
      }
      static \u0275fac = function FormsModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _FormsModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _FormsModule,
        declarations: [NgModel, NgModelGroup, NgForm],
        exports: [\u0275InternalFormsSharedModule, NgModel, NgModelGroup, NgForm]
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
        imports: [\u0275InternalFormsSharedModule]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormsModule, [{
        type: NgModule,
        args: [{
          declarations: TEMPLATE_DRIVEN_DIRECTIVES,
          exports: [\u0275InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
        }]
      }], null, null);
    })();
    ReactiveFormsModule = class _ReactiveFormsModule {
      /**
       * @description
       * Provides options for configuring the reactive forms module.
       *
       * @param opts An object of configuration options
       * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`
       * binding is used with reactive form directives.
       * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
       * correct, or to only call it `whenDisabled`, which is the legacy behavior.
       */
      static withConfig(opts) {
        return {
          ngModule: _ReactiveFormsModule,
          providers: [{
            provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,
            useValue: opts.warnOnNgModelWithFormControl ?? "always"
          }, {
            provide: CALL_SET_DISABLED_STATE,
            useValue: opts.callSetDisabledState ?? setDisabledStateDefault
          }]
        };
      }
      static \u0275fac = function ReactiveFormsModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ReactiveFormsModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _ReactiveFormsModule,
        declarations: [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName],
        exports: [\u0275InternalFormsSharedModule, FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName]
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
        imports: [\u0275InternalFormsSharedModule]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReactiveFormsModule, [{
        type: NgModule,
        args: [{
          declarations: [REACTIVE_DRIVEN_DIRECTIVES],
          exports: [\u0275InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
        }]
      }], null, null);
    })();
  }
});

// src/app/dashboard/signaling.service.ts
var SignalingService;
var init_signaling_service = __esm({
  "src/app/dashboard/signaling.service.ts"() {
    "use strict";
    init_core();
    init_esm();
    init_core();
    SignalingService = class _SignalingService {
      ws = null;
      messagesSubject = new Subject();
      messages$ = this.messagesSubject.asObservable();
      room;
      buildUrl(room) {
        const override = window.__SIGNALING_URL__;
        if (override) {
          return `${override.replace(/\/$/, "")}/${encodeURIComponent(room)}/`;
        }
        const scheme = location.protocol === "https:" ? "wss" : "ws";
        return `${scheme}://${location.host}/ws/signaling/${encodeURIComponent(room)}/`;
      }
      connect(room) {
        this.room = room;
        const url = this.buildUrl(room);
        console.log("[SignalingService] connecting \u2192", url);
        this.ws = new WebSocket(url);
        this.ws.onopen = () => {
          console.log("[SignalingService] \u2705 WebSocket connected");
        };
        this.ws.onmessage = (ev) => {
          try {
            const data2 = JSON.parse(ev.data);
            this.messagesSubject.next(data2);
          } catch (err) {
            console.error("[SignalingService] JSON parse error", err, ev.data);
          }
        };
        this.ws.onclose = () => {
          console.warn("[SignalingService] WebSocket closed, attempting reconnect\u2026");
          setTimeout(() => this.reconnect(), 1e3);
        };
        this.ws.onerror = (err) => {
          console.error("[SignalingService] WebSocket error", err);
          this.ws?.close();
        };
      }
      reconnect() {
        if (this.room)
          this.connect(this.room);
      }
      getSocket() {
        return this.ws;
      }
      disconnect() {
        this.ws?.close();
        this.ws = null;
      }
      sendMessage(msg) {
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
          console.warn("[SignalingService] sendMessage failed, socket not open", "readyState:", this.ws?.readyState);
          return;
        }
        try {
          this.ws.send(JSON.stringify(msg));
        } catch (err) {
          console.error("[SignalingService] sendMessage error", err, msg);
        }
      }
      static \u0275fac = function SignalingService_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _SignalingService)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _SignalingService, factory: _SignalingService.\u0275fac, providedIn: "root" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SignalingService, [{
        type: Injectable,
        args: [{ providedIn: "root" }]
      }], null, null);
    })();
  }
});

// src/app/dashboard/src-object.directive.ts
var SrcObjectDirective;
var init_src_object_directive = __esm({
  "src/app/dashboard/src-object.directive.ts"() {
    "use strict";
    init_core();
    init_core();
    SrcObjectDirective = class _SrcObjectDirective {
      el;
      srcObject;
      constructor(el) {
        this.el = el;
      }
      ngOnChanges(changes) {
        if ("srcObject" in changes) {
          const element = this.el.nativeElement;
          if (this.srcObject instanceof MediaStream) {
            element.srcObject = this.srcObject;
          } else {
            element.srcObject = null;
          }
        }
      }
      static \u0275fac = function SrcObjectDirective_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _SrcObjectDirective)(\u0275\u0275directiveInject(ElementRef));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({ type: _SrcObjectDirective, selectors: [["", "appSrcObject", ""]], inputs: { srcObject: [0, "appSrcObject", "srcObject"] }, features: [\u0275\u0275NgOnChangesFeature] });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SrcObjectDirective, [{
        type: Directive,
        args: [{
          selector: "[appSrcObject]",
          standalone: true
        }]
      }], () => [{ type: ElementRef }], { srcObject: [{
        type: Input,
        args: ["appSrcObject"]
      }] });
    })();
  }
});

// node_modules/@angular/cdk/fesm2022/shadow-dom.mjs
function _supportsShadowDom() {
  if (shadowDomIsSupported == null) {
    const head = typeof document !== "undefined" ? document.head : null;
    shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));
  }
  return shadowDomIsSupported;
}
function _getShadowRoot(element) {
  if (_supportsShadowDom()) {
    const rootNode = element.getRootNode ? element.getRootNode() : null;
    if (typeof ShadowRoot !== "undefined" && ShadowRoot && rootNode instanceof ShadowRoot) {
      return rootNode;
    }
  }
  return null;
}
function _getEventTarget(event) {
  return event.composedPath ? event.composedPath()[0] : event.target;
}
var shadowDomIsSupported;
var init_shadow_dom = __esm({
  "node_modules/@angular/cdk/fesm2022/shadow-dom.mjs"() {
    "use strict";
  }
});

// node_modules/@angular/cdk/fesm2022/fake-event-detection.mjs
function isFakeMousedownFromScreenReader(event) {
  return event.buttons === 0 || event.detail === 0;
}
function isFakeTouchstartFromScreenReader(event) {
  const touch = event.touches && event.touches[0] || event.changedTouches && event.changedTouches[0];
  return !!touch && touch.identifier === -1 && (touch.radiusX == null || touch.radiusX === 1) && (touch.radiusY == null || touch.radiusY === 1);
}
var init_fake_event_detection = __esm({
  "node_modules/@angular/cdk/fesm2022/fake-event-detection.mjs"() {
    "use strict";
  }
});

// node_modules/@angular/cdk/fesm2022/element.mjs
function coerceNumberProperty(value, fallbackValue = 0) {
  if (_isNumberValue(value)) {
    return Number(value);
  }
  return arguments.length === 2 ? fallbackValue : 0;
}
function _isNumberValue(value) {
  return !isNaN(parseFloat(value)) && !isNaN(Number(value));
}
function coerceElement(elementOrRef) {
  return elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;
}
var init_element = __esm({
  "node_modules/@angular/cdk/fesm2022/element.mjs"() {
    "use strict";
    init_core();
  }
});

// node_modules/@angular/cdk/fesm2022/style-loader.mjs
var appsWithLoaders, _CdkPrivateStyleLoader;
var init_style_loader = __esm({
  "node_modules/@angular/cdk/fesm2022/style-loader.mjs"() {
    "use strict";
    init_core();
    init_core();
    appsWithLoaders = /* @__PURE__ */ new WeakMap();
    _CdkPrivateStyleLoader = class __CdkPrivateStyleLoader {
      _appRef;
      _injector = inject2(Injector);
      _environmentInjector = inject2(EnvironmentInjector);
      /**
       * Loads a set of styles.
       * @param loader Component which will be instantiated to load the styles.
       */
      load(loader) {
        const appRef = this._appRef = this._appRef || this._injector.get(ApplicationRef);
        let data2 = appsWithLoaders.get(appRef);
        if (!data2) {
          data2 = {
            loaders: /* @__PURE__ */ new Set(),
            refs: []
          };
          appsWithLoaders.set(appRef, data2);
          appRef.onDestroy(() => {
            appsWithLoaders.get(appRef)?.refs.forEach((ref) => ref.destroy());
            appsWithLoaders.delete(appRef);
          });
        }
        if (!data2.loaders.has(loader)) {
          data2.loaders.add(loader);
          data2.refs.push(createComponent(loader, {
            environmentInjector: this._environmentInjector
          }));
        }
      }
      static \u0275fac = function _CdkPrivateStyleLoader_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || __CdkPrivateStyleLoader)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: __CdkPrivateStyleLoader,
        factory: __CdkPrivateStyleLoader.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_CdkPrivateStyleLoader, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
  }
});

// node_modules/@angular/cdk/fesm2022/platform2.mjs
var hasV8BreakIterator, Platform;
var init_platform2 = __esm({
  "node_modules/@angular/cdk/fesm2022/platform2.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_common();
    try {
      hasV8BreakIterator = typeof Intl !== "undefined" && Intl.v8BreakIterator;
    } catch {
      hasV8BreakIterator = false;
    }
    Platform = class _Platform {
      _platformId = inject2(PLATFORM_ID);
      // We want to use the Angular platform check because if the Document is shimmed
      // without the navigator, the following checks will fail. This is preferred because
      // sometimes the Document may be shimmed without the user's knowledge or intention
      /** Whether the Angular application is being rendered in the browser. */
      isBrowser = this._platformId ? isPlatformBrowser(this._platformId) : typeof document === "object" && !!document;
      /** Whether the current browser is Microsoft Edge. */
      EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);
      /** Whether the current rendering engine is Microsoft Trident. */
      TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);
      // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.
      /** Whether the current rendering engine is Blink. */
      BLINK = this.isBrowser && !!(window.chrome || hasV8BreakIterator) && typeof CSS !== "undefined" && !this.EDGE && !this.TRIDENT;
      // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to
      // ensure that Webkit runs standalone and is not used as another engine's base.
      /** Whether the current rendering engine is WebKit. */
      WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;
      /** Whether the current platform is Apple iOS. */
      IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window);
      // It's difficult to detect the plain Gecko engine, because most of the browsers identify
      // them self as Gecko-like browsers and modify the userAgent's according to that.
      // Since we only cover one explicit Firefox case, we can simply check for Firefox
      // instead of having an unstable check for Gecko.
      /** Whether the current browser is Firefox. */
      FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);
      /** Whether the current platform is Android. */
      // Trident on mobile adds the android platform to the userAgent to trick detections.
      ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;
      // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake
      // this and just place the Safari keyword in the userAgent. To be more safe about Safari every
      // Safari browser should also use Webkit as its layout engine.
      /** Whether the current browser is Safari. */
      SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
      constructor() {
      }
      static \u0275fac = function Platform_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Platform)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _Platform,
        factory: _Platform.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Platform, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [], null);
    })();
  }
});

// node_modules/@angular/cdk/fesm2022/directionality.mjs
function DIR_DOCUMENT_FACTORY() {
  return inject2(DOCUMENT);
}
function _resolveDirectionality(rawValue) {
  const value = rawValue?.toLowerCase() || "";
  if (value === "auto" && typeof navigator !== "undefined" && navigator?.language) {
    return RTL_LOCALE_PATTERN.test(navigator.language) ? "rtl" : "ltr";
  }
  return value === "rtl" ? "rtl" : "ltr";
}
var DIR_DOCUMENT, RTL_LOCALE_PATTERN, Directionality;
var init_directionality = __esm({
  "node_modules/@angular/cdk/fesm2022/directionality.mjs"() {
    "use strict";
    init_core();
    init_core();
    DIR_DOCUMENT = new InjectionToken("cdk-dir-doc", {
      providedIn: "root",
      factory: DIR_DOCUMENT_FACTORY
    });
    RTL_LOCALE_PATTERN = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;
    Directionality = class _Directionality {
      /** The current 'ltr' or 'rtl' value. */
      get value() {
        return this.valueSignal();
      }
      /**
       * The current 'ltr' or 'rtl' value.
       */
      valueSignal = signal("ltr", ...ngDevMode ? [{
        debugName: "valueSignal"
      }] : []);
      /** Stream that emits whenever the 'ltr' / 'rtl' state changes. */
      change = new EventEmitter();
      constructor() {
        const _document2 = inject2(DIR_DOCUMENT, {
          optional: true
        });
        if (_document2) {
          const bodyDir = _document2.body ? _document2.body.dir : null;
          const htmlDir = _document2.documentElement ? _document2.documentElement.dir : null;
          this.valueSignal.set(_resolveDirectionality(bodyDir || htmlDir || "ltr"));
        }
      }
      ngOnDestroy() {
        this.change.complete();
      }
      static \u0275fac = function Directionality_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Directionality)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _Directionality,
        factory: _Directionality.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Directionality, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [], null);
    })();
  }
});

// node_modules/@angular/cdk/fesm2022/scrolling2.mjs
function supportsScrollBehavior() {
  if (scrollBehaviorSupported == null) {
    if (typeof document !== "object" || !document || typeof Element !== "function" || !Element) {
      scrollBehaviorSupported = false;
      return scrollBehaviorSupported;
    }
    if ("scrollBehavior" in document.documentElement.style) {
      scrollBehaviorSupported = true;
    } else {
      const scrollToFunction = Element.prototype.scrollTo;
      if (scrollToFunction) {
        scrollBehaviorSupported = !/\{\s*\[native code\]\s*\}/.test(scrollToFunction.toString());
      } else {
        scrollBehaviorSupported = false;
      }
    }
  }
  return scrollBehaviorSupported;
}
function getRtlScrollAxisType() {
  if (typeof document !== "object" || !document) {
    return RtlScrollAxisType.NORMAL;
  }
  if (rtlScrollAxisType == null) {
    const scrollContainer = document.createElement("div");
    const containerStyle = scrollContainer.style;
    scrollContainer.dir = "rtl";
    containerStyle.width = "1px";
    containerStyle.overflow = "auto";
    containerStyle.visibility = "hidden";
    containerStyle.pointerEvents = "none";
    containerStyle.position = "absolute";
    const content2 = document.createElement("div");
    const contentStyle = content2.style;
    contentStyle.width = "2px";
    contentStyle.height = "1px";
    scrollContainer.appendChild(content2);
    document.body.appendChild(scrollContainer);
    rtlScrollAxisType = RtlScrollAxisType.NORMAL;
    if (scrollContainer.scrollLeft === 0) {
      scrollContainer.scrollLeft = 1;
      rtlScrollAxisType = scrollContainer.scrollLeft === 0 ? RtlScrollAxisType.NEGATED : RtlScrollAxisType.INVERTED;
    }
    scrollContainer.remove();
  }
  return rtlScrollAxisType;
}
var RtlScrollAxisType, rtlScrollAxisType, scrollBehaviorSupported;
var init_scrolling2 = __esm({
  "node_modules/@angular/cdk/fesm2022/scrolling2.mjs"() {
    "use strict";
    (function(RtlScrollAxisType2) {
      RtlScrollAxisType2[RtlScrollAxisType2["NORMAL"] = 0] = "NORMAL";
      RtlScrollAxisType2[RtlScrollAxisType2["NEGATED"] = 1] = "NEGATED";
      RtlScrollAxisType2[RtlScrollAxisType2["INVERTED"] = 2] = "INVERTED";
    })(RtlScrollAxisType || (RtlScrollAxisType = {}));
  }
});

// node_modules/@angular/cdk/fesm2022/bidi.mjs
var Dir, BidiModule;
var init_bidi = __esm({
  "node_modules/@angular/cdk/fesm2022/bidi.mjs"() {
    "use strict";
    init_directionality();
    init_core();
    init_core();
    Dir = class _Dir {
      /** Whether the `value` has been set to its initial value. */
      _isInitialized = false;
      /** Direction as passed in by the consumer. */
      _rawDir;
      /** Event emitted when the direction changes. */
      change = new EventEmitter();
      /** @docs-private */
      get dir() {
        return this.valueSignal();
      }
      set dir(value) {
        const previousValue = this.valueSignal();
        this.valueSignal.set(_resolveDirectionality(value));
        this._rawDir = value;
        if (previousValue !== this.valueSignal() && this._isInitialized) {
          this.change.emit(this.valueSignal());
        }
      }
      /** Current layout direction of the element. */
      get value() {
        return this.dir;
      }
      valueSignal = signal("ltr", ...ngDevMode ? [{
        debugName: "valueSignal"
      }] : []);
      /** Initialize once default value has been set. */
      ngAfterContentInit() {
        this._isInitialized = true;
      }
      ngOnDestroy() {
        this.change.complete();
      }
      static \u0275fac = function Dir_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Dir)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _Dir,
        selectors: [["", "dir", ""]],
        hostVars: 1,
        hostBindings: function Dir_HostBindings(rf, ctx) {
          if (rf & 2) {
            \u0275\u0275attribute("dir", ctx._rawDir);
          }
        },
        inputs: {
          dir: "dir"
        },
        outputs: {
          change: "dirChange"
        },
        exportAs: ["dir"],
        features: [\u0275\u0275ProvidersFeature([{
          provide: Directionality,
          useExisting: _Dir
        }])]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Dir, [{
        type: Directive,
        args: [{
          selector: "[dir]",
          providers: [{
            provide: Directionality,
            useExisting: Dir
          }],
          host: {
            "[attr.dir]": "_rawDir"
          },
          exportAs: "dir"
        }]
      }], null, {
        change: [{
          type: Output,
          args: ["dirChange"]
        }],
        dir: [{
          type: Input
        }]
      });
    })();
    BidiModule = class _BidiModule {
      static \u0275fac = function BidiModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _BidiModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _BidiModule,
        imports: [Dir],
        exports: [Dir]
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BidiModule, [{
        type: NgModule,
        args: [{
          imports: [Dir],
          exports: [Dir]
        }]
      }], null, null);
    })();
  }
});

// node_modules/@angular/cdk/fesm2022/data-source.mjs
function isDataSource(value) {
  return value && typeof value.connect === "function" && !(value instanceof ConnectableObservable);
}
var DataSource;
var init_data_source = __esm({
  "node_modules/@angular/cdk/fesm2022/data-source.mjs"() {
    "use strict";
    init_esm();
    DataSource = class {
    };
  }
});

// node_modules/@angular/cdk/fesm2022/recycle-view-repeater-strategy.mjs
var ArrayDataSource, _ViewRepeaterOperation, _VIEW_REPEATER_STRATEGY, _RecycleViewRepeaterStrategy;
var init_recycle_view_repeater_strategy = __esm({
  "node_modules/@angular/cdk/fesm2022/recycle-view-repeater-strategy.mjs"() {
    "use strict";
    init_esm();
    init_data_source();
    init_core();
    ArrayDataSource = class extends DataSource {
      _data;
      constructor(_data) {
        super();
        this._data = _data;
      }
      connect() {
        return isObservable(this._data) ? this._data : of(this._data);
      }
      disconnect() {
      }
    };
    (function(_ViewRepeaterOperation2) {
      _ViewRepeaterOperation2[_ViewRepeaterOperation2["REPLACED"] = 0] = "REPLACED";
      _ViewRepeaterOperation2[_ViewRepeaterOperation2["INSERTED"] = 1] = "INSERTED";
      _ViewRepeaterOperation2[_ViewRepeaterOperation2["MOVED"] = 2] = "MOVED";
      _ViewRepeaterOperation2[_ViewRepeaterOperation2["REMOVED"] = 3] = "REMOVED";
    })(_ViewRepeaterOperation || (_ViewRepeaterOperation = {}));
    _VIEW_REPEATER_STRATEGY = new InjectionToken("_ViewRepeater");
    _RecycleViewRepeaterStrategy = class {
      /**
       * The size of the cache used to store unused views.
       * Setting the cache size to `0` will disable caching. Defaults to 20 views.
       */
      viewCacheSize = 20;
      /**
       * View cache that stores embedded view instances that have been previously stamped out,
       * but don't are not currently rendered. The view repeater will reuse these views rather than
       * creating brand new ones.
       *
       * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.
       */
      _viewCache = [];
      /** Apply changes to the DOM. */
      applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {
        changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {
          let view;
          let operation;
          if (record.previousIndex == null) {
            const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);
            view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));
            operation = view ? _ViewRepeaterOperation.INSERTED : _ViewRepeaterOperation.REPLACED;
          } else if (currentIndex == null) {
            this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);
            operation = _ViewRepeaterOperation.REMOVED;
          } else {
            view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));
            operation = _ViewRepeaterOperation.MOVED;
          }
          if (itemViewChanged) {
            itemViewChanged({
              context: view?.context,
              operation,
              record
            });
          }
        });
      }
      detach() {
        for (const view of this._viewCache) {
          view.destroy();
        }
        this._viewCache = [];
      }
      /**
       * Inserts a view for a new item, either from the cache or by creating a new
       * one. Returns `undefined` if the item was inserted into a cached view.
       */
      _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {
        const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);
        if (cachedView) {
          cachedView.context.$implicit = value;
          return void 0;
        }
        const viewArgs = viewArgsFactory();
        return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);
      }
      /** Detaches the view at the given index and inserts into the view cache. */
      _detachAndCacheView(index, viewContainerRef) {
        const detachedView = viewContainerRef.detach(index);
        this._maybeCacheView(detachedView, viewContainerRef);
      }
      /** Moves view at the previous index to the current index. */
      _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {
        const view = viewContainerRef.get(adjustedPreviousIndex);
        viewContainerRef.move(view, currentIndex);
        view.context.$implicit = value;
        return view;
      }
      /**
       * Cache the given detached view. If the cache is full, the view will be
       * destroyed.
       */
      _maybeCacheView(view, viewContainerRef) {
        if (this._viewCache.length < this.viewCacheSize) {
          this._viewCache.push(view);
        } else {
          const index = viewContainerRef.indexOf(view);
          if (index === -1) {
            view.destroy();
          } else {
            viewContainerRef.remove(index);
          }
        }
      }
      /** Inserts a recycled view from the cache at the given index. */
      _insertViewFromCache(index, viewContainerRef) {
        const cachedView = this._viewCache.pop();
        if (cachedView) {
          viewContainerRef.insert(cachedView, index);
        }
        return cachedView || null;
      }
    };
  }
});

// node_modules/@angular/cdk/fesm2022/scrolling.mjs
function _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {
  return fixedSizeDir._scrollStrategy;
}
function rangesEqual(r1, r2) {
  return r1.start == r2.start && r1.end == r2.end;
}
function getOffset(orientation, direction, node) {
  const el = node;
  if (!el.getBoundingClientRect) {
    return 0;
  }
  const rect = el.getBoundingClientRect();
  if (orientation === "horizontal") {
    return direction === "start" ? rect.left : rect.right;
  }
  return direction === "start" ? rect.top : rect.bottom;
}
var _c0, _c1, VIRTUAL_SCROLL_STRATEGY, FixedSizeVirtualScrollStrategy, CdkFixedSizeVirtualScroll, DEFAULT_SCROLL_TIME, ScrollDispatcher, CdkScrollable, DEFAULT_RESIZE_TIME, ViewportRuler, VIRTUAL_SCROLLABLE, CdkVirtualScrollable, SCROLL_SCHEDULER, CdkVirtualScrollViewport, CdkVirtualForOf, CdkVirtualScrollableElement, CdkVirtualScrollableWindow, CdkScrollableModule, ScrollingModule;
var init_scrolling = __esm({
  "node_modules/@angular/cdk/fesm2022/scrolling.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_esm();
    init_operators();
    init_element();
    init_platform2();
    init_directionality();
    init_scrolling2();
    init_bidi();
    init_recycle_view_repeater_strategy();
    init_data_source();
    _c0 = ["contentWrapper"];
    _c1 = ["*"];
    VIRTUAL_SCROLL_STRATEGY = new InjectionToken("VIRTUAL_SCROLL_STRATEGY");
    FixedSizeVirtualScrollStrategy = class {
      _scrolledIndexChange = new Subject();
      /** @docs-private Implemented as part of VirtualScrollStrategy. */
      scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());
      /** The attached viewport. */
      _viewport = null;
      /** The size of the items in the virtually scrolling list. */
      _itemSize;
      /** The minimum amount of buffer rendered beyond the viewport (in pixels). */
      _minBufferPx;
      /** The number of buffer items to render beyond the edge of the viewport (in pixels). */
      _maxBufferPx;
      /**
       * @param itemSize The size of the items in the virtually scrolling list.
       * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
       * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
       */
      constructor(itemSize, minBufferPx, maxBufferPx) {
        this._itemSize = itemSize;
        this._minBufferPx = minBufferPx;
        this._maxBufferPx = maxBufferPx;
      }
      /**
       * Attaches this scroll strategy to a viewport.
       * @param viewport The viewport to attach this strategy to.
       */
      attach(viewport) {
        this._viewport = viewport;
        this._updateTotalContentSize();
        this._updateRenderedRange();
      }
      /** Detaches this scroll strategy from the currently attached viewport. */
      detach() {
        this._scrolledIndexChange.complete();
        this._viewport = null;
      }
      /**
       * Update the item size and buffer size.
       * @param itemSize The size of the items in the virtually scrolling list.
       * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
       * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
       */
      updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {
        if (maxBufferPx < minBufferPx && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw Error("CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx");
        }
        this._itemSize = itemSize;
        this._minBufferPx = minBufferPx;
        this._maxBufferPx = maxBufferPx;
        this._updateTotalContentSize();
        this._updateRenderedRange();
      }
      /** @docs-private Implemented as part of VirtualScrollStrategy. */
      onContentScrolled() {
        this._updateRenderedRange();
      }
      /** @docs-private Implemented as part of VirtualScrollStrategy. */
      onDataLengthChanged() {
        this._updateTotalContentSize();
        this._updateRenderedRange();
      }
      /** @docs-private Implemented as part of VirtualScrollStrategy. */
      onContentRendered() {
      }
      /** @docs-private Implemented as part of VirtualScrollStrategy. */
      onRenderedOffsetChanged() {
      }
      /**
       * Scroll to the offset for the given index.
       * @param index The index of the element to scroll to.
       * @param behavior The ScrollBehavior to use when scrolling.
       */
      scrollToIndex(index, behavior) {
        if (this._viewport) {
          this._viewport.scrollToOffset(index * this._itemSize, behavior);
        }
      }
      /** Update the viewport's total content size. */
      _updateTotalContentSize() {
        if (!this._viewport) {
          return;
        }
        this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);
      }
      /** Update the viewport's rendered range. */
      _updateRenderedRange() {
        if (!this._viewport) {
          return;
        }
        const renderedRange = this._viewport.getRenderedRange();
        const newRange = {
          start: renderedRange.start,
          end: renderedRange.end
        };
        const viewportSize = this._viewport.getViewportSize();
        const dataLength = this._viewport.getDataLength();
        let scrollOffset = this._viewport.measureScrollOffset();
        let firstVisibleIndex = this._itemSize > 0 ? scrollOffset / this._itemSize : 0;
        if (newRange.end > dataLength) {
          const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);
          const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));
          if (firstVisibleIndex != newVisibleIndex) {
            firstVisibleIndex = newVisibleIndex;
            scrollOffset = newVisibleIndex * this._itemSize;
            newRange.start = Math.floor(firstVisibleIndex);
          }
          newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));
        }
        const startBuffer = scrollOffset - newRange.start * this._itemSize;
        if (startBuffer < this._minBufferPx && newRange.start != 0) {
          const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);
          newRange.start = Math.max(0, newRange.start - expandStart);
          newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));
        } else {
          const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);
          if (endBuffer < this._minBufferPx && newRange.end != dataLength) {
            const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);
            if (expandEnd > 0) {
              newRange.end = Math.min(dataLength, newRange.end + expandEnd);
              newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));
            }
          }
        }
        this._viewport.setRenderedRange(newRange);
        this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);
        this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));
      }
    };
    CdkFixedSizeVirtualScroll = class _CdkFixedSizeVirtualScroll {
      /** The size of the items in the list (in pixels). */
      get itemSize() {
        return this._itemSize;
      }
      set itemSize(value) {
        this._itemSize = coerceNumberProperty(value);
      }
      _itemSize = 20;
      /**
       * The minimum amount of buffer rendered beyond the viewport (in pixels).
       * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.
       */
      get minBufferPx() {
        return this._minBufferPx;
      }
      set minBufferPx(value) {
        this._minBufferPx = coerceNumberProperty(value);
      }
      _minBufferPx = 100;
      /**
       * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.
       */
      get maxBufferPx() {
        return this._maxBufferPx;
      }
      set maxBufferPx(value) {
        this._maxBufferPx = coerceNumberProperty(value);
      }
      _maxBufferPx = 200;
      /** The scroll strategy used by this directive. */
      _scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);
      ngOnChanges() {
        this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);
      }
      static \u0275fac = function CdkFixedSizeVirtualScroll_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkFixedSizeVirtualScroll)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkFixedSizeVirtualScroll,
        selectors: [["cdk-virtual-scroll-viewport", "itemSize", ""]],
        inputs: {
          itemSize: "itemSize",
          minBufferPx: "minBufferPx",
          maxBufferPx: "maxBufferPx"
        },
        features: [\u0275\u0275ProvidersFeature([{
          provide: VIRTUAL_SCROLL_STRATEGY,
          useFactory: _fixedSizeVirtualScrollStrategyFactory,
          deps: [forwardRef(() => _CdkFixedSizeVirtualScroll)]
        }]), \u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFixedSizeVirtualScroll, [{
        type: Directive,
        args: [{
          selector: "cdk-virtual-scroll-viewport[itemSize]",
          providers: [{
            provide: VIRTUAL_SCROLL_STRATEGY,
            useFactory: _fixedSizeVirtualScrollStrategyFactory,
            deps: [forwardRef(() => CdkFixedSizeVirtualScroll)]
          }]
        }]
      }], null, {
        itemSize: [{
          type: Input
        }],
        minBufferPx: [{
          type: Input
        }],
        maxBufferPx: [{
          type: Input
        }]
      });
    })();
    DEFAULT_SCROLL_TIME = 20;
    ScrollDispatcher = class _ScrollDispatcher {
      _ngZone = inject2(NgZone);
      _platform = inject2(Platform);
      _renderer = inject2(RendererFactory2).createRenderer(null, null);
      _cleanupGlobalListener;
      constructor() {
      }
      /** Subject for notifying that a registered scrollable reference element has been scrolled. */
      _scrolled = new Subject();
      /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */
      _scrolledCount = 0;
      /**
       * Map of all the scrollable references that are registered with the service and their
       * scroll event subscriptions.
       */
      scrollContainers = /* @__PURE__ */ new Map();
      /**
       * Registers a scrollable instance with the service and listens for its scrolled events. When the
       * scrollable is scrolled, the service emits the event to its scrolled observable.
       * @param scrollable Scrollable instance to be registered.
       */
      register(scrollable) {
        if (!this.scrollContainers.has(scrollable)) {
          this.scrollContainers.set(scrollable, scrollable.elementScrolled().subscribe(() => this._scrolled.next(scrollable)));
        }
      }
      /**
       * De-registers a Scrollable reference and unsubscribes from its scroll event observable.
       * @param scrollable Scrollable instance to be deregistered.
       */
      deregister(scrollable) {
        const scrollableReference = this.scrollContainers.get(scrollable);
        if (scrollableReference) {
          scrollableReference.unsubscribe();
          this.scrollContainers.delete(scrollable);
        }
      }
      /**
       * Returns an observable that emits an event whenever any of the registered Scrollable
       * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
       * to override the default "throttle" time.
       *
       * **Note:** in order to avoid hitting change detection for every scroll event,
       * all of the events emitted from this stream will be run outside the Angular zone.
       * If you need to update any data bindings as a result of a scroll event, you have
       * to run the callback using `NgZone.run`.
       */
      scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {
        if (!this._platform.isBrowser) {
          return of();
        }
        return new Observable((observer) => {
          if (!this._cleanupGlobalListener) {
            this._cleanupGlobalListener = this._ngZone.runOutsideAngular(() => this._renderer.listen("document", "scroll", () => this._scrolled.next()));
          }
          const subscription = auditTimeInMs > 0 ? this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) : this._scrolled.subscribe(observer);
          this._scrolledCount++;
          return () => {
            subscription.unsubscribe();
            this._scrolledCount--;
            if (!this._scrolledCount) {
              this._cleanupGlobalListener?.();
              this._cleanupGlobalListener = void 0;
            }
          };
        });
      }
      ngOnDestroy() {
        this._cleanupGlobalListener?.();
        this._cleanupGlobalListener = void 0;
        this.scrollContainers.forEach((_, container) => this.deregister(container));
        this._scrolled.complete();
      }
      /**
       * Returns an observable that emits whenever any of the
       * scrollable ancestors of an element are scrolled.
       * @param elementOrElementRef Element whose ancestors to listen for.
       * @param auditTimeInMs Time to throttle the scroll events.
       */
      ancestorScrolled(elementOrElementRef, auditTimeInMs) {
        const ancestors = this.getAncestorScrollContainers(elementOrElementRef);
        return this.scrolled(auditTimeInMs).pipe(filter((target) => !target || ancestors.indexOf(target) > -1));
      }
      /** Returns all registered Scrollables that contain the provided element. */
      getAncestorScrollContainers(elementOrElementRef) {
        const scrollingContainers = [];
        this.scrollContainers.forEach((_subscription, scrollable) => {
          if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {
            scrollingContainers.push(scrollable);
          }
        });
        return scrollingContainers;
      }
      /** Returns true if the element is contained within the provided Scrollable. */
      _scrollableContainsElement(scrollable, elementOrElementRef) {
        let element = coerceElement(elementOrElementRef);
        let scrollableElement = scrollable.getElementRef().nativeElement;
        do {
          if (element == scrollableElement) {
            return true;
          }
        } while (element = element.parentElement);
        return false;
      }
      static \u0275fac = function ScrollDispatcher_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ScrollDispatcher)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _ScrollDispatcher,
        factory: _ScrollDispatcher.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollDispatcher, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [], null);
    })();
    CdkScrollable = class _CdkScrollable {
      elementRef = inject2(ElementRef);
      scrollDispatcher = inject2(ScrollDispatcher);
      ngZone = inject2(NgZone);
      dir = inject2(Directionality, {
        optional: true
      });
      _scrollElement = this.elementRef.nativeElement;
      _destroyed = new Subject();
      _renderer = inject2(Renderer2);
      _cleanupScroll;
      _elementScrolled = new Subject();
      constructor() {
      }
      ngOnInit() {
        this._cleanupScroll = this.ngZone.runOutsideAngular(() => this._renderer.listen(this._scrollElement, "scroll", (event) => this._elementScrolled.next(event)));
        this.scrollDispatcher.register(this);
      }
      ngOnDestroy() {
        this._cleanupScroll?.();
        this._elementScrolled.complete();
        this.scrollDispatcher.deregister(this);
        this._destroyed.next();
        this._destroyed.complete();
      }
      /** Returns observable that emits when a scroll event is fired on the host element. */
      elementScrolled() {
        return this._elementScrolled;
      }
      /** Gets the ElementRef for the viewport. */
      getElementRef() {
        return this.elementRef;
      }
      /**
       * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
       * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
       * left and right always refer to the left and right side of the scrolling container irrespective
       * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
       * in an RTL context.
       * @param options specified the offsets to scroll to.
       */
      scrollTo(options) {
        const el = this.elementRef.nativeElement;
        const isRtl = this.dir && this.dir.value == "rtl";
        if (options.left == null) {
          options.left = isRtl ? options.end : options.start;
        }
        if (options.right == null) {
          options.right = isRtl ? options.start : options.end;
        }
        if (options.bottom != null) {
          options.top = el.scrollHeight - el.clientHeight - options.bottom;
        }
        if (isRtl && getRtlScrollAxisType() != RtlScrollAxisType.NORMAL) {
          if (options.left != null) {
            options.right = el.scrollWidth - el.clientWidth - options.left;
          }
          if (getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
            options.left = options.right;
          } else if (getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
            options.left = options.right ? -options.right : options.right;
          }
        } else {
          if (options.right != null) {
            options.left = el.scrollWidth - el.clientWidth - options.right;
          }
        }
        this._applyScrollToOptions(options);
      }
      _applyScrollToOptions(options) {
        const el = this.elementRef.nativeElement;
        if (supportsScrollBehavior()) {
          el.scrollTo(options);
        } else {
          if (options.top != null) {
            el.scrollTop = options.top;
          }
          if (options.left != null) {
            el.scrollLeft = options.left;
          }
        }
      }
      /**
       * Measures the scroll offset relative to the specified edge of the viewport. This method can be
       * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent
       * about what scrollLeft means in RTL. The values returned by this method are normalized such that
       * left and right always refer to the left and right side of the scrolling container irrespective
       * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
       * in an RTL context.
       * @param from The edge to measure from.
       */
      measureScrollOffset(from2) {
        const LEFT = "left";
        const RIGHT = "right";
        const el = this.elementRef.nativeElement;
        if (from2 == "top") {
          return el.scrollTop;
        }
        if (from2 == "bottom") {
          return el.scrollHeight - el.clientHeight - el.scrollTop;
        }
        const isRtl = this.dir && this.dir.value == "rtl";
        if (from2 == "start") {
          from2 = isRtl ? RIGHT : LEFT;
        } else if (from2 == "end") {
          from2 = isRtl ? LEFT : RIGHT;
        }
        if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
          if (from2 == LEFT) {
            return el.scrollWidth - el.clientWidth - el.scrollLeft;
          } else {
            return el.scrollLeft;
          }
        } else if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
          if (from2 == LEFT) {
            return el.scrollLeft + el.scrollWidth - el.clientWidth;
          } else {
            return -el.scrollLeft;
          }
        } else {
          if (from2 == LEFT) {
            return el.scrollLeft;
          } else {
            return el.scrollWidth - el.clientWidth - el.scrollLeft;
          }
        }
      }
      static \u0275fac = function CdkScrollable_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkScrollable)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkScrollable,
        selectors: [["", "cdk-scrollable", ""], ["", "cdkScrollable", ""]]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkScrollable, [{
        type: Directive,
        args: [{
          selector: "[cdk-scrollable], [cdkScrollable]"
        }]
      }], () => [], null);
    })();
    DEFAULT_RESIZE_TIME = 20;
    ViewportRuler = class _ViewportRuler {
      _platform = inject2(Platform);
      _listeners;
      /** Cached viewport dimensions. */
      _viewportSize;
      /** Stream of viewport change events. */
      _change = new Subject();
      /** Used to reference correct document/window */
      _document = inject2(DOCUMENT);
      constructor() {
        const ngZone = inject2(NgZone);
        const renderer = inject2(RendererFactory2).createRenderer(null, null);
        ngZone.runOutsideAngular(() => {
          if (this._platform.isBrowser) {
            const changeListener = (event) => this._change.next(event);
            this._listeners = [renderer.listen("window", "resize", changeListener), renderer.listen("window", "orientationchange", changeListener)];
          }
          this.change().subscribe(() => this._viewportSize = null);
        });
      }
      ngOnDestroy() {
        this._listeners?.forEach((cleanup) => cleanup());
        this._change.complete();
      }
      /** Returns the viewport's width and height. */
      getViewportSize() {
        if (!this._viewportSize) {
          this._updateViewportSize();
        }
        const output = {
          width: this._viewportSize.width,
          height: this._viewportSize.height
        };
        if (!this._platform.isBrowser) {
          this._viewportSize = null;
        }
        return output;
      }
      /** Gets a DOMRect for the viewport's bounds. */
      getViewportRect() {
        const scrollPosition = this.getViewportScrollPosition();
        const {
          width,
          height
        } = this.getViewportSize();
        return {
          top: scrollPosition.top,
          left: scrollPosition.left,
          bottom: scrollPosition.top + height,
          right: scrollPosition.left + width,
          height,
          width
        };
      }
      /** Gets the (top, left) scroll position of the viewport. */
      getViewportScrollPosition() {
        if (!this._platform.isBrowser) {
          return {
            top: 0,
            left: 0
          };
        }
        const document2 = this._document;
        const window2 = this._getWindow();
        const documentElement = document2.documentElement;
        const documentRect = documentElement.getBoundingClientRect();
        const top2 = -documentRect.top || document2.body.scrollTop || window2.scrollY || documentElement.scrollTop || 0;
        const left = -documentRect.left || document2.body.scrollLeft || window2.scrollX || documentElement.scrollLeft || 0;
        return {
          top: top2,
          left
        };
      }
      /**
       * Returns a stream that emits whenever the size of the viewport changes.
       * This stream emits outside of the Angular zone.
       * @param throttleTime Time in milliseconds to throttle the stream.
       */
      change(throttleTime = DEFAULT_RESIZE_TIME) {
        return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;
      }
      /** Use defaultView of injected document if available or fallback to global window reference */
      _getWindow() {
        return this._document.defaultView || window;
      }
      /** Updates the cached viewport size. */
      _updateViewportSize() {
        const window2 = this._getWindow();
        this._viewportSize = this._platform.isBrowser ? {
          width: window2.innerWidth,
          height: window2.innerHeight
        } : {
          width: 0,
          height: 0
        };
      }
      static \u0275fac = function ViewportRuler_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ViewportRuler)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _ViewportRuler,
        factory: _ViewportRuler.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewportRuler, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [], null);
    })();
    VIRTUAL_SCROLLABLE = new InjectionToken("VIRTUAL_SCROLLABLE");
    CdkVirtualScrollable = class _CdkVirtualScrollable extends CdkScrollable {
      constructor() {
        super();
      }
      /**
       * Measure the viewport size for the provided orientation.
       *
       * @param orientation The orientation to measure the size from.
       */
      measureViewportSize(orientation) {
        const viewportEl = this.elementRef.nativeElement;
        return orientation === "horizontal" ? viewportEl.clientWidth : viewportEl.clientHeight;
      }
      static \u0275fac = function CdkVirtualScrollable_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkVirtualScrollable)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkVirtualScrollable,
        features: [\u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollable, [{
        type: Directive
      }], () => [], null);
    })();
    SCROLL_SCHEDULER = typeof requestAnimationFrame !== "undefined" ? animationFrameScheduler : asapScheduler;
    CdkVirtualScrollViewport = class _CdkVirtualScrollViewport extends CdkVirtualScrollable {
      elementRef = inject2(ElementRef);
      _changeDetectorRef = inject2(ChangeDetectorRef);
      _scrollStrategy = inject2(VIRTUAL_SCROLL_STRATEGY, {
        optional: true
      });
      scrollable = inject2(VIRTUAL_SCROLLABLE, {
        optional: true
      });
      _platform = inject2(Platform);
      /** Emits when the viewport is detached from a CdkVirtualForOf. */
      _detachedSubject = new Subject();
      /** Emits when the rendered range changes. */
      _renderedRangeSubject = new Subject();
      /** The direction the viewport scrolls. */
      get orientation() {
        return this._orientation;
      }
      set orientation(orientation) {
        if (this._orientation !== orientation) {
          this._orientation = orientation;
          this._calculateSpacerSize();
        }
      }
      _orientation = "vertical";
      /**
       * Whether rendered items should persist in the DOM after scrolling out of view. By default, items
       * will be removed.
       */
      appendOnly = false;
      // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll
      // strategy lazily (i.e. only if the user is actually listening to the events). We do this because
      // depending on how the strategy calculates the scrolled index, it may come at a cost to
      // performance.
      /** Emits when the index of the first element visible in the viewport changes. */
      scrolledIndexChange = new Observable((observer) => this._scrollStrategy.scrolledIndexChange.subscribe((index) => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));
      /** The element that wraps the rendered content. */
      _contentWrapper;
      /** A stream that emits whenever the rendered range changes. */
      renderedRangeStream = this._renderedRangeSubject;
      /**
       * The total size of all content (in pixels), including content that is not currently rendered.
       */
      _totalContentSize = 0;
      /** A string representing the `style.width` property value to be used for the spacer element. */
      _totalContentWidth = signal("", ...ngDevMode ? [{
        debugName: "_totalContentWidth"
      }] : []);
      /** A string representing the `style.height` property value to be used for the spacer element. */
      _totalContentHeight = signal("", ...ngDevMode ? [{
        debugName: "_totalContentHeight"
      }] : []);
      /**
       * The CSS transform applied to the rendered subset of items so that they appear within the bounds
       * of the visible viewport.
       */
      _renderedContentTransform;
      /** The currently rendered range of indices. */
      _renderedRange = {
        start: 0,
        end: 0
      };
      /** The length of the data bound to this viewport (in number of items). */
      _dataLength = 0;
      /** The size of the viewport (in pixels). */
      _viewportSize = 0;
      /** the currently attached CdkVirtualScrollRepeater. */
      _forOf;
      /** The last rendered content offset that was set. */
      _renderedContentOffset = 0;
      /**
       * Whether the last rendered content offset was to the end of the content (and therefore needs to
       * be rewritten as an offset to the start of the content).
       */
      _renderedContentOffsetNeedsRewrite = false;
      _changeDetectionNeeded = signal(false, ...ngDevMode ? [{
        debugName: "_changeDetectionNeeded"
      }] : []);
      /** A list of functions to run after the next change detection cycle. */
      _runAfterChangeDetection = [];
      /** Subscription to changes in the viewport size. */
      _viewportChanges = Subscription.EMPTY;
      _injector = inject2(Injector);
      _isDestroyed = false;
      constructor() {
        super();
        const viewportRuler = inject2(ViewportRuler);
        if (!this._scrollStrategy && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw Error('Error: cdk-virtual-scroll-viewport requires the "itemSize" property to be set.');
        }
        this._viewportChanges = viewportRuler.change().subscribe(() => {
          this.checkViewportSize();
        });
        if (!this.scrollable) {
          this.elementRef.nativeElement.classList.add("cdk-virtual-scrollable");
          this.scrollable = this;
        }
        const ref = effect(() => {
          if (this._changeDetectionNeeded()) {
            this._doChangeDetection();
          }
        }, ...ngDevMode ? [{
          debugName: "ref",
          injector: inject2(ApplicationRef).injector
        }] : [
          // Using ApplicationRef injector is important here because we want this to be a root
          // effect that runs before change detection of any application views (since we're depending on markForCheck marking parents dirty)
          {
            injector: inject2(ApplicationRef).injector
          }
        ]);
        inject2(DestroyRef).onDestroy(() => void ref.destroy());
      }
      ngOnInit() {
        if (!this._platform.isBrowser) {
          return;
        }
        if (this.scrollable === this) {
          super.ngOnInit();
        }
        this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {
          this._measureViewportSize();
          this._scrollStrategy.attach(this);
          this.scrollable.elementScrolled().pipe(
            // Start off with a fake scroll event so we properly detect our initial position.
            startWith(null),
            // Collect multiple events into one until the next animation frame. This way if
            // there are multiple scroll events in the same frame we only need to recheck
            // our layout once.
            auditTime(0, SCROLL_SCHEDULER),
            // Usually `elementScrolled` is completed when the scrollable is destroyed, but
            // that may not be the case if a `CdkVirtualScrollableElement` is used so we have
            // to unsubscribe here just in case.
            takeUntil(this._destroyed)
          ).subscribe(() => this._scrollStrategy.onContentScrolled());
          this._markChangeDetectionNeeded();
        }));
      }
      ngOnDestroy() {
        this.detach();
        this._scrollStrategy.detach();
        this._renderedRangeSubject.complete();
        this._detachedSubject.complete();
        this._viewportChanges.unsubscribe();
        this._isDestroyed = true;
        super.ngOnDestroy();
      }
      /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */
      attach(forOf) {
        if (this._forOf && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw Error("CdkVirtualScrollViewport is already attached.");
        }
        this.ngZone.runOutsideAngular(() => {
          this._forOf = forOf;
          this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe((data2) => {
            const newLength = data2.length;
            if (newLength !== this._dataLength) {
              this._dataLength = newLength;
              this._scrollStrategy.onDataLengthChanged();
            }
            this._doChangeDetection();
          });
        });
      }
      /** Detaches the current `CdkVirtualForOf`. */
      detach() {
        this._forOf = null;
        this._detachedSubject.next();
      }
      /** Gets the length of the data bound to this viewport (in number of items). */
      getDataLength() {
        return this._dataLength;
      }
      /** Gets the size of the viewport (in pixels). */
      getViewportSize() {
        return this._viewportSize;
      }
      // TODO(mmalerba): This is technically out of sync with what's really rendered until a render
      // cycle happens. I'm being careful to only call it after the render cycle is complete and before
      // setting it to something else, but its error prone and should probably be split into
      // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.
      /** Get the current rendered range of items. */
      getRenderedRange() {
        return this._renderedRange;
      }
      measureBoundingClientRectWithScrollOffset(from2) {
        return this.getElementRef().nativeElement.getBoundingClientRect()[from2];
      }
      /**
       * Sets the total size of all content (in pixels), including content that is not currently
       * rendered.
       */
      setTotalContentSize(size) {
        if (this._totalContentSize !== size) {
          this._totalContentSize = size;
          this._calculateSpacerSize();
          this._markChangeDetectionNeeded();
        }
      }
      /** Sets the currently rendered range of indices. */
      setRenderedRange(range) {
        if (!rangesEqual(this._renderedRange, range)) {
          if (this.appendOnly) {
            range = {
              start: 0,
              end: Math.max(this._renderedRange.end, range.end)
            };
          }
          this._renderedRangeSubject.next(this._renderedRange = range);
          this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());
        }
      }
      /**
       * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).
       */
      getOffsetToRenderedContentStart() {
        return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;
      }
      /**
       * Sets the offset from the start of the viewport to either the start or end of the rendered data
       * (in pixels).
       */
      setRenderedContentOffset(offset, to = "to-start") {
        offset = this.appendOnly && to === "to-start" ? 0 : offset;
        const isRtl = this.dir && this.dir.value == "rtl";
        const isHorizontal = this.orientation == "horizontal";
        const axis = isHorizontal ? "X" : "Y";
        const axisDirection = isHorizontal && isRtl ? -1 : 1;
        let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;
        this._renderedContentOffset = offset;
        if (to === "to-end") {
          transform += ` translate${axis}(-100%)`;
          this._renderedContentOffsetNeedsRewrite = true;
        }
        if (this._renderedContentTransform != transform) {
          this._renderedContentTransform = transform;
          this._markChangeDetectionNeeded(() => {
            if (this._renderedContentOffsetNeedsRewrite) {
              this._renderedContentOffset -= this.measureRenderedContentSize();
              this._renderedContentOffsetNeedsRewrite = false;
              this.setRenderedContentOffset(this._renderedContentOffset);
            } else {
              this._scrollStrategy.onRenderedOffsetChanged();
            }
          });
        }
      }
      /**
       * Scrolls to the given offset from the start of the viewport. Please note that this is not always
       * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left
       * direction, this would be the equivalent of setting a fictional `scrollRight` property.
       * @param offset The offset to scroll to.
       * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
       */
      scrollToOffset(offset, behavior = "auto") {
        const options = {
          behavior
        };
        if (this.orientation === "horizontal") {
          options.start = offset;
        } else {
          options.top = offset;
        }
        this.scrollable.scrollTo(options);
      }
      /**
       * Scrolls to the offset for the given index.
       * @param index The index of the element to scroll to.
       * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
       */
      scrollToIndex(index, behavior = "auto") {
        this._scrollStrategy.scrollToIndex(index, behavior);
      }
      /**
       * Gets the current scroll offset from the start of the scrollable (in pixels).
       * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'
       *     in horizontal mode.
       */
      measureScrollOffset(from2) {
        let measureScrollOffset;
        if (this.scrollable == this) {
          measureScrollOffset = (_from) => super.measureScrollOffset(_from);
        } else {
          measureScrollOffset = (_from) => this.scrollable.measureScrollOffset(_from);
        }
        return Math.max(0, measureScrollOffset(from2 ?? (this.orientation === "horizontal" ? "start" : "top")) - this.measureViewportOffset());
      }
      /**
       * Measures the offset of the viewport from the scrolling container
       * @param from The edge to measure from.
       */
      measureViewportOffset(from2) {
        let fromRect;
        const LEFT = "left";
        const RIGHT = "right";
        const isRtl = this.dir?.value == "rtl";
        if (from2 == "start") {
          fromRect = isRtl ? RIGHT : LEFT;
        } else if (from2 == "end") {
          fromRect = isRtl ? LEFT : RIGHT;
        } else if (from2) {
          fromRect = from2;
        } else {
          fromRect = this.orientation === "horizontal" ? "left" : "top";
        }
        const scrollerClientRect = this.scrollable.measureBoundingClientRectWithScrollOffset(fromRect);
        const viewportClientRect = this.elementRef.nativeElement.getBoundingClientRect()[fromRect];
        return viewportClientRect - scrollerClientRect;
      }
      /** Measure the combined size of all of the rendered items. */
      measureRenderedContentSize() {
        const contentEl = this._contentWrapper.nativeElement;
        return this.orientation === "horizontal" ? contentEl.offsetWidth : contentEl.offsetHeight;
      }
      /**
       * Measure the total combined size of the given range. Throws if the range includes items that are
       * not rendered.
       */
      measureRangeSize(range) {
        if (!this._forOf) {
          return 0;
        }
        return this._forOf.measureRangeSize(range, this.orientation);
      }
      /** Update the viewport dimensions and re-render. */
      checkViewportSize() {
        this._measureViewportSize();
        this._scrollStrategy.onDataLengthChanged();
      }
      /** Measure the viewport size. */
      _measureViewportSize() {
        this._viewportSize = this.scrollable.measureViewportSize(this.orientation);
      }
      /** Queue up change detection to run. */
      _markChangeDetectionNeeded(runAfter) {
        if (runAfter) {
          this._runAfterChangeDetection.push(runAfter);
        }
        if (untracked2(this._changeDetectionNeeded)) {
          return;
        }
        this.ngZone.runOutsideAngular(() => {
          Promise.resolve().then(() => {
            this.ngZone.run(() => {
              this._changeDetectionNeeded.set(true);
            });
          });
        });
      }
      /** Run change detection. */
      _doChangeDetection() {
        if (this._isDestroyed) {
          return;
        }
        this.ngZone.run(() => {
          this._changeDetectorRef.markForCheck();
          this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;
          afterNextRender(() => {
            this._changeDetectionNeeded.set(false);
            const runAfterChangeDetection = this._runAfterChangeDetection;
            this._runAfterChangeDetection = [];
            for (const fn of runAfterChangeDetection) {
              fn();
            }
          }, {
            injector: this._injector
          });
        });
      }
      /** Calculates the `style.width` and `style.height` for the spacer element. */
      _calculateSpacerSize() {
        this._totalContentHeight.set(this.orientation === "horizontal" ? "" : `${this._totalContentSize}px`);
        this._totalContentWidth.set(this.orientation === "horizontal" ? `${this._totalContentSize}px` : "");
      }
      static \u0275fac = function CdkVirtualScrollViewport_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkVirtualScrollViewport)();
      };
      static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
        type: _CdkVirtualScrollViewport,
        selectors: [["cdk-virtual-scroll-viewport"]],
        viewQuery: function CdkVirtualScrollViewport_Query(rf, ctx) {
          if (rf & 1) {
            \u0275\u0275viewQuery(_c0, 7);
          }
          if (rf & 2) {
            let _t;
            \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx._contentWrapper = _t.first);
          }
        },
        hostAttrs: [1, "cdk-virtual-scroll-viewport"],
        hostVars: 4,
        hostBindings: function CdkVirtualScrollViewport_HostBindings(rf, ctx) {
          if (rf & 2) {
            \u0275\u0275classProp("cdk-virtual-scroll-orientation-horizontal", ctx.orientation === "horizontal")("cdk-virtual-scroll-orientation-vertical", ctx.orientation !== "horizontal");
          }
        },
        inputs: {
          orientation: "orientation",
          appendOnly: [2, "appendOnly", "appendOnly", booleanAttribute]
        },
        outputs: {
          scrolledIndexChange: "scrolledIndexChange"
        },
        features: [\u0275\u0275ProvidersFeature([{
          provide: CdkScrollable,
          useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,
          deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], _CdkVirtualScrollViewport]
        }]), \u0275\u0275InheritDefinitionFeature],
        ngContentSelectors: _c1,
        decls: 4,
        vars: 4,
        consts: [["contentWrapper", ""], [1, "cdk-virtual-scroll-content-wrapper"], [1, "cdk-virtual-scroll-spacer"]],
        template: function CdkVirtualScrollViewport_Template(rf, ctx) {
          if (rf & 1) {
            \u0275\u0275projectionDef();
            \u0275\u0275domElementStart(0, "div", 1, 0);
            \u0275\u0275projection(2);
            \u0275\u0275domElementEnd();
            \u0275\u0275domElement(3, "div", 2);
          }
          if (rf & 2) {
            \u0275\u0275advance(3);
            \u0275\u0275styleProp("width", ctx._totalContentWidth())("height", ctx._totalContentHeight());
          }
        },
        styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}\n"],
        encapsulation: 2,
        changeDetection: 0
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollViewport, [{
        type: Component,
        args: [{
          selector: "cdk-virtual-scroll-viewport",
          host: {
            "class": "cdk-virtual-scroll-viewport",
            "[class.cdk-virtual-scroll-orientation-horizontal]": 'orientation === "horizontal"',
            "[class.cdk-virtual-scroll-orientation-vertical]": 'orientation !== "horizontal"'
          },
          encapsulation: ViewEncapsulation.None,
          changeDetection: ChangeDetectionStrategy.OnPush,
          providers: [{
            provide: CdkScrollable,
            useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,
            deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], CdkVirtualScrollViewport]
          }],
          template: '<!--\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\n  position.\n-->\n<div #contentWrapper class="cdk-virtual-scroll-content-wrapper">\n  <ng-content></ng-content>\n</div>\n<!--\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\n  so that the scrollbar captures the size of the entire data set.\n-->\n<div class="cdk-virtual-scroll-spacer"\n     [style.width]="_totalContentWidth()" [style.height]="_totalContentHeight()"></div>\n',
          styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}\n"]
        }]
      }], () => [], {
        orientation: [{
          type: Input
        }],
        appendOnly: [{
          type: Input,
          args: [{
            transform: booleanAttribute
          }]
        }],
        scrolledIndexChange: [{
          type: Output
        }],
        _contentWrapper: [{
          type: ViewChild,
          args: ["contentWrapper", {
            static: true
          }]
        }]
      });
    })();
    CdkVirtualForOf = class _CdkVirtualForOf {
      _viewContainerRef = inject2(ViewContainerRef);
      _template = inject2(TemplateRef);
      _differs = inject2(IterableDiffers);
      _viewRepeater = inject2(_VIEW_REPEATER_STRATEGY);
      _viewport = inject2(CdkVirtualScrollViewport, {
        skipSelf: true
      });
      /** Emits when the rendered view of the data changes. */
      viewChange = new Subject();
      /** Subject that emits when a new DataSource instance is given. */
      _dataSourceChanges = new Subject();
      /** The DataSource to display. */
      get cdkVirtualForOf() {
        return this._cdkVirtualForOf;
      }
      set cdkVirtualForOf(value) {
        this._cdkVirtualForOf = value;
        if (isDataSource(value)) {
          this._dataSourceChanges.next(value);
        } else {
          this._dataSourceChanges.next(new ArrayDataSource(isObservable(value) ? value : Array.from(value || [])));
        }
      }
      _cdkVirtualForOf;
      /**
       * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and
       * the item and produces a value to be used as the item's identity when tracking changes.
       */
      get cdkVirtualForTrackBy() {
        return this._cdkVirtualForTrackBy;
      }
      set cdkVirtualForTrackBy(fn) {
        this._needsUpdate = true;
        this._cdkVirtualForTrackBy = fn ? (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item) : void 0;
      }
      _cdkVirtualForTrackBy;
      /** The template used to stamp out new elements. */
      set cdkVirtualForTemplate(value) {
        if (value) {
          this._needsUpdate = true;
          this._template = value;
        }
      }
      /**
       * The size of the cache used to store templates that are not being used for re-use later.
       * Setting the cache size to `0` will disable caching. Defaults to 20 templates.
       */
      get cdkVirtualForTemplateCacheSize() {
        return this._viewRepeater.viewCacheSize;
      }
      set cdkVirtualForTemplateCacheSize(size) {
        this._viewRepeater.viewCacheSize = coerceNumberProperty(size);
      }
      /** Emits whenever the data in the current DataSource changes. */
      dataStream = this._dataSourceChanges.pipe(
        // Start off with null `DataSource`.
        startWith(null),
        // Bundle up the previous and current data sources so we can work with both.
        pairwise(),
        // Use `_changeDataSource` to disconnect from the previous data source and connect to the
        // new one, passing back a stream of data changes which we run through `switchMap` to give
        // us a data stream that emits the latest data from whatever the current `DataSource` is.
        switchMap(([prev, cur2]) => this._changeDataSource(prev, cur2)),
        // Replay the last emitted data when someone subscribes.
        shareReplay(1)
      );
      /** The differ used to calculate changes to the data. */
      _differ = null;
      /** The most recent data emitted from the DataSource. */
      _data;
      /** The currently rendered items. */
      _renderedItems;
      /** The currently rendered range of indices. */
      _renderedRange;
      /** Whether the rendered data should be updated during the next ngDoCheck cycle. */
      _needsUpdate = false;
      _destroyed = new Subject();
      constructor() {
        const ngZone = inject2(NgZone);
        this.dataStream.subscribe((data2) => {
          this._data = data2;
          this._onRenderedDataChange();
        });
        this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe((range) => {
          this._renderedRange = range;
          if (this.viewChange.observers.length) {
            ngZone.run(() => this.viewChange.next(this._renderedRange));
          }
          this._onRenderedDataChange();
        });
        this._viewport.attach(this);
      }
      /**
       * Measures the combined size (width for horizontal orientation, height for vertical) of all items
       * in the specified range. Throws an error if the range includes items that are not currently
       * rendered.
       */
      measureRangeSize(range, orientation) {
        if (range.start >= range.end) {
          return 0;
        }
        if ((range.start < this._renderedRange.start || range.end > this._renderedRange.end) && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw Error(`Error: attempted to measure an item that isn't rendered.`);
        }
        const renderedStartIndex = range.start - this._renderedRange.start;
        const rangeLen = range.end - range.start;
        let firstNode;
        let lastNode;
        for (let i = 0; i < rangeLen; i++) {
          const view = this._viewContainerRef.get(i + renderedStartIndex);
          if (view && view.rootNodes.length) {
            firstNode = lastNode = view.rootNodes[0];
            break;
          }
        }
        for (let i = rangeLen - 1; i > -1; i--) {
          const view = this._viewContainerRef.get(i + renderedStartIndex);
          if (view && view.rootNodes.length) {
            lastNode = view.rootNodes[view.rootNodes.length - 1];
            break;
          }
        }
        return firstNode && lastNode ? getOffset(orientation, "end", lastNode) - getOffset(orientation, "start", firstNode) : 0;
      }
      ngDoCheck() {
        if (this._differ && this._needsUpdate) {
          const changes = this._differ.diff(this._renderedItems);
          if (!changes) {
            this._updateContext();
          } else {
            this._applyChanges(changes);
          }
          this._needsUpdate = false;
        }
      }
      ngOnDestroy() {
        this._viewport.detach();
        this._dataSourceChanges.next(void 0);
        this._dataSourceChanges.complete();
        this.viewChange.complete();
        this._destroyed.next();
        this._destroyed.complete();
        this._viewRepeater.detach();
      }
      /** React to scroll state changes in the viewport. */
      _onRenderedDataChange() {
        if (!this._renderedRange) {
          return;
        }
        this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);
        if (!this._differ) {
          this._differ = this._differs.find(this._renderedItems).create((index, item) => {
            return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;
          });
        }
        this._needsUpdate = true;
      }
      /** Swap out one `DataSource` for another. */
      _changeDataSource(oldDs, newDs) {
        if (oldDs) {
          oldDs.disconnect(this);
        }
        this._needsUpdate = true;
        return newDs ? newDs.connect(this) : of();
      }
      /** Update the `CdkVirtualForOfContext` for all views. */
      _updateContext() {
        const count2 = this._data.length;
        let i = this._viewContainerRef.length;
        while (i--) {
          const view = this._viewContainerRef.get(i);
          view.context.index = this._renderedRange.start + i;
          view.context.count = count2;
          this._updateComputedContextProperties(view.context);
          view.detectChanges();
        }
      }
      /** Apply changes to the DOM. */
      _applyChanges(changes) {
        this._viewRepeater.applyChanges(changes, this._viewContainerRef, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record, currentIndex), (record) => record.item);
        changes.forEachIdentityChange((record) => {
          const view = this._viewContainerRef.get(record.currentIndex);
          view.context.$implicit = record.item;
        });
        const count2 = this._data.length;
        let i = this._viewContainerRef.length;
        while (i--) {
          const view = this._viewContainerRef.get(i);
          view.context.index = this._renderedRange.start + i;
          view.context.count = count2;
          this._updateComputedContextProperties(view.context);
        }
      }
      /** Update the computed properties on the `CdkVirtualForOfContext`. */
      _updateComputedContextProperties(context2) {
        context2.first = context2.index === 0;
        context2.last = context2.index === context2.count - 1;
        context2.even = context2.index % 2 === 0;
        context2.odd = !context2.even;
      }
      _getEmbeddedViewArgs(record, index) {
        return {
          templateRef: this._template,
          context: {
            $implicit: record.item,
            // It's guaranteed that the iterable is not "undefined" or "null" because we only
            // generate views for elements if the "cdkVirtualForOf" iterable has elements.
            cdkVirtualForOf: this._cdkVirtualForOf,
            index: -1,
            count: -1,
            first: false,
            last: false,
            odd: false,
            even: false
          },
          index
        };
      }
      static ngTemplateContextGuard(directive, context2) {
        return true;
      }
      static \u0275fac = function CdkVirtualForOf_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkVirtualForOf)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkVirtualForOf,
        selectors: [["", "cdkVirtualFor", "", "cdkVirtualForOf", ""]],
        inputs: {
          cdkVirtualForOf: "cdkVirtualForOf",
          cdkVirtualForTrackBy: "cdkVirtualForTrackBy",
          cdkVirtualForTemplate: "cdkVirtualForTemplate",
          cdkVirtualForTemplateCacheSize: "cdkVirtualForTemplateCacheSize"
        },
        features: [\u0275\u0275ProvidersFeature([{
          provide: _VIEW_REPEATER_STRATEGY,
          useClass: _RecycleViewRepeaterStrategy
        }])]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualForOf, [{
        type: Directive,
        args: [{
          selector: "[cdkVirtualFor][cdkVirtualForOf]",
          providers: [{
            provide: _VIEW_REPEATER_STRATEGY,
            useClass: _RecycleViewRepeaterStrategy
          }]
        }]
      }], () => [], {
        cdkVirtualForOf: [{
          type: Input
        }],
        cdkVirtualForTrackBy: [{
          type: Input
        }],
        cdkVirtualForTemplate: [{
          type: Input
        }],
        cdkVirtualForTemplateCacheSize: [{
          type: Input
        }]
      });
    })();
    CdkVirtualScrollableElement = class _CdkVirtualScrollableElement extends CdkVirtualScrollable {
      constructor() {
        super();
      }
      measureBoundingClientRectWithScrollOffset(from2) {
        return this.getElementRef().nativeElement.getBoundingClientRect()[from2] - this.measureScrollOffset(from2);
      }
      static \u0275fac = function CdkVirtualScrollableElement_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkVirtualScrollableElement)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkVirtualScrollableElement,
        selectors: [["", "cdkVirtualScrollingElement", ""]],
        hostAttrs: [1, "cdk-virtual-scrollable"],
        features: [\u0275\u0275ProvidersFeature([{
          provide: VIRTUAL_SCROLLABLE,
          useExisting: _CdkVirtualScrollableElement
        }]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollableElement, [{
        type: Directive,
        args: [{
          selector: "[cdkVirtualScrollingElement]",
          providers: [{
            provide: VIRTUAL_SCROLLABLE,
            useExisting: CdkVirtualScrollableElement
          }],
          host: {
            "class": "cdk-virtual-scrollable"
          }
        }]
      }], () => [], null);
    })();
    CdkVirtualScrollableWindow = class _CdkVirtualScrollableWindow extends CdkVirtualScrollable {
      constructor() {
        super();
        const document2 = inject2(DOCUMENT);
        this.elementRef = new ElementRef(document2.documentElement);
        this._scrollElement = document2;
      }
      measureBoundingClientRectWithScrollOffset(from2) {
        return this.getElementRef().nativeElement.getBoundingClientRect()[from2];
      }
      static \u0275fac = function CdkVirtualScrollableWindow_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkVirtualScrollableWindow)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkVirtualScrollableWindow,
        selectors: [["cdk-virtual-scroll-viewport", "scrollWindow", ""]],
        features: [\u0275\u0275ProvidersFeature([{
          provide: VIRTUAL_SCROLLABLE,
          useExisting: _CdkVirtualScrollableWindow
        }]), \u0275\u0275InheritDefinitionFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollableWindow, [{
        type: Directive,
        args: [{
          selector: "cdk-virtual-scroll-viewport[scrollWindow]",
          providers: [{
            provide: VIRTUAL_SCROLLABLE,
            useExisting: CdkVirtualScrollableWindow
          }]
        }]
      }], () => [], null);
    })();
    CdkScrollableModule = class _CdkScrollableModule {
      static \u0275fac = function CdkScrollableModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkScrollableModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _CdkScrollableModule,
        imports: [CdkScrollable],
        exports: [CdkScrollable]
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkScrollableModule, [{
        type: NgModule,
        args: [{
          exports: [CdkScrollable],
          imports: [CdkScrollable]
        }]
      }], null, null);
    })();
    ScrollingModule = class _ScrollingModule {
      static \u0275fac = function ScrollingModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _ScrollingModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _ScrollingModule,
        imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],
        exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
        imports: [BidiModule, CdkScrollableModule, BidiModule, CdkScrollableModule]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollingModule, [{
        type: NgModule,
        args: [{
          imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],
          exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]
        }]
      }], null, null);
    })();
  }
});

// node_modules/@angular/cdk/fesm2022/id-generator.mjs
var counters, _IdGenerator;
var init_id_generator = __esm({
  "node_modules/@angular/cdk/fesm2022/id-generator.mjs"() {
    "use strict";
    init_core();
    init_core();
    counters = {};
    _IdGenerator = class __IdGenerator {
      _appId = inject2(APP_ID);
      /**
       * Generates a unique ID with a specific prefix.
       * @param prefix Prefix to add to the ID.
       */
      getId(prefix) {
        if (this._appId !== "ng") {
          prefix += this._appId;
        }
        if (!counters.hasOwnProperty(prefix)) {
          counters[prefix] = 0;
        }
        return `${prefix}${counters[prefix]++}`;
      }
      static \u0275fac = function _IdGenerator_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || __IdGenerator)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: __IdGenerator,
        factory: __IdGenerator.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_IdGenerator, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
  }
});

// node_modules/@angular/cdk/fesm2022/array.mjs
function coerceArray(value) {
  return Array.isArray(value) ? value : [value];
}
var init_array = __esm({
  "node_modules/@angular/cdk/fesm2022/array.mjs"() {
    "use strict";
  }
});

// node_modules/@angular/cdk/fesm2022/drag-drop.mjs
function deepCloneNode(node) {
  const clone = node.cloneNode(true);
  const descendantsWithId = clone.querySelectorAll("[id]");
  const nodeName = node.nodeName.toLowerCase();
  clone.removeAttribute("id");
  for (let i = 0; i < descendantsWithId.length; i++) {
    descendantsWithId[i].removeAttribute("id");
  }
  if (nodeName === "canvas") {
    transferCanvasData(node, clone);
  } else if (nodeName === "input" || nodeName === "select" || nodeName === "textarea") {
    transferInputData(node, clone);
  }
  transferData("canvas", node, clone, transferCanvasData);
  transferData("input, textarea, select", node, clone, transferInputData);
  return clone;
}
function transferData(selector, node, clone, callback) {
  const descendantElements = node.querySelectorAll(selector);
  if (descendantElements.length) {
    const cloneElements = clone.querySelectorAll(selector);
    for (let i = 0; i < descendantElements.length; i++) {
      callback(descendantElements[i], cloneElements[i]);
    }
  }
}
function transferInputData(source, clone) {
  if (clone.type !== "file") {
    clone.value = source.value;
  }
  if (clone.type === "radio" && clone.name) {
    clone.name = `mat-clone-${clone.name}-${cloneUniqueId++}`;
  }
}
function transferCanvasData(source, clone) {
  const context2 = clone.getContext("2d");
  if (context2) {
    try {
      context2.drawImage(source, 0, 0);
    } catch {
    }
  }
}
function getMutableClientRect(element) {
  const rect = element.getBoundingClientRect();
  return {
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    width: rect.width,
    height: rect.height,
    x: rect.x,
    y: rect.y
  };
}
function isInsideClientRect(clientRect, x, y) {
  const {
    top: top2,
    bottom,
    left,
    right
  } = clientRect;
  return y >= top2 && y <= bottom && x >= left && x <= right;
}
function isOverflowingParent(parentRect, childRect) {
  const isLeftOverflowing = childRect.left < parentRect.left;
  const isRightOverflowing = childRect.left + childRect.width > parentRect.right;
  const isTopOverflowing = childRect.top < parentRect.top;
  const isBottomOverflowing = childRect.top + childRect.height > parentRect.bottom;
  return isLeftOverflowing || isRightOverflowing || isTopOverflowing || isBottomOverflowing;
}
function adjustDomRect(domRect, top2, left) {
  domRect.top += top2;
  domRect.bottom = domRect.top + domRect.height;
  domRect.left += left;
  domRect.right = domRect.left + domRect.width;
}
function isPointerNearDomRect(rect, threshold, pointerX, pointerY) {
  const {
    top: top2,
    right,
    bottom,
    left,
    width,
    height
  } = rect;
  const xThreshold = width * threshold;
  const yThreshold = height * threshold;
  return pointerY > top2 - yThreshold && pointerY < bottom + yThreshold && pointerX > left - xThreshold && pointerX < right + xThreshold;
}
function getRootNode(viewRef, _document2) {
  const rootNodes = viewRef.rootNodes;
  if (rootNodes.length === 1 && rootNodes[0].nodeType === _document2.ELEMENT_NODE) {
    return rootNodes[0];
  }
  const wrapper = _document2.createElement("div");
  rootNodes.forEach((node) => wrapper.appendChild(node));
  return wrapper;
}
function extendStyles(dest, source, importantProperties2) {
  for (let key in source) {
    if (source.hasOwnProperty(key)) {
      const value = source[key];
      if (value) {
        dest.setProperty(key, value, importantProperties2?.has(key) ? "important" : "");
      } else {
        dest.removeProperty(key);
      }
    }
  }
  return dest;
}
function toggleNativeDragInteractions(element, enable) {
  const userSelect = enable ? "" : "none";
  extendStyles(element.style, {
    "touch-action": enable ? "" : "none",
    "-webkit-user-drag": enable ? "" : "none",
    "-webkit-tap-highlight-color": enable ? "" : "transparent",
    "user-select": userSelect,
    "-ms-user-select": userSelect,
    "-webkit-user-select": userSelect,
    "-moz-user-select": userSelect
  });
}
function toggleVisibility(element, enable, importantProperties2) {
  extendStyles(element.style, {
    position: enable ? "" : "fixed",
    top: enable ? "" : "0",
    opacity: enable ? "" : "0",
    left: enable ? "" : "-999em"
  }, importantProperties2);
}
function combineTransforms(transform, initialTransform) {
  return initialTransform && initialTransform != "none" ? transform + " " + initialTransform : transform;
}
function matchElementSize(target, sourceRect) {
  target.style.width = `${sourceRect.width}px`;
  target.style.height = `${sourceRect.height}px`;
  target.style.transform = getTransform(sourceRect.left, sourceRect.top);
}
function getTransform(x, y) {
  return `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;
}
function parseCssTimeUnitsToMs(value) {
  const multiplier = value.toLowerCase().indexOf("ms") > -1 ? 1 : 1e3;
  return parseFloat(value) * multiplier;
}
function getTransformTransitionDurationInMs(element) {
  const computedStyle = getComputedStyle(element);
  const transitionedProperties = parseCssPropertyValue(computedStyle, "transition-property");
  const property = transitionedProperties.find((prop) => prop === "transform" || prop === "all");
  if (!property) {
    return 0;
  }
  const propertyIndex = transitionedProperties.indexOf(property);
  const rawDurations = parseCssPropertyValue(computedStyle, "transition-duration");
  const rawDelays = parseCssPropertyValue(computedStyle, "transition-delay");
  return parseCssTimeUnitsToMs(rawDurations[propertyIndex]) + parseCssTimeUnitsToMs(rawDelays[propertyIndex]);
}
function parseCssPropertyValue(computedStyle, name2) {
  const value = computedStyle.getPropertyValue(name2);
  return value.split(",").map((part) => part.trim());
}
function supportsPopover(element) {
  return "showPopover" in element;
}
function clamp$1(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function isTouchEvent(event) {
  return event.type[0] === "t";
}
function shadowDomSelectStart(event) {
  event.preventDefault();
}
function moveItemInArray(array, fromIndex, toIndex) {
  const from2 = clamp(fromIndex, array.length - 1);
  const to = clamp(toIndex, array.length - 1);
  if (from2 === to) {
    return;
  }
  const target = array[from2];
  const delta = to < from2 ? -1 : 1;
  for (let i = from2; i !== to; i += delta) {
    array[i] = array[i + delta];
  }
  array[to] = target;
}
function clamp(value, max) {
  return Math.max(0, Math.min(max, value));
}
function getVerticalScrollDirection(clientRect, pointerY) {
  const {
    top: top2,
    bottom,
    height
  } = clientRect;
  const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;
  if (pointerY >= top2 - yThreshold && pointerY <= top2 + yThreshold) {
    return AutoScrollVerticalDirection.UP;
  } else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {
    return AutoScrollVerticalDirection.DOWN;
  }
  return AutoScrollVerticalDirection.NONE;
}
function getHorizontalScrollDirection(clientRect, pointerX) {
  const {
    left,
    right,
    width
  } = clientRect;
  const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;
  if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {
    return AutoScrollHorizontalDirection.LEFT;
  } else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {
    return AutoScrollHorizontalDirection.RIGHT;
  }
  return AutoScrollHorizontalDirection.NONE;
}
function getElementScrollDirections(element, clientRect, direction, pointerX, pointerY) {
  const computedVertical = getVerticalScrollDirection(clientRect, pointerY);
  const computedHorizontal = getHorizontalScrollDirection(clientRect, pointerX);
  let verticalScrollDirection = AutoScrollVerticalDirection.NONE;
  let horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
  if (computedVertical) {
    const scrollTop = element.scrollTop;
    if (computedVertical === AutoScrollVerticalDirection.UP) {
      if (scrollTop > 0) {
        verticalScrollDirection = AutoScrollVerticalDirection.UP;
      }
    } else if (element.scrollHeight - scrollTop > element.clientHeight) {
      verticalScrollDirection = AutoScrollVerticalDirection.DOWN;
    }
  }
  if (computedHorizontal) {
    const scrollLeft = element.scrollLeft;
    if (direction === "rtl") {
      if (computedHorizontal === AutoScrollHorizontalDirection.RIGHT) {
        if (scrollLeft < 0) {
          horizontalScrollDirection = AutoScrollHorizontalDirection.RIGHT;
        }
      } else if (element.scrollWidth + scrollLeft > element.clientWidth) {
        horizontalScrollDirection = AutoScrollHorizontalDirection.LEFT;
      }
    } else {
      if (computedHorizontal === AutoScrollHorizontalDirection.LEFT) {
        if (scrollLeft > 0) {
          horizontalScrollDirection = AutoScrollHorizontalDirection.LEFT;
        }
      } else if (element.scrollWidth - scrollLeft > element.clientWidth) {
        horizontalScrollDirection = AutoScrollHorizontalDirection.RIGHT;
      }
    }
  }
  return [verticalScrollDirection, horizontalScrollDirection];
}
function assertElementNode(node, name2) {
  if (node.nodeType !== 1) {
    throw Error(`${name2} must be attached to an element node. Currently attached to "${node.nodeName}".`);
  }
}
var cloneUniqueId, ParentPositionTracker, importantProperties, PreviewRef, passiveEventListenerOptions, activeEventListenerOptions, activeCapturingEventOptions$1, MOUSE_EVENT_IGNORE_TIME, PLACEHOLDER_CLASS, dragImportantProperties, DragRef, SingleAxisSortStrategy, MixedSortStrategy, DROP_PROXIMITY_THRESHOLD, SCROLL_PROXIMITY_THRESHOLD, AutoScrollVerticalDirection, AutoScrollHorizontalDirection, DropListRef, capturingEventOptions, activeCapturingEventOptions, _ResetsLoader, DragDropRegistry, DEFAULT_CONFIG, DragDrop, CDK_DRAG_PARENT, CDK_DRAG_HANDLE, CdkDragHandle, CDK_DRAG_CONFIG, CDK_DROP_LIST, CdkDrag, CDK_DROP_LIST_GROUP, CdkDropListGroup, CdkDropList, CDK_DRAG_PREVIEW, CdkDragPreview, CDK_DRAG_PLACEHOLDER, CdkDragPlaceholder, DRAG_DROP_DIRECTIVES, DragDropModule;
var init_drag_drop = __esm({
  "node_modules/@angular/cdk/fesm2022/drag-drop.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_esm();
    init_shadow_dom();
    init_fake_event_detection();
    init_element();
    init_operators();
    init_style_loader();
    init_scrolling();
    init_directionality();
    init_id_generator();
    init_array();
    cloneUniqueId = 0;
    ParentPositionTracker = class {
      _document;
      /** Cached positions of the scrollable parent elements. */
      positions = /* @__PURE__ */ new Map();
      constructor(_document2) {
        this._document = _document2;
      }
      /** Clears the cached positions. */
      clear() {
        this.positions.clear();
      }
      /** Caches the positions. Should be called at the beginning of a drag sequence. */
      cache(elements) {
        this.clear();
        this.positions.set(this._document, {
          scrollPosition: this.getViewportScrollPosition()
        });
        elements.forEach((element) => {
          this.positions.set(element, {
            scrollPosition: {
              top: element.scrollTop,
              left: element.scrollLeft
            },
            clientRect: getMutableClientRect(element)
          });
        });
      }
      /** Handles scrolling while a drag is taking place. */
      handleScroll(event) {
        const target = _getEventTarget(event);
        const cachedPosition = this.positions.get(target);
        if (!cachedPosition) {
          return null;
        }
        const scrollPosition = cachedPosition.scrollPosition;
        let newTop;
        let newLeft;
        if (target === this._document) {
          const viewportScrollPosition = this.getViewportScrollPosition();
          newTop = viewportScrollPosition.top;
          newLeft = viewportScrollPosition.left;
        } else {
          newTop = target.scrollTop;
          newLeft = target.scrollLeft;
        }
        const topDifference = scrollPosition.top - newTop;
        const leftDifference = scrollPosition.left - newLeft;
        this.positions.forEach((position, node) => {
          if (position.clientRect && target !== node && target.contains(node)) {
            adjustDomRect(position.clientRect, topDifference, leftDifference);
          }
        });
        scrollPosition.top = newTop;
        scrollPosition.left = newLeft;
        return {
          top: topDifference,
          left: leftDifference
        };
      }
      /**
       * Gets the scroll position of the viewport. Note that we use the scrollX and scrollY directly,
       * instead of going through the `ViewportRuler`, because the first value the ruler looks at is
       * the top/left offset of the `document.documentElement` which works for most cases, but breaks
       * if the element is offset by something like the `BlockScrollStrategy`.
       */
      getViewportScrollPosition() {
        return {
          top: window.scrollY,
          left: window.scrollX
        };
      }
    };
    importantProperties = /* @__PURE__ */ new Set([
      // Needs to be important, because some `mat-table` sets `position: sticky !important`. See #22781.
      "position"
    ]);
    PreviewRef = class {
      _document;
      _rootElement;
      _direction;
      _initialDomRect;
      _previewTemplate;
      _previewClass;
      _pickupPositionOnPage;
      _initialTransform;
      _zIndex;
      _renderer;
      /** Reference to the view of the preview element. */
      _previewEmbeddedView;
      /** Reference to the preview element. */
      _preview;
      get element() {
        return this._preview;
      }
      constructor(_document2, _rootElement, _direction, _initialDomRect, _previewTemplate, _previewClass, _pickupPositionOnPage, _initialTransform, _zIndex, _renderer) {
        this._document = _document2;
        this._rootElement = _rootElement;
        this._direction = _direction;
        this._initialDomRect = _initialDomRect;
        this._previewTemplate = _previewTemplate;
        this._previewClass = _previewClass;
        this._pickupPositionOnPage = _pickupPositionOnPage;
        this._initialTransform = _initialTransform;
        this._zIndex = _zIndex;
        this._renderer = _renderer;
      }
      attach(parent) {
        this._preview = this._createPreview();
        parent.appendChild(this._preview);
        if (supportsPopover(this._preview)) {
          this._preview["showPopover"]();
        }
      }
      destroy() {
        this._preview.remove();
        this._previewEmbeddedView?.destroy();
        this._preview = this._previewEmbeddedView = null;
      }
      setTransform(value) {
        this._preview.style.transform = value;
      }
      getBoundingClientRect() {
        return this._preview.getBoundingClientRect();
      }
      addClass(className) {
        this._preview.classList.add(className);
      }
      getTransitionDuration() {
        return getTransformTransitionDurationInMs(this._preview);
      }
      addEventListener(name2, handler) {
        return this._renderer.listen(this._preview, name2, handler);
      }
      _createPreview() {
        const previewConfig = this._previewTemplate;
        const previewClass = this._previewClass;
        const previewTemplate = previewConfig ? previewConfig.template : null;
        let preview;
        if (previewTemplate && previewConfig) {
          const rootRect = previewConfig.matchSize ? this._initialDomRect : null;
          const viewRef = previewConfig.viewContainer.createEmbeddedView(previewTemplate, previewConfig.context);
          viewRef.detectChanges();
          preview = getRootNode(viewRef, this._document);
          this._previewEmbeddedView = viewRef;
          if (previewConfig.matchSize) {
            matchElementSize(preview, rootRect);
          } else {
            preview.style.transform = getTransform(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);
          }
        } else {
          preview = deepCloneNode(this._rootElement);
          matchElementSize(preview, this._initialDomRect);
          if (this._initialTransform) {
            preview.style.transform = this._initialTransform;
          }
        }
        extendStyles(preview.style, {
          // It's important that we disable the pointer events on the preview, because
          // it can throw off the `document.elementFromPoint` calls in the `CdkDropList`.
          "pointer-events": "none",
          // If the preview has a margin, it can throw off our positioning so we reset it. The reset
          // value for `margin-right` needs to be `auto` when opened as a popover, because our
          // positioning is always top/left based, but native popover seems to position itself
          // to the top/right if `<html>` or `<body>` have `dir="rtl"` (see #29604). Setting it
          // to `auto` pushed it to the top/left corner in RTL and is a noop in LTR.
          "margin": supportsPopover(preview) ? "0 auto 0 0" : "0",
          "position": "fixed",
          "top": "0",
          "left": "0",
          "z-index": this._zIndex + ""
        }, importantProperties);
        toggleNativeDragInteractions(preview, false);
        preview.classList.add("cdk-drag-preview");
        preview.setAttribute("popover", "manual");
        preview.setAttribute("dir", this._direction);
        if (previewClass) {
          if (Array.isArray(previewClass)) {
            previewClass.forEach((className) => preview.classList.add(className));
          } else {
            preview.classList.add(previewClass);
          }
        }
        return preview;
      }
    };
    passiveEventListenerOptions = {
      passive: true
    };
    activeEventListenerOptions = {
      passive: false
    };
    activeCapturingEventOptions$1 = {
      passive: false,
      capture: true
    };
    MOUSE_EVENT_IGNORE_TIME = 800;
    PLACEHOLDER_CLASS = "cdk-drag-placeholder";
    dragImportantProperties = /* @__PURE__ */ new Set([
      // Needs to be important, because some `mat-table` sets `position: sticky !important`. See #22781.
      "position"
    ]);
    DragRef = class {
      _config;
      _document;
      _ngZone;
      _viewportRuler;
      _dragDropRegistry;
      _renderer;
      _rootElementCleanups;
      _cleanupShadowRootSelectStart;
      /** Element displayed next to the user's pointer while the element is dragged. */
      _preview;
      /** Container into which to insert the preview. */
      _previewContainer;
      /** Reference to the view of the placeholder element. */
      _placeholderRef;
      /** Element that is rendered instead of the draggable item while it is being sorted. */
      _placeholder;
      /** Coordinates within the element at which the user picked up the element. */
      _pickupPositionInElement;
      /** Coordinates on the page at which the user picked up the element. */
      _pickupPositionOnPage;
      /**
       * Marker node used to save the place in the DOM where the element was
       * picked up so that it can be restored at the end of the drag sequence.
       */
      _marker;
      /**
       * Element indicating the position from which the item was picked up initially.
       */
      _anchor = null;
      /**
       * CSS `transform` applied to the element when it isn't being dragged. We need a
       * passive transform in order for the dragged element to retain its new position
       * after the user has stopped dragging and because we need to know the relative
       * position in case they start dragging again. This corresponds to `element.style.transform`.
       */
      _passiveTransform = {
        x: 0,
        y: 0
      };
      /** CSS `transform` that is applied to the element while it's being dragged. */
      _activeTransform = {
        x: 0,
        y: 0
      };
      /** Inline `transform` value that the element had before the first dragging sequence. */
      _initialTransform;
      /**
       * Whether the dragging sequence has been started. Doesn't
       * necessarily mean that the element has been moved.
       */
      _hasStartedDragging = signal(false, ...ngDevMode ? [{
        debugName: "_hasStartedDragging"
      }] : []);
      /** Whether the element has moved since the user started dragging it. */
      _hasMoved;
      /** Drop container in which the DragRef resided when dragging began. */
      _initialContainer;
      /** Index at which the item started in its initial container. */
      _initialIndex;
      /** Cached positions of scrollable parent elements. */
      _parentPositions;
      /** Emits when the item is being moved. */
      _moveEvents = new Subject();
      /** Keeps track of the direction in which the user is dragging along each axis. */
      _pointerDirectionDelta;
      /** Pointer position at which the last change in the delta occurred. */
      _pointerPositionAtLastDirectionChange;
      /** Position of the pointer at the last pointer event. */
      _lastKnownPointerPosition;
      /**
       * Root DOM node of the drag instance. This is the element that will
       * be moved around as the user is dragging.
       */
      _rootElement;
      /**
       * Nearest ancestor SVG, relative to which coordinates are calculated if dragging SVGElement
       */
      _ownerSVGElement;
      /**
       * Inline style value of `-webkit-tap-highlight-color` at the time the
       * dragging was started. Used to restore the value once we're done dragging.
       */
      _rootElementTapHighlight;
      /** Subscription to pointer movement events. */
      _pointerMoveSubscription = Subscription.EMPTY;
      /** Subscription to the event that is dispatched when the user lifts their pointer. */
      _pointerUpSubscription = Subscription.EMPTY;
      /** Subscription to the viewport being scrolled. */
      _scrollSubscription = Subscription.EMPTY;
      /** Subscription to the viewport being resized. */
      _resizeSubscription = Subscription.EMPTY;
      /**
       * Time at which the last touch event occurred. Used to avoid firing the same
       * events multiple times on touch devices where the browser will fire a fake
       * mouse event for each touch event, after a certain time.
       */
      _lastTouchEventTime;
      /** Time at which the last dragging sequence was started. */
      _dragStartTime;
      /** Cached reference to the boundary element. */
      _boundaryElement = null;
      /** Whether the native dragging interactions have been enabled on the root element. */
      _nativeInteractionsEnabled = true;
      /** Client rect of the root element when the dragging sequence has started. */
      _initialDomRect;
      /** Cached dimensions of the preview element. Should be read via `_getPreviewRect`. */
      _previewRect;
      /** Cached dimensions of the boundary element. */
      _boundaryRect;
      /** Element that will be used as a template to create the draggable item's preview. */
      _previewTemplate;
      /** Template for placeholder element rendered to show where a draggable would be dropped. */
      _placeholderTemplate;
      /** Elements that can be used to drag the draggable item. */
      _handles = [];
      /** Registered handles that are currently disabled. */
      _disabledHandles = /* @__PURE__ */ new Set();
      /** Droppable container that the draggable is a part of. */
      _dropContainer;
      /** Layout direction of the item. */
      _direction = "ltr";
      /** Ref that the current drag item is nested in. */
      _parentDragRef;
      /**
       * Cached shadow root that the element is placed in. `null` means that the element isn't in
       * the shadow DOM and `undefined` means that it hasn't been resolved yet. Should be read via
       * `_getShadowRoot`, not directly.
       */
      _cachedShadowRoot;
      /** Axis along which dragging is locked. */
      lockAxis;
      /**
       * Amount of milliseconds to wait after the user has put their
       * pointer down before starting to drag the element.
       */
      dragStartDelay = 0;
      /** Class to be added to the preview element. */
      previewClass;
      /**
       * If the parent of the dragged element has a `scale` transform, it can throw off the
       * positioning when the user starts dragging. Use this input to notify the CDK of the scale.
       */
      scale = 1;
      /** Whether starting to drag this element is disabled. */
      get disabled() {
        return this._disabled || !!(this._dropContainer && this._dropContainer.disabled);
      }
      set disabled(value) {
        if (value !== this._disabled) {
          this._disabled = value;
          this._toggleNativeDragInteractions();
          this._handles.forEach((handle) => toggleNativeDragInteractions(handle, value));
        }
      }
      _disabled = false;
      /** Emits as the drag sequence is being prepared. */
      beforeStarted = new Subject();
      /** Emits when the user starts dragging the item. */
      started = new Subject();
      /** Emits when the user has released a drag item, before any animations have started. */
      released = new Subject();
      /** Emits when the user stops dragging an item in the container. */
      ended = new Subject();
      /** Emits when the user has moved the item into a new container. */
      entered = new Subject();
      /** Emits when the user removes the item its container by dragging it into another container. */
      exited = new Subject();
      /** Emits when the user drops the item inside a container. */
      dropped = new Subject();
      /**
       * Emits as the user is dragging the item. Use with caution,
       * because this event will fire for every pixel that the user has dragged.
       */
      moved = this._moveEvents;
      /** Arbitrary data that can be attached to the drag item. */
      data;
      /**
       * Function that can be used to customize the logic of how the position of the drag item
       * is limited while it's being dragged. Gets called with a point containing the current position
       * of the user's pointer on the page, a reference to the item being dragged and its dimensions.
       * Should return a point describing where the item should be rendered.
       */
      constrainPosition;
      constructor(element, _config, _document2, _ngZone, _viewportRuler, _dragDropRegistry, _renderer) {
        this._config = _config;
        this._document = _document2;
        this._ngZone = _ngZone;
        this._viewportRuler = _viewportRuler;
        this._dragDropRegistry = _dragDropRegistry;
        this._renderer = _renderer;
        this.withRootElement(element).withParent(_config.parentDragRef || null);
        this._parentPositions = new ParentPositionTracker(_document2);
        _dragDropRegistry.registerDragItem(this);
      }
      /**
       * Returns the element that is being used as a placeholder
       * while the current element is being dragged.
       */
      getPlaceholderElement() {
        return this._placeholder;
      }
      /** Returns the root draggable element. */
      getRootElement() {
        return this._rootElement;
      }
      /**
       * Gets the currently-visible element that represents the drag item.
       * While dragging this is the placeholder, otherwise it's the root element.
       */
      getVisibleElement() {
        return this.isDragging() ? this.getPlaceholderElement() : this.getRootElement();
      }
      /** Registers the handles that can be used to drag the element. */
      withHandles(handles) {
        this._handles = handles.map((handle) => coerceElement(handle));
        this._handles.forEach((handle) => toggleNativeDragInteractions(handle, this.disabled));
        this._toggleNativeDragInteractions();
        const disabledHandles = /* @__PURE__ */ new Set();
        this._disabledHandles.forEach((handle) => {
          if (this._handles.indexOf(handle) > -1) {
            disabledHandles.add(handle);
          }
        });
        this._disabledHandles = disabledHandles;
        return this;
      }
      /**
       * Registers the template that should be used for the drag preview.
       * @param template Template that from which to stamp out the preview.
       */
      withPreviewTemplate(template) {
        this._previewTemplate = template;
        return this;
      }
      /**
       * Registers the template that should be used for the drag placeholder.
       * @param template Template that from which to stamp out the placeholder.
       */
      withPlaceholderTemplate(template) {
        this._placeholderTemplate = template;
        return this;
      }
      /**
       * Sets an alternate drag root element. The root element is the element that will be moved as
       * the user is dragging. Passing an alternate root element is useful when trying to enable
       * dragging on an element that you might not have access to.
       */
      withRootElement(rootElement) {
        const element = coerceElement(rootElement);
        if (element !== this._rootElement) {
          this._removeRootElementListeners();
          const renderer = this._renderer;
          this._rootElementCleanups = this._ngZone.runOutsideAngular(() => [renderer.listen(element, "mousedown", this._pointerDown, activeEventListenerOptions), renderer.listen(element, "touchstart", this._pointerDown, passiveEventListenerOptions), renderer.listen(element, "dragstart", this._nativeDragStart, activeEventListenerOptions)]);
          this._initialTransform = void 0;
          this._rootElement = element;
        }
        if (typeof SVGElement !== "undefined" && this._rootElement instanceof SVGElement) {
          this._ownerSVGElement = this._rootElement.ownerSVGElement;
        }
        return this;
      }
      /**
       * Element to which the draggable's position will be constrained.
       */
      withBoundaryElement(boundaryElement) {
        this._boundaryElement = boundaryElement ? coerceElement(boundaryElement) : null;
        this._resizeSubscription.unsubscribe();
        if (boundaryElement) {
          this._resizeSubscription = this._viewportRuler.change(10).subscribe(() => this._containInsideBoundaryOnResize());
        }
        return this;
      }
      /** Sets the parent ref that the ref is nested in.  */
      withParent(parent) {
        this._parentDragRef = parent;
        return this;
      }
      /** Removes the dragging functionality from the DOM element. */
      dispose() {
        this._removeRootElementListeners();
        if (this.isDragging()) {
          this._rootElement?.remove();
        }
        this._marker?.remove();
        this._destroyPreview();
        this._destroyPlaceholder();
        this._dragDropRegistry.removeDragItem(this);
        this._removeListeners();
        this.beforeStarted.complete();
        this.started.complete();
        this.released.complete();
        this.ended.complete();
        this.entered.complete();
        this.exited.complete();
        this.dropped.complete();
        this._moveEvents.complete();
        this._handles = [];
        this._disabledHandles.clear();
        this._dropContainer = void 0;
        this._resizeSubscription.unsubscribe();
        this._parentPositions.clear();
        this._boundaryElement = this._rootElement = this._ownerSVGElement = this._placeholderTemplate = this._previewTemplate = this._marker = this._parentDragRef = null;
      }
      /** Checks whether the element is currently being dragged. */
      isDragging() {
        return this._hasStartedDragging() && this._dragDropRegistry.isDragging(this);
      }
      /** Resets a standalone drag item to its initial position. */
      reset() {
        this._rootElement.style.transform = this._initialTransform || "";
        this._activeTransform = {
          x: 0,
          y: 0
        };
        this._passiveTransform = {
          x: 0,
          y: 0
        };
      }
      /** Resets drag item to end of boundary element. */
      resetToBoundary() {
        if (
          // can be null if the drag item was never dragged.
          this._boundaryElement && this._rootElement && // check if we are overflowing off our boundary element
          isOverflowingParent(this._boundaryElement.getBoundingClientRect(), this._rootElement.getBoundingClientRect())
        ) {
          const parentRect = this._boundaryElement.getBoundingClientRect();
          const childRect = this._rootElement.getBoundingClientRect();
          let offsetX = 0;
          let offsetY = 0;
          if (childRect.left < parentRect.left) {
            offsetX = parentRect.left - childRect.left;
          } else if (childRect.right > parentRect.right) {
            offsetX = parentRect.right - childRect.right;
          }
          if (childRect.top < parentRect.top) {
            offsetY = parentRect.top - childRect.top;
          } else if (childRect.bottom > parentRect.bottom) {
            offsetY = parentRect.bottom - childRect.bottom;
          }
          const currentLeft = this._activeTransform.x;
          const currentTop = this._activeTransform.y;
          let x = currentLeft + offsetX, y = currentTop + offsetY;
          this._rootElement.style.transform = getTransform(x, y);
          this._activeTransform = {
            x,
            y
          };
          this._passiveTransform = {
            x,
            y
          };
        }
      }
      /**
       * Sets a handle as disabled. While a handle is disabled, it'll capture and interrupt dragging.
       * @param handle Handle element that should be disabled.
       */
      disableHandle(handle) {
        if (!this._disabledHandles.has(handle) && this._handles.indexOf(handle) > -1) {
          this._disabledHandles.add(handle);
          toggleNativeDragInteractions(handle, true);
        }
      }
      /**
       * Enables a handle, if it has been disabled.
       * @param handle Handle element to be enabled.
       */
      enableHandle(handle) {
        if (this._disabledHandles.has(handle)) {
          this._disabledHandles.delete(handle);
          toggleNativeDragInteractions(handle, this.disabled);
        }
      }
      /** Sets the layout direction of the draggable item. */
      withDirection(direction) {
        this._direction = direction;
        return this;
      }
      /** Sets the container that the item is part of. */
      _withDropContainer(container) {
        this._dropContainer = container;
      }
      /**
       * Gets the current position in pixels the draggable outside of a drop container.
       */
      getFreeDragPosition() {
        const position = this.isDragging() ? this._activeTransform : this._passiveTransform;
        return {
          x: position.x,
          y: position.y
        };
      }
      /**
       * Sets the current position in pixels the draggable outside of a drop container.
       * @param value New position to be set.
       */
      setFreeDragPosition(value) {
        this._activeTransform = {
          x: 0,
          y: 0
        };
        this._passiveTransform.x = value.x;
        this._passiveTransform.y = value.y;
        if (!this._dropContainer) {
          this._applyRootElementTransform(value.x, value.y);
        }
        return this;
      }
      /**
       * Sets the container into which to insert the preview element.
       * @param value Container into which to insert the preview.
       */
      withPreviewContainer(value) {
        this._previewContainer = value;
        return this;
      }
      /** Updates the item's sort order based on the last-known pointer position. */
      _sortFromLastPointerPosition() {
        const position = this._lastKnownPointerPosition;
        if (position && this._dropContainer) {
          this._updateActiveDropContainer(this._getConstrainedPointerPosition(position), position);
        }
      }
      /** Unsubscribes from the global subscriptions. */
      _removeListeners() {
        this._pointerMoveSubscription.unsubscribe();
        this._pointerUpSubscription.unsubscribe();
        this._scrollSubscription.unsubscribe();
        this._cleanupShadowRootSelectStart?.();
        this._cleanupShadowRootSelectStart = void 0;
      }
      /** Destroys the preview element and its ViewRef. */
      _destroyPreview() {
        this._preview?.destroy();
        this._preview = null;
      }
      /** Destroys the placeholder element and its ViewRef. */
      _destroyPlaceholder() {
        this._anchor?.remove();
        this._placeholder?.remove();
        this._placeholderRef?.destroy();
        this._placeholder = this._anchor = this._placeholderRef = null;
      }
      /** Handler for the `mousedown`/`touchstart` events. */
      _pointerDown = (event) => {
        this.beforeStarted.next();
        if (this._handles.length) {
          const targetHandle = this._getTargetHandle(event);
          if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {
            this._initializeDragSequence(targetHandle, event);
          }
        } else if (!this.disabled) {
          this._initializeDragSequence(this._rootElement, event);
        }
      };
      /** Handler that is invoked when the user moves their pointer after they've initiated a drag. */
      _pointerMove = (event) => {
        const pointerPosition = this._getPointerPositionOnPage(event);
        if (!this._hasStartedDragging()) {
          const distanceX = Math.abs(pointerPosition.x - this._pickupPositionOnPage.x);
          const distanceY = Math.abs(pointerPosition.y - this._pickupPositionOnPage.y);
          const isOverThreshold = distanceX + distanceY >= this._config.dragStartThreshold;
          if (isOverThreshold) {
            const isDelayElapsed = Date.now() >= this._dragStartTime + this._getDragStartDelay(event);
            const container = this._dropContainer;
            if (!isDelayElapsed) {
              this._endDragSequence(event);
              return;
            }
            if (!container || !container.isDragging() && !container.isReceiving()) {
              if (event.cancelable) {
                event.preventDefault();
              }
              this._hasStartedDragging.set(true);
              this._ngZone.run(() => this._startDragSequence(event));
            }
          }
          return;
        }
        if (event.cancelable) {
          event.preventDefault();
        }
        const constrainedPointerPosition = this._getConstrainedPointerPosition(pointerPosition);
        this._hasMoved = true;
        this._lastKnownPointerPosition = pointerPosition;
        this._updatePointerDirectionDelta(constrainedPointerPosition);
        if (this._dropContainer) {
          this._updateActiveDropContainer(constrainedPointerPosition, pointerPosition);
        } else {
          const offset = this.constrainPosition ? this._initialDomRect : this._pickupPositionOnPage;
          const activeTransform = this._activeTransform;
          activeTransform.x = constrainedPointerPosition.x - offset.x + this._passiveTransform.x;
          activeTransform.y = constrainedPointerPosition.y - offset.y + this._passiveTransform.y;
          this._applyRootElementTransform(activeTransform.x, activeTransform.y);
        }
        if (this._moveEvents.observers.length) {
          this._ngZone.run(() => {
            this._moveEvents.next({
              source: this,
              pointerPosition: constrainedPointerPosition,
              event,
              distance: this._getDragDistance(constrainedPointerPosition),
              delta: this._pointerDirectionDelta
            });
          });
        }
      };
      /** Handler that is invoked when the user lifts their pointer up, after initiating a drag. */
      _pointerUp = (event) => {
        this._endDragSequence(event);
      };
      /**
       * Clears subscriptions and stops the dragging sequence.
       * @param event Browser event object that ended the sequence.
       */
      _endDragSequence(event) {
        if (!this._dragDropRegistry.isDragging(this)) {
          return;
        }
        this._removeListeners();
        this._dragDropRegistry.stopDragging(this);
        this._toggleNativeDragInteractions();
        if (this._handles) {
          this._rootElement.style.webkitTapHighlightColor = this._rootElementTapHighlight;
        }
        if (!this._hasStartedDragging()) {
          return;
        }
        this.released.next({
          source: this,
          event
        });
        if (this._dropContainer) {
          this._dropContainer._stopScrolling();
          this._animatePreviewToPlaceholder().then(() => {
            this._cleanupDragArtifacts(event);
            this._cleanupCachedDimensions();
            this._dragDropRegistry.stopDragging(this);
          });
        } else {
          this._passiveTransform.x = this._activeTransform.x;
          const pointerPosition = this._getPointerPositionOnPage(event);
          this._passiveTransform.y = this._activeTransform.y;
          this._ngZone.run(() => {
            this.ended.next({
              source: this,
              distance: this._getDragDistance(pointerPosition),
              dropPoint: pointerPosition,
              event
            });
          });
          this._cleanupCachedDimensions();
          this._dragDropRegistry.stopDragging(this);
        }
      }
      /** Starts the dragging sequence. */
      _startDragSequence(event) {
        if (isTouchEvent(event)) {
          this._lastTouchEventTime = Date.now();
        }
        this._toggleNativeDragInteractions();
        const shadowRoot = this._getShadowRoot();
        const dropContainer = this._dropContainer;
        if (shadowRoot) {
          this._ngZone.runOutsideAngular(() => {
            this._cleanupShadowRootSelectStart = this._renderer.listen(shadowRoot, "selectstart", shadowDomSelectStart, activeCapturingEventOptions$1);
          });
        }
        if (dropContainer) {
          const element = this._rootElement;
          const parent = element.parentNode;
          const placeholder = this._placeholder = this._createPlaceholderElement();
          const marker = this._marker = this._marker || this._document.createComment(typeof ngDevMode === "undefined" || ngDevMode ? "cdk-drag-marker" : "");
          parent.insertBefore(marker, element);
          this._initialTransform = element.style.transform || "";
          this._preview = new PreviewRef(this._document, this._rootElement, this._direction, this._initialDomRect, this._previewTemplate || null, this.previewClass || null, this._pickupPositionOnPage, this._initialTransform, this._config.zIndex || 1e3, this._renderer);
          this._preview.attach(this._getPreviewInsertionPoint(parent, shadowRoot));
          toggleVisibility(element, false, dragImportantProperties);
          this._document.body.appendChild(parent.replaceChild(placeholder, element));
          this.started.next({
            source: this,
            event
          });
          dropContainer.start();
          this._initialContainer = dropContainer;
          this._initialIndex = dropContainer.getItemIndex(this);
        } else {
          this.started.next({
            source: this,
            event
          });
          this._initialContainer = this._initialIndex = void 0;
        }
        this._parentPositions.cache(dropContainer ? dropContainer.getScrollableParents() : []);
      }
      /**
       * Sets up the different variables and subscriptions
       * that will be necessary for the dragging sequence.
       * @param referenceElement Element that started the drag sequence.
       * @param event Browser event object that started the sequence.
       */
      _initializeDragSequence(referenceElement, event) {
        if (this._parentDragRef) {
          event.stopPropagation();
        }
        const isDragging = this.isDragging();
        const isTouchSequence = isTouchEvent(event);
        const isAuxiliaryMouseButton = !isTouchSequence && event.button !== 0;
        const rootElement = this._rootElement;
        const target = _getEventTarget(event);
        const isSyntheticEvent = !isTouchSequence && this._lastTouchEventTime && this._lastTouchEventTime + MOUSE_EVENT_IGNORE_TIME > Date.now();
        const isFakeEvent = isTouchSequence ? isFakeTouchstartFromScreenReader(event) : isFakeMousedownFromScreenReader(event);
        if (target && target.draggable && event.type === "mousedown") {
          event.preventDefault();
        }
        if (isDragging || isAuxiliaryMouseButton || isSyntheticEvent || isFakeEvent) {
          return;
        }
        if (this._handles.length) {
          const rootStyles = rootElement.style;
          this._rootElementTapHighlight = rootStyles.webkitTapHighlightColor || "";
          rootStyles.webkitTapHighlightColor = "transparent";
        }
        this._hasMoved = false;
        this._hasStartedDragging.set(this._hasMoved);
        this._removeListeners();
        this._initialDomRect = this._rootElement.getBoundingClientRect();
        this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove);
        this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp);
        this._scrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe((scrollEvent) => this._updateOnScroll(scrollEvent));
        if (this._boundaryElement) {
          this._boundaryRect = getMutableClientRect(this._boundaryElement);
        }
        const previewTemplate = this._previewTemplate;
        this._pickupPositionInElement = previewTemplate && previewTemplate.template && !previewTemplate.matchSize ? {
          x: 0,
          y: 0
        } : this._getPointerPositionInElement(this._initialDomRect, referenceElement, event);
        const pointerPosition = this._pickupPositionOnPage = this._lastKnownPointerPosition = this._getPointerPositionOnPage(event);
        this._pointerDirectionDelta = {
          x: 0,
          y: 0
        };
        this._pointerPositionAtLastDirectionChange = {
          x: pointerPosition.x,
          y: pointerPosition.y
        };
        this._dragStartTime = Date.now();
        this._dragDropRegistry.startDragging(this, event);
      }
      /** Cleans up the DOM artifacts that were added to facilitate the element being dragged. */
      _cleanupDragArtifacts(event) {
        toggleVisibility(this._rootElement, true, dragImportantProperties);
        this._marker.parentNode.replaceChild(this._rootElement, this._marker);
        this._destroyPreview();
        this._destroyPlaceholder();
        this._initialDomRect = this._boundaryRect = this._previewRect = this._initialTransform = void 0;
        this._ngZone.run(() => {
          const container = this._dropContainer;
          const currentIndex = container.getItemIndex(this);
          const pointerPosition = this._getPointerPositionOnPage(event);
          const distance = this._getDragDistance(pointerPosition);
          const isPointerOverContainer = container._isOverContainer(pointerPosition.x, pointerPosition.y);
          this.ended.next({
            source: this,
            distance,
            dropPoint: pointerPosition,
            event
          });
          this.dropped.next({
            item: this,
            currentIndex,
            previousIndex: this._initialIndex,
            container,
            previousContainer: this._initialContainer,
            isPointerOverContainer,
            distance,
            dropPoint: pointerPosition,
            event
          });
          container.drop(this, currentIndex, this._initialIndex, this._initialContainer, isPointerOverContainer, distance, pointerPosition, event);
          this._dropContainer = this._initialContainer;
        });
      }
      /**
       * Updates the item's position in its drop container, or moves it
       * into a new one, depending on its current drag position.
       */
      _updateActiveDropContainer({
        x,
        y
      }, {
        x: rawX,
        y: rawY
      }) {
        let newContainer = this._initialContainer._getSiblingContainerFromPosition(this, x, y);
        if (!newContainer && this._dropContainer !== this._initialContainer && this._initialContainer._isOverContainer(x, y)) {
          newContainer = this._initialContainer;
        }
        if (newContainer && newContainer !== this._dropContainer) {
          this._ngZone.run(() => {
            const exitIndex = this._dropContainer.getItemIndex(this);
            const nextItemElement = this._dropContainer.getItemAtIndex(exitIndex + 1)?.getVisibleElement() || null;
            this.exited.next({
              item: this,
              container: this._dropContainer
            });
            this._dropContainer.exit(this);
            this._conditionallyInsertAnchor(newContainer, this._dropContainer, nextItemElement);
            this._dropContainer = newContainer;
            this._dropContainer.enter(
              this,
              x,
              y,
              // If we're re-entering the initial container and sorting is disabled,
              // put item the into its starting index to begin with.
              newContainer === this._initialContainer && newContainer.sortingDisabled ? this._initialIndex : void 0
            );
            this.entered.next({
              item: this,
              container: newContainer,
              currentIndex: newContainer.getItemIndex(this)
            });
          });
        }
        if (this.isDragging()) {
          this._dropContainer._startScrollingIfNecessary(rawX, rawY);
          this._dropContainer._sortItem(this, x, y, this._pointerDirectionDelta);
          if (this.constrainPosition) {
            this._applyPreviewTransform(x, y);
          } else {
            this._applyPreviewTransform(x - this._pickupPositionInElement.x, y - this._pickupPositionInElement.y);
          }
        }
      }
      /**
       * Animates the preview element from its current position to the location of the drop placeholder.
       * @returns Promise that resolves when the animation completes.
       */
      _animatePreviewToPlaceholder() {
        if (!this._hasMoved) {
          return Promise.resolve();
        }
        const placeholderRect = this._placeholder.getBoundingClientRect();
        this._preview.addClass("cdk-drag-animating");
        this._applyPreviewTransform(placeholderRect.left, placeholderRect.top);
        const duration = this._preview.getTransitionDuration();
        if (duration === 0) {
          return Promise.resolve();
        }
        return this._ngZone.runOutsideAngular(() => {
          return new Promise((resolve) => {
            const handler = (event) => {
              if (!event || this._preview && _getEventTarget(event) === this._preview.element && event.propertyName === "transform") {
                cleanupListener();
                resolve();
                clearTimeout(timeout);
              }
            };
            const timeout = setTimeout(handler, duration * 1.5);
            const cleanupListener = this._preview.addEventListener("transitionend", handler);
          });
        });
      }
      /** Creates an element that will be shown instead of the current element while dragging. */
      _createPlaceholderElement() {
        const placeholderConfig = this._placeholderTemplate;
        const placeholderTemplate = placeholderConfig ? placeholderConfig.template : null;
        let placeholder;
        if (placeholderTemplate) {
          this._placeholderRef = placeholderConfig.viewContainer.createEmbeddedView(placeholderTemplate, placeholderConfig.context);
          this._placeholderRef.detectChanges();
          placeholder = getRootNode(this._placeholderRef, this._document);
        } else {
          placeholder = deepCloneNode(this._rootElement);
        }
        placeholder.style.pointerEvents = "none";
        placeholder.classList.add(PLACEHOLDER_CLASS);
        return placeholder;
      }
      /**
       * Figures out the coordinates at which an element was picked up.
       * @param referenceElement Element that initiated the dragging.
       * @param event Event that initiated the dragging.
       */
      _getPointerPositionInElement(elementRect, referenceElement, event) {
        const handleElement = referenceElement === this._rootElement ? null : referenceElement;
        const referenceRect = handleElement ? handleElement.getBoundingClientRect() : elementRect;
        const point = isTouchEvent(event) ? event.targetTouches[0] : event;
        const scrollPosition = this._getViewportScrollPosition();
        const x = point.pageX - referenceRect.left - scrollPosition.left;
        const y = point.pageY - referenceRect.top - scrollPosition.top;
        return {
          x: referenceRect.left - elementRect.left + x,
          y: referenceRect.top - elementRect.top + y
        };
      }
      /** Determines the point of the page that was touched by the user. */
      _getPointerPositionOnPage(event) {
        const scrollPosition = this._getViewportScrollPosition();
        const point = isTouchEvent(event) ? (
          // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.
          // Also note that on real devices we're guaranteed for either `touches` or `changedTouches`
          // to have a value, but Firefox in device emulation mode has a bug where both can be empty
          // for `touchstart` and `touchend` so we fall back to a dummy object in order to avoid
          // throwing an error. The value returned here will be incorrect, but since this only
          // breaks inside a developer tool and the value is only used for secondary information,
          // we can get away with it. See https://bugzilla.mozilla.org/show_bug.cgi?id=1615824.
          event.touches[0] || event.changedTouches[0] || {
            pageX: 0,
            pageY: 0
          }
        ) : event;
        const x = point.pageX - scrollPosition.left;
        const y = point.pageY - scrollPosition.top;
        if (this._ownerSVGElement) {
          const svgMatrix = this._ownerSVGElement.getScreenCTM();
          if (svgMatrix) {
            const svgPoint = this._ownerSVGElement.createSVGPoint();
            svgPoint.x = x;
            svgPoint.y = y;
            return svgPoint.matrixTransform(svgMatrix.inverse());
          }
        }
        return {
          x,
          y
        };
      }
      /** Gets the pointer position on the page, accounting for any position constraints. */
      _getConstrainedPointerPosition(point) {
        const dropContainerLock = this._dropContainer ? this._dropContainer.lockAxis : null;
        let {
          x,
          y
        } = this.constrainPosition ? this.constrainPosition(point, this, this._initialDomRect, this._pickupPositionInElement) : point;
        if (this.lockAxis === "x" || dropContainerLock === "x") {
          y = this._pickupPositionOnPage.y - (this.constrainPosition ? this._pickupPositionInElement.y : 0);
        } else if (this.lockAxis === "y" || dropContainerLock === "y") {
          x = this._pickupPositionOnPage.x - (this.constrainPosition ? this._pickupPositionInElement.x : 0);
        }
        if (this._boundaryRect) {
          const {
            x: pickupX,
            y: pickupY
          } = !this.constrainPosition ? this._pickupPositionInElement : {
            x: 0,
            y: 0
          };
          const boundaryRect = this._boundaryRect;
          const {
            width: previewWidth,
            height: previewHeight
          } = this._getPreviewRect();
          const minY = boundaryRect.top + pickupY;
          const maxY = boundaryRect.bottom - (previewHeight - pickupY);
          const minX = boundaryRect.left + pickupX;
          const maxX = boundaryRect.right - (previewWidth - pickupX);
          x = clamp$1(x, minX, maxX);
          y = clamp$1(y, minY, maxY);
        }
        return {
          x,
          y
        };
      }
      /** Updates the current drag delta, based on the user's current pointer position on the page. */
      _updatePointerDirectionDelta(pointerPositionOnPage) {
        const {
          x,
          y
        } = pointerPositionOnPage;
        const delta = this._pointerDirectionDelta;
        const positionSinceLastChange = this._pointerPositionAtLastDirectionChange;
        const changeX = Math.abs(x - positionSinceLastChange.x);
        const changeY = Math.abs(y - positionSinceLastChange.y);
        if (changeX > this._config.pointerDirectionChangeThreshold) {
          delta.x = x > positionSinceLastChange.x ? 1 : -1;
          positionSinceLastChange.x = x;
        }
        if (changeY > this._config.pointerDirectionChangeThreshold) {
          delta.y = y > positionSinceLastChange.y ? 1 : -1;
          positionSinceLastChange.y = y;
        }
        return delta;
      }
      /** Toggles the native drag interactions, based on how many handles are registered. */
      _toggleNativeDragInteractions() {
        if (!this._rootElement || !this._handles) {
          return;
        }
        const shouldEnable = this._handles.length > 0 || !this.isDragging();
        if (shouldEnable !== this._nativeInteractionsEnabled) {
          this._nativeInteractionsEnabled = shouldEnable;
          toggleNativeDragInteractions(this._rootElement, shouldEnable);
        }
      }
      /** Removes the manually-added event listeners from the root element. */
      _removeRootElementListeners() {
        this._rootElementCleanups?.forEach((cleanup) => cleanup());
        this._rootElementCleanups = void 0;
      }
      /**
       * Applies a `transform` to the root element, taking into account any existing transforms on it.
       * @param x New transform value along the X axis.
       * @param y New transform value along the Y axis.
       */
      _applyRootElementTransform(x, y) {
        const scale = 1 / this.scale;
        const transform = getTransform(x * scale, y * scale);
        const styles = this._rootElement.style;
        if (this._initialTransform == null) {
          this._initialTransform = styles.transform && styles.transform != "none" ? styles.transform : "";
        }
        styles.transform = combineTransforms(transform, this._initialTransform);
      }
      /**
       * Applies a `transform` to the preview, taking into account any existing transforms on it.
       * @param x New transform value along the X axis.
       * @param y New transform value along the Y axis.
       */
      _applyPreviewTransform(x, y) {
        const initialTransform = this._previewTemplate?.template ? void 0 : this._initialTransform;
        const transform = getTransform(x, y);
        this._preview.setTransform(combineTransforms(transform, initialTransform));
      }
      /**
       * Gets the distance that the user has dragged during the current drag sequence.
       * @param currentPosition Current position of the user's pointer.
       */
      _getDragDistance(currentPosition) {
        const pickupPosition = this._pickupPositionOnPage;
        if (pickupPosition) {
          return {
            x: currentPosition.x - pickupPosition.x,
            y: currentPosition.y - pickupPosition.y
          };
        }
        return {
          x: 0,
          y: 0
        };
      }
      /** Cleans up any cached element dimensions that we don't need after dragging has stopped. */
      _cleanupCachedDimensions() {
        this._boundaryRect = this._previewRect = void 0;
        this._parentPositions.clear();
      }
      /**
       * Checks whether the element is still inside its boundary after the viewport has been resized.
       * If not, the position is adjusted so that the element fits again.
       */
      _containInsideBoundaryOnResize() {
        let {
          x,
          y
        } = this._passiveTransform;
        if (x === 0 && y === 0 || this.isDragging() || !this._boundaryElement) {
          return;
        }
        const elementRect = this._rootElement.getBoundingClientRect();
        const boundaryRect = this._boundaryElement.getBoundingClientRect();
        if (boundaryRect.width === 0 && boundaryRect.height === 0 || elementRect.width === 0 && elementRect.height === 0) {
          return;
        }
        const leftOverflow = boundaryRect.left - elementRect.left;
        const rightOverflow = elementRect.right - boundaryRect.right;
        const topOverflow = boundaryRect.top - elementRect.top;
        const bottomOverflow = elementRect.bottom - boundaryRect.bottom;
        if (boundaryRect.width > elementRect.width) {
          if (leftOverflow > 0) {
            x += leftOverflow;
          }
          if (rightOverflow > 0) {
            x -= rightOverflow;
          }
        } else {
          x = 0;
        }
        if (boundaryRect.height > elementRect.height) {
          if (topOverflow > 0) {
            y += topOverflow;
          }
          if (bottomOverflow > 0) {
            y -= bottomOverflow;
          }
        } else {
          y = 0;
        }
        if (x !== this._passiveTransform.x || y !== this._passiveTransform.y) {
          this.setFreeDragPosition({
            y,
            x
          });
        }
      }
      /** Gets the drag start delay, based on the event type. */
      _getDragStartDelay(event) {
        const value = this.dragStartDelay;
        if (typeof value === "number") {
          return value;
        } else if (isTouchEvent(event)) {
          return value.touch;
        }
        return value ? value.mouse : 0;
      }
      /** Updates the internal state of the draggable element when scrolling has occurred. */
      _updateOnScroll(event) {
        const scrollDifference = this._parentPositions.handleScroll(event);
        if (scrollDifference) {
          const target = _getEventTarget(event);
          if (this._boundaryRect && target !== this._boundaryElement && target.contains(this._boundaryElement)) {
            adjustDomRect(this._boundaryRect, scrollDifference.top, scrollDifference.left);
          }
          this._pickupPositionOnPage.x += scrollDifference.left;
          this._pickupPositionOnPage.y += scrollDifference.top;
          if (!this._dropContainer) {
            this._activeTransform.x -= scrollDifference.left;
            this._activeTransform.y -= scrollDifference.top;
            this._applyRootElementTransform(this._activeTransform.x, this._activeTransform.y);
          }
        }
      }
      /** Gets the scroll position of the viewport. */
      _getViewportScrollPosition() {
        return this._parentPositions.positions.get(this._document)?.scrollPosition || this._parentPositions.getViewportScrollPosition();
      }
      /**
       * Lazily resolves and returns the shadow root of the element. We do this in a function, rather
       * than saving it in property directly on init, because we want to resolve it as late as possible
       * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the
       * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.
       */
      _getShadowRoot() {
        if (this._cachedShadowRoot === void 0) {
          this._cachedShadowRoot = _getShadowRoot(this._rootElement);
        }
        return this._cachedShadowRoot;
      }
      /** Gets the element into which the drag preview should be inserted. */
      _getPreviewInsertionPoint(initialParent, shadowRoot) {
        const previewContainer = this._previewContainer || "global";
        if (previewContainer === "parent") {
          return initialParent;
        }
        if (previewContainer === "global") {
          const documentRef = this._document;
          return shadowRoot || documentRef.fullscreenElement || documentRef.webkitFullscreenElement || documentRef.mozFullScreenElement || documentRef.msFullscreenElement || documentRef.body;
        }
        return coerceElement(previewContainer);
      }
      /** Lazily resolves and returns the dimensions of the preview. */
      _getPreviewRect() {
        if (!this._previewRect || !this._previewRect.width && !this._previewRect.height) {
          this._previewRect = this._preview ? this._preview.getBoundingClientRect() : this._initialDomRect;
        }
        return this._previewRect;
      }
      /** Handles a native `dragstart` event. */
      _nativeDragStart = (event) => {
        if (this._handles.length) {
          const targetHandle = this._getTargetHandle(event);
          if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {
            event.preventDefault();
          }
        } else if (!this.disabled) {
          event.preventDefault();
        }
      };
      /** Gets a handle that is the target of an event. */
      _getTargetHandle(event) {
        return this._handles.find((handle) => {
          return event.target && (event.target === handle || handle.contains(event.target));
        });
      }
      /** Inserts the anchor element, if it's valid. */
      _conditionallyInsertAnchor(newContainer, exitContainer, nextItemElement) {
        if (newContainer === this._initialContainer) {
          this._anchor?.remove();
          this._anchor = null;
        } else if (exitContainer === this._initialContainer && exitContainer.hasAnchor) {
          const anchor = this._anchor ??= deepCloneNode(this._placeholder);
          anchor.classList.remove(PLACEHOLDER_CLASS);
          anchor.classList.add("cdk-drag-anchor");
          anchor.style.transform = "";
          if (nextItemElement) {
            nextItemElement.before(anchor);
          } else {
            coerceElement(exitContainer.element).appendChild(anchor);
          }
        }
      }
    };
    SingleAxisSortStrategy = class {
      _dragDropRegistry;
      /** Root element container of the drop list. */
      _element;
      /** Function used to determine if an item can be sorted into a specific index. */
      _sortPredicate;
      /** Cache of the dimensions of all the items inside the container. */
      _itemPositions = [];
      /**
       * Draggable items that are currently active inside the container. Includes the items
       * that were there at the start of the sequence, as well as any items that have been dragged
       * in, but haven't been dropped yet.
       */
      _activeDraggables;
      /** Direction in which the list is oriented. */
      orientation = "vertical";
      /** Layout direction of the drop list. */
      direction;
      constructor(_dragDropRegistry) {
        this._dragDropRegistry = _dragDropRegistry;
      }
      /**
       * Keeps track of the item that was last swapped with the dragged item, as well as what direction
       * the pointer was moving in when the swap occurred and whether the user's pointer continued to
       * overlap with the swapped item after the swapping occurred.
       */
      _previousSwap = {
        drag: null,
        delta: 0,
        overlaps: false
      };
      /**
       * To be called when the drag sequence starts.
       * @param items Items that are currently in the list.
       */
      start(items) {
        this.withItems(items);
      }
      /**
       * To be called when an item is being sorted.
       * @param item Item to be sorted.
       * @param pointerX Position of the item along the X axis.
       * @param pointerY Position of the item along the Y axis.
       * @param pointerDelta Direction in which the pointer is moving along each axis.
       */
      sort(item, pointerX, pointerY, pointerDelta) {
        const siblings = this._itemPositions;
        const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);
        if (newIndex === -1 && siblings.length > 0) {
          return null;
        }
        const isHorizontal = this.orientation === "horizontal";
        const currentIndex = siblings.findIndex((currentItem) => currentItem.drag === item);
        const siblingAtNewPosition = siblings[newIndex];
        const currentPosition = siblings[currentIndex].clientRect;
        const newPosition = siblingAtNewPosition.clientRect;
        const delta = currentIndex > newIndex ? 1 : -1;
        const itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);
        const siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);
        const oldOrder = siblings.slice();
        moveItemInArray(siblings, currentIndex, newIndex);
        siblings.forEach((sibling, index) => {
          if (oldOrder[index] === sibling) {
            return;
          }
          const isDraggedItem = sibling.drag === item;
          const offset = isDraggedItem ? itemOffset : siblingOffset;
          const elementToOffset = isDraggedItem ? item.getPlaceholderElement() : sibling.drag.getRootElement();
          sibling.offset += offset;
          const transformAmount = Math.round(sibling.offset * (1 / sibling.drag.scale));
          if (isHorizontal) {
            elementToOffset.style.transform = combineTransforms(`translate3d(${transformAmount}px, 0, 0)`, sibling.initialTransform);
            adjustDomRect(sibling.clientRect, 0, offset);
          } else {
            elementToOffset.style.transform = combineTransforms(`translate3d(0, ${transformAmount}px, 0)`, sibling.initialTransform);
            adjustDomRect(sibling.clientRect, offset, 0);
          }
        });
        this._previousSwap.overlaps = isInsideClientRect(newPosition, pointerX, pointerY);
        this._previousSwap.drag = siblingAtNewPosition.drag;
        this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;
        return {
          previousIndex: currentIndex,
          currentIndex: newIndex
        };
      }
      /**
       * Called when an item is being moved into the container.
       * @param item Item that was moved into the container.
       * @param pointerX Position of the item along the X axis.
       * @param pointerY Position of the item along the Y axis.
       * @param index Index at which the item entered. If omitted, the container will try to figure it
       *   out automatically.
       */
      enter(item, pointerX, pointerY, index) {
        const newIndex = index == null || index < 0 ? (
          // We use the coordinates of where the item entered the drop
          // zone to figure out at which index it should be inserted.
          this._getItemIndexFromPointerPosition(item, pointerX, pointerY)
        ) : index;
        const activeDraggables = this._activeDraggables;
        const currentIndex = activeDraggables.indexOf(item);
        const placeholder = item.getPlaceholderElement();
        let newPositionReference = activeDraggables[newIndex];
        if (newPositionReference === item) {
          newPositionReference = activeDraggables[newIndex + 1];
        }
        if (!newPositionReference && (newIndex == null || newIndex === -1 || newIndex < activeDraggables.length - 1) && this._shouldEnterAsFirstChild(pointerX, pointerY)) {
          newPositionReference = activeDraggables[0];
        }
        if (currentIndex > -1) {
          activeDraggables.splice(currentIndex, 1);
        }
        if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {
          const element = newPositionReference.getRootElement();
          element.parentElement.insertBefore(placeholder, element);
          activeDraggables.splice(newIndex, 0, item);
        } else {
          this._element.appendChild(placeholder);
          activeDraggables.push(item);
        }
        placeholder.style.transform = "";
        this._cacheItemPositions();
      }
      /** Sets the items that are currently part of the list. */
      withItems(items) {
        this._activeDraggables = items.slice();
        this._cacheItemPositions();
      }
      /** Assigns a sort predicate to the strategy. */
      withSortPredicate(predicate) {
        this._sortPredicate = predicate;
      }
      /** Resets the strategy to its initial state before dragging was started. */
      reset() {
        this._activeDraggables?.forEach((item) => {
          const rootElement = item.getRootElement();
          if (rootElement) {
            const initialTransform = this._itemPositions.find((p) => p.drag === item)?.initialTransform;
            rootElement.style.transform = initialTransform || "";
          }
        });
        this._itemPositions = [];
        this._activeDraggables = [];
        this._previousSwap.drag = null;
        this._previousSwap.delta = 0;
        this._previousSwap.overlaps = false;
      }
      /**
       * Gets a snapshot of items currently in the list.
       * Can include items that we dragged in from another list.
       */
      getActiveItemsSnapshot() {
        return this._activeDraggables;
      }
      /** Gets the index of a specific item. */
      getItemIndex(item) {
        return this._getVisualItemPositions().findIndex((currentItem) => currentItem.drag === item);
      }
      /** Gets the item at a specific index. */
      getItemAtIndex(index) {
        return this._getVisualItemPositions()[index]?.drag || null;
      }
      /** Used to notify the strategy that the scroll position has changed. */
      updateOnScroll(topDifference, leftDifference) {
        this._itemPositions.forEach(({
          clientRect
        }) => {
          adjustDomRect(clientRect, topDifference, leftDifference);
        });
        this._itemPositions.forEach(({
          drag
        }) => {
          if (this._dragDropRegistry.isDragging(drag)) {
            drag._sortFromLastPointerPosition();
          }
        });
      }
      withElementContainer(container) {
        this._element = container;
      }
      /** Refreshes the position cache of the items and sibling containers. */
      _cacheItemPositions() {
        const isHorizontal = this.orientation === "horizontal";
        this._itemPositions = this._activeDraggables.map((drag) => {
          const elementToMeasure = drag.getVisibleElement();
          return {
            drag,
            offset: 0,
            initialTransform: elementToMeasure.style.transform || "",
            clientRect: getMutableClientRect(elementToMeasure)
          };
        }).sort((a, b) => {
          return isHorizontal ? a.clientRect.left - b.clientRect.left : a.clientRect.top - b.clientRect.top;
        });
      }
      _getVisualItemPositions() {
        return this.orientation === "horizontal" && this.direction === "rtl" ? this._itemPositions.slice().reverse() : this._itemPositions;
      }
      /**
       * Gets the offset in pixels by which the item that is being dragged should be moved.
       * @param currentPosition Current position of the item.
       * @param newPosition Position of the item where the current item should be moved.
       * @param delta Direction in which the user is moving.
       */
      _getItemOffsetPx(currentPosition, newPosition, delta) {
        const isHorizontal = this.orientation === "horizontal";
        let itemOffset = isHorizontal ? newPosition.left - currentPosition.left : newPosition.top - currentPosition.top;
        if (delta === -1) {
          itemOffset += isHorizontal ? newPosition.width - currentPosition.width : newPosition.height - currentPosition.height;
        }
        return itemOffset;
      }
      /**
       * Gets the offset in pixels by which the items that aren't being dragged should be moved.
       * @param currentIndex Index of the item currently being dragged.
       * @param siblings All of the items in the list.
       * @param delta Direction in which the user is moving.
       */
      _getSiblingOffsetPx(currentIndex, siblings, delta) {
        const isHorizontal = this.orientation === "horizontal";
        const currentPosition = siblings[currentIndex].clientRect;
        const immediateSibling = siblings[currentIndex + delta * -1];
        let siblingOffset = currentPosition[isHorizontal ? "width" : "height"] * delta;
        if (immediateSibling) {
          const start = isHorizontal ? "left" : "top";
          const end = isHorizontal ? "right" : "bottom";
          if (delta === -1) {
            siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];
          } else {
            siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];
          }
        }
        return siblingOffset;
      }
      /**
       * Checks if pointer is entering in the first position
       * @param pointerX Position of the user's pointer along the X axis.
       * @param pointerY Position of the user's pointer along the Y axis.
       */
      _shouldEnterAsFirstChild(pointerX, pointerY) {
        if (!this._activeDraggables.length) {
          return false;
        }
        const itemPositions = this._itemPositions;
        const isHorizontal = this.orientation === "horizontal";
        const reversed = itemPositions[0].drag !== this._activeDraggables[0];
        if (reversed) {
          const lastItemRect = itemPositions[itemPositions.length - 1].clientRect;
          return isHorizontal ? pointerX >= lastItemRect.right : pointerY >= lastItemRect.bottom;
        } else {
          const firstItemRect = itemPositions[0].clientRect;
          return isHorizontal ? pointerX <= firstItemRect.left : pointerY <= firstItemRect.top;
        }
      }
      /**
       * Gets the index of an item in the drop container, based on the position of the user's pointer.
       * @param item Item that is being sorted.
       * @param pointerX Position of the user's pointer along the X axis.
       * @param pointerY Position of the user's pointer along the Y axis.
       * @param delta Direction in which the user is moving their pointer.
       */
      _getItemIndexFromPointerPosition(item, pointerX, pointerY, delta) {
        const isHorizontal = this.orientation === "horizontal";
        const index = this._itemPositions.findIndex(({
          drag,
          clientRect
        }) => {
          if (drag === item) {
            return false;
          }
          if (delta) {
            const direction = isHorizontal ? delta.x : delta.y;
            if (drag === this._previousSwap.drag && this._previousSwap.overlaps && direction === this._previousSwap.delta) {
              return false;
            }
          }
          return isHorizontal ? (
            // Round these down since most browsers report client rects with
            // sub-pixel precision, whereas the pointer coordinates are rounded to pixels.
            pointerX >= Math.floor(clientRect.left) && pointerX < Math.floor(clientRect.right)
          ) : pointerY >= Math.floor(clientRect.top) && pointerY < Math.floor(clientRect.bottom);
        });
        return index === -1 || !this._sortPredicate(index, item) ? -1 : index;
      }
    };
    MixedSortStrategy = class {
      _document;
      _dragDropRegistry;
      /** Root element container of the drop list. */
      _element;
      /** Function used to determine if an item can be sorted into a specific index. */
      _sortPredicate;
      /** Lazily-resolved root node containing the list. Use `_getRootNode` to read this. */
      _rootNode;
      /**
       * Draggable items that are currently active inside the container. Includes the items
       * that were there at the start of the sequence, as well as any items that have been dragged
       * in, but haven't been dropped yet.
       */
      _activeItems;
      /**
       * Keeps track of the item that was last swapped with the dragged item, as well as what direction
       * the pointer was moving in when the swap occurred and whether the user's pointer continued to
       * overlap with the swapped item after the swapping occurred.
       */
      _previousSwap = {
        drag: null,
        deltaX: 0,
        deltaY: 0,
        overlaps: false
      };
      /**
       * Keeps track of the relationship between a node and its next sibling. This information
       * is used to restore the DOM to the order it was in before dragging started.
       */
      _relatedNodes = [];
      constructor(_document2, _dragDropRegistry) {
        this._document = _document2;
        this._dragDropRegistry = _dragDropRegistry;
      }
      /**
       * To be called when the drag sequence starts.
       * @param items Items that are currently in the list.
       */
      start(items) {
        const childNodes = this._element.childNodes;
        this._relatedNodes = [];
        for (let i = 0; i < childNodes.length; i++) {
          const node = childNodes[i];
          this._relatedNodes.push([node, node.nextSibling]);
        }
        this.withItems(items);
      }
      /**
       * To be called when an item is being sorted.
       * @param item Item to be sorted.
       * @param pointerX Position of the item along the X axis.
       * @param pointerY Position of the item along the Y axis.
       * @param pointerDelta Direction in which the pointer is moving along each axis.
       */
      sort(item, pointerX, pointerY, pointerDelta) {
        const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY);
        const previousSwap = this._previousSwap;
        if (newIndex === -1 || this._activeItems[newIndex] === item) {
          return null;
        }
        const toSwapWith = this._activeItems[newIndex];
        if (previousSwap.drag === toSwapWith && previousSwap.overlaps && previousSwap.deltaX === pointerDelta.x && previousSwap.deltaY === pointerDelta.y) {
          return null;
        }
        const previousIndex = this.getItemIndex(item);
        const current = item.getPlaceholderElement();
        const overlapElement = toSwapWith.getRootElement();
        if (newIndex > previousIndex) {
          overlapElement.after(current);
        } else {
          overlapElement.before(current);
        }
        moveItemInArray(this._activeItems, previousIndex, newIndex);
        const newOverlapElement = this._getRootNode().elementFromPoint(pointerX, pointerY);
        previousSwap.deltaX = pointerDelta.x;
        previousSwap.deltaY = pointerDelta.y;
        previousSwap.drag = toSwapWith;
        previousSwap.overlaps = overlapElement === newOverlapElement || overlapElement.contains(newOverlapElement);
        return {
          previousIndex,
          currentIndex: newIndex
        };
      }
      /**
       * Called when an item is being moved into the container.
       * @param item Item that was moved into the container.
       * @param pointerX Position of the item along the X axis.
       * @param pointerY Position of the item along the Y axis.
       * @param index Index at which the item entered. If omitted, the container will try to figure it
       *   out automatically.
       */
      enter(item, pointerX, pointerY, index) {
        const currentIndex = this._activeItems.indexOf(item);
        if (currentIndex > -1) {
          this._activeItems.splice(currentIndex, 1);
        }
        let enterIndex = index == null || index < 0 ? this._getItemIndexFromPointerPosition(item, pointerX, pointerY) : index;
        if (enterIndex === -1) {
          enterIndex = this._getClosestItemIndexToPointer(item, pointerX, pointerY);
        }
        const targetItem = this._activeItems[enterIndex];
        if (targetItem && !this._dragDropRegistry.isDragging(targetItem)) {
          this._activeItems.splice(enterIndex, 0, item);
          targetItem.getRootElement().before(item.getPlaceholderElement());
        } else {
          this._activeItems.push(item);
          this._element.appendChild(item.getPlaceholderElement());
        }
      }
      /** Sets the items that are currently part of the list. */
      withItems(items) {
        this._activeItems = items.slice();
      }
      /** Assigns a sort predicate to the strategy. */
      withSortPredicate(predicate) {
        this._sortPredicate = predicate;
      }
      /** Resets the strategy to its initial state before dragging was started. */
      reset() {
        const root = this._element;
        const previousSwap = this._previousSwap;
        for (let i = this._relatedNodes.length - 1; i > -1; i--) {
          const [node, nextSibling] = this._relatedNodes[i];
          if (node.parentNode === root && node.nextSibling !== nextSibling) {
            if (nextSibling === null) {
              root.appendChild(node);
            } else if (nextSibling.parentNode === root) {
              root.insertBefore(node, nextSibling);
            }
          }
        }
        this._relatedNodes = [];
        this._activeItems = [];
        previousSwap.drag = null;
        previousSwap.deltaX = previousSwap.deltaY = 0;
        previousSwap.overlaps = false;
      }
      /**
       * Gets a snapshot of items currently in the list.
       * Can include items that we dragged in from another list.
       */
      getActiveItemsSnapshot() {
        return this._activeItems;
      }
      /** Gets the index of a specific item. */
      getItemIndex(item) {
        return this._activeItems.indexOf(item);
      }
      /** Gets the item at a specific index. */
      getItemAtIndex(index) {
        return this._activeItems[index] || null;
      }
      /** Used to notify the strategy that the scroll position has changed. */
      updateOnScroll() {
        this._activeItems.forEach((item) => {
          if (this._dragDropRegistry.isDragging(item)) {
            item._sortFromLastPointerPosition();
          }
        });
      }
      withElementContainer(container) {
        if (container !== this._element) {
          this._element = container;
          this._rootNode = void 0;
        }
      }
      /**
       * Gets the index of an item in the drop container, based on the position of the user's pointer.
       * @param item Item that is being sorted.
       * @param pointerX Position of the user's pointer along the X axis.
       * @param pointerY Position of the user's pointer along the Y axis.
       * @param delta Direction in which the user is moving their pointer.
       */
      _getItemIndexFromPointerPosition(item, pointerX, pointerY) {
        const elementAtPoint = this._getRootNode().elementFromPoint(Math.floor(pointerX), Math.floor(pointerY));
        const index = elementAtPoint ? this._activeItems.findIndex((item2) => {
          const root = item2.getRootElement();
          return elementAtPoint === root || root.contains(elementAtPoint);
        }) : -1;
        return index === -1 || !this._sortPredicate(index, item) ? -1 : index;
      }
      /** Lazily resolves the list's root node. */
      _getRootNode() {
        if (!this._rootNode) {
          this._rootNode = _getShadowRoot(this._element) || this._document;
        }
        return this._rootNode;
      }
      /**
       * Finds the index of the item that's closest to the item being dragged.
       * @param item Item being dragged.
       * @param pointerX Position of the user's pointer along the X axis.
       * @param pointerY Position of the user's pointer along the Y axis.
       */
      _getClosestItemIndexToPointer(item, pointerX, pointerY) {
        if (this._activeItems.length === 0) {
          return -1;
        }
        if (this._activeItems.length === 1) {
          return 0;
        }
        let minDistance = Infinity;
        let minIndex = -1;
        for (let i = 0; i < this._activeItems.length; i++) {
          const current = this._activeItems[i];
          if (current !== item) {
            const {
              x,
              y
            } = current.getRootElement().getBoundingClientRect();
            const distance = Math.hypot(pointerX - x, pointerY - y);
            if (distance < minDistance) {
              minDistance = distance;
              minIndex = i;
            }
          }
        }
        return minIndex;
      }
    };
    DROP_PROXIMITY_THRESHOLD = 0.05;
    SCROLL_PROXIMITY_THRESHOLD = 0.05;
    (function(AutoScrollVerticalDirection2) {
      AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["NONE"] = 0] = "NONE";
      AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["UP"] = 1] = "UP";
      AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["DOWN"] = 2] = "DOWN";
    })(AutoScrollVerticalDirection || (AutoScrollVerticalDirection = {}));
    (function(AutoScrollHorizontalDirection2) {
      AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["NONE"] = 0] = "NONE";
      AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["LEFT"] = 1] = "LEFT";
      AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["RIGHT"] = 2] = "RIGHT";
    })(AutoScrollHorizontalDirection || (AutoScrollHorizontalDirection = {}));
    DropListRef = class {
      _dragDropRegistry;
      _ngZone;
      _viewportRuler;
      /** Element that the drop list is attached to. */
      element;
      /** Whether starting a dragging sequence from this container is disabled. */
      disabled = false;
      /** Whether sorting items within the list is disabled. */
      sortingDisabled = false;
      /** Locks the position of the draggable elements inside the container along the specified axis. */
      lockAxis;
      /**
       * Whether auto-scrolling the view when the user
       * moves their pointer close to the edges is disabled.
       */
      autoScrollDisabled = false;
      /** Number of pixels to scroll for each frame when auto-scrolling an element. */
      autoScrollStep = 2;
      /**
       * Whether the items in the list should leave an anchor node when leaving the initial container.
       */
      hasAnchor = false;
      /**
       * Function that is used to determine whether an item
       * is allowed to be moved into a drop container.
       */
      enterPredicate = () => true;
      /** Function that is used to determine whether an item can be sorted into a particular index. */
      sortPredicate = () => true;
      /** Emits right before dragging has started. */
      beforeStarted = new Subject();
      /**
       * Emits when the user has moved a new drag item into this container.
       */
      entered = new Subject();
      /**
       * Emits when the user removes an item from the container
       * by dragging it into another container.
       */
      exited = new Subject();
      /** Emits when the user drops an item inside the container. */
      dropped = new Subject();
      /** Emits as the user is swapping items while actively dragging. */
      sorted = new Subject();
      /** Emits when a dragging sequence is started in a list connected to the current one. */
      receivingStarted = new Subject();
      /** Emits when a dragging sequence is stopped from a list connected to the current one. */
      receivingStopped = new Subject();
      /** Arbitrary data that can be attached to the drop list. */
      data;
      /** Element that is the direct parent of the drag items. */
      _container;
      /** Whether an item in the list is being dragged. */
      _isDragging = false;
      /** Keeps track of the positions of any parent scrollable elements. */
      _parentPositions;
      /** Strategy being used to sort items within the list. */
      _sortStrategy;
      /** Cached `DOMRect` of the drop list. */
      _domRect;
      /** Draggable items in the container. */
      _draggables = [];
      /** Drop lists that are connected to the current one. */
      _siblings = [];
      /** Connected siblings that currently have a dragged item. */
      _activeSiblings = /* @__PURE__ */ new Set();
      /** Subscription to the window being scrolled. */
      _viewportScrollSubscription = Subscription.EMPTY;
      /** Vertical direction in which the list is currently scrolling. */
      _verticalScrollDirection = AutoScrollVerticalDirection.NONE;
      /** Horizontal direction in which the list is currently scrolling. */
      _horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
      /** Node that is being auto-scrolled. */
      _scrollNode;
      /** Used to signal to the current auto-scroll sequence when to stop. */
      _stopScrollTimers = new Subject();
      /** Shadow root of the current element. Necessary for `elementFromPoint` to resolve correctly. */
      _cachedShadowRoot = null;
      /** Reference to the document. */
      _document;
      /** Elements that can be scrolled while the user is dragging. */
      _scrollableElements = [];
      /** Initial value for the element's `scroll-snap-type` style. */
      _initialScrollSnap;
      /** Direction of the list's layout. */
      _direction = "ltr";
      constructor(element, _dragDropRegistry, _document2, _ngZone, _viewportRuler) {
        this._dragDropRegistry = _dragDropRegistry;
        this._ngZone = _ngZone;
        this._viewportRuler = _viewportRuler;
        const coercedElement = this.element = coerceElement(element);
        this._document = _document2;
        this.withOrientation("vertical").withElementContainer(coercedElement);
        _dragDropRegistry.registerDropContainer(this);
        this._parentPositions = new ParentPositionTracker(_document2);
      }
      /** Removes the drop list functionality from the DOM element. */
      dispose() {
        this._stopScrolling();
        this._stopScrollTimers.complete();
        this._viewportScrollSubscription.unsubscribe();
        this.beforeStarted.complete();
        this.entered.complete();
        this.exited.complete();
        this.dropped.complete();
        this.sorted.complete();
        this.receivingStarted.complete();
        this.receivingStopped.complete();
        this._activeSiblings.clear();
        this._scrollNode = null;
        this._parentPositions.clear();
        this._dragDropRegistry.removeDropContainer(this);
      }
      /** Whether an item from this list is currently being dragged. */
      isDragging() {
        return this._isDragging;
      }
      /** Starts dragging an item. */
      start() {
        this._draggingStarted();
        this._notifyReceivingSiblings();
      }
      /**
       * Attempts to move an item into the container.
       * @param item Item that was moved into the container.
       * @param pointerX Position of the item along the X axis.
       * @param pointerY Position of the item along the Y axis.
       * @param index Index at which the item entered. If omitted, the container will try to figure it
       *   out automatically.
       */
      enter(item, pointerX, pointerY, index) {
        this._draggingStarted();
        if (index == null && this.sortingDisabled) {
          index = this._draggables.indexOf(item);
        }
        this._sortStrategy.enter(item, pointerX, pointerY, index);
        this._cacheParentPositions();
        this._notifyReceivingSiblings();
        this.entered.next({
          item,
          container: this,
          currentIndex: this.getItemIndex(item)
        });
      }
      /**
       * Removes an item from the container after it was dragged into another container by the user.
       * @param item Item that was dragged out.
       */
      exit(item) {
        this._reset();
        this.exited.next({
          item,
          container: this
        });
      }
      /**
       * Drops an item into this container.
       * @param item Item being dropped into the container.
       * @param currentIndex Index at which the item should be inserted.
       * @param previousIndex Index of the item when dragging started.
       * @param previousContainer Container from which the item got dragged in.
       * @param isPointerOverContainer Whether the user's pointer was over the
       *    container when the item was dropped.
       * @param distance Distance the user has dragged since the start of the dragging sequence.
       * @param event Event that triggered the dropping sequence.
       *
       * @breaking-change 15.0.0 `previousIndex` and `event` parameters to become required.
       */
      drop(item, currentIndex, previousIndex, previousContainer, isPointerOverContainer, distance, dropPoint, event = {}) {
        this._reset();
        this.dropped.next({
          item,
          currentIndex,
          previousIndex,
          container: this,
          previousContainer,
          isPointerOverContainer,
          distance,
          dropPoint,
          event
        });
      }
      /**
       * Sets the draggable items that are a part of this list.
       * @param items Items that are a part of this list.
       */
      withItems(items) {
        const previousItems = this._draggables;
        this._draggables = items;
        items.forEach((item) => item._withDropContainer(this));
        if (this.isDragging()) {
          const draggedItems = previousItems.filter((item) => item.isDragging());
          if (draggedItems.every((item) => items.indexOf(item) === -1)) {
            this._reset();
          } else {
            this._sortStrategy.withItems(this._draggables);
          }
        }
        return this;
      }
      /** Sets the layout direction of the drop list. */
      withDirection(direction) {
        this._direction = direction;
        if (this._sortStrategy instanceof SingleAxisSortStrategy) {
          this._sortStrategy.direction = direction;
        }
        return this;
      }
      /**
       * Sets the containers that are connected to this one. When two or more containers are
       * connected, the user will be allowed to transfer items between them.
       * @param connectedTo Other containers that the current containers should be connected to.
       */
      connectedTo(connectedTo) {
        this._siblings = connectedTo.slice();
        return this;
      }
      /**
       * Sets the orientation of the container.
       * @param orientation New orientation for the container.
       */
      withOrientation(orientation) {
        if (orientation === "mixed") {
          this._sortStrategy = new MixedSortStrategy(this._document, this._dragDropRegistry);
        } else {
          const strategy = new SingleAxisSortStrategy(this._dragDropRegistry);
          strategy.direction = this._direction;
          strategy.orientation = orientation;
          this._sortStrategy = strategy;
        }
        this._sortStrategy.withElementContainer(this._container);
        this._sortStrategy.withSortPredicate((index, item) => this.sortPredicate(index, item, this));
        return this;
      }
      /**
       * Sets which parent elements are can be scrolled while the user is dragging.
       * @param elements Elements that can be scrolled.
       */
      withScrollableParents(elements) {
        const element = this._container;
        this._scrollableElements = elements.indexOf(element) === -1 ? [element, ...elements] : elements.slice();
        return this;
      }
      /**
       * Configures the drop list so that a different element is used as the container for the
       * dragged items. This is useful for the cases when one might not have control over the
       * full DOM that sets up the dragging.
       * Note that the alternate container needs to be a descendant of the drop list.
       * @param container New element container to be assigned.
       */
      withElementContainer(container) {
        if (container === this._container) {
          return this;
        }
        const element = coerceElement(this.element);
        if ((typeof ngDevMode === "undefined" || ngDevMode) && container !== element && !element.contains(container)) {
          throw new Error("Invalid DOM structure for drop list. Alternate container element must be a descendant of the drop list.");
        }
        const oldContainerIndex = this._scrollableElements.indexOf(this._container);
        const newContainerIndex = this._scrollableElements.indexOf(container);
        if (oldContainerIndex > -1) {
          this._scrollableElements.splice(oldContainerIndex, 1);
        }
        if (newContainerIndex > -1) {
          this._scrollableElements.splice(newContainerIndex, 1);
        }
        if (this._sortStrategy) {
          this._sortStrategy.withElementContainer(container);
        }
        this._cachedShadowRoot = null;
        this._scrollableElements.unshift(container);
        this._container = container;
        return this;
      }
      /** Gets the scrollable parents that are registered with this drop container. */
      getScrollableParents() {
        return this._scrollableElements;
      }
      /**
       * Figures out the index of an item in the container.
       * @param item Item whose index should be determined.
       */
      getItemIndex(item) {
        return this._isDragging ? this._sortStrategy.getItemIndex(item) : this._draggables.indexOf(item);
      }
      /**
       * Gets the item at a specific index.
       * @param index Index at which to retrieve the item.
       */
      getItemAtIndex(index) {
        return this._isDragging ? this._sortStrategy.getItemAtIndex(index) : this._draggables[index] || null;
      }
      /**
       * Whether the list is able to receive the item that
       * is currently being dragged inside a connected drop list.
       */
      isReceiving() {
        return this._activeSiblings.size > 0;
      }
      /**
       * Sorts an item inside the container based on its position.
       * @param item Item to be sorted.
       * @param pointerX Position of the item along the X axis.
       * @param pointerY Position of the item along the Y axis.
       * @param pointerDelta Direction in which the pointer is moving along each axis.
       */
      _sortItem(item, pointerX, pointerY, pointerDelta) {
        if (this.sortingDisabled || !this._domRect || !isPointerNearDomRect(this._domRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {
          return;
        }
        const result = this._sortStrategy.sort(item, pointerX, pointerY, pointerDelta);
        if (result) {
          this.sorted.next({
            previousIndex: result.previousIndex,
            currentIndex: result.currentIndex,
            container: this,
            item
          });
        }
      }
      /**
       * Checks whether the user's pointer is close to the edges of either the
       * viewport or the drop list and starts the auto-scroll sequence.
       * @param pointerX User's pointer position along the x axis.
       * @param pointerY User's pointer position along the y axis.
       */
      _startScrollingIfNecessary(pointerX, pointerY) {
        if (this.autoScrollDisabled) {
          return;
        }
        let scrollNode;
        let verticalScrollDirection = AutoScrollVerticalDirection.NONE;
        let horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
        this._parentPositions.positions.forEach((position, element) => {
          if (element === this._document || !position.clientRect || scrollNode) {
            return;
          }
          if (isPointerNearDomRect(position.clientRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {
            [verticalScrollDirection, horizontalScrollDirection] = getElementScrollDirections(element, position.clientRect, this._direction, pointerX, pointerY);
            if (verticalScrollDirection || horizontalScrollDirection) {
              scrollNode = element;
            }
          }
        });
        if (!verticalScrollDirection && !horizontalScrollDirection) {
          const {
            width,
            height
          } = this._viewportRuler.getViewportSize();
          const domRect = {
            width,
            height,
            top: 0,
            right: width,
            bottom: height,
            left: 0
          };
          verticalScrollDirection = getVerticalScrollDirection(domRect, pointerY);
          horizontalScrollDirection = getHorizontalScrollDirection(domRect, pointerX);
          scrollNode = window;
        }
        if (scrollNode && (verticalScrollDirection !== this._verticalScrollDirection || horizontalScrollDirection !== this._horizontalScrollDirection || scrollNode !== this._scrollNode)) {
          this._verticalScrollDirection = verticalScrollDirection;
          this._horizontalScrollDirection = horizontalScrollDirection;
          this._scrollNode = scrollNode;
          if ((verticalScrollDirection || horizontalScrollDirection) && scrollNode) {
            this._ngZone.runOutsideAngular(this._startScrollInterval);
          } else {
            this._stopScrolling();
          }
        }
      }
      /** Stops any currently-running auto-scroll sequences. */
      _stopScrolling() {
        this._stopScrollTimers.next();
      }
      /** Starts the dragging sequence within the list. */
      _draggingStarted() {
        const styles = this._container.style;
        this.beforeStarted.next();
        this._isDragging = true;
        if ((typeof ngDevMode === "undefined" || ngDevMode) && // Prevent the check from running on apps not using an alternate container. Ideally we
        // would always run it, but introducing it at this stage would be a breaking change.
        this._container !== coerceElement(this.element)) {
          for (const drag of this._draggables) {
            if (!drag.isDragging() && drag.getVisibleElement().parentNode !== this._container) {
              throw new Error("Invalid DOM structure for drop list. All items must be placed directly inside of the element container.");
            }
          }
        }
        this._initialScrollSnap = styles.msScrollSnapType || styles.scrollSnapType || "";
        styles.scrollSnapType = styles.msScrollSnapType = "none";
        this._sortStrategy.start(this._draggables);
        this._cacheParentPositions();
        this._viewportScrollSubscription.unsubscribe();
        this._listenToScrollEvents();
      }
      /** Caches the positions of the configured scrollable parents. */
      _cacheParentPositions() {
        this._parentPositions.cache(this._scrollableElements);
        this._domRect = this._parentPositions.positions.get(this._container).clientRect;
      }
      /** Resets the container to its initial state. */
      _reset() {
        this._isDragging = false;
        const styles = this._container.style;
        styles.scrollSnapType = styles.msScrollSnapType = this._initialScrollSnap;
        this._siblings.forEach((sibling) => sibling._stopReceiving(this));
        this._sortStrategy.reset();
        this._stopScrolling();
        this._viewportScrollSubscription.unsubscribe();
        this._parentPositions.clear();
      }
      /** Starts the interval that'll auto-scroll the element. */
      _startScrollInterval = () => {
        this._stopScrolling();
        interval(0, animationFrameScheduler).pipe(takeUntil(this._stopScrollTimers)).subscribe(() => {
          const node = this._scrollNode;
          const scrollStep = this.autoScrollStep;
          if (this._verticalScrollDirection === AutoScrollVerticalDirection.UP) {
            node.scrollBy(0, -scrollStep);
          } else if (this._verticalScrollDirection === AutoScrollVerticalDirection.DOWN) {
            node.scrollBy(0, scrollStep);
          }
          if (this._horizontalScrollDirection === AutoScrollHorizontalDirection.LEFT) {
            node.scrollBy(-scrollStep, 0);
          } else if (this._horizontalScrollDirection === AutoScrollHorizontalDirection.RIGHT) {
            node.scrollBy(scrollStep, 0);
          }
        });
      };
      /**
       * Checks whether the user's pointer is positioned over the container.
       * @param x Pointer position along the X axis.
       * @param y Pointer position along the Y axis.
       */
      _isOverContainer(x, y) {
        return this._domRect != null && isInsideClientRect(this._domRect, x, y);
      }
      /**
       * Figures out whether an item should be moved into a sibling
       * drop container, based on its current position.
       * @param item Drag item that is being moved.
       * @param x Position of the item along the X axis.
       * @param y Position of the item along the Y axis.
       */
      _getSiblingContainerFromPosition(item, x, y) {
        return this._siblings.find((sibling) => sibling._canReceive(item, x, y));
      }
      /**
       * Checks whether the drop list can receive the passed-in item.
       * @param item Item that is being dragged into the list.
       * @param x Position of the item along the X axis.
       * @param y Position of the item along the Y axis.
       */
      _canReceive(item, x, y) {
        if (!this._domRect || !isInsideClientRect(this._domRect, x, y) || !this.enterPredicate(item, this)) {
          return false;
        }
        const elementFromPoint = this._getShadowRoot().elementFromPoint(x, y);
        if (!elementFromPoint) {
          return false;
        }
        return elementFromPoint === this._container || this._container.contains(elementFromPoint);
      }
      /**
       * Called by one of the connected drop lists when a dragging sequence has started.
       * @param sibling Sibling in which dragging has started.
       */
      _startReceiving(sibling, items) {
        const activeSiblings = this._activeSiblings;
        if (!activeSiblings.has(sibling) && items.every((item) => {
          return this.enterPredicate(item, this) || this._draggables.indexOf(item) > -1;
        })) {
          activeSiblings.add(sibling);
          this._cacheParentPositions();
          this._listenToScrollEvents();
          this.receivingStarted.next({
            initiator: sibling,
            receiver: this,
            items
          });
        }
      }
      /**
       * Called by a connected drop list when dragging has stopped.
       * @param sibling Sibling whose dragging has stopped.
       */
      _stopReceiving(sibling) {
        this._activeSiblings.delete(sibling);
        this._viewportScrollSubscription.unsubscribe();
        this.receivingStopped.next({
          initiator: sibling,
          receiver: this
        });
      }
      /**
       * Starts listening to scroll events on the viewport.
       * Used for updating the internal state of the list.
       */
      _listenToScrollEvents() {
        this._viewportScrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe((event) => {
          if (this.isDragging()) {
            const scrollDifference = this._parentPositions.handleScroll(event);
            if (scrollDifference) {
              this._sortStrategy.updateOnScroll(scrollDifference.top, scrollDifference.left);
            }
          } else if (this.isReceiving()) {
            this._cacheParentPositions();
          }
        });
      }
      /**
       * Lazily resolves and returns the shadow root of the element. We do this in a function, rather
       * than saving it in property directly on init, because we want to resolve it as late as possible
       * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the
       * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.
       */
      _getShadowRoot() {
        if (!this._cachedShadowRoot) {
          const shadowRoot = _getShadowRoot(this._container);
          this._cachedShadowRoot = shadowRoot || this._document;
        }
        return this._cachedShadowRoot;
      }
      /** Notifies any siblings that may potentially receive the item. */
      _notifyReceivingSiblings() {
        const draggedItems = this._sortStrategy.getActiveItemsSnapshot().filter((item) => item.isDragging());
        this._siblings.forEach((sibling) => sibling._startReceiving(this, draggedItems));
      }
    };
    capturingEventOptions = {
      capture: true
    };
    activeCapturingEventOptions = {
      passive: false,
      capture: true
    };
    _ResetsLoader = class __ResetsLoader {
      static \u0275fac = function _ResetsLoader_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || __ResetsLoader)();
      };
      static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
        type: __ResetsLoader,
        selectors: [["ng-component"]],
        hostAttrs: ["cdk-drag-resets-container", ""],
        decls: 0,
        vars: 0,
        template: function _ResetsLoader_Template(rf, ctx) {
        },
        styles: ["@layer cdk-resets{.cdk-drag-preview{background:none;border:none;padding:0;color:inherit;inset:auto}}.cdk-drag-placeholder *,.cdk-drag-preview *{pointer-events:none !important}\n"],
        encapsulation: 2,
        changeDetection: 0
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_ResetsLoader, [{
        type: Component,
        args: [{
          encapsulation: ViewEncapsulation.None,
          template: "",
          changeDetection: ChangeDetectionStrategy.OnPush,
          host: {
            "cdk-drag-resets-container": ""
          },
          styles: ["@layer cdk-resets{.cdk-drag-preview{background:none;border:none;padding:0;color:inherit;inset:auto}}.cdk-drag-placeholder *,.cdk-drag-preview *{pointer-events:none !important}\n"]
        }]
      }], null, null);
    })();
    DragDropRegistry = class _DragDropRegistry {
      _ngZone = inject2(NgZone);
      _document = inject2(DOCUMENT);
      _styleLoader = inject2(_CdkPrivateStyleLoader);
      _renderer = inject2(RendererFactory2).createRenderer(null, null);
      _cleanupDocumentTouchmove;
      _scroll = new Subject();
      /** Registered drop container instances. */
      _dropInstances = /* @__PURE__ */ new Set();
      /** Registered drag item instances. */
      _dragInstances = /* @__PURE__ */ new Set();
      /** Drag item instances that are currently being dragged. */
      _activeDragInstances = signal([], ...ngDevMode ? [{
        debugName: "_activeDragInstances"
      }] : []);
      /** Keeps track of the event listeners that we've bound to the `document`. */
      _globalListeners;
      /**
       * Predicate function to check if an item is being dragged.  Moved out into a property,
       * because it'll be called a lot and we don't want to create a new function every time.
       */
      _draggingPredicate = (item) => item.isDragging();
      /**
       * Map tracking DOM nodes and their corresponding drag directives. Note that this is different
       * from looking through the `_dragInstances` and getting their root node, because the root node
       * isn't necessarily the node that the directive is set on.
       */
      _domNodesToDirectives = null;
      /**
       * Emits the `touchmove` or `mousemove` events that are dispatched
       * while the user is dragging a drag item instance.
       */
      pointerMove = new Subject();
      /**
       * Emits the `touchend` or `mouseup` events that are dispatched
       * while the user is dragging a drag item instance.
       */
      pointerUp = new Subject();
      constructor() {
      }
      /** Adds a drop container to the registry. */
      registerDropContainer(drop) {
        if (!this._dropInstances.has(drop)) {
          this._dropInstances.add(drop);
        }
      }
      /** Adds a drag item instance to the registry. */
      registerDragItem(drag) {
        this._dragInstances.add(drag);
        if (this._dragInstances.size === 1) {
          this._ngZone.runOutsideAngular(() => {
            this._cleanupDocumentTouchmove?.();
            this._cleanupDocumentTouchmove = this._renderer.listen(this._document, "touchmove", this._persistentTouchmoveListener, activeCapturingEventOptions);
          });
        }
      }
      /** Removes a drop container from the registry. */
      removeDropContainer(drop) {
        this._dropInstances.delete(drop);
      }
      /** Removes a drag item instance from the registry. */
      removeDragItem(drag) {
        this._dragInstances.delete(drag);
        this.stopDragging(drag);
        if (this._dragInstances.size === 0) {
          this._cleanupDocumentTouchmove?.();
        }
      }
      /**
       * Starts the dragging sequence for a drag instance.
       * @param drag Drag instance which is being dragged.
       * @param event Event that initiated the dragging.
       */
      startDragging(drag, event) {
        if (this._activeDragInstances().indexOf(drag) > -1) {
          return;
        }
        this._styleLoader.load(_ResetsLoader);
        this._activeDragInstances.update((instances) => [...instances, drag]);
        if (this._activeDragInstances().length === 1) {
          const isTouchEvent2 = event.type.startsWith("touch");
          const endEventHandler = (e) => this.pointerUp.next(e);
          const toBind = [
            // Use capturing so that we pick up scroll changes in any scrollable nodes that aren't
            // the document. See https://github.com/angular/components/issues/17144.
            ["scroll", (e) => this._scroll.next(e), capturingEventOptions],
            // Preventing the default action on `mousemove` isn't enough to disable text selection
            // on Safari so we need to prevent the selection event as well. Alternatively this can
            // be done by setting `user-select: none` on the `body`, however it has causes a style
            // recalculation which can be expensive on pages with a lot of elements.
            ["selectstart", this._preventDefaultWhileDragging, activeCapturingEventOptions]
          ];
          if (isTouchEvent2) {
            toBind.push(["touchend", endEventHandler, capturingEventOptions], ["touchcancel", endEventHandler, capturingEventOptions]);
          } else {
            toBind.push(["mouseup", endEventHandler, capturingEventOptions]);
          }
          if (!isTouchEvent2) {
            toBind.push(["mousemove", (e) => this.pointerMove.next(e), activeCapturingEventOptions]);
          }
          this._ngZone.runOutsideAngular(() => {
            this._globalListeners = toBind.map(([name2, handler, options]) => this._renderer.listen(this._document, name2, handler, options));
          });
        }
      }
      /** Stops dragging a drag item instance. */
      stopDragging(drag) {
        this._activeDragInstances.update((instances) => {
          const index = instances.indexOf(drag);
          if (index > -1) {
            instances.splice(index, 1);
            return [...instances];
          }
          return instances;
        });
        if (this._activeDragInstances().length === 0) {
          this._clearGlobalListeners();
        }
      }
      /** Gets whether a drag item instance is currently being dragged. */
      isDragging(drag) {
        return this._activeDragInstances().indexOf(drag) > -1;
      }
      /**
       * Gets a stream that will emit when any element on the page is scrolled while an item is being
       * dragged.
       * @param shadowRoot Optional shadow root that the current dragging sequence started from.
       *   Top-level listeners won't pick up events coming from the shadow DOM so this parameter can
       *   be used to include an additional top-level listener at the shadow root level.
       */
      scrolled(shadowRoot) {
        const streams = [this._scroll];
        if (shadowRoot && shadowRoot !== this._document) {
          streams.push(new Observable((observer) => {
            return this._ngZone.runOutsideAngular(() => {
              const cleanup = this._renderer.listen(shadowRoot, "scroll", (event) => {
                if (this._activeDragInstances().length) {
                  observer.next(event);
                }
              }, capturingEventOptions);
              return () => {
                cleanup();
              };
            });
          }));
        }
        return merge(...streams);
      }
      /**
       * Tracks the DOM node which has a draggable directive.
       * @param node Node to track.
       * @param dragRef Drag directive set on the node.
       */
      registerDirectiveNode(node, dragRef) {
        this._domNodesToDirectives ??= /* @__PURE__ */ new WeakMap();
        this._domNodesToDirectives.set(node, dragRef);
      }
      /**
       * Stops tracking a draggable directive node.
       * @param node Node to stop tracking.
       */
      removeDirectiveNode(node) {
        this._domNodesToDirectives?.delete(node);
      }
      /**
       * Gets the drag directive corresponding to a specific DOM node, if any.
       * @param node Node for which to do the lookup.
       */
      getDragDirectiveForNode(node) {
        return this._domNodesToDirectives?.get(node) || null;
      }
      ngOnDestroy() {
        this._dragInstances.forEach((instance) => this.removeDragItem(instance));
        this._dropInstances.forEach((instance) => this.removeDropContainer(instance));
        this._domNodesToDirectives = null;
        this._clearGlobalListeners();
        this.pointerMove.complete();
        this.pointerUp.complete();
      }
      /**
       * Event listener that will prevent the default browser action while the user is dragging.
       * @param event Event whose default action should be prevented.
       */
      _preventDefaultWhileDragging = (event) => {
        if (this._activeDragInstances().length > 0) {
          event.preventDefault();
        }
      };
      /** Event listener for `touchmove` that is bound even if no dragging is happening. */
      _persistentTouchmoveListener = (event) => {
        if (this._activeDragInstances().length > 0) {
          if (this._activeDragInstances().some(this._draggingPredicate)) {
            event.preventDefault();
          }
          this.pointerMove.next(event);
        }
      };
      /** Clears out the global event listeners from the `document`. */
      _clearGlobalListeners() {
        this._globalListeners?.forEach((cleanup) => cleanup());
        this._globalListeners = void 0;
      }
      static \u0275fac = function DragDropRegistry_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DragDropRegistry)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _DragDropRegistry,
        factory: _DragDropRegistry.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDropRegistry, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [], null);
    })();
    DEFAULT_CONFIG = {
      dragStartThreshold: 5,
      pointerDirectionChangeThreshold: 5
    };
    DragDrop = class _DragDrop {
      _document = inject2(DOCUMENT);
      _ngZone = inject2(NgZone);
      _viewportRuler = inject2(ViewportRuler);
      _dragDropRegistry = inject2(DragDropRegistry);
      _renderer = inject2(RendererFactory2).createRenderer(null, null);
      constructor() {
      }
      /**
       * Turns an element into a draggable item.
       * @param element Element to which to attach the dragging functionality.
       * @param config Object used to configure the dragging behavior.
       */
      createDrag(element, config3 = DEFAULT_CONFIG) {
        return new DragRef(element, config3, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry, this._renderer);
      }
      /**
       * Turns an element into a drop list.
       * @param element Element to which to attach the drop list functionality.
       */
      createDropList(element) {
        return new DropListRef(element, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler);
      }
      static \u0275fac = function DragDrop_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DragDrop)();
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
        token: _DragDrop,
        factory: _DragDrop.\u0275fac,
        providedIn: "root"
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDrop, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [], null);
    })();
    CDK_DRAG_PARENT = new InjectionToken("CDK_DRAG_PARENT");
    CDK_DRAG_HANDLE = new InjectionToken("CdkDragHandle");
    CdkDragHandle = class _CdkDragHandle {
      element = inject2(ElementRef);
      _parentDrag = inject2(CDK_DRAG_PARENT, {
        optional: true,
        skipSelf: true
      });
      _dragDropRegistry = inject2(DragDropRegistry);
      /** Emits when the state of the handle has changed. */
      _stateChanges = new Subject();
      /** Whether starting to drag through this handle is disabled. */
      get disabled() {
        return this._disabled;
      }
      set disabled(value) {
        this._disabled = value;
        this._stateChanges.next(this);
      }
      _disabled = false;
      constructor() {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          assertElementNode(this.element.nativeElement, "cdkDragHandle");
        }
        this._parentDrag?._addHandle(this);
      }
      ngAfterViewInit() {
        if (!this._parentDrag) {
          let parent = this.element.nativeElement.parentElement;
          while (parent) {
            const ref = this._dragDropRegistry.getDragDirectiveForNode(parent);
            if (ref) {
              this._parentDrag = ref;
              ref._addHandle(this);
              break;
            }
            parent = parent.parentElement;
          }
        }
      }
      ngOnDestroy() {
        this._parentDrag?._removeHandle(this);
        this._stateChanges.complete();
      }
      static \u0275fac = function CdkDragHandle_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkDragHandle)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkDragHandle,
        selectors: [["", "cdkDragHandle", ""]],
        hostAttrs: [1, "cdk-drag-handle"],
        inputs: {
          disabled: [2, "cdkDragHandleDisabled", "disabled", booleanAttribute]
        },
        features: [\u0275\u0275ProvidersFeature([{
          provide: CDK_DRAG_HANDLE,
          useExisting: _CdkDragHandle
        }])]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragHandle, [{
        type: Directive,
        args: [{
          selector: "[cdkDragHandle]",
          host: {
            "class": "cdk-drag-handle"
          },
          providers: [{
            provide: CDK_DRAG_HANDLE,
            useExisting: CdkDragHandle
          }]
        }]
      }], () => [], {
        disabled: [{
          type: Input,
          args: [{
            alias: "cdkDragHandleDisabled",
            transform: booleanAttribute
          }]
        }]
      });
    })();
    CDK_DRAG_CONFIG = new InjectionToken("CDK_DRAG_CONFIG");
    CDK_DROP_LIST = new InjectionToken("CdkDropList");
    CdkDrag = class _CdkDrag {
      element = inject2(ElementRef);
      dropContainer = inject2(CDK_DROP_LIST, {
        optional: true,
        skipSelf: true
      });
      _ngZone = inject2(NgZone);
      _viewContainerRef = inject2(ViewContainerRef);
      _dir = inject2(Directionality, {
        optional: true
      });
      _changeDetectorRef = inject2(ChangeDetectorRef);
      _selfHandle = inject2(CDK_DRAG_HANDLE, {
        optional: true,
        self: true
      });
      _parentDrag = inject2(CDK_DRAG_PARENT, {
        optional: true,
        skipSelf: true
      });
      _dragDropRegistry = inject2(DragDropRegistry);
      _destroyed = new Subject();
      _handles = new BehaviorSubject([]);
      _previewTemplate;
      _placeholderTemplate;
      /** Reference to the underlying drag instance. */
      _dragRef;
      /** Arbitrary data to attach to this drag instance. */
      data;
      /** Locks the position of the dragged element along the specified axis. */
      lockAxis;
      /**
       * Selector that will be used to determine the root draggable element, starting from
       * the `cdkDrag` element and going up the DOM. Passing an alternate root element is useful
       * when trying to enable dragging on an element that you might not have access to.
       */
      rootElementSelector;
      /**
       * Node or selector that will be used to determine the element to which the draggable's
       * position will be constrained. If a string is passed in, it'll be used as a selector that
       * will be matched starting from the element's parent and going up the DOM until a match
       * has been found.
       */
      boundaryElement;
      /**
       * Amount of milliseconds to wait after the user has put their
       * pointer down before starting to drag the element.
       */
      dragStartDelay;
      /**
       * Sets the position of a `CdkDrag` that is outside of a drop container.
       * Can be used to restore the element's position for a returning user.
       */
      freeDragPosition;
      /** Whether starting to drag this element is disabled. */
      get disabled() {
        return this._disabled || !!(this.dropContainer && this.dropContainer.disabled);
      }
      set disabled(value) {
        this._disabled = value;
        this._dragRef.disabled = this._disabled;
      }
      _disabled;
      /**
       * Function that can be used to customize the logic of how the position of the drag item
       * is limited while it's being dragged. Gets called with a point containing the current position
       * of the user's pointer on the page, a reference to the item being dragged and its dimensions.
       * Should return a point describing where the item should be rendered.
       */
      constrainPosition;
      /** Class to be added to the preview element. */
      previewClass;
      /**
       * Configures the place into which the preview of the item will be inserted. Can be configured
       * globally through `CDK_DROP_LIST`. Possible values:
       * - `global` - Preview will be inserted at the bottom of the `<body>`. The advantage is that
       * you don't have to worry about `overflow: hidden` or `z-index`, but the item won't retain
       * its inherited styles.
       * - `parent` - Preview will be inserted into the parent of the drag item. The advantage is that
       * inherited styles will be preserved, but it may be clipped by `overflow: hidden` or not be
       * visible due to `z-index`. Furthermore, the preview is going to have an effect over selectors
       * like `:nth-child` and some flexbox configurations.
       * - `ElementRef<HTMLElement> | HTMLElement` - Preview will be inserted into a specific element.
       * Same advantages and disadvantages as `parent`.
       */
      previewContainer;
      /**
       * If the parent of the dragged element has a `scale` transform, it can throw off the
       * positioning when the user starts dragging. Use this input to notify the CDK of the scale.
       */
      scale = 1;
      /** Emits when the user starts dragging the item. */
      started = new EventEmitter();
      /** Emits when the user has released a drag item, before any animations have started. */
      released = new EventEmitter();
      /** Emits when the user stops dragging an item in the container. */
      ended = new EventEmitter();
      /** Emits when the user has moved the item into a new container. */
      entered = new EventEmitter();
      /** Emits when the user removes the item its container by dragging it into another container. */
      exited = new EventEmitter();
      /** Emits when the user drops the item inside a container. */
      dropped = new EventEmitter();
      /**
       * Emits as the user is dragging the item. Use with caution,
       * because this event will fire for every pixel that the user has dragged.
       */
      moved = new Observable((observer) => {
        const subscription = this._dragRef.moved.pipe(map((movedEvent) => ({
          source: this,
          pointerPosition: movedEvent.pointerPosition,
          event: movedEvent.event,
          delta: movedEvent.delta,
          distance: movedEvent.distance
        }))).subscribe(observer);
        return () => {
          subscription.unsubscribe();
        };
      });
      _injector = inject2(Injector);
      constructor() {
        const dropContainer = this.dropContainer;
        const config3 = inject2(CDK_DRAG_CONFIG, {
          optional: true
        });
        const dragDrop = inject2(DragDrop);
        this._dragRef = dragDrop.createDrag(this.element, {
          dragStartThreshold: config3 && config3.dragStartThreshold != null ? config3.dragStartThreshold : 5,
          pointerDirectionChangeThreshold: config3 && config3.pointerDirectionChangeThreshold != null ? config3.pointerDirectionChangeThreshold : 5,
          zIndex: config3?.zIndex
        });
        this._dragRef.data = this;
        this._dragDropRegistry.registerDirectiveNode(this.element.nativeElement, this);
        if (config3) {
          this._assignDefaults(config3);
        }
        if (dropContainer) {
          dropContainer.addItem(this);
          dropContainer._dropListRef.beforeStarted.pipe(takeUntil(this._destroyed)).subscribe(() => {
            this._dragRef.scale = this.scale;
          });
        }
        this._syncInputs(this._dragRef);
        this._handleEvents(this._dragRef);
      }
      /**
       * Returns the element that is being used as a placeholder
       * while the current element is being dragged.
       */
      getPlaceholderElement() {
        return this._dragRef.getPlaceholderElement();
      }
      /** Returns the root draggable element. */
      getRootElement() {
        return this._dragRef.getRootElement();
      }
      /** Resets a standalone drag item to its initial position. */
      reset() {
        this._dragRef.reset();
      }
      /** Resets drag item to end of boundary element. */
      resetToBoundary() {
        this._dragRef.resetToBoundary();
      }
      /**
       * Gets the pixel coordinates of the draggable outside of a drop container.
       */
      getFreeDragPosition() {
        return this._dragRef.getFreeDragPosition();
      }
      /**
       * Sets the current position in pixels the draggable outside of a drop container.
       * @param value New position to be set.
       */
      setFreeDragPosition(value) {
        this._dragRef.setFreeDragPosition(value);
      }
      ngAfterViewInit() {
        afterNextRender(() => {
          this._updateRootElement();
          this._setupHandlesListener();
          this._dragRef.scale = this.scale;
          if (this.freeDragPosition) {
            this._dragRef.setFreeDragPosition(this.freeDragPosition);
          }
        }, {
          injector: this._injector
        });
      }
      ngOnChanges(changes) {
        const rootSelectorChange = changes["rootElementSelector"];
        const positionChange = changes["freeDragPosition"];
        if (rootSelectorChange && !rootSelectorChange.firstChange) {
          this._updateRootElement();
        }
        this._dragRef.scale = this.scale;
        if (positionChange && !positionChange.firstChange && this.freeDragPosition) {
          this._dragRef.setFreeDragPosition(this.freeDragPosition);
        }
      }
      ngOnDestroy() {
        if (this.dropContainer) {
          this.dropContainer.removeItem(this);
        }
        this._dragDropRegistry.removeDirectiveNode(this.element.nativeElement);
        this._ngZone.runOutsideAngular(() => {
          this._handles.complete();
          this._destroyed.next();
          this._destroyed.complete();
          this._dragRef.dispose();
        });
      }
      _addHandle(handle) {
        const handles = this._handles.getValue();
        handles.push(handle);
        this._handles.next(handles);
      }
      _removeHandle(handle) {
        const handles = this._handles.getValue();
        const index = handles.indexOf(handle);
        if (index > -1) {
          handles.splice(index, 1);
          this._handles.next(handles);
        }
      }
      _setPreviewTemplate(preview) {
        this._previewTemplate = preview;
      }
      _resetPreviewTemplate(preview) {
        if (preview === this._previewTemplate) {
          this._previewTemplate = null;
        }
      }
      _setPlaceholderTemplate(placeholder) {
        this._placeholderTemplate = placeholder;
      }
      _resetPlaceholderTemplate(placeholder) {
        if (placeholder === this._placeholderTemplate) {
          this._placeholderTemplate = null;
        }
      }
      /** Syncs the root element with the `DragRef`. */
      _updateRootElement() {
        const element = this.element.nativeElement;
        let rootElement = element;
        if (this.rootElementSelector) {
          rootElement = element.closest !== void 0 ? element.closest(this.rootElementSelector) : (
            // Comment tag doesn't have closest method, so use parent's one.
            element.parentElement?.closest(this.rootElementSelector)
          );
        }
        if (rootElement && (typeof ngDevMode === "undefined" || ngDevMode)) {
          assertElementNode(rootElement, "cdkDrag");
        }
        this._dragRef.withRootElement(rootElement || element);
      }
      /** Gets the boundary element, based on the `boundaryElement` value. */
      _getBoundaryElement() {
        const boundary = this.boundaryElement;
        if (!boundary) {
          return null;
        }
        if (typeof boundary === "string") {
          return this.element.nativeElement.closest(boundary);
        }
        return coerceElement(boundary);
      }
      /** Syncs the inputs of the CdkDrag with the options of the underlying DragRef. */
      _syncInputs(ref) {
        ref.beforeStarted.subscribe(() => {
          if (!ref.isDragging()) {
            const dir = this._dir;
            const dragStartDelay = this.dragStartDelay;
            const placeholder = this._placeholderTemplate ? {
              template: this._placeholderTemplate.templateRef,
              context: this._placeholderTemplate.data,
              viewContainer: this._viewContainerRef
            } : null;
            const preview = this._previewTemplate ? {
              template: this._previewTemplate.templateRef,
              context: this._previewTemplate.data,
              matchSize: this._previewTemplate.matchSize,
              viewContainer: this._viewContainerRef
            } : null;
            ref.disabled = this.disabled;
            ref.lockAxis = this.lockAxis;
            ref.scale = this.scale;
            ref.dragStartDelay = typeof dragStartDelay === "object" && dragStartDelay ? dragStartDelay : coerceNumberProperty(dragStartDelay);
            ref.constrainPosition = this.constrainPosition;
            ref.previewClass = this.previewClass;
            ref.withBoundaryElement(this._getBoundaryElement()).withPlaceholderTemplate(placeholder).withPreviewTemplate(preview).withPreviewContainer(this.previewContainer || "global");
            if (dir) {
              ref.withDirection(dir.value);
            }
          }
        });
        ref.beforeStarted.pipe(take(1)).subscribe(() => {
          if (this._parentDrag) {
            ref.withParent(this._parentDrag._dragRef);
            return;
          }
          let parent = this.element.nativeElement.parentElement;
          while (parent) {
            const parentDrag = this._dragDropRegistry.getDragDirectiveForNode(parent);
            if (parentDrag) {
              ref.withParent(parentDrag._dragRef);
              break;
            }
            parent = parent.parentElement;
          }
        });
      }
      /** Handles the events from the underlying `DragRef`. */
      _handleEvents(ref) {
        ref.started.subscribe((startEvent) => {
          this.started.emit({
            source: this,
            event: startEvent.event
          });
          this._changeDetectorRef.markForCheck();
        });
        ref.released.subscribe((releaseEvent) => {
          this.released.emit({
            source: this,
            event: releaseEvent.event
          });
        });
        ref.ended.subscribe((endEvent) => {
          this.ended.emit({
            source: this,
            distance: endEvent.distance,
            dropPoint: endEvent.dropPoint,
            event: endEvent.event
          });
          this._changeDetectorRef.markForCheck();
        });
        ref.entered.subscribe((enterEvent) => {
          this.entered.emit({
            container: enterEvent.container.data,
            item: this,
            currentIndex: enterEvent.currentIndex
          });
        });
        ref.exited.subscribe((exitEvent) => {
          this.exited.emit({
            container: exitEvent.container.data,
            item: this
          });
        });
        ref.dropped.subscribe((dropEvent) => {
          this.dropped.emit({
            previousIndex: dropEvent.previousIndex,
            currentIndex: dropEvent.currentIndex,
            previousContainer: dropEvent.previousContainer.data,
            container: dropEvent.container.data,
            isPointerOverContainer: dropEvent.isPointerOverContainer,
            item: this,
            distance: dropEvent.distance,
            dropPoint: dropEvent.dropPoint,
            event: dropEvent.event
          });
        });
      }
      /** Assigns the default input values based on a provided config object. */
      _assignDefaults(config3) {
        const {
          lockAxis,
          dragStartDelay,
          constrainPosition,
          previewClass,
          boundaryElement,
          draggingDisabled,
          rootElementSelector,
          previewContainer
        } = config3;
        this.disabled = draggingDisabled == null ? false : draggingDisabled;
        this.dragStartDelay = dragStartDelay || 0;
        if (lockAxis) {
          this.lockAxis = lockAxis;
        }
        if (constrainPosition) {
          this.constrainPosition = constrainPosition;
        }
        if (previewClass) {
          this.previewClass = previewClass;
        }
        if (boundaryElement) {
          this.boundaryElement = boundaryElement;
        }
        if (rootElementSelector) {
          this.rootElementSelector = rootElementSelector;
        }
        if (previewContainer) {
          this.previewContainer = previewContainer;
        }
      }
      /** Sets up the listener that syncs the handles with the drag ref. */
      _setupHandlesListener() {
        this._handles.pipe(
          // Sync the new handles with the DragRef.
          tap((handles) => {
            const handleElements = handles.map((handle) => handle.element);
            if (this._selfHandle && this.rootElementSelector) {
              handleElements.push(this.element);
            }
            this._dragRef.withHandles(handleElements);
          }),
          // Listen if the state of any of the handles changes.
          switchMap((handles) => {
            return merge(...handles.map((item) => item._stateChanges.pipe(startWith(item))));
          }),
          takeUntil(this._destroyed)
        ).subscribe((handleInstance) => {
          const dragRef = this._dragRef;
          const handle = handleInstance.element.nativeElement;
          handleInstance.disabled ? dragRef.disableHandle(handle) : dragRef.enableHandle(handle);
        });
      }
      static \u0275fac = function CdkDrag_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkDrag)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkDrag,
        selectors: [["", "cdkDrag", ""]],
        hostAttrs: [1, "cdk-drag"],
        hostVars: 4,
        hostBindings: function CdkDrag_HostBindings(rf, ctx) {
          if (rf & 2) {
            \u0275\u0275classProp("cdk-drag-disabled", ctx.disabled)("cdk-drag-dragging", ctx._dragRef.isDragging());
          }
        },
        inputs: {
          data: [0, "cdkDragData", "data"],
          lockAxis: [0, "cdkDragLockAxis", "lockAxis"],
          rootElementSelector: [0, "cdkDragRootElement", "rootElementSelector"],
          boundaryElement: [0, "cdkDragBoundary", "boundaryElement"],
          dragStartDelay: [0, "cdkDragStartDelay", "dragStartDelay"],
          freeDragPosition: [0, "cdkDragFreeDragPosition", "freeDragPosition"],
          disabled: [2, "cdkDragDisabled", "disabled", booleanAttribute],
          constrainPosition: [0, "cdkDragConstrainPosition", "constrainPosition"],
          previewClass: [0, "cdkDragPreviewClass", "previewClass"],
          previewContainer: [0, "cdkDragPreviewContainer", "previewContainer"],
          scale: [2, "cdkDragScale", "scale", numberAttribute]
        },
        outputs: {
          started: "cdkDragStarted",
          released: "cdkDragReleased",
          ended: "cdkDragEnded",
          entered: "cdkDragEntered",
          exited: "cdkDragExited",
          dropped: "cdkDragDropped",
          moved: "cdkDragMoved"
        },
        exportAs: ["cdkDrag"],
        features: [\u0275\u0275ProvidersFeature([{
          provide: CDK_DRAG_PARENT,
          useExisting: _CdkDrag
        }]), \u0275\u0275NgOnChangesFeature]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDrag, [{
        type: Directive,
        args: [{
          selector: "[cdkDrag]",
          exportAs: "cdkDrag",
          host: {
            "class": "cdk-drag",
            "[class.cdk-drag-disabled]": "disabled",
            "[class.cdk-drag-dragging]": "_dragRef.isDragging()"
          },
          providers: [{
            provide: CDK_DRAG_PARENT,
            useExisting: CdkDrag
          }]
        }]
      }], () => [], {
        data: [{
          type: Input,
          args: ["cdkDragData"]
        }],
        lockAxis: [{
          type: Input,
          args: ["cdkDragLockAxis"]
        }],
        rootElementSelector: [{
          type: Input,
          args: ["cdkDragRootElement"]
        }],
        boundaryElement: [{
          type: Input,
          args: ["cdkDragBoundary"]
        }],
        dragStartDelay: [{
          type: Input,
          args: ["cdkDragStartDelay"]
        }],
        freeDragPosition: [{
          type: Input,
          args: ["cdkDragFreeDragPosition"]
        }],
        disabled: [{
          type: Input,
          args: [{
            alias: "cdkDragDisabled",
            transform: booleanAttribute
          }]
        }],
        constrainPosition: [{
          type: Input,
          args: ["cdkDragConstrainPosition"]
        }],
        previewClass: [{
          type: Input,
          args: ["cdkDragPreviewClass"]
        }],
        previewContainer: [{
          type: Input,
          args: ["cdkDragPreviewContainer"]
        }],
        scale: [{
          type: Input,
          args: [{
            alias: "cdkDragScale",
            transform: numberAttribute
          }]
        }],
        started: [{
          type: Output,
          args: ["cdkDragStarted"]
        }],
        released: [{
          type: Output,
          args: ["cdkDragReleased"]
        }],
        ended: [{
          type: Output,
          args: ["cdkDragEnded"]
        }],
        entered: [{
          type: Output,
          args: ["cdkDragEntered"]
        }],
        exited: [{
          type: Output,
          args: ["cdkDragExited"]
        }],
        dropped: [{
          type: Output,
          args: ["cdkDragDropped"]
        }],
        moved: [{
          type: Output,
          args: ["cdkDragMoved"]
        }]
      });
    })();
    CDK_DROP_LIST_GROUP = new InjectionToken("CdkDropListGroup");
    CdkDropListGroup = class _CdkDropListGroup {
      /** Drop lists registered inside the group. */
      _items = /* @__PURE__ */ new Set();
      /** Whether starting a dragging sequence from inside this group is disabled. */
      disabled = false;
      ngOnDestroy() {
        this._items.clear();
      }
      static \u0275fac = function CdkDropListGroup_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkDropListGroup)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkDropListGroup,
        selectors: [["", "cdkDropListGroup", ""]],
        inputs: {
          disabled: [2, "cdkDropListGroupDisabled", "disabled", booleanAttribute]
        },
        exportAs: ["cdkDropListGroup"],
        features: [\u0275\u0275ProvidersFeature([{
          provide: CDK_DROP_LIST_GROUP,
          useExisting: _CdkDropListGroup
        }])]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDropListGroup, [{
        type: Directive,
        args: [{
          selector: "[cdkDropListGroup]",
          exportAs: "cdkDropListGroup",
          providers: [{
            provide: CDK_DROP_LIST_GROUP,
            useExisting: CdkDropListGroup
          }]
        }]
      }], null, {
        disabled: [{
          type: Input,
          args: [{
            alias: "cdkDropListGroupDisabled",
            transform: booleanAttribute
          }]
        }]
      });
    })();
    CdkDropList = class _CdkDropList {
      element = inject2(ElementRef);
      _changeDetectorRef = inject2(ChangeDetectorRef);
      _scrollDispatcher = inject2(ScrollDispatcher);
      _dir = inject2(Directionality, {
        optional: true
      });
      _group = inject2(CDK_DROP_LIST_GROUP, {
        optional: true,
        skipSelf: true
      });
      /** Refs that have been synced with the drop ref most recently. */
      _latestSortedRefs;
      /** Emits when the list has been destroyed. */
      _destroyed = new Subject();
      /** Whether the element's scrollable parents have been resolved. */
      _scrollableParentsResolved;
      /** Keeps track of the drop lists that are currently on the page. */
      static _dropLists = [];
      /** Reference to the underlying drop list instance. */
      _dropListRef;
      /**
       * Other draggable containers that this container is connected to and into which the
       * container's items can be transferred. Can either be references to other drop containers,
       * or their unique IDs.
       */
      connectedTo = [];
      /** Arbitrary data to attach to this container. */
      data;
      /** Direction in which the list is oriented. */
      orientation;
      /**
       * Unique ID for the drop zone. Can be used as a reference
       * in the `connectedTo` of another `CdkDropList`.
       */
      id = inject2(_IdGenerator).getId("cdk-drop-list-");
      /** Locks the position of the draggable elements inside the container along the specified axis. */
      lockAxis;
      /** Whether starting a dragging sequence from this container is disabled. */
      get disabled() {
        return this._disabled || !!this._group && this._group.disabled;
      }
      set disabled(value) {
        this._dropListRef.disabled = this._disabled = value;
      }
      _disabled;
      /** Whether sorting within this drop list is disabled. */
      sortingDisabled;
      /**
       * Function that is used to determine whether an item
       * is allowed to be moved into a drop container.
       */
      enterPredicate = () => true;
      /** Functions that is used to determine whether an item can be sorted into a particular index. */
      sortPredicate = () => true;
      /** Whether to auto-scroll the view when the user moves their pointer close to the edges. */
      autoScrollDisabled;
      /** Number of pixels to scroll for each frame when auto-scrolling an element. */
      autoScrollStep;
      /**
       * Selector that will be used to resolve an alternate element container for the drop list.
       * Passing an alternate container is useful for the cases where one might not have control
       * over the parent node of the draggable items within the list (e.g. due to content projection).
       * This allows for usages like:
       *
       * ```
       * <div cdkDropList cdkDropListElementContainer=".inner">
       *   <div class="inner">
       *     <div cdkDrag></div>
       *   </div>
       * </div>
       * ```
       */
      elementContainerSelector;
      /**
       * By default when an item leaves its initial container, its placeholder will be transferred
       * to the new container. If that's not desirable for your use case, you can enable this option
       * which will clone the placeholder and leave it inside the original container. If the item is
       * returned to the initial container, the anchor element will be removed automatically.
       *
       * The cloned placeholder can be styled by targeting the `cdk-drag-anchor` class.
       *
       * This option is useful in combination with `cdkDropListSortingDisabled` to implement copying
       * behavior in a drop list.
       */
      hasAnchor;
      /** Emits when the user drops an item inside the container. */
      dropped = new EventEmitter();
      /**
       * Emits when the user has moved a new drag item into this container.
       */
      entered = new EventEmitter();
      /**
       * Emits when the user removes an item from the container
       * by dragging it into another container.
       */
      exited = new EventEmitter();
      /** Emits as the user is swapping items while actively dragging. */
      sorted = new EventEmitter();
      /**
       * Keeps track of the items that are registered with this container. Historically we used to
       * do this with a `ContentChildren` query, however queries don't handle transplanted views very
       * well which means that we can't handle cases like dragging the headers of a `mat-table`
       * correctly. What we do instead is to have the items register themselves with the container
       * and then we sort them based on their position in the DOM.
       */
      _unsortedItems = /* @__PURE__ */ new Set();
      constructor() {
        const dragDrop = inject2(DragDrop);
        const config3 = inject2(CDK_DRAG_CONFIG, {
          optional: true
        });
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          assertElementNode(this.element.nativeElement, "cdkDropList");
        }
        this._dropListRef = dragDrop.createDropList(this.element);
        this._dropListRef.data = this;
        if (config3) {
          this._assignDefaults(config3);
        }
        this._dropListRef.enterPredicate = (drag, drop) => {
          return this.enterPredicate(drag.data, drop.data);
        };
        this._dropListRef.sortPredicate = (index, drag, drop) => {
          return this.sortPredicate(index, drag.data, drop.data);
        };
        this._setupInputSyncSubscription(this._dropListRef);
        this._handleEvents(this._dropListRef);
        _CdkDropList._dropLists.push(this);
        if (this._group) {
          this._group._items.add(this);
        }
      }
      /** Registers an items with the drop list. */
      addItem(item) {
        this._unsortedItems.add(item);
        item._dragRef._withDropContainer(this._dropListRef);
        if (this._dropListRef.isDragging()) {
          this._syncItemsWithRef(this.getSortedItems().map((item2) => item2._dragRef));
        }
      }
      /** Removes an item from the drop list. */
      removeItem(item) {
        this._unsortedItems.delete(item);
        if (this._latestSortedRefs) {
          const index = this._latestSortedRefs.indexOf(item._dragRef);
          if (index > -1) {
            this._latestSortedRefs.splice(index, 1);
            this._syncItemsWithRef(this._latestSortedRefs);
          }
        }
      }
      /** Gets the registered items in the list, sorted by their position in the DOM. */
      getSortedItems() {
        return Array.from(this._unsortedItems).sort((a, b) => {
          const documentPosition = a._dragRef.getVisibleElement().compareDocumentPosition(b._dragRef.getVisibleElement());
          return documentPosition & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
        });
      }
      ngOnDestroy() {
        const index = _CdkDropList._dropLists.indexOf(this);
        if (index > -1) {
          _CdkDropList._dropLists.splice(index, 1);
        }
        if (this._group) {
          this._group._items.delete(this);
        }
        this._latestSortedRefs = void 0;
        this._unsortedItems.clear();
        this._dropListRef.dispose();
        this._destroyed.next();
        this._destroyed.complete();
      }
      /** Syncs the inputs of the CdkDropList with the options of the underlying DropListRef. */
      _setupInputSyncSubscription(ref) {
        if (this._dir) {
          this._dir.change.pipe(startWith(this._dir.value), takeUntil(this._destroyed)).subscribe((value) => ref.withDirection(value));
        }
        ref.beforeStarted.subscribe(() => {
          const siblings = coerceArray(this.connectedTo).map((drop) => {
            if (typeof drop === "string") {
              const correspondingDropList = _CdkDropList._dropLists.find((list) => list.id === drop);
              if (!correspondingDropList && (typeof ngDevMode === "undefined" || ngDevMode)) {
                console.warn(`CdkDropList could not find connected drop list with id "${drop}"`);
              }
              return correspondingDropList;
            }
            return drop;
          });
          if (this._group) {
            this._group._items.forEach((drop) => {
              if (siblings.indexOf(drop) === -1) {
                siblings.push(drop);
              }
            });
          }
          if (!this._scrollableParentsResolved) {
            const scrollableParents2 = this._scrollDispatcher.getAncestorScrollContainers(this.element).map((scrollable) => scrollable.getElementRef().nativeElement);
            this._dropListRef.withScrollableParents(scrollableParents2);
            this._scrollableParentsResolved = true;
          }
          if (this.elementContainerSelector) {
            const container = this.element.nativeElement.querySelector(this.elementContainerSelector);
            if (!container && (typeof ngDevMode === "undefined" || ngDevMode)) {
              throw new Error(`CdkDropList could not find an element container matching the selector "${this.elementContainerSelector}"`);
            }
            ref.withElementContainer(container);
          }
          ref.disabled = this.disabled;
          ref.lockAxis = this.lockAxis;
          ref.sortingDisabled = this.sortingDisabled;
          ref.autoScrollDisabled = this.autoScrollDisabled;
          ref.autoScrollStep = coerceNumberProperty(this.autoScrollStep, 2);
          ref.hasAnchor = this.hasAnchor;
          ref.connectedTo(siblings.filter((drop) => drop && drop !== this).map((list) => list._dropListRef)).withOrientation(this.orientation);
        });
      }
      /** Handles events from the underlying DropListRef. */
      _handleEvents(ref) {
        ref.beforeStarted.subscribe(() => {
          this._syncItemsWithRef(this.getSortedItems().map((item) => item._dragRef));
          this._changeDetectorRef.markForCheck();
        });
        ref.entered.subscribe((event) => {
          this.entered.emit({
            container: this,
            item: event.item.data,
            currentIndex: event.currentIndex
          });
        });
        ref.exited.subscribe((event) => {
          this.exited.emit({
            container: this,
            item: event.item.data
          });
          this._changeDetectorRef.markForCheck();
        });
        ref.sorted.subscribe((event) => {
          this.sorted.emit({
            previousIndex: event.previousIndex,
            currentIndex: event.currentIndex,
            container: this,
            item: event.item.data
          });
        });
        ref.dropped.subscribe((dropEvent) => {
          this.dropped.emit({
            previousIndex: dropEvent.previousIndex,
            currentIndex: dropEvent.currentIndex,
            previousContainer: dropEvent.previousContainer.data,
            container: dropEvent.container.data,
            item: dropEvent.item.data,
            isPointerOverContainer: dropEvent.isPointerOverContainer,
            distance: dropEvent.distance,
            dropPoint: dropEvent.dropPoint,
            event: dropEvent.event
          });
          this._changeDetectorRef.markForCheck();
        });
        merge(ref.receivingStarted, ref.receivingStopped).subscribe(() => this._changeDetectorRef.markForCheck());
      }
      /** Assigns the default input values based on a provided config object. */
      _assignDefaults(config3) {
        const {
          lockAxis,
          draggingDisabled,
          sortingDisabled,
          listAutoScrollDisabled,
          listOrientation
        } = config3;
        this.disabled = draggingDisabled == null ? false : draggingDisabled;
        this.sortingDisabled = sortingDisabled == null ? false : sortingDisabled;
        this.autoScrollDisabled = listAutoScrollDisabled == null ? false : listAutoScrollDisabled;
        this.orientation = listOrientation || "vertical";
        if (lockAxis) {
          this.lockAxis = lockAxis;
        }
      }
      /** Syncs up the registered drag items with underlying drop list ref. */
      _syncItemsWithRef(items) {
        this._latestSortedRefs = items;
        this._dropListRef.withItems(items);
      }
      static \u0275fac = function CdkDropList_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkDropList)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkDropList,
        selectors: [["", "cdkDropList", ""], ["cdk-drop-list"]],
        hostAttrs: [1, "cdk-drop-list"],
        hostVars: 7,
        hostBindings: function CdkDropList_HostBindings(rf, ctx) {
          if (rf & 2) {
            \u0275\u0275attribute("id", ctx.id);
            \u0275\u0275classProp("cdk-drop-list-disabled", ctx.disabled)("cdk-drop-list-dragging", ctx._dropListRef.isDragging())("cdk-drop-list-receiving", ctx._dropListRef.isReceiving());
          }
        },
        inputs: {
          connectedTo: [0, "cdkDropListConnectedTo", "connectedTo"],
          data: [0, "cdkDropListData", "data"],
          orientation: [0, "cdkDropListOrientation", "orientation"],
          id: "id",
          lockAxis: [0, "cdkDropListLockAxis", "lockAxis"],
          disabled: [2, "cdkDropListDisabled", "disabled", booleanAttribute],
          sortingDisabled: [2, "cdkDropListSortingDisabled", "sortingDisabled", booleanAttribute],
          enterPredicate: [0, "cdkDropListEnterPredicate", "enterPredicate"],
          sortPredicate: [0, "cdkDropListSortPredicate", "sortPredicate"],
          autoScrollDisabled: [2, "cdkDropListAutoScrollDisabled", "autoScrollDisabled", booleanAttribute],
          autoScrollStep: [0, "cdkDropListAutoScrollStep", "autoScrollStep"],
          elementContainerSelector: [0, "cdkDropListElementContainer", "elementContainerSelector"],
          hasAnchor: [2, "cdkDropListHasAnchor", "hasAnchor", booleanAttribute]
        },
        outputs: {
          dropped: "cdkDropListDropped",
          entered: "cdkDropListEntered",
          exited: "cdkDropListExited",
          sorted: "cdkDropListSorted"
        },
        exportAs: ["cdkDropList"],
        features: [\u0275\u0275ProvidersFeature([
          // Prevent child drop lists from picking up the same group as their parent.
          {
            provide: CDK_DROP_LIST_GROUP,
            useValue: void 0
          },
          {
            provide: CDK_DROP_LIST,
            useExisting: _CdkDropList
          }
        ])]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDropList, [{
        type: Directive,
        args: [{
          selector: "[cdkDropList], cdk-drop-list",
          exportAs: "cdkDropList",
          providers: [
            // Prevent child drop lists from picking up the same group as their parent.
            {
              provide: CDK_DROP_LIST_GROUP,
              useValue: void 0
            },
            {
              provide: CDK_DROP_LIST,
              useExisting: CdkDropList
            }
          ],
          host: {
            "class": "cdk-drop-list",
            "[attr.id]": "id",
            "[class.cdk-drop-list-disabled]": "disabled",
            "[class.cdk-drop-list-dragging]": "_dropListRef.isDragging()",
            "[class.cdk-drop-list-receiving]": "_dropListRef.isReceiving()"
          }
        }]
      }], () => [], {
        connectedTo: [{
          type: Input,
          args: ["cdkDropListConnectedTo"]
        }],
        data: [{
          type: Input,
          args: ["cdkDropListData"]
        }],
        orientation: [{
          type: Input,
          args: ["cdkDropListOrientation"]
        }],
        id: [{
          type: Input
        }],
        lockAxis: [{
          type: Input,
          args: ["cdkDropListLockAxis"]
        }],
        disabled: [{
          type: Input,
          args: [{
            alias: "cdkDropListDisabled",
            transform: booleanAttribute
          }]
        }],
        sortingDisabled: [{
          type: Input,
          args: [{
            alias: "cdkDropListSortingDisabled",
            transform: booleanAttribute
          }]
        }],
        enterPredicate: [{
          type: Input,
          args: ["cdkDropListEnterPredicate"]
        }],
        sortPredicate: [{
          type: Input,
          args: ["cdkDropListSortPredicate"]
        }],
        autoScrollDisabled: [{
          type: Input,
          args: [{
            alias: "cdkDropListAutoScrollDisabled",
            transform: booleanAttribute
          }]
        }],
        autoScrollStep: [{
          type: Input,
          args: ["cdkDropListAutoScrollStep"]
        }],
        elementContainerSelector: [{
          type: Input,
          args: ["cdkDropListElementContainer"]
        }],
        hasAnchor: [{
          type: Input,
          args: [{
            alias: "cdkDropListHasAnchor",
            transform: booleanAttribute
          }]
        }],
        dropped: [{
          type: Output,
          args: ["cdkDropListDropped"]
        }],
        entered: [{
          type: Output,
          args: ["cdkDropListEntered"]
        }],
        exited: [{
          type: Output,
          args: ["cdkDropListExited"]
        }],
        sorted: [{
          type: Output,
          args: ["cdkDropListSorted"]
        }]
      });
    })();
    CDK_DRAG_PREVIEW = new InjectionToken("CdkDragPreview");
    CdkDragPreview = class _CdkDragPreview {
      templateRef = inject2(TemplateRef);
      _drag = inject2(CDK_DRAG_PARENT, {
        optional: true
      });
      /** Context data to be added to the preview template instance. */
      data;
      /** Whether the preview should preserve the same size as the item that is being dragged. */
      matchSize = false;
      constructor() {
        this._drag?._setPreviewTemplate(this);
      }
      ngOnDestroy() {
        this._drag?._resetPreviewTemplate(this);
      }
      static \u0275fac = function CdkDragPreview_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkDragPreview)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkDragPreview,
        selectors: [["ng-template", "cdkDragPreview", ""]],
        inputs: {
          data: "data",
          matchSize: [2, "matchSize", "matchSize", booleanAttribute]
        },
        features: [\u0275\u0275ProvidersFeature([{
          provide: CDK_DRAG_PREVIEW,
          useExisting: _CdkDragPreview
        }])]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragPreview, [{
        type: Directive,
        args: [{
          selector: "ng-template[cdkDragPreview]",
          providers: [{
            provide: CDK_DRAG_PREVIEW,
            useExisting: CdkDragPreview
          }]
        }]
      }], () => [], {
        data: [{
          type: Input
        }],
        matchSize: [{
          type: Input,
          args: [{
            transform: booleanAttribute
          }]
        }]
      });
    })();
    CDK_DRAG_PLACEHOLDER = new InjectionToken("CdkDragPlaceholder");
    CdkDragPlaceholder = class _CdkDragPlaceholder {
      templateRef = inject2(TemplateRef);
      _drag = inject2(CDK_DRAG_PARENT, {
        optional: true
      });
      /** Context data to be added to the placeholder template instance. */
      data;
      constructor() {
        this._drag?._setPlaceholderTemplate(this);
      }
      ngOnDestroy() {
        this._drag?._resetPlaceholderTemplate(this);
      }
      static \u0275fac = function CdkDragPlaceholder_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _CdkDragPlaceholder)();
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
        type: _CdkDragPlaceholder,
        selectors: [["ng-template", "cdkDragPlaceholder", ""]],
        inputs: {
          data: "data"
        },
        features: [\u0275\u0275ProvidersFeature([{
          provide: CDK_DRAG_PLACEHOLDER,
          useExisting: _CdkDragPlaceholder
        }])]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragPlaceholder, [{
        type: Directive,
        args: [{
          selector: "ng-template[cdkDragPlaceholder]",
          providers: [{
            provide: CDK_DRAG_PLACEHOLDER,
            useExisting: CdkDragPlaceholder
          }]
        }]
      }], () => [], {
        data: [{
          type: Input
        }]
      });
    })();
    DRAG_DROP_DIRECTIVES = [CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder];
    DragDropModule = class _DragDropModule {
      static \u0275fac = function DragDropModule_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _DragDropModule)();
      };
      static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
        type: _DragDropModule,
        imports: [CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder],
        exports: [CdkScrollableModule, CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder]
      });
      static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
        providers: [DragDrop],
        imports: [CdkScrollableModule]
      });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDropModule, [{
        type: NgModule,
        args: [{
          imports: DRAG_DROP_DIRECTIVES,
          exports: [CdkScrollableModule, ...DRAG_DROP_DIRECTIVES],
          providers: [DragDrop]
        }]
      }], null, null);
    })();
  }
});

// node_modules/@marijn/find-cluster-break/src/index.js
function isExtendingChar(code) {
  if (code < 768) return false;
  for (let from2 = 0, to = rangeFrom.length; ; ) {
    let mid = from2 + to >> 1;
    if (code < rangeFrom[mid]) to = mid;
    else if (code >= rangeTo[mid]) from2 = mid + 1;
    else return true;
    if (from2 == to) return false;
  }
}
function isRegionalIndicator(code) {
  return code >= 127462 && code <= 127487;
}
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
  if (pos == str.length) return pos;
  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;
  let prev = codePointAt(str, pos);
  pos += codePointSize(prev);
  while (pos < str.length) {
    let next = codePointAt(str, pos);
    if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
      pos += codePointSize(next);
      prev = next;
    } else if (isRegionalIndicator(next)) {
      let countBefore = 0, i = pos - 2;
      while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
        countBefore++;
        i -= 2;
      }
      if (countBefore % 2 == 0) break;
      else pos += 2;
    } else {
      break;
    }
  }
  return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
  while (pos > 0) {
    let found = nextClusterBreak(str, pos - 2, includeExtending);
    if (found < pos) return found;
    pos--;
  }
  return 0;
}
function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow(code1)) return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function surrogateLow(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointSize(code) {
  return code < 65536 ? 1 : 2;
}
var rangeFrom, rangeTo, ZWJ;
var init_src = __esm({
  "node_modules/@marijn/find-cluster-break/src/index.js"() {
    "use strict";
    rangeFrom = [];
    rangeTo = [];
    (() => {
      let numbers = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
      for (let i = 0, n = 0; i < numbers.length; i++)
        (i % 2 ? rangeTo : rangeFrom).push(n = n + numbers[i]);
    })();
    ZWJ = 8205;
  }
});

// node_modules/@codemirror/state/dist/index.js
function textLength(text) {
  let length = -1;
  for (let line of text)
    length += line.length + 1;
  return length;
}
function appendText(text, target, from2 = 0, to = 1e9) {
  for (let pos = 0, i = 0, first2 = true; i < text.length && pos <= to; i++) {
    let line = text[i], end = pos + line.length;
    if (end >= from2) {
      if (end > to)
        line = line.slice(0, to - pos);
      if (pos < from2)
        line = line.slice(from2 - pos);
      if (first2) {
        target[target.length - 1] += line;
        first2 = false;
      } else
        target.push(line);
    }
    pos = end + 1;
  }
  return target;
}
function sliceText(text, from2, to) {
  return appendText(text, [""], from2, to);
}
function clip(text, from2, to) {
  from2 = Math.max(0, Math.min(text.length, from2));
  return [from2, Math.max(from2, Math.min(text.length, to))];
}
function findClusterBreak2(str, pos, forward = true, includeExtending = true) {
  return findClusterBreak(str, pos, forward, includeExtending);
}
function surrogateLow2(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh2(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointAt2(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh2(code0) || pos + 1 == str.length)
    return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow2(code1))
    return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function fromCodePoint(code) {
  if (code <= 65535)
    return String.fromCharCode(code);
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
function codePointSize2(code) {
  return code < 65536 ? 1 : 2;
}
function addSection(sections, len, ins, forceJoin = false) {
  if (len == 0 && ins <= 0)
    return;
  let last4 = sections.length - 2;
  if (last4 >= 0 && ins <= 0 && ins == sections[last4 + 1])
    sections[last4] += len;
  else if (last4 >= 0 && len == 0 && sections[last4] == 0)
    sections[last4 + 1] += ins;
  else if (forceJoin) {
    sections[last4] += len;
    sections[last4 + 1] += ins;
  } else
    sections.push(len, ins);
}
function addInsert(values2, sections, value) {
  if (value.length == 0)
    return;
  let index = sections.length - 2 >> 1;
  if (index < values2.length) {
    values2[values2.length - 1] = values2[values2.length - 1].append(value);
  } else {
    while (values2.length < index)
      values2.push(Text2.empty);
    values2.push(value);
  }
}
function iterChanges(desc, f, individual) {
  let inserted = desc.inserted;
  for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
    let len = desc.sections[i++], ins = desc.sections[i++];
    if (ins < 0) {
      posA += len;
      posB += len;
    } else {
      let endA = posA, endB = posB, text = Text2.empty;
      for (; ; ) {
        endA += len;
        endB += ins;
        if (ins && inserted)
          text = text.append(inserted[i - 2 >> 1]);
        if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
          break;
        len = desc.sections[i++];
        ins = desc.sections[i++];
      }
      f(posA, endA, posB, endB, text);
      posA = endA;
      posB = endB;
    }
  }
}
function mapSet(setA, setB, before, mkSet = false) {
  let sections = [], insert2 = mkSet ? [] : null;
  let a = new SectionIter(setA), b = new SectionIter(setB);
  for (let inserted = -1; ; ) {
    if (a.done && b.len || b.done && a.len) {
      throw new Error("Mismatched change set lengths");
    } else if (a.ins == -1 && b.ins == -1) {
      let len = Math.min(a.len, b.len);
      addSection(sections, len, -1);
      a.forward(len);
      b.forward(len);
    } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
      let len = b.len;
      addSection(sections, b.ins, -1);
      while (len) {
        let piece = Math.min(a.len, len);
        if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
          addSection(sections, 0, a.ins);
          if (insert2)
            addInsert(insert2, sections, a.text);
          inserted = a.i;
        }
        a.forward(piece);
        len -= piece;
      }
      b.next();
    } else if (a.ins >= 0) {
      let len = 0, left = a.len;
      while (left) {
        if (b.ins == -1) {
          let piece = Math.min(left, b.len);
          len += piece;
          left -= piece;
          b.forward(piece);
        } else if (b.ins == 0 && b.len < left) {
          left -= b.len;
          b.next();
        } else {
          break;
        }
      }
      addSection(sections, len, inserted < a.i ? a.ins : 0);
      if (insert2 && inserted < a.i)
        addInsert(insert2, sections, a.text);
      inserted = a.i;
      a.forward(a.len - left);
    } else if (a.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else {
      throw new Error("Mismatched change set lengths");
    }
  }
}
function composeSets(setA, setB, mkSet = false) {
  let sections = [];
  let insert2 = mkSet ? [] : null;
  let a = new SectionIter(setA), b = new SectionIter(setB);
  for (let open = false; ; ) {
    if (a.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else if (a.ins == 0) {
      addSection(sections, a.len, 0, open);
      a.next();
    } else if (b.len == 0 && !b.done) {
      addSection(sections, 0, b.ins, open);
      if (insert2)
        addInsert(insert2, sections, b.text);
      b.next();
    } else if (a.done || b.done) {
      throw new Error("Mismatched change set lengths");
    } else {
      let len = Math.min(a.len2, b.len), sectionLen = sections.length;
      if (a.ins == -1) {
        let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
        addSection(sections, len, insB, open);
        if (insert2 && insB)
          addInsert(insert2, sections, b.text);
      } else if (b.ins == -1) {
        addSection(sections, a.off ? 0 : a.len, len, open);
        if (insert2)
          addInsert(insert2, sections, a.textBit(len));
      } else {
        addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
        if (insert2 && !b.off)
          addInsert(insert2, sections, b.text);
      }
      open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
      a.forward2(len);
      b.forward(len);
    }
  }
}
function checkSelection(selection2, docLength) {
  for (let range of selection2.ranges)
    if (range.to > docLength)
      throw new RangeError("Selection points outside of document");
}
function sameArray(a, b) {
  return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
}
function compareArray(a, b, compare3) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!compare3(a[i], b[i]))
      return false;
  return true;
}
function ensureAll(state, addrs) {
  let changed = false;
  for (let addr of addrs)
    if (ensureAddr(state, addr) & 1)
      changed = true;
  return changed;
}
function dynamicFacetSlot(addresses, facet, providers) {
  let providerAddrs = providers.map((p) => addresses[p.id]);
  let providerTypes = providers.map((p) => p.type);
  let dynamic = providerAddrs.filter((p) => !(p & 1));
  let idx = addresses[facet.id] >> 1;
  function get(state) {
    let values2 = [];
    for (let i = 0; i < providerAddrs.length; i++) {
      let value = getAddr(state, providerAddrs[i]);
      if (providerTypes[i] == 2)
        for (let val of value)
          values2.push(val);
      else
        values2.push(value);
    }
    return facet.combine(values2);
  }
  return {
    create(state) {
      for (let addr of providerAddrs)
        ensureAddr(state, addr);
      state.values[idx] = get(state);
      return 1;
    },
    update(state, tr) {
      if (!ensureAll(state, dynamic))
        return 0;
      let value = get(state);
      if (facet.compare(value, state.values[idx]))
        return 0;
      state.values[idx] = value;
      return 1;
    },
    reconfigure(state, oldState) {
      let depChanged = ensureAll(state, providerAddrs);
      let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
      if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
        state.values[idx] = oldValue;
        return 0;
      }
      let value = get(state);
      if (facet.compare(value, oldValue)) {
        state.values[idx] = oldValue;
        return 0;
      }
      state.values[idx] = value;
      return 1;
    }
  };
}
function prec(value) {
  return (ext) => new PrecExtension(ext, value);
}
function flatten2(extension, compartments, newCompartments) {
  let result = [[], [], [], [], []];
  let seen = /* @__PURE__ */ new Map();
  function inner(ext, prec2) {
    let known = seen.get(ext);
    if (known != null) {
      if (known <= prec2)
        return;
      let found = result[known].indexOf(ext);
      if (found > -1)
        result[known].splice(found, 1);
      if (ext instanceof CompartmentInstance)
        newCompartments.delete(ext.compartment);
    }
    seen.set(ext, prec2);
    if (Array.isArray(ext)) {
      for (let e of ext)
        inner(e, prec2);
    } else if (ext instanceof CompartmentInstance) {
      if (newCompartments.has(ext.compartment))
        throw new RangeError(`Duplicate use of compartment in extensions`);
      let content2 = compartments.get(ext.compartment) || ext.inner;
      newCompartments.set(ext.compartment, content2);
      inner(content2, prec2);
    } else if (ext instanceof PrecExtension) {
      inner(ext.inner, ext.prec);
    } else if (ext instanceof StateField) {
      result[prec2].push(ext);
      if (ext.provides)
        inner(ext.provides, prec2);
    } else if (ext instanceof FacetProvider) {
      result[prec2].push(ext);
      if (ext.facet.extensions)
        inner(ext.facet.extensions, Prec_.default);
    } else {
      let content2 = ext.extension;
      if (!content2)
        throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      inner(content2, prec2);
    }
  }
  inner(extension, Prec_.default);
  return result.reduce((a, b) => a.concat(b));
}
function ensureAddr(state, addr) {
  if (addr & 1)
    return 2;
  let idx = addr >> 1;
  let status = state.status[idx];
  if (status == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (status & 2)
    return status;
  state.status[idx] = 4;
  let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
  return state.status[idx] = 2 | changed;
}
function getAddr(state, addr) {
  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}
function joinRanges(a, b) {
  let result = [];
  for (let iA = 0, iB = 0; ; ) {
    let from2, to;
    if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
      from2 = a[iA++];
      to = a[iA++];
    } else if (iB < b.length) {
      from2 = b[iB++];
      to = b[iB++];
    } else
      return result;
    if (!result.length || result[result.length - 1] < from2)
      result.push(from2, to);
    else if (result[result.length - 1] < to)
      result[result.length - 1] = to;
  }
}
function mergeTransaction(a, b, sequential) {
  var _a2;
  let mapForA, mapForB, changes;
  if (sequential) {
    mapForA = b.changes;
    mapForB = ChangeSet.empty(b.changes.length);
    changes = a.changes.compose(b.changes);
  } else {
    mapForA = b.changes.map(a.changes);
    mapForB = a.changes.mapDesc(b.changes, true);
    changes = a.changes.compose(mapForA);
  }
  return {
    changes,
    selection: b.selection ? b.selection.map(mapForB) : (_a2 = a.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
    effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
    annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
    scrollIntoView: a.scrollIntoView || b.scrollIntoView
  };
}
function resolveTransactionInner(state, spec, docSize) {
  let sel = spec.selection, annotations = asArray(spec.annotations);
  if (spec.userEvent)
    annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
  return {
    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
    effects: asArray(spec.effects),
    annotations,
    scrollIntoView: !!spec.scrollIntoView
  };
}
function resolveTransaction(state, specs, filter2) {
  let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
  if (specs.length && specs[0].filter === false)
    filter2 = false;
  for (let i = 1; i < specs.length; i++) {
    if (specs[i].filter === false)
      filter2 = false;
    let seq = !!specs[i].sequential;
    s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
  }
  let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
  return extendTransaction(filter2 ? filterTransaction(tr) : tr);
}
function filterTransaction(tr) {
  let state = tr.startState;
  let result = true;
  for (let filter2 of state.facet(changeFilter)) {
    let value = filter2(tr);
    if (value === false) {
      result = false;
      break;
    }
    if (Array.isArray(value))
      result = result === true ? value : joinRanges(result, value);
  }
  if (result !== true) {
    let changes, back;
    if (result === false) {
      back = tr.changes.invertedDesc;
      changes = ChangeSet.empty(state.doc.length);
    } else {
      let filtered = tr.changes.filter(result);
      changes = filtered.changes;
      back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
    }
    tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
  }
  let filters = state.facet(transactionFilter);
  for (let i = filters.length - 1; i >= 0; i--) {
    let filtered = filters[i](tr);
    if (filtered instanceof Transaction)
      tr = filtered;
    else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
      tr = filtered[0];
    else
      tr = resolveTransaction(state, asArray(filtered), false);
  }
  return tr;
}
function extendTransaction(tr) {
  let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
  for (let i = extenders.length - 1; i >= 0; i--) {
    let extension = extenders[i](tr);
    if (extension && Object.keys(extension).length)
      spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
  }
  return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
function asArray(value) {
  return value == null ? none : Array.isArray(value) ? value : [value];
}
function hasWordChar(str) {
  if (wordChar)
    return wordChar.test(str);
  for (let i = 0; i < str.length; i++) {
    let ch = str[i];
    if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
      return true;
  }
  return false;
}
function makeCategorizer(wordChars) {
  return (char) => {
    if (!/\S/.test(char))
      return CharCategory.Space;
    if (hasWordChar(char))
      return CharCategory.Word;
    for (let i = 0; i < wordChars.length; i++)
      if (char.indexOf(wordChars[i]) > -1)
        return CharCategory.Word;
    return CharCategory.Other;
  };
}
function combineConfig(configs, defaults3, combine = {}) {
  let result = {};
  for (let config3 of configs)
    for (let key of Object.keys(config3)) {
      let value = config3[key], current = result[key];
      if (current === void 0)
        result[key] = value;
      else if (current === value || value === void 0) ;
      else if (Object.hasOwnProperty.call(combine, key))
        result[key] = combine[key](current, value);
      else
        throw new Error("Config merge conflict for field " + key);
    }
  for (let key in defaults3)
    if (result[key] === void 0)
      result[key] = defaults3[key];
  return result;
}
function cmpRange(a, b) {
  return a.from - b.from || a.value.startSide - b.value.startSide;
}
function lazySort(ranges) {
  if (ranges.length > 1)
    for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
      let cur2 = ranges[i];
      if (cmpRange(prev, cur2) > 0)
        return ranges.slice().sort(cmpRange);
      prev = cur2;
    }
  return ranges;
}
function findSharedChunks(a, b, textDiff) {
  let inA = /* @__PURE__ */ new Map();
  for (let set of a)
    for (let i = 0; i < set.chunk.length; i++)
      if (set.chunk[i].maxPoint <= 0)
        inA.set(set.chunk[i], set.chunkPos[i]);
  let shared = /* @__PURE__ */ new Set();
  for (let set of b)
    for (let i = 0; i < set.chunk.length; i++) {
      let known = inA.get(set.chunk[i]);
      if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))
        shared.add(set.chunk[i]);
    }
  return shared;
}
function heapBubble(heap, index) {
  for (let cur2 = heap[index]; ; ) {
    let childIndex = (index << 1) + 1;
    if (childIndex >= heap.length)
      break;
    let child = heap[childIndex];
    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
      child = heap[childIndex + 1];
      childIndex++;
    }
    if (cur2.compare(child) < 0)
      break;
    heap[childIndex] = cur2;
    heap[index] = child;
    index = childIndex;
  }
}
function compare2(a, startA, b, startB, length, comparator) {
  a.goto(startA);
  b.goto(startB);
  let endB = startB + length;
  let pos = startB, dPos = startB - startA;
  for (; ; ) {
    let dEnd = a.to + dPos - b.to, diff = dEnd || a.endSide - b.endSide;
    let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
    if (a.point || b.point) {
      if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))))
        comparator.comparePoint(pos, clipEnd, a.point, b.point);
    } else {
      if (clipEnd > pos && !sameValues(a.active, b.active))
        comparator.compareRange(pos, clipEnd, a.active, b.active);
    }
    if (end > endB)
      break;
    if ((dEnd || a.openEnd != b.openEnd) && comparator.boundChange)
      comparator.boundChange(end);
    pos = end;
    if (diff <= 0)
      a.next();
    if (diff >= 0)
      b.next();
  }
}
function sameValues(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (a[i] != b[i] && !a[i].eq(b[i]))
      return false;
  return true;
}
function remove2(array, index) {
  for (let i = index, e = array.length - 1; i < e; i++)
    array[i] = array[i + 1];
  array.pop();
}
function insert(array, index, value) {
  for (let i = array.length - 1; i >= index; i--)
    array[i + 1] = array[i];
  array[index] = value;
}
function findMinIndex(value, array) {
  let found = -1, foundPos = 1e9;
  for (let i = 0; i < array.length; i++)
    if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
      found = i;
      foundPos = array[i];
    }
  return found;
}
function countColumn(string2, tabSize, to = string2.length) {
  let n = 0;
  for (let i = 0; i < to && i < string2.length; ) {
    if (string2.charCodeAt(i) == 9) {
      n += tabSize - n % tabSize;
      i++;
    } else {
      n++;
      i = findClusterBreak2(string2, i);
    }
  }
  return n;
}
function findColumn(string2, col, tabSize, strict) {
  for (let i = 0, n = 0; ; ) {
    if (n >= col)
      return i;
    if (i == string2.length)
      break;
    n += string2.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;
    i = findClusterBreak2(string2, i);
  }
  return strict === true ? -1 : string2.length;
}
var Text2, TextLeaf, TextNode, RawTextCursor, PartialTextCursor, LineCursor, Line, DefaultSplit, MapMode, ChangeDesc, ChangeSet, SectionIter, SelectionRange, EditorSelection, nextID, Facet, FacetProvider, initField, StateField, Prec_, Prec, PrecExtension, Compartment, CompartmentInstance, Configuration, languageData, allowMultipleSelections, lineSeparator, changeFilter, transactionFilter, transactionExtender, readOnly, Annotation, AnnotationType, StateEffectType, StateEffect, Transaction, none, CharCategory, nonASCIISingleCaseWordChar, wordChar, EditorState, RangeValue, Range, Chunk, RangeSet, RangeSetBuilder, LayerCursor, HeapCursor, SpanCursor;
var init_dist = __esm({
  "node_modules/@codemirror/state/dist/index.js"() {
    "use strict";
    init_src();
    Text2 = class _Text {
      /**
      Get the line description around the given position.
      */
      lineAt(pos) {
        if (pos < 0 || pos > this.length)
          throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
        return this.lineInner(pos, false, 1, 0);
      }
      /**
      Get the description for the given (1-based) line number.
      */
      line(n) {
        if (n < 1 || n > this.lines)
          throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
        return this.lineInner(n, true, 1, 0);
      }
      /**
      Replace a range of the text with the given content.
      */
      replace(from2, to, text) {
        [from2, to] = clip(this, from2, to);
        let parts = [];
        this.decompose(
          0,
          from2,
          parts,
          2
          /* Open.To */
        );
        if (text.length)
          text.decompose(
            0,
            text.length,
            parts,
            1 | 2
            /* Open.To */
          );
        this.decompose(
          to,
          this.length,
          parts,
          1
          /* Open.From */
        );
        return TextNode.from(parts, this.length - (to - from2) + text.length);
      }
      /**
      Append another document to this one.
      */
      append(other) {
        return this.replace(this.length, this.length, other);
      }
      /**
      Retrieve the text between the given points.
      */
      slice(from2, to = this.length) {
        [from2, to] = clip(this, from2, to);
        let parts = [];
        this.decompose(from2, to, parts, 0);
        return TextNode.from(parts, to - from2);
      }
      /**
      Test whether this text is equal to another instance.
      */
      eq(other) {
        if (other == this)
          return true;
        if (other.length != this.length || other.lines != this.lines)
          return false;
        let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
        let a = new RawTextCursor(this), b = new RawTextCursor(other);
        for (let skip = start, pos = start; ; ) {
          a.next(skip);
          b.next(skip);
          skip = 0;
          if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
            return false;
          pos += a.value.length;
          if (a.done || pos >= end)
            return true;
        }
      }
      /**
      Iterate over the text. When `dir` is `-1`, iteration happens
      from end to start. This will return lines and the breaks between
      them as separate strings.
      */
      iter(dir = 1) {
        return new RawTextCursor(this, dir);
      }
      /**
      Iterate over a range of the text. When `from` > `to`, the
      iterator will run in reverse.
      */
      iterRange(from2, to = this.length) {
        return new PartialTextCursor(this, from2, to);
      }
      /**
      Return a cursor that iterates over the given range of lines,
      _without_ returning the line breaks between, and yielding empty
      strings for empty lines.
      
      When `from` and `to` are given, they should be 1-based line numbers.
      */
      iterLines(from2, to) {
        let inner;
        if (from2 == null) {
          inner = this.iter();
        } else {
          if (to == null)
            to = this.lines + 1;
          let start = this.line(from2).from;
          inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
        }
        return new LineCursor(inner);
      }
      /**
      Return the document as a string, using newline characters to
      separate lines.
      */
      toString() {
        return this.sliceString(0);
      }
      /**
      Convert the document to an array of lines (which can be
      deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
      */
      toJSON() {
        let lines = [];
        this.flatten(lines);
        return lines;
      }
      /**
      @internal
      */
      constructor() {
      }
      /**
      Create a `Text` instance for the given array of lines.
      */
      static of(text) {
        if (text.length == 0)
          throw new RangeError("A document must have at least one line");
        if (text.length == 1 && !text[0])
          return _Text.empty;
        return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
      }
    };
    TextLeaf = class _TextLeaf extends Text2 {
      constructor(text, length = textLength(text)) {
        super();
        this.text = text;
        this.length = length;
      }
      get lines() {
        return this.text.length;
      }
      get children() {
        return null;
      }
      lineInner(target, isLine, line, offset) {
        for (let i = 0; ; i++) {
          let string2 = this.text[i], end = offset + string2.length;
          if ((isLine ? line : end) >= target)
            return new Line(offset, end, line, string2);
          offset = end + 1;
          line++;
        }
      }
      decompose(from2, to, target, open) {
        let text = from2 <= 0 && to >= this.length ? this : new _TextLeaf(sliceText(this.text, from2, to), Math.min(to, this.length) - Math.max(0, from2));
        if (open & 1) {
          let prev = target.pop();
          let joined = appendText(text.text, prev.text.slice(), 0, text.length);
          if (joined.length <= 32) {
            target.push(new _TextLeaf(joined, prev.length + text.length));
          } else {
            let mid = joined.length >> 1;
            target.push(new _TextLeaf(joined.slice(0, mid)), new _TextLeaf(joined.slice(mid)));
          }
        } else {
          target.push(text);
        }
      }
      replace(from2, to, text) {
        if (!(text instanceof _TextLeaf))
          return super.replace(from2, to, text);
        [from2, to] = clip(this, from2, to);
        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from2)), to);
        let newLen = this.length + text.length - (to - from2);
        if (lines.length <= 32)
          return new _TextLeaf(lines, newLen);
        return TextNode.from(_TextLeaf.split(lines, []), newLen);
      }
      sliceString(from2, to = this.length, lineSep = "\n") {
        [from2, to] = clip(this, from2, to);
        let result = "";
        for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
          let line = this.text[i], end = pos + line.length;
          if (pos > from2 && i)
            result += lineSep;
          if (from2 < end && to > pos)
            result += line.slice(Math.max(0, from2 - pos), to - pos);
          pos = end + 1;
        }
        return result;
      }
      flatten(target) {
        for (let line of this.text)
          target.push(line);
      }
      scanIdentical() {
        return 0;
      }
      static split(text, target) {
        let part = [], len = -1;
        for (let line of text) {
          part.push(line);
          len += line.length + 1;
          if (part.length == 32) {
            target.push(new _TextLeaf(part, len));
            part = [];
            len = -1;
          }
        }
        if (len > -1)
          target.push(new _TextLeaf(part, len));
        return target;
      }
    };
    TextNode = class _TextNode extends Text2 {
      constructor(children, length) {
        super();
        this.children = children;
        this.length = length;
        this.lines = 0;
        for (let child of children)
          this.lines += child.lines;
      }
      lineInner(target, isLine, line, offset) {
        for (let i = 0; ; i++) {
          let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
          if ((isLine ? endLine : end) >= target)
            return child.lineInner(target, isLine, line, offset);
          offset = end + 1;
          line = endLine + 1;
        }
      }
      decompose(from2, to, target, open) {
        for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
          let child = this.children[i], end = pos + child.length;
          if (from2 <= end && to >= pos) {
            let childOpen = open & ((pos <= from2 ? 1 : 0) | (end >= to ? 2 : 0));
            if (pos >= from2 && end <= to && !childOpen)
              target.push(child);
            else
              child.decompose(from2 - pos, to - pos, target, childOpen);
          }
          pos = end + 1;
        }
      }
      replace(from2, to, text) {
        [from2, to] = clip(this, from2, to);
        if (text.lines < this.lines)
          for (let i = 0, pos = 0; i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (from2 >= pos && to <= end) {
              let updated = child.replace(from2 - pos, to - pos, text);
              let totalLines = this.lines - child.lines + updated.lines;
              if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
                let copy = this.children.slice();
                copy[i] = updated;
                return new _TextNode(copy, this.length - (to - from2) + text.length);
              }
              return super.replace(pos, end, updated);
            }
            pos = end + 1;
          }
        return super.replace(from2, to, text);
      }
      sliceString(from2, to = this.length, lineSep = "\n") {
        [from2, to] = clip(this, from2, to);
        let result = "";
        for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
          let child = this.children[i], end = pos + child.length;
          if (pos > from2 && i)
            result += lineSep;
          if (from2 < end && to > pos)
            result += child.sliceString(from2 - pos, to - pos, lineSep);
          pos = end + 1;
        }
        return result;
      }
      flatten(target) {
        for (let child of this.children)
          child.flatten(target);
      }
      scanIdentical(other, dir) {
        if (!(other instanceof _TextNode))
          return 0;
        let length = 0;
        let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
        for (; ; iA += dir, iB += dir) {
          if (iA == eA || iB == eB)
            return length;
          let chA = this.children[iA], chB = other.children[iB];
          if (chA != chB)
            return length + chA.scanIdentical(chB, dir);
          length += chA.length + 1;
        }
      }
      static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
        let lines = 0;
        for (let ch of children)
          lines += ch.lines;
        if (lines < 32) {
          let flat = [];
          for (let ch of children)
            ch.flatten(flat);
          return new TextLeaf(flat, length);
        }
        let chunk = Math.max(
          32,
          lines >> 5
          /* Tree.BranchShift */
        ), maxChunk = chunk << 1, minChunk = chunk >> 1;
        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
        function add2(child) {
          let last4;
          if (child.lines > maxChunk && child instanceof _TextNode) {
            for (let node of child.children)
              add2(node);
          } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
            flush();
            chunked.push(child);
          } else if (child instanceof TextLeaf && currentLines && (last4 = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last4.lines <= 32) {
            currentLines += child.lines;
            currentLen += child.length + 1;
            currentChunk[currentChunk.length - 1] = new TextLeaf(last4.text.concat(child.text), last4.length + 1 + child.length);
          } else {
            if (currentLines + child.lines > chunk)
              flush();
            currentLines += child.lines;
            currentLen += child.length + 1;
            currentChunk.push(child);
          }
        }
        function flush() {
          if (currentLines == 0)
            return;
          chunked.push(currentChunk.length == 1 ? currentChunk[0] : _TextNode.from(currentChunk, currentLen));
          currentLen = -1;
          currentLines = currentChunk.length = 0;
        }
        for (let child of children)
          add2(child);
        flush();
        return chunked.length == 1 ? chunked[0] : new _TextNode(chunked, length);
      }
    };
    Text2.empty = /* @__PURE__ */ new TextLeaf([""], 0);
    RawTextCursor = class {
      constructor(text, dir = 1) {
        this.dir = dir;
        this.done = false;
        this.lineBreak = false;
        this.value = "";
        this.nodes = [text];
        this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
      }
      nextInner(skip, dir) {
        this.done = this.lineBreak = false;
        for (; ; ) {
          let last4 = this.nodes.length - 1;
          let top2 = this.nodes[last4], offsetValue = this.offsets[last4], offset = offsetValue >> 1;
          let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
          if (offset == (dir > 0 ? size : 0)) {
            if (last4 == 0) {
              this.done = true;
              this.value = "";
              return this;
            }
            if (dir > 0)
              this.offsets[last4 - 1]++;
            this.nodes.pop();
            this.offsets.pop();
          } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
            this.offsets[last4] += dir;
            if (skip == 0) {
              this.lineBreak = true;
              this.value = "\n";
              return this;
            }
            skip--;
          } else if (top2 instanceof TextLeaf) {
            let next = top2.text[offset + (dir < 0 ? -1 : 0)];
            this.offsets[last4] += dir;
            if (next.length > Math.max(0, skip)) {
              this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
              return this;
            }
            skip -= next.length;
          } else {
            let next = top2.children[offset + (dir < 0 ? -1 : 0)];
            if (skip > next.length) {
              skip -= next.length;
              this.offsets[last4] += dir;
            } else {
              if (dir < 0)
                this.offsets[last4]--;
              this.nodes.push(next);
              this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
            }
          }
        }
      }
      next(skip = 0) {
        if (skip < 0) {
          this.nextInner(-skip, -this.dir);
          skip = this.value.length;
        }
        return this.nextInner(skip, this.dir);
      }
    };
    PartialTextCursor = class {
      constructor(text, start, end) {
        this.value = "";
        this.done = false;
        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
        this.pos = start > end ? text.length : 0;
        this.from = Math.min(start, end);
        this.to = Math.max(start, end);
      }
      nextInner(skip, dir) {
        if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
          this.value = "";
          this.done = true;
          return this;
        }
        skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
        let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
        if (skip > limit)
          skip = limit;
        limit -= skip;
        let { value } = this.cursor.next(skip);
        this.pos += (value.length + skip) * dir;
        this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
        this.done = !this.value;
        return this;
      }
      next(skip = 0) {
        if (skip < 0)
          skip = Math.max(skip, this.from - this.pos);
        else if (skip > 0)
          skip = Math.min(skip, this.to - this.pos);
        return this.nextInner(skip, this.cursor.dir);
      }
      get lineBreak() {
        return this.cursor.lineBreak && this.value != "";
      }
    };
    LineCursor = class {
      constructor(inner) {
        this.inner = inner;
        this.afterBreak = true;
        this.value = "";
        this.done = false;
      }
      next(skip = 0) {
        let { done, lineBreak, value } = this.inner.next(skip);
        if (done && this.afterBreak) {
          this.value = "";
          this.afterBreak = false;
        } else if (done) {
          this.done = true;
          this.value = "";
        } else if (lineBreak) {
          if (this.afterBreak) {
            this.value = "";
          } else {
            this.afterBreak = true;
            this.next();
          }
        } else {
          this.value = value;
          this.afterBreak = false;
        }
        return this;
      }
      get lineBreak() {
        return false;
      }
    };
    if (typeof Symbol != "undefined") {
      Text2.prototype[Symbol.iterator] = function() {
        return this.iter();
      };
      RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
        return this;
      };
    }
    Line = class {
      /**
      @internal
      */
      constructor(from2, to, number2, text) {
        this.from = from2;
        this.to = to;
        this.number = number2;
        this.text = text;
      }
      /**
      The length of the line (not including any line break after it).
      */
      get length() {
        return this.to - this.from;
      }
    };
    DefaultSplit = /\r\n?|\n/;
    MapMode = /* @__PURE__ */ function(MapMode2) {
      MapMode2[MapMode2["Simple"] = 0] = "Simple";
      MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
      MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
      MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
      return MapMode2;
    }(MapMode || (MapMode = {}));
    ChangeDesc = class _ChangeDesc {
      // Sections are encoded as pairs of integers. The first is the
      // length in the current document, and the second is -1 for
      // unaffected sections, and the length of the replacement content
      // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
      // 0), and a replacement two positive numbers.
      /**
      @internal
      */
      constructor(sections) {
        this.sections = sections;
      }
      /**
      The length of the document before the change.
      */
      get length() {
        let result = 0;
        for (let i = 0; i < this.sections.length; i += 2)
          result += this.sections[i];
        return result;
      }
      /**
      The length of the document after the change.
      */
      get newLength() {
        let result = 0;
        for (let i = 0; i < this.sections.length; i += 2) {
          let ins = this.sections[i + 1];
          result += ins < 0 ? this.sections[i] : ins;
        }
        return result;
      }
      /**
      False when there are actual changes in this set.
      */
      get empty() {
        return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
      }
      /**
      Iterate over the unchanged parts left by these changes. `posA`
      provides the position of the range in the old document, `posB`
      the new position in the changed document.
      */
      iterGaps(f) {
        for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
          let len = this.sections[i++], ins = this.sections[i++];
          if (ins < 0) {
            f(posA, posB, len);
            posB += len;
          } else {
            posB += ins;
          }
          posA += len;
        }
      }
      /**
      Iterate over the ranges changed by these changes. (See
      [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
      variant that also provides you with the inserted text.)
      `fromA`/`toA` provides the extent of the change in the starting
      document, `fromB`/`toB` the extent of the replacement in the
      changed document.
      
      When `individual` is true, adjacent changes (which are kept
      separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
      reported separately.
      */
      iterChangedRanges(f, individual = false) {
        iterChanges(this, f, individual);
      }
      /**
      Get a description of the inverted form of these changes.
      */
      get invertedDesc() {
        let sections = [];
        for (let i = 0; i < this.sections.length; ) {
          let len = this.sections[i++], ins = this.sections[i++];
          if (ins < 0)
            sections.push(len, ins);
          else
            sections.push(ins, len);
        }
        return new _ChangeDesc(sections);
      }
      /**
      Compute the combined effect of applying another set of changes
      after this one. The length of the document after this set should
      match the length before `other`.
      */
      composeDesc(other) {
        return this.empty ? other : other.empty ? this : composeSets(this, other);
      }
      /**
      Map this description, which should start with the same document
      as `other`, over another set of changes, so that it can be
      applied after it. When `before` is true, map as if the changes
      in `this` happened before the ones in `other`.
      */
      mapDesc(other, before = false) {
        return other.empty ? this : mapSet(this, other, before);
      }
      mapPos(pos, assoc = -1, mode = MapMode.Simple) {
        let posA = 0, posB = 0;
        for (let i = 0; i < this.sections.length; ) {
          let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
          if (ins < 0) {
            if (endA > pos)
              return posB + (pos - posA);
            posB += len;
          } else {
            if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
              return null;
            if (endA > pos || endA == pos && assoc < 0 && !len)
              return pos == posA || assoc < 0 ? posB : posB + ins;
            posB += ins;
          }
          posA = endA;
        }
        if (pos > posA)
          throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
        return posB;
      }
      /**
      Check whether these changes touch a given range. When one of the
      changes entirely covers the range, the string `"cover"` is
      returned.
      */
      touchesRange(from2, to = from2) {
        for (let i = 0, pos = 0; i < this.sections.length && pos <= to; ) {
          let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
          if (ins >= 0 && pos <= to && end >= from2)
            return pos < from2 && end > to ? "cover" : true;
          pos = end;
        }
        return false;
      }
      /**
      @internal
      */
      toString() {
        let result = "";
        for (let i = 0; i < this.sections.length; ) {
          let len = this.sections[i++], ins = this.sections[i++];
          result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
        }
        return result;
      }
      /**
      Serialize this change desc to a JSON-representable value.
      */
      toJSON() {
        return this.sections;
      }
      /**
      Create a change desc from its JSON representation (as produced
      by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
      */
      static fromJSON(json2) {
        if (!Array.isArray(json2) || json2.length % 2 || json2.some((a) => typeof a != "number"))
          throw new RangeError("Invalid JSON representation of ChangeDesc");
        return new _ChangeDesc(json2);
      }
      /**
      @internal
      */
      static create(sections) {
        return new _ChangeDesc(sections);
      }
    };
    ChangeSet = class _ChangeSet extends ChangeDesc {
      constructor(sections, inserted) {
        super(sections);
        this.inserted = inserted;
      }
      /**
      Apply the changes to a document, returning the modified
      document.
      */
      apply(doc2) {
        if (this.length != doc2.length)
          throw new RangeError("Applying change set to a document with the wrong length");
        iterChanges(this, (fromA, toA, fromB, _toB, text) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text), false);
        return doc2;
      }
      mapDesc(other, before = false) {
        return mapSet(this, other, before, true);
      }
      /**
      Given the document as it existed _before_ the changes, return a
      change set that represents the inverse of this set, which could
      be used to go from the document created by the changes back to
      the document as it existed before the changes.
      */
      invert(doc2) {
        let sections = this.sections.slice(), inserted = [];
        for (let i = 0, pos = 0; i < sections.length; i += 2) {
          let len = sections[i], ins = sections[i + 1];
          if (ins >= 0) {
            sections[i] = ins;
            sections[i + 1] = len;
            let index = i >> 1;
            while (inserted.length < index)
              inserted.push(Text2.empty);
            inserted.push(len ? doc2.slice(pos, pos + len) : Text2.empty);
          }
          pos += len;
        }
        return new _ChangeSet(sections, inserted);
      }
      /**
      Combine two subsequent change sets into a single set. `other`
      must start in the document produced by `this`. If `this` goes
      `docA`  `docB` and `other` represents `docB`  `docC`, the
      returned value will represent the change `docA`  `docC`.
      */
      compose(other) {
        return this.empty ? other : other.empty ? this : composeSets(this, other, true);
      }
      /**
      Given another change set starting in the same document, maps this
      change set over the other, producing a new change set that can be
      applied to the document produced by applying `other`. When
      `before` is `true`, order changes as if `this` comes before
      `other`, otherwise (the default) treat `other` as coming first.
      
      Given two changes `A` and `B`, `A.compose(B.map(A))` and
      `B.compose(A.map(B, true))` will produce the same document. This
      provides a basic form of [operational
      transformation](https://en.wikipedia.org/wiki/Operational_transformation),
      and can be used for collaborative editing.
      */
      map(other, before = false) {
        return other.empty ? this : mapSet(this, other, before, true);
      }
      /**
      Iterate over the changed ranges in the document, calling `f` for
      each, with the range in the original document (`fromA`-`toA`)
      and the range that replaces it in the new document
      (`fromB`-`toB`).
      
      When `individual` is true, adjacent changes are reported
      separately.
      */
      iterChanges(f, individual = false) {
        iterChanges(this, f, individual);
      }
      /**
      Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
      set.
      */
      get desc() {
        return ChangeDesc.create(this.sections);
      }
      /**
      @internal
      */
      filter(ranges) {
        let resultSections = [], resultInserted = [], filteredSections = [];
        let iter = new SectionIter(this);
        done: for (let i = 0, pos = 0; ; ) {
          let next = i == ranges.length ? 1e9 : ranges[i++];
          while (pos < next || pos == next && iter.len == 0) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, next - pos);
            addSection(filteredSections, len, -1);
            let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
            addSection(resultSections, len, ins);
            if (ins > 0)
              addInsert(resultInserted, resultSections, iter.text);
            iter.forward(len);
            pos += len;
          }
          let end = ranges[i++];
          while (pos < end) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, end - pos);
            addSection(resultSections, len, -1);
            addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
            iter.forward(len);
            pos += len;
          }
        }
        return {
          changes: new _ChangeSet(resultSections, resultInserted),
          filtered: ChangeDesc.create(filteredSections)
        };
      }
      /**
      Serialize this change set to a JSON-representable value.
      */
      toJSON() {
        let parts = [];
        for (let i = 0; i < this.sections.length; i += 2) {
          let len = this.sections[i], ins = this.sections[i + 1];
          if (ins < 0)
            parts.push(len);
          else if (ins == 0)
            parts.push([len]);
          else
            parts.push([len].concat(this.inserted[i >> 1].toJSON()));
        }
        return parts;
      }
      /**
      Create a change set for the given changes, for a document of the
      given length, using `lineSep` as line separator.
      */
      static of(changes, length, lineSep) {
        let sections = [], inserted = [], pos = 0;
        let total = null;
        function flush(force = false) {
          if (!force && !sections.length)
            return;
          if (pos < length)
            addSection(sections, length - pos, -1);
          let set = new _ChangeSet(sections, inserted);
          total = total ? total.compose(set.map(total)) : set;
          sections = [];
          inserted = [];
          pos = 0;
        }
        function process3(spec) {
          if (Array.isArray(spec)) {
            for (let sub of spec)
              process3(sub);
          } else if (spec instanceof _ChangeSet) {
            if (spec.length != length)
              throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
            flush();
            total = total ? total.compose(spec.map(total)) : spec;
          } else {
            let { from: from2, to = from2, insert: insert2 } = spec;
            if (from2 > to || from2 < 0 || to > length)
              throw new RangeError(`Invalid change range ${from2} to ${to} (in doc of length ${length})`);
            let insText = !insert2 ? Text2.empty : typeof insert2 == "string" ? Text2.of(insert2.split(lineSep || DefaultSplit)) : insert2;
            let insLen = insText.length;
            if (from2 == to && insLen == 0)
              return;
            if (from2 < pos)
              flush();
            if (from2 > pos)
              addSection(sections, from2 - pos, -1);
            addSection(sections, to - from2, insLen);
            addInsert(inserted, sections, insText);
            pos = to;
          }
        }
        process3(changes);
        flush(!total);
        return total;
      }
      /**
      Create an empty changeset of the given length.
      */
      static empty(length) {
        return new _ChangeSet(length ? [length, -1] : [], []);
      }
      /**
      Create a changeset from its JSON representation (as produced by
      [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
      */
      static fromJSON(json2) {
        if (!Array.isArray(json2))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        let sections = [], inserted = [];
        for (let i = 0; i < json2.length; i++) {
          let part = json2[i];
          if (typeof part == "number") {
            sections.push(part, -1);
          } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i2) => i2 && typeof e != "string")) {
            throw new RangeError("Invalid JSON representation of ChangeSet");
          } else if (part.length == 1) {
            sections.push(part[0], 0);
          } else {
            while (inserted.length < i)
              inserted.push(Text2.empty);
            inserted[i] = Text2.of(part.slice(1));
            sections.push(part[0], inserted[i].length);
          }
        }
        return new _ChangeSet(sections, inserted);
      }
      /**
      @internal
      */
      static createSet(sections, inserted) {
        return new _ChangeSet(sections, inserted);
      }
    };
    SectionIter = class {
      constructor(set) {
        this.set = set;
        this.i = 0;
        this.next();
      }
      next() {
        let { sections } = this.set;
        if (this.i < sections.length) {
          this.len = sections[this.i++];
          this.ins = sections[this.i++];
        } else {
          this.len = 0;
          this.ins = -2;
        }
        this.off = 0;
      }
      get done() {
        return this.ins == -2;
      }
      get len2() {
        return this.ins < 0 ? this.len : this.ins;
      }
      get text() {
        let { inserted } = this.set, index = this.i - 2 >> 1;
        return index >= inserted.length ? Text2.empty : inserted[index];
      }
      textBit(len) {
        let { inserted } = this.set, index = this.i - 2 >> 1;
        return index >= inserted.length && !len ? Text2.empty : inserted[index].slice(this.off, len == null ? void 0 : this.off + len);
      }
      forward(len) {
        if (len == this.len)
          this.next();
        else {
          this.len -= len;
          this.off += len;
        }
      }
      forward2(len) {
        if (this.ins == -1)
          this.forward(len);
        else if (len == this.ins)
          this.next();
        else {
          this.ins -= len;
          this.off += len;
        }
      }
    };
    SelectionRange = class _SelectionRange {
      constructor(from2, to, flags) {
        this.from = from2;
        this.to = to;
        this.flags = flags;
      }
      /**
      The anchor of the rangethe side that doesn't move when you
      extend it.
      */
      get anchor() {
        return this.flags & 32 ? this.to : this.from;
      }
      /**
      The head of the range, which is moved when the range is
      [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
      */
      get head() {
        return this.flags & 32 ? this.from : this.to;
      }
      /**
      True when `anchor` and `head` are at the same position.
      */
      get empty() {
        return this.from == this.to;
      }
      /**
      If this is a cursor that is explicitly associated with the
      character on one of its sides, this returns the side. -1 means
      the character before its position, 1 the character after, and 0
      means no association.
      */
      get assoc() {
        return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
      }
      /**
      The bidirectional text level associated with this cursor, if
      any.
      */
      get bidiLevel() {
        let level = this.flags & 7;
        return level == 7 ? null : level;
      }
      /**
      The goal column (stored vertical offset) associated with a
      cursor. This is used to preserve the vertical position when
      [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
      lines of different length.
      */
      get goalColumn() {
        let value = this.flags >> 6;
        return value == 16777215 ? void 0 : value;
      }
      /**
      Map this range through a change, producing a valid range in the
      updated document.
      */
      map(change, assoc = -1) {
        let from2, to;
        if (this.empty) {
          from2 = to = change.mapPos(this.from, assoc);
        } else {
          from2 = change.mapPos(this.from, 1);
          to = change.mapPos(this.to, -1);
        }
        return from2 == this.from && to == this.to ? this : new _SelectionRange(from2, to, this.flags);
      }
      /**
      Extend this range to cover at least `from` to `to`.
      */
      extend(from2, to = from2) {
        if (from2 <= this.anchor && to >= this.anchor)
          return EditorSelection.range(from2, to);
        let head = Math.abs(from2 - this.anchor) > Math.abs(to - this.anchor) ? from2 : to;
        return EditorSelection.range(this.anchor, head);
      }
      /**
      Compare this range to another range.
      */
      eq(other, includeAssoc = false) {
        return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);
      }
      /**
      Return a JSON-serializable object representing the range.
      */
      toJSON() {
        return { anchor: this.anchor, head: this.head };
      }
      /**
      Convert a JSON representation of a range to a `SelectionRange`
      instance.
      */
      static fromJSON(json2) {
        if (!json2 || typeof json2.anchor != "number" || typeof json2.head != "number")
          throw new RangeError("Invalid JSON representation for SelectionRange");
        return EditorSelection.range(json2.anchor, json2.head);
      }
      /**
      @internal
      */
      static create(from2, to, flags) {
        return new _SelectionRange(from2, to, flags);
      }
    };
    EditorSelection = class _EditorSelection {
      constructor(ranges, mainIndex) {
        this.ranges = ranges;
        this.mainIndex = mainIndex;
      }
      /**
      Map a selection through a change. Used to adjust the selection
      position for changes.
      */
      map(change, assoc = -1) {
        if (change.empty)
          return this;
        return _EditorSelection.create(this.ranges.map((r) => r.map(change, assoc)), this.mainIndex);
      }
      /**
      Compare this selection to another selection. By default, ranges
      are compared only by position. When `includeAssoc` is true,
      cursor ranges must also have the same
      [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
      */
      eq(other, includeAssoc = false) {
        if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
          return false;
        for (let i = 0; i < this.ranges.length; i++)
          if (!this.ranges[i].eq(other.ranges[i], includeAssoc))
            return false;
        return true;
      }
      /**
      Get the primary selection range. Usually, you should make sure
      your code applies to _all_ ranges, by using methods like
      [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
      */
      get main() {
        return this.ranges[this.mainIndex];
      }
      /**
      Make sure the selection only has one range. Returns a selection
      holding only the main range from this selection.
      */
      asSingle() {
        return this.ranges.length == 1 ? this : new _EditorSelection([this.main], 0);
      }
      /**
      Extend this selection with an extra range.
      */
      addRange(range, main = true) {
        return _EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
      }
      /**
      Replace a given range with another range, and then normalize the
      selection to merge and sort ranges if necessary.
      */
      replaceRange(range, which = this.mainIndex) {
        let ranges = this.ranges.slice();
        ranges[which] = range;
        return _EditorSelection.create(ranges, this.mainIndex);
      }
      /**
      Convert this selection to an object that can be serialized to
      JSON.
      */
      toJSON() {
        return { ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex };
      }
      /**
      Create a selection from a JSON representation.
      */
      static fromJSON(json2) {
        if (!json2 || !Array.isArray(json2.ranges) || typeof json2.main != "number" || json2.main >= json2.ranges.length)
          throw new RangeError("Invalid JSON representation for EditorSelection");
        return new _EditorSelection(json2.ranges.map((r) => SelectionRange.fromJSON(r)), json2.main);
      }
      /**
      Create a selection holding a single range.
      */
      static single(anchor, head = anchor) {
        return new _EditorSelection([_EditorSelection.range(anchor, head)], 0);
      }
      /**
      Sort and merge the given set of ranges, creating a valid
      selection.
      */
      static create(ranges, mainIndex = 0) {
        if (ranges.length == 0)
          throw new RangeError("A selection needs at least one range");
        for (let pos = 0, i = 0; i < ranges.length; i++) {
          let range = ranges[i];
          if (range.empty ? range.from <= pos : range.from < pos)
            return _EditorSelection.normalized(ranges.slice(), mainIndex);
          pos = range.to;
        }
        return new _EditorSelection(ranges, mainIndex);
      }
      /**
      Create a cursor selection range at the given position. You can
      safely ignore the optional arguments in most situations.
      */
      static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
        return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6);
      }
      /**
      Create a selection range.
      */
      static range(anchor, head, goalColumn, bidiLevel) {
        let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6 | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
        return head < anchor ? SelectionRange.create(head, anchor, 32 | 16 | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 : 0) | flags);
      }
      /**
      @internal
      */
      static normalized(ranges, mainIndex = 0) {
        let main = ranges[mainIndex];
        ranges.sort((a, b) => a.from - b.from);
        mainIndex = ranges.indexOf(main);
        for (let i = 1; i < ranges.length; i++) {
          let range = ranges[i], prev = ranges[i - 1];
          if (range.empty ? range.from <= prev.to : range.from < prev.to) {
            let from2 = prev.from, to = Math.max(range.to, prev.to);
            if (i <= mainIndex)
              mainIndex--;
            ranges.splice(--i, 2, range.anchor > range.head ? _EditorSelection.range(to, from2) : _EditorSelection.range(from2, to));
          }
        }
        return new _EditorSelection(ranges, mainIndex);
      }
    };
    nextID = 0;
    Facet = class _Facet {
      constructor(combine, compareInput, compare3, isStatic, enables) {
        this.combine = combine;
        this.compareInput = compareInput;
        this.compare = compare3;
        this.isStatic = isStatic;
        this.id = nextID++;
        this.default = combine([]);
        this.extensions = typeof enables == "function" ? enables(this) : enables;
      }
      /**
      Returns a facet reader for this facet, which can be used to
      [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
      */
      get reader() {
        return this;
      }
      /**
      Define a new facet.
      */
      static define(config3 = {}) {
        return new _Facet(config3.combine || ((a) => a), config3.compareInput || ((a, b) => a === b), config3.compare || (!config3.combine ? sameArray : (a, b) => a === b), !!config3.static, config3.enables);
      }
      /**
      Returns an extension that adds the given value to this facet.
      */
      of(value) {
        return new FacetProvider([], this, 0, value);
      }
      /**
      Create an extension that computes a value for the facet from a
      state. You must take care to declare the parts of the state that
      this value depends on, since your function is only called again
      for a new state when one of those parts changed.
      
      In cases where your value depends only on a single field, you'll
      want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
      */
      compute(deps, get) {
        if (this.isStatic)
          throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, 1, get);
      }
      /**
      Create an extension that computes zero or more values for this
      facet from a state.
      */
      computeN(deps, get) {
        if (this.isStatic)
          throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, 2, get);
      }
      from(field, get) {
        if (!get)
          get = (x) => x;
        return this.compute([field], (state) => get(state.field(field)));
      }
    };
    FacetProvider = class {
      constructor(dependencies, facet, type, value) {
        this.dependencies = dependencies;
        this.facet = facet;
        this.type = type;
        this.value = value;
        this.id = nextID++;
      }
      dynamicSlot(addresses) {
        var _a2;
        let getter = this.value;
        let compare3 = this.facet.compareInput;
        let id2 = this.id, idx = addresses[id2] >> 1, multi = this.type == 2;
        let depDoc = false, depSel = false, depAddrs = [];
        for (let dep of this.dependencies) {
          if (dep == "doc")
            depDoc = true;
          else if (dep == "selection")
            depSel = true;
          else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
            depAddrs.push(addresses[dep.id]);
        }
        return {
          create(state) {
            state.values[idx] = getter(state);
            return 1;
          },
          update(state, tr) {
            if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
              let newVal = getter(state);
              if (multi ? !compareArray(newVal, state.values[idx], compare3) : !compare3(newVal, state.values[idx])) {
                state.values[idx] = newVal;
                return 1;
              }
            }
            return 0;
          },
          reconfigure: (state, oldState) => {
            let newVal, oldAddr = oldState.config.address[id2];
            if (oldAddr != null) {
              let oldVal = getAddr(oldState, oldAddr);
              if (this.dependencies.every((dep) => {
                return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
              }) || (multi ? compareArray(newVal = getter(state), oldVal, compare3) : compare3(newVal = getter(state), oldVal))) {
                state.values[idx] = oldVal;
                return 0;
              }
            } else {
              newVal = getter(state);
            }
            state.values[idx] = newVal;
            return 1;
          }
        };
      }
    };
    initField = /* @__PURE__ */ Facet.define({ static: true });
    StateField = class _StateField {
      constructor(id2, createF, updateF, compareF, spec) {
        this.id = id2;
        this.createF = createF;
        this.updateF = updateF;
        this.compareF = compareF;
        this.spec = spec;
        this.provides = void 0;
      }
      /**
      Define a state field.
      */
      static define(config3) {
        let field = new _StateField(nextID++, config3.create, config3.update, config3.compare || ((a, b) => a === b), config3);
        if (config3.provide)
          field.provides = config3.provide(field);
        return field;
      }
      create(state) {
        let init = state.facet(initField).find((i) => i.field == this);
        return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
      }
      /**
      @internal
      */
      slot(addresses) {
        let idx = addresses[this.id] >> 1;
        return {
          create: (state) => {
            state.values[idx] = this.create(state);
            return 1;
          },
          update: (state, tr) => {
            let oldVal = state.values[idx];
            let value = this.updateF(oldVal, tr);
            if (this.compareF(oldVal, value))
              return 0;
            state.values[idx] = value;
            return 1;
          },
          reconfigure: (state, oldState) => {
            let init = state.facet(initField), oldInit = oldState.facet(initField), reInit;
            if ((reInit = init.find((i) => i.field == this)) && reInit != oldInit.find((i) => i.field == this)) {
              state.values[idx] = reInit.create(state);
              return 1;
            }
            if (oldState.config.address[this.id] != null) {
              state.values[idx] = oldState.field(this);
              return 0;
            }
            state.values[idx] = this.create(state);
            return 1;
          }
        };
      }
      /**
      Returns an extension that enables this field and overrides the
      way it is initialized. Can be useful when you need to provide a
      non-default starting value for the field.
      */
      init(create) {
        return [this, initField.of({ field: this, create })];
      }
      /**
      State field instances can be used as
      [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
      given state.
      */
      get extension() {
        return this;
      }
    };
    Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
    Prec = {
      /**
      The highest precedence level, for extensions that should end up
      near the start of the precedence ordering.
      */
      highest: /* @__PURE__ */ prec(Prec_.highest),
      /**
      A higher-than-default precedence, for extensions that should
      come before those with default precedence.
      */
      high: /* @__PURE__ */ prec(Prec_.high),
      /**
      The default precedence, which is also used for extensions
      without an explicit precedence.
      */
      default: /* @__PURE__ */ prec(Prec_.default),
      /**
      A lower-than-default precedence.
      */
      low: /* @__PURE__ */ prec(Prec_.low),
      /**
      The lowest precedence level. Meant for things that should end up
      near the end of the extension order.
      */
      lowest: /* @__PURE__ */ prec(Prec_.lowest)
    };
    PrecExtension = class {
      constructor(inner, prec2) {
        this.inner = inner;
        this.prec = prec2;
      }
    };
    Compartment = class _Compartment {
      /**
      Create an instance of this compartment to add to your [state
      configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
      */
      of(ext) {
        return new CompartmentInstance(this, ext);
      }
      /**
      Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
      reconfigures this compartment.
      */
      reconfigure(content2) {
        return _Compartment.reconfigure.of({ compartment: this, extension: content2 });
      }
      /**
      Get the current content of the compartment in the state, or
      `undefined` if it isn't present.
      */
      get(state) {
        return state.config.compartments.get(this);
      }
    };
    CompartmentInstance = class {
      constructor(compartment, inner) {
        this.compartment = compartment;
        this.inner = inner;
      }
    };
    Configuration = class _Configuration {
      constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
        this.base = base2;
        this.compartments = compartments;
        this.dynamicSlots = dynamicSlots;
        this.address = address;
        this.staticValues = staticValues;
        this.facets = facets;
        this.statusTemplate = [];
        while (this.statusTemplate.length < dynamicSlots.length)
          this.statusTemplate.push(
            0
            /* SlotStatus.Unresolved */
          );
      }
      staticFacet(facet) {
        let addr = this.address[facet.id];
        return addr == null ? facet.default : this.staticValues[addr >> 1];
      }
      static resolve(base2, compartments, oldState) {
        let fields = [];
        let facets = /* @__PURE__ */ Object.create(null);
        let newCompartments = /* @__PURE__ */ new Map();
        for (let ext of flatten2(base2, compartments, newCompartments)) {
          if (ext instanceof StateField)
            fields.push(ext);
          else
            (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
        }
        let address = /* @__PURE__ */ Object.create(null);
        let staticValues = [];
        let dynamicSlots = [];
        for (let field of fields) {
          address[field.id] = dynamicSlots.length << 1;
          dynamicSlots.push((a) => field.slot(a));
        }
        let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
        for (let id2 in facets) {
          let providers = facets[id2], facet = providers[0].facet;
          let oldProviders = oldFacets && oldFacets[id2] || [];
          if (providers.every(
            (p) => p.type == 0
            /* Provider.Static */
          )) {
            address[facet.id] = staticValues.length << 1 | 1;
            if (sameArray(oldProviders, providers)) {
              staticValues.push(oldState.facet(facet));
            } else {
              let value = facet.combine(providers.map((p) => p.value));
              staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
            }
          } else {
            for (let p of providers) {
              if (p.type == 0) {
                address[p.id] = staticValues.length << 1 | 1;
                staticValues.push(p.value);
              } else {
                address[p.id] = dynamicSlots.length << 1;
                dynamicSlots.push((a) => p.dynamicSlot(a));
              }
            }
            address[facet.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
          }
        }
        let dynamic = dynamicSlots.map((f) => f(address));
        return new _Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
      }
    };
    languageData = /* @__PURE__ */ Facet.define();
    allowMultipleSelections = /* @__PURE__ */ Facet.define({
      combine: (values2) => values2.some((v) => v),
      static: true
    });
    lineSeparator = /* @__PURE__ */ Facet.define({
      combine: (values2) => values2.length ? values2[0] : void 0,
      static: true
    });
    changeFilter = /* @__PURE__ */ Facet.define();
    transactionFilter = /* @__PURE__ */ Facet.define();
    transactionExtender = /* @__PURE__ */ Facet.define();
    readOnly = /* @__PURE__ */ Facet.define({
      combine: (values2) => values2.length ? values2[0] : false
    });
    Annotation = class {
      /**
      @internal
      */
      constructor(type, value) {
        this.type = type;
        this.value = value;
      }
      /**
      Define a new type of annotation.
      */
      static define() {
        return new AnnotationType();
      }
    };
    AnnotationType = class {
      /**
      Create an instance of this annotation.
      */
      of(value) {
        return new Annotation(this, value);
      }
    };
    StateEffectType = class {
      /**
      @internal
      */
      constructor(map2) {
        this.map = map2;
      }
      /**
      Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
      type.
      */
      of(value) {
        return new StateEffect(this, value);
      }
    };
    StateEffect = class _StateEffect {
      /**
      @internal
      */
      constructor(type, value) {
        this.type = type;
        this.value = value;
      }
      /**
      Map this effect through a position mapping. Will return
      `undefined` when that ends up deleting the effect.
      */
      map(mapping) {
        let mapped = this.type.map(this.value, mapping);
        return mapped === void 0 ? void 0 : mapped == this.value ? this : new _StateEffect(this.type, mapped);
      }
      /**
      Tells you whether this effect object is of a given
      [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
      */
      is(type) {
        return this.type == type;
      }
      /**
      Define a new effect type. The type parameter indicates the type
      of values that his effect holds. It should be a type that
      doesn't include `undefined`, since that is used in
      [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
      removed.
      */
      static define(spec = {}) {
        return new StateEffectType(spec.map || ((v) => v));
      }
      /**
      Map an array of effects through a change set.
      */
      static mapEffects(effects, mapping) {
        if (!effects.length)
          return effects;
        let result = [];
        for (let effect2 of effects) {
          let mapped = effect2.map(mapping);
          if (mapped)
            result.push(mapped);
        }
        return result;
      }
    };
    StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
    StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
    Transaction = class _Transaction {
      constructor(startState, changes, selection2, effects, annotations, scrollIntoView3) {
        this.startState = startState;
        this.changes = changes;
        this.selection = selection2;
        this.effects = effects;
        this.annotations = annotations;
        this.scrollIntoView = scrollIntoView3;
        this._doc = null;
        this._state = null;
        if (selection2)
          checkSelection(selection2, changes.newLength);
        if (!annotations.some((a) => a.type == _Transaction.time))
          this.annotations = annotations.concat(_Transaction.time.of(Date.now()));
      }
      /**
      @internal
      */
      static create(startState, changes, selection2, effects, annotations, scrollIntoView3) {
        return new _Transaction(startState, changes, selection2, effects, annotations, scrollIntoView3);
      }
      /**
      The new document produced by the transaction. Contrary to
      [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
      force the entire new state to be computed right away, so it is
      recommended that [transaction
      filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
      when they need to look at the new document.
      */
      get newDoc() {
        return this._doc || (this._doc = this.changes.apply(this.startState.doc));
      }
      /**
      The new selection produced by the transaction. If
      [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
      this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
      current selection through the changes made by the transaction.
      */
      get newSelection() {
        return this.selection || this.startState.selection.map(this.changes);
      }
      /**
      The new state created by the transaction. Computed on demand
      (but retained for subsequent access), so it is recommended not to
      access it in [transaction
      filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
      */
      get state() {
        if (!this._state)
          this.startState.applyTransaction(this);
        return this._state;
      }
      /**
      Get the value of the given annotation type, if any.
      */
      annotation(type) {
        for (let ann of this.annotations)
          if (ann.type == type)
            return ann.value;
        return void 0;
      }
      /**
      Indicates whether the transaction changed the document.
      */
      get docChanged() {
        return !this.changes.empty;
      }
      /**
      Indicates whether this transaction reconfigures the state
      (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
      with a top-level configuration
      [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
      */
      get reconfigured() {
        return this.startState.config != this.state.config;
      }
      /**
      Returns true if the transaction has a [user
      event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
      or more specific than `event`. For example, if the transaction
      has `"select.pointer"` as user event, `"select"` and
      `"select.pointer"` will match it.
      */
      isUserEvent(event) {
        let e = this.annotation(_Transaction.userEvent);
        return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
      }
    };
    Transaction.time = /* @__PURE__ */ Annotation.define();
    Transaction.userEvent = /* @__PURE__ */ Annotation.define();
    Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
    Transaction.remote = /* @__PURE__ */ Annotation.define();
    none = [];
    CharCategory = /* @__PURE__ */ function(CharCategory2) {
      CharCategory2[CharCategory2["Word"] = 0] = "Word";
      CharCategory2[CharCategory2["Space"] = 1] = "Space";
      CharCategory2[CharCategory2["Other"] = 2] = "Other";
      return CharCategory2;
    }(CharCategory || (CharCategory = {}));
    nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
    try {
      wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
    } catch (_) {
    }
    EditorState = class _EditorState {
      constructor(config3, doc2, selection2, values2, computeSlot, tr) {
        this.config = config3;
        this.doc = doc2;
        this.selection = selection2;
        this.values = values2;
        this.status = config3.statusTemplate.slice();
        this.computeSlot = computeSlot;
        if (tr)
          tr._state = this;
        for (let i = 0; i < this.config.dynamicSlots.length; i++)
          ensureAddr(this, i << 1);
        this.computeSlot = null;
      }
      field(field, require2 = true) {
        let addr = this.config.address[field.id];
        if (addr == null) {
          if (require2)
            throw new RangeError("Field is not present in this state");
          return void 0;
        }
        ensureAddr(this, addr);
        return getAddr(this, addr);
      }
      /**
      Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
      state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
      can be passed. Unless
      [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
      [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
      are assumed to start in the _current_ document (not the document
      produced by previous specs), and its
      [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
      [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
      to the document created by its _own_ changes. The resulting
      transaction contains the combined effect of all the different
      specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
      specs take precedence over earlier ones.
      */
      update(...specs) {
        return resolveTransaction(this, specs, true);
      }
      /**
      @internal
      */
      applyTransaction(tr) {
        let conf = this.config, { base: base2, compartments } = conf;
        for (let effect2 of tr.effects) {
          if (effect2.is(Compartment.reconfigure)) {
            if (conf) {
              compartments = /* @__PURE__ */ new Map();
              conf.compartments.forEach((val, key) => compartments.set(key, val));
              conf = null;
            }
            compartments.set(effect2.value.compartment, effect2.value.extension);
          } else if (effect2.is(StateEffect.reconfigure)) {
            conf = null;
            base2 = effect2.value;
          } else if (effect2.is(StateEffect.appendConfig)) {
            conf = null;
            base2 = asArray(base2).concat(effect2.value);
          }
        }
        let startValues;
        if (!conf) {
          conf = Configuration.resolve(base2, compartments, this);
          let intermediateState = new _EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
          startValues = intermediateState.values;
        } else {
          startValues = tr.startState.values.slice();
        }
        let selection2 = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();
        new _EditorState(conf, tr.newDoc, selection2, startValues, (state, slot) => slot.update(state, tr), tr);
      }
      /**
      Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
      replaces every selection range with the given content.
      */
      replaceSelection(text) {
        if (typeof text == "string")
          text = this.toText(text);
        return this.changeByRange((range) => ({
          changes: { from: range.from, to: range.to, insert: text },
          range: EditorSelection.cursor(range.from + text.length)
        }));
      }
      /**
      Create a set of changes and a new selection by running the given
      function for each range in the active selection. The function
      can return an optional set of changes (in the coordinate space
      of the start document), plus an updated range (in the coordinate
      space of the document produced by the call's own changes). This
      method will merge all the changes and ranges into a single
      changeset and selection, and return it as a [transaction
      spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
      [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
      */
      changeByRange(f) {
        let sel = this.selection;
        let result1 = f(sel.ranges[0]);
        let changes = this.changes(result1.changes), ranges = [result1.range];
        let effects = asArray(result1.effects);
        for (let i = 1; i < sel.ranges.length; i++) {
          let result = f(sel.ranges[i]);
          let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
          for (let j = 0; j < i; j++)
            ranges[j] = ranges[j].map(newMapped);
          let mapBy = changes.mapDesc(newChanges, true);
          ranges.push(result.range.map(mapBy));
          changes = changes.compose(newMapped);
          effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
        }
        return {
          changes,
          selection: EditorSelection.create(ranges, sel.mainIndex),
          effects
        };
      }
      /**
      Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
      description, taking the state's document length and line
      separator into account.
      */
      changes(spec = []) {
        if (spec instanceof ChangeSet)
          return spec;
        return ChangeSet.of(spec, this.doc.length, this.facet(_EditorState.lineSeparator));
      }
      /**
      Using the state's [line
      separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
      [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
      */
      toText(string2) {
        return Text2.of(string2.split(this.facet(_EditorState.lineSeparator) || DefaultSplit));
      }
      /**
      Return the given range of the document as a string.
      */
      sliceDoc(from2 = 0, to = this.doc.length) {
        return this.doc.sliceString(from2, to, this.lineBreak);
      }
      /**
      Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
      */
      facet(facet) {
        let addr = this.config.address[facet.id];
        if (addr == null)
          return facet.default;
        ensureAddr(this, addr);
        return getAddr(this, addr);
      }
      /**
      Convert this state to a JSON-serializable object. When custom
      fields should be serialized, you can pass them in as an object
      mapping property names (in the resulting object, which should
      not use `doc` or `selection`) to fields.
      */
      toJSON(fields) {
        let result = {
          doc: this.sliceDoc(),
          selection: this.selection.toJSON()
        };
        if (fields)
          for (let prop in fields) {
            let value = fields[prop];
            if (value instanceof StateField && this.config.address[value.id] != null)
              result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
          }
        return result;
      }
      /**
      Deserialize a state from its JSON representation. When custom
      fields should be deserialized, pass the same object you passed
      to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
      third argument.
      */
      static fromJSON(json2, config3 = {}, fields) {
        if (!json2 || typeof json2.doc != "string")
          throw new RangeError("Invalid JSON representation for EditorState");
        let fieldInit = [];
        if (fields)
          for (let prop in fields) {
            if (Object.prototype.hasOwnProperty.call(json2, prop)) {
              let field = fields[prop], value = json2[prop];
              fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
            }
          }
        return _EditorState.create({
          doc: json2.doc,
          selection: EditorSelection.fromJSON(json2.selection),
          extensions: config3.extensions ? fieldInit.concat([config3.extensions]) : fieldInit
        });
      }
      /**
      Create a new state. You'll usually only need this when
      initializing an editorupdated states are created by applying
      transactions.
      */
      static create(config3 = {}) {
        let configuration = Configuration.resolve(config3.extensions || [], /* @__PURE__ */ new Map());
        let doc2 = config3.doc instanceof Text2 ? config3.doc : Text2.of((config3.doc || "").split(configuration.staticFacet(_EditorState.lineSeparator) || DefaultSplit));
        let selection2 = !config3.selection ? EditorSelection.single(0) : config3.selection instanceof EditorSelection ? config3.selection : EditorSelection.single(config3.selection.anchor, config3.selection.head);
        checkSelection(selection2, doc2.length);
        if (!configuration.staticFacet(allowMultipleSelections))
          selection2 = selection2.asSingle();
        return new _EditorState(configuration, doc2, selection2, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
      }
      /**
      The size (in columns) of a tab in the document, determined by
      the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
      */
      get tabSize() {
        return this.facet(_EditorState.tabSize);
      }
      /**
      Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
      string for this state.
      */
      get lineBreak() {
        return this.facet(_EditorState.lineSeparator) || "\n";
      }
      /**
      Returns true when the editor is
      [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
      */
      get readOnly() {
        return this.facet(readOnly);
      }
      /**
      Look up a translation for the given phrase (via the
      [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
      original string if no translation is found.
      
      If additional arguments are passed, they will be inserted in
      place of markers like `$1` (for the first value) and `$2`, etc.
      A single `$` is equivalent to `$1`, and `$$` will produce a
      literal dollar sign.
      */
      phrase(phrase2, ...insert2) {
        for (let map2 of this.facet(_EditorState.phrases))
          if (Object.prototype.hasOwnProperty.call(map2, phrase2)) {
            phrase2 = map2[phrase2];
            break;
          }
        if (insert2.length)
          phrase2 = phrase2.replace(/\$(\$|\d*)/g, (m, i) => {
            if (i == "$")
              return "$";
            let n = +(i || 1);
            return !n || n > insert2.length ? m : insert2[n - 1];
          });
        return phrase2;
      }
      /**
      Find the values for a given language data field, provided by the
      the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
      
      Examples of language data fields are...
      
      - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
        comment syntax.
      - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
        for providing language-specific completion sources.
      - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
        characters that should be considered part of words in this
        language.
      - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
        bracket closing behavior.
      */
      languageDataAt(name2, pos, side = -1) {
        let values2 = [];
        for (let provider of this.facet(languageData)) {
          for (let result of provider(this, pos, side)) {
            if (Object.prototype.hasOwnProperty.call(result, name2))
              values2.push(result[name2]);
          }
        }
        return values2;
      }
      /**
      Return a function that can categorize strings (expected to
      represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
      into one of:
      
       - Word (contains an alphanumeric character or a character
         explicitly listed in the local language's `"wordChars"`
         language data, which should be a string)
       - Space (contains only whitespace)
       - Other (anything else)
      */
      charCategorizer(at) {
        return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
      }
      /**
      Find the word at the given position, meaning the range
      containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
      around it. If no word characters are adjacent to the position,
      this returns null.
      */
      wordAt(pos) {
        let { text, from: from2, length } = this.doc.lineAt(pos);
        let cat = this.charCategorizer(pos);
        let start = pos - from2, end = pos - from2;
        while (start > 0) {
          let prev = findClusterBreak2(text, start, false);
          if (cat(text.slice(prev, start)) != CharCategory.Word)
            break;
          start = prev;
        }
        while (end < length) {
          let next = findClusterBreak2(text, end);
          if (cat(text.slice(end, next)) != CharCategory.Word)
            break;
          end = next;
        }
        return start == end ? null : EditorSelection.range(start + from2, end + from2);
      }
    };
    EditorState.allowMultipleSelections = allowMultipleSelections;
    EditorState.tabSize = /* @__PURE__ */ Facet.define({
      combine: (values2) => values2.length ? values2[0] : 4
    });
    EditorState.lineSeparator = lineSeparator;
    EditorState.readOnly = readOnly;
    EditorState.phrases = /* @__PURE__ */ Facet.define({
      compare(a, b) {
        let kA = Object.keys(a), kB = Object.keys(b);
        return kA.length == kB.length && kA.every((k) => a[k] == b[k]);
      }
    });
    EditorState.languageData = languageData;
    EditorState.changeFilter = changeFilter;
    EditorState.transactionFilter = transactionFilter;
    EditorState.transactionExtender = transactionExtender;
    Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
    RangeValue = class {
      /**
      Compare this value with another value. Used when comparing
      rangesets. The default implementation compares by identity.
      Unless you are only creating a fixed number of unique instances
      of your value type, it is a good idea to implement this
      properly.
      */
      eq(other) {
        return this == other;
      }
      /**
      Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
      */
      range(from2, to = from2) {
        return Range.create(from2, to, this);
      }
    };
    RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
    RangeValue.prototype.point = false;
    RangeValue.prototype.mapMode = MapMode.TrackDel;
    Range = class _Range {
      constructor(from2, to, value) {
        this.from = from2;
        this.to = to;
        this.value = value;
      }
      /**
      @internal
      */
      static create(from2, to, value) {
        return new _Range(from2, to, value);
      }
    };
    Chunk = class _Chunk {
      constructor(from2, to, value, maxPoint) {
        this.from = from2;
        this.to = to;
        this.value = value;
        this.maxPoint = maxPoint;
      }
      get length() {
        return this.to[this.to.length - 1];
      }
      // Find the index of the given position and side. Use the ranges'
      // `from` pos when `end == false`, `to` when `end == true`.
      findIndex(pos, side, end, startAt = 0) {
        let arr = end ? this.to : this.from;
        for (let lo = startAt, hi = arr.length; ; ) {
          if (lo == hi)
            return lo;
          let mid = lo + hi >> 1;
          let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
          if (mid == lo)
            return diff >= 0 ? lo : hi;
          if (diff >= 0)
            hi = mid;
          else
            lo = mid + 1;
        }
      }
      between(offset, from2, to, f) {
        for (let i = this.findIndex(from2, -1e9, true), e = this.findIndex(to, 1e9, false, i); i < e; i++)
          if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
            return false;
      }
      map(offset, changes) {
        let value = [], from2 = [], to = [], newPos = -1, maxPoint = -1;
        for (let i = 0; i < this.value.length; i++) {
          let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
          if (curFrom == curTo) {
            let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
            if (mapped == null)
              continue;
            newFrom = newTo = mapped;
            if (val.startSide != val.endSide) {
              newTo = changes.mapPos(curFrom, val.endSide);
              if (newTo < newFrom)
                continue;
            }
          } else {
            newFrom = changes.mapPos(curFrom, val.startSide);
            newTo = changes.mapPos(curTo, val.endSide);
            if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
              continue;
          }
          if ((newTo - newFrom || val.endSide - val.startSide) < 0)
            continue;
          if (newPos < 0)
            newPos = newFrom;
          if (val.point)
            maxPoint = Math.max(maxPoint, newTo - newFrom);
          value.push(val);
          from2.push(newFrom - newPos);
          to.push(newTo - newPos);
        }
        return { mapped: value.length ? new _Chunk(from2, to, value, maxPoint) : null, pos: newPos };
      }
    };
    RangeSet = class _RangeSet {
      constructor(chunkPos, chunk, nextLayer, maxPoint) {
        this.chunkPos = chunkPos;
        this.chunk = chunk;
        this.nextLayer = nextLayer;
        this.maxPoint = maxPoint;
      }
      /**
      @internal
      */
      static create(chunkPos, chunk, nextLayer, maxPoint) {
        return new _RangeSet(chunkPos, chunk, nextLayer, maxPoint);
      }
      /**
      @internal
      */
      get length() {
        let last4 = this.chunk.length - 1;
        return last4 < 0 ? 0 : Math.max(this.chunkEnd(last4), this.nextLayer.length);
      }
      /**
      The number of ranges in the set.
      */
      get size() {
        if (this.isEmpty)
          return 0;
        let size = this.nextLayer.size;
        for (let chunk of this.chunk)
          size += chunk.value.length;
        return size;
      }
      /**
      @internal
      */
      chunkEnd(index) {
        return this.chunkPos[index] + this.chunk[index].length;
      }
      /**
      Update the range set, optionally adding new ranges or filtering
      out existing ones.
      
      (Note: The type parameter is just there as a kludge to work
      around TypeScript variance issues that prevented `RangeSet<X>`
      from being a subtype of `RangeSet<Y>` when `X` is a subtype of
      `Y`.)
      */
      update(updateSpec) {
        let { add: add2 = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
        let filter2 = updateSpec.filter;
        if (add2.length == 0 && !filter2)
          return this;
        if (sort)
          add2 = add2.slice().sort(cmpRange);
        if (this.isEmpty)
          return add2.length ? _RangeSet.of(add2) : this;
        let cur2 = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
        let builder = new RangeSetBuilder();
        while (cur2.value || i < add2.length) {
          if (i < add2.length && (cur2.from - add2[i].from || cur2.startSide - add2[i].value.startSide) >= 0) {
            let range = add2[i++];
            if (!builder.addInner(range.from, range.to, range.value))
              spill.push(range);
          } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i == add2.length || this.chunkEnd(cur2.chunkIndex) < add2[i].from) && (!filter2 || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
            cur2.nextChunk();
          } else {
            if (!filter2 || filterFrom > cur2.to || filterTo < cur2.from || filter2(cur2.from, cur2.to, cur2.value)) {
              if (!builder.addInner(cur2.from, cur2.to, cur2.value))
                spill.push(Range.create(cur2.from, cur2.to, cur2.value));
            }
            cur2.next();
          }
        }
        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? _RangeSet.empty : this.nextLayer.update({ add: spill, filter: filter2, filterFrom, filterTo }));
      }
      /**
      Map this range set through a set of changes, return the new set.
      */
      map(changes) {
        if (changes.empty || this.isEmpty)
          return this;
        let chunks = [], chunkPos = [], maxPoint = -1;
        for (let i = 0; i < this.chunk.length; i++) {
          let start = this.chunkPos[i], chunk = this.chunk[i];
          let touch = changes.touchesRange(start, start + chunk.length);
          if (touch === false) {
            maxPoint = Math.max(maxPoint, chunk.maxPoint);
            chunks.push(chunk);
            chunkPos.push(changes.mapPos(start));
          } else if (touch === true) {
            let { mapped, pos } = chunk.map(start, changes);
            if (mapped) {
              maxPoint = Math.max(maxPoint, mapped.maxPoint);
              chunks.push(mapped);
              chunkPos.push(pos);
            }
          }
        }
        let next = this.nextLayer.map(changes);
        return chunks.length == 0 ? next : new _RangeSet(chunkPos, chunks, next || _RangeSet.empty, maxPoint);
      }
      /**
      Iterate over the ranges that touch the region `from` to `to`,
      calling `f` for each. There is no guarantee that the ranges will
      be reported in any specific order. When the callback returns
      `false`, iteration stops.
      */
      between(from2, to, f) {
        if (this.isEmpty)
          return;
        for (let i = 0; i < this.chunk.length; i++) {
          let start = this.chunkPos[i], chunk = this.chunk[i];
          if (to >= start && from2 <= start + chunk.length && chunk.between(start, from2 - start, to - start, f) === false)
            return;
        }
        this.nextLayer.between(from2, to, f);
      }
      /**
      Iterate over the ranges in this set, in order, including all
      ranges that end at or after `from`.
      */
      iter(from2 = 0) {
        return HeapCursor.from([this]).goto(from2);
      }
      /**
      @internal
      */
      get isEmpty() {
        return this.nextLayer == this;
      }
      /**
      Iterate over the ranges in a collection of sets, in order,
      starting from `from`.
      */
      static iter(sets, from2 = 0) {
        return HeapCursor.from(sets).goto(from2);
      }
      /**
      Iterate over two groups of sets, calling methods on `comparator`
      to notify it of possible differences.
      */
      static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
        let a = oldSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
        let b = newSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
        let sharedChunks = findSharedChunks(a, b, textDiff);
        let sideA = new SpanCursor(a, sharedChunks, minPointSize);
        let sideB = new SpanCursor(b, sharedChunks, minPointSize);
        textDiff.iterGaps((fromA, fromB, length) => compare2(sideA, fromA, sideB, fromB, length, comparator));
        if (textDiff.empty && textDiff.length == 0)
          compare2(sideA, 0, sideB, 0, 0, comparator);
      }
      /**
      Compare the contents of two groups of range sets, returning true
      if they are equivalent in the given range.
      */
      static eq(oldSets, newSets, from2 = 0, to) {
        if (to == null)
          to = 1e9 - 1;
        let a = oldSets.filter((set) => !set.isEmpty && newSets.indexOf(set) < 0);
        let b = newSets.filter((set) => !set.isEmpty && oldSets.indexOf(set) < 0);
        if (a.length != b.length)
          return false;
        if (!a.length)
          return true;
        let sharedChunks = findSharedChunks(a, b);
        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from2), sideB = new SpanCursor(b, sharedChunks, 0).goto(from2);
        for (; ; ) {
          if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
            return false;
          if (sideA.to > to)
            return true;
          sideA.next();
          sideB.next();
        }
      }
      /**
      Iterate over a group of range sets at the same time, notifying
      the iterator about the ranges covering every given piece of
      content. Returns the open count (see
      [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
      of the iteration.
      */
      static spans(sets, from2, to, iterator2, minPointSize = -1) {
        let cursor2 = new SpanCursor(sets, null, minPointSize).goto(from2), pos = from2;
        let openRanges = cursor2.openStart;
        for (; ; ) {
          let curTo = Math.min(cursor2.to, to);
          if (cursor2.point) {
            let active = cursor2.activeForPoint(cursor2.to);
            let openCount = cursor2.pointFrom < from2 ? active.length + 1 : cursor2.point.startSide < 0 ? active.length : Math.min(active.length, openRanges);
            iterator2.point(pos, curTo, cursor2.point, active, openCount, cursor2.pointRank);
            openRanges = Math.min(cursor2.openEnd(curTo), active.length);
          } else if (curTo > pos) {
            iterator2.span(pos, curTo, cursor2.active, openRanges);
            openRanges = cursor2.openEnd(curTo);
          }
          if (cursor2.to > to)
            return openRanges + (cursor2.point && cursor2.to > to ? 1 : 0);
          pos = cursor2.to;
          cursor2.next();
        }
      }
      /**
      Create a range set for the given range or array of ranges. By
      default, this expects the ranges to be _sorted_ (by start
      position and, if two start at the same position,
      `value.startSide`). You can pass `true` as second argument to
      cause the method to sort them.
      */
      static of(ranges, sort = false) {
        let build = new RangeSetBuilder();
        for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
          build.add(range.from, range.to, range.value);
        return build.finish();
      }
      /**
      Join an array of range sets into a single set.
      */
      static join(sets) {
        if (!sets.length)
          return _RangeSet.empty;
        let result = sets[sets.length - 1];
        for (let i = sets.length - 2; i >= 0; i--) {
          for (let layer2 = sets[i]; layer2 != _RangeSet.empty; layer2 = layer2.nextLayer)
            result = new _RangeSet(layer2.chunkPos, layer2.chunk, result, Math.max(layer2.maxPoint, result.maxPoint));
        }
        return result;
      }
    };
    RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
    RangeSet.empty.nextLayer = RangeSet.empty;
    RangeSetBuilder = class _RangeSetBuilder {
      finishChunk(newArrays) {
        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
        this.chunkPos.push(this.chunkStart);
        this.chunkStart = -1;
        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
        this.maxPoint = -1;
        if (newArrays) {
          this.from = [];
          this.to = [];
          this.value = [];
        }
      }
      /**
      Create an empty builder.
      */
      constructor() {
        this.chunks = [];
        this.chunkPos = [];
        this.chunkStart = -1;
        this.last = null;
        this.lastFrom = -1e9;
        this.lastTo = -1e9;
        this.from = [];
        this.to = [];
        this.value = [];
        this.maxPoint = -1;
        this.setMaxPoint = -1;
        this.nextLayer = null;
      }
      /**
      Add a range. Ranges should be added in sorted (by `from` and
      `value.startSide`) order.
      */
      add(from2, to, value) {
        if (!this.addInner(from2, to, value))
          (this.nextLayer || (this.nextLayer = new _RangeSetBuilder())).add(from2, to, value);
      }
      /**
      @internal
      */
      addInner(from2, to, value) {
        let diff = from2 - this.lastTo || value.startSide - this.last.endSide;
        if (diff <= 0 && (from2 - this.lastFrom || value.startSide - this.last.startSide) < 0)
          throw new Error("Ranges must be added sorted by `from` position and `startSide`");
        if (diff < 0)
          return false;
        if (this.from.length == 250)
          this.finishChunk(true);
        if (this.chunkStart < 0)
          this.chunkStart = from2;
        this.from.push(from2 - this.chunkStart);
        this.to.push(to - this.chunkStart);
        this.last = value;
        this.lastFrom = from2;
        this.lastTo = to;
        this.value.push(value);
        if (value.point)
          this.maxPoint = Math.max(this.maxPoint, to - from2);
        return true;
      }
      /**
      @internal
      */
      addChunk(from2, chunk) {
        if ((from2 - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
          return false;
        if (this.from.length)
          this.finishChunk(true);
        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
        this.chunks.push(chunk);
        this.chunkPos.push(from2);
        let last4 = chunk.value.length - 1;
        this.last = chunk.value[last4];
        this.lastFrom = chunk.from[last4] + from2;
        this.lastTo = chunk.to[last4] + from2;
        return true;
      }
      /**
      Finish the range set. Returns the new set. The builder can't be
      used anymore after this has been called.
      */
      finish() {
        return this.finishInner(RangeSet.empty);
      }
      /**
      @internal
      */
      finishInner(next) {
        if (this.from.length)
          this.finishChunk(false);
        if (this.chunks.length == 0)
          return next;
        let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
        this.from = null;
        return result;
      }
    };
    LayerCursor = class {
      constructor(layer2, skip, minPoint, rank = 0) {
        this.layer = layer2;
        this.skip = skip;
        this.minPoint = minPoint;
        this.rank = rank;
      }
      get startSide() {
        return this.value ? this.value.startSide : 0;
      }
      get endSide() {
        return this.value ? this.value.endSide : 0;
      }
      goto(pos, side = -1e9) {
        this.chunkIndex = this.rangeIndex = 0;
        this.gotoInner(pos, side, false);
        return this;
      }
      gotoInner(pos, side, forward) {
        while (this.chunkIndex < this.layer.chunk.length) {
          let next = this.layer.chunk[this.chunkIndex];
          if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
            break;
          this.chunkIndex++;
          forward = false;
        }
        if (this.chunkIndex < this.layer.chunk.length) {
          let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
          if (!forward || this.rangeIndex < rangeIndex)
            this.setRangeIndex(rangeIndex);
        }
        this.next();
      }
      forward(pos, side) {
        if ((this.to - pos || this.endSide - side) < 0)
          this.gotoInner(pos, side, true);
      }
      next() {
        for (; ; ) {
          if (this.chunkIndex == this.layer.chunk.length) {
            this.from = this.to = 1e9;
            this.value = null;
            break;
          } else {
            let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
            let from2 = chunkPos + chunk.from[this.rangeIndex];
            this.from = from2;
            this.to = chunkPos + chunk.to[this.rangeIndex];
            this.value = chunk.value[this.rangeIndex];
            this.setRangeIndex(this.rangeIndex + 1);
            if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
              break;
          }
        }
      }
      setRangeIndex(index) {
        if (index == this.layer.chunk[this.chunkIndex].value.length) {
          this.chunkIndex++;
          if (this.skip) {
            while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
              this.chunkIndex++;
          }
          this.rangeIndex = 0;
        } else {
          this.rangeIndex = index;
        }
      }
      nextChunk() {
        this.chunkIndex++;
        this.rangeIndex = 0;
        this.next();
      }
      compare(other) {
        return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
      }
    };
    HeapCursor = class _HeapCursor {
      constructor(heap) {
        this.heap = heap;
      }
      static from(sets, skip = null, minPoint = -1) {
        let heap = [];
        for (let i = 0; i < sets.length; i++) {
          for (let cur2 = sets[i]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
            if (cur2.maxPoint >= minPoint)
              heap.push(new LayerCursor(cur2, skip, minPoint, i));
          }
        }
        return heap.length == 1 ? heap[0] : new _HeapCursor(heap);
      }
      get startSide() {
        return this.value ? this.value.startSide : 0;
      }
      goto(pos, side = -1e9) {
        for (let cur2 of this.heap)
          cur2.goto(pos, side);
        for (let i = this.heap.length >> 1; i >= 0; i--)
          heapBubble(this.heap, i);
        this.next();
        return this;
      }
      forward(pos, side) {
        for (let cur2 of this.heap)
          cur2.forward(pos, side);
        for (let i = this.heap.length >> 1; i >= 0; i--)
          heapBubble(this.heap, i);
        if ((this.to - pos || this.value.endSide - side) < 0)
          this.next();
      }
      next() {
        if (this.heap.length == 0) {
          this.from = this.to = 1e9;
          this.value = null;
          this.rank = -1;
        } else {
          let top2 = this.heap[0];
          this.from = top2.from;
          this.to = top2.to;
          this.value = top2.value;
          this.rank = top2.rank;
          if (top2.value)
            top2.next();
          heapBubble(this.heap, 0);
        }
      }
    };
    SpanCursor = class {
      constructor(sets, skip, minPoint) {
        this.minPoint = minPoint;
        this.active = [];
        this.activeTo = [];
        this.activeRank = [];
        this.minActive = -1;
        this.point = null;
        this.pointFrom = 0;
        this.pointRank = 0;
        this.to = -1e9;
        this.endSide = 0;
        this.openStart = -1;
        this.cursor = HeapCursor.from(sets, skip, minPoint);
      }
      goto(pos, side = -1e9) {
        this.cursor.goto(pos, side);
        this.active.length = this.activeTo.length = this.activeRank.length = 0;
        this.minActive = -1;
        this.to = pos;
        this.endSide = side;
        this.openStart = -1;
        this.next();
        return this;
      }
      forward(pos, side) {
        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
          this.removeActive(this.minActive);
        this.cursor.forward(pos, side);
      }
      removeActive(index) {
        remove2(this.active, index);
        remove2(this.activeTo, index);
        remove2(this.activeRank, index);
        this.minActive = findMinIndex(this.active, this.activeTo);
      }
      addActive(trackOpen) {
        let i = 0, { value, to, rank } = this.cursor;
        while (i < this.activeRank.length && (rank - this.activeRank[i] || to - this.activeTo[i]) > 0)
          i++;
        insert(this.active, i, value);
        insert(this.activeTo, i, to);
        insert(this.activeRank, i, rank);
        if (trackOpen)
          insert(trackOpen, i, this.cursor.from);
        this.minActive = findMinIndex(this.active, this.activeTo);
      }
      // After calling this, if `this.point` != null, the next range is a
      // point. Otherwise, it's a regular range, covered by `this.active`.
      next() {
        let from2 = this.to, wasPoint = this.point;
        this.point = null;
        let trackOpen = this.openStart < 0 ? [] : null;
        for (; ; ) {
          let a = this.minActive;
          if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
            if (this.activeTo[a] > from2) {
              this.to = this.activeTo[a];
              this.endSide = this.active[a].endSide;
              break;
            }
            this.removeActive(a);
            if (trackOpen)
              remove2(trackOpen, a);
          } else if (!this.cursor.value) {
            this.to = this.endSide = 1e9;
            break;
          } else if (this.cursor.from > from2) {
            this.to = this.cursor.from;
            this.endSide = this.cursor.startSide;
            break;
          } else {
            let nextVal = this.cursor.value;
            if (!nextVal.point) {
              this.addActive(trackOpen);
              this.cursor.next();
            } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
              this.cursor.next();
            } else {
              this.point = nextVal;
              this.pointFrom = this.cursor.from;
              this.pointRank = this.cursor.rank;
              this.to = this.cursor.to;
              this.endSide = nextVal.endSide;
              this.cursor.next();
              this.forward(this.to, this.endSide);
              break;
            }
          }
        }
        if (trackOpen) {
          this.openStart = 0;
          for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from2; i--)
            this.openStart++;
        }
      }
      activeForPoint(to) {
        if (!this.active.length)
          return this.active;
        let active = [];
        for (let i = this.active.length - 1; i >= 0; i--) {
          if (this.activeRank[i] < this.pointRank)
            break;
          if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
            active.push(this.active[i]);
        }
        return active.reverse();
      }
      openEnd(to) {
        let open = 0;
        for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
          open++;
        return open;
      }
    };
  }
});

// node_modules/style-mod/src/style-mod.js
var C, COUNT, SET, top, StyleModule, adoptedSet, StyleSet;
var init_style_mod = __esm({
  "node_modules/style-mod/src/style-mod.js"() {
    "use strict";
    C = "\u037C";
    COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
    SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
    top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
    StyleModule = class {
      // :: (Object<Style>, ?{finish: ?(string)  string})
      // Create a style module from the given spec.
      //
      // When `finish` is given, it is called on regular (non-`@`)
      // selectors (after `&` expansion) to compute the final selector.
      constructor(spec, options) {
        this.rules = [];
        let { finish } = options || {};
        function splitSelector(selector) {
          return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
        }
        function render(selectors, spec2, target, isKeyframes) {
          let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
          if (isAt && spec2 == null) return target.push(selectors[0] + ";");
          for (let prop in spec2) {
            let value = spec2[prop];
            if (/&/.test(prop)) {
              render(
                prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)),
                value,
                target
              );
            } else if (value && typeof value == "object") {
              if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
              render(splitSelector(prop), value, local, keyframes);
            } else if (value != null) {
              local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
            }
          }
          if (local.length || keyframes) {
            target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
          }
        }
        for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules);
      }
      // :: ()  string
      // Returns a string containing the module's CSS rules.
      getRules() {
        return this.rules.join("\n");
      }
      // :: ()  string
      // Generate a new unique CSS class name.
      static newName() {
        let id2 = top[COUNT] || 1;
        top[COUNT] = id2 + 1;
        return C + id2.toString(36);
      }
      // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
      //
      // Mount the given set of modules in the given DOM root, which ensures
      // that the CSS rules defined by the module are available in that
      // context.
      //
      // Rules are only added to the document once per root.
      //
      // Rule order will follow the order of the modules, so that rules from
      // modules later in the array take precedence of those from earlier
      // modules. If you call this function multiple times for the same root
      // in a way that changes the order of already mounted modules, the old
      // order will be changed.
      //
      // If a Content Security Policy nonce is provided, it is added to
      // the `<style>` tag generated by the library.
      static mount(root, modules2, options) {
        let set = root[SET], nonce = options && options.nonce;
        if (!set) set = new StyleSet(root, nonce);
        else if (nonce) set.setNonce(nonce);
        set.mount(Array.isArray(modules2) ? modules2 : [modules2], root);
      }
    };
    adoptedSet = /* @__PURE__ */ new Map();
    StyleSet = class {
      constructor(root, nonce) {
        let doc2 = root.ownerDocument || root, win = doc2.defaultView;
        if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
          let adopted = adoptedSet.get(doc2);
          if (adopted) return root[SET] = adopted;
          this.sheet = new win.CSSStyleSheet();
          adoptedSet.set(doc2, this);
        } else {
          this.styleTag = doc2.createElement("style");
          if (nonce) this.styleTag.setAttribute("nonce", nonce);
        }
        this.modules = [];
        root[SET] = this;
      }
      mount(modules2, root) {
        let sheet = this.sheet;
        let pos = 0, j = 0;
        for (let i = 0; i < modules2.length; i++) {
          let mod = modules2[i], index = this.modules.indexOf(mod);
          if (index < j && index > -1) {
            this.modules.splice(index, 1);
            j--;
            index = -1;
          }
          if (index == -1) {
            this.modules.splice(j++, 0, mod);
            if (sheet) for (let k = 0; k < mod.rules.length; k++)
              sheet.insertRule(mod.rules[k], pos++);
          } else {
            while (j < index) pos += this.modules[j++].rules.length;
            pos += mod.rules.length;
            j++;
          }
        }
        if (sheet) {
          if (root.adoptedStyleSheets.indexOf(this.sheet) < 0)
            root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets];
        } else {
          let text = "";
          for (let i = 0; i < this.modules.length; i++)
            text += this.modules[i].getRules() + "\n";
          this.styleTag.textContent = text;
          let target = root.head || root;
          if (this.styleTag.parentNode != target)
            target.insertBefore(this.styleTag, target.firstChild);
        }
      }
      setNonce(nonce) {
        if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce)
          this.styleTag.setAttribute("nonce", nonce);
      }
    };
  }
});

// node_modules/w3c-keyname/index.js
function keyName(event) {
  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name2 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name2 == "Esc") name2 = "Escape";
  if (name2 == "Del") name2 = "Delete";
  if (name2 == "Left") name2 = "ArrowLeft";
  if (name2 == "Up") name2 = "ArrowUp";
  if (name2 == "Right") name2 = "ArrowRight";
  if (name2 == "Down") name2 = "ArrowDown";
  return name2;
}
var base, shift, mac, ie, i, i, i, code;
var init_w3c_keyname = __esm({
  "node_modules/w3c-keyname/index.js"() {
    "use strict";
    base = {
      8: "Backspace",
      9: "Tab",
      10: "Enter",
      12: "NumLock",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      44: "PrintScreen",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Meta",
      92: "Meta",
      106: "*",
      107: "+",
      108: ",",
      109: "-",
      110: ".",
      111: "/",
      144: "NumLock",
      145: "ScrollLock",
      160: "Shift",
      161: "Shift",
      162: "Control",
      163: "Control",
      164: "Alt",
      165: "Alt",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'"
    };
    shift = {
      48: ")",
      49: "!",
      50: "@",
      51: "#",
      52: "$",
      53: "%",
      54: "^",
      55: "&",
      56: "*",
      57: "(",
      59: ":",
      61: "+",
      173: "_",
      186: ":",
      187: "+",
      188: "<",
      189: "_",
      190: ">",
      191: "?",
      192: "~",
      219: "{",
      220: "|",
      221: "}",
      222: '"'
    };
    mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
    ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
    for (i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
    for (i = 1; i <= 24; i++) base[i + 111] = "F" + i;
    for (i = 65; i <= 90; i++) {
      base[i] = String.fromCharCode(i + 32);
      shift[i] = String.fromCharCode(i);
    }
    for (code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
  }
});

// node_modules/crelt/index.js
function crelt() {
  var elt2 = arguments[0];
  if (typeof elt2 == "string") elt2 = document.createElement(elt2);
  var i = 1, next = arguments[1];
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name2 in next) if (Object.prototype.hasOwnProperty.call(next, name2)) {
      var value = next[name2];
      if (typeof value == "string") elt2.setAttribute(name2, value);
      else if (value != null) elt2[name2] = value;
    }
    i++;
  }
  for (; i < arguments.length; i++) add(elt2, arguments[i]);
  return elt2;
}
function add(elt2, child) {
  if (typeof child == "string") {
    elt2.appendChild(document.createTextNode(child));
  } else if (child == null) {
  } else if (child.nodeType != null) {
    elt2.appendChild(child);
  } else if (Array.isArray(child)) {
    for (var i = 0; i < child.length; i++) add(elt2, child[i]);
  } else {
    throw new RangeError("Unsupported child node: " + child);
  }
}
var init_crelt = __esm({
  "node_modules/crelt/index.js"() {
    "use strict";
  }
});

// node_modules/@codemirror/view/dist/index.js
function getSelection(root) {
  let target;
  if (root.nodeType == 11) {
    target = root.getSelection ? root : root.ownerDocument;
  } else {
    target = root;
  }
  return target.getSelection();
}
function contains(dom, node) {
  return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}
function hasSelection(dom, selection2) {
  if (!selection2.anchorNode)
    return false;
  try {
    return contains(dom, selection2.anchorNode);
  } catch (_) {
    return false;
  }
}
function clientRectsFor(dom) {
  if (dom.nodeType == 3)
    return textRange(dom, 0, dom.nodeValue.length).getClientRects();
  else if (dom.nodeType == 1)
    return dom.getClientRects();
  else
    return [];
}
function isEquivalentPosition(node, off, targetNode, targetOff) {
  return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
}
function domIndex(node) {
  for (var index = 0; ; index++) {
    node = node.previousSibling;
    if (!node)
      return index;
  }
}
function isBlockElement(node) {
  return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : maxOffset(node))) {
      if (node.nodeName == "DIV")
        return false;
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1)
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.nodeType == 1 && node.contentEditable == "false")
        return false;
      off = dir < 0 ? maxOffset(node) : 0;
    } else {
      return false;
    }
  }
}
function maxOffset(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function flattenRect(rect, left) {
  let x = left ? rect.left : rect.right;
  return { left: x, right: x, top: rect.top, bottom: rect.bottom };
}
function windowRect(win) {
  let vp = win.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  };
}
function getScale(elt2, rect) {
  let scaleX = rect.width / elt2.offsetWidth;
  let scaleY = rect.height / elt2.offsetHeight;
  if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt2.offsetWidth) < 1)
    scaleX = 1;
  if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt2.offsetHeight) < 1)
    scaleY = 1;
  return { scaleX, scaleY };
}
function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  for (let cur2 = dom, stop = false; cur2 && !stop; ) {
    if (cur2.nodeType == 1) {
      let bounding, top2 = cur2 == doc2.body;
      let scaleX = 1, scaleY = 1;
      if (top2) {
        bounding = windowRect(win);
      } else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(cur2).position))
          stop = true;
        if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
          cur2 = cur2.assignedSlot || cur2.parentNode;
          continue;
        }
        let rect2 = cur2.getBoundingClientRect();
        ({ scaleX, scaleY } = getScale(cur2, rect2));
        bounding = {
          left: rect2.left,
          right: rect2.left + cur2.clientWidth * scaleX,
          top: rect2.top,
          bottom: rect2.top + cur2.clientHeight * scaleY
        };
      }
      let moveX = 0, moveY = 0;
      if (y == "nearest") {
        if (rect.top < bounding.top) {
          moveY = rect.top - (bounding.top + yMargin);
          if (side > 0 && rect.bottom > bounding.bottom + moveY)
            moveY = rect.bottom - bounding.bottom + yMargin;
        } else if (rect.bottom > bounding.bottom) {
          moveY = rect.bottom - bounding.bottom + yMargin;
          if (side < 0 && rect.top - moveY < bounding.top)
            moveY = rect.top - (bounding.top + yMargin);
        }
      } else {
        let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
        let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || y == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
        moveY = targetTop - bounding.top;
      }
      if (x == "nearest") {
        if (rect.left < bounding.left) {
          moveX = rect.left - (bounding.left + xMargin);
          if (side > 0 && rect.right > bounding.right + moveX)
            moveX = rect.right - bounding.right + xMargin;
        } else if (rect.right > bounding.right) {
          moveX = rect.right - bounding.right + xMargin;
          if (side < 0 && rect.left < bounding.left + moveX)
            moveX = rect.left - (bounding.left + xMargin);
        }
      } else {
        let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
        moveX = targetLeft - bounding.left;
      }
      if (moveX || moveY) {
        if (top2) {
          win.scrollBy(moveX, moveY);
        } else {
          let movedX = 0, movedY = 0;
          if (moveY) {
            let start = cur2.scrollTop;
            cur2.scrollTop += moveY / scaleY;
            movedY = (cur2.scrollTop - start) * scaleY;
          }
          if (moveX) {
            let start = cur2.scrollLeft;
            cur2.scrollLeft += moveX / scaleX;
            movedX = (cur2.scrollLeft - start) * scaleX;
          }
          rect = {
            left: rect.left - movedX,
            top: rect.top - movedY,
            right: rect.right - movedX,
            bottom: rect.bottom - movedY
          };
          if (movedX && Math.abs(movedX - moveX) < 1)
            x = "nearest";
          if (movedY && Math.abs(movedY - moveY) < 1)
            y = "nearest";
        }
      }
      if (top2)
        break;
      if (rect.top < bounding.top || rect.bottom > bounding.bottom || rect.left < bounding.left || rect.right > bounding.right)
        rect = {
          left: Math.max(rect.left, bounding.left),
          right: Math.min(rect.right, bounding.right),
          top: Math.max(rect.top, bounding.top),
          bottom: Math.min(rect.bottom, bounding.bottom)
        };
      cur2 = cur2.assignedSlot || cur2.parentNode;
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
}
function scrollableParents(dom) {
  let doc2 = dom.ownerDocument, x, y;
  for (let cur2 = dom.parentNode; cur2; ) {
    if (cur2 == doc2.body || x && y) {
      break;
    } else if (cur2.nodeType == 1) {
      if (!y && cur2.scrollHeight > cur2.clientHeight)
        y = cur2;
      if (!x && cur2.scrollWidth > cur2.clientWidth)
        x = cur2;
      cur2 = cur2.assignedSlot || cur2.parentNode;
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
  return { x, y };
}
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stack = [];
  for (let cur2 = dom; cur2; cur2 = cur2.parentNode) {
    stack.push(cur2, cur2.scrollTop, cur2.scrollLeft);
    if (cur2 == cur2.ownerDocument)
      break;
  }
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    for (let i = 0; i < stack.length; ) {
      let elt2 = stack[i++], top2 = stack[i++], left = stack[i++];
      if (elt2.scrollTop != top2)
        elt2.scrollTop = top2;
      if (elt2.scrollLeft != left)
        elt2.scrollLeft = left;
    }
  }
}
function textRange(node, from2, to = from2) {
  let range = scratchRange || (scratchRange = document.createRange());
  range.setEnd(node, to);
  range.setStart(node, from2);
  return range;
}
function dispatchKey(elt2, name2, code, mods) {
  let options = { key: name2, code: name2, keyCode: code, which: code, cancelable: true };
  if (mods)
    ({ altKey: options.altKey, ctrlKey: options.ctrlKey, shiftKey: options.shiftKey, metaKey: options.metaKey } = mods);
  let down = new KeyboardEvent("keydown", options);
  down.synthetic = true;
  elt2.dispatchEvent(down);
  let up = new KeyboardEvent("keyup", options);
  up.synthetic = true;
  elt2.dispatchEvent(up);
  return down.defaultPrevented || up.defaultPrevented;
}
function getRoot(node) {
  while (node) {
    if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
      return node;
    node = node.assignedSlot || node.parentNode;
  }
  return null;
}
function clearAttributes(node) {
  while (node.attributes.length)
    node.removeAttributeNode(node.attributes[0]);
}
function atElementStart(doc2, selection2) {
  let node = selection2.focusNode, offset = selection2.focusOffset;
  if (!node || selection2.anchorNode != node || selection2.anchorOffset != offset)
    return false;
  offset = Math.min(offset, maxOffset(node));
  for (; ; ) {
    if (offset) {
      if (node.nodeType != 1)
        return false;
      let prev = node.childNodes[offset - 1];
      if (prev.contentEditable == "false")
        offset--;
      else {
        node = prev;
        offset = maxOffset(node);
      }
    } else if (node == doc2) {
      return true;
    } else {
      offset = domIndex(node);
      node = node.parentNode;
    }
  }
}
function isScrolledToBottom(elt2) {
  return elt2.scrollTop > Math.max(1, elt2.scrollHeight - elt2.clientHeight - 4);
}
function textNodeBefore(startNode, startOffset) {
  for (let node = startNode, offset = startOffset; ; ) {
    if (node.nodeType == 3 && offset > 0) {
      return { node, offset };
    } else if (node.nodeType == 1 && offset > 0) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset - 1];
      offset = maxOffset(node);
    } else if (node.parentNode && !isBlockElement(node)) {
      offset = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter(startNode, startOffset) {
  for (let node = startNode, offset = startOffset; ; ) {
    if (node.nodeType == 3 && offset < node.nodeValue.length) {
      return { node, offset };
    } else if (node.nodeType == 1 && offset < node.childNodes.length) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset];
      offset = 0;
    } else if (node.parentNode && !isBlockElement(node)) {
      offset = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function rm$1(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
function replaceRange(parent, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
  let { children } = parent;
  let before = children.length ? children[fromI] : null;
  let last4 = insert2.length ? insert2[insert2.length - 1] : null;
  let breakAtEnd = last4 ? last4.breakAfter : breakAtStart;
  if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert2.length < 2 && before.merge(fromOff, toOff, insert2.length ? last4 : null, fromOff == 0, openStart, openEnd))
    return;
  if (toI < children.length) {
    let after = children[toI];
    if (after && (toOff < after.length || after.breakAfter && (last4 === null || last4 === void 0 ? void 0 : last4.breakAfter))) {
      if (fromI == toI) {
        after = after.split(toOff);
        toOff = 0;
      }
      if (!breakAtEnd && last4 && after.merge(0, toOff, last4, true, 0, openEnd)) {
        insert2[insert2.length - 1] = after;
      } else {
        if (toOff || after.children.length && !after.children[0].length)
          after.merge(0, toOff, null, false, 0, openEnd);
        insert2.push(after);
      }
    } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
      if (last4)
        last4.breakAfter = 1;
      else
        breakAtStart = 1;
    }
    toI++;
  }
  if (before) {
    before.breakAfter = breakAtStart;
    if (fromOff > 0) {
      if (!breakAtStart && insert2.length && before.merge(fromOff, before.length, insert2[0], false, openStart, 0)) {
        before.breakAfter = insert2.shift().breakAfter;
      } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
        before.merge(fromOff, before.length, null, false, openStart, 0);
      }
      fromI++;
    }
  }
  while (fromI < toI && insert2.length) {
    if (children[toI - 1].become(insert2[insert2.length - 1])) {
      toI--;
      insert2.pop();
      openEnd = insert2.length ? 0 : openStart;
    } else if (children[fromI].become(insert2[0])) {
      fromI++;
      insert2.shift();
      openStart = insert2.length ? 0 : openEnd;
    } else {
      break;
    }
  }
  if (!insert2.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
    fromI--;
  if (fromI < toI || insert2.length)
    parent.replaceChildren(fromI, toI, insert2);
}
function mergeChildrenInto(parent, from2, to, insert2, openStart, openEnd) {
  let cur2 = parent.childCursor();
  let { i: toI, off: toOff } = cur2.findPos(to, 1);
  let { i: fromI, off: fromOff } = cur2.findPos(from2, -1);
  let dLen = from2 - to;
  for (let view of insert2)
    dLen += view.length;
  parent.length += dLen;
  replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
}
function textCoords(text, pos, side) {
  let length = text.nodeValue.length;
  if (pos > length)
    pos = length;
  let from2 = pos, to = pos, flatten3 = 0;
  if (pos == 0 && side < 0 || pos == length && side >= 0) {
    if (!(browser.chrome || browser.gecko)) {
      if (pos) {
        from2--;
        flatten3 = 1;
      } else if (to < length) {
        to++;
        flatten3 = -1;
      }
    }
  } else {
    if (side < 0)
      from2--;
    else if (to < length)
      to++;
  }
  let rects = textRange(text, from2, to).getClientRects();
  if (!rects.length)
    return null;
  let rect = rects[(flatten3 ? flatten3 < 0 : side >= 0) ? 0 : rects.length - 1];
  if (browser.safari && !flatten3 && rect.width == 0)
    rect = Array.prototype.find.call(rects, (r) => r.width) || rect;
  return flatten3 ? flattenRect(rect, flatten3 < 0) : rect || null;
}
function inlineDOMAtPos(parent, pos) {
  let dom = parent.dom, { children } = parent, i = 0;
  for (let off = 0; i < children.length; i++) {
    let child = children[i], end = off + child.length;
    if (end == off && child.getSide() <= 0)
      continue;
    if (pos > off && pos < end && child.dom.parentNode == dom)
      return child.domAtPos(pos - off);
    if (pos <= off)
      break;
    off = end;
  }
  for (let j = i; j > 0; j--) {
    let prev = children[j - 1];
    if (prev.dom.parentNode == dom)
      return prev.domAtPos(prev.length);
  }
  for (let j = i; j < children.length; j++) {
    let next = children[j];
    if (next.dom.parentNode == dom)
      return next.domAtPos(0);
  }
  return new DOMPos(dom, 0);
}
function joinInlineInto(parent, view, open) {
  let last4, { children } = parent;
  if (open > 0 && view instanceof MarkView && children.length && (last4 = children[children.length - 1]) instanceof MarkView && last4.mark.eq(view.mark)) {
    joinInlineInto(last4, view.children[0], open - 1);
  } else {
    children.push(view);
    view.setParent(parent);
  }
  parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
  let before = null, beforePos = -1, after = null, afterPos = -1;
  function scan2(view2, pos2) {
    for (let i = 0, off = 0; i < view2.children.length && off <= pos2; i++) {
      let child = view2.children[i], end = off + child.length;
      if (end >= pos2) {
        if (child.children.length) {
          scan2(child, pos2 - off);
        } else if ((!after || after.isHidden && (side > 0 || onSameLine(after, child))) && (end > pos2 || off == end && child.getSide() > 0)) {
          after = child;
          afterPos = pos2 - off;
        } else if (off < pos2 || off == end && child.getSide() < 0 && !child.isHidden) {
          before = child;
          beforePos = pos2 - off;
        }
      }
      off = end;
    }
  }
  scan2(view, pos);
  let target = (side < 0 ? before : after) || before || after;
  if (target)
    return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
  return fallbackRect(view);
}
function fallbackRect(view) {
  let last4 = view.dom.lastChild;
  if (!last4)
    return view.dom.getBoundingClientRect();
  let rects = clientRectsFor(last4);
  return rects[rects.length - 1] || null;
}
function onSameLine(a, b) {
  let posA = a.coordsAt(0, 1), posB = b.coordsAt(0, 1);
  return posA && posB && posB.top < posA.bottom;
}
function combineAttrs(source, target) {
  for (let name2 in source) {
    if (name2 == "class" && target.class)
      target.class += " " + source.class;
    else if (name2 == "style" && target.style)
      target.style += ";" + source.style;
    else
      target[name2] = source[name2];
  }
  return target;
}
function attrsEq(a, b, ignore) {
  if (a == b)
    return true;
  if (!a)
    a = noAttrs;
  if (!b)
    b = noAttrs;
  let keysA = Object.keys(a), keysB = Object.keys(b);
  if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0))
    return false;
  for (let key of keysA) {
    if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key]))
      return false;
  }
  return true;
}
function updateAttrs(dom, prev, attrs) {
  let changed = false;
  if (prev) {
    for (let name2 in prev)
      if (!(attrs && name2 in attrs)) {
        changed = true;
        if (name2 == "style")
          dom.style.cssText = "";
        else
          dom.removeAttribute(name2);
      }
  }
  if (attrs) {
    for (let name2 in attrs)
      if (!(prev && prev[name2] == attrs[name2])) {
        changed = true;
        if (name2 == "style")
          dom.style.cssText = attrs[name2];
        else
          dom.setAttribute(name2, attrs[name2]);
      }
  }
  return changed;
}
function getAttrs(dom) {
  let attrs = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < dom.attributes.length; i++) {
    let attr = dom.attributes[i];
    attrs[attr.name] = attr.value;
  }
  return attrs;
}
function getInclusive(spec, block = false) {
  let { inclusiveStart: start, inclusiveEnd: end } = spec;
  if (start == null)
    start = spec.inclusive;
  if (end == null)
    end = spec.inclusive;
  return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
}
function widgetsEq(a, b) {
  return a == b || !!(a && b && a.compare(b));
}
function addRange(from2, to, ranges, margin = 0) {
  let last4 = ranges.length - 1;
  if (last4 >= 0 && ranges[last4] + margin >= from2)
    ranges[last4] = Math.max(ranges[last4], to);
  else
    ranges.push(from2, to);
}
function wrapMarks(view, active) {
  for (let mark of active)
    view = new MarkView(mark, [view], view.length);
  return view;
}
function dec(str) {
  let result = [];
  for (let i = 0; i < str.length; i++)
    result.push(1 << +str[i]);
  return result;
}
function charType(ch) {
  return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8204 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : 1;
}
function isolatesEq(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++) {
    let iA = a[i], iB = b[i];
    if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
      return false;
  }
  return true;
}
function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
  for (let iI = 0; iI <= isolates.length; iI++) {
    let from2 = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    let prevType = iI ? 256 : outerType;
    for (let i = from2, prev = prevType, prevStrong = prevType; i < to; i++) {
      let type = charType(line.charCodeAt(i));
      if (type == 512)
        type = prev;
      else if (type == 8 && prevStrong == 4)
        type = 16;
      types[i] = type == 4 ? 2 : type;
      if (type & 7)
        prevStrong = type;
      prev = type;
    }
    for (let i = from2, prev = prevType, prevStrong = prevType; i < to; i++) {
      let type = types[i];
      if (type == 128) {
        if (i < to - 1 && prev == types[i + 1] && prev & 24)
          type = types[i] = prev;
        else
          types[i] = 256;
      } else if (type == 64) {
        let end = i + 1;
        while (end < to && types[end] == 64)
          end++;
        let replace2 = i && prev == 8 || end < rTo && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
        for (let j = i; j < end; j++)
          types[j] = replace2;
        i = end - 1;
      } else if (type == 8 && prevStrong == 1) {
        types[i] = 1;
      }
      prev = type;
      if (type & 7)
        prevStrong = type;
    }
  }
}
function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
  let oppositeType = outerType == 1 ? 2 : 1;
  for (let iI = 0, sI = 0, context2 = 0; iI <= isolates.length; iI++) {
    let from2 = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i = from2, ch, br, type; i < to; i++) {
      if (br = Brackets[ch = line.charCodeAt(i)]) {
        if (br < 0) {
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            if (BracketStack[sJ + 1] == -br) {
              let flags = BracketStack[sJ + 2];
              let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
              if (type2)
                types[i] = types[BracketStack[sJ]] = type2;
              sI = sJ;
              break;
            }
          }
        } else if (BracketStack.length == 189) {
          break;
        } else {
          BracketStack[sI++] = i;
          BracketStack[sI++] = ch;
          BracketStack[sI++] = context2;
        }
      } else if ((type = types[i]) == 2 || type == 1) {
        let embed = type == outerType;
        context2 = embed ? 0 : 1;
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          let cur2 = BracketStack[sJ + 2];
          if (cur2 & 2)
            break;
          if (embed) {
            BracketStack[sJ + 2] |= 2;
          } else {
            if (cur2 & 4)
              break;
            BracketStack[sJ + 2] |= 4;
          }
        }
      }
    }
  }
}
function processNeutrals(rFrom, rTo, isolates, outerType) {
  for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
    let from2 = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i = from2; i < to; ) {
      let type = types[i];
      if (type == 256) {
        let end = i + 1;
        for (; ; ) {
          if (end == to) {
            if (iI == isolates.length)
              break;
            end = isolates[iI++].to;
            to = iI < isolates.length ? isolates[iI].from : rTo;
          } else if (types[end] == 256) {
            end++;
          } else {
            break;
          }
        }
        let beforeL = prev == 1;
        let afterL = (end < rTo ? types[end] : outerType) == 1;
        let replace2 = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
        for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i; ) {
          if (j == fromJ) {
            j = isolates[--jI].from;
            fromJ = jI ? isolates[jI - 1].to : rFrom;
          }
          types[--j] = replace2;
        }
        i = end;
      } else {
        prev = type;
        i++;
      }
    }
  }
}
function emitSpans(line, from2, to, level, baseLevel, isolates, order) {
  let ourType = level % 2 ? 2 : 1;
  if (level % 2 == baseLevel % 2) {
    for (let iCh = from2, iI = 0; iCh < to; ) {
      let sameDir = true, isNum = false;
      if (iI == isolates.length || iCh < isolates[iI].from) {
        let next = types[iCh];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run: for (; ; ) {
        if (iI < isolates.length && iScan == isolates[iI].from) {
          if (isNum)
            break run;
          let iso = isolates[iI];
          if (!sameDir)
            for (let upto = iso.to, jI = iI + 1; ; ) {
              if (upto == to)
                break run;
              if (jI < isolates.length && isolates[jI].from == upto)
                upto = isolates[jI++].to;
              else if (types[upto] == ourType)
                break run;
              else
                break;
            }
          iI++;
          if (recurse) {
            recurse.push(iso);
          } else {
            if (iso.from > iCh)
              order.push(new BidiSpan(iCh, iso.from, localLevel));
            let dirSwap = iso.direction == LTR != !(localLevel % 2);
            computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
            iCh = iso.to;
          }
          iScan = iso.to;
        } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
          break;
        } else {
          iScan++;
        }
      }
      if (recurse)
        emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);
      else if (iCh < iScan)
        order.push(new BidiSpan(iCh, iScan, localLevel));
      iCh = iScan;
    }
  } else {
    for (let iCh = to, iI = isolates.length; iCh > from2; ) {
      let sameDir = true, isNum = false;
      if (!iI || iCh > isolates[iI - 1].to) {
        let next = types[iCh - 1];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run: for (; ; ) {
        if (iI && iScan == isolates[iI - 1].to) {
          if (isNum)
            break run;
          let iso = isolates[--iI];
          if (!sameDir)
            for (let upto = iso.from, jI = iI; ; ) {
              if (upto == from2)
                break run;
              if (jI && isolates[jI - 1].to == upto)
                upto = isolates[--jI].from;
              else if (types[upto - 1] == ourType)
                break run;
              else
                break;
            }
          if (recurse) {
            recurse.push(iso);
          } else {
            if (iso.to < iCh)
              order.push(new BidiSpan(iso.to, iCh, localLevel));
            let dirSwap = iso.direction == LTR != !(localLevel % 2);
            computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
            iCh = iso.from;
          }
          iScan = iso.from;
        } else if (iScan == from2 || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
          break;
        } else {
          iScan--;
        }
      }
      if (recurse)
        emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);
      else if (iScan < iCh)
        order.push(new BidiSpan(iScan, iCh, localLevel));
      iCh = iScan;
    }
  }
}
function computeSectionOrder(line, level, baseLevel, isolates, from2, to, order) {
  let outerType = level % 2 ? 2 : 1;
  computeCharTypes(line, from2, to, isolates, outerType);
  processBracketPairs(line, from2, to, isolates, outerType);
  processNeutrals(from2, to, isolates, outerType);
  emitSpans(line, from2, to, level, baseLevel, isolates, order);
}
function computeOrder(line, direction, isolates) {
  if (!line)
    return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
  if (direction == LTR && !isolates.length && !BidiRE.test(line))
    return trivialOrder(line.length);
  if (isolates.length)
    while (line.length > types.length)
      types[types.length] = 256;
  let order = [], level = direction == LTR ? 0 : 1;
  computeSectionOrder(line, level, level, isolates, 0, line.length, order);
  return order;
}
function trivialOrder(length) {
  return [new BidiSpan(0, length, 0)];
}
function moveVisually(line, order, dir, start, forward) {
  var _a2;
  let startIndex = start.head - line.from;
  let spanI = BidiSpan.find(order, startIndex, (_a2 = start.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start.assoc);
  let span = order[spanI], spanEnd = span.side(forward, dir);
  if (startIndex == spanEnd) {
    let nextI = spanI += forward ? 1 : -1;
    if (nextI < 0 || nextI >= order.length)
      return null;
    span = order[spanI = nextI];
    startIndex = span.side(!forward, dir);
    spanEnd = span.side(forward, dir);
  }
  let nextIndex = findClusterBreak2(line.text, startIndex, span.forward(forward, dir));
  if (nextIndex < span.from || nextIndex > span.to)
    nextIndex = spanEnd;
  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
  let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
  if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level)
    return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);
  return EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);
}
function autoDirection(text, from2, to) {
  for (let i = from2; i < to; i++) {
    let type = charType(text.charCodeAt(i));
    if (type == 1)
      return LTR;
    if (type == 2 || type == 4)
      return RTL;
  }
  return LTR;
}
function logException(state, exception, context2) {
  let handler = state.facet(exceptionSink);
  if (handler.length)
    handler[0](exception);
  else if (window.onerror && window.onerror(String(exception), context2, void 0, void 0, exception)) ;
  else if (context2)
    console.error(context2 + ":", exception);
  else
    console.error(exception);
}
function getIsolatedRanges(view, line) {
  let isolates = view.state.facet(bidiIsolatedRanges);
  if (!isolates.length)
    return isolates;
  let sets = isolates.map((i) => i instanceof Function ? i(view) : i);
  let result = [];
  RangeSet.spans(sets, line.from, line.to, {
    point() {
    },
    span(fromDoc, toDoc, active, open) {
      let from2 = fromDoc - line.from, to = toDoc - line.from;
      let level = result;
      for (let i = active.length - 1; i >= 0; i--, open--) {
        let direction = active[i].spec.bidiIsolate, update;
        if (direction == null)
          direction = autoDirection(line.text, from2, to);
        if (open > 0 && level.length && (update = level[level.length - 1]).to == from2 && update.direction == direction) {
          update.to = to;
          level = update.inner;
        } else {
          let add2 = { from: from2, to, direction, inner: [] };
          level.push(add2);
          level = add2.inner;
        }
      }
    }
  });
  return result;
}
function getScrollMargins(view) {
  let left = 0, right = 0, top2 = 0, bottom = 0;
  for (let source of view.state.facet(scrollMargins)) {
    let m = source(view);
    if (m) {
      if (m.left != null)
        left = Math.max(left, m.left);
      if (m.right != null)
        right = Math.max(right, m.right);
      if (m.top != null)
        top2 = Math.max(top2, m.top);
      if (m.bottom != null)
        bottom = Math.max(bottom, m.bottom);
    }
  }
  return { left, right, top: top2, bottom };
}
function betweenUneditable(pos) {
  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
function findCompositionNode(view, headPos) {
  let sel = view.observer.selectionRange;
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
  let textNode = textBefore || textAfter;
  if (textAfter && textBefore && textAfter.node != textBefore.node) {
    let descAfter = ContentView.get(textAfter.node);
    if (!descAfter || descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue) {
      textNode = textAfter;
    } else if (view.docView.lastCompositionAfterCursor) {
      let descBefore = ContentView.get(textBefore.node);
      if (!(!descBefore || descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue))
        textNode = textAfter;
    }
  }
  view.docView.lastCompositionAfterCursor = textNode != textBefore;
  if (!textNode)
    return null;
  let from2 = headPos - textNode.offset;
  return { from: from2, to: from2 + textNode.node.nodeValue.length, node: textNode.node };
}
function findCompositionRange(view, changes, headPos) {
  let found = findCompositionNode(view, headPos);
  if (!found)
    return null;
  let { node: textNode, from: from2, to } = found, text = textNode.nodeValue;
  if (/[\n\r]/.test(text))
    return null;
  if (view.state.doc.sliceString(found.from, found.to) != text)
    return null;
  let inv = changes.invertedDesc;
  let range = new ChangedRange(inv.mapPos(from2), inv.mapPos(to), from2, to);
  let marks2 = [];
  for (let parent = textNode.parentNode; ; parent = parent.parentNode) {
    let parentView = ContentView.get(parent);
    if (parentView instanceof MarkView)
      marks2.push({ node: parent, deco: parentView.mark });
    else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM)
      return { range, text: textNode, marks: marks2, line: parent };
    else if (parent != view.contentDOM)
      marks2.push({ node: parent, deco: new MarkDecoration({
        inclusive: true,
        attributes: getAttrs(parent),
        tagName: parent.tagName.toLowerCase()
      }) });
    else
      return null;
  }
}
function nextToUneditable(node, offset) {
  if (node.nodeType != 1)
    return 0;
  return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
}
function findChangedDeco(a, b, diff) {
  let comp = new DecorationComparator$1();
  RangeSet.compare(a, b, diff, comp);
  return comp.changes;
}
function inUneditable(node, inside2) {
  for (let cur2 = node; cur2 && cur2 != inside2; cur2 = cur2.assignedSlot || cur2.parentNode) {
    if (cur2.nodeType == 1 && cur2.contentEditable == "false") {
      return true;
    }
  }
  return false;
}
function touchesComposition(changes, composition) {
  let touched = false;
  if (composition)
    changes.iterChangedRanges((from2, to) => {
      if (from2 < composition.to && to > composition.from)
        touched = true;
    });
  return touched;
}
function groupAt(state, pos, bias = 1) {
  let categorize = state.charCategorizer(pos);
  let line = state.doc.lineAt(pos), linePos = pos - line.from;
  if (line.length == 0)
    return EditorSelection.cursor(pos);
  if (linePos == 0)
    bias = 1;
  else if (linePos == line.length)
    bias = -1;
  let from2 = linePos, to = linePos;
  if (bias < 0)
    from2 = findClusterBreak2(line.text, linePos, false);
  else
    to = findClusterBreak2(line.text, linePos);
  let cat = categorize(line.text.slice(from2, to));
  while (from2 > 0) {
    let prev = findClusterBreak2(line.text, from2, false);
    if (categorize(line.text.slice(prev, from2)) != cat)
      break;
    from2 = prev;
  }
  while (to < line.length) {
    let next = findClusterBreak2(line.text, to);
    if (categorize(line.text.slice(to, next)) != cat)
      break;
    to = next;
  }
  return EditorSelection.range(from2 + line.from, to + line.from);
}
function getdx(x, rect) {
  return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
}
function getdy(y, rect) {
  return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
}
function yOverlap(a, b) {
  return a.top < b.bottom - 1 && a.bottom > b.top + 1;
}
function upTop(rect, top2) {
  return top2 < rect.top ? { top: top2, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
}
function upBot(rect, bottom) {
  return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
}
function domPosAtCoords(parent, x, y) {
  let closest, closestRect, closestX, closestY, closestOverlap = false;
  let above, below, aboveRect, belowRect;
  for (let child = parent.firstChild; child; child = child.nextSibling) {
    let rects = clientRectsFor(child);
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (closestRect && yOverlap(closestRect, rect))
        rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
      let dx = getdx(x, rect), dy = getdy(y, rect);
      if (dx == 0 && dy == 0)
        return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
      if (!closest || closestY > dy || closestY == dy && closestX > dx) {
        closest = child;
        closestRect = rect;
        closestX = dx;
        closestY = dy;
        closestOverlap = !dx ? true : x < rect.left ? i > 0 : i < rects.length - 1;
      }
      if (dx == 0) {
        if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
          above = child;
          aboveRect = rect;
        } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
          below = child;
          belowRect = rect;
        }
      } else if (aboveRect && yOverlap(aboveRect, rect)) {
        aboveRect = upBot(aboveRect, rect.bottom);
      } else if (belowRect && yOverlap(belowRect, rect)) {
        belowRect = upTop(belowRect, rect.top);
      }
    }
  }
  if (aboveRect && aboveRect.bottom >= y) {
    closest = above;
    closestRect = aboveRect;
  } else if (belowRect && belowRect.top <= y) {
    closest = below;
    closestRect = belowRect;
  }
  if (!closest)
    return { node: parent, offset: 0 };
  let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
  if (closest.nodeType == 3)
    return domPosInText(closest, clipX, y);
  if (closestOverlap && closest.contentEditable != "false")
    return domPosAtCoords(closest, clipX, y);
  let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
  return { node: parent, offset };
}
function domPosInText(node, x, y) {
  let len = node.nodeValue.length;
  let closestOffset = -1, closestDY = 1e9, generalSide = 0;
  for (let i = 0; i < len; i++) {
    let rects = textRange(node, i, i + 1).getClientRects();
    for (let j = 0; j < rects.length; j++) {
      let rect = rects[j];
      if (rect.top == rect.bottom)
        continue;
      if (!generalSide)
        generalSide = x - rect.left;
      let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
      if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
        let right = x >= (rect.left + rect.right) / 2, after = right;
        if (browser.chrome || browser.gecko) {
          let rectBefore = textRange(node, i).getBoundingClientRect();
          if (rectBefore.left == rect.right)
            after = !right;
        }
        if (dy <= 0)
          return { node, offset: i + (after ? 1 : 0) };
        closestOffset = i + (after ? 1 : 0);
        closestDY = dy;
      }
    }
  }
  return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
}
function posAtCoords(view, coords, precise, bias = -1) {
  var _a2, _b;
  let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
  let block, { docHeight } = view.viewState;
  let { x, y } = coords, yOffset = y - docTop;
  if (yOffset < 0)
    return 0;
  if (yOffset > docHeight)
    return view.state.doc.length;
  for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false; ; ) {
    block = view.elementAtHeight(yOffset);
    if (block.type == BlockType.Text)
      break;
    for (; ; ) {
      yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
      if (yOffset >= 0 && yOffset <= docHeight)
        break;
      if (bounced)
        return precise ? null : 0;
      bounced = true;
      bias = -bias;
    }
  }
  y = docTop + yOffset;
  let lineStart = block.from;
  if (lineStart < view.viewport.from)
    return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
  if (lineStart > view.viewport.to)
    return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
  let doc2 = view.dom.ownerDocument;
  let root = view.root.elementFromPoint ? view.root : doc2;
  let element = root.elementFromPoint(x, y);
  if (element && !view.contentDOM.contains(element))
    element = null;
  if (!element) {
    x = Math.max(content2.left + 1, Math.min(content2.right - 1, x));
    element = root.elementFromPoint(x, y);
    if (element && !view.contentDOM.contains(element))
      element = null;
  }
  let node, offset = -1;
  if (element && ((_a2 = view.docView.nearest(element)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
    if (doc2.caretPositionFromPoint) {
      let pos = doc2.caretPositionFromPoint(x, y);
      if (pos)
        ({ offsetNode: node, offset } = pos);
    } else if (doc2.caretRangeFromPoint) {
      let range = doc2.caretRangeFromPoint(x, y);
      if (range)
        ({ startContainer: node, startOffset: offset } = range);
    }
    if (node && (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x)))
      node = void 0;
    if (node)
      offset = Math.min(maxOffset(node), offset);
  }
  if (!node || !view.docView.dom.contains(node)) {
    let line = LineView.find(view.docView, lineStart);
    if (!line)
      return yOffset > block.top + block.height / 2 ? block.to : block.from;
    ({ node, offset } = domPosAtCoords(line.dom, x, y));
  }
  let nearest = view.docView.nearest(node);
  if (!nearest)
    return null;
  if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
    let rect = nearest.dom.getBoundingClientRect();
    return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;
  } else {
    return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;
  }
}
function posAtCoordsImprecise(view, contentRect, block, x, y) {
  let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
  if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
    let textHeight = view.viewState.heightOracle.textHeight;
    let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
    into += line * view.viewState.heightOracle.lineLength;
  }
  let content2 = view.state.sliceDoc(block.from, block.to);
  return block.from + findColumn(content2, into, view.state.tabSize);
}
function isEndOfLineBefore(node, offset, x) {
  let len, scan2 = node;
  if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
    return false;
  for (; ; ) {
    let next = scan2.nextSibling;
    if (next) {
      if (next.nodeName == "BR")
        break;
      return false;
    } else {
      let parent = scan2.parentNode;
      if (!parent || parent.nodeName == "DIV")
        break;
      scan2 = parent;
    }
  }
  return textRange(node, len - 1, len).getBoundingClientRect().right > x;
}
function isSuspiciousSafariCaretResult(node, offset, x) {
  return isEndOfLineBefore(node, offset, x);
}
function isSuspiciousChromeCaretResult(node, offset, x) {
  if (offset != 0)
    return isEndOfLineBefore(node, offset, x);
  for (let cur2 = node; ; ) {
    let parent = cur2.parentNode;
    if (!parent || parent.nodeType != 1 || parent.firstChild != cur2)
      return false;
    if (parent.classList.contains("cm-line"))
      break;
    cur2 = parent;
  }
  let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
  return x - rect.left > 5;
}
function blockAt(view, pos, side) {
  let line = view.lineBlockAt(pos);
  if (Array.isArray(line.type)) {
    let best;
    for (let l of line.type) {
      if (l.from > pos)
        break;
      if (l.to < pos)
        continue;
      if (l.from < pos && l.to > pos)
        return l;
      if (!best || l.type == BlockType.Text && (best.type != l.type || (side < 0 ? l.from < pos : l.to > pos)))
        best = l;
    }
    return best || line;
  }
  return line;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
  let line = blockAt(view, start.head, start.assoc || -1);
  let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
  if (coords) {
    let editorRect = view.dom.getBoundingClientRect();
    let direction = view.textDirectionAt(line.from);
    let pos = view.posAtCoords({
      x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
      y: (coords.top + coords.bottom) / 2
    });
    if (pos != null)
      return EditorSelection.cursor(pos, forward ? -1 : 1);
  }
  return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
  let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
  let direction = view.textDirectionAt(line.from);
  for (let cur2 = start, check = null; ; ) {
    let next = moveVisually(line, spans, direction, cur2, forward), char = movedOver;
    if (!next) {
      if (line.number == (forward ? view.state.doc.lines : 1))
        return cur2;
      char = "\n";
      line = view.state.doc.line(line.number + (forward ? 1 : -1));
      spans = view.bidiSpans(line);
      next = view.visualLineSide(line, !forward);
    }
    if (!check) {
      if (!by)
        return next;
      check = by(char);
    } else if (!check(char)) {
      return cur2;
    }
    cur2 = next;
  }
}
function byGroup(view, pos, start) {
  let categorize = view.state.charCategorizer(pos);
  let cat = categorize(start);
  return (next) => {
    let nextCat = categorize(next);
    if (cat == CharCategory.Space)
      cat = nextCat;
    return cat == nextCat;
  };
}
function moveVertically(view, start, forward, distance) {
  let startPos = start.head, dir = forward ? 1 : -1;
  if (startPos == (forward ? view.state.doc.length : 0))
    return EditorSelection.cursor(startPos, start.assoc);
  let goal = start.goalColumn, startY;
  let rect = view.contentDOM.getBoundingClientRect();
  let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;
  if (startCoords) {
    if (goal == null)
      goal = startCoords.left - rect.left;
    startY = dir < 0 ? startCoords.top : startCoords.bottom;
  } else {
    let line = view.viewState.lineBlockAt(startPos);
    if (goal == null)
      goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
    startY = (dir < 0 ? line.top : line.bottom) + docTop;
  }
  let resolvedGoal = rect.left + goal;
  let dist2 = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;
  for (let extra = 0; ; extra += 10) {
    let curY = startY + (dist2 + extra) * dir;
    let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
    if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
      let charRect = view.docView.coordsForChar(pos);
      let assoc = !charRect || curY < charRect.top ? -1 : 1;
      return EditorSelection.cursor(pos, assoc, void 0, goal);
    }
  }
}
function skipAtomicRanges(atoms, pos, bias) {
  for (; ; ) {
    let moved = 0;
    for (let set of atoms) {
      set.between(pos - 1, pos + 1, (from2, to, value) => {
        if (pos > from2 && pos < to) {
          let side = moved || bias || (pos - from2 < to - pos ? -1 : 1);
          pos = side < 0 ? from2 : to;
          moved = side;
        }
      });
    }
    if (!moved)
      return pos;
  }
}
function skipAtomsForSelection(atoms, sel) {
  let ranges = null;
  for (let i = 0; i < sel.ranges.length; i++) {
    let range = sel.ranges[i], updated = null;
    if (range.empty) {
      let pos = skipAtomicRanges(atoms, range.from, 0);
      if (pos != range.from)
        updated = EditorSelection.cursor(pos, -1);
    } else {
      let from2 = skipAtomicRanges(atoms, range.from, -1);
      let to = skipAtomicRanges(atoms, range.to, 1);
      if (from2 != range.from || to != range.to)
        updated = EditorSelection.range(range.from == range.anchor ? from2 : to, range.from == range.head ? from2 : to);
    }
    if (updated) {
      if (!ranges)
        ranges = sel.ranges.slice();
      ranges[i] = updated;
    }
  }
  return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;
}
function skipAtoms(view, oldPos, pos) {
  let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f) => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
  return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
}
function isAtEnd(parent, node, offset) {
  for (; ; ) {
    if (!node || offset < maxOffset(node))
      return false;
    if (node == parent)
      return true;
    offset = domIndex(node) + 1;
    node = node.parentNode;
  }
}
function isEmptyToEnd(node, end) {
  let widgets;
  for (; ; node = node.nextSibling) {
    if (node == end || !node)
      break;
    let view = ContentView.get(node);
    if (!((view === null || view === void 0 ? void 0 : view.isWidget) || node.cmIgnore))
      return false;
    if (view)
      (widgets || (widgets = [])).push(view);
  }
  if (widgets)
    for (let w of widgets) {
      let override = w.overrideDOMText;
      if (override === null || override === void 0 ? void 0 : override.length)
        return false;
    }
  return true;
}
function applyDOMChange(view, domChange) {
  let change;
  let { newSel } = domChange, sel = view.state.selection.main;
  let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
  if (domChange.bounds) {
    let { from: from2, to } = domChange.bounds;
    let preferredPos = sel.from, preferredSide = null;
    if (lastKey === 8 || browser.android && domChange.text.length < to - from2) {
      preferredPos = sel.to;
      preferredSide = "end";
    }
    let diff = findDiff(view.state.doc.sliceString(from2, to, LineBreakPlaceholder), domChange.text, preferredPos - from2, preferredSide);
    if (diff) {
      if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
        diff.toB--;
      change = {
        from: from2 + diff.from,
        to: from2 + diff.toA,
        insert: Text2.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
      };
    }
  } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
    newSel = null;
  }
  if (!change && !newSel)
    return false;
  if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
    change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
  } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
    if (newSel && change.insert.length == 2)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: change.from, to: change.to, insert: Text2.of([change.insert.toString().replace(".", " ")]) };
  } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
    };
  } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
    if (newSel)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: sel.from, to: sel.to, insert: Text2.of([" "]) };
  }
  if (change) {
    return applyDOMChangeInner(view, change, newSel, lastKey);
  } else if (newSel && !newSel.main.eq(sel)) {
    let scrollIntoView3 = false, userEvent = "select";
    if (view.inputState.lastSelectionTime > Date.now() - 50) {
      if (view.inputState.lastSelectionOrigin == "select")
        scrollIntoView3 = true;
      userEvent = view.inputState.lastSelectionOrigin;
      if (userEvent == "select.pointer")
        newSel = skipAtomsForSelection(view.state.facet(atomicRanges).map((f) => f(view)), newSel);
    }
    view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView3, userEvent });
    return true;
  } else {
    return false;
  }
}
function applyDOMChangeInner(view, change, newSel, lastKey = -1) {
  if (browser.ios && view.inputState.flushIOSKey(change))
    return true;
  let sel = view.state.selection.main;
  if (browser.android && (change.to == sel.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == " ") && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
    return true;
  let text = change.insert.toString();
  if (view.inputState.composing >= 0)
    view.inputState.composing++;
  let defaultTr;
  let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
  if (!view.state.facet(inputHandler).some((h) => h(view, change.from, change.to, text, defaultInsert)))
    view.dispatch(defaultInsert());
  return true;
}
function applyDefaultInsert(view, change, newSel) {
  let tr, startState = view.state, sel = startState.selection.main, inAtomic = -1;
  if (change.from == change.to && change.from < sel.from || change.from > sel.to) {
    let side = change.from < sel.from ? -1 : 1, pos = side < 0 ? sel.from : sel.to;
    let moved = skipAtomicRanges(startState.facet(atomicRanges).map((f) => f(view)), pos, side);
    if (change.from == moved)
      inAtomic = moved;
  }
  if (inAtomic > -1) {
    tr = {
      changes: change,
      selection: EditorSelection.cursor(change.from + change.insert.length, -1)
    };
  } else if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
    let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
    let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
    tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
  } else {
    let changes = startState.changes(change);
    let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : void 0;
    if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
      let replaced = view.state.sliceDoc(change.from, change.to);
      let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
      if (composition) {
        let dLen = change.insert.length - (change.to - change.from);
        compositionRange = { from: composition.from, to: composition.to - dLen };
      } else {
        compositionRange = view.state.doc.lineAt(sel.head);
      }
      let offset = sel.to - change.to, size = sel.to - sel.from;
      tr = startState.changeByRange((range) => {
        if (range.from == sel.from && range.to == sel.to)
          return { changes, range: mainSel || range.map(changes) };
        let to = range.to - offset, from2 = to - replaced.length;
        if (range.to - range.from != size || view.state.sliceDoc(from2, to) != replaced || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        range.to >= compositionRange.from && range.from <= compositionRange.to)
          return { range };
        let rangeChanges = startState.changes({ from: from2, to, insert: change.insert }), selOff = range.to - sel.to;
        return {
          changes: rangeChanges,
          range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
        };
      });
    } else {
      tr = {
        changes,
        selection: mainSel && startState.selection.replaceRange(mainSel)
      };
    }
  }
  let userEvent = "input.type";
  if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
    view.inputState.compositionPendingChange = false;
    userEvent += ".compose";
    if (view.inputState.compositionFirstChange) {
      userEvent += ".start";
      view.inputState.compositionFirstChange = false;
    }
  }
  return startState.update(tr, { userEvent, scrollIntoView: true });
}
function findDiff(a, b, preferredPos, preferredSide) {
  let minLen = Math.min(a.length, b.length);
  let from2 = 0;
  while (from2 < minLen && a.charCodeAt(from2) == b.charCodeAt(from2))
    from2++;
  if (from2 == minLen && a.length == b.length)
    return null;
  let toA = a.length, toB = b.length;
  while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
    toA--;
    toB--;
  }
  if (preferredSide == "end") {
    let adjust = Math.max(0, from2 - Math.min(toA, toB));
    preferredPos -= toA + adjust - from2;
  }
  if (toA < from2 && a.length < b.length) {
    let move = preferredPos <= from2 && preferredPos >= toA ? from2 - preferredPos : 0;
    from2 -= move;
    toB = from2 + (toB - toA);
    toA = from2;
  } else if (toB < from2) {
    let move = preferredPos <= from2 && preferredPos >= toB ? from2 - preferredPos : 0;
    from2 -= move;
    toA = from2 + (toA - toB);
    toB = from2;
  }
  return { from: from2, toA, toB };
}
function selectionPoints(view) {
  let result = [];
  if (view.root.activeElement != view.contentDOM)
    return result;
  let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
  if (anchorNode) {
    result.push(new DOMPoint(anchorNode, anchorOffset));
    if (focusNode != anchorNode || focusOffset != anchorOffset)
      result.push(new DOMPoint(focusNode, focusOffset));
  }
  return result;
}
function selectionFromPoints(points, base2) {
  if (points.length == 0)
    return null;
  let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
  return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
}
function bindHandler(plugin, handler) {
  return (view, event) => {
    try {
      return handler.call(plugin, event, view);
    } catch (e) {
      logException(view.state, e);
    }
  };
}
function computeHandlers(plugins) {
  let result = /* @__PURE__ */ Object.create(null);
  function record(type) {
    return result[type] || (result[type] = { observers: [], handlers: [] });
  }
  for (let plugin of plugins) {
    let spec = plugin.spec, handlers2 = spec && spec.plugin.domEventHandlers, observers2 = spec && spec.plugin.domEventObservers;
    if (handlers2)
      for (let type in handlers2) {
        let f = handlers2[type];
        if (f)
          record(type).handlers.push(bindHandler(plugin.value, f));
      }
    if (observers2)
      for (let type in observers2) {
        let f = observers2[type];
        if (f)
          record(type).observers.push(bindHandler(plugin.value, f));
      }
  }
  for (let type in handlers)
    record(type).handlers.push(handlers[type]);
  for (let type in observers)
    record(type).observers.push(observers[type]);
  return result;
}
function dragScrollSpeed(dist2) {
  return Math.max(0, dist2) * 0.7 + 8;
}
function dist(a, b) {
  return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));
}
function addsSelectionRange(view, event) {
  let facet = view.state.facet(clickAddsSelectionRange);
  return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
  let facet = view.state.facet(dragMovesSelection$1);
  return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
  let { main } = view.state.selection;
  if (main.empty)
    return false;
  let sel = getSelection(view.root);
  if (!sel || sel.rangeCount == 0)
    return true;
  let rects = sel.getRangeAt(0).getClientRects();
  for (let i = 0; i < rects.length; i++) {
    let rect = rects[i];
    if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
      return true;
  }
  return false;
}
function eventBelongsToEditor(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
    if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event))
      return false;
  return true;
}
function capturePaste(view) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(() => {
    view.focus();
    target.remove();
    doPaste(view, target.value);
  }, 50);
}
function textFilter(state, facet, text) {
  for (let filter2 of state.facet(facet))
    text = filter2(text, state);
  return text;
}
function doPaste(view, input2) {
  input2 = textFilter(view.state, clipboardInputFilter, input2);
  let { state } = view, changes, i = 1, text = state.toText(input2);
  let byLine = text.lines == state.selection.ranges.length;
  let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text.toString();
  if (linewise) {
    let lastLine = -1;
    changes = state.changeByRange((range) => {
      let line = state.doc.lineAt(range.from);
      if (line.from == lastLine)
        return { range };
      lastLine = line.from;
      let insert2 = state.toText((byLine ? text.line(i++).text : input2) + state.lineBreak);
      return {
        changes: { from: line.from, insert: insert2 },
        range: EditorSelection.cursor(range.from + insert2.length)
      };
    });
  } else if (byLine) {
    changes = state.changeByRange((range) => {
      let line = text.line(i++);
      return {
        changes: { from: range.from, to: range.to, insert: line.text },
        range: EditorSelection.cursor(range.from + line.length)
      };
    });
  } else {
    changes = state.replaceSelection(text);
  }
  view.dispatch(changes, {
    userEvent: "input.paste",
    scrollIntoView: true
  });
}
function rangeForClick(view, pos, bias, type) {
  if (type == 1) {
    return EditorSelection.cursor(pos, bias);
  } else if (type == 2) {
    return groupAt(view.state, pos, bias);
  } else {
    let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
    let from2 = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
    if (to < view.state.doc.length && to == line.to)
      to++;
    return EditorSelection.range(from2, to);
  }
}
function findPositionSide(view, pos, x, y) {
  let line = LineView.find(view.docView, pos);
  if (!line)
    return 1;
  let off = pos - line.posAtStart;
  if (off == 0)
    return 1;
  if (off == line.length)
    return -1;
  let before = line.coordsAt(off, -1);
  if (before && inside(x, y, before))
    return -1;
  let after = line.coordsAt(off, 1);
  if (after && inside(x, y, after))
    return 1;
  return before && before.bottom >= y ? -1 : 1;
}
function queryPos(view, event) {
  let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
}
function getClickType(event) {
  if (!BadMouseDetail)
    return event.detail;
  let last4 = lastMouseDown, lastTime = lastMouseDownTime;
  lastMouseDown = event;
  lastMouseDownTime = Date.now();
  return lastMouseDownCount = !last4 || lastTime > Date.now() - 400 && Math.abs(last4.clientX - event.clientX) < 2 && Math.abs(last4.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
  let start = queryPos(view, event), type = getClickType(event);
  let startSel = view.state.selection;
  return {
    update(update) {
      if (update.docChanged) {
        start.pos = update.changes.mapPos(start.pos);
        startSel = startSel.map(update.changes);
      }
    },
    get(event2, extend, multiple) {
      let cur2 = queryPos(view, event2), removed;
      let range = rangeForClick(view, cur2.pos, cur2.bias, type);
      if (start.pos != cur2.pos && !extend) {
        let startRange = rangeForClick(view, start.pos, start.bias, type);
        let from2 = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
        range = from2 < range.from ? EditorSelection.range(from2, to) : EditorSelection.range(to, from2);
      }
      if (extend)
        return startSel.replaceRange(startSel.main.extend(range.from, range.to));
      else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur2.pos)))
        return removed;
      else if (multiple)
        return startSel.addRange(range);
      else
        return EditorSelection.create([range]);
    }
  };
}
function removeRangeAround(sel, pos) {
  for (let i = 0; i < sel.ranges.length; i++) {
    let { from: from2, to } = sel.ranges[i];
    if (from2 <= pos && to >= pos)
      return EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
  }
  return null;
}
function dropText(view, event, text, direct) {
  text = textFilter(view.state, clipboardInputFilter, text);
  if (!text)
    return;
  let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  let { draggedContent } = view.inputState;
  let del = direct && draggedContent && dragMovesSelection(view, event) ? { from: draggedContent.from, to: draggedContent.to } : null;
  let ins = { from: dropPos, insert: text };
  let changes = view.state.changes(del ? [del, ins] : ins);
  view.focus();
  view.dispatch({
    changes,
    selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
    userEvent: del ? "move.drop" : "input.drop"
  });
  view.inputState.draggedContent = null;
}
function captureCopy(view, text) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.value = text;
  target.focus();
  target.selectionEnd = text.length;
  target.selectionStart = 0;
  setTimeout(() => {
    target.remove();
    view.focus();
  }, 50);
}
function copiedRange(state) {
  let content2 = [], ranges = [], linewise = false;
  for (let range of state.selection.ranges)
    if (!range.empty) {
      content2.push(state.sliceDoc(range.from, range.to));
      ranges.push(range);
    }
  if (!content2.length) {
    let upto = -1;
    for (let { from: from2 } of state.selection.ranges) {
      let line = state.doc.lineAt(from2);
      if (line.number > upto) {
        content2.push(line.text);
        ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
      }
      upto = line.number;
    }
    linewise = true;
  }
  return { text: textFilter(state, clipboardOutputFilter, content2.join(state.lineBreak)), ranges, linewise };
}
function focusChangeTransaction(state, focus) {
  let effects = [];
  for (let getEffect of state.facet(focusChangeEffect)) {
    let effect2 = getEffect(state, focus);
    if (effect2)
      effects.push(effect2);
  }
  return effects.length ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
}
function updateForFocusChange(view) {
  setTimeout(() => {
    let focus = view.hasFocus;
    if (focus != view.inputState.notifiedFocused) {
      let tr = focusChangeTransaction(view.state, focus);
      if (tr)
        view.dispatch(tr);
      else
        view.update([]);
    }
  }, 10);
}
function firefoxCopyCutHack(doc2) {
  if (!appliedFirefoxHack.has(doc2)) {
    appliedFirefoxHack.add(doc2);
    doc2.addEventListener("copy", () => {
    });
    doc2.addEventListener("cut", () => {
    });
  }
}
function clearHeightChangeFlag() {
  heightChangeFlag = false;
}
function replace(old, val) {
  if (old == val)
    return old;
  if (old.constructor != val.constructor)
    heightChangeFlag = true;
  return val;
}
function mergeGaps(nodes, around) {
  let before, after;
  if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
    nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
function heightRelevantDecoChanges(a, b, diff) {
  let comp = new DecorationComparator2();
  RangeSet.compare(a, b, diff, comp, 0);
  return comp.changes;
}
function visiblePixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
  let top2 = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
  for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
    if (parent.nodeType == 1) {
      let elt2 = parent;
      let style = window.getComputedStyle(elt2);
      if ((elt2.scrollHeight > elt2.clientHeight || elt2.scrollWidth > elt2.clientWidth) && style.overflow != "visible") {
        let parentRect = elt2.getBoundingClientRect();
        left = Math.max(left, parentRect.left);
        right = Math.min(right, parentRect.right);
        top2 = Math.max(top2, parentRect.top);
        bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);
      }
      parent = style.position == "absolute" || style.position == "fixed" ? elt2.offsetParent : elt2.parentNode;
    } else if (parent.nodeType == 11) {
      parent = parent.host;
    } else {
      break;
    }
  }
  return {
    left: left - rect.left,
    right: Math.max(left, right) - rect.left,
    top: top2 - (rect.top + paddingTop),
    bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
  };
}
function inWindow(elt2) {
  let rect = elt2.getBoundingClientRect(), win = elt2.ownerDocument.defaultView || window;
  return rect.left < win.innerWidth && rect.right > 0 && rect.top < win.innerHeight && rect.bottom > 0;
}
function fullPixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  return {
    left: 0,
    right: rect.right - rect.left,
    top: paddingTop,
    bottom: rect.bottom - (rect.top + paddingTop)
  };
}
function lineStructure(from2, to, stateDeco) {
  let ranges = [], pos = from2, total = 0;
  RangeSet.spans(stateDeco, from2, to, {
    span() {
    },
    point(from3, to2) {
      if (from3 > pos) {
        ranges.push({ from: pos, to: from3 });
        total += from3 - pos;
      }
      pos = to2;
    }
  }, 20);
  if (pos < to) {
    ranges.push({ from: pos, to });
    total += to - pos;
  }
  return { total, ranges };
}
function findPosition({ total, ranges }, ratio) {
  if (ratio <= 0)
    return ranges[0].from;
  if (ratio >= 1)
    return ranges[ranges.length - 1].to;
  let dist2 = Math.floor(total * ratio);
  for (let i = 0; ; i++) {
    let { from: from2, to } = ranges[i], size = to - from2;
    if (dist2 <= size)
      return from2 + dist2;
    dist2 -= size;
  }
}
function findFraction(structure, pos) {
  let counted = 0;
  for (let { from: from2, to } of structure.ranges) {
    if (pos <= to) {
      counted += pos - from2;
      break;
    }
    counted += to - from2;
  }
  return counted / structure.total;
}
function find(array, f) {
  for (let val of array)
    if (f(val))
      return val;
  return void 0;
}
function scaleBlock(block, scaler) {
  if (scaler.scale == 1)
    return block;
  let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
  return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b) => scaleBlock(b, scaler)) : block._content);
}
function buildTheme(main, spec, scopes) {
  return new StyleModule(spec, {
    finish(sel) {
      return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
        if (m == "&")
          return main;
        if (!scopes || !scopes[m])
          throw new RangeError(`Unsupported selector: ${m}`);
        return scopes[m];
      }) : main + " " + sel;
    }
  });
}
function findChild(cView, dom, dir) {
  while (dom) {
    let curView = ContentView.get(dom);
    if (curView && curView.parent == cView)
      return curView;
    let parent = dom.parentNode;
    dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
  }
  return null;
}
function buildSelectionRangeFromRange(view, range) {
  let anchorNode = range.startContainer, anchorOffset = range.startOffset;
  let focusNode = range.endContainer, focusOffset = range.endOffset;
  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariSelectionRangeHack(view, selection2) {
  if (selection2.getComposedRanges) {
    let range = selection2.getComposedRanges(view.root)[0];
    if (range)
      return buildSelectionRangeFromRange(view, range);
  }
  let found = null;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found = event.getTargetRanges()[0];
  }
  view.contentDOM.addEventListener("beforeinput", read, true);
  view.dom.ownerDocument.execCommand("indent");
  view.contentDOM.removeEventListener("beforeinput", read, true);
  return found ? buildSelectionRangeFromRange(view, found) : null;
}
function attrsFromFacet(view, facet, base2) {
  for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
    let source = sources[i], value = typeof source == "function" ? source(view) : source;
    if (value)
      combineAttrs(value, base2);
  }
  return base2;
}
function normalizeKeyName(name2, platform) {
  const parts = name2.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta2;
  for (let i = 0; i < parts.length - 1; ++i) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta2 = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (platform == "mac")
        meta2 = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta2)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function modifiers(name2, event, shift2) {
  if (event.altKey)
    name2 = "Alt-" + name2;
  if (event.ctrlKey)
    name2 = "Ctrl-" + name2;
  if (event.metaKey)
    name2 = "Meta-" + name2;
  if (shift2 !== false && event.shiftKey)
    name2 = "Shift-" + name2;
  return name2;
}
function getKeymap(state) {
  let bindings = state.facet(keymap);
  let map2 = Keymaps.get(bindings);
  if (!map2)
    Keymaps.set(bindings, map2 = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
  return map2;
}
function runScopeHandlers(view, event, scope) {
  return runHandlers(getKeymap(view.state), event, view, scope);
}
function buildKeymap(bindings, platform = currentPlatform) {
  let bound = /* @__PURE__ */ Object.create(null);
  let isPrefix = /* @__PURE__ */ Object.create(null);
  let checkPrefix = (name2, is) => {
    let current = isPrefix[name2];
    if (current == null)
      isPrefix[name2] = is;
    else if (current != is)
      throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
  };
  let add2 = (scope, key, command2, preventDefault, stopPropagation) => {
    var _a2, _b;
    let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
    let parts = key.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
    for (let i = 1; i < parts.length; i++) {
      let prefix = parts.slice(0, i).join(" ");
      checkPrefix(prefix, true);
      if (!scopeObj[prefix])
        scopeObj[prefix] = {
          preventDefault: true,
          stopPropagation: false,
          run: [(view) => {
            let ourObj = storedPrefix = { view, prefix, scope };
            setTimeout(() => {
              if (storedPrefix == ourObj)
                storedPrefix = null;
            }, PrefixTimeout);
            return true;
          }]
        };
    }
    let full = parts.join(" ");
    checkPrefix(full, false);
    let binding = scopeObj[full] || (scopeObj[full] = {
      preventDefault: false,
      stopPropagation: false,
      run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
    });
    if (command2)
      binding.run.push(command2);
    if (preventDefault)
      binding.preventDefault = true;
    if (stopPropagation)
      binding.stopPropagation = true;
  };
  for (let b of bindings) {
    let scopes = b.scope ? b.scope.split(" ") : ["editor"];
    if (b.any)
      for (let scope of scopes) {
        let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
        if (!scopeObj._any)
          scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
        let { any } = b;
        for (let key in scopeObj)
          scopeObj[key].run.push((view) => any(view, currentKeyEvent));
      }
    let name2 = b[platform] || b.key;
    if (!name2)
      continue;
    for (let scope of scopes) {
      add2(scope, name2, b.run, b.preventDefault, b.stopPropagation);
      if (b.shift)
        add2(scope, "Shift-" + name2, b.shift, b.preventDefault, b.stopPropagation);
    }
  }
  return bound;
}
function runHandlers(map2, event, view, scope) {
  currentKeyEvent = event;
  let name2 = keyName(event);
  let charCode = codePointAt2(name2, 0), isChar = codePointSize2(charCode) == name2.length && name2 != " ";
  let prefix = "", handled = false, prevented = false, stopPropagation = false;
  if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
    prefix = storedPrefix.prefix + " ";
    if (modifierCodes.indexOf(event.keyCode) < 0) {
      prevented = true;
      storedPrefix = null;
    }
  }
  let ran = /* @__PURE__ */ new Set();
  let runFor = (binding) => {
    if (binding) {
      for (let cmd2 of binding.run)
        if (!ran.has(cmd2)) {
          ran.add(cmd2);
          if (cmd2(view)) {
            if (binding.stopPropagation)
              stopPropagation = true;
            return true;
          }
        }
      if (binding.preventDefault) {
        if (binding.stopPropagation)
          stopPropagation = true;
        prevented = true;
      }
    }
    return false;
  };
  let scopeObj = map2[scope], baseName, shiftName;
  if (scopeObj) {
    if (runFor(scopeObj[prefix + modifiers(name2, event, !isChar)])) {
      handled = true;
    } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
    !(browser.windows && event.ctrlKey && event.altKey) && // Alt-combinations on macOS tend to be typed characters
    !(browser.mac && event.altKey && !(event.ctrlKey || event.metaKey)) && (baseName = base[event.keyCode]) && baseName != name2) {
      if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
        handled = true;
      } else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name2 && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {
        handled = true;
      }
    } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name2, event, true)])) {
      handled = true;
    }
    if (!handled && runFor(scopeObj._any))
      handled = true;
  }
  if (prevented)
    handled = true;
  if (handled && stopPropagation)
    event.stopPropagation();
  currentKeyEvent = null;
  return handled;
}
function getBase(view) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;
  return { left: left - view.scrollDOM.scrollLeft * view.scaleX, top: rect.top - view.scrollDOM.scrollTop * view.scaleY };
}
function wrappedLine(view, pos, side, inside2) {
  let coords = view.coordsAtPos(pos, side * 2);
  if (!coords)
    return inside2;
  let editorRect = view.dom.getBoundingClientRect();
  let y = (coords.top + coords.bottom) / 2;
  let left = view.posAtCoords({ x: editorRect.left + 1, y });
  let right = view.posAtCoords({ x: editorRect.right - 1, y });
  if (left == null || right == null)
    return inside2;
  return { from: Math.max(inside2.from, Math.min(left, right)), to: Math.min(inside2.to, Math.max(left, right)) };
}
function rectanglesForRange(view, className, range) {
  if (range.to <= view.viewport.from || range.from >= view.viewport.to)
    return [];
  let from2 = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
  let ltr = view.textDirection == Direction.LTR;
  let content2 = view.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view);
  let lineElt = content2.querySelector(".cm-line"), lineStyle = lineElt && window.getComputedStyle(lineElt);
  let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
  let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
  let startBlock = blockAt(view, from2, 1), endBlock = blockAt(view, to, -1);
  let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
  let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
  if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks))
    visualStart = wrappedLine(view, from2, 1, visualStart);
  if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks))
    visualEnd = wrappedLine(view, to, -1, visualEnd);
  if (visualStart && visualEnd && visualStart.from == visualEnd.from && visualStart.to == visualEnd.to) {
    return pieces(drawForLine(range.from, range.to, visualStart));
  } else {
    let top2 = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
    let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
    let between = [];
    if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top2.bottom + view.defaultLineHeight / 2 < bottom.top)
      between.push(piece(leftSide, top2.bottom, rightSide, bottom.top));
    else if (top2.bottom < bottom.top && view.elementAtHeight((top2.bottom + bottom.top) / 2).type == BlockType.Text)
      top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2;
    return pieces(top2).concat(between).concat(pieces(bottom));
  }
  function piece(left, top2, right, bottom) {
    return new RectangleMarker(className, left - base2.left, top2 - base2.top, right - left, bottom - top2);
  }
  function pieces({ top: top2, bottom, horizontal }) {
    let pieces2 = [];
    for (let i = 0; i < horizontal.length; i += 2)
      pieces2.push(piece(horizontal[i], top2, horizontal[i + 1], bottom));
    return pieces2;
  }
  function drawForLine(from3, to2, line) {
    let top2 = 1e9, bottom = -1e9, horizontal = [];
    function addSpan(from4, fromOpen, to3, toOpen, dir) {
      let fromCoords = view.coordsAtPos(from4, from4 == line.to ? -2 : 2);
      let toCoords = view.coordsAtPos(to3, to3 == line.from ? 2 : -2);
      if (!fromCoords || !toCoords)
        return;
      top2 = Math.min(fromCoords.top, toCoords.top, top2);
      bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
      if (dir == Direction.LTR)
        horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
      else
        horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
    }
    let start = from3 !== null && from3 !== void 0 ? from3 : line.from, end = to2 !== null && to2 !== void 0 ? to2 : line.to;
    for (let r of view.visibleRanges)
      if (r.to > start && r.from < end) {
        for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end); ; ) {
          let docLine = view.state.doc.lineAt(pos);
          for (let span of view.bidiSpans(docLine)) {
            let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
            if (spanFrom >= endPos)
              break;
            if (spanTo > pos)
              addSpan(Math.max(spanFrom, pos), from3 == null && spanFrom <= start, Math.min(spanTo, endPos), to2 == null && spanTo >= end, span.dir);
          }
          pos = docLine.to + 1;
          if (pos >= endPos)
            break;
        }
      }
    if (horizontal.length == 0)
      addSpan(start, from3 == null, end, to2 == null, view.textDirection);
    return { top: top2, bottom, horizontal };
  }
  function drawForWidget(block, top2) {
    let y = contentRect.top + (top2 ? block.top : block.bottom);
    return { top: y, bottom: y, horizontal: [] };
  }
}
function sameMarker(a, b) {
  return a.constructor == b.constructor && a.eq(b);
}
function layer(config3) {
  return [
    ViewPlugin.define((v) => new LayerView(v, config3)),
    layerOrder.of(config3)
  ];
}
function drawSelection(config3 = {}) {
  return [
    selectionConfig.of(config3),
    cursorLayer,
    selectionLayer,
    hideNativeSelection,
    nativeSelectionHidden.of(true)
  ];
}
function configChanged(update) {
  return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
}
function setBlinkRate(state, dom) {
  dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
}
function dropCursor() {
  return [dropCursorPos, drawDropCursor];
}
function iterMatches(doc2, re, from2, to, f) {
  re.lastIndex = 0;
  for (let cursor2 = doc2.iterRange(from2, to), pos = from2, m; !cursor2.next().done; pos += cursor2.value.length) {
    if (!cursor2.lineBreak)
      while (m = re.exec(cursor2.value))
        f(pos + m.index, m);
  }
}
function matchRanges(view, maxLength) {
  let visible = view.visibleRanges;
  if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to)
    return visible;
  let result = [];
  for (let { from: from2, to } of visible) {
    from2 = Math.max(view.state.doc.lineAt(from2).from, from2 - maxLength);
    to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
    if (result.length && result[result.length - 1].to >= from2)
      result[result.length - 1].to = to;
    else
      result.push({ from: from2, to });
  }
  return result;
}
function supportsTabSize() {
  var _a2;
  if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
    let styles = document.body.style;
    _supportsTabSize = ((_a2 = styles.tabSize) !== null && _a2 !== void 0 ? _a2 : styles.MozTabSize) != null;
  }
  return _supportsTabSize || false;
}
function highlightSpecialChars(config3 = {}) {
  return [specialCharConfig.of(config3), specialCharPlugin()];
}
function specialCharPlugin() {
  return _plugin || (_plugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.decorations = Decoration.none;
      this.decorationCache = /* @__PURE__ */ Object.create(null);
      this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
      this.decorations = this.decorator.createDeco(view);
    }
    makeDecorator(conf) {
      return new MatchDecorator({
        regexp: conf.specialChars,
        decoration: (m, view, pos) => {
          let { doc: doc2 } = view.state;
          let code = codePointAt2(m[0], 0);
          if (code == 9) {
            let line = doc2.lineAt(pos);
            let size = view.state.tabSize, col = countColumn(line.text, size, pos - line.from);
            return Decoration.replace({
              widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));
        },
        boundary: conf.replaceTabs ? void 0 : /[^]/
      });
    }
    update(update) {
      let conf = update.state.facet(specialCharConfig);
      if (update.startState.facet(specialCharConfig) != conf) {
        this.decorator = this.makeDecorator(conf);
        this.decorations = this.decorator.createDeco(update.view);
      } else {
        this.decorations = this.decorator.updateDeco(update, this.decorations);
      }
    }
  }, {
    decorations: (v) => v.decorations
  }));
}
function placeholder$1(code) {
  if (code >= 32)
    return DefaultPlaceholder;
  if (code == 10)
    return "\u2424";
  return String.fromCharCode(9216 + code);
}
function highlightActiveLine() {
  return activeLineHighlighter;
}
function rectangleFor(state, a, b) {
  let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
  let ranges = [];
  if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
    let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
    for (let i = startLine; i <= endLine; i++) {
      let line = state.doc.line(i);
      if (line.length <= endOff)
        ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
    }
  } else {
    let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
    for (let i = startLine; i <= endLine; i++) {
      let line = state.doc.line(i);
      let start = findColumn(line.text, startCol, state.tabSize, true);
      if (start < 0) {
        ranges.push(EditorSelection.cursor(line.to));
      } else {
        let end = findColumn(line.text, endCol, state.tabSize);
        ranges.push(EditorSelection.range(line.from + start, line.from + end));
      }
    }
  }
  return ranges;
}
function absoluteColumn(view, x) {
  let ref = view.coordsAtPos(view.viewport.from);
  return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
}
function getPos(view, event) {
  let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  let line = view.state.doc.lineAt(offset), off = offset - line.from;
  let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : countColumn(line.text, view.state.tabSize, offset - line.from);
  return { line: line.number, col, off };
}
function rectangleSelectionStyle(view, event) {
  let start = getPos(view, event), startSel = view.state.selection;
  if (!start)
    return null;
  return {
    update(update) {
      if (update.docChanged) {
        let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
        let newLine = update.state.doc.lineAt(newStart);
        start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };
        startSel = startSel.map(update.changes);
      }
    },
    get(event2, _extend, multiple) {
      let cur2 = getPos(view, event2);
      if (!cur2)
        return startSel;
      let ranges = rectangleFor(view.state, start, cur2);
      if (!ranges.length)
        return startSel;
      if (multiple)
        return EditorSelection.create(ranges.concat(startSel.ranges));
      else
        return EditorSelection.create(ranges);
    }
  };
}
function rectangularSelection(options) {
  let filter2 = (options === null || options === void 0 ? void 0 : options.eventFilter) || ((e) => e.altKey && e.button == 0);
  return EditorView.mouseSelectionStyle.of((view, event) => filter2(event) ? rectangleSelectionStyle(view, event) : null);
}
function crosshairCursor(options = {}) {
  let [code, getter] = keys[options.key || "Alt"];
  let plugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.isDown = false;
    }
    set(isDown) {
      if (this.isDown != isDown) {
        this.isDown = isDown;
        this.view.update([]);
      }
    }
  }, {
    eventObservers: {
      keydown(e) {
        this.set(e.keyCode == code || getter(e));
      },
      keyup(e) {
        if (e.keyCode == code || !getter(e))
          this.set(false);
      },
      mousemove(e) {
        this.set(getter(e));
      }
    }
  });
  return [
    plugin,
    EditorView.contentAttributes.of((view) => {
      var _a2;
      return ((_a2 = view.plugin(plugin)) === null || _a2 === void 0 ? void 0 : _a2.isDown) ? showCrosshair : null;
    })
  ];
}
function windowSpace(view) {
  let docElt = view.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: docElt.clientHeight, right: docElt.clientWidth };
}
function setLeftStyle(elt2, value) {
  let current = parseInt(elt2.style.left, 10);
  if (isNaN(current) || Math.abs(value - current) > 1)
    elt2.style.left = value + "px";
}
function isInTooltip(tooltip, event) {
  let { left, right, top: top2, bottom } = tooltip.getBoundingClientRect(), arrow;
  if (arrow = tooltip.querySelector(".cm-tooltip-arrow")) {
    let arrowRect = arrow.getBoundingClientRect();
    top2 = Math.min(arrowRect.top, top2);
    bottom = Math.max(arrowRect.bottom, bottom);
  }
  return event.clientX >= left - tooltipMargin && event.clientX <= right + tooltipMargin && event.clientY >= top2 - tooltipMargin && event.clientY <= bottom + tooltipMargin;
}
function isOverRange(view, from2, to, x, y, margin) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;
  if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y)
    return false;
  let pos = view.posAtCoords({ x, y }, false);
  return pos >= from2 && pos <= to;
}
function hoverTooltip(source, options = {}) {
  let setHover = StateEffect.define();
  let hoverState = StateField.define({
    create() {
      return [];
    },
    update(value, tr) {
      if (value.length) {
        if (options.hideOnChange && (tr.docChanged || tr.selection))
          value = [];
        else if (options.hideOn)
          value = value.filter((v) => !options.hideOn(tr, v));
        if (tr.docChanged) {
          let mapped = [];
          for (let tooltip of value) {
            let newPos = tr.changes.mapPos(tooltip.pos, -1, MapMode.TrackDel);
            if (newPos != null) {
              let copy = Object.assign(/* @__PURE__ */ Object.create(null), tooltip);
              copy.pos = newPos;
              if (copy.end != null)
                copy.end = tr.changes.mapPos(copy.end);
              mapped.push(copy);
            }
          }
          value = mapped;
        }
      }
      for (let effect2 of tr.effects) {
        if (effect2.is(setHover))
          value = effect2.value;
        if (effect2.is(closeHoverTooltipEffect))
          value = [];
      }
      return value;
    },
    provide: (f) => showHoverTooltip.from(f)
  });
  return {
    active: hoverState,
    extension: [
      hoverState,
      ViewPlugin.define((view) => new HoverPlugin(
        view,
        source,
        hoverState,
        setHover,
        options.hoverTime || 300
        /* Hover.Time */
      )),
      showHoverTooltipHost
    ]
  };
}
function getTooltip(view, tooltip) {
  let plugin = view.plugin(tooltipPlugin);
  if (!plugin)
    return null;
  let found = plugin.manager.tooltips.indexOf(tooltip);
  return found < 0 ? null : plugin.manager.tooltipViews[found];
}
function getPanel(view, panel) {
  let plugin = view.plugin(panelPlugin);
  let index = plugin ? plugin.specs.indexOf(panel) : -1;
  return index > -1 ? plugin.panels[index] : null;
}
function rm(node) {
  let next = node.nextSibling;
  node.remove();
  return next;
}
function gutter(config3) {
  return [gutters(), activeGutters.of(__spreadValues(__spreadValues({}, defaults), config3))];
}
function gutters(config3) {
  let result = [
    gutterView
  ];
  if (config3 && config3.fixed === false)
    result.push(unfixGutters.of(true));
  return result;
}
function asArray2(val) {
  return Array.isArray(val) ? val : [val];
}
function advanceCursor(cursor2, collect, pos) {
  while (cursor2.value && cursor2.from <= pos) {
    if (cursor2.from == pos)
      collect.push(cursor2.value);
    cursor2.next();
  }
}
function sameMarkers(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].compare(b[i]))
      return false;
  return true;
}
function formatNumber2(view, number2) {
  return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
}
function lineNumbers(config3 = {}) {
  return [
    lineNumberConfig.of(config3),
    gutters(),
    lineNumberGutter
  ];
}
function maxLineNumber(lines) {
  let last4 = 9;
  while (last4 < lines)
    last4 = last4 * 10 + 9;
  return last4;
}
function highlightActiveLineGutter() {
  return activeLineGutterHighlighter;
}
var nav, doc, ie_edge, ie_upto10, ie_11up, ie2, gecko, chrome, webkit, safari, ios, browser, DOMSelectionState, preventScrollSupported, scratchRange, DOMPos, noChildren, ContentView, ChildCursor, MaxJoinLen, TextView, MarkView, WidgetView, WidgetBufferView, noAttrs, WidgetType, BlockType, Decoration, MarkDecoration, LineDecoration, PointDecoration, LineView, BlockWidgetView, BlockGapWidget, ContentBuilder, NullWidget, Direction, LTR, RTL, LowTypes, ArabicTypes, Brackets, BracketStack, BidiRE, BidiSpan, types, movedOver, clickAddsSelectionRange, dragMovesSelection$1, mouseSelectionStyle, exceptionSink, updateListener, inputHandler, focusChangeEffect, clipboardInputFilter, clipboardOutputFilter, perLineTextDirection, nativeSelectionHidden, scrollHandler, ScrollTarget, scrollIntoView, setEditContextFormatting, editable, nextPluginID, viewPlugin, ViewPlugin, PluginInstance, editorAttributes, contentAttributes, decorations, outerDecorations, atomicRanges, bidiIsolatedRanges, scrollMargins, styleModule, ChangedRange, ViewUpdate, DocView, DecorationComparator$1, LineBreakPlaceholder, DOMReader, DOMPoint, DOMChange, InputState, PendingKeys, EmacsyPendingKeys, modifierCodes, dragScrollMargin, MouseSelection, handlers, observers, brokenClipboardAPI, inside, BadMouseDetail, lastMouseDown, lastMouseDownCount, lastMouseDownTime, lastLinewiseCopy, isFocusChange, appliedFirefoxHack, wrappingWhiteSpace, heightChangeFlag, HeightOracle, MeasuredHeights, BlockInfo, QueryType, Epsilon, HeightMap, HeightMapBlock, HeightMapText, HeightMapGap, HeightMapBranch, relevantWidgetHeight, NodeBuilder, DecorationComparator2, LineGap, LineGapWidget, ViewState, Viewport, IdScaler, BigScaler, theme, darkTheme, baseThemeID, baseLightID, baseDarkID, lightDarkIDs, baseTheme$1, observeOptions, useCharData, DOMObserver, EditContextManager, EditorView, MaxBidiLine, BadMeasure, CachedOrder, currentPlatform, handleKeyEvents, keymap, Keymaps, storedPrefix, PrefixTimeout, currentKeyEvent, RectangleMarker, LayerView, layerOrder, selectionConfig, cursorLayer, selectionLayer, hideNativeSelection, setDropCursorPos, dropCursorPos, drawDropCursor, MatchDecorator, UnicodeRegexpSupport, Specials, Names, _supportsTabSize, specialCharConfig, _plugin, DefaultPlaceholder, SpecialCharWidget, TabWidget, lineDeco, activeLineHighlighter, MaxOff, keys, showCrosshair, Outside, TooltipViewManager, tooltipConfig, knownHeight, tooltipPlugin, baseTheme, noOffset, showTooltip, showHoverTooltip, HoverTooltipHost, showHoverTooltipHost, HoverPlugin, tooltipMargin, closeHoverTooltipEffect, panelConfig, panelPlugin, PanelGroup, showPanel, GutterMarker, gutterLineClass, gutterWidgetClass, defaults, activeGutters, unfixGutters, gutterView, UpdateContext, SingleGutterView, GutterElement, lineNumberMarkers, lineNumberWidgetMarker, lineNumberConfig, NumberMarker, lineNumberGutter, activeLineGutterMarker, activeLineGutterHighlighter;
var init_dist2 = __esm({
  "node_modules/@codemirror/view/dist/index.js"() {
    "use strict";
    init_dist();
    init_style_mod();
    init_w3c_keyname();
    init_crelt();
    nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
    doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
    ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
    ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
    ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
    ie2 = !!(ie_upto10 || ie_11up || ie_edge);
    gecko = !ie2 && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
    chrome = !ie2 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
    webkit = "webkitFontSmoothing" in doc.documentElement.style;
    safari = !ie2 && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
    ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
    browser = {
      mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
      windows: /* @__PURE__ */ /Win/.test(nav.platform),
      linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
      ie: ie2,
      ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
      gecko,
      gecko_version: gecko ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
      chrome: !!chrome,
      chrome_version: chrome ? +chrome[1] : 0,
      ios,
      android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
      webkit,
      webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
      safari,
      safari_version: safari ? +(/* @__PURE__ */ /\bVersion\/(\d+(\.\d+)?)/.exec(nav.userAgent) || [0, 0])[1] : 0,
      tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
    };
    DOMSelectionState = class {
      constructor() {
        this.anchorNode = null;
        this.anchorOffset = 0;
        this.focusNode = null;
        this.focusOffset = 0;
      }
      eq(domSel) {
        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
      }
      setRange(range) {
        let { anchorNode, focusNode } = range;
        this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
      }
      set(anchorNode, anchorOffset, focusNode, focusOffset) {
        this.anchorNode = anchorNode;
        this.anchorOffset = anchorOffset;
        this.focusNode = focusNode;
        this.focusOffset = focusOffset;
      }
    };
    preventScrollSupported = null;
    if (browser.safari && browser.safari_version >= 26)
      preventScrollSupported = false;
    DOMPos = class _DOMPos {
      constructor(node, offset, precise = true) {
        this.node = node;
        this.offset = offset;
        this.precise = precise;
      }
      static before(dom, precise) {
        return new _DOMPos(dom.parentNode, domIndex(dom), precise);
      }
      static after(dom, precise) {
        return new _DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
      }
    };
    noChildren = [];
    ContentView = class _ContentView {
      constructor() {
        this.parent = null;
        this.dom = null;
        this.flags = 2;
      }
      get overrideDOMText() {
        return null;
      }
      get posAtStart() {
        return this.parent ? this.parent.posBefore(this) : 0;
      }
      get posAtEnd() {
        return this.posAtStart + this.length;
      }
      posBefore(view) {
        let pos = this.posAtStart;
        for (let child of this.children) {
          if (child == view)
            return pos;
          pos += child.length + child.breakAfter;
        }
        throw new RangeError("Invalid child in posBefore");
      }
      posAfter(view) {
        return this.posBefore(view) + view.length;
      }
      sync(view, track) {
        if (this.flags & 2) {
          let parent = this.dom;
          let prev = null, next;
          for (let child of this.children) {
            if (child.flags & 7) {
              if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
                let contentView = _ContentView.get(next);
                if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                  child.reuseDOM(next);
              }
              child.sync(view, track);
              child.flags &= ~7;
            }
            next = prev ? prev.nextSibling : parent.firstChild;
            if (track && !track.written && track.node == parent && next != child.dom)
              track.written = true;
            if (child.dom.parentNode == parent) {
              while (next && next != child.dom)
                next = rm$1(next);
            } else {
              parent.insertBefore(child.dom, next);
            }
            prev = child.dom;
          }
          next = prev ? prev.nextSibling : parent.firstChild;
          if (next && track && track.node == parent)
            track.written = true;
          while (next)
            next = rm$1(next);
        } else if (this.flags & 1) {
          for (let child of this.children)
            if (child.flags & 7) {
              child.sync(view, track);
              child.flags &= ~7;
            }
        }
      }
      reuseDOM(_dom) {
      }
      localPosFromDOM(node, offset) {
        let after;
        if (node == this.dom) {
          after = this.dom.childNodes[offset];
        } else {
          let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
          for (; ; ) {
            let parent = node.parentNode;
            if (parent == this.dom)
              break;
            if (bias == 0 && parent.firstChild != parent.lastChild) {
              if (node == parent.firstChild)
                bias = -1;
              else
                bias = 1;
            }
            node = parent;
          }
          if (bias < 0)
            after = node;
          else
            after = node.nextSibling;
        }
        if (after == this.dom.firstChild)
          return 0;
        while (after && !_ContentView.get(after))
          after = after.nextSibling;
        if (!after)
          return this.length;
        for (let i = 0, pos = 0; ; i++) {
          let child = this.children[i];
          if (child.dom == after)
            return pos;
          pos += child.length + child.breakAfter;
        }
      }
      domBoundsAround(from2, to, offset = 0) {
        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
        for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
          let child = this.children[i], end = pos + child.length;
          if (pos < from2 && end > to)
            return child.domBoundsAround(from2, to, pos);
          if (end >= from2 && fromI == -1) {
            fromI = i;
            fromStart = pos;
          }
          if (pos > to && child.dom.parentNode == this.dom) {
            toI = i;
            toEnd = prevEnd;
            break;
          }
          prevEnd = end;
          pos = end + child.breakAfter;
        }
        return {
          from: fromStart,
          to: toEnd < 0 ? offset + this.length : toEnd,
          startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
          endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
        };
      }
      markDirty(andParent = false) {
        this.flags |= 2;
        this.markParentsDirty(andParent);
      }
      markParentsDirty(childList) {
        for (let parent = this.parent; parent; parent = parent.parent) {
          if (childList)
            parent.flags |= 2;
          if (parent.flags & 1)
            return;
          parent.flags |= 1;
          childList = false;
        }
      }
      setParent(parent) {
        if (this.parent != parent) {
          this.parent = parent;
          if (this.flags & 7)
            this.markParentsDirty(true);
        }
      }
      setDOM(dom) {
        if (this.dom == dom)
          return;
        if (this.dom)
          this.dom.cmView = null;
        this.dom = dom;
        dom.cmView = this;
      }
      get rootView() {
        for (let v = this; ; ) {
          let parent = v.parent;
          if (!parent)
            return v;
          v = parent;
        }
      }
      replaceChildren(from2, to, children = noChildren) {
        this.markDirty();
        for (let i = from2; i < to; i++) {
          let child = this.children[i];
          if (child.parent == this && children.indexOf(child) < 0)
            child.destroy();
        }
        if (children.length < 250)
          this.children.splice(from2, to - from2, ...children);
        else
          this.children = [].concat(this.children.slice(0, from2), children, this.children.slice(to));
        for (let i = 0; i < children.length; i++)
          children[i].setParent(this);
      }
      ignoreMutation(_rec) {
        return false;
      }
      ignoreEvent(_event) {
        return false;
      }
      childCursor(pos = this.length) {
        return new ChildCursor(this.children, pos, this.children.length);
      }
      childPos(pos, bias = 1) {
        return this.childCursor().findPos(pos, bias);
      }
      toString() {
        let name2 = this.constructor.name.replace("View", "");
        return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
      }
      static get(node) {
        return node.cmView;
      }
      get isEditable() {
        return true;
      }
      get isWidget() {
        return false;
      }
      get isHidden() {
        return false;
      }
      merge(from2, to, source, hasStart, openStart, openEnd) {
        return false;
      }
      become(other) {
        return false;
      }
      canReuseDOM(other) {
        return other.constructor == this.constructor && !((this.flags | other.flags) & 8);
      }
      // When this is a zero-length view with a side, this should return a
      // number <= 0 to indicate it is before its position, or a
      // number > 0 when after its position.
      getSide() {
        return 0;
      }
      destroy() {
        for (let child of this.children)
          if (child.parent == this)
            child.destroy();
        this.parent = null;
      }
    };
    ContentView.prototype.breakAfter = 0;
    ChildCursor = class {
      constructor(children, pos, i) {
        this.children = children;
        this.pos = pos;
        this.i = i;
        this.off = 0;
      }
      findPos(pos, bias = 1) {
        for (; ; ) {
          if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
            this.off = pos - this.pos;
            return this;
          }
          let next = this.children[--this.i];
          this.pos -= next.length + next.breakAfter;
        }
      }
    };
    MaxJoinLen = 256;
    TextView = class _TextView extends ContentView {
      constructor(text) {
        super();
        this.text = text;
      }
      get length() {
        return this.text.length;
      }
      createDOM(textDOM) {
        this.setDOM(textDOM || document.createTextNode(this.text));
      }
      sync(view, track) {
        if (!this.dom)
          this.createDOM();
        if (this.dom.nodeValue != this.text) {
          if (track && track.node == this.dom)
            track.written = true;
          this.dom.nodeValue = this.text;
        }
      }
      reuseDOM(dom) {
        if (dom.nodeType == 3)
          this.createDOM(dom);
      }
      merge(from2, to, source) {
        if (this.flags & 8 || source && (!(source instanceof _TextView) || this.length - (to - from2) + source.length > MaxJoinLen || source.flags & 8))
          return false;
        this.text = this.text.slice(0, from2) + (source ? source.text : "") + this.text.slice(to);
        this.markDirty();
        return true;
      }
      split(from2) {
        let result = new _TextView(this.text.slice(from2));
        this.text = this.text.slice(0, from2);
        this.markDirty();
        result.flags |= this.flags & 8;
        return result;
      }
      localPosFromDOM(node, offset) {
        return node == this.dom ? offset : offset ? this.text.length : 0;
      }
      domAtPos(pos) {
        return new DOMPos(this.dom, pos);
      }
      domBoundsAround(_from, _to, offset) {
        return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
      }
      coordsAt(pos, side) {
        return textCoords(this.dom, pos, side);
      }
    };
    MarkView = class _MarkView extends ContentView {
      constructor(mark, children = [], length = 0) {
        super();
        this.mark = mark;
        this.children = children;
        this.length = length;
        for (let ch of children)
          ch.setParent(this);
      }
      setAttrs(dom) {
        clearAttributes(dom);
        if (this.mark.class)
          dom.className = this.mark.class;
        if (this.mark.attrs)
          for (let name2 in this.mark.attrs)
            dom.setAttribute(name2, this.mark.attrs[name2]);
        return dom;
      }
      canReuseDOM(other) {
        return super.canReuseDOM(other) && !((this.flags | other.flags) & 8);
      }
      reuseDOM(node) {
        if (node.nodeName == this.mark.tagName.toUpperCase()) {
          this.setDOM(node);
          this.flags |= 4 | 2;
        }
      }
      sync(view, track) {
        if (!this.dom)
          this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
        else if (this.flags & 4)
          this.setAttrs(this.dom);
        super.sync(view, track);
      }
      merge(from2, to, source, _hasStart, openStart, openEnd) {
        if (source && (!(source instanceof _MarkView && source.mark.eq(this.mark)) || from2 && openStart <= 0 || to < this.length && openEnd <= 0))
          return false;
        mergeChildrenInto(this, from2, to, source ? source.children.slice() : [], openStart - 1, openEnd - 1);
        this.markDirty();
        return true;
      }
      split(from2) {
        let result = [], off = 0, detachFrom = -1, i = 0;
        for (let elt2 of this.children) {
          let end = off + elt2.length;
          if (end > from2)
            result.push(off < from2 ? elt2.split(from2 - off) : elt2);
          if (detachFrom < 0 && off >= from2)
            detachFrom = i;
          off = end;
          i++;
        }
        let length = this.length - from2;
        this.length = from2;
        if (detachFrom > -1) {
          this.children.length = detachFrom;
          this.markDirty();
        }
        return new _MarkView(this.mark, result, length);
      }
      domAtPos(pos) {
        return inlineDOMAtPos(this, pos);
      }
      coordsAt(pos, side) {
        return coordsInChildren(this, pos, side);
      }
    };
    WidgetView = class _WidgetView extends ContentView {
      static create(widget, length, side) {
        return new _WidgetView(widget, length, side);
      }
      constructor(widget, length, side) {
        super();
        this.widget = widget;
        this.length = length;
        this.side = side;
        this.prevWidget = null;
      }
      split(from2) {
        let result = _WidgetView.create(this.widget, this.length - from2, this.side);
        this.length -= from2;
        return result;
      }
      sync(view) {
        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
          if (this.dom && this.prevWidget)
            this.prevWidget.destroy(this.dom);
          this.prevWidget = null;
          this.setDOM(this.widget.toDOM(view));
          if (!this.widget.editable)
            this.dom.contentEditable = "false";
        }
      }
      getSide() {
        return this.side;
      }
      merge(from2, to, source, hasStart, openStart, openEnd) {
        if (source && (!(source instanceof _WidgetView) || !this.widget.compare(source.widget) || from2 > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
          return false;
        this.length = from2 + (source ? source.length : 0) + (this.length - to);
        return true;
      }
      become(other) {
        if (other instanceof _WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {
          if (!this.widget.compare(other.widget))
            this.markDirty(true);
          if (this.dom && !this.prevWidget)
            this.prevWidget = this.widget;
          this.widget = other.widget;
          this.length = other.length;
          return true;
        }
        return false;
      }
      ignoreMutation() {
        return true;
      }
      ignoreEvent(event) {
        return this.widget.ignoreEvent(event);
      }
      get overrideDOMText() {
        if (this.length == 0)
          return Text2.empty;
        let top2 = this;
        while (top2.parent)
          top2 = top2.parent;
        let { view } = top2, text = view && view.state.doc, start = this.posAtStart;
        return text ? text.slice(start, start + this.length) : Text2.empty;
      }
      domAtPos(pos) {
        return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
      }
      domBoundsAround() {
        return null;
      }
      coordsAt(pos, side) {
        let custom = this.widget.coordsAt(this.dom, pos, side);
        if (custom)
          return custom;
        let rects = this.dom.getClientRects(), rect = null;
        if (!rects.length)
          return null;
        let fromBack = this.side ? this.side < 0 : pos > 0;
        for (let i = fromBack ? rects.length - 1 : 0; ; i += fromBack ? -1 : 1) {
          rect = rects[i];
          if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
            break;
        }
        return flattenRect(rect, !fromBack);
      }
      get isEditable() {
        return false;
      }
      get isWidget() {
        return true;
      }
      get isHidden() {
        return this.widget.isHidden;
      }
      destroy() {
        super.destroy();
        if (this.dom)
          this.widget.destroy(this.dom);
      }
    };
    WidgetBufferView = class _WidgetBufferView extends ContentView {
      constructor(side) {
        super();
        this.side = side;
      }
      get length() {
        return 0;
      }
      merge() {
        return false;
      }
      become(other) {
        return other instanceof _WidgetBufferView && other.side == this.side;
      }
      split() {
        return new _WidgetBufferView(this.side);
      }
      sync() {
        if (!this.dom) {
          let dom = document.createElement("img");
          dom.className = "cm-widgetBuffer";
          dom.setAttribute("aria-hidden", "true");
          this.setDOM(dom);
        }
      }
      getSide() {
        return this.side;
      }
      domAtPos(pos) {
        return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);
      }
      localPosFromDOM() {
        return 0;
      }
      domBoundsAround() {
        return null;
      }
      coordsAt(pos) {
        return this.dom.getBoundingClientRect();
      }
      get overrideDOMText() {
        return Text2.empty;
      }
      get isHidden() {
        return true;
      }
    };
    TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
    noAttrs = /* @__PURE__ */ Object.create(null);
    WidgetType = class {
      /**
      Compare this instance to another instance of the same type.
      (TypeScript can't express this, but only instances of the same
      specific class will be passed to this method.) This is used to
      avoid redrawing widgets when they are replaced by a new
      decoration of the same type. The default implementation just
      returns `false`, which will cause new instances of the widget to
      always be redrawn.
      */
      eq(widget) {
        return false;
      }
      /**
      Update a DOM element created by a widget of the same type (but
      different, non-`eq` content) to reflect this widget. May return
      true to indicate that it could update, false to indicate it
      couldn't (in which case the widget will be redrawn). The default
      implementation just returns false.
      */
      updateDOM(dom, view) {
        return false;
      }
      /**
      @internal
      */
      compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
      }
      /**
      The estimated height this widget will have, to be used when
      estimating the height of content that hasn't been drawn. May
      return -1 to indicate you don't know. The default implementation
      returns -1.
      */
      get estimatedHeight() {
        return -1;
      }
      /**
      For inline widgets that are displayed inline (as opposed to
      `inline-block`) and introduce line breaks (through `<br>` tags
      or textual newlines), this must indicate the amount of line
      breaks they introduce. Defaults to 0.
      */
      get lineBreaks() {
        return 0;
      }
      /**
      Can be used to configure which kinds of events inside the widget
      should be ignored by the editor. The default is to ignore all
      events.
      */
      ignoreEvent(event) {
        return true;
      }
      /**
      Override the way screen coordinates for positions at/in the
      widget are found. `pos` will be the offset into the widget, and
      `side` the side of the position that is being queriedless than
      zero for before, greater than zero for after, and zero for
      directly at that position.
      */
      coordsAt(dom, pos, side) {
        return null;
      }
      /**
      @internal
      */
      get isHidden() {
        return false;
      }
      /**
      @internal
      */
      get editable() {
        return false;
      }
      /**
      This is called when the an instance of the widget is removed
      from the editor view.
      */
      destroy(dom) {
      }
    };
    BlockType = /* @__PURE__ */ function(BlockType2) {
      BlockType2[BlockType2["Text"] = 0] = "Text";
      BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
      BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
      BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
      return BlockType2;
    }(BlockType || (BlockType = {}));
    Decoration = class extends RangeValue {
      constructor(startSide, endSide, widget, spec) {
        super();
        this.startSide = startSide;
        this.endSide = endSide;
        this.widget = widget;
        this.spec = spec;
      }
      /**
      @internal
      */
      get heightRelevant() {
        return false;
      }
      /**
      Create a mark decoration, which influences the styling of the
      content in its range. Nested mark decorations will cause nested
      DOM elements to be created. Nesting order is determined by
      precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
      the higher-precedence decorations creating the inner DOM nodes.
      Such elements are split on line boundaries and on the boundaries
      of lower-precedence decorations.
      */
      static mark(spec) {
        return new MarkDecoration(spec);
      }
      /**
      Create a widget decoration, which displays a DOM element at the
      given position.
      */
      static widget(spec) {
        let side = Math.max(-1e4, Math.min(1e4, spec.side || 0)), block = !!spec.block;
        side += block && !spec.inlineOrder ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
        return new PointDecoration(spec, side, side, block, spec.widget || null, false);
      }
      /**
      Create a replace decoration which replaces the given range with
      a widget, or simply hides it.
      */
      static replace(spec) {
        let block = !!spec.block, startSide, endSide;
        if (spec.isBlockGap) {
          startSide = -5e8;
          endSide = 4e8;
        } else {
          let { start, end } = getInclusive(spec, block);
          startSide = (start ? block ? -3e8 : -1 : 5e8) - 1;
          endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
        }
        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
      }
      /**
      Create a line decoration, which can add DOM attributes to the
      line starting at the given position.
      */
      static line(spec) {
        return new LineDecoration(spec);
      }
      /**
      Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
      decorated range or ranges. If the ranges aren't already sorted,
      pass `true` for `sort` to make the library sort them for you.
      */
      static set(of2, sort = false) {
        return RangeSet.of(of2, sort);
      }
      /**
      @internal
      */
      hasHeight() {
        return this.widget ? this.widget.estimatedHeight > -1 : false;
      }
    };
    Decoration.none = RangeSet.empty;
    MarkDecoration = class _MarkDecoration extends Decoration {
      constructor(spec) {
        let { start, end } = getInclusive(spec);
        super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
        this.tagName = spec.tagName || "span";
        this.class = spec.class || "";
        this.attrs = spec.attributes || null;
      }
      eq(other) {
        var _a2, _b;
        return this == other || other instanceof _MarkDecoration && this.tagName == other.tagName && (this.class || ((_a2 = this.attrs) === null || _a2 === void 0 ? void 0 : _a2.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, "class");
      }
      range(from2, to = from2) {
        if (from2 >= to)
          throw new RangeError("Mark decorations may not be empty");
        return super.range(from2, to);
      }
    };
    MarkDecoration.prototype.point = false;
    LineDecoration = class _LineDecoration extends Decoration {
      constructor(spec) {
        super(-2e8, -2e8, null, spec);
      }
      eq(other) {
        return other instanceof _LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
      }
      range(from2, to = from2) {
        if (to != from2)
          throw new RangeError("Line decoration ranges must be zero-length");
        return super.range(from2, to);
      }
    };
    LineDecoration.prototype.mapMode = MapMode.TrackBefore;
    LineDecoration.prototype.point = true;
    PointDecoration = class _PointDecoration extends Decoration {
      constructor(spec, startSide, endSide, block, widget, isReplace) {
        super(startSide, endSide, widget, spec);
        this.block = block;
        this.isReplace = isReplace;
        this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
      }
      // Only relevant when this.block == true
      get type() {
        return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
      }
      get heightRelevant() {
        return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
      }
      eq(other) {
        return other instanceof _PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
      }
      range(from2, to = from2) {
        if (this.isReplace && (from2 > to || from2 == to && this.startSide > 0 && this.endSide <= 0))
          throw new RangeError("Invalid range for replacement decoration");
        if (!this.isReplace && to != from2)
          throw new RangeError("Widget decorations can only have zero-length ranges");
        return super.range(from2, to);
      }
    };
    PointDecoration.prototype.point = true;
    LineView = class _LineView extends ContentView {
      constructor() {
        super(...arguments);
        this.children = [];
        this.length = 0;
        this.prevAttrs = void 0;
        this.attrs = null;
        this.breakAfter = 0;
      }
      // Consumes source
      merge(from2, to, source, hasStart, openStart, openEnd) {
        if (source) {
          if (!(source instanceof _LineView))
            return false;
          if (!this.dom)
            source.transferDOM(this);
        }
        if (hasStart)
          this.setDeco(source ? source.attrs : null);
        mergeChildrenInto(this, from2, to, source ? source.children.slice() : [], openStart, openEnd);
        return true;
      }
      split(at) {
        let end = new _LineView();
        end.breakAfter = this.breakAfter;
        if (this.length == 0)
          return end;
        let { i, off } = this.childPos(at);
        if (off) {
          end.append(this.children[i].split(off), 0);
          this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
          i++;
        }
        for (let j = i; j < this.children.length; j++)
          end.append(this.children[j], 0);
        while (i > 0 && this.children[i - 1].length == 0)
          this.children[--i].destroy();
        this.children.length = i;
        this.markDirty();
        this.length = at;
        return end;
      }
      transferDOM(other) {
        if (!this.dom)
          return;
        this.markDirty();
        other.setDOM(this.dom);
        other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
        this.prevAttrs = void 0;
        this.dom = null;
      }
      setDeco(attrs) {
        if (!attrsEq(this.attrs, attrs)) {
          if (this.dom) {
            this.prevAttrs = this.attrs;
            this.markDirty();
          }
          this.attrs = attrs;
        }
      }
      append(child, openStart) {
        joinInlineInto(this, child, openStart);
      }
      // Only called when building a line view in ContentBuilder
      addLineDeco(deco) {
        let attrs = deco.spec.attributes, cls = deco.spec.class;
        if (attrs)
          this.attrs = combineAttrs(attrs, this.attrs || {});
        if (cls)
          this.attrs = combineAttrs({ class: cls }, this.attrs || {});
      }
      domAtPos(pos) {
        return inlineDOMAtPos(this, pos);
      }
      reuseDOM(node) {
        if (node.nodeName == "DIV") {
          this.setDOM(node);
          this.flags |= 4 | 2;
        }
      }
      sync(view, track) {
        var _a2;
        if (!this.dom) {
          this.setDOM(document.createElement("div"));
          this.dom.className = "cm-line";
          this.prevAttrs = this.attrs ? null : void 0;
        } else if (this.flags & 4) {
          clearAttributes(this.dom);
          this.dom.className = "cm-line";
          this.prevAttrs = this.attrs ? null : void 0;
        }
        if (this.prevAttrs !== void 0) {
          updateAttrs(this.dom, this.prevAttrs, this.attrs);
          this.dom.classList.add("cm-line");
          this.prevAttrs = void 0;
        }
        super.sync(view, track);
        let last4 = this.dom.lastChild;
        while (last4 && ContentView.get(last4) instanceof MarkView)
          last4 = last4.lastChild;
        if (!last4 || !this.length || last4.nodeName != "BR" && ((_a2 = ContentView.get(last4)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
          let hack = document.createElement("BR");
          hack.cmIgnore = true;
          this.dom.appendChild(hack);
        }
      }
      measureTextSize() {
        if (this.children.length == 0 || this.length > 20)
          return null;
        let totalWidth = 0, textHeight;
        for (let child of this.children) {
          if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
            return null;
          let rects = clientRectsFor(child.dom);
          if (rects.length != 1)
            return null;
          totalWidth += rects[0].width;
          textHeight = rects[0].height;
        }
        return !totalWidth ? null : {
          lineHeight: this.dom.getBoundingClientRect().height,
          charWidth: totalWidth / this.length,
          textHeight
        };
      }
      coordsAt(pos, side) {
        let rect = coordsInChildren(this, pos, side);
        if (!this.children.length && rect && this.parent) {
          let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
          if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
            let dist2 = (height - heightOracle.textHeight) / 2;
            return { top: rect.top + dist2, bottom: rect.bottom - dist2, left: rect.left, right: rect.left };
          }
        }
        return rect;
      }
      become(other) {
        return other instanceof _LineView && this.children.length == 0 && other.children.length == 0 && attrsEq(this.attrs, other.attrs) && this.breakAfter == other.breakAfter;
      }
      covers() {
        return true;
      }
      static find(docView, pos) {
        for (let i = 0, off = 0; i < docView.children.length; i++) {
          let block = docView.children[i], end = off + block.length;
          if (end >= pos) {
            if (block instanceof _LineView)
              return block;
            if (end > pos)
              break;
          }
          off = end + block.breakAfter;
        }
        return null;
      }
    };
    BlockWidgetView = class _BlockWidgetView extends ContentView {
      constructor(widget, length, deco) {
        super();
        this.widget = widget;
        this.length = length;
        this.deco = deco;
        this.breakAfter = 0;
        this.prevWidget = null;
      }
      merge(from2, to, source, _takeDeco, openStart, openEnd) {
        if (source && (!(source instanceof _BlockWidgetView) || !this.widget.compare(source.widget) || from2 > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
          return false;
        this.length = from2 + (source ? source.length : 0) + (this.length - to);
        return true;
      }
      domAtPos(pos) {
        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
      }
      split(at) {
        let len = this.length - at;
        this.length = at;
        let end = new _BlockWidgetView(this.widget, len, this.deco);
        end.breakAfter = this.breakAfter;
        return end;
      }
      get children() {
        return noChildren;
      }
      sync(view) {
        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
          if (this.dom && this.prevWidget)
            this.prevWidget.destroy(this.dom);
          this.prevWidget = null;
          this.setDOM(this.widget.toDOM(view));
          if (!this.widget.editable)
            this.dom.contentEditable = "false";
        }
      }
      get overrideDOMText() {
        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text2.empty;
      }
      domBoundsAround() {
        return null;
      }
      become(other) {
        if (other instanceof _BlockWidgetView && other.widget.constructor == this.widget.constructor) {
          if (!other.widget.compare(this.widget))
            this.markDirty(true);
          if (this.dom && !this.prevWidget)
            this.prevWidget = this.widget;
          this.widget = other.widget;
          this.length = other.length;
          this.deco = other.deco;
          this.breakAfter = other.breakAfter;
          return true;
        }
        return false;
      }
      ignoreMutation() {
        return true;
      }
      ignoreEvent(event) {
        return this.widget.ignoreEvent(event);
      }
      get isEditable() {
        return false;
      }
      get isWidget() {
        return true;
      }
      coordsAt(pos, side) {
        let custom = this.widget.coordsAt(this.dom, pos, side);
        if (custom)
          return custom;
        if (this.widget instanceof BlockGapWidget)
          return null;
        return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);
      }
      destroy() {
        super.destroy();
        if (this.dom)
          this.widget.destroy(this.dom);
      }
      covers(side) {
        let { startSide, endSide } = this.deco;
        return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
      }
    };
    BlockGapWidget = class extends WidgetType {
      constructor(height) {
        super();
        this.height = height;
      }
      toDOM() {
        let elt2 = document.createElement("div");
        elt2.className = "cm-gap";
        this.updateDOM(elt2);
        return elt2;
      }
      eq(other) {
        return other.height == this.height;
      }
      updateDOM(elt2) {
        elt2.style.height = this.height + "px";
        return true;
      }
      get editable() {
        return true;
      }
      get estimatedHeight() {
        return this.height;
      }
      ignoreEvent() {
        return false;
      }
    };
    ContentBuilder = class _ContentBuilder {
      constructor(doc2, pos, end, disallowBlockEffectsFor) {
        this.doc = doc2;
        this.pos = pos;
        this.end = end;
        this.disallowBlockEffectsFor = disallowBlockEffectsFor;
        this.content = [];
        this.curLine = null;
        this.breakAtStart = 0;
        this.pendingBuffer = 0;
        this.bufferMarks = [];
        this.atCursorPos = true;
        this.openStart = -1;
        this.openEnd = -1;
        this.text = "";
        this.textOff = 0;
        this.cursor = doc2.iter();
        this.skip = pos;
      }
      posCovered() {
        if (this.content.length == 0)
          return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
        let last4 = this.content[this.content.length - 1];
        return !(last4.breakAfter || last4 instanceof BlockWidgetView && last4.deco.endSide < 0);
      }
      getLine() {
        if (!this.curLine) {
          this.content.push(this.curLine = new LineView());
          this.atCursorPos = true;
        }
        return this.curLine;
      }
      flushBuffer(active = this.bufferMarks) {
        if (this.pendingBuffer) {
          this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
          this.pendingBuffer = 0;
        }
      }
      addBlockWidget(view) {
        this.flushBuffer();
        this.curLine = null;
        this.content.push(view);
      }
      finish(openEnd) {
        if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
          this.flushBuffer();
        else
          this.pendingBuffer = 0;
        if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView))
          this.getLine();
      }
      buildText(length, active, openStart) {
        while (length > 0) {
          if (this.textOff == this.text.length) {
            let { value, lineBreak, done } = this.cursor.next(this.skip);
            this.skip = 0;
            if (done)
              throw new Error("Ran out of text content when drawing inline views");
            if (lineBreak) {
              if (!this.posCovered())
                this.getLine();
              if (this.content.length)
                this.content[this.content.length - 1].breakAfter = 1;
              else
                this.breakAtStart = 1;
              this.flushBuffer();
              this.curLine = null;
              this.atCursorPos = true;
              length--;
              continue;
            } else {
              this.text = value;
              this.textOff = 0;
            }
          }
          let remaining = Math.min(this.text.length - this.textOff, length);
          let take2 = Math.min(
            remaining,
            512
            /* T.Chunk */
          );
          this.flushBuffer(active.slice(active.length - openStart));
          this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take2)), active), openStart);
          this.atCursorPos = true;
          this.textOff += take2;
          length -= take2;
          openStart = remaining <= take2 ? 0 : active.length;
        }
      }
      span(from2, to, active, openStart) {
        this.buildText(to - from2, active, openStart);
        this.pos = to;
        if (this.openStart < 0)
          this.openStart = openStart;
      }
      point(from2, to, deco, active, openStart, index) {
        if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
          if (deco.block)
            throw new RangeError("Block decorations may not be specified via plugins");
          if (to > this.doc.lineAt(this.pos).to)
            throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
        }
        let len = to - from2;
        if (deco instanceof PointDecoration) {
          if (deco.block) {
            if (deco.startSide > 0 && !this.posCovered())
              this.getLine();
            this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco));
          } else {
            let view = WidgetView.create(deco.widget || NullWidget.inline, len, len ? 0 : deco.startSide);
            let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from2 < to || deco.startSide > 0);
            let cursorAfter = !view.isEditable && (from2 < to || openStart > active.length || deco.startSide <= 0);
            let line = this.getLine();
            if (this.pendingBuffer == 2 && !cursorBefore && !view.isEditable)
              this.pendingBuffer = 0;
            this.flushBuffer(active);
            if (cursorBefore) {
              line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
              openStart = active.length + Math.max(0, openStart - active.length);
            }
            line.append(wrapMarks(view, active), openStart);
            this.atCursorPos = cursorAfter;
            this.pendingBuffer = !cursorAfter ? 0 : from2 < to || openStart > active.length ? 1 : 2;
            if (this.pendingBuffer)
              this.bufferMarks = active.slice();
          }
        } else if (this.doc.lineAt(this.pos).from == this.pos) {
          this.getLine().addLineDeco(deco);
        }
        if (len) {
          if (this.textOff + len <= this.text.length) {
            this.textOff += len;
          } else {
            this.skip += len - (this.text.length - this.textOff);
            this.text = "";
            this.textOff = 0;
          }
          this.pos = to;
        }
        if (this.openStart < 0)
          this.openStart = openStart;
      }
      static build(text, from2, to, decorations2, dynamicDecorationMap) {
        let builder = new _ContentBuilder(text, from2, to, dynamicDecorationMap);
        builder.openEnd = RangeSet.spans(decorations2, from2, to, builder);
        if (builder.openStart < 0)
          builder.openStart = builder.openEnd;
        builder.finish(builder.openEnd);
        return builder;
      }
    };
    NullWidget = class extends WidgetType {
      constructor(tag) {
        super();
        this.tag = tag;
      }
      eq(other) {
        return other.tag == this.tag;
      }
      toDOM() {
        return document.createElement(this.tag);
      }
      updateDOM(elt2) {
        return elt2.nodeName.toLowerCase() == this.tag;
      }
      get isHidden() {
        return true;
      }
    };
    NullWidget.inline = /* @__PURE__ */ new NullWidget("span");
    NullWidget.block = /* @__PURE__ */ new NullWidget("div");
    Direction = /* @__PURE__ */ function(Direction2) {
      Direction2[Direction2["LTR"] = 0] = "LTR";
      Direction2[Direction2["RTL"] = 1] = "RTL";
      return Direction2;
    }(Direction || (Direction = {}));
    LTR = Direction.LTR;
    RTL = Direction.RTL;
    LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
    ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
    Brackets = /* @__PURE__ */ Object.create(null);
    BracketStack = [];
    for (let p of ["()", "[]", "{}"]) {
      let l = /* @__PURE__ */ p.charCodeAt(0), r = /* @__PURE__ */ p.charCodeAt(1);
      Brackets[l] = r;
      Brackets[r] = -l;
    }
    BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
    BidiSpan = class {
      /**
      The direction of this span.
      */
      get dir() {
        return this.level % 2 ? RTL : LTR;
      }
      /**
      @internal
      */
      constructor(from2, to, level) {
        this.from = from2;
        this.to = to;
        this.level = level;
      }
      /**
      @internal
      */
      side(end, dir) {
        return this.dir == dir == end ? this.to : this.from;
      }
      /**
      @internal
      */
      forward(forward, dir) {
        return forward == (this.dir == dir);
      }
      /**
      @internal
      */
      static find(order, index, level, assoc) {
        let maybe = -1;
        for (let i = 0; i < order.length; i++) {
          let span = order[i];
          if (span.from <= index && span.to >= index) {
            if (span.level == level)
              return i;
            if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level))
              maybe = i;
          }
        }
        if (maybe < 0)
          throw new RangeError("Index out of range");
        return maybe;
      }
    };
    types = [];
    movedOver = "";
    clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
    dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
    mouseSelectionStyle = /* @__PURE__ */ Facet.define();
    exceptionSink = /* @__PURE__ */ Facet.define();
    updateListener = /* @__PURE__ */ Facet.define();
    inputHandler = /* @__PURE__ */ Facet.define();
    focusChangeEffect = /* @__PURE__ */ Facet.define();
    clipboardInputFilter = /* @__PURE__ */ Facet.define();
    clipboardOutputFilter = /* @__PURE__ */ Facet.define();
    perLineTextDirection = /* @__PURE__ */ Facet.define({
      combine: (values2) => values2.some((x) => x)
    });
    nativeSelectionHidden = /* @__PURE__ */ Facet.define({
      combine: (values2) => values2.some((x) => x)
    });
    scrollHandler = /* @__PURE__ */ Facet.define();
    ScrollTarget = class _ScrollTarget {
      constructor(range, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5, isSnapshot = false) {
        this.range = range;
        this.y = y;
        this.x = x;
        this.yMargin = yMargin;
        this.xMargin = xMargin;
        this.isSnapshot = isSnapshot;
      }
      map(changes) {
        return changes.empty ? this : new _ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
      }
      clip(state) {
        return this.range.to <= state.doc.length ? this : new _ScrollTarget(EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
      }
    };
    scrollIntoView = /* @__PURE__ */ StateEffect.define({ map: (t2, ch) => t2.map(ch) });
    setEditContextFormatting = /* @__PURE__ */ StateEffect.define();
    editable = /* @__PURE__ */ Facet.define({ combine: (values2) => values2.length ? values2[0] : true });
    nextPluginID = 0;
    viewPlugin = /* @__PURE__ */ Facet.define({
      combine(plugins) {
        return plugins.filter((p, i) => {
          for (let j = 0; j < i; j++)
            if (plugins[j].plugin == p.plugin)
              return false;
          return true;
        });
      }
    });
    ViewPlugin = class _ViewPlugin {
      constructor(id2, create, domEventHandlers, domEventObservers, buildExtensions) {
        this.id = id2;
        this.create = create;
        this.domEventHandlers = domEventHandlers;
        this.domEventObservers = domEventObservers;
        this.baseExtensions = buildExtensions(this);
        this.extension = this.baseExtensions.concat(viewPlugin.of({ plugin: this, arg: void 0 }));
      }
      /**
      Create an extension for this plugin with the given argument.
      */
      of(arg) {
        return this.baseExtensions.concat(viewPlugin.of({ plugin: this, arg }));
      }
      /**
      Define a plugin from a constructor function that creates the
      plugin's value, given an editor view.
      */
      static define(create, spec) {
        const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
        return new _ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, (plugin) => {
          let ext = [];
          if (deco)
            ext.push(decorations.of((view) => {
              let pluginInst = view.plugin(plugin);
              return pluginInst ? deco(pluginInst) : Decoration.none;
            }));
          if (provide)
            ext.push(provide(plugin));
          return ext;
        });
      }
      /**
      Create a plugin for a class whose constructor takes a single
      editor view as argument.
      */
      static fromClass(cls, spec) {
        return _ViewPlugin.define((view, arg) => new cls(view, arg), spec);
      }
    };
    PluginInstance = class {
      constructor(spec) {
        this.spec = spec;
        this.mustUpdate = null;
        this.value = null;
      }
      get plugin() {
        return this.spec && this.spec.plugin;
      }
      update(view) {
        if (!this.value) {
          if (this.spec) {
            try {
              this.value = this.spec.plugin.create(view, this.spec.arg);
            } catch (e) {
              logException(view.state, e, "CodeMirror plugin crashed");
              this.deactivate();
            }
          }
        } else if (this.mustUpdate) {
          let update = this.mustUpdate;
          this.mustUpdate = null;
          if (this.value.update) {
            try {
              this.value.update(update);
            } catch (e) {
              logException(update.state, e, "CodeMirror plugin crashed");
              if (this.value.destroy)
                try {
                  this.value.destroy();
                } catch (_) {
                }
              this.deactivate();
            }
          }
        }
        return this;
      }
      destroy(view) {
        var _a2;
        if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
          try {
            this.value.destroy();
          } catch (e) {
            logException(view.state, e, "CodeMirror plugin crashed");
          }
        }
      }
      deactivate() {
        this.spec = this.value = null;
      }
    };
    editorAttributes = /* @__PURE__ */ Facet.define();
    contentAttributes = /* @__PURE__ */ Facet.define();
    decorations = /* @__PURE__ */ Facet.define();
    outerDecorations = /* @__PURE__ */ Facet.define();
    atomicRanges = /* @__PURE__ */ Facet.define();
    bidiIsolatedRanges = /* @__PURE__ */ Facet.define();
    scrollMargins = /* @__PURE__ */ Facet.define();
    styleModule = /* @__PURE__ */ Facet.define();
    ChangedRange = class _ChangedRange {
      constructor(fromA, toA, fromB, toB) {
        this.fromA = fromA;
        this.toA = toA;
        this.fromB = fromB;
        this.toB = toB;
      }
      join(other) {
        return new _ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
      }
      addToSet(set) {
        let i = set.length, me = this;
        for (; i > 0; i--) {
          let range = set[i - 1];
          if (range.fromA > me.toA)
            continue;
          if (range.toA < me.fromA)
            break;
          me = me.join(range);
          set.splice(i - 1, 1);
        }
        set.splice(i, 0, me);
        return set;
      }
      static extendWithRanges(diff, ranges) {
        if (ranges.length == 0)
          return diff;
        let result = [];
        for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
          let next = dI == diff.length ? null : diff[dI], off = posA - posB;
          let end = next ? next.fromB : 1e9;
          while (rI < ranges.length && ranges[rI] < end) {
            let from2 = ranges[rI], to = ranges[rI + 1];
            let fromB = Math.max(posB, from2), toB = Math.min(end, to);
            if (fromB <= toB)
              new _ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
            if (to > end)
              break;
            else
              rI += 2;
          }
          if (!next)
            return result;
          new _ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
          posA = next.toA;
          posB = next.toB;
        }
      }
    };
    ViewUpdate = class _ViewUpdate {
      constructor(view, state, transactions) {
        this.view = view;
        this.state = state;
        this.transactions = transactions;
        this.flags = 0;
        this.startState = view.state;
        this.changes = ChangeSet.empty(this.startState.doc.length);
        for (let tr of transactions)
          this.changes = this.changes.compose(tr.changes);
        let changedRanges = [];
        this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
        this.changedRanges = changedRanges;
      }
      /**
      @internal
      */
      static create(view, state, transactions) {
        return new _ViewUpdate(view, state, transactions);
      }
      /**
      Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
      [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
      update.
      */
      get viewportChanged() {
        return (this.flags & 4) > 0;
      }
      /**
      Returns true when
      [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
      and the viewport change is not just the result of mapping it in
      response to document changes.
      */
      get viewportMoved() {
        return (this.flags & 8) > 0;
      }
      /**
      Indicates whether the height of a block element in the editor
      changed in this update.
      */
      get heightChanged() {
        return (this.flags & 2) > 0;
      }
      /**
      Returns true when the document was modified or the size of the
      editor, or elements within the editor, changed.
      */
      get geometryChanged() {
        return this.docChanged || (this.flags & (16 | 2)) > 0;
      }
      /**
      True when this update indicates a focus change.
      */
      get focusChanged() {
        return (this.flags & 1) > 0;
      }
      /**
      Whether the document changed in this update.
      */
      get docChanged() {
        return !this.changes.empty;
      }
      /**
      Whether the selection was explicitly set in this update.
      */
      get selectionSet() {
        return this.transactions.some((tr) => tr.selection);
      }
      /**
      @internal
      */
      get empty() {
        return this.flags == 0 && this.transactions.length == 0;
      }
    };
    DocView = class extends ContentView {
      get length() {
        return this.view.state.doc.length;
      }
      constructor(view) {
        super();
        this.view = view;
        this.decorations = [];
        this.dynamicDecorationMap = [false];
        this.domChanged = null;
        this.hasComposition = null;
        this.markedForComposition = /* @__PURE__ */ new Set();
        this.editContextFormatting = Decoration.none;
        this.lastCompositionAfterCursor = false;
        this.minWidth = 0;
        this.minWidthFrom = 0;
        this.minWidthTo = 0;
        this.impreciseAnchor = null;
        this.impreciseHead = null;
        this.forceSelection = false;
        this.lastUpdate = Date.now();
        this.setDOM(view.contentDOM);
        this.children = [new LineView()];
        this.children[0].setParent(this);
        this.updateDeco();
        this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
      }
      // Update the document view to a given state.
      update(update) {
        var _a2;
        let changedRanges = update.changedRanges;
        if (this.minWidth > 0 && changedRanges.length) {
          if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
            this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
          } else {
            this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
            this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
          }
        }
        this.updateEditContextFormatting(update);
        let readCompositionAt = -1;
        if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
          if ((_a2 = this.domChanged) === null || _a2 === void 0 ? void 0 : _a2.newSel)
            readCompositionAt = this.domChanged.newSel.head;
          else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
            readCompositionAt = update.state.selection.main.head;
        }
        let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
        this.domChanged = null;
        if (this.hasComposition) {
          this.markedForComposition.clear();
          let { from: from2, to } = this.hasComposition;
          changedRanges = new ChangedRange(from2, to, update.changes.mapPos(from2, -1), update.changes.mapPos(to, 1)).addToSet(changedRanges.slice());
        }
        this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
        if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines)
          this.forceSelection = true;
        let prevDeco = this.decorations, deco = this.updateDeco();
        let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
        if (!(this.flags & 7) && changedRanges.length == 0) {
          return false;
        } else {
          this.updateInner(changedRanges, update.startState.doc.length, composition);
          if (update.transactions.length)
            this.lastUpdate = Date.now();
          return true;
        }
      }
      // Used by update and the constructor do perform the actual DOM
      // update
      updateInner(changes, oldLength, composition) {
        this.view.viewState.mustMeasureContent = true;
        this.updateChildren(changes, oldLength, composition);
        let { observer } = this.view;
        observer.ignore(() => {
          this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
          this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
          let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
          this.sync(this.view, track);
          this.flags &= ~7;
          if (track && (track.written || observer.selectionRange.focusNode != track.node))
            this.forceSelection = true;
          this.dom.style.height = "";
        });
        this.markedForComposition.forEach(
          (cView) => cView.flags &= ~8
          /* ViewFlag.Composition */
        );
        let gaps = [];
        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
          for (let child of this.children)
            if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
              gaps.push(child.dom);
        }
        observer.updateGaps(gaps);
      }
      updateChildren(changes, oldLength, composition) {
        let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
        let cursor2 = this.childCursor(oldLength);
        for (let i = ranges.length - 1; ; i--) {
          let next = i >= 0 ? ranges[i] : null;
          if (!next)
            break;
          let { fromA, toA, fromB, toB } = next, content2, breakAtStart, openStart, openEnd;
          if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
            let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
            let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
            breakAtStart = before.breakAtStart;
            openStart = before.openStart;
            openEnd = after.openEnd;
            let compLine = this.compositionView(composition);
            if (after.breakAtStart) {
              compLine.breakAfter = 1;
            } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
              compLine.breakAfter = after.content[0].breakAfter;
              after.content.shift();
            }
            if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
              before.content.pop();
            }
            content2 = before.content.concat(compLine).concat(after.content);
          } else {
            ({ content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
          }
          let { i: toI, off: toOff } = cursor2.findPos(toA, 1);
          let { i: fromI, off: fromOff } = cursor2.findPos(fromA, -1);
          replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
        }
        if (composition)
          this.fixCompositionDOM(composition);
      }
      updateEditContextFormatting(update) {
        this.editContextFormatting = this.editContextFormatting.map(update.changes);
        for (let tr of update.transactions)
          for (let effect2 of tr.effects)
            if (effect2.is(setEditContextFormatting)) {
              this.editContextFormatting = effect2.value;
            }
      }
      compositionView(composition) {
        let cur2 = new TextView(composition.text.nodeValue);
        cur2.flags |= 8;
        for (let { deco } of composition.marks)
          cur2 = new MarkView(deco, [cur2], cur2.length);
        let line = new LineView();
        line.append(cur2, 0);
        return line;
      }
      fixCompositionDOM(composition) {
        let fix = (dom, cView2) => {
          cView2.flags |= 8 | (cView2.children.some(
            (c) => c.flags & 7
            /* ViewFlag.Dirty */
          ) ? 1 : 0);
          this.markedForComposition.add(cView2);
          let prev = ContentView.get(dom);
          if (prev && prev != cView2)
            prev.dom = null;
          cView2.setDOM(dom);
        };
        let pos = this.childPos(composition.range.fromB, 1);
        let cView = this.children[pos.i];
        fix(composition.line, cView);
        for (let i = composition.marks.length - 1; i >= -1; i--) {
          pos = cView.childPos(pos.off, 1);
          cView = cView.children[pos.i];
          fix(i >= 0 ? composition.marks[i].node : composition.text, cView);
        }
      }
      // Sync the DOM selection to this.state.selection
      updateSelection(mustRead = false, fromPointer = false) {
        if (mustRead || !this.view.observer.selectionRange.focusNode)
          this.view.observer.readSelectionRange();
        let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
        let selectionNotFocus = !focused && !(this.view.state.facet(editable) || this.dom.tabIndex > -1) && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
        if (!(focused || fromPointer || selectionNotFocus))
          return;
        let force = this.forceSelection;
        this.forceSelection = false;
        let main = this.view.state.selection.main;
        let anchor = this.moveToLine(this.domAtPos(main.anchor));
        let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));
        if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
          let dummy = document.createTextNode("");
          this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
          anchor = head = new DOMPos(dummy, 0);
          force = true;
        }
        let domSel = this.view.observer.selectionRange;
        if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {
          this.view.observer.ignore(() => {
            if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
              this.dom.blur();
              this.dom.focus({ preventScroll: true });
            }
            let rawSel = getSelection(this.view.root);
            if (!rawSel) ;
            else if (main.empty) {
              if (browser.gecko) {
                let nextTo = nextToUneditable(anchor.node, anchor.offset);
                if (nextTo && nextTo != (1 | 2)) {
                  let text = (nextTo == 1 ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
                  if (text)
                    anchor = new DOMPos(text.node, text.offset);
                }
              }
              rawSel.collapse(anchor.node, anchor.offset);
              if (main.bidiLevel != null && rawSel.caretBidiLevel !== void 0)
                rawSel.caretBidiLevel = main.bidiLevel;
            } else if (rawSel.extend) {
              rawSel.collapse(anchor.node, anchor.offset);
              try {
                rawSel.extend(head.node, head.offset);
              } catch (_) {
              }
            } else {
              let range = document.createRange();
              if (main.anchor > main.head)
                [anchor, head] = [head, anchor];
              range.setEnd(head.node, head.offset);
              range.setStart(anchor.node, anchor.offset);
              rawSel.removeAllRanges();
              rawSel.addRange(range);
            }
            if (selectionNotFocus && this.view.root.activeElement == this.dom) {
              this.dom.blur();
              if (activeElt)
                activeElt.focus();
            }
          });
          this.view.observer.setSelectionRange(anchor, head);
        }
        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
      }
      // If a zero-length widget is inserted next to the cursor during
      // composition, avoid moving it across it and disrupting the
      // composition.
      suppressWidgetCursorChange(sel, cursor2) {
        return this.hasComposition && cursor2.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor2.head;
      }
      enforceCursorAssoc() {
        if (this.hasComposition)
          return;
        let { view } = this, cursor2 = view.state.selection.main;
        let sel = getSelection(view.root);
        let { anchorNode, anchorOffset } = view.observer.selectionRange;
        if (!sel || !cursor2.empty || !cursor2.assoc || !sel.modify)
          return;
        let line = LineView.find(this, cursor2.head);
        if (!line)
          return;
        let lineStart = line.posAtStart;
        if (cursor2.head == lineStart || cursor2.head == lineStart + line.length)
          return;
        let before = this.coordsAt(cursor2.head, -1), after = this.coordsAt(cursor2.head, 1);
        if (!before || !after || before.bottom > after.top)
          return;
        let dom = this.domAtPos(cursor2.head + cursor2.assoc);
        sel.collapse(dom.node, dom.offset);
        sel.modify("move", cursor2.assoc < 0 ? "forward" : "backward", "lineboundary");
        view.observer.readSelectionRange();
        let newRange = view.observer.selectionRange;
        if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor2.from)
          sel.collapse(anchorNode, anchorOffset);
      }
      // If a position is in/near a block widget, move it to a nearby text
      // line, since we don't want the cursor inside a block widget.
      moveToLine(pos) {
        let dom = this.dom, newPos;
        if (pos.node != dom)
          return pos;
        for (let i = pos.offset; !newPos && i < dom.childNodes.length; i++) {
          let view = ContentView.get(dom.childNodes[i]);
          if (view instanceof LineView)
            newPos = view.domAtPos(0);
        }
        for (let i = pos.offset - 1; !newPos && i >= 0; i--) {
          let view = ContentView.get(dom.childNodes[i]);
          if (view instanceof LineView)
            newPos = view.domAtPos(view.length);
        }
        return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
      }
      nearest(dom) {
        for (let cur2 = dom; cur2; ) {
          let domView = ContentView.get(cur2);
          if (domView && domView.rootView == this)
            return domView;
          cur2 = cur2.parentNode;
        }
        return null;
      }
      posFromDOM(node, offset) {
        let view = this.nearest(node);
        if (!view)
          throw new RangeError("Trying to find position for a DOM position outside of the document");
        return view.localPosFromDOM(node, offset) + view.posAtStart;
      }
      domAtPos(pos) {
        let { i, off } = this.childCursor().findPos(pos, -1);
        for (; i < this.children.length - 1; ) {
          let child = this.children[i];
          if (off < child.length || child instanceof LineView)
            break;
          i++;
          off = 0;
        }
        return this.children[i].domAtPos(off);
      }
      coordsAt(pos, side) {
        let best = null, bestPos = 0;
        for (let off = this.length, i = this.children.length - 1; i >= 0; i--) {
          let child = this.children[i], end = off - child.breakAfter, start = end - child.length;
          if (end < pos)
            break;
          if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
            best = child;
            bestPos = start;
          } else if (best && start == pos && end == pos && child instanceof BlockWidgetView && Math.abs(side) < 2) {
            if (child.deco.startSide < 0)
              break;
            else if (i)
              best = null;
          }
          off = start;
        }
        return best ? best.coordsAt(pos - bestPos, side) : null;
      }
      coordsForChar(pos) {
        let { i, off } = this.childPos(pos, 1), child = this.children[i];
        if (!(child instanceof LineView))
          return null;
        while (child.children.length) {
          let { i: i2, off: childOff } = child.childPos(off, 1);
          for (; ; i2++) {
            if (i2 == child.children.length)
              return null;
            if ((child = child.children[i2]).length)
              break;
          }
          off = childOff;
        }
        if (!(child instanceof TextView))
          return null;
        let end = findClusterBreak2(child.text, off);
        if (end == off)
          return null;
        let rects = textRange(child.dom, off, end).getClientRects();
        for (let i2 = 0; i2 < rects.length; i2++) {
          let rect = rects[i2];
          if (i2 == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
            return rect;
        }
        return null;
      }
      measureVisibleLineHeights(viewport) {
        let result = [], { from: from2, to } = viewport;
        let contentWidth = this.view.contentDOM.clientWidth;
        let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
        let widest = -1, ltr = this.view.textDirection == Direction.LTR;
        for (let pos = 0, i = 0; i < this.children.length; i++) {
          let child = this.children[i], end = pos + child.length;
          if (end > to)
            break;
          if (pos >= from2) {
            let childRect = child.dom.getBoundingClientRect();
            result.push(childRect.height);
            if (isWider) {
              let last4 = child.dom.lastChild;
              let rects = last4 ? clientRectsFor(last4) : [];
              if (rects.length) {
                let rect = rects[rects.length - 1];
                let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
                if (width > widest) {
                  widest = width;
                  this.minWidth = contentWidth;
                  this.minWidthFrom = pos;
                  this.minWidthTo = end;
                }
              }
            }
          }
          pos = end + child.breakAfter;
        }
        return result;
      }
      textDirectionAt(pos) {
        let { i } = this.childPos(pos, 1);
        return getComputedStyle(this.children[i].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
      }
      measureTextSize() {
        for (let child of this.children) {
          if (child instanceof LineView) {
            let measure = child.measureTextSize();
            if (measure)
              return measure;
          }
        }
        let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
        dummy.className = "cm-line";
        dummy.style.width = "99999px";
        dummy.style.position = "absolute";
        dummy.textContent = "abc def ghi jkl mno pqr stu";
        this.view.observer.ignore(() => {
          this.dom.appendChild(dummy);
          let rect = clientRectsFor(dummy.firstChild)[0];
          lineHeight = dummy.getBoundingClientRect().height;
          charWidth = rect ? rect.width / 27 : 7;
          textHeight = rect ? rect.height : lineHeight;
          dummy.remove();
        });
        return { lineHeight, charWidth, textHeight };
      }
      childCursor(pos = this.length) {
        let i = this.children.length;
        if (i)
          pos -= this.children[--i].length;
        return new ChildCursor(this.children, pos, i);
      }
      computeBlockGapDeco() {
        let deco = [], vs = this.view.viewState;
        for (let pos = 0, i = 0; ; i++) {
          let next = i == vs.viewports.length ? null : vs.viewports[i];
          let end = next ? next.from - 1 : this.length;
          if (end > pos) {
            let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
            deco.push(Decoration.replace({
              widget: new BlockGapWidget(height),
              block: true,
              inclusive: true,
              isBlockGap: true
            }).range(pos, end));
          }
          if (!next)
            break;
          pos = next.to + 1;
        }
        return Decoration.set(deco);
      }
      updateDeco() {
        let i = 1;
        let allDeco = this.view.state.facet(decorations).map((d) => {
          let dynamic = this.dynamicDecorationMap[i++] = typeof d == "function";
          return dynamic ? d(this.view) : d;
        });
        let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d, i2) => {
          let dynamic = typeof d == "function";
          if (dynamic)
            dynamicOuter = true;
          return dynamic ? d(this.view) : d;
        });
        if (outerDeco.length) {
          this.dynamicDecorationMap[i++] = dynamicOuter;
          allDeco.push(RangeSet.join(outerDeco));
        }
        this.decorations = [
          this.editContextFormatting,
          ...allDeco,
          this.computeBlockGapDeco(),
          this.view.viewState.lineGapDeco
        ];
        while (i < this.decorations.length)
          this.dynamicDecorationMap[i++] = false;
        return this.decorations;
      }
      scrollIntoView(target) {
        if (target.isSnapshot) {
          let ref = this.view.viewState.lineBlockAt(target.range.head);
          this.view.scrollDOM.scrollTop = ref.top - target.yMargin;
          this.view.scrollDOM.scrollLeft = target.xMargin;
          return;
        }
        for (let handler of this.view.state.facet(scrollHandler)) {
          try {
            if (handler(this.view, target.range, target))
              return true;
          } catch (e) {
            logException(this.view.state, e, "scroll handler");
          }
        }
        let { range } = target;
        let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
        if (!rect)
          return;
        if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
          rect = {
            left: Math.min(rect.left, other.left),
            top: Math.min(rect.top, other.top),
            right: Math.max(rect.right, other.right),
            bottom: Math.max(rect.bottom, other.bottom)
          };
        let margins = getScrollMargins(this.view);
        let targetRect = {
          left: rect.left - margins.left,
          top: rect.top - margins.top,
          right: rect.right + margins.right,
          bottom: rect.bottom + margins.bottom
        };
        let { offsetWidth, offsetHeight } = this.view.scrollDOM;
        scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
      }
    };
    DecorationComparator$1 = class DecorationComparator {
      constructor() {
        this.changes = [];
      }
      compareRange(from2, to) {
        addRange(from2, to, this.changes);
      }
      comparePoint(from2, to) {
        addRange(from2, to, this.changes);
      }
      boundChange(pos) {
        addRange(pos, pos, this.changes);
      }
    };
    LineBreakPlaceholder = "\uFFFF";
    DOMReader = class {
      constructor(points, state) {
        this.points = points;
        this.text = "";
        this.lineSeparator = state.facet(EditorState.lineSeparator);
      }
      append(text) {
        this.text += text;
      }
      lineBreak() {
        this.text += LineBreakPlaceholder;
      }
      readRange(start, end) {
        if (!start)
          return this;
        let parent = start.parentNode;
        for (let cur2 = start; ; ) {
          this.findPointBefore(parent, cur2);
          let oldLen = this.text.length;
          this.readNode(cur2);
          let next = cur2.nextSibling;
          if (next == end)
            break;
          let view = ContentView.get(cur2), nextView = ContentView.get(next);
          if ((view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur2)) || isBlockElement(next) && (cur2.nodeName != "BR" || cur2.cmIgnore) && this.text.length > oldLen) && !isEmptyToEnd(next, end))
            this.lineBreak();
          cur2 = next;
        }
        this.findPointBefore(parent, end);
        return this;
      }
      readTextNode(node) {
        let text = node.nodeValue;
        for (let point of this.points)
          if (point.node == node)
            point.pos = this.text.length + Math.min(point.offset, text.length);
        for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
          let nextBreak = -1, breakSize = 1, m;
          if (this.lineSeparator) {
            nextBreak = text.indexOf(this.lineSeparator, off);
            breakSize = this.lineSeparator.length;
          } else if (m = re.exec(text)) {
            nextBreak = m.index;
            breakSize = m[0].length;
          }
          this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
          if (nextBreak < 0)
            break;
          this.lineBreak();
          if (breakSize > 1) {
            for (let point of this.points)
              if (point.node == node && point.pos > this.text.length)
                point.pos -= breakSize - 1;
          }
          off = nextBreak + breakSize;
        }
      }
      readNode(node) {
        if (node.cmIgnore)
          return;
        let view = ContentView.get(node);
        let fromView = view && view.overrideDOMText;
        if (fromView != null) {
          this.findPointInside(node, fromView.length);
          for (let i = fromView.iter(); !i.next().done; ) {
            if (i.lineBreak)
              this.lineBreak();
            else
              this.append(i.value);
          }
        } else if (node.nodeType == 3) {
          this.readTextNode(node);
        } else if (node.nodeName == "BR") {
          if (node.nextSibling)
            this.lineBreak();
        } else if (node.nodeType == 1) {
          this.readRange(node.firstChild, null);
        }
      }
      findPointBefore(node, next) {
        for (let point of this.points)
          if (point.node == node && node.childNodes[point.offset] == next)
            point.pos = this.text.length;
      }
      findPointInside(node, length) {
        for (let point of this.points)
          if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
            point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);
      }
    };
    DOMPoint = class {
      constructor(node, offset) {
        this.node = node;
        this.offset = offset;
        this.pos = -1;
      }
    };
    DOMChange = class {
      constructor(view, start, end, typeOver) {
        this.typeOver = typeOver;
        this.bounds = null;
        this.text = "";
        this.domChanged = start > -1;
        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
        if (view.state.readOnly && start > -1) {
          this.newSel = null;
        } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
          let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
          let reader = new DOMReader(selPoints, view.state);
          reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
          this.text = reader.text;
          this.newSel = selectionFromPoints(selPoints, this.bounds.from);
        } else {
          let domSel = view.observer.selectionRange;
          let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
          let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
          let vp = view.viewport;
          if ((browser.ios || browser.chrome) && view.state.selection.main.empty && head != anchor && (vp.from > 0 || vp.to < view.state.doc.length)) {
            let from2 = Math.min(head, anchor), to = Math.max(head, anchor);
            let offFrom = vp.from - from2, offTo = vp.to - to;
            if ((offFrom == 0 || offFrom == 1 || from2 == 0) && (offTo == 0 || offTo == -1 || to == view.state.doc.length)) {
              head = 0;
              anchor = view.state.doc.length;
            }
          }
          this.newSel = EditorSelection.single(anchor, head);
        }
      }
    };
    InputState = class {
      setSelectionOrigin(origin) {
        this.lastSelectionOrigin = origin;
        this.lastSelectionTime = Date.now();
      }
      constructor(view) {
        this.view = view;
        this.lastKeyCode = 0;
        this.lastKeyTime = 0;
        this.lastTouchTime = 0;
        this.lastFocusTime = 0;
        this.lastScrollTop = 0;
        this.lastScrollLeft = 0;
        this.pendingIOSKey = void 0;
        this.tabFocusMode = -1;
        this.lastSelectionOrigin = null;
        this.lastSelectionTime = 0;
        this.lastContextMenu = 0;
        this.scrollHandlers = [];
        this.handlers = /* @__PURE__ */ Object.create(null);
        this.composing = -1;
        this.compositionFirstChange = null;
        this.compositionEndedAt = 0;
        this.compositionPendingKey = false;
        this.compositionPendingChange = false;
        this.mouseSelection = null;
        this.draggedContent = null;
        this.handleEvent = this.handleEvent.bind(this);
        this.notifiedFocused = view.hasFocus;
        if (browser.safari)
          view.contentDOM.addEventListener("input", () => null);
        if (browser.gecko)
          firefoxCopyCutHack(view.contentDOM.ownerDocument);
      }
      handleEvent(event) {
        if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event))
          return;
        if (event.type == "keydown" && this.keydown(event))
          return;
        if (this.view.updateState != 0)
          Promise.resolve().then(() => this.runHandlers(event.type, event));
        else
          this.runHandlers(event.type, event);
      }
      runHandlers(type, event) {
        let handlers2 = this.handlers[type];
        if (handlers2) {
          for (let observer of handlers2.observers)
            observer(this.view, event);
          for (let handler of handlers2.handlers) {
            if (event.defaultPrevented)
              break;
            if (handler(this.view, event)) {
              event.preventDefault();
              break;
            }
          }
        }
      }
      ensureHandlers(plugins) {
        let handlers2 = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
        for (let type in handlers2)
          if (type != "scroll") {
            let passive = !handlers2[type].handlers.length;
            let exists = prev[type];
            if (exists && passive != !exists.handlers.length) {
              dom.removeEventListener(type, this.handleEvent);
              exists = null;
            }
            if (!exists)
              dom.addEventListener(type, this.handleEvent, { passive });
          }
        for (let type in prev)
          if (type != "scroll" && !handlers2[type])
            dom.removeEventListener(type, this.handleEvent);
        this.handlers = handlers2;
      }
      keydown(event) {
        this.lastKeyCode = event.keyCode;
        this.lastKeyTime = Date.now();
        if (event.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
          return true;
        if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)
          this.tabFocusMode = -1;
        if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
          this.view.observer.delayAndroidKey(event.key, event.keyCode);
          return true;
        }
        let pending;
        if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
          this.pendingIOSKey = pending || event;
          setTimeout(() => this.flushIOSKey(), 250);
          return true;
        }
        if (event.keyCode != 229)
          this.view.observer.forceFlush();
        return false;
      }
      flushIOSKey(change) {
        let key = this.pendingIOSKey;
        if (!key)
          return false;
        if (key.key == "Enter" && change && change.from < change.to && /^\S+$/.test(change.insert.toString()))
          return false;
        this.pendingIOSKey = void 0;
        return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : void 0);
      }
      ignoreDuringComposition(event) {
        if (!/^key/.test(event.type) || event.synthetic)
          return false;
        if (this.composing > 0)
          return true;
        if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
          this.compositionPendingKey = false;
          return true;
        }
        return false;
      }
      startMouseSelection(mouseSelection) {
        if (this.mouseSelection)
          this.mouseSelection.destroy();
        this.mouseSelection = mouseSelection;
      }
      update(update) {
        this.view.observer.update(update);
        if (this.mouseSelection)
          this.mouseSelection.update(update);
        if (this.draggedContent && update.docChanged)
          this.draggedContent = this.draggedContent.map(update.changes);
        if (update.transactions.length)
          this.lastKeyCode = this.lastSelectionTime = 0;
      }
      destroy() {
        if (this.mouseSelection)
          this.mouseSelection.destroy();
      }
    };
    PendingKeys = [
      { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
      { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
      { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
      { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
    ];
    EmacsyPendingKeys = "dthko";
    modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
    dragScrollMargin = 6;
    MouseSelection = class {
      constructor(view, startEvent, style, mustSelect) {
        this.view = view;
        this.startEvent = startEvent;
        this.style = style;
        this.mustSelect = mustSelect;
        this.scrollSpeed = { x: 0, y: 0 };
        this.scrolling = -1;
        this.lastEvent = startEvent;
        this.scrollParents = scrollableParents(view.contentDOM);
        this.atoms = view.state.facet(atomicRanges).map((f) => f(view));
        let doc2 = view.contentDOM.ownerDocument;
        doc2.addEventListener("mousemove", this.move = this.move.bind(this));
        doc2.addEventListener("mouseup", this.up = this.up.bind(this));
        this.extend = startEvent.shiftKey;
        this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
        this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
      }
      start(event) {
        if (this.dragging === false)
          this.select(event);
      }
      move(event) {
        if (event.buttons == 0)
          return this.destroy();
        if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10)
          return;
        this.select(this.lastEvent = event);
        let sx = 0, sy = 0;
        let left = 0, top2 = 0, right = this.view.win.innerWidth, bottom = this.view.win.innerHeight;
        if (this.scrollParents.x)
          ({ left, right } = this.scrollParents.x.getBoundingClientRect());
        if (this.scrollParents.y)
          ({ top: top2, bottom } = this.scrollParents.y.getBoundingClientRect());
        let margins = getScrollMargins(this.view);
        if (event.clientX - margins.left <= left + dragScrollMargin)
          sx = -dragScrollSpeed(left - event.clientX);
        else if (event.clientX + margins.right >= right - dragScrollMargin)
          sx = dragScrollSpeed(event.clientX - right);
        if (event.clientY - margins.top <= top2 + dragScrollMargin)
          sy = -dragScrollSpeed(top2 - event.clientY);
        else if (event.clientY + margins.bottom >= bottom - dragScrollMargin)
          sy = dragScrollSpeed(event.clientY - bottom);
        this.setScrollSpeed(sx, sy);
      }
      up(event) {
        if (this.dragging == null)
          this.select(this.lastEvent);
        if (!this.dragging)
          event.preventDefault();
        this.destroy();
      }
      destroy() {
        this.setScrollSpeed(0, 0);
        let doc2 = this.view.contentDOM.ownerDocument;
        doc2.removeEventListener("mousemove", this.move);
        doc2.removeEventListener("mouseup", this.up);
        this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
      }
      setScrollSpeed(sx, sy) {
        this.scrollSpeed = { x: sx, y: sy };
        if (sx || sy) {
          if (this.scrolling < 0)
            this.scrolling = setInterval(() => this.scroll(), 50);
        } else if (this.scrolling > -1) {
          clearInterval(this.scrolling);
          this.scrolling = -1;
        }
      }
      scroll() {
        let { x, y } = this.scrollSpeed;
        if (x && this.scrollParents.x) {
          this.scrollParents.x.scrollLeft += x;
          x = 0;
        }
        if (y && this.scrollParents.y) {
          this.scrollParents.y.scrollTop += y;
          y = 0;
        }
        if (x || y)
          this.view.win.scrollBy(x, y);
        if (this.dragging === false)
          this.select(this.lastEvent);
      }
      select(event) {
        let { view } = this, selection2 = skipAtomsForSelection(this.atoms, this.style.get(event, this.extend, this.multiple));
        if (this.mustSelect || !selection2.eq(view.state.selection, this.dragging === false))
          this.view.dispatch({
            selection: selection2,
            userEvent: "select.pointer"
          });
        this.mustSelect = false;
      }
      update(update) {
        if (update.transactions.some((tr) => tr.isUserEvent("input.type")))
          this.destroy();
        else if (this.style.update(update))
          setTimeout(() => this.select(this.lastEvent), 20);
      }
    };
    handlers = /* @__PURE__ */ Object.create(null);
    observers = /* @__PURE__ */ Object.create(null);
    brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
    observers.scroll = (view) => {
      view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
      view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
    };
    handlers.keydown = (view, event) => {
      view.inputState.setSelectionOrigin("select");
      if (event.keyCode == 27 && view.inputState.tabFocusMode != 0)
        view.inputState.tabFocusMode = Date.now() + 2e3;
      return false;
    };
    observers.touchstart = (view, e) => {
      view.inputState.lastTouchTime = Date.now();
      view.inputState.setSelectionOrigin("select.pointer");
    };
    observers.touchmove = (view) => {
      view.inputState.setSelectionOrigin("select.pointer");
    };
    handlers.mousedown = (view, event) => {
      view.observer.flush();
      if (view.inputState.lastTouchTime > Date.now() - 2e3)
        return false;
      let style = null;
      for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
        style = makeStyle(view, event);
        if (style)
          break;
      }
      if (!style && event.button == 0)
        style = basicMouseSelection(view, event);
      if (style) {
        let mustFocus = !view.hasFocus;
        view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
        if (mustFocus)
          view.observer.ignore(() => {
            focusPreventScroll(view.contentDOM);
            let active = view.root.activeElement;
            if (active && !active.contains(view.contentDOM))
              active.blur();
          });
        let mouseSel = view.inputState.mouseSelection;
        if (mouseSel) {
          mouseSel.start(event);
          return mouseSel.dragging === false;
        }
      } else {
        view.inputState.setSelectionOrigin("select.pointer");
      }
      return false;
    };
    inside = (x, y, rect) => y >= rect.top && y <= rect.bottom && x >= rect.left && x <= rect.right;
    BadMouseDetail = browser.ie && browser.ie_version <= 11;
    lastMouseDown = null;
    lastMouseDownCount = 0;
    lastMouseDownTime = 0;
    handlers.dragstart = (view, event) => {
      let { selection: { main: range } } = view.state;
      if (event.target.draggable) {
        let cView = view.docView.nearest(event.target);
        if (cView && cView.isWidget) {
          let from2 = cView.posAtStart, to = from2 + cView.length;
          if (from2 >= range.to || to <= range.from)
            range = EditorSelection.range(from2, to);
        }
      }
      let { inputState } = view;
      if (inputState.mouseSelection)
        inputState.mouseSelection.dragging = true;
      inputState.draggedContent = range;
      if (event.dataTransfer) {
        event.dataTransfer.setData("Text", textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range.from, range.to)));
        event.dataTransfer.effectAllowed = "copyMove";
      }
      return false;
    };
    handlers.dragend = (view) => {
      view.inputState.draggedContent = null;
      return false;
    };
    handlers.drop = (view, event) => {
      if (!event.dataTransfer)
        return false;
      if (view.state.readOnly)
        return true;
      let files = event.dataTransfer.files;
      if (files && files.length) {
        let text = Array(files.length), read = 0;
        let finishFile = () => {
          if (++read == files.length)
            dropText(view, event, text.filter((s) => s != null).join(view.state.lineBreak), false);
        };
        for (let i = 0; i < files.length; i++) {
          let reader = new FileReader();
          reader.onerror = finishFile;
          reader.onload = () => {
            if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
              text[i] = reader.result;
            finishFile();
          };
          reader.readAsText(files[i]);
        }
        return true;
      } else {
        let text = event.dataTransfer.getData("Text");
        if (text) {
          dropText(view, event, text, true);
          return true;
        }
      }
      return false;
    };
    handlers.paste = (view, event) => {
      if (view.state.readOnly)
        return true;
      view.observer.flush();
      let data2 = brokenClipboardAPI ? null : event.clipboardData;
      if (data2) {
        doPaste(view, data2.getData("text/plain") || data2.getData("text/uri-list"));
        return true;
      } else {
        capturePaste(view);
        return false;
      }
    };
    lastLinewiseCopy = null;
    handlers.copy = handlers.cut = (view, event) => {
      let { text, ranges, linewise } = copiedRange(view.state);
      if (!text && !linewise)
        return false;
      lastLinewiseCopy = linewise ? text : null;
      if (event.type == "cut" && !view.state.readOnly)
        view.dispatch({
          changes: ranges,
          scrollIntoView: true,
          userEvent: "delete.cut"
        });
      let data2 = brokenClipboardAPI ? null : event.clipboardData;
      if (data2) {
        data2.clearData();
        data2.setData("text/plain", text);
        return true;
      } else {
        captureCopy(view, text);
        return false;
      }
    };
    isFocusChange = /* @__PURE__ */ Annotation.define();
    observers.focus = (view) => {
      view.inputState.lastFocusTime = Date.now();
      if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
        view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
        view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
      }
      updateForFocusChange(view);
    };
    observers.blur = (view) => {
      view.observer.clearSelectionRange();
      updateForFocusChange(view);
    };
    observers.compositionstart = observers.compositionupdate = (view) => {
      if (view.observer.editContext)
        return;
      if (view.inputState.compositionFirstChange == null)
        view.inputState.compositionFirstChange = true;
      if (view.inputState.composing < 0) {
        view.inputState.composing = 0;
      }
    };
    observers.compositionend = (view) => {
      if (view.observer.editContext)
        return;
      view.inputState.composing = -1;
      view.inputState.compositionEndedAt = Date.now();
      view.inputState.compositionPendingKey = true;
      view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
      view.inputState.compositionFirstChange = null;
      if (browser.chrome && browser.android) {
        view.observer.flushSoon();
      } else if (view.inputState.compositionPendingChange) {
        Promise.resolve().then(() => view.observer.flush());
      } else {
        setTimeout(() => {
          if (view.inputState.composing < 0 && view.docView.hasComposition)
            view.update([]);
        }, 50);
      }
    };
    observers.contextmenu = (view) => {
      view.inputState.lastContextMenu = Date.now();
    };
    handlers.beforeinput = (view, event) => {
      var _a2, _b;
      if (event.inputType == "insertReplacementText" && view.observer.editContext) {
        let text = (_a2 = event.dataTransfer) === null || _a2 === void 0 ? void 0 : _a2.getData("text/plain"), ranges = event.getTargetRanges();
        if (text && ranges.length) {
          let r = ranges[0];
          let from2 = view.posAtDOM(r.startContainer, r.startOffset), to = view.posAtDOM(r.endContainer, r.endOffset);
          applyDOMChangeInner(view, { from: from2, to, insert: view.state.toText(text) }, null);
          return true;
        }
      }
      let pending;
      if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event.inputType))) {
        view.observer.delayAndroidKey(pending.key, pending.keyCode);
        if (pending.key == "Backspace" || pending.key == "Delete") {
          let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;
          setTimeout(() => {
            var _a3;
            if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view.hasFocus) {
              view.contentDOM.blur();
              view.focus();
            }
          }, 100);
        }
      }
      if (browser.ios && event.inputType == "deleteContentForward") {
        view.observer.flushSoon();
      }
      if (browser.safari && event.inputType == "insertText" && view.inputState.composing >= 0) {
        setTimeout(() => observers.compositionend(view, event), 20);
      }
      return false;
    };
    appliedFirefoxHack = /* @__PURE__ */ new Set();
    wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
    heightChangeFlag = false;
    HeightOracle = class {
      constructor(lineWrapping) {
        this.lineWrapping = lineWrapping;
        this.doc = Text2.empty;
        this.heightSamples = {};
        this.lineHeight = 14;
        this.charWidth = 7;
        this.textHeight = 14;
        this.lineLength = 30;
      }
      heightForGap(from2, to) {
        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from2).number + 1;
        if (this.lineWrapping)
          lines += Math.max(0, Math.ceil((to - from2 - lines * this.lineLength * 0.5) / this.lineLength));
        return this.lineHeight * lines;
      }
      heightForLine(length) {
        if (!this.lineWrapping)
          return this.lineHeight;
        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / Math.max(1, this.lineLength - 5)));
        return lines * this.lineHeight;
      }
      setDoc(doc2) {
        this.doc = doc2;
        return this;
      }
      mustRefreshForWrapping(whiteSpace) {
        return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
      }
      mustRefreshForHeights(lineHeights) {
        let newHeight = false;
        for (let i = 0; i < lineHeights.length; i++) {
          let h = lineHeights[i];
          if (h < 0) {
            i++;
          } else if (!this.heightSamples[Math.floor(h * 10)]) {
            newHeight = true;
            this.heightSamples[Math.floor(h * 10)] = true;
          }
        }
        return newHeight;
      }
      refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
        this.lineWrapping = lineWrapping;
        this.lineHeight = lineHeight;
        this.charWidth = charWidth;
        this.textHeight = textHeight;
        this.lineLength = lineLength;
        if (changed) {
          this.heightSamples = {};
          for (let i = 0; i < knownHeights.length; i++) {
            let h = knownHeights[i];
            if (h < 0)
              i++;
            else
              this.heightSamples[Math.floor(h * 10)] = true;
          }
        }
        return changed;
      }
    };
    MeasuredHeights = class {
      constructor(from2, heights) {
        this.from = from2;
        this.heights = heights;
        this.index = 0;
      }
      get more() {
        return this.index < this.heights.length;
      }
    };
    BlockInfo = class _BlockInfo {
      /**
      @internal
      */
      constructor(from2, length, top2, height, _content) {
        this.from = from2;
        this.length = length;
        this.top = top2;
        this.height = height;
        this._content = _content;
      }
      /**
      The type of element this is. When querying lines, this may be
      an array of all the blocks that make up the line.
      */
      get type() {
        return typeof this._content == "number" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
      }
      /**
      The end of the element as a document position.
      */
      get to() {
        return this.from + this.length;
      }
      /**
      The bottom position of the element.
      */
      get bottom() {
        return this.top + this.height;
      }
      /**
      If this is a widget block, this will return the widget
      associated with it.
      */
      get widget() {
        return this._content instanceof PointDecoration ? this._content.widget : null;
      }
      /**
      If this is a textblock, this holds the number of line breaks
      that appear in widgets inside the block.
      */
      get widgetLineBreaks() {
        return typeof this._content == "number" ? this._content : 0;
      }
      /**
      @internal
      */
      join(other) {
        let content2 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other._content) ? other._content : [other]);
        return new _BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content2);
      }
    };
    QueryType = /* @__PURE__ */ function(QueryType3) {
      QueryType3[QueryType3["ByPos"] = 0] = "ByPos";
      QueryType3[QueryType3["ByHeight"] = 1] = "ByHeight";
      QueryType3[QueryType3["ByPosNoHeight"] = 2] = "ByPosNoHeight";
      return QueryType3;
    }(QueryType || (QueryType = {}));
    Epsilon = 1e-3;
    HeightMap = class _HeightMap {
      constructor(length, height, flags = 2) {
        this.length = length;
        this.height = height;
        this.flags = flags;
      }
      get outdated() {
        return (this.flags & 2) > 0;
      }
      set outdated(value) {
        this.flags = (value ? 2 : 0) | this.flags & ~2;
      }
      setHeight(height) {
        if (this.height != height) {
          if (Math.abs(this.height - height) > Epsilon)
            heightChangeFlag = true;
          this.height = height;
        }
      }
      // Base case is to replace a leaf node, which simply builds a tree
      // from the new nodes and returns that (HeightMapBranch and
      // HeightMapGap override this to actually use from/to)
      replace(_from, _to, nodes) {
        return _HeightMap.of(nodes);
      }
      // Again, these are base cases, and are overridden for branch and gap nodes.
      decomposeLeft(_to, result) {
        result.push(this);
      }
      decomposeRight(_from, result) {
        result.push(this);
      }
      applyChanges(decorations2, oldDoc, oracle, changes) {
        let me = this, doc2 = oracle.doc;
        for (let i = changes.length - 1; i >= 0; i--) {
          let { fromA, toA, fromB, toB } = changes[i];
          let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
          let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
          toB += end.to - toA;
          toA = end.to;
          while (i > 0 && start.from <= changes[i - 1].toA) {
            fromA = changes[i - 1].fromA;
            fromB = changes[i - 1].fromB;
            i--;
            if (fromA < start.from)
              start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
          }
          fromB += start.from - fromA;
          fromA = start.from;
          let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
          me = replace(me, me.replace(fromA, toA, nodes));
        }
        return me.updateHeight(oracle, 0);
      }
      static empty() {
        return new HeightMapText(0, 0);
      }
      // nodes uses null values to indicate the position of line breaks.
      // There are never line breaks at the start or end of the array, or
      // two line breaks next to each other, and the array isn't allowed
      // to be empty (same restrictions as return value from the builder).
      static of(nodes) {
        if (nodes.length == 1)
          return nodes[0];
        let i = 0, j = nodes.length, before = 0, after = 0;
        for (; ; ) {
          if (i == j) {
            if (before > after * 2) {
              let split2 = nodes[i - 1];
              if (split2.break)
                nodes.splice(--i, 1, split2.left, null, split2.right);
              else
                nodes.splice(--i, 1, split2.left, split2.right);
              j += 1 + split2.break;
              before -= split2.size;
            } else if (after > before * 2) {
              let split2 = nodes[j];
              if (split2.break)
                nodes.splice(j, 1, split2.left, null, split2.right);
              else
                nodes.splice(j, 1, split2.left, split2.right);
              j += 2 + split2.break;
              after -= split2.size;
            } else {
              break;
            }
          } else if (before < after) {
            let next = nodes[i++];
            if (next)
              before += next.size;
          } else {
            let next = nodes[--j];
            if (next)
              after += next.size;
          }
        }
        let brk = 0;
        if (nodes[i - 1] == null) {
          brk = 1;
          i--;
        } else if (nodes[i] == null) {
          brk = 1;
          j++;
        }
        return new HeightMapBranch(_HeightMap.of(nodes.slice(0, i)), brk, _HeightMap.of(nodes.slice(j)));
      }
    };
    HeightMap.prototype.size = 1;
    HeightMapBlock = class extends HeightMap {
      constructor(length, height, deco) {
        super(length, height);
        this.deco = deco;
      }
      blockAt(_height, _oracle, top2, offset) {
        return new BlockInfo(offset, this.length, top2, this.height, this.deco || 0);
      }
      lineAt(_value, _type, oracle, top2, offset) {
        return this.blockAt(0, oracle, top2, offset);
      }
      forEachLine(from2, to, oracle, top2, offset, f) {
        if (from2 <= offset + this.length && to >= offset)
          f(this.blockAt(0, oracle, top2, offset));
      }
      updateHeight(oracle, offset = 0, _force = false, measured) {
        if (measured && measured.from <= offset && measured.more)
          this.setHeight(measured.heights[measured.index++]);
        this.outdated = false;
        return this;
      }
      toString() {
        return `block(${this.length})`;
      }
    };
    HeightMapText = class _HeightMapText extends HeightMapBlock {
      constructor(length, height) {
        super(length, height, null);
        this.collapsed = 0;
        this.widgetHeight = 0;
        this.breaks = 0;
      }
      blockAt(_height, _oracle, top2, offset) {
        return new BlockInfo(offset, this.length, top2, this.height, this.breaks);
      }
      replace(_from, _to, nodes) {
        let node = nodes[0];
        if (nodes.length == 1 && (node instanceof _HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
          if (node instanceof HeightMapGap)
            node = new _HeightMapText(node.length, this.height);
          else
            node.height = this.height;
          if (!this.outdated)
            node.outdated = false;
          return node;
        } else {
          return HeightMap.of(nodes);
        }
      }
      updateHeight(oracle, offset = 0, force = false, measured) {
        if (measured && measured.from <= offset && measured.more)
          this.setHeight(measured.heights[measured.index++]);
        else if (force || this.outdated)
          this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
        this.outdated = false;
        return this;
      }
      toString() {
        return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
      }
    };
    HeightMapGap = class _HeightMapGap extends HeightMap {
      constructor(length) {
        super(length, 0);
      }
      heightMetrics(oracle, offset) {
        let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
        let lines = lastLine - firstLine + 1;
        let perLine, perChar = 0;
        if (oracle.lineWrapping) {
          let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
          perLine = totalPerLine / lines;
          if (this.length > lines + 1)
            perChar = (this.height - totalPerLine) / (this.length - lines - 1);
        } else {
          perLine = this.height / lines;
        }
        return { firstLine, lastLine, perLine, perChar };
      }
      blockAt(height, oracle, top2, offset) {
        let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        if (oracle.lineWrapping) {
          let guess = offset + (height < oracle.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (height - top2) / this.height)) * this.length));
          let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
          let lineTop = Math.max(top2, height - lineHeight / 2);
          return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
        } else {
          let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / perLine)));
          let { from: from2, length } = oracle.doc.line(firstLine + line);
          return new BlockInfo(from2, length, top2 + perLine * line, perLine, 0);
        }
      }
      lineAt(value, type, oracle, top2, offset) {
        if (type == QueryType.ByHeight)
          return this.blockAt(value, oracle, top2, offset);
        if (type == QueryType.ByPosNoHeight) {
          let { from: from2, to } = oracle.doc.lineAt(value);
          return new BlockInfo(from2, to - from2, 0, 0, 0);
        }
        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
        let linesAbove = line.number - firstLine;
        let lineTop = top2 + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
        return new BlockInfo(line.from, line.length, Math.max(top2, Math.min(lineTop, top2 + this.height - lineHeight)), lineHeight, 0);
      }
      forEachLine(from2, to, oracle, top2, offset, f) {
        from2 = Math.max(from2, offset);
        to = Math.min(to, offset + this.length);
        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        for (let pos = from2, lineTop = top2; pos <= to; ) {
          let line = oracle.doc.lineAt(pos);
          if (pos == from2) {
            let linesAbove = line.number - firstLine;
            lineTop += perLine * linesAbove + perChar * (from2 - offset - linesAbove);
          }
          let lineHeight = perLine + perChar * line.length;
          f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
          lineTop += lineHeight;
          pos = line.to + 1;
        }
      }
      replace(from2, to, nodes) {
        let after = this.length - to;
        if (after > 0) {
          let last4 = nodes[nodes.length - 1];
          if (last4 instanceof _HeightMapGap)
            nodes[nodes.length - 1] = new _HeightMapGap(last4.length + after);
          else
            nodes.push(null, new _HeightMapGap(after - 1));
        }
        if (from2 > 0) {
          let first2 = nodes[0];
          if (first2 instanceof _HeightMapGap)
            nodes[0] = new _HeightMapGap(from2 + first2.length);
          else
            nodes.unshift(new _HeightMapGap(from2 - 1), null);
        }
        return HeightMap.of(nodes);
      }
      decomposeLeft(to, result) {
        result.push(new _HeightMapGap(to - 1), null);
      }
      decomposeRight(from2, result) {
        result.push(null, new _HeightMapGap(this.length - from2 - 1));
      }
      updateHeight(oracle, offset = 0, force = false, measured) {
        let end = offset + this.length;
        if (measured && measured.from <= offset + this.length && measured.more) {
          let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
          if (measured.from > offset)
            nodes.push(new _HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
          while (pos <= end && measured.more) {
            let len = oracle.doc.lineAt(pos).length;
            if (nodes.length)
              nodes.push(null);
            let height = measured.heights[measured.index++];
            if (singleHeight == -1)
              singleHeight = height;
            else if (Math.abs(height - singleHeight) >= Epsilon)
              singleHeight = -2;
            let line = new HeightMapText(len, height);
            line.outdated = false;
            nodes.push(line);
            pos += len + 1;
          }
          if (pos <= end)
            nodes.push(null, new _HeightMapGap(end - pos).updateHeight(oracle, pos));
          let result = HeightMap.of(nodes);
          if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
            heightChangeFlag = true;
          return replace(this, result);
        } else if (force || this.outdated) {
          this.setHeight(oracle.heightForGap(offset, offset + this.length));
          this.outdated = false;
        }
        return this;
      }
      toString() {
        return `gap(${this.length})`;
      }
    };
    HeightMapBranch = class extends HeightMap {
      constructor(left, brk, right) {
        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
        this.left = left;
        this.right = right;
        this.size = left.size + right.size;
      }
      get break() {
        return this.flags & 1;
      }
      blockAt(height, oracle, top2, offset) {
        let mid = top2 + this.left.height;
        return height < mid ? this.left.blockAt(height, oracle, top2, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
      }
      lineAt(value, type, oracle, top2, offset) {
        let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
        let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
        let base2 = left ? this.left.lineAt(value, type, oracle, top2, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
        if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
          return base2;
        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
        if (left)
          return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
        else
          return this.left.lineAt(rightOffset, subQuery, oracle, top2, offset).join(base2);
      }
      forEachLine(from2, to, oracle, top2, offset, f) {
        let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
        if (this.break) {
          if (from2 < rightOffset)
            this.left.forEachLine(from2, to, oracle, top2, offset, f);
          if (to >= rightOffset)
            this.right.forEachLine(from2, to, oracle, rightTop, rightOffset, f);
        } else {
          let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top2, offset);
          if (from2 < mid.from)
            this.left.forEachLine(from2, mid.from - 1, oracle, top2, offset, f);
          if (mid.to >= from2 && mid.from <= to)
            f(mid);
          if (to > mid.to)
            this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);
        }
      }
      replace(from2, to, nodes) {
        let rightStart = this.left.length + this.break;
        if (to < rightStart)
          return this.balanced(this.left.replace(from2, to, nodes), this.right);
        if (from2 > this.left.length)
          return this.balanced(this.left, this.right.replace(from2 - rightStart, to - rightStart, nodes));
        let result = [];
        if (from2 > 0)
          this.decomposeLeft(from2, result);
        let left = result.length;
        for (let node of nodes)
          result.push(node);
        if (from2 > 0)
          mergeGaps(result, left - 1);
        if (to < this.length) {
          let right = result.length;
          this.decomposeRight(to, result);
          mergeGaps(result, right);
        }
        return HeightMap.of(result);
      }
      decomposeLeft(to, result) {
        let left = this.left.length;
        if (to <= left)
          return this.left.decomposeLeft(to, result);
        result.push(this.left);
        if (this.break) {
          left++;
          if (to >= left)
            result.push(null);
        }
        if (to > left)
          this.right.decomposeLeft(to - left, result);
      }
      decomposeRight(from2, result) {
        let left = this.left.length, right = left + this.break;
        if (from2 >= right)
          return this.right.decomposeRight(from2 - right, result);
        if (from2 < left)
          this.left.decomposeRight(from2, result);
        if (this.break && from2 < right)
          result.push(null);
        result.push(this.right);
      }
      balanced(left, right) {
        if (left.size > 2 * right.size || right.size > 2 * left.size)
          return HeightMap.of(this.break ? [left, null, right] : [left, right]);
        this.left = replace(this.left, left);
        this.right = replace(this.right, right);
        this.setHeight(left.height + right.height);
        this.outdated = left.outdated || right.outdated;
        this.size = left.size + right.size;
        this.length = left.length + this.break + right.length;
        return this;
      }
      updateHeight(oracle, offset = 0, force = false, measured) {
        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
        if (measured && measured.from <= offset + left.length && measured.more)
          rebalance = left = left.updateHeight(oracle, offset, force, measured);
        else
          left.updateHeight(oracle, offset, force);
        if (measured && measured.from <= rightStart + right.length && measured.more)
          rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
        else
          right.updateHeight(oracle, rightStart, force);
        if (rebalance)
          return this.balanced(left, right);
        this.height = this.left.height + this.right.height;
        this.outdated = false;
        return this;
      }
      toString() {
        return this.left + (this.break ? " " : "-") + this.right;
      }
    };
    relevantWidgetHeight = 5;
    NodeBuilder = class _NodeBuilder {
      constructor(pos, oracle) {
        this.pos = pos;
        this.oracle = oracle;
        this.nodes = [];
        this.lineStart = -1;
        this.lineEnd = -1;
        this.covering = null;
        this.writtenTo = pos;
      }
      get isCovered() {
        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
      }
      span(_from, to) {
        if (this.lineStart > -1) {
          let end = Math.min(to, this.lineEnd), last4 = this.nodes[this.nodes.length - 1];
          if (last4 instanceof HeightMapText)
            last4.length += end - this.pos;
          else if (end > this.pos || !this.isCovered)
            this.nodes.push(new HeightMapText(end - this.pos, -1));
          this.writtenTo = end;
          if (to > end) {
            this.nodes.push(null);
            this.writtenTo++;
            this.lineStart = -1;
          }
        }
        this.pos = to;
      }
      point(from2, to, deco) {
        if (from2 < to || deco.heightRelevant) {
          let height = deco.widget ? deco.widget.estimatedHeight : 0;
          let breaks = deco.widget ? deco.widget.lineBreaks : 0;
          if (height < 0)
            height = this.oracle.lineHeight;
          let len = to - from2;
          if (deco.block) {
            this.addBlock(new HeightMapBlock(len, height, deco));
          } else if (len || breaks || height >= relevantWidgetHeight) {
            this.addLineDeco(height, breaks, len);
          }
        } else if (to > from2) {
          this.span(from2, to);
        }
        if (this.lineEnd > -1 && this.lineEnd < this.pos)
          this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
      }
      enterLine() {
        if (this.lineStart > -1)
          return;
        let { from: from2, to } = this.oracle.doc.lineAt(this.pos);
        this.lineStart = from2;
        this.lineEnd = to;
        if (this.writtenTo < from2) {
          if (this.writtenTo < from2 - 1 || this.nodes[this.nodes.length - 1] == null)
            this.nodes.push(this.blankContent(this.writtenTo, from2 - 1));
          this.nodes.push(null);
        }
        if (this.pos > from2)
          this.nodes.push(new HeightMapText(this.pos - from2, -1));
        this.writtenTo = this.pos;
      }
      blankContent(from2, to) {
        let gap = new HeightMapGap(to - from2);
        if (this.oracle.doc.lineAt(from2).to == to)
          gap.flags |= 4;
        return gap;
      }
      ensureLine() {
        this.enterLine();
        let last4 = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
        if (last4 instanceof HeightMapText)
          return last4;
        let line = new HeightMapText(0, -1);
        this.nodes.push(line);
        return line;
      }
      addBlock(block) {
        this.enterLine();
        let deco = block.deco;
        if (deco && deco.startSide > 0 && !this.isCovered)
          this.ensureLine();
        this.nodes.push(block);
        this.writtenTo = this.pos = this.pos + block.length;
        if (deco && deco.endSide > 0)
          this.covering = block;
      }
      addLineDeco(height, breaks, length) {
        let line = this.ensureLine();
        line.length += length;
        line.collapsed += length;
        line.widgetHeight = Math.max(line.widgetHeight, height);
        line.breaks += breaks;
        this.writtenTo = this.pos = this.pos + length;
      }
      finish(from2) {
        let last4 = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
        if (this.lineStart > -1 && !(last4 instanceof HeightMapText) && !this.isCovered)
          this.nodes.push(new HeightMapText(0, -1));
        else if (this.writtenTo < this.pos || last4 == null)
          this.nodes.push(this.blankContent(this.writtenTo, this.pos));
        let pos = from2;
        for (let node of this.nodes) {
          if (node instanceof HeightMapText)
            node.updateHeight(this.oracle, pos);
          pos += node ? node.length : 1;
        }
        return this.nodes;
      }
      // Always called with a region that on both sides either stretches
      // to a line break or the end of the document.
      // The returned array uses null to indicate line breaks, but never
      // starts or ends in a line break, or has multiple line breaks next
      // to each other.
      static build(oracle, decorations2, from2, to) {
        let builder = new _NodeBuilder(from2, oracle);
        RangeSet.spans(decorations2, from2, to, builder, 0);
        return builder.finish(from2);
      }
    };
    DecorationComparator2 = class {
      constructor() {
        this.changes = [];
      }
      compareRange() {
      }
      comparePoint(from2, to, a, b) {
        if (from2 < to || a && a.heightRelevant || b && b.heightRelevant)
          addRange(from2, to, this.changes, 5);
      }
    };
    LineGap = class {
      constructor(from2, to, size, displaySize) {
        this.from = from2;
        this.to = to;
        this.size = size;
        this.displaySize = displaySize;
      }
      static same(a, b) {
        if (a.length != b.length)
          return false;
        for (let i = 0; i < a.length; i++) {
          let gA = a[i], gB = b[i];
          if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
            return false;
        }
        return true;
      }
      draw(viewState, wrapping) {
        return Decoration.replace({
          widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
        }).range(this.from, this.to);
      }
    };
    LineGapWidget = class extends WidgetType {
      constructor(size, vertical) {
        super();
        this.size = size;
        this.vertical = vertical;
      }
      eq(other) {
        return other.size == this.size && other.vertical == this.vertical;
      }
      toDOM() {
        let elt2 = document.createElement("div");
        if (this.vertical) {
          elt2.style.height = this.size + "px";
        } else {
          elt2.style.width = this.size + "px";
          elt2.style.height = "2px";
          elt2.style.display = "inline-block";
        }
        return elt2;
      }
      get estimatedHeight() {
        return this.vertical ? this.size : -1;
      }
    };
    ViewState = class {
      constructor(state) {
        this.state = state;
        this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
        this.inView = true;
        this.paddingTop = 0;
        this.paddingBottom = 0;
        this.contentDOMWidth = 0;
        this.contentDOMHeight = 0;
        this.editorHeight = 0;
        this.editorWidth = 0;
        this.scrollTop = 0;
        this.scrolledToBottom = false;
        this.scaleX = 1;
        this.scaleY = 1;
        this.scrollAnchorPos = 0;
        this.scrollAnchorHeight = -1;
        this.scaler = IdScaler;
        this.scrollTarget = null;
        this.printing = false;
        this.mustMeasureContent = true;
        this.defaultTextDirection = Direction.LTR;
        this.visibleRanges = [];
        this.mustEnforceCursorAssoc = false;
        let guessWrapping = state.facet(contentAttributes).some((v) => typeof v != "function" && v.class == "cm-lineWrapping");
        this.heightOracle = new HeightOracle(guessWrapping);
        this.stateDeco = state.facet(decorations).filter((d) => typeof d != "function");
        this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text2.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
        for (let i = 0; i < 2; i++) {
          this.viewport = this.getViewport(0, null);
          if (!this.updateForViewport())
            break;
        }
        this.updateViewportLines();
        this.lineGaps = this.ensureLineGaps([]);
        this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(this, false)));
        this.computeVisibleRanges();
      }
      updateForViewport() {
        let viewports = [this.viewport], { main } = this.state.selection;
        for (let i = 0; i <= 1; i++) {
          let pos = i ? main.head : main.anchor;
          if (!viewports.some(({ from: from2, to }) => pos >= from2 && pos <= to)) {
            let { from: from2, to } = this.lineBlockAt(pos);
            viewports.push(new Viewport(from2, to));
          }
        }
        this.viewports = viewports.sort((a, b) => a.from - b.from);
        return this.updateScaler();
      }
      updateScaler() {
        let scaler = this.scaler;
        this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
        return scaler.eq(this.scaler) ? 0 : 2;
      }
      updateViewportLines() {
        this.viewportLines = [];
        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block) => {
          this.viewportLines.push(scaleBlock(block, this.scaler));
        });
      }
      update(update, scrollTarget = null) {
        this.state = update.state;
        let prevDeco = this.stateDeco;
        this.stateDeco = this.state.facet(decorations).filter((d) => typeof d != "function");
        let contentChanges = update.changedRanges;
        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
        let prevHeight = this.heightMap.height;
        let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
        clearHeightChangeFlag();
        this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
        if (this.heightMap.height != prevHeight || heightChangeFlag)
          update.flags |= 2;
        if (scrollAnchor) {
          this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
          this.scrollAnchorHeight = scrollAnchor.top;
        } else {
          this.scrollAnchorPos = -1;
          this.scrollAnchorHeight = prevHeight;
        }
        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
        if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
          viewport = this.getViewport(0, scrollTarget);
        let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;
        this.viewport = viewport;
        update.flags |= this.updateForViewport();
        if (viewportChange || !update.changes.empty || update.flags & 2)
          this.updateViewportLines();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
          this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
        update.flags |= this.computeVisibleRanges(update.changes);
        if (scrollTarget)
          this.scrollTarget = scrollTarget;
        if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden))
          this.mustEnforceCursorAssoc = true;
      }
      measure(view) {
        let dom = view.contentDOM, style = window.getComputedStyle(dom);
        let oracle = this.heightOracle;
        let whiteSpace = style.whiteSpace;
        this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
        let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
        let domRect = dom.getBoundingClientRect();
        let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
        this.contentDOMHeight = domRect.height;
        this.mustMeasureContent = false;
        let result = 0, bias = 0;
        if (domRect.width && domRect.height) {
          let { scaleX, scaleY } = getScale(dom, domRect);
          if (scaleX > 5e-3 && Math.abs(this.scaleX - scaleX) > 5e-3 || scaleY > 5e-3 && Math.abs(this.scaleY - scaleY) > 5e-3) {
            this.scaleX = scaleX;
            this.scaleY = scaleY;
            result |= 16;
            refresh = measureContent = true;
          }
        }
        let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
        let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
        if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
          this.paddingTop = paddingTop;
          this.paddingBottom = paddingBottom;
          result |= 16 | 2;
        }
        if (this.editorWidth != view.scrollDOM.clientWidth) {
          if (oracle.lineWrapping)
            measureContent = true;
          this.editorWidth = view.scrollDOM.clientWidth;
          result |= 16;
        }
        let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
        if (this.scrollTop != scrollTop) {
          this.scrollAnchorHeight = -1;
          this.scrollTop = scrollTop;
        }
        this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
        let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
        this.pixelViewport = pixelViewport;
        let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
        if (inView != this.inView) {
          this.inView = inView;
          if (inView)
            measureContent = true;
        }
        if (!this.inView && !this.scrollTarget && !inWindow(view.dom))
          return 0;
        let contentWidth = domRect.width;
        if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
          this.contentDOMWidth = domRect.width;
          this.editorHeight = view.scrollDOM.clientHeight;
          result |= 16;
        }
        if (measureContent) {
          let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
          if (oracle.mustRefreshForHeights(lineHeights))
            refresh = true;
          if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
            let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
            refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, Math.max(5, contentWidth / charWidth), lineHeights);
            if (refresh) {
              view.docView.minWidth = 0;
              result |= 16;
            }
          }
          if (dTop > 0 && dBottom > 0)
            bias = Math.max(dTop, dBottom);
          else if (dTop < 0 && dBottom < 0)
            bias = Math.min(dTop, dBottom);
          clearHeightChangeFlag();
          for (let vp of this.viewports) {
            let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
            this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text2.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
          }
          if (heightChangeFlag)
            result |= 2;
        }
        let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
        if (viewportChange) {
          if (result & 2)
            result |= this.updateScaler();
          this.viewport = this.getViewport(bias, this.scrollTarget);
          result |= this.updateForViewport();
        }
        if (result & 2 || viewportChange)
          this.updateViewportLines();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
          this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
        result |= this.computeVisibleRanges();
        if (this.mustEnforceCursorAssoc) {
          this.mustEnforceCursorAssoc = false;
          view.docView.enforceCursorAssoc();
        }
        return result;
      }
      get visibleTop() {
        return this.scaler.fromDOM(this.pixelViewport.top);
      }
      get visibleBottom() {
        return this.scaler.fromDOM(this.pixelViewport.bottom);
      }
      getViewport(bias, scrollTarget) {
        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
        let map2 = this.heightMap, oracle = this.heightOracle;
        let { visibleTop, visibleBottom } = this;
        let viewport = new Viewport(map2.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, oracle, 0, 0).from, map2.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, oracle, 0, 0).to);
        if (scrollTarget) {
          let { head } = scrollTarget.range;
          if (head < viewport.from || head > viewport.to) {
            let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
            let block = map2.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;
            if (scrollTarget.y == "center")
              topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
            else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
              topPos = block.top;
            else
              topPos = block.bottom - viewHeight;
            viewport = new Viewport(map2.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).from, map2.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).to);
          }
        }
        return viewport;
      }
      mapViewport(viewport, changes) {
        let from2 = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
        return new Viewport(this.heightMap.lineAt(from2, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);
      }
      // Checks if a given viewport covers the visible part of the
      // document and not too much beyond that.
      viewportIsAppropriate({ from: from2, to }, bias = 0) {
        if (!this.inView)
          return true;
        let { top: top2 } = this.heightMap.lineAt(from2, QueryType.ByPos, this.heightOracle, 0, 0);
        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);
        let { visibleTop, visibleBottom } = this;
        return (from2 == 0 || top2 <= visibleTop - Math.max(10, Math.min(
          -bias,
          250
          /* VP.MaxCoverMargin */
        ))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(
          bias,
          250
          /* VP.MaxCoverMargin */
        ))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
      }
      mapLineGaps(gaps, changes) {
        if (!gaps.length || changes.empty)
          return gaps;
        let mapped = [];
        for (let gap of gaps)
          if (!changes.touchesRange(gap.from, gap.to))
            mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));
        return mapped;
      }
      // Computes positions in the viewport where the start or end of a
      // line should be hidden, trying to reuse existing line gaps when
      // appropriate to avoid unneccesary redraws.
      // Uses crude character-counting for the positioning and sizing,
      // since actual DOM coordinates aren't always available and
      // predictable. Relies on generous margins (see LG.Margin) to hide
      // the artifacts this might produce from the user.
      ensureLineGaps(current, mayMeasure) {
        let wrapping = this.heightOracle.lineWrapping;
        let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
        if (this.defaultTextDirection != Direction.LTR && !wrapping)
          return [];
        let gaps = [];
        let addGap = (from2, to, line, structure) => {
          if (to - from2 < halfMargin)
            return;
          let sel = this.state.selection.main, avoid = [sel.from];
          if (!sel.empty)
            avoid.push(sel.to);
          for (let pos of avoid) {
            if (pos > from2 && pos < to) {
              addGap(from2, pos - 10, line, structure);
              addGap(pos + 10, to, line, structure);
              return;
            }
          }
          let gap = find(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from2) < halfMargin && Math.abs(gap2.to - to) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
          if (!gap) {
            if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r) => r.from <= to && r.to >= to)) {
              let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
              if (lineStart > from2)
                to = lineStart;
            }
            let size = this.gapSize(line, from2, to, structure);
            let displaySize = wrapping || size < 2e6 ? size : 2e6;
            gap = new LineGap(from2, to, size, displaySize);
          }
          gaps.push(gap);
        };
        let checkLine = (line) => {
          if (line.length < doubleMargin || line.type != BlockType.Text)
            return;
          let structure = lineStructure(line.from, line.to, this.stateDeco);
          if (structure.total < doubleMargin)
            return;
          let target = this.scrollTarget ? this.scrollTarget.range.head : null;
          let viewFrom, viewTo;
          if (wrapping) {
            let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
            let top2, bot;
            if (target != null) {
              let targetFrac = findFraction(structure, target);
              let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
              top2 = targetFrac - spaceFrac;
              bot = targetFrac + spaceFrac;
            } else {
              top2 = (this.visibleTop - line.top - marginHeight) / line.height;
              bot = (this.visibleBottom - line.top + marginHeight) / line.height;
            }
            viewFrom = findPosition(structure, top2);
            viewTo = findPosition(structure, bot);
          } else {
            let totalWidth = structure.total * this.heightOracle.charWidth;
            let marginWidth = margin * this.heightOracle.charWidth;
            let horizOffset = 0;
            if (totalWidth > 2e6)
              for (let old of current) {
                if (old.from >= line.from && old.from < line.to && old.size != old.displaySize && old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left)
                  horizOffset = old.size - old.displaySize;
              }
            let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;
            let left, right;
            if (target != null) {
              let targetFrac = findFraction(structure, target);
              let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;
              left = targetFrac - spaceFrac;
              right = targetFrac + spaceFrac;
            } else {
              left = (pxLeft - marginWidth) / totalWidth;
              right = (pxRight + marginWidth) / totalWidth;
            }
            viewFrom = findPosition(structure, left);
            viewTo = findPosition(structure, right);
          }
          if (viewFrom > line.from)
            addGap(line.from, viewFrom, line, structure);
          if (viewTo < line.to)
            addGap(viewTo, line.to, line, structure);
        };
        for (let line of this.viewportLines) {
          if (Array.isArray(line.type))
            line.type.forEach(checkLine);
          else
            checkLine(line);
        }
        return gaps;
      }
      gapSize(line, from2, to, structure) {
        let fraction = findFraction(structure, to) - findFraction(structure, from2);
        if (this.heightOracle.lineWrapping) {
          return line.height * fraction;
        } else {
          return structure.total * this.heightOracle.charWidth * fraction;
        }
      }
      updateLineGaps(gaps) {
        if (!LineGap.same(gaps, this.lineGaps)) {
          this.lineGaps = gaps;
          this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping)));
        }
      }
      computeVisibleRanges(changes) {
        let deco = this.stateDeco;
        if (this.lineGaps.length)
          deco = deco.concat(this.lineGapDeco);
        let ranges = [];
        RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
          span(from2, to) {
            ranges.push({ from: from2, to });
          },
          point() {
          }
        }, 20);
        let changed = 0;
        if (ranges.length != this.visibleRanges.length) {
          changed = 8 | 4;
        } else {
          for (let i = 0; i < ranges.length && !(changed & 8); i++) {
            let old = this.visibleRanges[i], nw = ranges[i];
            if (old.from != nw.from || old.to != nw.to) {
              changed |= 4;
              if (!(changes && changes.mapPos(old.from, -1) == nw.from && changes.mapPos(old.to, 1) == nw.to))
                changed |= 8;
            }
          }
        }
        this.visibleRanges = ranges;
        return changed;
      }
      lineBlockAt(pos) {
        return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
      }
      lineBlockAtHeight(height) {
        return height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((l) => l.top <= height && l.bottom >= height) || scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
      }
      scrollAnchorAt(scrollTop) {
        let block = this.lineBlockAtHeight(scrollTop + 8);
        return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
      }
      elementAtHeight(height) {
        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
      }
      get docHeight() {
        return this.scaler.toDOM(this.heightMap.height);
      }
      get contentHeight() {
        return this.docHeight + this.paddingTop + this.paddingBottom;
      }
    };
    Viewport = class {
      constructor(from2, to) {
        this.from = from2;
        this.to = to;
      }
    };
    IdScaler = {
      toDOM(n) {
        return n;
      },
      fromDOM(n) {
        return n;
      },
      scale: 1,
      eq(other) {
        return other == this;
      }
    };
    BigScaler = class _BigScaler {
      constructor(oracle, heightMap, viewports) {
        let vpHeight = 0, base2 = 0, domBase = 0;
        this.viewports = viewports.map(({ from: from2, to }) => {
          let top2 = heightMap.lineAt(from2, QueryType.ByPos, oracle, 0, 0).top;
          let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;
          vpHeight += bottom - top2;
          return { from: from2, to, top: top2, bottom, domTop: 0, domBottom: 0 };
        });
        this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
        for (let obj of this.viewports) {
          obj.domTop = domBase + (obj.top - base2) * this.scale;
          domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
          base2 = obj.bottom;
        }
      }
      toDOM(n) {
        for (let i = 0, base2 = 0, domBase = 0; ; i++) {
          let vp = i < this.viewports.length ? this.viewports[i] : null;
          if (!vp || n < vp.top)
            return domBase + (n - base2) * this.scale;
          if (n <= vp.bottom)
            return vp.domTop + (n - vp.top);
          base2 = vp.bottom;
          domBase = vp.domBottom;
        }
      }
      fromDOM(n) {
        for (let i = 0, base2 = 0, domBase = 0; ; i++) {
          let vp = i < this.viewports.length ? this.viewports[i] : null;
          if (!vp || n < vp.domTop)
            return base2 + (n - domBase) / this.scale;
          if (n <= vp.domBottom)
            return vp.top + (n - vp.domTop);
          base2 = vp.bottom;
          domBase = vp.domBottom;
        }
      }
      eq(other) {
        if (!(other instanceof _BigScaler))
          return false;
        return this.scale == other.scale && this.viewports.length == other.viewports.length && this.viewports.every((vp, i) => vp.from == other.viewports[i].from && vp.to == other.viewports[i].to);
      }
    };
    theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
    darkTheme = /* @__PURE__ */ Facet.define({ combine: (values2) => values2.indexOf(true) > -1 });
    baseThemeID = /* @__PURE__ */ StyleModule.newName();
    baseLightID = /* @__PURE__ */ StyleModule.newName();
    baseDarkID = /* @__PURE__ */ StyleModule.newName();
    lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
    baseTheme$1 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
      "&": {
        position: "relative !important",
        boxSizing: "border-box",
        "&.cm-focused": {
          // Provide a simple default outline to make sure a focused
          // editor is visually distinct. Can't leave the default behavior
          // because that will apply to the content element, which is
          // inside the scrollable container and doesn't include the
          // gutters. We also can't use an 'auto' outline, since those
          // are, for some reason, drawn behind the element content, which
          // will cause things like the active line background to cover
          // the outline (#297).
          outline: "1px dotted #212121"
        },
        display: "flex !important",
        flexDirection: "column"
      },
      ".cm-scroller": {
        display: "flex !important",
        alignItems: "flex-start !important",
        fontFamily: "monospace",
        lineHeight: 1.4,
        height: "100%",
        overflowX: "auto",
        position: "relative",
        zIndex: 0,
        overflowAnchor: "none"
      },
      ".cm-content": {
        margin: 0,
        flexGrow: 2,
        flexShrink: 0,
        display: "block",
        whiteSpace: "pre",
        wordWrap: "normal",
        // https://github.com/codemirror/dev/issues/456
        boxSizing: "border-box",
        minHeight: "100%",
        padding: "4px 0",
        outline: "none",
        "&[contenteditable=true]": {
          WebkitUserModify: "read-write-plaintext-only"
        }
      },
      ".cm-lineWrapping": {
        whiteSpace_fallback: "pre-wrap",
        // For IE
        whiteSpace: "break-spaces",
        wordBreak: "break-word",
        // For Safari, which doesn't support overflow-wrap: anywhere
        overflowWrap: "anywhere",
        flexShrink: 1
      },
      "&light .cm-content": { caretColor: "black" },
      "&dark .cm-content": { caretColor: "white" },
      ".cm-line": {
        display: "block",
        padding: "0 2px 0 6px"
      },
      ".cm-layer": {
        position: "absolute",
        left: 0,
        top: 0,
        contain: "size style",
        "& > *": {
          position: "absolute"
        }
      },
      "&light .cm-selectionBackground": {
        background: "#d9d9d9"
      },
      "&dark .cm-selectionBackground": {
        background: "#222"
      },
      "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
        background: "#d7d4f0"
      },
      "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
        background: "#233"
      },
      ".cm-cursorLayer": {
        pointerEvents: "none"
      },
      "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
        animation: "steps(1) cm-blink 1.2s infinite"
      },
      // Two animations defined so that we can switch between them to
      // restart the animation without forcing another style
      // recomputation.
      "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
      "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
      ".cm-cursor, .cm-dropCursor": {
        borderLeft: "1.2px solid black",
        marginLeft: "-0.6px",
        pointerEvents: "none"
      },
      ".cm-cursor": {
        display: "none"
      },
      "&dark .cm-cursor": {
        borderLeftColor: "#ddd"
      },
      ".cm-dropCursor": {
        position: "absolute"
      },
      "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
        display: "block"
      },
      ".cm-iso": {
        unicodeBidi: "isolate"
      },
      ".cm-announced": {
        position: "fixed",
        top: "-10000px"
      },
      "@media print": {
        ".cm-announced": { display: "none" }
      },
      "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
      "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
      "&light .cm-specialChar": { color: "red" },
      "&dark .cm-specialChar": { color: "#f78" },
      ".cm-gutters": {
        flexShrink: 0,
        display: "flex",
        height: "100%",
        boxSizing: "border-box",
        zIndex: 200
      },
      ".cm-gutters-before": { insetInlineStart: 0 },
      ".cm-gutters-after": { insetInlineEnd: 0 },
      "&light .cm-gutters": {
        backgroundColor: "#f5f5f5",
        color: "#6c6c6c",
        border: "0px solid #ddd",
        "&.cm-gutters-before": { borderRightWidth: "1px" },
        "&.cm-gutters-after": { borderLeftWidth: "1px" }
      },
      "&dark .cm-gutters": {
        backgroundColor: "#333338",
        color: "#ccc"
      },
      ".cm-gutter": {
        display: "flex !important",
        // Necessary -- prevents margin collapsing
        flexDirection: "column",
        flexShrink: 0,
        boxSizing: "border-box",
        minHeight: "100%",
        overflow: "hidden"
      },
      ".cm-gutterElement": {
        boxSizing: "border-box"
      },
      ".cm-lineNumbers .cm-gutterElement": {
        padding: "0 3px 0 5px",
        minWidth: "20px",
        textAlign: "right",
        whiteSpace: "nowrap"
      },
      "&light .cm-activeLineGutter": {
        backgroundColor: "#e2f2ff"
      },
      "&dark .cm-activeLineGutter": {
        backgroundColor: "#222227"
      },
      ".cm-panels": {
        boxSizing: "border-box",
        position: "sticky",
        left: 0,
        right: 0,
        zIndex: 300
      },
      "&light .cm-panels": {
        backgroundColor: "#f5f5f5",
        color: "black"
      },
      "&light .cm-panels-top": {
        borderBottom: "1px solid #ddd"
      },
      "&light .cm-panels-bottom": {
        borderTop: "1px solid #ddd"
      },
      "&dark .cm-panels": {
        backgroundColor: "#333338",
        color: "white"
      },
      ".cm-dialog": {
        padding: "2px 19px 4px 6px",
        position: "relative",
        "& label": { fontSize: "80%" }
      },
      ".cm-dialog-close": {
        position: "absolute",
        top: "3px",
        right: "4px",
        backgroundColor: "inherit",
        border: "none",
        font: "inherit",
        fontSize: "14px",
        padding: "0"
      },
      ".cm-tab": {
        display: "inline-block",
        overflow: "hidden",
        verticalAlign: "bottom"
      },
      ".cm-widgetBuffer": {
        verticalAlign: "text-top",
        height: "1em",
        width: 0,
        display: "inline"
      },
      ".cm-placeholder": {
        color: "#888",
        display: "inline-block",
        verticalAlign: "top",
        userSelect: "none"
      },
      ".cm-highlightSpace": {
        backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
        backgroundPosition: "center"
      },
      ".cm-highlightTab": {
        backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
        backgroundSize: "auto 100%",
        backgroundPosition: "right 90%",
        backgroundRepeat: "no-repeat"
      },
      ".cm-trailingSpace": {
        backgroundColor: "#ff332255"
      },
      ".cm-button": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        padding: ".2em 1em",
        borderRadius: "1px"
      },
      "&light .cm-button": {
        backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
        border: "1px solid #888",
        "&:active": {
          backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
        }
      },
      "&dark .cm-button": {
        backgroundImage: "linear-gradient(#393939, #111)",
        border: "1px solid #888",
        "&:active": {
          backgroundImage: "linear-gradient(#111, #333)"
        }
      },
      ".cm-textfield": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        border: "1px solid silver",
        padding: ".2em .5em"
      },
      "&light .cm-textfield": {
        backgroundColor: "white"
      },
      "&dark .cm-textfield": {
        border: "1px solid #555",
        backgroundColor: "inherit"
      }
    }, lightDarkIDs);
    observeOptions = {
      childList: true,
      characterData: true,
      subtree: true,
      attributes: true,
      characterDataOldValue: true
    };
    useCharData = browser.ie && browser.ie_version <= 11;
    DOMObserver = class {
      constructor(view) {
        this.view = view;
        this.active = false;
        this.editContext = null;
        this.selectionRange = new DOMSelectionState();
        this.selectionChanged = false;
        this.delayedFlush = -1;
        this.resizeTimeout = -1;
        this.queue = [];
        this.delayedAndroidKey = null;
        this.flushingAndroidKey = -1;
        this.lastChange = 0;
        this.scrollTargets = [];
        this.intersection = null;
        this.resizeScroll = null;
        this.intersecting = false;
        this.gapIntersection = null;
        this.gaps = [];
        this.printQuery = null;
        this.parentCheck = -1;
        this.dom = view.contentDOM;
        this.observer = new MutationObserver((mutations) => {
          for (let mut of mutations)
            this.queue.push(mut);
          if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
            this.flushSoon();
          else
            this.flush();
        });
        if (window.EditContext && browser.android && view.constructor.EDIT_CONTEXT !== false && // Chrome <126 doesn't support inverted selections in edit context (#1392)
        !(browser.chrome && browser.chrome_version < 126)) {
          this.editContext = new EditContextManager(view);
          if (view.state.facet(editable))
            view.contentDOM.editContext = this.editContext.editContext;
        }
        if (useCharData)
          this.onCharData = (event) => {
            this.queue.push({
              target: event.target,
              type: "characterData",
              oldValue: event.prevValue
            });
            this.flushSoon();
          };
        this.onSelectionChange = this.onSelectionChange.bind(this);
        this.onResize = this.onResize.bind(this);
        this.onPrint = this.onPrint.bind(this);
        this.onScroll = this.onScroll.bind(this);
        if (window.matchMedia)
          this.printQuery = window.matchMedia("print");
        if (typeof ResizeObserver == "function") {
          this.resizeScroll = new ResizeObserver(() => {
            var _a2;
            if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75)
              this.onResize();
          });
          this.resizeScroll.observe(view.scrollDOM);
        }
        this.addWindowListeners(this.win = view.win);
        this.start();
        if (typeof IntersectionObserver == "function") {
          this.intersection = new IntersectionObserver((entries) => {
            if (this.parentCheck < 0)
              this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
            if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
              this.intersecting = !this.intersecting;
              if (this.intersecting != this.view.inView)
                this.onScrollChanged(document.createEvent("Event"));
            }
          }, { threshold: [0, 1e-3] });
          this.intersection.observe(this.dom);
          this.gapIntersection = new IntersectionObserver((entries) => {
            if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
              this.onScrollChanged(document.createEvent("Event"));
          }, {});
        }
        this.listenForScroll();
        this.readSelectionRange();
      }
      onScrollChanged(e) {
        this.view.inputState.runHandlers("scroll", e);
        if (this.intersecting)
          this.view.measure();
      }
      onScroll(e) {
        if (this.intersecting)
          this.flush(false);
        if (this.editContext)
          this.view.requestMeasure(this.editContext.measureReq);
        this.onScrollChanged(e);
      }
      onResize() {
        if (this.resizeTimeout < 0)
          this.resizeTimeout = setTimeout(() => {
            this.resizeTimeout = -1;
            this.view.requestMeasure();
          }, 50);
      }
      onPrint(event) {
        if ((event.type == "change" || !event.type) && !event.matches)
          return;
        this.view.viewState.printing = true;
        this.view.measure();
        setTimeout(() => {
          this.view.viewState.printing = false;
          this.view.requestMeasure();
        }, 500);
      }
      updateGaps(gaps) {
        if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
          this.gapIntersection.disconnect();
          for (let gap of gaps)
            this.gapIntersection.observe(gap);
          this.gaps = gaps;
        }
      }
      onSelectionChange(event) {
        let wasChanged = this.selectionChanged;
        if (!this.readSelectionRange() || this.delayedAndroidKey)
          return;
        let { view } = this, sel = this.selectionRange;
        if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel))
          return;
        let context2 = sel.anchorNode && view.docView.nearest(sel.anchorNode);
        if (context2 && context2.ignoreEvent(event)) {
          if (!wasChanged)
            this.selectionChanged = false;
          return;
        }
        if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
        sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
          this.flushSoon();
        else
          this.flush(false);
      }
      readSelectionRange() {
        let { view } = this;
        let selection2 = getSelection(view.root);
        if (!selection2)
          return false;
        let range = browser.safari && view.root.nodeType == 11 && view.root.activeElement == this.dom && safariSelectionRangeHack(this.view, selection2) || selection2;
        if (!range || this.selectionRange.eq(range))
          return false;
        let local = hasSelection(this.dom, range);
        if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
          this.view.inputState.lastFocusTime = 0;
          view.docView.updateSelection();
          return false;
        }
        this.selectionRange.setRange(range);
        if (local)
          this.selectionChanged = true;
        return true;
      }
      setSelectionRange(anchor, head) {
        this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
        this.selectionChanged = false;
      }
      clearSelectionRange() {
        this.selectionRange.set(null, 0, null, 0);
      }
      listenForScroll() {
        this.parentCheck = -1;
        let i = 0, changed = null;
        for (let dom = this.dom; dom; ) {
          if (dom.nodeType == 1) {
            if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
              i++;
            else if (!changed)
              changed = this.scrollTargets.slice(0, i);
            if (changed)
              changed.push(dom);
            dom = dom.assignedSlot || dom.parentNode;
          } else if (dom.nodeType == 11) {
            dom = dom.host;
          } else {
            break;
          }
        }
        if (i < this.scrollTargets.length && !changed)
          changed = this.scrollTargets.slice(0, i);
        if (changed) {
          for (let dom of this.scrollTargets)
            dom.removeEventListener("scroll", this.onScroll);
          for (let dom of this.scrollTargets = changed)
            dom.addEventListener("scroll", this.onScroll);
        }
      }
      ignore(f) {
        if (!this.active)
          return f();
        try {
          this.stop();
          return f();
        } finally {
          this.start();
          this.clear();
        }
      }
      start() {
        if (this.active)
          return;
        this.observer.observe(this.dom, observeOptions);
        if (useCharData)
          this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
        this.active = true;
      }
      stop() {
        if (!this.active)
          return;
        this.active = false;
        this.observer.disconnect();
        if (useCharData)
          this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
      }
      // Throw away any pending changes
      clear() {
        this.processRecords();
        this.queue.length = 0;
        this.selectionChanged = false;
      }
      // Chrome Android, especially in combination with GBoard, not only
      // doesn't reliably fire regular key events, but also often
      // surrounds the effect of enter or backspace with a bunch of
      // composition events that, when interrupted, cause text duplication
      // or other kinds of corruption. This hack makes the editor back off
      // from handling DOM changes for a moment when such a key is
      // detected (via beforeinput or keydown), and then tries to flush
      // them or, if that has no effect, dispatches the given key.
      delayAndroidKey(key, keyCode) {
        var _a2;
        if (!this.delayedAndroidKey) {
          let flush = () => {
            let key2 = this.delayedAndroidKey;
            if (key2) {
              this.clearDelayedAndroidKey();
              this.view.inputState.lastKeyCode = key2.keyCode;
              this.view.inputState.lastKeyTime = Date.now();
              let flushed = this.flush();
              if (!flushed && key2.force)
                dispatchKey(this.dom, key2.key, key2.keyCode);
            }
          };
          this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
        }
        if (!this.delayedAndroidKey || key == "Enter")
          this.delayedAndroidKey = {
            key,
            keyCode,
            // Only run the key handler when no changes are detected if
            // this isn't coming right after another change, in which case
            // it is probably part of a weird chain of updates, and should
            // be ignored if it returns the DOM to its previous state.
            force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
          };
      }
      clearDelayedAndroidKey() {
        this.win.cancelAnimationFrame(this.flushingAndroidKey);
        this.delayedAndroidKey = null;
        this.flushingAndroidKey = -1;
      }
      flushSoon() {
        if (this.delayedFlush < 0)
          this.delayedFlush = this.view.win.requestAnimationFrame(() => {
            this.delayedFlush = -1;
            this.flush();
          });
      }
      forceFlush() {
        if (this.delayedFlush >= 0) {
          this.view.win.cancelAnimationFrame(this.delayedFlush);
          this.delayedFlush = -1;
        }
        this.flush();
      }
      pendingRecords() {
        for (let mut of this.observer.takeRecords())
          this.queue.push(mut);
        return this.queue;
      }
      processRecords() {
        let records = this.pendingRecords();
        if (records.length)
          this.queue = [];
        let from2 = -1, to = -1, typeOver = false;
        for (let record of records) {
          let range = this.readMutation(record);
          if (!range)
            continue;
          if (range.typeOver)
            typeOver = true;
          if (from2 == -1) {
            ({ from: from2, to } = range);
          } else {
            from2 = Math.min(range.from, from2);
            to = Math.max(range.to, to);
          }
        }
        return { from: from2, to, typeOver };
      }
      readChange() {
        let { from: from2, to, typeOver } = this.processRecords();
        let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
        if (from2 < 0 && !newSel)
          return null;
        if (from2 > -1)
          this.lastChange = Date.now();
        this.view.inputState.lastFocusTime = 0;
        this.selectionChanged = false;
        let change = new DOMChange(this.view, from2, to, typeOver);
        this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
        return change;
      }
      // Apply pending changes, if any
      flush(readSelection = true) {
        if (this.delayedFlush >= 0 || this.delayedAndroidKey)
          return false;
        if (readSelection)
          this.readSelectionRange();
        let domChange = this.readChange();
        if (!domChange) {
          this.view.requestMeasure();
          return false;
        }
        let startState = this.view.state;
        let handled = applyDOMChange(this.view, domChange);
        if (this.view.state == startState && (domChange.domChanged || domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main)))
          this.view.update([]);
        return handled;
      }
      readMutation(rec) {
        let cView = this.view.docView.nearest(rec.target);
        if (!cView || cView.ignoreMutation(rec))
          return null;
        cView.markDirty(rec.type == "attributes");
        if (rec.type == "attributes")
          cView.flags |= 4;
        if (rec.type == "childList") {
          let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
          let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
          return {
            from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
            to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
            typeOver: false
          };
        } else if (rec.type == "characterData") {
          return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
        } else {
          return null;
        }
      }
      setWindow(win) {
        if (win != this.win) {
          this.removeWindowListeners(this.win);
          this.win = win;
          this.addWindowListeners(this.win);
        }
      }
      addWindowListeners(win) {
        win.addEventListener("resize", this.onResize);
        if (this.printQuery) {
          if (this.printQuery.addEventListener)
            this.printQuery.addEventListener("change", this.onPrint);
          else
            this.printQuery.addListener(this.onPrint);
        } else
          win.addEventListener("beforeprint", this.onPrint);
        win.addEventListener("scroll", this.onScroll);
        win.document.addEventListener("selectionchange", this.onSelectionChange);
      }
      removeWindowListeners(win) {
        win.removeEventListener("scroll", this.onScroll);
        win.removeEventListener("resize", this.onResize);
        if (this.printQuery) {
          if (this.printQuery.removeEventListener)
            this.printQuery.removeEventListener("change", this.onPrint);
          else
            this.printQuery.removeListener(this.onPrint);
        } else
          win.removeEventListener("beforeprint", this.onPrint);
        win.document.removeEventListener("selectionchange", this.onSelectionChange);
      }
      update(update) {
        if (this.editContext) {
          this.editContext.update(update);
          if (update.startState.facet(editable) != update.state.facet(editable))
            update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;
        }
      }
      destroy() {
        var _a2, _b, _c;
        this.stop();
        (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
        (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
        (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
        for (let dom of this.scrollTargets)
          dom.removeEventListener("scroll", this.onScroll);
        this.removeWindowListeners(this.win);
        clearTimeout(this.parentCheck);
        clearTimeout(this.resizeTimeout);
        this.win.cancelAnimationFrame(this.delayedFlush);
        this.win.cancelAnimationFrame(this.flushingAndroidKey);
        if (this.editContext) {
          this.view.contentDOM.editContext = null;
          this.editContext.destroy();
        }
      }
    };
    EditContextManager = class {
      constructor(view) {
        this.from = 0;
        this.to = 0;
        this.pendingContextChange = null;
        this.handlers = /* @__PURE__ */ Object.create(null);
        this.composing = null;
        this.resetRange(view.state);
        let context2 = this.editContext = new window.EditContext({
          text: view.state.doc.sliceString(this.from, this.to),
          selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),
          selectionEnd: this.toContextPos(view.state.selection.main.head)
        });
        this.handlers.textupdate = (e) => {
          let main = view.state.selection.main, { anchor, head } = main;
          let from2 = this.toEditorPos(e.updateRangeStart), to = this.toEditorPos(e.updateRangeEnd);
          if (view.inputState.composing >= 0 && !this.composing)
            this.composing = { contextBase: e.updateRangeStart, editorBase: from2, drifted: false };
          let deletes = to - from2 > e.text.length;
          if (from2 == this.from && anchor < this.from)
            from2 = anchor;
          else if (to == this.to && anchor > this.to)
            to = anchor;
          let diff = findDiff(view.state.sliceDoc(from2, to), e.text, (deletes ? main.from : main.to) - from2, deletes ? "end" : null);
          if (!diff) {
            let newSel = EditorSelection.single(this.toEditorPos(e.selectionStart), this.toEditorPos(e.selectionEnd));
            if (!newSel.main.eq(main))
              view.dispatch({ selection: newSel, userEvent: "select" });
            return;
          }
          let change = {
            from: diff.from + from2,
            to: diff.toA + from2,
            insert: Text2.of(e.text.slice(diff.from, diff.toB).split("\n"))
          };
          if ((browser.mac || browser.android) && change.from == head - 1 && /^\. ?$/.test(e.text) && view.contentDOM.getAttribute("autocorrect") == "off")
            change = { from: from2, to, insert: Text2.of([e.text.replace(".", " ")]) };
          this.pendingContextChange = change;
          if (!view.state.readOnly) {
            let newLen = this.to - this.from + (change.to - change.from + change.insert.length);
            applyDOMChangeInner(view, change, EditorSelection.single(this.toEditorPos(e.selectionStart, newLen), this.toEditorPos(e.selectionEnd, newLen)));
          }
          if (this.pendingContextChange) {
            this.revertPending(view.state);
            this.setSelection(view.state);
          }
          if (change.from < change.to && !change.insert.length && view.inputState.composing >= 0 && !/[\\p{Alphabetic}\\p{Number}_]/.test(context2.text.slice(Math.max(0, e.updateRangeStart - 1), Math.min(context2.text.length, e.updateRangeStart + 1))))
            this.handlers.compositionend(e);
        };
        this.handlers.characterboundsupdate = (e) => {
          let rects = [], prev = null;
          for (let i = this.toEditorPos(e.rangeStart), end = this.toEditorPos(e.rangeEnd); i < end; i++) {
            let rect = view.coordsForChar(i);
            prev = rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top) || prev || new DOMRect();
            rects.push(prev);
          }
          context2.updateCharacterBounds(e.rangeStart, rects);
        };
        this.handlers.textformatupdate = (e) => {
          let deco = [];
          for (let format of e.getTextFormats()) {
            let lineStyle = format.underlineStyle, thickness = format.underlineThickness;
            if (!/none/i.test(lineStyle) && !/none/i.test(thickness)) {
              let from2 = this.toEditorPos(format.rangeStart), to = this.toEditorPos(format.rangeEnd);
              if (from2 < to) {
                let style = `text-decoration: underline ${/^[a-z]/.test(lineStyle) ? lineStyle + " " : lineStyle == "Dashed" ? "dashed " : lineStyle == "Squiggle" ? "wavy " : ""}${/thin/i.test(thickness) ? 1 : 2}px`;
                deco.push(Decoration.mark({ attributes: { style } }).range(from2, to));
              }
            }
          }
          view.dispatch({ effects: setEditContextFormatting.of(Decoration.set(deco)) });
        };
        this.handlers.compositionstart = () => {
          if (view.inputState.composing < 0) {
            view.inputState.composing = 0;
            view.inputState.compositionFirstChange = true;
          }
        };
        this.handlers.compositionend = () => {
          view.inputState.composing = -1;
          view.inputState.compositionFirstChange = null;
          if (this.composing) {
            let { drifted } = this.composing;
            this.composing = null;
            if (drifted)
              this.reset(view.state);
          }
        };
        for (let event in this.handlers)
          context2.addEventListener(event, this.handlers[event]);
        this.measureReq = { read: (view2) => {
          this.editContext.updateControlBounds(view2.contentDOM.getBoundingClientRect());
          let sel = getSelection(view2.root);
          if (sel && sel.rangeCount)
            this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());
        } };
      }
      applyEdits(update) {
        let off = 0, abort = false, pending = this.pendingContextChange;
        update.changes.iterChanges((fromA, toA, _fromB, _toB, insert2) => {
          if (abort)
            return;
          let dLen = insert2.length - (toA - fromA);
          if (pending && toA >= pending.to) {
            if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert2)) {
              pending = this.pendingContextChange = null;
              off += dLen;
              this.to += dLen;
              return;
            } else {
              pending = null;
              this.revertPending(update.state);
            }
          }
          fromA += off;
          toA += off;
          if (toA <= this.from) {
            this.from += dLen;
            this.to += dLen;
          } else if (fromA < this.to) {
            if (fromA < this.from || toA > this.to || this.to - this.from + insert2.length > 3e4) {
              abort = true;
              return;
            }
            this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert2.toString());
            this.to += dLen;
          }
          off += dLen;
        });
        if (pending && !abort)
          this.revertPending(update.state);
        return !abort;
      }
      update(update) {
        let reverted = this.pendingContextChange, startSel = update.startState.selection.main;
        if (this.composing && (this.composing.drifted || !update.changes.touchesRange(startSel.from, startSel.to) && update.transactions.some((tr) => !tr.isUserEvent("input.type") && tr.changes.touchesRange(this.from, this.to)))) {
          this.composing.drifted = true;
          this.composing.editorBase = update.changes.mapPos(this.composing.editorBase);
        } else if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {
          this.pendingContextChange = null;
          this.reset(update.state);
        } else if (update.docChanged || update.selectionSet || reverted) {
          this.setSelection(update.state);
        }
        if (update.geometryChanged || update.docChanged || update.selectionSet)
          update.view.requestMeasure(this.measureReq);
      }
      resetRange(state) {
        let { head } = state.selection.main;
        this.from = Math.max(
          0,
          head - 1e4
          /* CxVp.Margin */
        );
        this.to = Math.min(
          state.doc.length,
          head + 1e4
          /* CxVp.Margin */
        );
      }
      reset(state) {
        this.resetRange(state);
        this.editContext.updateText(0, this.editContext.text.length, state.doc.sliceString(this.from, this.to));
        this.setSelection(state);
      }
      revertPending(state) {
        let pending = this.pendingContextChange;
        this.pendingContextChange = null;
        this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));
      }
      setSelection(state) {
        let { main } = state.selection;
        let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));
        let end = this.toContextPos(main.head);
        if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end)
          this.editContext.updateSelection(start, end);
      }
      rangeIsValid(state) {
        let { head } = state.selection.main;
        return !(this.from > 0 && head - this.from < 500 || this.to < state.doc.length && this.to - head < 500 || this.to - this.from > 1e4 * 3);
      }
      toEditorPos(contextPos, clipLen = this.to - this.from) {
        contextPos = Math.min(contextPos, clipLen);
        let c = this.composing;
        return c && c.drifted ? c.editorBase + (contextPos - c.contextBase) : contextPos + this.from;
      }
      toContextPos(editorPos) {
        let c = this.composing;
        return c && c.drifted ? c.contextBase + (editorPos - c.editorBase) : editorPos - this.from;
      }
      destroy() {
        for (let event in this.handlers)
          this.editContext.removeEventListener(event, this.handlers[event]);
      }
    };
    EditorView = class _EditorView {
      /**
      The current editor state.
      */
      get state() {
        return this.viewState.state;
      }
      /**
      To be able to display large documents without consuming too much
      memory or overloading the browser, CodeMirror only draws the
      code that is visible (plus a margin around it) to the DOM. This
      property tells you the extent of the current drawn viewport, in
      document positions.
      */
      get viewport() {
        return this.viewState.viewport;
      }
      /**
      When there are, for example, large collapsed ranges in the
      viewport, its size can be a lot bigger than the actual visible
      content. Thus, if you are doing something like styling the
      content in the viewport, it is preferable to only do so for
      these ranges, which are the subset of the viewport that is
      actually drawn.
      */
      get visibleRanges() {
        return this.viewState.visibleRanges;
      }
      /**
      Returns false when the editor is entirely scrolled out of view
      or otherwise hidden.
      */
      get inView() {
        return this.viewState.inView;
      }
      /**
      Indicates whether the user is currently composing text via
      [IME](https://en.wikipedia.org/wiki/Input_method), and at least
      one change has been made in the current composition.
      */
      get composing() {
        return !!this.inputState && this.inputState.composing > 0;
      }
      /**
      Indicates whether the user is currently in composing state. Note
      that on some platforms, like Android, this will be the case a
      lot, since just putting the cursor on a word starts a
      composition there.
      */
      get compositionStarted() {
        return !!this.inputState && this.inputState.composing >= 0;
      }
      /**
      The document or shadow root that the view lives in.
      */
      get root() {
        return this._root;
      }
      /**
      @internal
      */
      get win() {
        return this.dom.ownerDocument.defaultView || window;
      }
      /**
      Construct a new view. You'll want to either provide a `parent`
      option, or put `view.dom` into your document after creating a
      view, so that the user can see the editor.
      */
      constructor(config3 = {}) {
        var _a2;
        this.plugins = [];
        this.pluginMap = /* @__PURE__ */ new Map();
        this.editorAttrs = {};
        this.contentAttrs = {};
        this.bidiCache = [];
        this.destroyed = false;
        this.updateState = 2;
        this.measureScheduled = -1;
        this.measureRequests = [];
        this.contentDOM = document.createElement("div");
        this.scrollDOM = document.createElement("div");
        this.scrollDOM.tabIndex = -1;
        this.scrollDOM.className = "cm-scroller";
        this.scrollDOM.appendChild(this.contentDOM);
        this.announceDOM = document.createElement("div");
        this.announceDOM.className = "cm-announced";
        this.announceDOM.setAttribute("aria-live", "polite");
        this.dom = document.createElement("div");
        this.dom.appendChild(this.announceDOM);
        this.dom.appendChild(this.scrollDOM);
        if (config3.parent)
          config3.parent.appendChild(this.dom);
        let { dispatch } = config3;
        this.dispatchTransactions = config3.dispatchTransactions || dispatch && ((trs) => trs.forEach((tr) => dispatch(tr, this))) || ((trs) => this.update(trs));
        this.dispatch = this.dispatch.bind(this);
        this._root = config3.root || getRoot(config3.parent) || document;
        this.viewState = new ViewState(config3.state || EditorState.create(config3));
        if (config3.scrollTo && config3.scrollTo.is(scrollIntoView))
          this.viewState.scrollTarget = config3.scrollTo.value.clip(this.viewState.state);
        this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
        for (let plugin of this.plugins)
          plugin.update(this);
        this.observer = new DOMObserver(this);
        this.inputState = new InputState(this);
        this.inputState.ensureHandlers(this.plugins);
        this.docView = new DocView(this);
        this.mountStyles();
        this.updateAttrs();
        this.updateState = 0;
        this.requestMeasure();
        if ((_a2 = document.fonts) === null || _a2 === void 0 ? void 0 : _a2.ready)
          document.fonts.ready.then(() => this.requestMeasure());
      }
      dispatch(...input2) {
        let trs = input2.length == 1 && input2[0] instanceof Transaction ? input2 : input2.length == 1 && Array.isArray(input2[0]) ? input2[0] : [this.state.update(...input2)];
        this.dispatchTransactions(trs, this);
      }
      /**
      Update the view for the given array of transactions. This will
      update the visible document and selection to match the state
      produced by the transactions, and notify view plugins of the
      change. You should usually call
      [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
      as a primitive.
      */
      update(transactions) {
        if (this.updateState != 0)
          throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
        let redrawn = false, attrsChanged = false, update;
        let state = this.state;
        for (let tr of transactions) {
          if (tr.startState != state)
            throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
          state = tr.state;
        }
        if (this.destroyed) {
          this.viewState.state = state;
          return;
        }
        let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
        if (transactions.some((tr) => tr.annotation(isFocusChange))) {
          this.inputState.notifiedFocused = focus;
          focusFlag = 1;
        } else if (focus != this.inputState.notifiedFocused) {
          this.inputState.notifiedFocused = focus;
          dispatchFocus = focusChangeTransaction(state, focus);
          if (!dispatchFocus)
            focusFlag = 1;
        }
        let pendingKey = this.observer.delayedAndroidKey, domChange = null;
        if (pendingKey) {
          this.observer.clearDelayedAndroidKey();
          domChange = this.observer.readChange();
          if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
            domChange = null;
        } else {
          this.observer.clear();
        }
        if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
          return this.setState(state);
        update = ViewUpdate.create(this, state, transactions);
        update.flags |= focusFlag;
        let scrollTarget = this.viewState.scrollTarget;
        try {
          this.updateState = 2;
          for (let tr of transactions) {
            if (scrollTarget)
              scrollTarget = scrollTarget.map(tr.changes);
            if (tr.scrollIntoView) {
              let { main } = tr.state.selection;
              scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
            }
            for (let e of tr.effects)
              if (e.is(scrollIntoView))
                scrollTarget = e.value.clip(this.state);
          }
          this.viewState.update(update, scrollTarget);
          this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
          if (!update.empty) {
            this.updatePlugins(update);
            this.inputState.update(update);
          }
          redrawn = this.docView.update(update);
          if (this.state.facet(styleModule) != this.styleModules)
            this.mountStyles();
          attrsChanged = this.updateAttrs();
          this.showAnnouncements(transactions);
          this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
        } finally {
          this.updateState = 0;
        }
        if (update.startState.facet(theme) != update.state.facet(theme))
          this.viewState.mustMeasureContent = true;
        if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
          this.requestMeasure();
        if (redrawn)
          this.docViewUpdate();
        if (!update.empty)
          for (let listener of this.state.facet(updateListener)) {
            try {
              listener(update);
            } catch (e) {
              logException(this.state, e, "update listener");
            }
          }
        if (dispatchFocus || domChange)
          Promise.resolve().then(() => {
            if (dispatchFocus && this.state == dispatchFocus.startState)
              this.dispatch(dispatchFocus);
            if (domChange) {
              if (!applyDOMChange(this, domChange) && pendingKey.force)
                dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
            }
          });
      }
      /**
      Reset the view to the given state. (This will cause the entire
      document to be redrawn and all view plugins to be reinitialized,
      so you should probably only use it when the new state isn't
      derived from the old state. Otherwise, use
      [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
      */
      setState(newState) {
        if (this.updateState != 0)
          throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
        if (this.destroyed) {
          this.viewState.state = newState;
          return;
        }
        this.updateState = 2;
        let hadFocus = this.hasFocus;
        try {
          for (let plugin of this.plugins)
            plugin.destroy(this);
          this.viewState = new ViewState(newState);
          this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
          this.pluginMap.clear();
          for (let plugin of this.plugins)
            plugin.update(this);
          this.docView.destroy();
          this.docView = new DocView(this);
          this.inputState.ensureHandlers(this.plugins);
          this.mountStyles();
          this.updateAttrs();
          this.bidiCache = [];
        } finally {
          this.updateState = 0;
        }
        if (hadFocus)
          this.focus();
        this.requestMeasure();
      }
      updatePlugins(update) {
        let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
        if (prevSpecs != specs) {
          let newPlugins = [];
          for (let spec of specs) {
            let found = prevSpecs.indexOf(spec);
            if (found < 0) {
              newPlugins.push(new PluginInstance(spec));
            } else {
              let plugin = this.plugins[found];
              plugin.mustUpdate = update;
              newPlugins.push(plugin);
            }
          }
          for (let plugin of this.plugins)
            if (plugin.mustUpdate != update)
              plugin.destroy(this);
          this.plugins = newPlugins;
          this.pluginMap.clear();
        } else {
          for (let p of this.plugins)
            p.mustUpdate = update;
        }
        for (let i = 0; i < this.plugins.length; i++)
          this.plugins[i].update(this);
        if (prevSpecs != specs)
          this.inputState.ensureHandlers(this.plugins);
      }
      docViewUpdate() {
        for (let plugin of this.plugins) {
          let val = plugin.value;
          if (val && val.docViewUpdate) {
            try {
              val.docViewUpdate(this);
            } catch (e) {
              logException(this.state, e, "doc view update listener");
            }
          }
        }
      }
      /**
      @internal
      */
      measure(flush = true) {
        if (this.destroyed)
          return;
        if (this.measureScheduled > -1)
          this.win.cancelAnimationFrame(this.measureScheduled);
        if (this.observer.delayedAndroidKey) {
          this.measureScheduled = -1;
          this.requestMeasure();
          return;
        }
        this.measureScheduled = 0;
        if (flush)
          this.observer.forceFlush();
        let updated = null;
        let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
        let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
        if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
          scrollAnchorHeight = -1;
        this.viewState.scrollAnchorHeight = -1;
        try {
          for (let i = 0; ; i++) {
            if (scrollAnchorHeight < 0) {
              if (isScrolledToBottom(sDOM)) {
                scrollAnchorPos = -1;
                scrollAnchorHeight = this.viewState.heightMap.height;
              } else {
                let block = this.viewState.scrollAnchorAt(scrollTop);
                scrollAnchorPos = block.from;
                scrollAnchorHeight = block.top;
              }
            }
            this.updateState = 1;
            let changed = this.viewState.measure(this);
            if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
              break;
            if (i > 5) {
              console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
              break;
            }
            let measuring = [];
            if (!(changed & 4))
              [this.measureRequests, measuring] = [measuring, this.measureRequests];
            let measured = measuring.map((m) => {
              try {
                return m.read(this);
              } catch (e) {
                logException(this.state, e);
                return BadMeasure;
              }
            });
            let update = ViewUpdate.create(this, this.state, []), redrawn = false;
            update.flags |= changed;
            if (!updated)
              updated = update;
            else
              updated.flags |= changed;
            this.updateState = 2;
            if (!update.empty) {
              this.updatePlugins(update);
              this.inputState.update(update);
              this.updateAttrs();
              redrawn = this.docView.update(update);
              if (redrawn)
                this.docViewUpdate();
            }
            for (let i2 = 0; i2 < measuring.length; i2++)
              if (measured[i2] != BadMeasure) {
                try {
                  let m = measuring[i2];
                  if (m.write)
                    m.write(measured[i2], this);
                } catch (e) {
                  logException(this.state, e);
                }
              }
            if (redrawn)
              this.docView.updateSelection(true);
            if (!update.viewportChanged && this.measureRequests.length == 0) {
              if (this.viewState.editorHeight) {
                if (this.viewState.scrollTarget) {
                  this.docView.scrollIntoView(this.viewState.scrollTarget);
                  this.viewState.scrollTarget = null;
                  scrollAnchorHeight = -1;
                  continue;
                } else {
                  let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
                  let diff = newAnchorHeight - scrollAnchorHeight;
                  if (diff > 1 || diff < -1) {
                    scrollTop = scrollTop + diff;
                    sDOM.scrollTop = scrollTop / this.scaleY;
                    scrollAnchorHeight = -1;
                    continue;
                  }
                }
              }
              break;
            }
          }
        } finally {
          this.updateState = 0;
          this.measureScheduled = -1;
        }
        if (updated && !updated.empty)
          for (let listener of this.state.facet(updateListener))
            listener(updated);
      }
      /**
      Get the CSS classes for the currently active editor themes.
      */
      get themeClasses() {
        return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
      }
      updateAttrs() {
        let editorAttrs = attrsFromFacet(this, editorAttributes, {
          class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
        });
        let contentAttrs = {
          spellcheck: "false",
          autocorrect: "off",
          autocapitalize: "off",
          writingsuggestions: "false",
          translate: "no",
          contenteditable: !this.state.facet(editable) ? "false" : "true",
          class: "cm-content",
          style: `${browser.tabSize}: ${this.state.tabSize}`,
          role: "textbox",
          "aria-multiline": "true"
        };
        if (this.state.readOnly)
          contentAttrs["aria-readonly"] = "true";
        attrsFromFacet(this, contentAttributes, contentAttrs);
        let changed = this.observer.ignore(() => {
          let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
          let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
          return changedContent || changedEditor;
        });
        this.editorAttrs = editorAttrs;
        this.contentAttrs = contentAttrs;
        return changed;
      }
      showAnnouncements(trs) {
        let first2 = true;
        for (let tr of trs)
          for (let effect2 of tr.effects)
            if (effect2.is(_EditorView.announce)) {
              if (first2)
                this.announceDOM.textContent = "";
              first2 = false;
              let div = this.announceDOM.appendChild(document.createElement("div"));
              div.textContent = effect2.value;
            }
      }
      mountStyles() {
        this.styleModules = this.state.facet(styleModule);
        let nonce = this.state.facet(_EditorView.cspNonce);
        StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : void 0);
      }
      readMeasured() {
        if (this.updateState == 2)
          throw new Error("Reading the editor layout isn't allowed during an update");
        if (this.updateState == 0 && this.measureScheduled > -1)
          this.measure(false);
      }
      /**
      Schedule a layout measurement, optionally providing callbacks to
      do custom DOM measuring followed by a DOM write phase. Using
      this is preferable reading DOM layout directly from, for
      example, an event handler, because it'll make sure measuring and
      drawing done by other components is synchronized, avoiding
      unnecessary DOM layout computations.
      */
      requestMeasure(request) {
        if (this.measureScheduled < 0)
          this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
        if (request) {
          if (this.measureRequests.indexOf(request) > -1)
            return;
          if (request.key != null)
            for (let i = 0; i < this.measureRequests.length; i++) {
              if (this.measureRequests[i].key === request.key) {
                this.measureRequests[i] = request;
                return;
              }
            }
          this.measureRequests.push(request);
        }
      }
      /**
      Get the value of a specific plugin, if present. Note that
      plugins that crash can be dropped from a view, so even when you
      know you registered a given plugin, it is recommended to check
      the return value of this method.
      */
      plugin(plugin) {
        let known = this.pluginMap.get(plugin);
        if (known === void 0 || known && known.plugin != plugin)
          this.pluginMap.set(plugin, known = this.plugins.find((p) => p.plugin == plugin) || null);
        return known && known.update(this).value;
      }
      /**
      The top position of the document, in screen coordinates. This
      may be negative when the editor is scrolled down. Points
      directly to the top of the first line, not above the padding.
      */
      get documentTop() {
        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
      }
      /**
      Reports the padding above and below the document.
      */
      get documentPadding() {
        return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
      }
      /**
      If the editor is transformed with CSS, this provides the scale
      along the X axis. Otherwise, it will just be 1. Note that
      transforms other than translation and scaling are not supported.
      */
      get scaleX() {
        return this.viewState.scaleX;
      }
      /**
      Provide the CSS transformed scale along the Y axis.
      */
      get scaleY() {
        return this.viewState.scaleY;
      }
      /**
      Find the text line or block widget at the given vertical
      position (which is interpreted as relative to the [top of the
      document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
      */
      elementAtHeight(height) {
        this.readMeasured();
        return this.viewState.elementAtHeight(height);
      }
      /**
      Find the line block (see
      [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt)) at the given
      height, again interpreted relative to the [top of the
      document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
      */
      lineBlockAtHeight(height) {
        this.readMeasured();
        return this.viewState.lineBlockAtHeight(height);
      }
      /**
      Get the extent and vertical position of all [line
      blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
      are relative to the [top of the
      document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
      */
      get viewportLineBlocks() {
        return this.viewState.viewportLines;
      }
      /**
      Find the line block around the given document position. A line
      block is a range delimited on both sides by either a
      non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
      start/end of the document. It will usually just hold a line of
      text, but may be broken into multiple textblocks by block
      widgets.
      */
      lineBlockAt(pos) {
        return this.viewState.lineBlockAt(pos);
      }
      /**
      The editor's total content height.
      */
      get contentHeight() {
        return this.viewState.contentHeight;
      }
      /**
      Move a cursor position by [grapheme
      cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
      the motion is away from the line start, or towards it. In
      bidirectional text, the line is traversed in visual order, using
      the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
      When the start position was the last one on the line, the
      returned position will be across the line break. If there is no
      further line, the original position is returned.
      
      By default, this method moves over a single cluster. The
      optional `by` argument can be used to move across more. It will
      be called with the first cluster as argument, and should return
      a predicate that determines, for each subsequent cluster,
      whether it should also be moved over.
      */
      moveByChar(start, forward, by) {
        return skipAtoms(this, start, moveByChar(this, start, forward, by));
      }
      /**
      Move a cursor position across the next group of either
      [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
      non-whitespace characters.
      */
      moveByGroup(start, forward) {
        return skipAtoms(this, start, moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial)));
      }
      /**
      Get the cursor position visually at the start or end of a line.
      Note that this may differ from the _logical_ position at its
      start or end (which is simply at `line.from`/`line.to`) if text
      at the start or end goes against the line's base text direction.
      */
      visualLineSide(line, end) {
        let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);
        let span = order[end ? order.length - 1 : 0];
        return EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);
      }
      /**
      Move to the next line boundary in the given direction. If
      `includeWrap` is true, line wrapping is on, and there is a
      further wrap point on the current line, the wrap point will be
      returned. Otherwise this function will return the start or end
      of the line.
      */
      moveToLineBoundary(start, forward, includeWrap = true) {
        return moveToLineBoundary(this, start, forward, includeWrap);
      }
      /**
      Move a cursor position vertically. When `distance` isn't given,
      it defaults to moving to the next line (including wrapped
      lines). Otherwise, `distance` should provide a positive distance
      in pixels.
      
      When `start` has a
      [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
      motion will use that as a target horizontal position. Otherwise,
      the cursor's own horizontal position is used. The returned
      cursor will have its goal column set to whichever column was
      used.
      */
      moveVertically(start, forward, distance) {
        return skipAtoms(this, start, moveVertically(this, start, forward, distance));
      }
      /**
      Find the DOM parent node and offset (child offset if `node` is
      an element, character offset when it is a text node) at the
      given document position.
      
      Note that for positions that aren't currently in
      `visibleRanges`, the resulting DOM position isn't necessarily
      meaningful (it may just point before or after a placeholder
      element).
      */
      domAtPos(pos) {
        return this.docView.domAtPos(pos);
      }
      /**
      Find the document position at the given DOM node. Can be useful
      for associating positions with DOM events. Will raise an error
      when `node` isn't part of the editor content.
      */
      posAtDOM(node, offset = 0) {
        return this.docView.posFromDOM(node, offset);
      }
      posAtCoords(coords, precise = true) {
        this.readMeasured();
        return posAtCoords(this, coords, precise);
      }
      /**
      Get the screen coordinates at the given document position.
      `side` determines whether the coordinates are based on the
      element before (-1) or after (1) the position (if no element is
      available on the given side, the method will transparently use
      another strategy to get reasonable coordinates).
      */
      coordsAtPos(pos, side = 1) {
        this.readMeasured();
        let rect = this.docView.coordsAt(pos, side);
        if (!rect || rect.left == rect.right)
          return rect;
        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
        let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
        return flattenRect(rect, span.dir == Direction.LTR == side > 0);
      }
      /**
      Return the rectangle around a given character. If `pos` does not
      point in front of a character that is in the viewport and
      rendered (i.e. not replaced, not a line break), this will return
      null. For space characters that are a line wrap point, this will
      return the position before the line break.
      */
      coordsForChar(pos) {
        this.readMeasured();
        return this.docView.coordsForChar(pos);
      }
      /**
      The default width of a character in the editor. May not
      accurately reflect the width of all characters (given variable
      width fonts or styling of invididual ranges).
      */
      get defaultCharacterWidth() {
        return this.viewState.heightOracle.charWidth;
      }
      /**
      The default height of a line in the editor. May not be accurate
      for all lines.
      */
      get defaultLineHeight() {
        return this.viewState.heightOracle.lineHeight;
      }
      /**
      The text direction
      ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
      CSS property) of the editor's content element.
      */
      get textDirection() {
        return this.viewState.defaultTextDirection;
      }
      /**
      Find the text direction of the block at the given position, as
      assigned by CSS. If
      [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
      isn't enabled, or the given position is outside of the viewport,
      this will always return the same as
      [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
      this may trigger a DOM layout.
      */
      textDirectionAt(pos) {
        let perLine = this.state.facet(perLineTextDirection);
        if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
          return this.textDirection;
        this.readMeasured();
        return this.docView.textDirectionAt(pos);
      }
      /**
      Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
      (as determined by the
      [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
      CSS property of its content element).
      */
      get lineWrapping() {
        return this.viewState.heightOracle.lineWrapping;
      }
      /**
      Returns the bidirectional text structure of the given line
      (which should be in the current document) as an array of span
      objects. The order of these spans matches the [text
      direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
      left-to-right, the leftmost spans come first, otherwise the
      rightmost spans come first.
      */
      bidiSpans(line) {
        if (line.length > MaxBidiLine)
          return trivialOrder(line.length);
        let dir = this.textDirectionAt(line.from), isolates;
        for (let entry of this.bidiCache) {
          if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line))))
            return entry.order;
        }
        if (!isolates)
          isolates = getIsolatedRanges(this, line);
        let order = computeOrder(line.text, dir, isolates);
        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
        return order;
      }
      /**
      Check whether the editor has focus.
      */
      get hasFocus() {
        var _a2;
        return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
      }
      /**
      Put focus on the editor.
      */
      focus() {
        this.observer.ignore(() => {
          focusPreventScroll(this.contentDOM);
          this.docView.updateSelection();
        });
      }
      /**
      Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
      necessary when moving the editor's existing DOM to a new window or shadow root.
      */
      setRoot(root) {
        if (this._root != root) {
          this._root = root;
          this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
          this.mountStyles();
        }
      }
      /**
      Clean up this editor view, removing its element from the
      document, unregistering event handlers, and notifying
      plugins. The view instance can no longer be used after
      calling this.
      */
      destroy() {
        if (this.root.activeElement == this.contentDOM)
          this.contentDOM.blur();
        for (let plugin of this.plugins)
          plugin.destroy(this);
        this.plugins = [];
        this.inputState.destroy();
        this.docView.destroy();
        this.dom.remove();
        this.observer.destroy();
        if (this.measureScheduled > -1)
          this.win.cancelAnimationFrame(this.measureScheduled);
        this.destroyed = true;
      }
      /**
      Returns an effect that can be
      [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
      cause it to scroll the given position or range into view.
      */
      static scrollIntoView(pos, options = {}) {
        return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
      }
      /**
      Return an effect that resets the editor to its current (at the
      time this method was called) scroll position. Note that this
      only affects the editor's own scrollable element, not parents.
      See also
      [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
      
      The effect should be used with a document identical to the one
      it was created for. Failing to do so is not an error, but may
      not scroll to the expected position. You can
      [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
      */
      scrollSnapshot() {
        let { scrollTop, scrollLeft } = this.scrollDOM;
        let ref = this.viewState.scrollAnchorAt(scrollTop);
        return scrollIntoView.of(new ScrollTarget(EditorSelection.cursor(ref.from), "start", "start", ref.top - scrollTop, scrollLeft, true));
      }
      /**
      Enable or disable tab-focus mode, which disables key bindings
      for Tab and Shift-Tab, letting the browser's default
      focus-changing behavior go through instead. This is useful to
      prevent trapping keyboard users in your editor.
      
      Without argument, this toggles the mode. With a boolean, it
      enables (true) or disables it (false). Given a number, it
      temporarily enables the mode until that number of milliseconds
      have passed or another non-Tab key is pressed.
      */
      setTabFocusMode(to) {
        if (to == null)
          this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;
        else if (typeof to == "boolean")
          this.inputState.tabFocusMode = to ? 0 : -1;
        else if (this.inputState.tabFocusMode != 0)
          this.inputState.tabFocusMode = Date.now() + to;
      }
      /**
      Returns an extension that can be used to add DOM event handlers.
      The value should be an object mapping event names to handler
      functions. For any given event, such functions are ordered by
      extension precedence, and the first handler to return true will
      be assumed to have handled that event, and no other handlers or
      built-in behavior will be activated for it. These are registered
      on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
      for `scroll` handlers, which will be called any time the
      editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
      its parent nodes is scrolled.
      */
      static domEventHandlers(handlers2) {
        return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
      }
      /**
      Create an extension that registers DOM event observers. Contrary
      to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
      observers can't be prevented from running by a higher-precedence
      handler returning true. They also don't prevent other handlers
      and observers from running when they return true, and should not
      call `preventDefault`.
      */
      static domEventObservers(observers2) {
        return ViewPlugin.define(() => ({}), { eventObservers: observers2 });
      }
      /**
      Create a theme extension. The first argument can be a
      [`style-mod`](https://github.com/marijnh/style-mod#documentation)
      style spec providing the styles for the theme. These will be
      prefixed with a generated class for the style.
      
      Because the selectors will be prefixed with a scope class, rule
      that directly match the editor's [wrapper
      element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
      addedneed to be explicitly differentiated by adding an `&` to
      the selector for that elementfor example
      `&.cm-focused`.
      
      When `dark` is set to true, the theme will be marked as dark,
      which will cause the `&dark` rules from [base
      themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
      `&light` when a light theme is active).
      */
      static theme(spec, options) {
        let prefix = StyleModule.newName();
        let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
        if (options && options.dark)
          result.push(darkTheme.of(true));
        return result;
      }
      /**
      Create an extension that adds styles to the base theme. Like
      with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
      place of the editor wrapper element when directly targeting
      that. You can also use `&dark` or `&light` instead to only
      target editors with a dark or light theme.
      */
      static baseTheme(spec) {
        return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
      }
      /**
      Retrieve an editor view instance from the view's DOM
      representation.
      */
      static findFromDOM(dom) {
        var _a2;
        let content2 = dom.querySelector(".cm-content");
        let cView = content2 && ContentView.get(content2) || ContentView.get(dom);
        return ((_a2 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
      }
    };
    EditorView.styleModule = styleModule;
    EditorView.inputHandler = inputHandler;
    EditorView.clipboardInputFilter = clipboardInputFilter;
    EditorView.clipboardOutputFilter = clipboardOutputFilter;
    EditorView.scrollHandler = scrollHandler;
    EditorView.focusChangeEffect = focusChangeEffect;
    EditorView.perLineTextDirection = perLineTextDirection;
    EditorView.exceptionSink = exceptionSink;
    EditorView.updateListener = updateListener;
    EditorView.editable = editable;
    EditorView.mouseSelectionStyle = mouseSelectionStyle;
    EditorView.dragMovesSelection = dragMovesSelection$1;
    EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
    EditorView.decorations = decorations;
    EditorView.outerDecorations = outerDecorations;
    EditorView.atomicRanges = atomicRanges;
    EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
    EditorView.scrollMargins = scrollMargins;
    EditorView.darkTheme = darkTheme;
    EditorView.cspNonce = /* @__PURE__ */ Facet.define({ combine: (values2) => values2.length ? values2[0] : "" });
    EditorView.contentAttributes = contentAttributes;
    EditorView.editorAttributes = editorAttributes;
    EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
    EditorView.announce = /* @__PURE__ */ StateEffect.define();
    MaxBidiLine = 4096;
    BadMeasure = {};
    CachedOrder = class _CachedOrder {
      constructor(from2, to, dir, isolates, fresh, order) {
        this.from = from2;
        this.to = to;
        this.dir = dir;
        this.isolates = isolates;
        this.fresh = fresh;
        this.order = order;
      }
      static update(cache3, changes) {
        if (changes.empty && !cache3.some((c) => c.fresh))
          return cache3;
        let result = [], lastDir = cache3.length ? cache3[cache3.length - 1].dir : Direction.LTR;
        for (let i = Math.max(0, cache3.length - 10); i < cache3.length; i++) {
          let entry = cache3[i];
          if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
            result.push(new _CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
        }
        return result;
      }
    };
    currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
    handleKeyEvents = /* @__PURE__ */ Prec.default(/* @__PURE__ */ EditorView.domEventHandlers({
      keydown(event, view) {
        return runHandlers(getKeymap(view.state), event, view, "editor");
      }
    }));
    keymap = /* @__PURE__ */ Facet.define({ enables: handleKeyEvents });
    Keymaps = /* @__PURE__ */ new WeakMap();
    storedPrefix = null;
    PrefixTimeout = 4e3;
    currentKeyEvent = null;
    RectangleMarker = class _RectangleMarker {
      /**
      Create a marker with the given class and dimensions. If `width`
      is null, the DOM element will get no width style.
      */
      constructor(className, left, top2, width, height) {
        this.className = className;
        this.left = left;
        this.top = top2;
        this.width = width;
        this.height = height;
      }
      draw() {
        let elt2 = document.createElement("div");
        elt2.className = this.className;
        this.adjust(elt2);
        return elt2;
      }
      update(elt2, prev) {
        if (prev.className != this.className)
          return false;
        this.adjust(elt2);
        return true;
      }
      adjust(elt2) {
        elt2.style.left = this.left + "px";
        elt2.style.top = this.top + "px";
        if (this.width != null)
          elt2.style.width = this.width + "px";
        elt2.style.height = this.height + "px";
      }
      eq(p) {
        return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
      }
      /**
      Create a set of rectangles for the given selection range,
      assigning them theclass`className`. Will create a single
      rectangle for empty ranges, and a set of selection-style
      rectangles covering the range's content (in a bidi-aware
      way) for non-empty ones.
      */
      static forRange(view, className, range) {
        if (range.empty) {
          let pos = view.coordsAtPos(range.head, range.assoc || 1);
          if (!pos)
            return [];
          let base2 = getBase(view);
          return [new _RectangleMarker(className, pos.left - base2.left, pos.top - base2.top, null, pos.bottom - pos.top)];
        } else {
          return rectanglesForRange(view, className, range);
        }
      }
    };
    LayerView = class {
      constructor(view, layer2) {
        this.view = view;
        this.layer = layer2;
        this.drawn = [];
        this.scaleX = 1;
        this.scaleY = 1;
        this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };
        this.dom = view.scrollDOM.appendChild(document.createElement("div"));
        this.dom.classList.add("cm-layer");
        if (layer2.above)
          this.dom.classList.add("cm-layer-above");
        if (layer2.class)
          this.dom.classList.add(layer2.class);
        this.scale();
        this.dom.setAttribute("aria-hidden", "true");
        this.setOrder(view.state);
        view.requestMeasure(this.measureReq);
        if (layer2.mount)
          layer2.mount(this.dom, view);
      }
      update(update) {
        if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
          this.setOrder(update.state);
        if (this.layer.update(update, this.dom) || update.geometryChanged) {
          this.scale();
          update.view.requestMeasure(this.measureReq);
        }
      }
      docViewUpdate(view) {
        if (this.layer.updateOnDocViewUpdate !== false)
          view.requestMeasure(this.measureReq);
      }
      setOrder(state) {
        let pos = 0, order = state.facet(layerOrder);
        while (pos < order.length && order[pos] != this.layer)
          pos++;
        this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
      }
      measure() {
        return this.layer.markers(this.view);
      }
      scale() {
        let { scaleX, scaleY } = this.view;
        if (scaleX != this.scaleX || scaleY != this.scaleY) {
          this.scaleX = scaleX;
          this.scaleY = scaleY;
          this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
        }
      }
      draw(markers) {
        if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {
          let old = this.dom.firstChild, oldI = 0;
          for (let marker of markers) {
            if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {
              old = old.nextSibling;
              oldI++;
            } else {
              this.dom.insertBefore(marker.draw(), old);
            }
          }
          while (old) {
            let next = old.nextSibling;
            old.remove();
            old = next;
          }
          this.drawn = markers;
          if (browser.safari && browser.safari_version >= 26)
            this.dom.style.display = this.dom.firstChild ? "" : "none";
        }
      }
      destroy() {
        if (this.layer.destroy)
          this.layer.destroy(this.dom, this.view);
        this.dom.remove();
      }
    };
    layerOrder = /* @__PURE__ */ Facet.define();
    selectionConfig = /* @__PURE__ */ Facet.define({
      combine(configs) {
        return combineConfig(configs, {
          cursorBlinkRate: 1200,
          drawRangeCursor: true
        }, {
          cursorBlinkRate: (a, b) => Math.min(a, b),
          drawRangeCursor: (a, b) => a || b
        });
      }
    });
    cursorLayer = /* @__PURE__ */ layer({
      above: true,
      markers(view) {
        let { state } = view, conf = state.facet(selectionConfig);
        let cursors = [];
        for (let r of state.selection.ranges) {
          let prim = r == state.selection.main;
          if (r.empty || conf.drawRangeCursor) {
            let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
            let cursor2 = r.empty ? r : EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);
            for (let piece of RectangleMarker.forRange(view, className, cursor2))
              cursors.push(piece);
          }
        }
        return cursors;
      },
      update(update, dom) {
        if (update.transactions.some((tr) => tr.selection))
          dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
        let confChange = configChanged(update);
        if (confChange)
          setBlinkRate(update.state, dom);
        return update.docChanged || update.selectionSet || confChange;
      },
      mount(dom, view) {
        setBlinkRate(view.state, dom);
      },
      class: "cm-cursorLayer"
    });
    selectionLayer = /* @__PURE__ */ layer({
      above: false,
      markers(view) {
        return view.state.selection.ranges.map((r) => r.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r)).reduce((a, b) => a.concat(b));
      },
      update(update, dom) {
        return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
      },
      class: "cm-selectionLayer"
    });
    hideNativeSelection = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.theme({
      ".cm-line": {
        "& ::selection, &::selection": { backgroundColor: "transparent !important" },
        caretColor: "transparent !important"
      },
      ".cm-content": {
        caretColor: "transparent !important",
        "& :focus": {
          caretColor: "initial !important",
          "&::selection, & ::selection": {
            backgroundColor: "Highlight !important"
          }
        }
      }
    }));
    setDropCursorPos = /* @__PURE__ */ StateEffect.define({
      map(pos, mapping) {
        return pos == null ? null : mapping.mapPos(pos);
      }
    });
    dropCursorPos = /* @__PURE__ */ StateField.define({
      create() {
        return null;
      },
      update(pos, tr) {
        if (pos != null)
          pos = tr.changes.mapPos(pos);
        return tr.effects.reduce((pos2, e) => e.is(setDropCursorPos) ? e.value : pos2, pos);
      }
    });
    drawDropCursor = /* @__PURE__ */ ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.cursor = null;
        this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
      }
      update(update) {
        var _a2;
        let cursorPos = update.state.field(dropCursorPos);
        if (cursorPos == null) {
          if (this.cursor != null) {
            (_a2 = this.cursor) === null || _a2 === void 0 ? void 0 : _a2.remove();
            this.cursor = null;
          }
        } else {
          if (!this.cursor) {
            this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
            this.cursor.className = "cm-dropCursor";
          }
          if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
            this.view.requestMeasure(this.measureReq);
        }
      }
      readPos() {
        let { view } = this;
        let pos = view.state.field(dropCursorPos);
        let rect = pos != null && view.coordsAtPos(pos);
        if (!rect)
          return null;
        let outer = view.scrollDOM.getBoundingClientRect();
        return {
          left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,
          top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,
          height: rect.bottom - rect.top
        };
      }
      drawCursor(pos) {
        if (this.cursor) {
          let { scaleX, scaleY } = this.view;
          if (pos) {
            this.cursor.style.left = pos.left / scaleX + "px";
            this.cursor.style.top = pos.top / scaleY + "px";
            this.cursor.style.height = pos.height / scaleY + "px";
          } else {
            this.cursor.style.left = "-100000px";
          }
        }
      }
      destroy() {
        if (this.cursor)
          this.cursor.remove();
      }
      setDropPos(pos) {
        if (this.view.state.field(dropCursorPos) != pos)
          this.view.dispatch({ effects: setDropCursorPos.of(pos) });
      }
    }, {
      eventObservers: {
        dragover(event) {
          this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));
        },
        dragleave(event) {
          if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
            this.setDropPos(null);
        },
        dragend() {
          this.setDropPos(null);
        },
        drop() {
          this.setDropPos(null);
        }
      }
    });
    MatchDecorator = class {
      /**
      Create a decorator.
      */
      constructor(config3) {
        const { regexp, decoration, decorate, boundary, maxLength = 1e3 } = config3;
        if (!regexp.global)
          throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
        this.regexp = regexp;
        if (decorate) {
          this.addMatch = (match2, view, from2, add2) => decorate(add2, from2, from2 + match2[0].length, match2, view);
        } else if (typeof decoration == "function") {
          this.addMatch = (match2, view, from2, add2) => {
            let deco = decoration(match2, view, from2);
            if (deco)
              add2(from2, from2 + match2[0].length, deco);
          };
        } else if (decoration) {
          this.addMatch = (match2, _view, from2, add2) => add2(from2, from2 + match2[0].length, decoration);
        } else {
          throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
        }
        this.boundary = boundary;
        this.maxLength = maxLength;
      }
      /**
      Compute the full set of decorations for matches in the given
      view's viewport. You'll want to call this when initializing your
      plugin.
      */
      createDeco(view) {
        let build = new RangeSetBuilder(), add2 = build.add.bind(build);
        for (let { from: from2, to } of matchRanges(view, this.maxLength))
          iterMatches(view.state.doc, this.regexp, from2, to, (from3, m) => this.addMatch(m, view, from3, add2));
        return build.finish();
      }
      /**
      Update a set of decorations for a view update. `deco` _must_ be
      the set of decorations produced by _this_ `MatchDecorator` for
      the view state before the update.
      */
      updateDeco(update, deco) {
        let changeFrom = 1e9, changeTo = -1;
        if (update.docChanged)
          update.changes.iterChanges((_f, _t, from2, to) => {
            if (to >= update.view.viewport.from && from2 <= update.view.viewport.to) {
              changeFrom = Math.min(from2, changeFrom);
              changeTo = Math.max(to, changeTo);
            }
          });
        if (update.viewportMoved || changeTo - changeFrom > 1e3)
          return this.createDeco(update.view);
        if (changeTo > -1)
          return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
        return deco;
      }
      updateRange(view, deco, updateFrom, updateTo) {
        for (let r of view.visibleRanges) {
          let from2 = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);
          if (to >= from2) {
            let fromLine = view.state.doc.lineAt(from2), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
            let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
            if (this.boundary) {
              for (; from2 > fromLine.from; from2--)
                if (this.boundary.test(fromLine.text[from2 - 1 - fromLine.from])) {
                  start = from2;
                  break;
                }
              for (; to < toLine.to; to++)
                if (this.boundary.test(toLine.text[to - toLine.from])) {
                  end = to;
                  break;
                }
            }
            let ranges = [], m;
            let add2 = (from3, to2, deco2) => ranges.push(deco2.range(from3, to2));
            if (fromLine == toLine) {
              this.regexp.lastIndex = start - fromLine.from;
              while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)
                this.addMatch(m, view, m.index + fromLine.from, add2);
            } else {
              iterMatches(view.state.doc, this.regexp, start, end, (from3, m2) => this.addMatch(m2, view, from3, add2));
            }
            deco = deco.update({ filterFrom: start, filterTo: end, filter: (from3, to2) => from3 < start || to2 > end, add: ranges });
          }
        }
        return deco;
      }
    };
    UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
    Specials = /* @__PURE__ */ new RegExp("[\0-\b\n-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]", UnicodeRegexpSupport);
    Names = {
      0: "null",
      7: "bell",
      8: "backspace",
      10: "newline",
      11: "vertical tab",
      13: "carriage return",
      27: "escape",
      8203: "zero width space",
      8204: "zero width non-joiner",
      8205: "zero width joiner",
      8206: "left-to-right mark",
      8207: "right-to-left mark",
      8232: "line separator",
      8237: "left-to-right override",
      8238: "right-to-left override",
      8294: "left-to-right isolate",
      8295: "right-to-left isolate",
      8297: "pop directional isolate",
      8233: "paragraph separator",
      65279: "zero width no-break space",
      65532: "object replacement"
    };
    _supportsTabSize = null;
    specialCharConfig = /* @__PURE__ */ Facet.define({
      combine(configs) {
        let config3 = combineConfig(configs, {
          render: null,
          specialChars: Specials,
          addSpecialChars: null
        });
        if (config3.replaceTabs = !supportsTabSize())
          config3.specialChars = new RegExp("	|" + config3.specialChars.source, UnicodeRegexpSupport);
        if (config3.addSpecialChars)
          config3.specialChars = new RegExp(config3.specialChars.source + "|" + config3.addSpecialChars.source, UnicodeRegexpSupport);
        return config3;
      }
    });
    _plugin = null;
    DefaultPlaceholder = "\u2022";
    SpecialCharWidget = class extends WidgetType {
      constructor(options, code) {
        super();
        this.options = options;
        this.code = code;
      }
      eq(other) {
        return other.code == this.code;
      }
      toDOM(view) {
        let ph = placeholder$1(this.code);
        let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
        let custom = this.options.render && this.options.render(this.code, desc, ph);
        if (custom)
          return custom;
        let span = document.createElement("span");
        span.textContent = ph;
        span.title = desc;
        span.setAttribute("aria-label", desc);
        span.className = "cm-specialChar";
        return span;
      }
      ignoreEvent() {
        return false;
      }
    };
    TabWidget = class extends WidgetType {
      constructor(width) {
        super();
        this.width = width;
      }
      eq(other) {
        return other.width == this.width;
      }
      toDOM() {
        let span = document.createElement("span");
        span.textContent = "	";
        span.className = "cm-tab";
        span.style.width = this.width + "px";
        return span;
      }
      ignoreEvent() {
        return false;
      }
    };
    lineDeco = /* @__PURE__ */ Decoration.line({ class: "cm-activeLine" });
    activeLineHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
      constructor(view) {
        this.decorations = this.getDeco(view);
      }
      update(update) {
        if (update.docChanged || update.selectionSet)
          this.decorations = this.getDeco(update.view);
      }
      getDeco(view) {
        let lastLineStart = -1, deco = [];
        for (let r of view.state.selection.ranges) {
          let line = view.lineBlockAt(r.head);
          if (line.from > lastLineStart) {
            deco.push(lineDeco.range(line.from));
            lastLineStart = line.from;
          }
        }
        return Decoration.set(deco);
      }
    }, {
      decorations: (v) => v.decorations
    });
    MaxOff = 2e3;
    keys = {
      Alt: [18, (e) => !!e.altKey],
      Control: [17, (e) => !!e.ctrlKey],
      Shift: [16, (e) => !!e.shiftKey],
      Meta: [91, (e) => !!e.metaKey]
    };
    showCrosshair = { style: "cursor: crosshair" };
    Outside = "-10000px";
    TooltipViewManager = class {
      constructor(view, facet, createTooltipView, removeTooltipView) {
        this.facet = facet;
        this.createTooltipView = createTooltipView;
        this.removeTooltipView = removeTooltipView;
        this.input = view.state.facet(facet);
        this.tooltips = this.input.filter((t2) => t2);
        let prev = null;
        this.tooltipViews = this.tooltips.map((t2) => prev = createTooltipView(t2, prev));
      }
      update(update, above) {
        var _a2;
        let input2 = update.state.facet(this.facet);
        let tooltips = input2.filter((x) => x);
        if (input2 === this.input) {
          for (let t2 of this.tooltipViews)
            if (t2.update)
              t2.update(update);
          return false;
        }
        let tooltipViews = [], newAbove = above ? [] : null;
        for (let i = 0; i < tooltips.length; i++) {
          let tip = tooltips[i], known = -1;
          if (!tip)
            continue;
          for (let i2 = 0; i2 < this.tooltips.length; i2++) {
            let other = this.tooltips[i2];
            if (other && other.create == tip.create)
              known = i2;
          }
          if (known < 0) {
            tooltipViews[i] = this.createTooltipView(tip, i ? tooltipViews[i - 1] : null);
            if (newAbove)
              newAbove[i] = !!tip.above;
          } else {
            let tooltipView = tooltipViews[i] = this.tooltipViews[known];
            if (newAbove)
              newAbove[i] = above[known];
            if (tooltipView.update)
              tooltipView.update(update);
          }
        }
        for (let t2 of this.tooltipViews)
          if (tooltipViews.indexOf(t2) < 0) {
            this.removeTooltipView(t2);
            (_a2 = t2.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t2);
          }
        if (above) {
          newAbove.forEach((val, i) => above[i] = val);
          above.length = newAbove.length;
        }
        this.input = input2;
        this.tooltips = tooltips;
        this.tooltipViews = tooltipViews;
        return true;
      }
    };
    tooltipConfig = /* @__PURE__ */ Facet.define({
      combine: (values2) => {
        var _a2, _b, _c;
        return {
          position: browser.ios ? "absolute" : ((_a2 = values2.find((conf) => conf.position)) === null || _a2 === void 0 ? void 0 : _a2.position) || "fixed",
          parent: ((_b = values2.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
          tooltipSpace: ((_c = values2.find((conf) => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
        };
      }
    });
    knownHeight = /* @__PURE__ */ new WeakMap();
    tooltipPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.above = [];
        this.inView = true;
        this.madeAbsolute = false;
        this.lastTransaction = 0;
        this.measureTimeout = -1;
        let config3 = view.state.facet(tooltipConfig);
        this.position = config3.position;
        this.parent = config3.parent;
        this.classes = view.themeClasses;
        this.createContainer();
        this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
        this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null;
        this.manager = new TooltipViewManager(view, showTooltip, (t2, p) => this.createTooltip(t2, p), (t2) => {
          if (this.resizeObserver)
            this.resizeObserver.unobserve(t2.dom);
          t2.dom.remove();
        });
        this.above = this.manager.tooltips.map((t2) => !!t2.above);
        this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
          if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
            this.measureSoon();
        }, { threshold: [1] }) : null;
        this.observeIntersection();
        view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
        this.maybeMeasure();
      }
      createContainer() {
        if (this.parent) {
          this.container = document.createElement("div");
          this.container.style.position = "relative";
          this.container.className = this.view.themeClasses;
          this.parent.appendChild(this.container);
        } else {
          this.container = this.view.dom;
        }
      }
      observeIntersection() {
        if (this.intersectionObserver) {
          this.intersectionObserver.disconnect();
          for (let tooltip of this.manager.tooltipViews)
            this.intersectionObserver.observe(tooltip.dom);
        }
      }
      measureSoon() {
        if (this.measureTimeout < 0)
          this.measureTimeout = setTimeout(() => {
            this.measureTimeout = -1;
            this.maybeMeasure();
          }, 50);
      }
      update(update) {
        if (update.transactions.length)
          this.lastTransaction = Date.now();
        let updated = this.manager.update(update, this.above);
        if (updated)
          this.observeIntersection();
        let shouldMeasure = updated || update.geometryChanged;
        let newConfig = update.state.facet(tooltipConfig);
        if (newConfig.position != this.position && !this.madeAbsolute) {
          this.position = newConfig.position;
          for (let t2 of this.manager.tooltipViews)
            t2.dom.style.position = this.position;
          shouldMeasure = true;
        }
        if (newConfig.parent != this.parent) {
          if (this.parent)
            this.container.remove();
          this.parent = newConfig.parent;
          this.createContainer();
          for (let t2 of this.manager.tooltipViews)
            this.container.appendChild(t2.dom);
          shouldMeasure = true;
        } else if (this.parent && this.view.themeClasses != this.classes) {
          this.classes = this.container.className = this.view.themeClasses;
        }
        if (shouldMeasure)
          this.maybeMeasure();
      }
      createTooltip(tooltip, prev) {
        let tooltipView = tooltip.create(this.view);
        let before = prev ? prev.dom : null;
        tooltipView.dom.classList.add("cm-tooltip");
        if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
          let arrow = document.createElement("div");
          arrow.className = "cm-tooltip-arrow";
          tooltipView.dom.appendChild(arrow);
        }
        tooltipView.dom.style.position = this.position;
        tooltipView.dom.style.top = Outside;
        tooltipView.dom.style.left = "0px";
        this.container.insertBefore(tooltipView.dom, before);
        if (tooltipView.mount)
          tooltipView.mount(this.view);
        if (this.resizeObserver)
          this.resizeObserver.observe(tooltipView.dom);
        return tooltipView;
      }
      destroy() {
        var _a2, _b, _c;
        this.view.win.removeEventListener("resize", this.measureSoon);
        for (let tooltipView of this.manager.tooltipViews) {
          tooltipView.dom.remove();
          (_a2 = tooltipView.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(tooltipView);
        }
        if (this.parent)
          this.container.remove();
        (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
        (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
        clearTimeout(this.measureTimeout);
      }
      readMeasure() {
        let scaleX = 1, scaleY = 1, makeAbsolute = false;
        if (this.position == "fixed" && this.manager.tooltipViews.length) {
          let { dom } = this.manager.tooltipViews[0];
          if (browser.gecko) {
            makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;
          } else if (dom.style.top == Outside && dom.style.left == "0px") {
            let rect = dom.getBoundingClientRect();
            makeAbsolute = Math.abs(rect.top + 1e4) > 1 || Math.abs(rect.left) > 1;
          }
        }
        if (makeAbsolute || this.position == "absolute") {
          if (this.parent) {
            let rect = this.parent.getBoundingClientRect();
            if (rect.width && rect.height) {
              scaleX = rect.width / this.parent.offsetWidth;
              scaleY = rect.height / this.parent.offsetHeight;
            }
          } else {
            ({ scaleX, scaleY } = this.view.viewState);
          }
        }
        let visible = this.view.scrollDOM.getBoundingClientRect(), margins = getScrollMargins(this.view);
        return {
          visible: {
            left: visible.left + margins.left,
            top: visible.top + margins.top,
            right: visible.right - margins.right,
            bottom: visible.bottom - margins.bottom
          },
          parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
          pos: this.manager.tooltips.map((t2, i) => {
            let tv = this.manager.tooltipViews[i];
            return tv.getCoords ? tv.getCoords(t2.pos) : this.view.coordsAtPos(t2.pos);
          }),
          size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
          space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
          scaleX,
          scaleY,
          makeAbsolute
        };
      }
      writeMeasure(measured) {
        var _a2;
        if (measured.makeAbsolute) {
          this.madeAbsolute = true;
          this.position = "absolute";
          for (let t2 of this.manager.tooltipViews)
            t2.dom.style.position = "absolute";
        }
        let { visible, space: space5, scaleX, scaleY } = measured;
        let others = [];
        for (let i = 0; i < this.manager.tooltips.length; i++) {
          let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;
          let pos = measured.pos[i], size = measured.size[i];
          if (!pos || tooltip.clip !== false && (pos.bottom <= Math.max(visible.top, space5.top) || pos.top >= Math.min(visible.bottom, space5.bottom) || pos.right < Math.max(visible.left, space5.left) - 0.1 || pos.left > Math.min(visible.right, space5.right) + 0.1)) {
            dom.style.top = Outside;
            continue;
          }
          let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
          let arrowHeight = arrow ? 7 : 0;
          let width = size.right - size.left, height = (_a2 = knownHeight.get(tView)) !== null && _a2 !== void 0 ? _a2 : size.bottom - size.top;
          let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
          let left = size.width > space5.right - space5.left ? ltr ? space5.left : space5.right - size.width : ltr ? Math.max(space5.left, Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space5.right - width)) : Math.min(Math.max(space5.left, pos.left - width + (arrow ? 14 : 0) - offset.x), space5.right - width);
          let above = this.above[i];
          if (!tooltip.strictSide && (above ? pos.top - height - arrowHeight - offset.y < space5.top : pos.bottom + height + arrowHeight + offset.y > space5.bottom) && above == space5.bottom - pos.bottom > pos.top - space5.top)
            above = this.above[i] = !above;
          let spaceVert = (above ? pos.top - space5.top : space5.bottom - pos.bottom) - arrowHeight;
          if (spaceVert < height && tView.resize !== false) {
            if (spaceVert < this.view.defaultLineHeight) {
              dom.style.top = Outside;
              continue;
            }
            knownHeight.set(tView, height);
            dom.style.height = (height = spaceVert) / scaleY + "px";
          } else if (dom.style.height) {
            dom.style.height = "";
          }
          let top2 = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
          let right = left + width;
          if (tView.overlap !== true) {
            for (let r of others)
              if (r.left < right && r.right > left && r.top < top2 + height && r.bottom > top2)
                top2 = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
          }
          if (this.position == "absolute") {
            dom.style.top = (top2 - measured.parent.top) / scaleY + "px";
            setLeftStyle(dom, (left - measured.parent.left) / scaleX);
          } else {
            dom.style.top = top2 / scaleY + "px";
            setLeftStyle(dom, left / scaleX);
          }
          if (arrow) {
            let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7);
            arrow.style.left = arrowLeft / scaleX + "px";
          }
          if (tView.overlap !== true)
            others.push({ left, top: top2, right, bottom: top2 + height });
          dom.classList.toggle("cm-tooltip-above", above);
          dom.classList.toggle("cm-tooltip-below", !above);
          if (tView.positioned)
            tView.positioned(measured.space);
        }
      }
      maybeMeasure() {
        if (this.manager.tooltips.length) {
          if (this.view.inView)
            this.view.requestMeasure(this.measureReq);
          if (this.inView != this.view.inView) {
            this.inView = this.view.inView;
            if (!this.inView)
              for (let tv of this.manager.tooltipViews)
                tv.dom.style.top = Outside;
          }
        }
      }
    }, {
      eventObservers: {
        scroll() {
          this.maybeMeasure();
        }
      }
    });
    baseTheme = /* @__PURE__ */ EditorView.baseTheme({
      ".cm-tooltip": {
        zIndex: 500,
        boxSizing: "border-box"
      },
      "&light .cm-tooltip": {
        border: "1px solid #bbb",
        backgroundColor: "#f5f5f5"
      },
      "&light .cm-tooltip-section:not(:first-child)": {
        borderTop: "1px solid #bbb"
      },
      "&dark .cm-tooltip": {
        backgroundColor: "#333338",
        color: "white"
      },
      ".cm-tooltip-arrow": {
        height: `${7}px`,
        width: `${7 * 2}px`,
        position: "absolute",
        zIndex: -1,
        overflow: "hidden",
        "&:before, &:after": {
          content: "''",
          position: "absolute",
          width: 0,
          height: 0,
          borderLeft: `${7}px solid transparent`,
          borderRight: `${7}px solid transparent`
        },
        ".cm-tooltip-above &": {
          bottom: `-${7}px`,
          "&:before": {
            borderTop: `${7}px solid #bbb`
          },
          "&:after": {
            borderTop: `${7}px solid #f5f5f5`,
            bottom: "1px"
          }
        },
        ".cm-tooltip-below &": {
          top: `-${7}px`,
          "&:before": {
            borderBottom: `${7}px solid #bbb`
          },
          "&:after": {
            borderBottom: `${7}px solid #f5f5f5`,
            top: "1px"
          }
        }
      },
      "&dark .cm-tooltip .cm-tooltip-arrow": {
        "&:before": {
          borderTopColor: "#333338",
          borderBottomColor: "#333338"
        },
        "&:after": {
          borderTopColor: "transparent",
          borderBottomColor: "transparent"
        }
      }
    });
    noOffset = { x: 0, y: 0 };
    showTooltip = /* @__PURE__ */ Facet.define({
      enables: [tooltipPlugin, baseTheme]
    });
    showHoverTooltip = /* @__PURE__ */ Facet.define({
      combine: (inputs) => inputs.reduce((a, i) => a.concat(i), [])
    });
    HoverTooltipHost = class _HoverTooltipHost {
      // Needs to be static so that host tooltip instances always match
      static create(view) {
        return new _HoverTooltipHost(view);
      }
      constructor(view) {
        this.view = view;
        this.mounted = false;
        this.dom = document.createElement("div");
        this.dom.classList.add("cm-tooltip-hover");
        this.manager = new TooltipViewManager(view, showHoverTooltip, (t2, p) => this.createHostedView(t2, p), (t2) => t2.dom.remove());
      }
      createHostedView(tooltip, prev) {
        let hostedView = tooltip.create(this.view);
        hostedView.dom.classList.add("cm-tooltip-section");
        this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);
        if (this.mounted && hostedView.mount)
          hostedView.mount(this.view);
        return hostedView;
      }
      mount(view) {
        for (let hostedView of this.manager.tooltipViews) {
          if (hostedView.mount)
            hostedView.mount(view);
        }
        this.mounted = true;
      }
      positioned(space5) {
        for (let hostedView of this.manager.tooltipViews) {
          if (hostedView.positioned)
            hostedView.positioned(space5);
        }
      }
      update(update) {
        this.manager.update(update);
      }
      destroy() {
        var _a2;
        for (let t2 of this.manager.tooltipViews)
          (_a2 = t2.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t2);
      }
      passProp(name2) {
        let value = void 0;
        for (let view of this.manager.tooltipViews) {
          let given = view[name2];
          if (given !== void 0) {
            if (value === void 0)
              value = given;
            else if (value !== given)
              return void 0;
          }
        }
        return value;
      }
      get offset() {
        return this.passProp("offset");
      }
      get getCoords() {
        return this.passProp("getCoords");
      }
      get overlap() {
        return this.passProp("overlap");
      }
      get resize() {
        return this.passProp("resize");
      }
    };
    showHoverTooltipHost = /* @__PURE__ */ showTooltip.compute([showHoverTooltip], (state) => {
      let tooltips = state.facet(showHoverTooltip);
      if (tooltips.length === 0)
        return null;
      return {
        pos: Math.min(...tooltips.map((t2) => t2.pos)),
        end: Math.max(...tooltips.map((t2) => {
          var _a2;
          return (_a2 = t2.end) !== null && _a2 !== void 0 ? _a2 : t2.pos;
        })),
        create: HoverTooltipHost.create,
        above: tooltips[0].above,
        arrow: tooltips.some((t2) => t2.arrow)
      };
    });
    HoverPlugin = class {
      constructor(view, source, field, setHover, hoverTime) {
        this.view = view;
        this.source = source;
        this.field = field;
        this.setHover = setHover;
        this.hoverTime = hoverTime;
        this.hoverTimeout = -1;
        this.restartTimeout = -1;
        this.pending = null;
        this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
        this.checkHover = this.checkHover.bind(this);
        view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
        view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
      }
      update() {
        if (this.pending) {
          this.pending = null;
          clearTimeout(this.restartTimeout);
          this.restartTimeout = setTimeout(() => this.startHover(), 20);
        }
      }
      get active() {
        return this.view.state.field(this.field);
      }
      checkHover() {
        this.hoverTimeout = -1;
        if (this.active.length)
          return;
        let hovered = Date.now() - this.lastMove.time;
        if (hovered < this.hoverTime)
          this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
        else
          this.startHover();
      }
      startHover() {
        clearTimeout(this.restartTimeout);
        let { view, lastMove } = this;
        let desc = view.docView.nearest(lastMove.target);
        if (!desc)
          return;
        let pos, side = 1;
        if (desc instanceof WidgetView) {
          pos = desc.posAtStart;
        } else {
          pos = view.posAtCoords(lastMove);
          if (pos == null)
            return;
          let posCoords = view.coordsAtPos(pos);
          if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth)
            return;
          let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find((s) => s.from <= pos && s.to >= pos);
          let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
          side = lastMove.x < posCoords.left ? -rtl : rtl;
        }
        let open = this.source(view, pos, side);
        if (open === null || open === void 0 ? void 0 : open.then) {
          let pending = this.pending = { pos };
          open.then((result) => {
            if (this.pending == pending) {
              this.pending = null;
              if (result && !(Array.isArray(result) && !result.length))
                view.dispatch({ effects: this.setHover.of(Array.isArray(result) ? result : [result]) });
            }
          }, (e) => logException(view.state, e, "hover tooltip"));
        } else if (open && !(Array.isArray(open) && !open.length)) {
          view.dispatch({ effects: this.setHover.of(Array.isArray(open) ? open : [open]) });
        }
      }
      get tooltip() {
        let plugin = this.view.plugin(tooltipPlugin);
        let index = plugin ? plugin.manager.tooltips.findIndex((t2) => t2.create == HoverTooltipHost.create) : -1;
        return index > -1 ? plugin.manager.tooltipViews[index] : null;
      }
      mousemove(event) {
        var _a2, _b;
        this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
        if (this.hoverTimeout < 0)
          this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
        let { active, tooltip } = this;
        if (active.length && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {
          let { pos } = active[0] || this.pending, end = (_b = (_a2 = active[0]) === null || _a2 === void 0 ? void 0 : _a2.end) !== null && _b !== void 0 ? _b : pos;
          if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY)) {
            this.view.dispatch({ effects: this.setHover.of([]) });
            this.pending = null;
          }
        }
      }
      mouseleave(event) {
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = -1;
        let { active } = this;
        if (active.length) {
          let { tooltip } = this;
          let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);
          if (!inTooltip)
            this.view.dispatch({ effects: this.setHover.of([]) });
          else
            this.watchTooltipLeave(tooltip.dom);
        }
      }
      watchTooltipLeave(tooltip) {
        let watch = (event) => {
          tooltip.removeEventListener("mouseleave", watch);
          if (this.active.length && !this.view.dom.contains(event.relatedTarget))
            this.view.dispatch({ effects: this.setHover.of([]) });
        };
        tooltip.addEventListener("mouseleave", watch);
      }
      destroy() {
        clearTimeout(this.hoverTimeout);
        this.view.dom.removeEventListener("mouseleave", this.mouseleave);
        this.view.dom.removeEventListener("mousemove", this.mousemove);
      }
    };
    tooltipMargin = 4;
    closeHoverTooltipEffect = /* @__PURE__ */ StateEffect.define();
    panelConfig = /* @__PURE__ */ Facet.define({
      combine(configs) {
        let topContainer, bottomContainer;
        for (let c of configs) {
          topContainer = topContainer || c.topContainer;
          bottomContainer = bottomContainer || c.bottomContainer;
        }
        return { topContainer, bottomContainer };
      }
    });
    panelPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
      constructor(view) {
        this.input = view.state.facet(showPanel);
        this.specs = this.input.filter((s) => s);
        this.panels = this.specs.map((spec) => spec(view));
        let conf = view.state.facet(panelConfig);
        this.top = new PanelGroup(view, true, conf.topContainer);
        this.bottom = new PanelGroup(view, false, conf.bottomContainer);
        this.top.sync(this.panels.filter((p) => p.top));
        this.bottom.sync(this.panels.filter((p) => !p.top));
        for (let p of this.panels) {
          p.dom.classList.add("cm-panel");
          if (p.mount)
            p.mount();
        }
      }
      update(update) {
        let conf = update.state.facet(panelConfig);
        if (this.top.container != conf.topContainer) {
          this.top.sync([]);
          this.top = new PanelGroup(update.view, true, conf.topContainer);
        }
        if (this.bottom.container != conf.bottomContainer) {
          this.bottom.sync([]);
          this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
        }
        this.top.syncClasses();
        this.bottom.syncClasses();
        let input2 = update.state.facet(showPanel);
        if (input2 != this.input) {
          let specs = input2.filter((x) => x);
          let panels = [], top2 = [], bottom = [], mount = [];
          for (let spec of specs) {
            let known = this.specs.indexOf(spec), panel;
            if (known < 0) {
              panel = spec(update.view);
              mount.push(panel);
            } else {
              panel = this.panels[known];
              if (panel.update)
                panel.update(update);
            }
            panels.push(panel);
            (panel.top ? top2 : bottom).push(panel);
          }
          this.specs = specs;
          this.panels = panels;
          this.top.sync(top2);
          this.bottom.sync(bottom);
          for (let p of mount) {
            p.dom.classList.add("cm-panel");
            if (p.mount)
              p.mount();
          }
        } else {
          for (let p of this.panels)
            if (p.update)
              p.update(update);
        }
      }
      destroy() {
        this.top.sync([]);
        this.bottom.sync([]);
      }
    }, {
      provide: (plugin) => EditorView.scrollMargins.of((view) => {
        let value = view.plugin(plugin);
        return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
      })
    });
    PanelGroup = class {
      constructor(view, top2, container) {
        this.view = view;
        this.top = top2;
        this.container = container;
        this.dom = void 0;
        this.classes = "";
        this.panels = [];
        this.syncClasses();
      }
      sync(panels) {
        for (let p of this.panels)
          if (p.destroy && panels.indexOf(p) < 0)
            p.destroy();
        this.panels = panels;
        this.syncDOM();
      }
      syncDOM() {
        if (this.panels.length == 0) {
          if (this.dom) {
            this.dom.remove();
            this.dom = void 0;
          }
          return;
        }
        if (!this.dom) {
          this.dom = document.createElement("div");
          this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
          this.dom.style[this.top ? "top" : "bottom"] = "0";
          let parent = this.container || this.view.dom;
          parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
        }
        let curDOM = this.dom.firstChild;
        for (let panel of this.panels) {
          if (panel.dom.parentNode == this.dom) {
            while (curDOM != panel.dom)
              curDOM = rm(curDOM);
            curDOM = curDOM.nextSibling;
          } else {
            this.dom.insertBefore(panel.dom, curDOM);
          }
        }
        while (curDOM)
          curDOM = rm(curDOM);
      }
      scrollMargin() {
        return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
      }
      syncClasses() {
        if (!this.container || this.classes == this.view.themeClasses)
          return;
        for (let cls of this.classes.split(" "))
          if (cls)
            this.container.classList.remove(cls);
        for (let cls of (this.classes = this.view.themeClasses).split(" "))
          if (cls)
            this.container.classList.add(cls);
      }
    };
    showPanel = /* @__PURE__ */ Facet.define({
      enables: panelPlugin
    });
    GutterMarker = class extends RangeValue {
      /**
      @internal
      */
      compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
      }
      /**
      Compare this marker to another marker of the same type.
      */
      eq(other) {
        return false;
      }
      /**
      Called if the marker has a `toDOM` method and its representation
      was removed from a gutter.
      */
      destroy(dom) {
      }
    };
    GutterMarker.prototype.elementClass = "";
    GutterMarker.prototype.toDOM = void 0;
    GutterMarker.prototype.mapMode = MapMode.TrackBefore;
    GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
    GutterMarker.prototype.point = true;
    gutterLineClass = /* @__PURE__ */ Facet.define();
    gutterWidgetClass = /* @__PURE__ */ Facet.define();
    defaults = {
      class: "",
      renderEmptyElements: false,
      elementStyle: "",
      markers: () => RangeSet.empty,
      lineMarker: () => null,
      widgetMarker: () => null,
      lineMarkerChange: null,
      initialSpacer: null,
      updateSpacer: null,
      domEventHandlers: {},
      side: "before"
    };
    activeGutters = /* @__PURE__ */ Facet.define();
    unfixGutters = /* @__PURE__ */ Facet.define({
      combine: (values2) => values2.some((x) => x)
    });
    gutterView = /* @__PURE__ */ ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.domAfter = null;
        this.prevViewport = view.viewport;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutters cm-gutters-before";
        this.dom.setAttribute("aria-hidden", "true");
        this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
        this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
        this.fixed = !view.state.facet(unfixGutters);
        for (let gutter2 of this.gutters) {
          if (gutter2.config.side == "after")
            this.getDOMAfter().appendChild(gutter2.dom);
          else
            this.dom.appendChild(gutter2.dom);
        }
        if (this.fixed) {
          this.dom.style.position = "sticky";
        }
        this.syncGutters(false);
        view.scrollDOM.insertBefore(this.dom, view.contentDOM);
      }
      getDOMAfter() {
        if (!this.domAfter) {
          this.domAfter = document.createElement("div");
          this.domAfter.className = "cm-gutters cm-gutters-after";
          this.domAfter.setAttribute("aria-hidden", "true");
          this.domAfter.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
          this.domAfter.style.position = this.fixed ? "sticky" : "";
          this.view.scrollDOM.appendChild(this.domAfter);
        }
        return this.domAfter;
      }
      update(update) {
        if (this.updateGutters(update)) {
          let vpA = this.prevViewport, vpB = update.view.viewport;
          let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
          this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
        }
        if (update.geometryChanged) {
          let min = this.view.contentHeight / this.view.scaleY + "px";
          this.dom.style.minHeight = min;
          if (this.domAfter)
            this.domAfter.style.minHeight = min;
        }
        if (this.view.state.facet(unfixGutters) != !this.fixed) {
          this.fixed = !this.fixed;
          this.dom.style.position = this.fixed ? "sticky" : "";
          if (this.domAfter)
            this.domAfter.style.position = this.fixed ? "sticky" : "";
        }
        this.prevViewport = update.view.viewport;
      }
      syncGutters(detach) {
        let after = this.dom.nextSibling;
        if (detach) {
          this.dom.remove();
          if (this.domAfter)
            this.domAfter.remove();
        }
        let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
        let classSet = [];
        let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
        for (let line of this.view.viewportLineBlocks) {
          if (classSet.length)
            classSet = [];
          if (Array.isArray(line.type)) {
            let first2 = true;
            for (let b of line.type) {
              if (b.type == BlockType.Text && first2) {
                advanceCursor(lineClasses, classSet, b.from);
                for (let cx of contexts)
                  cx.line(this.view, b, classSet);
                first2 = false;
              } else if (b.widget) {
                for (let cx of contexts)
                  cx.widget(this.view, b);
              }
            }
          } else if (line.type == BlockType.Text) {
            advanceCursor(lineClasses, classSet, line.from);
            for (let cx of contexts)
              cx.line(this.view, line, classSet);
          } else if (line.widget) {
            for (let cx of contexts)
              cx.widget(this.view, line);
          }
        }
        for (let cx of contexts)
          cx.finish();
        if (detach) {
          this.view.scrollDOM.insertBefore(this.dom, after);
          if (this.domAfter)
            this.view.scrollDOM.appendChild(this.domAfter);
        }
      }
      updateGutters(update) {
        let prev = update.startState.facet(activeGutters), cur2 = update.state.facet(activeGutters);
        let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
        if (prev == cur2) {
          for (let gutter2 of this.gutters)
            if (gutter2.update(update))
              change = true;
        } else {
          change = true;
          let gutters2 = [];
          for (let conf of cur2) {
            let known = prev.indexOf(conf);
            if (known < 0) {
              gutters2.push(new SingleGutterView(this.view, conf));
            } else {
              this.gutters[known].update(update);
              gutters2.push(this.gutters[known]);
            }
          }
          for (let g of this.gutters) {
            g.dom.remove();
            if (gutters2.indexOf(g) < 0)
              g.destroy();
          }
          for (let g of gutters2) {
            if (g.config.side == "after")
              this.getDOMAfter().appendChild(g.dom);
            else
              this.dom.appendChild(g.dom);
          }
          this.gutters = gutters2;
        }
        return change;
      }
      destroy() {
        for (let view of this.gutters)
          view.destroy();
        this.dom.remove();
        if (this.domAfter)
          this.domAfter.remove();
      }
    }, {
      provide: (plugin) => EditorView.scrollMargins.of((view) => {
        let value = view.plugin(plugin);
        if (!value || value.gutters.length == 0 || !value.fixed)
          return null;
        let before = value.dom.offsetWidth * view.scaleX, after = value.domAfter ? value.domAfter.offsetWidth * view.scaleX : 0;
        return view.textDirection == Direction.LTR ? { left: before, right: after } : { right: before, left: after };
      })
    });
    UpdateContext = class {
      constructor(gutter2, viewport, height) {
        this.gutter = gutter2;
        this.height = height;
        this.i = 0;
        this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
      }
      addElement(view, block, markers) {
        let { gutter: gutter2 } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;
        if (this.i == gutter2.elements.length) {
          let newElt = new GutterElement(view, height, above, markers);
          gutter2.elements.push(newElt);
          gutter2.dom.appendChild(newElt.dom);
        } else {
          gutter2.elements[this.i].update(view, height, above, markers);
        }
        this.height = block.bottom;
        this.i++;
      }
      line(view, line, extraMarkers) {
        let localMarkers = [];
        advanceCursor(this.cursor, localMarkers, line.from);
        if (extraMarkers.length)
          localMarkers = localMarkers.concat(extraMarkers);
        let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
        if (forLine)
          localMarkers.unshift(forLine);
        let gutter2 = this.gutter;
        if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
          return;
        this.addElement(view, line, localMarkers);
      }
      widget(view, block) {
        let marker = this.gutter.config.widgetMarker(view, block.widget, block), markers = marker ? [marker] : null;
        for (let cls of view.state.facet(gutterWidgetClass)) {
          let marker2 = cls(view, block.widget, block);
          if (marker2)
            (markers || (markers = [])).push(marker2);
        }
        if (markers)
          this.addElement(view, block, markers);
      }
      finish() {
        let gutter2 = this.gutter;
        while (gutter2.elements.length > this.i) {
          let last4 = gutter2.elements.pop();
          gutter2.dom.removeChild(last4.dom);
          last4.destroy();
        }
      }
    };
    SingleGutterView = class {
      constructor(view, config3) {
        this.view = view;
        this.config = config3;
        this.elements = [];
        this.spacer = null;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
        for (let prop in config3.domEventHandlers) {
          this.dom.addEventListener(prop, (event) => {
            let target = event.target, y;
            if (target != this.dom && this.dom.contains(target)) {
              while (target.parentNode != this.dom)
                target = target.parentNode;
              let rect = target.getBoundingClientRect();
              y = (rect.top + rect.bottom) / 2;
            } else {
              y = event.clientY;
            }
            let line = view.lineBlockAtHeight(y - view.documentTop);
            if (config3.domEventHandlers[prop](view, line, event))
              event.preventDefault();
          });
        }
        this.markers = asArray2(config3.markers(view));
        if (config3.initialSpacer) {
          this.spacer = new GutterElement(view, 0, 0, [config3.initialSpacer(view)]);
          this.dom.appendChild(this.spacer.dom);
          this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
        }
      }
      update(update) {
        let prevMarkers = this.markers;
        this.markers = asArray2(this.config.markers(update.view));
        if (this.spacer && this.config.updateSpacer) {
          let updated = this.config.updateSpacer(this.spacer.markers[0], update);
          if (updated != this.spacer.markers[0])
            this.spacer.update(update.view, 0, 0, [updated]);
        }
        let vp = update.view.viewport;
        return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
      }
      destroy() {
        for (let elt2 of this.elements)
          elt2.destroy();
      }
    };
    GutterElement = class {
      constructor(view, height, above, markers) {
        this.height = -1;
        this.above = 0;
        this.markers = [];
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutterElement";
        this.update(view, height, above, markers);
      }
      update(view, height, above, markers) {
        if (this.height != height) {
          this.height = height;
          this.dom.style.height = height + "px";
        }
        if (this.above != above)
          this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
        if (!sameMarkers(this.markers, markers))
          this.setMarkers(view, markers);
      }
      setMarkers(view, markers) {
        let cls = "cm-gutterElement", domPos = this.dom.firstChild;
        for (let iNew = 0, iOld = 0; ; ) {
          let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
          if (marker) {
            let c = marker.elementClass;
            if (c)
              cls += " " + c;
            for (let i = iOld; i < this.markers.length; i++)
              if (this.markers[i].compare(marker)) {
                skipTo = i;
                matched = true;
                break;
              }
          } else {
            skipTo = this.markers.length;
          }
          while (iOld < skipTo) {
            let next = this.markers[iOld++];
            if (next.toDOM) {
              next.destroy(domPos);
              let after = domPos.nextSibling;
              domPos.remove();
              domPos = after;
            }
          }
          if (!marker)
            break;
          if (marker.toDOM) {
            if (matched)
              domPos = domPos.nextSibling;
            else
              this.dom.insertBefore(marker.toDOM(view), domPos);
          }
          if (matched)
            iOld++;
        }
        this.dom.className = cls;
        this.markers = markers;
      }
      destroy() {
        this.setMarkers(null, []);
      }
    };
    lineNumberMarkers = /* @__PURE__ */ Facet.define();
    lineNumberWidgetMarker = /* @__PURE__ */ Facet.define();
    lineNumberConfig = /* @__PURE__ */ Facet.define({
      combine(values2) {
        return combineConfig(values2, { formatNumber: String, domEventHandlers: {} }, {
          domEventHandlers(a, b) {
            let result = Object.assign({}, a);
            for (let event in b) {
              let exists = result[event], add2 = b[event];
              result[event] = exists ? (view, line, event2) => exists(view, line, event2) || add2(view, line, event2) : add2;
            }
            return result;
          }
        });
      }
    });
    NumberMarker = class extends GutterMarker {
      constructor(number2) {
        super();
        this.number = number2;
      }
      eq(other) {
        return this.number == other.number;
      }
      toDOM() {
        return document.createTextNode(this.number);
      }
    };
    lineNumberGutter = /* @__PURE__ */ activeGutters.compute([lineNumberConfig], (state) => ({
      class: "cm-lineNumbers",
      renderEmptyElements: false,
      markers(view) {
        return view.state.facet(lineNumberMarkers);
      },
      lineMarker(view, line, others) {
        if (others.some((m) => m.toDOM))
          return null;
        return new NumberMarker(formatNumber2(view, view.state.doc.lineAt(line.from).number));
      },
      widgetMarker: (view, widget, block) => {
        for (let m of view.state.facet(lineNumberWidgetMarker)) {
          let result = m(view, widget, block);
          if (result)
            return result;
        }
        return null;
      },
      lineMarkerChange: (update) => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
      initialSpacer(view) {
        return new NumberMarker(formatNumber2(view, maxLineNumber(view.state.doc.lines)));
      },
      updateSpacer(spacer, update) {
        let max = formatNumber2(update.view, maxLineNumber(update.view.state.doc.lines));
        return max == spacer.number ? spacer : new NumberMarker(max);
      },
      domEventHandlers: state.facet(lineNumberConfig).domEventHandlers,
      side: "before"
    }));
    activeLineGutterMarker = /* @__PURE__ */ new class extends GutterMarker {
      constructor() {
        super(...arguments);
        this.elementClass = "cm-activeLineGutter";
      }
    }();
    activeLineGutterHighlighter = /* @__PURE__ */ gutterLineClass.compute(["selection"], (state) => {
      let marks2 = [], last4 = -1;
      for (let range of state.selection.ranges) {
        let linePos = state.doc.lineAt(range.head).from;
        if (linePos > last4) {
          last4 = linePos;
          marks2.push(activeLineGutterMarker.range(linePos));
        }
      }
      return RangeSet.of(marks2);
    });
  }
});

// node_modules/@lezer/common/dist/index.js
function checkSide(side, pos, from2, to) {
  switch (side) {
    case -2:
      return from2 < pos;
    case -1:
      return to >= pos && from2 < pos;
    case 0:
      return from2 < pos && to > pos;
    case 1:
      return from2 <= pos && to > pos;
    case 2:
      return to > pos;
    case 4:
      return true;
  }
}
function resolveNode2(node, pos, side, overlays) {
  var _a2;
  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
    let parent = !overlays && node instanceof TreeNode2 && node.index < 0 ? null : node.parent;
    if (!parent)
      return node;
    node = parent;
  }
  let mode = overlays ? 0 : IterMode.IgnoreOverlays;
  if (overlays)
    for (let scan2 = node, parent = scan2.parent; parent; scan2 = parent, parent = scan2.parent) {
      if (scan2 instanceof TreeNode2 && scan2.index < 0 && ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan2.from)
        node = parent;
    }
  for (; ; ) {
    let inner = node.enter(pos, side, mode);
    if (!inner)
      return node;
    node = inner;
  }
}
function getChildren(node, type, before, after) {
  let cur2 = node.cursor(), result = [];
  if (!cur2.firstChild())
    return result;
  if (before != null)
    for (let found = false; !found; ) {
      found = cur2.type.is(before);
      if (!cur2.nextSibling())
        return result;
    }
  for (; ; ) {
    if (after != null && cur2.type.is(after))
      return result;
    if (cur2.type.is(type))
      result.push(cur2.node);
    if (!cur2.nextSibling())
      return after == null ? result : [];
  }
}
function matchNodeContext(node, context2, i = context2.length - 1) {
  for (let p = node; i >= 0; p = p.parent) {
    if (!p)
      return false;
    if (!p.type.isAnonymous) {
      if (context2[i] && context2[i] != p.name)
        return false;
      i--;
    }
  }
  return true;
}
function iterStack(heads) {
  if (!heads.length)
    return null;
  let pick = 0, picked = heads[0];
  for (let i = 1; i < heads.length; i++) {
    let node = heads[i];
    if (node.from > picked.from || node.to < picked.to) {
      picked = node;
      pick = i;
    }
  }
  let next = picked instanceof TreeNode2 && picked.index < 0 ? null : picked.parent;
  let newHeads = heads.slice();
  if (next)
    newHeads[pick] = next;
  else
    newHeads.splice(pick, 1);
  return new StackIterator(newHeads, picked);
}
function stackIterator(tree2, pos, side) {
  let inner = tree2.resolveInner(pos, side), layers = null;
  for (let scan2 = inner instanceof TreeNode2 ? inner : inner.context.parent; scan2; scan2 = scan2.parent) {
    if (scan2.index < 0) {
      let parent = scan2.parent;
      (layers || (layers = [inner])).push(parent.resolve(pos, side));
      scan2 = parent;
    } else {
      let mount = MountedTree.get(scan2.tree);
      if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
        let root = new TreeNode2(mount.tree, mount.overlay[0].from + scan2.from, -1, scan2);
        (layers || (layers = [inner])).push(resolveNode2(root, pos, side, false));
      }
    }
  }
  return layers ? iterStack(layers) : inner;
}
function hasChild(tree2) {
  return tree2.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data2) {
  var _a2;
  let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data2;
  let cursor2 = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types2 = nodeSet.types;
  let contextHash = 0, lookAhead = 0;
  function takeNode(parentStart, minPos, children2, positions2, inRepeat, depth) {
    let { id: id2, start, end, size } = cursor2;
    let lookAheadAtStart = lookAhead, contextAtStart = contextHash;
    if (size < 0) {
      cursor2.next();
      if (size == -1) {
        let node2 = reused[id2];
        children2.push(node2);
        positions2.push(start - parentStart);
        return;
      } else if (size == -3) {
        contextHash = id2;
        return;
      } else if (size == -4) {
        lookAhead = id2;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size}`);
      }
    }
    let type = types2[id2], node, buffer2;
    let startPos = start - parentStart;
    if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor2.pos - minPos, inRepeat))) {
      let data3 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor2.pos - buffer2.size, index = data3.length;
      while (cursor2.pos > endPos)
        index = copyToBuffer(buffer2.start, data3, index);
      node = new TreeBuffer(data3, end - buffer2.start, nodeSet);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor2.pos - size;
      cursor2.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id2 >= minRepeatType ? id2 : -1;
      let lastGroup = 0, lastEnd = end;
      while (cursor2.pos > endPos) {
        if (localInRepeat >= 0 && cursor2.id == localInRepeat && cursor2.size >= 0) {
          if (cursor2.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor2.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor2.end;
          }
          cursor2.next();
        } else if (depth > 2500) {
          takeFlatNode(start, endPos, localChildren, localPositions);
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type, contextAtStart);
        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
      } else {
        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);
      }
    }
    children2.push(node);
    positions2.push(startPos);
  }
  function takeFlatNode(parentStart, minPos, children2, positions2) {
    let nodes = [];
    let nodeCount = 0, stopAt = -1;
    while (cursor2.pos > minPos) {
      let { id: id2, start, end, size } = cursor2;
      if (size > 4) {
        cursor2.next();
      } else if (stopAt > -1 && start < stopAt) {
        break;
      } else {
        if (stopAt < 0)
          stopAt = end - maxBufferLength;
        nodes.push(id2, start, end);
        nodeCount++;
        cursor2.next();
      }
    }
    if (nodeCount) {
      let buffer2 = new Uint16Array(nodeCount * 4);
      let start = nodes[nodes.length - 2];
      for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {
        buffer2[j++] = nodes[i];
        buffer2[j++] = nodes[i + 1] - start;
        buffer2[j++] = nodes[i + 2] - start;
        buffer2[j++] = j;
      }
      children2.push(new TreeBuffer(buffer2, nodes[2] - start, nodeSet));
      positions2.push(start - parentStart);
    }
  }
  function makeBalanced(type, contextHash2) {
    return (children2, positions2, length2) => {
      let lookAhead2 = 0, lastI = children2.length - 1, last4, lookAheadProp;
      if (lastI >= 0 && (last4 = children2[lastI]) instanceof Tree2) {
        if (!lastI && last4.type == type && last4.length == length2)
          return last4;
        if (lookAheadProp = last4.prop(NodeProp.lookAhead))
          lookAhead2 = positions2[lastI] + last4.length + lookAheadProp;
      }
      return makeTree(type, children2, positions2, length2, lookAhead2, contextHash2);
    };
  }
  function makeRepeatLeaf(children2, positions2, base2, i, from2, to, type, lookAhead2, contextHash2) {
    let localChildren = [], localPositions = [];
    while (children2.length > i) {
      localChildren.push(children2.pop());
      localPositions.push(positions2.pop() + base2 - from2);
    }
    children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from2, lookAhead2 - to, contextHash2));
    positions2.push(from2 - base2);
  }
  function makeTree(type, children2, positions2, length2, lookAhead2, contextHash2, props) {
    if (contextHash2) {
      let pair2 = [NodeProp.contextHash, contextHash2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    if (lookAhead2 > 25) {
      let pair2 = [NodeProp.lookAhead, lookAhead2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    return new Tree2(type, children2, positions2, length2, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor2.fork();
    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result = { size: 0, start: 0, skip: 0 };
    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
      let nodeSize2 = fork.size;
      if (fork.id == inRepeat && nodeSize2 >= 0) {
        result.size = size;
        result.start = start;
        result.skip = skip;
        skip += 4;
        size += 4;
        fork.next();
        continue;
      }
      let startPos = fork.pos - nodeSize2;
      if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
        break;
      let localSkipped = fork.id >= minRepeatType ? 4 : 0;
      let nodeStart2 = fork.start;
      fork.next();
      while (fork.pos > startPos) {
        if (fork.size < 0) {
          if (fork.size == -3)
            localSkipped += 4;
          else
            break scan;
        } else if (fork.id >= minRepeatType) {
          localSkipped += 4;
        }
        fork.next();
      }
      start = nodeStart2;
      size += nodeSize2;
      skip += localSkipped;
    }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index) {
    let { id: id2, start, end, size } = cursor2;
    cursor2.next();
    if (size >= 0 && id2 < minRepeatType) {
      let startIndex = index;
      if (size > 4) {
        let endPos = cursor2.pos - (size - 4);
        while (cursor2.pos > endPos)
          index = copyToBuffer(bufferStart, buffer2, index);
      }
      buffer2[--index] = startIndex;
      buffer2[--index] = end - bufferStart;
      buffer2[--index] = start - bufferStart;
      buffer2[--index] = id2;
    } else if (size == -3) {
      contextHash = id2;
    } else if (size == -4) {
      lookAhead = id2;
    }
    return index;
  }
  let children = [], positions = [];
  while (cursor2.pos > 0)
    takeNode(data2.start || 0, data2.bufferStart || 0, children, positions, -1, 0);
  let length = (_a2 = data2.length) !== null && _a2 !== void 0 ? _a2 : children.length ? positions[0] + children[0].length : 0;
  return new Tree2(types2[data2.topID], children.reverse(), positions.reverse(), length);
}
function nodeSize(balanceType, node) {
  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
    return 1;
  let size = nodeSizeCache.get(node);
  if (size == null) {
    size = 1;
    for (let child of node.children) {
      if (child.type != balanceType || !(child instanceof Tree2)) {
        size = 1;
        break;
      }
      size += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node, size);
  }
  return size;
}
function balanceRange(balanceType, children, positions, from2, to, start, length, mkTop, mkTree) {
  let total = 0;
  for (let i = from2; i < to; i++)
    total += nodeSize(balanceType, children[i]);
  let maxChild = Math.ceil(
    total * 1.5 / 8
    /* Balance.BranchFactor */
  );
  let localChildren = [], localPositions = [];
  function divide(children2, positions2, from3, to2, offset) {
    for (let i = from3; i < to2; ) {
      let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(balanceType, children2[i]);
      i++;
      for (; i < to2; i++) {
        let nextSize = nodeSize(balanceType, children2[i]);
        if (groupSize + nextSize >= maxChild)
          break;
        groupSize += nextSize;
      }
      if (i == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children2[groupFrom];
          divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
          continue;
        }
        localChildren.push(children2[groupFrom]);
      } else {
        let length2 = positions2[i - 1] + children2[i - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i, groupStart, length2, null, mkTree));
      }
      localPositions.push(groupStart + offset - start);
    }
  }
  divide(children, positions, from2, to, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length);
}
function parseMixed(nest) {
  return (parse, input2, fragments, ranges) => new MixedParse(parse, nest, input2, fragments, ranges);
}
function checkRanges(ranges) {
  if (!ranges.length || ranges.some((r) => r.from >= r.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(ranges));
}
function checkCover(covered, from2, to) {
  for (let range of covered) {
    if (range.from >= to)
      break;
    if (range.to > from2)
      return range.from <= from2 && range.to >= to ? 2 : 1;
  }
  return 0;
}
function sliceBuf(buf, startI, endI, nodes, positions, off) {
  if (startI < endI) {
    let from2 = buf.buffer[startI + 1];
    nodes.push(buf.slice(startI, endI, from2));
    positions.push(from2 - off);
  }
}
function materialize(cursor2) {
  let { node } = cursor2, stack = [];
  let buffer = node.context.buffer;
  do {
    stack.push(cursor2.index);
    cursor2.parent();
  } while (!cursor2.tree);
  let base2 = cursor2.tree, i = base2.children.indexOf(buffer);
  let buf = base2.children[i], b = buf.buffer, newStack = [i];
  function split2(startI, endI, type, innerOffset, length, stackPos) {
    let targetI = stack[stackPos];
    let children = [], positions = [];
    sliceBuf(buf, startI, targetI, children, positions, innerOffset);
    let from2 = b[targetI + 1], to = b[targetI + 2];
    newStack.push(children.length);
    let child = stackPos ? split2(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from2, to - from2, stackPos - 1) : node.toTree();
    children.push(child);
    positions.push(from2 - innerOffset);
    sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset);
    return new Tree2(type, children, positions, length);
  }
  base2.children[i] = split2(0, b.length, NodeType.none, 0, buf.length, stack.length - 1);
  for (let index of newStack) {
    let tree2 = cursor2.tree.children[index], pos = cursor2.tree.positions[index];
    cursor2.yield(new TreeNode2(tree2, pos + cursor2.from, index, cursor2._tree));
  }
}
function punchRanges(outer, ranges) {
  let copy = null, current = ranges;
  for (let i = 1, j = 0; i < outer.length; i++) {
    let gapFrom = outer[i - 1].to, gapTo = outer[i].from;
    for (; j < current.length; j++) {
      let r = current[j];
      if (r.from >= gapTo)
        break;
      if (r.to <= gapFrom)
        continue;
      if (!copy)
        current = copy = ranges.slice();
      if (r.from < gapFrom) {
        copy[j] = new Range2(r.from, gapFrom);
        if (r.to > gapTo)
          copy.splice(j + 1, 0, new Range2(gapTo, r.to));
      } else if (r.to > gapTo) {
        copy[j--] = new Range2(gapTo, r.to);
      } else {
        copy.splice(j--, 1);
      }
    }
  }
  return current;
}
function findCoverChanges(a, b, from2, to) {
  let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
  let result = [];
  for (; ; ) {
    let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
    let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
    if (inA != inB) {
      let start = Math.max(pos, from2), end = Math.min(nextA, nextB, to);
      if (start < end)
        result.push(new Range2(start, end));
    }
    pos = Math.min(nextA, nextB);
    if (pos == 1e9)
      break;
    if (nextA == pos) {
      if (!inA)
        inA = true;
      else {
        inA = false;
        iA++;
      }
    }
    if (nextB == pos) {
      if (!inB)
        inB = true;
      else {
        inB = false;
        iB++;
      }
    }
  }
  return result;
}
function enterFragments(mounts, ranges) {
  let result = [];
  for (let { pos, mount, frag } of mounts) {
    let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
    let from2 = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
    if (mount.overlay) {
      let overlay = mount.overlay.map((r) => new Range2(r.from + pos, r.to + pos));
      let changes = findCoverChanges(ranges, overlay, from2, to);
      for (let i = 0, pos2 = from2; ; i++) {
        let last4 = i == changes.length, end = last4 ? to : changes[i].from;
        if (end > pos2)
          result.push(new TreeFragment(pos2, end, mount.tree, -startPos, frag.from >= pos2 || frag.openStart, frag.to <= end || frag.openEnd));
        if (last4)
          break;
        pos2 = changes[i].to;
      }
    } else {
      result.push(new TreeFragment(from2, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));
    }
  }
  return result;
}
var DefaultBufferLength, nextPropID, Range2, NodeProp, MountedTree, noProps, NodeType, NodeSet, CachedNode, CachedInnerNode, IterMode, Tree2, FlatBufferCursor, TreeBuffer, BaseNode, TreeNode2, BufferContext, BufferNode, StackIterator, TreeCursor, nodeSizeCache, NodeWeakMap, TreeFragment, Parser, StringInput, InnerParse, ActiveOverlay, stoppedInner, MixedParse, StructureCursor, FragmentCursor;
var init_dist3 = __esm({
  "node_modules/@lezer/common/dist/index.js"() {
    "use strict";
    DefaultBufferLength = 1024;
    nextPropID = 0;
    Range2 = class {
      constructor(from2, to) {
        this.from = from2;
        this.to = to;
      }
    };
    NodeProp = class {
      /**
      Create a new node prop type.
      */
      constructor(config3 = {}) {
        this.id = nextPropID++;
        this.perNode = !!config3.perNode;
        this.deserialize = config3.deserialize || (() => {
          throw new Error("This node type doesn't define a deserialize function");
        });
        this.combine = config3.combine || null;
      }
      /**
      This is meant to be used with
      [`NodeSet.extend`](#common.NodeSet.extend) or
      [`LRParser.configure`](#lr.ParserConfig.props) to compute
      prop values for each node type in the set. Takes a [match
      object](#common.NodeType^match) or function that returns undefined
      if the node type doesn't get this prop, and the prop's value if
      it does.
      */
      add(match2) {
        if (this.perNode)
          throw new RangeError("Can't add per-node props to node types");
        if (typeof match2 != "function")
          match2 = NodeType.match(match2);
        return (type) => {
          let result = match2(type);
          return result === void 0 ? null : [this, result];
        };
      }
    };
    NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
    NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
    NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
    NodeProp.isolate = new NodeProp({ deserialize: (value) => {
      if (value && value != "rtl" && value != "ltr" && value != "auto")
        throw new RangeError("Invalid value for isolate: " + value);
      return value || "auto";
    } });
    NodeProp.contextHash = new NodeProp({ perNode: true });
    NodeProp.lookAhead = new NodeProp({ perNode: true });
    NodeProp.mounted = new NodeProp({ perNode: true });
    MountedTree = class {
      constructor(tree2, overlay, parser7) {
        this.tree = tree2;
        this.overlay = overlay;
        this.parser = parser7;
      }
      /**
      @internal
      */
      static get(tree2) {
        return tree2 && tree2.props && tree2.props[NodeProp.mounted.id];
      }
    };
    noProps = /* @__PURE__ */ Object.create(null);
    NodeType = class _NodeType {
      /**
      @internal
      */
      constructor(name2, props, id2, flags = 0) {
        this.name = name2;
        this.props = props;
        this.id = id2;
        this.flags = flags;
      }
      /**
      Define a node type.
      */
      static define(spec) {
        let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
        let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
        let type = new _NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props)
          for (let src of spec.props) {
            if (!Array.isArray(src))
              src = src(type);
            if (src) {
              if (src[0].perNode)
                throw new RangeError("Can't store a per-node prop on a node type");
              props[src[0].id] = src[1];
            }
          }
        return type;
      }
      /**
      Retrieves a node prop for this type. Will return `undefined` if
      the prop isn't present on this node.
      */
      prop(prop) {
        return this.props[prop.id];
      }
      /**
      True when this is the top node of a grammar.
      */
      get isTop() {
        return (this.flags & 1) > 0;
      }
      /**
      True when this node is produced by a skip rule.
      */
      get isSkipped() {
        return (this.flags & 2) > 0;
      }
      /**
      Indicates whether this is an error node.
      */
      get isError() {
        return (this.flags & 4) > 0;
      }
      /**
      When true, this node type doesn't correspond to a user-declared
      named node, for example because it is used to cache repetition.
      */
      get isAnonymous() {
        return (this.flags & 8) > 0;
      }
      /**
      Returns true when this node's name or one of its
      [groups](#common.NodeProp^group) matches the given string.
      */
      is(name2) {
        if (typeof name2 == "string") {
          if (this.name == name2)
            return true;
          let group = this.prop(NodeProp.group);
          return group ? group.indexOf(name2) > -1 : false;
        }
        return this.id == name2;
      }
      /**
      Create a function from node types to arbitrary values by
      specifying an object whose property names are node or
      [group](#common.NodeProp^group) names. Often useful with
      [`NodeProp.add`](#common.NodeProp.add). You can put multiple
      names, separated by spaces, in a single property name to map
      multiple node names to a single value.
      */
      static match(map2) {
        let direct = /* @__PURE__ */ Object.create(null);
        for (let prop in map2)
          for (let name2 of prop.split(" "))
            direct[name2] = map2[prop];
        return (node) => {
          for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
            let found = direct[i < 0 ? node.name : groups[i]];
            if (found)
              return found;
          }
        };
      }
    };
    NodeType.none = new NodeType(
      "",
      /* @__PURE__ */ Object.create(null),
      0,
      8
      /* NodeFlag.Anonymous */
    );
    NodeSet = class _NodeSet {
      /**
      Create a set with the given types. The `id` property of each
      type should correspond to its position within the array.
      */
      constructor(types2) {
        this.types = types2;
        for (let i = 0; i < types2.length; i++)
          if (types2[i].id != i)
            throw new RangeError("Node type ids should correspond to array positions when creating a node set");
      }
      /**
      Create a copy of this set with some node properties added. The
      arguments to this method can be created with
      [`NodeProp.add`](#common.NodeProp.add).
      */
      extend(...props) {
        let newTypes = [];
        for (let type of this.types) {
          let newProps = null;
          for (let source of props) {
            let add2 = source(type);
            if (add2) {
              if (!newProps)
                newProps = Object.assign({}, type.props);
              let value = add2[1], prop = add2[0];
              if (prop.combine && prop.id in newProps)
                value = prop.combine(newProps[prop.id], value);
              newProps[prop.id] = value;
            }
          }
          newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new _NodeSet(newTypes);
      }
    };
    CachedNode = /* @__PURE__ */ new WeakMap();
    CachedInnerNode = /* @__PURE__ */ new WeakMap();
    (function(IterMode2) {
      IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
      IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
      IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
      IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
    })(IterMode || (IterMode = {}));
    Tree2 = class _Tree {
      /**
      Construct a new tree. See also [`Tree.build`](#common.Tree^build).
      */
      constructor(type, children, positions, length, props) {
        this.type = type;
        this.children = children;
        this.positions = positions;
        this.length = length;
        this.props = null;
        if (props && props.length) {
          this.props = /* @__PURE__ */ Object.create(null);
          for (let [prop, value] of props)
            this.props[typeof prop == "number" ? prop : prop.id] = value;
        }
      }
      /**
      @internal
      */
      toString() {
        let mounted = MountedTree.get(this);
        if (mounted && !mounted.overlay)
          return mounted.tree.toString();
        let children = "";
        for (let ch of this.children) {
          let str = ch.toString();
          if (str) {
            if (children)
              children += ",";
            children += str;
          }
        }
        return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
      }
      /**
      Get a [tree cursor](#common.TreeCursor) positioned at the top of
      the tree. Mode can be used to [control](#common.IterMode) which
      nodes the cursor visits.
      */
      cursor(mode = 0) {
        return new TreeCursor(this.topNode, mode);
      }
      /**
      Get a [tree cursor](#common.TreeCursor) pointing into this tree
      at the given position and side (see
      [`moveTo`](#common.TreeCursor.moveTo).
      */
      cursorAt(pos, side = 0, mode = 0) {
        let scope = CachedNode.get(this) || this.topNode;
        let cursor2 = new TreeCursor(scope);
        cursor2.moveTo(pos, side);
        CachedNode.set(this, cursor2._tree);
        return cursor2;
      }
      /**
      Get a [syntax node](#common.SyntaxNode) object for the top of the
      tree.
      */
      get topNode() {
        return new TreeNode2(this, 0, 0, null);
      }
      /**
      Get the [syntax node](#common.SyntaxNode) at the given position.
      If `side` is -1, this will move into nodes that end at the
      position. If 1, it'll move into nodes that start at the
      position. With 0, it'll only enter nodes that cover the position
      from both sides.
      
      Note that this will not enter
      [overlays](#common.MountedTree.overlay), and you often want
      [`resolveInner`](#common.Tree.resolveInner) instead.
      */
      resolve(pos, side = 0) {
        let node = resolveNode2(CachedNode.get(this) || this.topNode, pos, side, false);
        CachedNode.set(this, node);
        return node;
      }
      /**
      Like [`resolve`](#common.Tree.resolve), but will enter
      [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
      pointing into the innermost overlaid tree at the given position
      (with parent links going through all parent structure, including
      the host trees).
      */
      resolveInner(pos, side = 0) {
        let node = resolveNode2(CachedInnerNode.get(this) || this.topNode, pos, side, true);
        CachedInnerNode.set(this, node);
        return node;
      }
      /**
      In some situations, it can be useful to iterate through all
      nodes around a position, including those in overlays that don't
      directly cover the position. This method gives you an iterator
      that will produce all nodes, from small to big, around the given
      position.
      */
      resolveStack(pos, side = 0) {
        return stackIterator(this, pos, side);
      }
      /**
      Iterate over the tree and its children, calling `enter` for any
      node that touches the `from`/`to` region (if given) before
      running over such a node's children, and `leave` (if given) when
      leaving the node. When `enter` returns `false`, that node will
      not have its children iterated over (or `leave` called).
      */
      iterate(spec) {
        let { enter, leave, from: from2 = 0, to = this.length } = spec;
        let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
        for (let c = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
          let entered = false;
          if (c.from <= to && c.to >= from2 && (!anon && c.type.isAnonymous || enter(c) !== false)) {
            if (c.firstChild())
              continue;
            entered = true;
          }
          for (; ; ) {
            if (entered && leave && (anon || !c.type.isAnonymous))
              leave(c);
            if (c.nextSibling())
              break;
            if (!c.parent())
              return;
            entered = true;
          }
        }
      }
      /**
      Get the value of the given [node prop](#common.NodeProp) for this
      node. Works with both per-node and per-type props.
      */
      prop(prop) {
        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
      }
      /**
      Returns the node's [per-node props](#common.NodeProp.perNode) in a
      format that can be passed to the [`Tree`](#common.Tree)
      constructor.
      */
      get propValues() {
        let result = [];
        if (this.props)
          for (let id2 in this.props)
            result.push([+id2, this.props[id2]]);
        return result;
      }
      /**
      Balance the direct children of this tree, producing a copy of
      which may have children grouped into subtrees with type
      [`NodeType.none`](#common.NodeType^none).
      */
      balance(config3 = {}) {
        return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new _Tree(this.type, children, positions, length, this.propValues), config3.makeTree || ((children, positions, length) => new _Tree(NodeType.none, children, positions, length)));
      }
      /**
      Build a tree from a postfix-ordered buffer of node information,
      or a cursor over such a buffer.
      */
      static build(data2) {
        return buildTree(data2);
      }
    };
    Tree2.empty = new Tree2(NodeType.none, [], [], 0);
    FlatBufferCursor = class _FlatBufferCursor {
      constructor(buffer, index) {
        this.buffer = buffer;
        this.index = index;
      }
      get id() {
        return this.buffer[this.index - 4];
      }
      get start() {
        return this.buffer[this.index - 3];
      }
      get end() {
        return this.buffer[this.index - 2];
      }
      get size() {
        return this.buffer[this.index - 1];
      }
      get pos() {
        return this.index;
      }
      next() {
        this.index -= 4;
      }
      fork() {
        return new _FlatBufferCursor(this.buffer, this.index);
      }
    };
    TreeBuffer = class _TreeBuffer {
      /**
      Create a tree buffer.
      */
      constructor(buffer, length, set) {
        this.buffer = buffer;
        this.length = length;
        this.set = set;
      }
      /**
      @internal
      */
      get type() {
        return NodeType.none;
      }
      /**
      @internal
      */
      toString() {
        let result = [];
        for (let index = 0; index < this.buffer.length; ) {
          result.push(this.childString(index));
          index = this.buffer[index + 3];
        }
        return result.join(",");
      }
      /**
      @internal
      */
      childString(index) {
        let id2 = this.buffer[index], endIndex = this.buffer[index + 3];
        let type = this.set.types[id2], result = type.name;
        if (/\W/.test(result) && !type.isError)
          result = JSON.stringify(result);
        index += 4;
        if (endIndex == index)
          return result;
        let children = [];
        while (index < endIndex) {
          children.push(this.childString(index));
          index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
      }
      /**
      @internal
      */
      findChild(startIndex, endIndex, dir, pos, side) {
        let { buffer } = this, pick = -1;
        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
          if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
            pick = i;
            if (dir > 0)
              break;
          }
        }
        return pick;
      }
      /**
      @internal
      */
      slice(startI, endI, from2) {
        let b = this.buffer;
        let copy = new Uint16Array(endI - startI), len = 0;
        for (let i = startI, j = 0; i < endI; ) {
          copy[j++] = b[i++];
          copy[j++] = b[i++] - from2;
          let to = copy[j++] = b[i++] - from2;
          copy[j++] = b[i++] - startI;
          len = Math.max(len, to);
        }
        return new _TreeBuffer(copy, len, this.set);
      }
    };
    BaseNode = class {
      cursor(mode = 0) {
        return new TreeCursor(this, mode);
      }
      getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
      }
      getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
      }
      resolve(pos, side = 0) {
        return resolveNode2(this, pos, side, false);
      }
      resolveInner(pos, side = 0) {
        return resolveNode2(this, pos, side, true);
      }
      matchContext(context2) {
        return matchNodeContext(this.parent, context2);
      }
      enterUnfinishedNodesBefore(pos) {
        let scan2 = this.childBefore(pos), node = this;
        while (scan2) {
          let last4 = scan2.lastChild;
          if (!last4 || last4.to != scan2.to)
            break;
          if (last4.type.isError && last4.from == last4.to) {
            node = scan2;
            scan2 = last4.prevSibling;
          } else {
            scan2 = last4;
          }
        }
        return node;
      }
      get node() {
        return this;
      }
      get next() {
        return this.parent;
      }
    };
    TreeNode2 = class _TreeNode extends BaseNode {
      constructor(_tree, from2, index, _parent) {
        super();
        this._tree = _tree;
        this.from = from2;
        this.index = index;
        this._parent = _parent;
      }
      get type() {
        return this._tree.type;
      }
      get name() {
        return this._tree.type.name;
      }
      get to() {
        return this.from + this._tree.length;
      }
      nextChild(i, dir, pos, side, mode = 0) {
        for (let parent = this; ; ) {
          for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
            let next = children[i], start = positions[i] + parent.from;
            if (!checkSide(side, pos, start, start + next.length))
              continue;
            if (next instanceof TreeBuffer) {
              if (mode & IterMode.ExcludeBuffers)
                continue;
              let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
              if (index > -1)
                return new BufferNode(new BufferContext(parent, next, i, start), null, index);
            } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
              let mounted;
              if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)
                return new _TreeNode(mounted.tree, start, i, parent);
              let inner = new _TreeNode(next, start, i, parent);
              return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
            }
          }
          if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
            return null;
          if (parent.index >= 0)
            i = parent.index + dir;
          else
            i = dir < 0 ? -1 : parent._parent._tree.children.length;
          parent = parent._parent;
          if (!parent)
            return null;
        }
      }
      get firstChild() {
        return this.nextChild(
          0,
          1,
          0,
          4
          /* Side.DontCare */
        );
      }
      get lastChild() {
        return this.nextChild(
          this._tree.children.length - 1,
          -1,
          0,
          4
          /* Side.DontCare */
        );
      }
      childAfter(pos) {
        return this.nextChild(
          0,
          1,
          pos,
          2
          /* Side.After */
        );
      }
      childBefore(pos) {
        return this.nextChild(
          this._tree.children.length - 1,
          -1,
          pos,
          -2
          /* Side.Before */
        );
      }
      enter(pos, side, mode = 0) {
        let mounted;
        if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
          let rPos = pos - this.from;
          for (let { from: from2, to } of mounted.overlay) {
            if ((side > 0 ? from2 <= rPos : from2 < rPos) && (side < 0 ? to >= rPos : to > rPos))
              return new _TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
          }
        }
        return this.nextChild(0, 1, pos, side, mode);
      }
      nextSignificantParent() {
        let val = this;
        while (val.type.isAnonymous && val._parent)
          val = val._parent;
        return val;
      }
      get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
      }
      get nextSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(
          this.index + 1,
          1,
          0,
          4
          /* Side.DontCare */
        ) : null;
      }
      get prevSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(
          this.index - 1,
          -1,
          0,
          4
          /* Side.DontCare */
        ) : null;
      }
      get tree() {
        return this._tree;
      }
      toTree() {
        return this._tree;
      }
      /**
      @internal
      */
      toString() {
        return this._tree.toString();
      }
    };
    BufferContext = class {
      constructor(parent, buffer, index, start) {
        this.parent = parent;
        this.buffer = buffer;
        this.index = index;
        this.start = start;
      }
    };
    BufferNode = class _BufferNode extends BaseNode {
      get name() {
        return this.type.name;
      }
      get from() {
        return this.context.start + this.context.buffer.buffer[this.index + 1];
      }
      get to() {
        return this.context.start + this.context.buffer.buffer[this.index + 2];
      }
      constructor(context2, _parent, index) {
        super();
        this.context = context2;
        this._parent = _parent;
        this.index = index;
        this.type = context2.buffer.set.types[context2.buffer.buffer[index]];
      }
      child(dir, pos, side) {
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
        return index < 0 ? null : new _BufferNode(this.context, this, index);
      }
      get firstChild() {
        return this.child(
          1,
          0,
          4
          /* Side.DontCare */
        );
      }
      get lastChild() {
        return this.child(
          -1,
          0,
          4
          /* Side.DontCare */
        );
      }
      childAfter(pos) {
        return this.child(
          1,
          pos,
          2
          /* Side.After */
        );
      }
      childBefore(pos) {
        return this.child(
          -1,
          pos,
          -2
          /* Side.Before */
        );
      }
      enter(pos, side, mode = 0) {
        if (mode & IterMode.ExcludeBuffers)
          return null;
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
        return index < 0 ? null : new _BufferNode(this.context, this, index);
      }
      get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
      }
      externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(
          this.context.index + dir,
          dir,
          0,
          4
          /* Side.DontCare */
        );
      }
      get nextSibling() {
        let { buffer } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
          return new _BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
      }
      get prevSibling() {
        let { buffer } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart)
          return this.externalSibling(-1);
        return new _BufferNode(this.context, this._parent, buffer.findChild(
          parentStart,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
      }
      get tree() {
        return null;
      }
      toTree() {
        let children = [], positions = [];
        let { buffer } = this.context;
        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
        if (endI > startI) {
          let from2 = buffer.buffer[this.index + 1];
          children.push(buffer.slice(startI, endI, from2));
          positions.push(0);
        }
        return new Tree2(this.type, children, positions, this.to - this.from);
      }
      /**
      @internal
      */
      toString() {
        return this.context.buffer.childString(this.index);
      }
    };
    StackIterator = class {
      constructor(heads, node) {
        this.heads = heads;
        this.node = node;
      }
      get next() {
        return iterStack(this.heads);
      }
    };
    TreeCursor = class {
      /**
      Shorthand for `.type.name`.
      */
      get name() {
        return this.type.name;
      }
      /**
      @internal
      */
      constructor(node, mode = 0) {
        this.mode = mode;
        this.buffer = null;
        this.stack = [];
        this.index = 0;
        this.bufferNode = null;
        if (node instanceof TreeNode2) {
          this.yieldNode(node);
        } else {
          this._tree = node.context.parent;
          this.buffer = node.context;
          for (let n = node._parent; n; n = n._parent)
            this.stack.unshift(n.index);
          this.bufferNode = node;
          this.yieldBuf(node.index);
        }
      }
      yieldNode(node) {
        if (!node)
          return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
      }
      yieldBuf(index, type) {
        this.index = index;
        let { start, buffer } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
      }
      /**
      @internal
      */
      yield(node) {
        if (!node)
          return false;
        if (node instanceof TreeNode2) {
          this.buffer = null;
          return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
      }
      /**
      @internal
      */
      toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
      }
      /**
      @internal
      */
      enterChild(dir, pos, side) {
        if (!this.buffer)
          return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
        let { buffer } = this.buffer;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
        if (index < 0)
          return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
      }
      /**
      Move the cursor to this node's first child. When this returns
      false, the node has no child, and the cursor has not been moved.
      */
      firstChild() {
        return this.enterChild(
          1,
          0,
          4
          /* Side.DontCare */
        );
      }
      /**
      Move the cursor to this node's last child.
      */
      lastChild() {
        return this.enterChild(
          -1,
          0,
          4
          /* Side.DontCare */
        );
      }
      /**
      Move the cursor to the first child that ends after `pos`.
      */
      childAfter(pos) {
        return this.enterChild(
          1,
          pos,
          2
          /* Side.After */
        );
      }
      /**
      Move to the last child that starts before `pos`.
      */
      childBefore(pos) {
        return this.enterChild(
          -1,
          pos,
          -2
          /* Side.Before */
        );
      }
      /**
      Move the cursor to the child around `pos`. If side is -1 the
      child may end at that position, when 1 it may start there. This
      will also enter [overlaid](#common.MountedTree.overlay)
      [mounted](#common.NodeProp^mounted) trees unless `overlays` is
      set to false.
      */
      enter(pos, side, mode = this.mode) {
        if (!this.buffer)
          return this.yield(this._tree.enter(pos, side, mode));
        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
      }
      /**
      Move to the node's parent node, if this isn't the top node.
      */
      parent() {
        if (!this.buffer)
          return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
          return this.yieldBuf(this.stack.pop());
        let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
      }
      /**
      @internal
      */
      sibling(dir) {
        if (!this.buffer)
          return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
        let { buffer } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
          let parentStart = d < 0 ? 0 : this.stack[d] + 4;
          if (this.index != parentStart)
            return this.yieldBuf(buffer.findChild(
              parentStart,
              this.index,
              -1,
              0,
              4
              /* Side.DontCare */
            ));
        } else {
          let after = buffer.buffer[this.index + 3];
          if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
            return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
      }
      /**
      Move to this node's next sibling, if any.
      */
      nextSibling() {
        return this.sibling(1);
      }
      /**
      Move to this node's previous sibling, if any.
      */
      prevSibling() {
        return this.sibling(-1);
      }
      atLastNode(dir) {
        let index, parent, { buffer } = this;
        if (buffer) {
          if (dir > 0) {
            if (this.index < buffer.buffer.buffer.length)
              return false;
          } else {
            for (let i = 0; i < this.index; i++)
              if (buffer.buffer.buffer[i + 3] < this.index)
                return false;
          }
          ({ index, parent } = buffer);
        } else {
          ({ index, _parent: parent } = this._tree);
        }
        for (; parent; { index, _parent: parent } = parent) {
          if (index > -1)
            for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
              let child = parent._tree.children[i];
              if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
                return false;
            }
        }
        return true;
      }
      move(dir, enter) {
        if (enter && this.enterChild(
          dir,
          0,
          4
          /* Side.DontCare */
        ))
          return true;
        for (; ; ) {
          if (this.sibling(dir))
            return true;
          if (this.atLastNode(dir) || !this.parent())
            return false;
        }
      }
      /**
      Move to the next node in a
      [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
      traversal, going from a node to its first child or, if the
      current node is empty or `enter` is false, its next sibling or
      the next sibling of the first parent node that has one.
      */
      next(enter = true) {
        return this.move(1, enter);
      }
      /**
      Move to the next node in a last-to-first pre-order traversal. A
      node is followed by its last child or, if it has none, its
      previous sibling or the previous sibling of the first parent
      node that has one.
      */
      prev(enter = true) {
        return this.move(-1, enter);
      }
      /**
      Move the cursor to the innermost node that covers `pos`. If
      `side` is -1, it will enter nodes that end at `pos`. If it is 1,
      it will enter nodes that start at `pos`.
      */
      moveTo(pos, side = 0) {
        while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
          if (!this.parent())
            break;
        while (this.enterChild(1, pos, side)) {
        }
        return this;
      }
      /**
      Get a [syntax node](#common.SyntaxNode) at the cursor's current
      position.
      */
      get node() {
        if (!this.buffer)
          return this._tree;
        let cache3 = this.bufferNode, result = null, depth = 0;
        if (cache3 && cache3.context == this.buffer) {
          scan: for (let index = this.index, d = this.stack.length; d >= 0; ) {
            for (let c = cache3; c; c = c._parent)
              if (c.index == index) {
                if (index == this.index)
                  return c;
                result = c;
                depth = d + 1;
                break scan;
              }
            index = this.stack[--d];
          }
        }
        for (let i = depth; i < this.stack.length; i++)
          result = new BufferNode(this.buffer, result, this.stack[i]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
      }
      /**
      Get the [tree](#common.Tree) that represents the current node, if
      any. Will return null when the node is in a [tree
      buffer](#common.TreeBuffer).
      */
      get tree() {
        return this.buffer ? null : this._tree._tree;
      }
      /**
      Iterate over the current node and all its descendants, calling
      `enter` when entering a node and `leave`, if given, when leaving
      one. When `enter` returns `false`, any children of that node are
      skipped, and `leave` isn't called for it.
      */
      iterate(enter, leave) {
        for (let depth = 0; ; ) {
          let mustLeave = false;
          if (this.type.isAnonymous || enter(this) !== false) {
            if (this.firstChild()) {
              depth++;
              continue;
            }
            if (!this.type.isAnonymous)
              mustLeave = true;
          }
          for (; ; ) {
            if (mustLeave && leave)
              leave(this);
            mustLeave = this.type.isAnonymous;
            if (!depth)
              return;
            if (this.nextSibling())
              break;
            this.parent();
            depth--;
            mustLeave = true;
          }
        }
      }
      /**
      Test whether the current node matches a given contexta sequence
      of direct parent node names. Empty strings in the context array
      are treated as wildcards.
      */
      matchContext(context2) {
        if (!this.buffer)
          return matchNodeContext(this.node.parent, context2);
        let { buffer } = this.buffer, { types: types2 } = buffer.set;
        for (let i = context2.length - 1, d = this.stack.length - 1; i >= 0; d--) {
          if (d < 0)
            return matchNodeContext(this._tree, context2, i);
          let type = types2[buffer.buffer[this.stack[d]]];
          if (!type.isAnonymous) {
            if (context2[i] && context2[i] != type.name)
              return false;
            i--;
          }
        }
        return true;
      }
    };
    nodeSizeCache = /* @__PURE__ */ new WeakMap();
    NodeWeakMap = class {
      constructor() {
        this.map = /* @__PURE__ */ new WeakMap();
      }
      setBuffer(buffer, index, value) {
        let inner = this.map.get(buffer);
        if (!inner)
          this.map.set(buffer, inner = /* @__PURE__ */ new Map());
        inner.set(index, value);
      }
      getBuffer(buffer, index) {
        let inner = this.map.get(buffer);
        return inner && inner.get(index);
      }
      /**
      Set the value for this syntax node.
      */
      set(node, value) {
        if (node instanceof BufferNode)
          this.setBuffer(node.context.buffer, node.index, value);
        else if (node instanceof TreeNode2)
          this.map.set(node.tree, value);
      }
      /**
      Retrieve value for this syntax node, if it exists in the map.
      */
      get(node) {
        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode2 ? this.map.get(node.tree) : void 0;
      }
      /**
      Set the value for the node that a cursor currently points to.
      */
      cursorSet(cursor2, value) {
        if (cursor2.buffer)
          this.setBuffer(cursor2.buffer.buffer, cursor2.index, value);
        else
          this.map.set(cursor2.tree, value);
      }
      /**
      Retrieve the value for the node that a cursor currently points
      to.
      */
      cursorGet(cursor2) {
        return cursor2.buffer ? this.getBuffer(cursor2.buffer.buffer, cursor2.index) : this.map.get(cursor2.tree);
      }
    };
    TreeFragment = class _TreeFragment {
      /**
      Construct a tree fragment. You'll usually want to use
      [`addTree`](#common.TreeFragment^addTree) and
      [`applyChanges`](#common.TreeFragment^applyChanges) instead of
      calling this directly.
      */
      constructor(from2, to, tree2, offset, openStart = false, openEnd = false) {
        this.from = from2;
        this.to = to;
        this.tree = tree2;
        this.offset = offset;
        this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
      }
      /**
      Whether the start of the fragment represents the start of a
      parse, or the end of a change. (In the second case, it may not
      be safe to reuse some nodes at the start, depending on the
      parsing algorithm.)
      */
      get openStart() {
        return (this.open & 1) > 0;
      }
      /**
      Whether the end of the fragment represents the end of a
      full-document parse, or the start of a change.
      */
      get openEnd() {
        return (this.open & 2) > 0;
      }
      /**
      Create a set of fragments from a freshly parsed tree, or update
      an existing set of fragments by replacing the ones that overlap
      with a tree with content from the new tree. When `partial` is
      true, the parse is treated as incomplete, and the resulting
      fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
      true.
      */
      static addTree(tree2, fragments = [], partial = false) {
        let result = [new _TreeFragment(0, tree2.length, tree2, 0, false, partial)];
        for (let f of fragments)
          if (f.to > tree2.length)
            result.push(f);
        return result;
      }
      /**
      Apply a set of edits to an array of fragments, removing or
      splitting fragments as necessary to remove edited ranges, and
      adjusting offsets for fragments that moved.
      */
      static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length)
          return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        for (let cI = 0, pos = 0, off = 0; ; cI++) {
          let nextC = cI < changes.length ? changes[cI] : null;
          let nextPos = nextC ? nextC.fromA : 1e9;
          if (nextPos - pos >= minGap)
            while (nextF && nextF.from < nextPos) {
              let cut = nextF;
              if (pos >= cut.from || nextPos <= cut.to || off) {
                let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                cut = fFrom >= fTo ? null : new _TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
              }
              if (cut)
                result.push(cut);
              if (nextF.to > nextPos)
                break;
              nextF = fI < fragments.length ? fragments[fI++] : null;
            }
          if (!nextC)
            break;
          pos = nextC.toA;
          off = nextC.toA - nextC.toB;
        }
        return result;
      }
    };
    Parser = class {
      /**
      Start a parse, returning a [partial parse](#common.PartialParse)
      object. [`fragments`](#common.TreeFragment) can be passed in to
      make the parse incremental.
      
      By default, the entire input is parsed. You can pass `ranges`,
      which should be a sorted array of non-empty, non-overlapping
      ranges, to parse only those ranges. The tree returned in that
      case will start at `ranges[0].from`.
      */
      startParse(input2, fragments, ranges) {
        if (typeof input2 == "string")
          input2 = new StringInput(input2);
        ranges = !ranges ? [new Range2(0, input2.length)] : ranges.length ? ranges.map((r) => new Range2(r.from, r.to)) : [new Range2(0, 0)];
        return this.createParse(input2, fragments || [], ranges);
      }
      /**
      Run a full parse, returning the resulting tree.
      */
      parse(input2, fragments, ranges) {
        let parse = this.startParse(input2, fragments, ranges);
        for (; ; ) {
          let done = parse.advance();
          if (done)
            return done;
        }
      }
    };
    StringInput = class {
      constructor(string2) {
        this.string = string2;
      }
      get length() {
        return this.string.length;
      }
      chunk(from2) {
        return this.string.slice(from2);
      }
      get lineChunks() {
        return false;
      }
      read(from2, to) {
        return this.string.slice(from2, to);
      }
    };
    InnerParse = class {
      constructor(parser7, parse, overlay, target, from2) {
        this.parser = parser7;
        this.parse = parse;
        this.overlay = overlay;
        this.target = target;
        this.from = from2;
      }
    };
    ActiveOverlay = class {
      constructor(parser7, predicate, mounts, index, start, target, prev) {
        this.parser = parser7;
        this.predicate = predicate;
        this.mounts = mounts;
        this.index = index;
        this.start = start;
        this.target = target;
        this.prev = prev;
        this.depth = 0;
        this.ranges = [];
      }
    };
    stoppedInner = new NodeProp({ perNode: true });
    MixedParse = class {
      constructor(base2, nest, input2, fragments, ranges) {
        this.nest = nest;
        this.input = input2;
        this.fragments = fragments;
        this.ranges = ranges;
        this.inner = [];
        this.innerDone = 0;
        this.baseTree = null;
        this.stoppedAt = null;
        this.baseParse = base2;
      }
      advance() {
        if (this.baseParse) {
          let done2 = this.baseParse.advance();
          if (!done2)
            return null;
          this.baseParse = null;
          this.baseTree = done2;
          this.startInner();
          if (this.stoppedAt != null)
            for (let inner2 of this.inner)
              inner2.parse.stopAt(this.stoppedAt);
        }
        if (this.innerDone == this.inner.length) {
          let result = this.baseTree;
          if (this.stoppedAt != null)
            result = new Tree2(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
          return result;
        }
        let inner = this.inner[this.innerDone], done = inner.parse.advance();
        if (done) {
          this.innerDone++;
          let props = Object.assign(/* @__PURE__ */ Object.create(null), inner.target.props);
          props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
          inner.target.props = props;
        }
        return null;
      }
      get parsedPos() {
        if (this.baseParse)
          return 0;
        let pos = this.input.length;
        for (let i = this.innerDone; i < this.inner.length; i++) {
          if (this.inner[i].from < pos)
            pos = Math.min(pos, this.inner[i].parse.parsedPos);
        }
        return pos;
      }
      stopAt(pos) {
        this.stoppedAt = pos;
        if (this.baseParse)
          this.baseParse.stopAt(pos);
        else
          for (let i = this.innerDone; i < this.inner.length; i++)
            this.inner[i].parse.stopAt(pos);
      }
      startInner() {
        let fragmentCursor = new FragmentCursor(this.fragments);
        let overlay = null;
        let covered = null;
        let cursor2 = new TreeCursor(new TreeNode2(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
        scan: for (let nest, isCovered; ; ) {
          let enter = true, range;
          if (this.stoppedAt != null && cursor2.from >= this.stoppedAt) {
            enter = false;
          } else if (fragmentCursor.hasNode(cursor2)) {
            if (overlay) {
              let match2 = overlay.mounts.find((m) => m.frag.from <= cursor2.from && m.frag.to >= cursor2.to && m.mount.overlay);
              if (match2)
                for (let r of match2.mount.overlay) {
                  let from2 = r.from + match2.pos, to = r.to + match2.pos;
                  if (from2 >= cursor2.from && to <= cursor2.to && !overlay.ranges.some((r2) => r2.from < to && r2.to > from2))
                    overlay.ranges.push({ from: from2, to });
                }
            }
            enter = false;
          } else if (covered && (isCovered = checkCover(covered.ranges, cursor2.from, cursor2.to))) {
            enter = isCovered != 2;
          } else if (!cursor2.type.isAnonymous && (nest = this.nest(cursor2, this.input)) && (cursor2.from < cursor2.to || !nest.overlay)) {
            if (!cursor2.tree) {
              materialize(cursor2);
              if (overlay)
                overlay.depth++;
              if (covered)
                covered.depth++;
            }
            let oldMounts = fragmentCursor.findMounts(cursor2.from, nest.parser);
            if (typeof nest.overlay == "function") {
              overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor2.from, cursor2.tree, overlay);
            } else {
              let ranges = punchRanges(this.ranges, nest.overlay || (cursor2.from < cursor2.to ? [new Range2(cursor2.from, cursor2.to)] : []));
              if (ranges.length)
                checkRanges(ranges);
              if (ranges.length || !nest.overlay)
                this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges) : nest.parser.startParse(""), nest.overlay ? nest.overlay.map((r) => new Range2(r.from - cursor2.from, r.to - cursor2.from)) : null, cursor2.tree, ranges.length ? ranges[0].from : cursor2.from));
              if (!nest.overlay)
                enter = false;
              else if (ranges.length)
                covered = { ranges, depth: 0, prev: covered };
            }
          } else if (overlay && (range = overlay.predicate(cursor2))) {
            if (range === true)
              range = new Range2(cursor2.from, cursor2.to);
            if (range.from < range.to) {
              let last4 = overlay.ranges.length - 1;
              if (last4 >= 0 && overlay.ranges[last4].to == range.from)
                overlay.ranges[last4] = { from: overlay.ranges[last4].from, to: range.to };
              else
                overlay.ranges.push(range);
            }
          }
          if (enter && cursor2.firstChild()) {
            if (overlay)
              overlay.depth++;
            if (covered)
              covered.depth++;
          } else {
            for (; ; ) {
              if (cursor2.nextSibling())
                break;
              if (!cursor2.parent())
                break scan;
              if (overlay && !--overlay.depth) {
                let ranges = punchRanges(this.ranges, overlay.ranges);
                if (ranges.length) {
                  checkRanges(ranges);
                  this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map((r) => new Range2(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges[0].from));
                }
                overlay = overlay.prev;
              }
              if (covered && !--covered.depth)
                covered = covered.prev;
            }
          }
        }
      }
    };
    StructureCursor = class {
      constructor(root, offset) {
        this.offset = offset;
        this.done = false;
        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
      }
      // Move to the first node (in pre-order) that starts at or after `pos`.
      moveTo(pos) {
        let { cursor: cursor2 } = this, p = pos - this.offset;
        while (!this.done && cursor2.from < p) {
          if (cursor2.to >= pos && cursor2.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;
          else if (!cursor2.next(false))
            this.done = true;
        }
      }
      hasNode(cursor2) {
        this.moveTo(cursor2.from);
        if (!this.done && this.cursor.from + this.offset == cursor2.from && this.cursor.tree) {
          for (let tree2 = this.cursor.tree; ; ) {
            if (tree2 == cursor2.tree)
              return true;
            if (tree2.children.length && tree2.positions[0] == 0 && tree2.children[0] instanceof Tree2)
              tree2 = tree2.children[0];
            else
              break;
          }
        }
        return false;
      }
    };
    FragmentCursor = class {
      constructor(fragments) {
        var _a2;
        this.fragments = fragments;
        this.curTo = 0;
        this.fragI = 0;
        if (fragments.length) {
          let first2 = this.curFrag = fragments[0];
          this.curTo = (_a2 = first2.tree.prop(stoppedInner)) !== null && _a2 !== void 0 ? _a2 : first2.to;
          this.inner = new StructureCursor(first2.tree, -first2.offset);
        } else {
          this.curFrag = this.inner = null;
        }
      }
      hasNode(node) {
        while (this.curFrag && node.from >= this.curTo)
          this.nextFrag();
        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
      }
      nextFrag() {
        var _a2;
        this.fragI++;
        if (this.fragI == this.fragments.length) {
          this.curFrag = this.inner = null;
        } else {
          let frag = this.curFrag = this.fragments[this.fragI];
          this.curTo = (_a2 = frag.tree.prop(stoppedInner)) !== null && _a2 !== void 0 ? _a2 : frag.to;
          this.inner = new StructureCursor(frag.tree, -frag.offset);
        }
      }
      findMounts(pos, parser7) {
        var _a2;
        let result = [];
        if (this.inner) {
          this.inner.cursor.moveTo(pos, 1);
          for (let pos2 = this.inner.cursor.node; pos2; pos2 = pos2.parent) {
            let mount = (_a2 = pos2.tree) === null || _a2 === void 0 ? void 0 : _a2.prop(NodeProp.mounted);
            if (mount && mount.parser == parser7) {
              for (let i = this.fragI; i < this.fragments.length; i++) {
                let frag = this.fragments[i];
                if (frag.from >= pos2.to)
                  break;
                if (frag.tree == this.curFrag.tree)
                  result.push({
                    frag,
                    pos: pos2.from - frag.offset,
                    mount
                  });
              }
            }
          }
        }
        return result;
      }
    };
  }
});

// node_modules/@lezer/lr/dist/index.js
function decodeArray(input2, Type3 = Uint16Array) {
  if (typeof input2 != "string")
    return input2;
  let array = null;
  for (let pos = 0, out = 0; pos < input2.length; ) {
    let value = 0;
    for (; ; ) {
      let next = input2.charCodeAt(pos++), stop = false;
      if (next == 126) {
        value = 65535;
        break;
      }
      if (next >= 92)
        next--;
      if (next >= 34)
        next--;
      let digit = next - 32;
      if (digit >= 46) {
        digit -= 46;
        stop = true;
      }
      value += digit;
      if (stop)
        break;
      value *= 46;
    }
    if (array)
      array[out++] = value;
    else
      array = new Type3(value);
  }
  return array;
}
function readToken(data2, input2, stack, group, precTable, precOffset) {
  let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;
  scan: for (; ; ) {
    if ((groupMask & data2[state]) == 0)
      break;
    let accEnd = data2[state + 1];
    for (let i = state + 3; i < accEnd; i += 2)
      if ((data2[i + 1] & groupMask) > 0) {
        let term = data2[i];
        if (dialect.allows(term) && (input2.token.value == -1 || input2.token.value == term || overrides(term, input2.token.value, precTable, precOffset))) {
          input2.acceptToken(term);
          break;
        }
      }
    let next = input2.next, low = 0, high = data2[state + 2];
    if (input2.next < 0 && high > low && data2[accEnd + high * 3 - 3] == 65535) {
      state = data2[accEnd + high * 3 - 1];
      continue scan;
    }
    for (; low < high; ) {
      let mid = low + high >> 1;
      let index = accEnd + mid + (mid << 1);
      let from2 = data2[index], to = data2[index + 1] || 65536;
      if (next < from2)
        high = mid;
      else if (next >= to)
        low = mid + 1;
      else {
        state = data2[index + 2];
        input2.advance();
        continue scan;
      }
    }
    break;
  }
}
function findOffset(data2, start, term) {
  for (let i = start, next; (next = data2[i]) != 65535; i++)
    if (next == term)
      return i - start;
  return -1;
}
function overrides(token, prev, tableData, tableOffset) {
  let iPrev = findOffset(tableData, tableOffset, prev);
  return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
}
function cutAt(tree2, pos, side) {
  let cursor2 = tree2.cursor(IterMode.IncludeAnonymous);
  cursor2.moveTo(pos);
  for (; ; ) {
    if (!(side < 0 ? cursor2.childBefore(pos) : cursor2.childAfter(pos)))
      for (; ; ) {
        if ((side < 0 ? cursor2.to < pos : cursor2.from > pos) && !cursor2.type.isError)
          return side < 0 ? Math.max(0, Math.min(
            cursor2.to - 1,
            pos - 25
            /* Lookahead.Margin */
          )) : Math.min(tree2.length, Math.max(
            cursor2.from + 1,
            pos + 25
            /* Lookahead.Margin */
          ));
        if (side < 0 ? cursor2.prevSibling() : cursor2.nextSibling())
          break;
        if (!cursor2.parent())
          return side < 0 ? 0 : tree2.length;
      }
  }
}
function pushStackDedup(stack, newStacks) {
  for (let i = 0; i < newStacks.length; i++) {
    let other = newStacks[i];
    if (other.pos == stack.pos && other.sameState(stack)) {
      if (newStacks[i].score < stack.score)
        newStacks[i] = stack;
      return;
    }
  }
  newStacks.push(stack);
}
function pair(data2, off) {
  return data2[off] | data2[off + 1] << 16;
}
function findFinished(stacks) {
  let best = null;
  for (let stack of stacks) {
    let stopped = stack.p.stoppedAt;
    if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(
      stack.state,
      2
      /* StateFlag.Accepting */
    ) && (!best || best.score < stack.score))
      best = stack;
  }
  return best;
}
function getSpecializer(spec) {
  if (spec.external) {
    let mask = spec.extend ? 1 : 0;
    return (value, stack) => spec.external(value, stack) << 1 | mask;
  }
  return spec.get;
}
var Stack, StackContext, SimulatedStack, StackBufferCursor, CachedToken, nullToken, InputStream, TokenGroup, LocalTokenGroup, ExternalTokenizer, verbose, stackIDs, FragmentCursor2, TokenCache, Parse, Dialect, id, ContextTracker, LRParser;
var init_dist4 = __esm({
  "node_modules/@lezer/lr/dist/index.js"() {
    "use strict";
    init_dist3();
    Stack = class _Stack {
      /**
      @internal
      */
      constructor(p, stack, state, reducePos, pos, score2, buffer, bufferBase, curContext, lookAhead = 0, parent) {
        this.p = p;
        this.stack = stack;
        this.state = state;
        this.reducePos = reducePos;
        this.pos = pos;
        this.score = score2;
        this.buffer = buffer;
        this.bufferBase = bufferBase;
        this.curContext = curContext;
        this.lookAhead = lookAhead;
        this.parent = parent;
      }
      /**
      @internal
      */
      toString() {
        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
      }
      // Start an empty stack
      /**
      @internal
      */
      static start(p, state, pos = 0) {
        let cx = p.parser.context;
        return new _Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
      }
      /**
      The stack's current [context](#lr.ContextTracker) value, if
      any. Its type will depend on the context tracker's type
      parameter, or it will be `null` if there is no context
      tracker.
      */
      get context() {
        return this.curContext ? this.curContext.context : null;
      }
      // Push a state onto the stack, tracking its start position as well
      // as the buffer base at that point.
      /**
      @internal
      */
      pushState(state, start) {
        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
        this.state = state;
      }
      // Apply a reduce action
      /**
      @internal
      */
      reduce(action) {
        var _a2;
        let depth = action >> 19, type = action & 65535;
        let { parser: parser7 } = this.p;
        let lookaheadRecord = this.reducePos < this.pos - 25;
        if (lookaheadRecord)
          this.setLookAhead(this.pos);
        let dPrec = parser7.dynamicPrecedence(type);
        if (dPrec)
          this.score += dPrec;
        if (depth == 0) {
          this.pushState(parser7.getGoto(this.state, type, true), this.reducePos);
          if (type < parser7.minRepeatTerm)
            this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);
          this.reduceContext(type, this.reducePos);
          return;
        }
        let base2 = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
        let start = base2 ? this.stack[base2 - 2] : this.p.ranges[0].from, size = this.reducePos - start;
        if (size >= 2e3 && !((_a2 = this.p.parser.nodeSet.types[type]) === null || _a2 === void 0 ? void 0 : _a2.isAnonymous)) {
          if (start == this.p.lastBigReductionStart) {
            this.p.bigReductionCount++;
            this.p.lastBigReductionSize = size;
          } else if (this.p.lastBigReductionSize < size) {
            this.p.bigReductionCount = 1;
            this.p.lastBigReductionStart = start;
            this.p.lastBigReductionSize = size;
          }
        }
        let bufferBase = base2 ? this.stack[base2 - 1] : 0, count2 = this.bufferBase + this.buffer.length - bufferBase;
        if (type < parser7.minRepeatTerm || action & 131072) {
          let pos = parser7.stateFlag(
            this.state,
            1
            /* StateFlag.Skipped */
          ) ? this.pos : this.reducePos;
          this.storeNode(type, start, pos, count2 + 4, true);
        }
        if (action & 262144) {
          this.state = this.stack[base2];
        } else {
          let baseStateID = this.stack[base2 - 3];
          this.state = parser7.getGoto(baseStateID, type, true);
        }
        while (this.stack.length > base2)
          this.stack.pop();
        this.reduceContext(type, start);
      }
      // Shift a value into the buffer
      /**
      @internal
      */
      storeNode(term, start, end, size = 4, mustSink = false) {
        if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
          let cur2 = this, top2 = this.buffer.length;
          if (top2 == 0 && cur2.parent) {
            top2 = cur2.bufferBase - cur2.parent.bufferBase;
            cur2 = cur2.parent;
          }
          if (top2 > 0 && cur2.buffer[top2 - 4] == 0 && cur2.buffer[top2 - 1] > -1) {
            if (start == end)
              return;
            if (cur2.buffer[top2 - 2] >= start) {
              cur2.buffer[top2 - 2] = end;
              return;
            }
          }
        }
        if (!mustSink || this.pos == end) {
          this.buffer.push(term, start, end, size);
        } else {
          let index = this.buffer.length;
          if (index > 0 && this.buffer[index - 4] != 0) {
            let mustMove = false;
            for (let scan2 = index; scan2 > 0 && this.buffer[scan2 - 2] > end; scan2 -= 4) {
              if (this.buffer[scan2 - 1] >= 0) {
                mustMove = true;
                break;
              }
            }
            if (mustMove)
              while (index > 0 && this.buffer[index - 2] > end) {
                this.buffer[index] = this.buffer[index - 4];
                this.buffer[index + 1] = this.buffer[index - 3];
                this.buffer[index + 2] = this.buffer[index - 2];
                this.buffer[index + 3] = this.buffer[index - 1];
                index -= 4;
                if (size > 4)
                  size -= 4;
              }
          }
          this.buffer[index] = term;
          this.buffer[index + 1] = start;
          this.buffer[index + 2] = end;
          this.buffer[index + 3] = size;
        }
      }
      // Apply a shift action
      /**
      @internal
      */
      shift(action, type, start, end) {
        if (action & 131072) {
          this.pushState(action & 65535, this.pos);
        } else if ((action & 262144) == 0) {
          let nextState = action, { parser: parser7 } = this.p;
          if (end > this.pos || type <= parser7.maxNode) {
            this.pos = end;
            if (!parser7.stateFlag(
              nextState,
              1
              /* StateFlag.Skipped */
            ))
              this.reducePos = end;
          }
          this.pushState(nextState, start);
          this.shiftContext(type, start);
          if (type <= parser7.maxNode)
            this.buffer.push(type, start, end, 4);
        } else {
          this.pos = end;
          this.shiftContext(type, start);
          if (type <= this.p.parser.maxNode)
            this.buffer.push(type, start, end, 4);
        }
      }
      // Apply an action
      /**
      @internal
      */
      apply(action, next, nextStart, nextEnd) {
        if (action & 65536)
          this.reduce(action);
        else
          this.shift(action, next, nextStart, nextEnd);
      }
      // Add a prebuilt (reused) node into the buffer.
      /**
      @internal
      */
      useNode(value, next) {
        let index = this.p.reused.length - 1;
        if (index < 0 || this.p.reused[index] != value) {
          this.p.reused.push(value);
          index++;
        }
        let start = this.pos;
        this.reducePos = this.pos = start + value.length;
        this.pushState(next, start);
        this.buffer.push(
          index,
          start,
          this.reducePos,
          -1
          /* size == -1 means this is a reused value */
        );
        if (this.curContext)
          this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
      }
      // Split the stack. Due to the buffer sharing and the fact
      // that `this.stack` tends to stay quite shallow, this isn't very
      // expensive.
      /**
      @internal
      */
      split() {
        let parent = this;
        let off = parent.buffer.length;
        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
          off -= 4;
        let buffer = parent.buffer.slice(off), base2 = parent.bufferBase + off;
        while (parent && base2 == parent.bufferBase)
          parent = parent.parent;
        return new _Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, this.lookAhead, parent);
      }
      // Try to recover from an error by 'deleting' (ignoring) one token.
      /**
      @internal
      */
      recoverByDelete(next, nextEnd) {
        let isNode = next <= this.p.parser.maxNode;
        if (isNode)
          this.storeNode(next, this.pos, nextEnd, 4);
        this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
        this.pos = this.reducePos = nextEnd;
        this.score -= 190;
      }
      /**
      Check if the given term would be able to be shifted (optionally
      after some reductions) on this stack. This can be useful for
      external tokenizers that want to make sure they only provide a
      given token when it applies.
      */
      canShift(term) {
        for (let sim = new SimulatedStack(this); ; ) {
          let action = this.p.parser.stateSlot(
            sim.state,
            4
            /* ParseState.DefaultReduce */
          ) || this.p.parser.hasAction(sim.state, term);
          if (action == 0)
            return false;
          if ((action & 65536) == 0)
            return true;
          sim.reduce(action);
        }
      }
      // Apply up to Recover.MaxNext recovery actions that conceptually
      // inserts some missing token or rule.
      /**
      @internal
      */
      recoverByInsert(next) {
        if (this.stack.length >= 300)
          return [];
        let nextStates = this.p.parser.nextStates(this.state);
        if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
          let best = [];
          for (let i = 0, s; i < nextStates.length; i += 2) {
            if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
              best.push(nextStates[i], s);
          }
          if (this.stack.length < 120)
            for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
              let s = nextStates[i + 1];
              if (!best.some((v, i2) => i2 & 1 && v == s))
                best.push(nextStates[i], s);
            }
          nextStates = best;
        }
        let result = [];
        for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
          let s = nextStates[i + 1];
          if (s == this.state)
            continue;
          let stack = this.split();
          stack.pushState(s, this.pos);
          stack.storeNode(0, stack.pos, stack.pos, 4, true);
          stack.shiftContext(nextStates[i], this.pos);
          stack.reducePos = this.pos;
          stack.score -= 200;
          result.push(stack);
        }
        return result;
      }
      // Force a reduce, if possible. Return false if that can't
      // be done.
      /**
      @internal
      */
      forceReduce() {
        let { parser: parser7 } = this.p;
        let reduce = parser7.stateSlot(
          this.state,
          5
          /* ParseState.ForcedReduce */
        );
        if ((reduce & 65536) == 0)
          return false;
        if (!parser7.validAction(this.state, reduce)) {
          let depth = reduce >> 19, term = reduce & 65535;
          let target = this.stack.length - depth * 3;
          if (target < 0 || parser7.getGoto(this.stack[target], term, false) < 0) {
            let backup = this.findForcedReduction();
            if (backup == null)
              return false;
            reduce = backup;
          }
          this.storeNode(0, this.pos, this.pos, 4, true);
          this.score -= 100;
        }
        this.reducePos = this.pos;
        this.reduce(reduce);
        return true;
      }
      /**
      Try to scan through the automaton to find some kind of reduction
      that can be applied. Used when the regular ForcedReduce field
      isn't a valid action. @internal
      */
      findForcedReduction() {
        let { parser: parser7 } = this.p, seen = [];
        let explore = (state, depth) => {
          if (seen.includes(state))
            return;
          seen.push(state);
          return parser7.allActions(state, (action) => {
            if (action & (262144 | 131072)) ;
            else if (action & 65536) {
              let rDepth = (action >> 19) - depth;
              if (rDepth > 1) {
                let term = action & 65535, target = this.stack.length - rDepth * 3;
                if (target >= 0 && parser7.getGoto(this.stack[target], term, false) >= 0)
                  return rDepth << 19 | 65536 | term;
              }
            } else {
              let found = explore(action, depth + 1);
              if (found != null)
                return found;
            }
          });
        };
        return explore(this.state, 0);
      }
      /**
      @internal
      */
      forceAll() {
        while (!this.p.parser.stateFlag(
          this.state,
          2
          /* StateFlag.Accepting */
        )) {
          if (!this.forceReduce()) {
            this.storeNode(0, this.pos, this.pos, 4, true);
            break;
          }
        }
        return this;
      }
      /**
      Check whether this state has no further actions (assumed to be a direct descendant of the
      top state, since any other states must be able to continue
      somehow). @internal
      */
      get deadEnd() {
        if (this.stack.length != 3)
          return false;
        let { parser: parser7 } = this.p;
        return parser7.data[parser7.stateSlot(
          this.state,
          1
          /* ParseState.Actions */
        )] == 65535 && !parser7.stateSlot(
          this.state,
          4
          /* ParseState.DefaultReduce */
        );
      }
      /**
      Restart the stack (put it back in its start state). Only safe
      when this.stack.length == 3 (state is directly below the top
      state). @internal
      */
      restart() {
        this.storeNode(0, this.pos, this.pos, 4, true);
        this.state = this.stack[0];
        this.stack.length = 0;
      }
      /**
      @internal
      */
      sameState(other) {
        if (this.state != other.state || this.stack.length != other.stack.length)
          return false;
        for (let i = 0; i < this.stack.length; i += 3)
          if (this.stack[i] != other.stack[i])
            return false;
        return true;
      }
      /**
      Get the parser used by this stack.
      */
      get parser() {
        return this.p.parser;
      }
      /**
      Test whether a given dialect (by numeric ID, as exported from
      the terms file) is enabled.
      */
      dialectEnabled(dialectID) {
        return this.p.parser.dialect.flags[dialectID];
      }
      shiftContext(term, start) {
        if (this.curContext)
          this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
      }
      reduceContext(term, start) {
        if (this.curContext)
          this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
      }
      /**
      @internal
      */
      emitContext() {
        let last4 = this.buffer.length - 1;
        if (last4 < 0 || this.buffer[last4] != -3)
          this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
      }
      /**
      @internal
      */
      emitLookAhead() {
        let last4 = this.buffer.length - 1;
        if (last4 < 0 || this.buffer[last4] != -4)
          this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
      }
      updateContext(context2) {
        if (context2 != this.curContext.context) {
          let newCx = new StackContext(this.curContext.tracker, context2);
          if (newCx.hash != this.curContext.hash)
            this.emitContext();
          this.curContext = newCx;
        }
      }
      /**
      @internal
      */
      setLookAhead(lookAhead) {
        if (lookAhead > this.lookAhead) {
          this.emitLookAhead();
          this.lookAhead = lookAhead;
        }
      }
      /**
      @internal
      */
      close() {
        if (this.curContext && this.curContext.tracker.strict)
          this.emitContext();
        if (this.lookAhead > 0)
          this.emitLookAhead();
      }
    };
    StackContext = class {
      constructor(tracker, context2) {
        this.tracker = tracker;
        this.context = context2;
        this.hash = tracker.strict ? tracker.hash(context2) : 0;
      }
    };
    SimulatedStack = class {
      constructor(start) {
        this.start = start;
        this.state = start.state;
        this.stack = start.stack;
        this.base = this.stack.length;
      }
      reduce(action) {
        let term = action & 65535, depth = action >> 19;
        if (depth == 0) {
          if (this.stack == this.start.stack)
            this.stack = this.stack.slice();
          this.stack.push(this.state, 0, 0);
          this.base += 3;
        } else {
          this.base -= (depth - 1) * 3;
        }
        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
        this.state = goto;
      }
    };
    StackBufferCursor = class _StackBufferCursor {
      constructor(stack, pos, index) {
        this.stack = stack;
        this.pos = pos;
        this.index = index;
        this.buffer = stack.buffer;
        if (this.index == 0)
          this.maybeNext();
      }
      static create(stack, pos = stack.bufferBase + stack.buffer.length) {
        return new _StackBufferCursor(stack, pos, pos - stack.bufferBase);
      }
      maybeNext() {
        let next = this.stack.parent;
        if (next != null) {
          this.index = this.stack.bufferBase - next.bufferBase;
          this.stack = next;
          this.buffer = next.buffer;
        }
      }
      get id() {
        return this.buffer[this.index - 4];
      }
      get start() {
        return this.buffer[this.index - 3];
      }
      get end() {
        return this.buffer[this.index - 2];
      }
      get size() {
        return this.buffer[this.index - 1];
      }
      next() {
        this.index -= 4;
        this.pos -= 4;
        if (this.index == 0)
          this.maybeNext();
      }
      fork() {
        return new _StackBufferCursor(this.stack, this.pos, this.index);
      }
    };
    CachedToken = class {
      constructor() {
        this.start = -1;
        this.value = -1;
        this.end = -1;
        this.extended = -1;
        this.lookAhead = 0;
        this.mask = 0;
        this.context = 0;
      }
    };
    nullToken = new CachedToken();
    InputStream = class {
      /**
      @internal
      */
      constructor(input2, ranges) {
        this.input = input2;
        this.ranges = ranges;
        this.chunk = "";
        this.chunkOff = 0;
        this.chunk2 = "";
        this.chunk2Pos = 0;
        this.next = -1;
        this.token = nullToken;
        this.rangeIndex = 0;
        this.pos = this.chunkPos = ranges[0].from;
        this.range = ranges[0];
        this.end = ranges[ranges.length - 1].to;
        this.readNext();
      }
      /**
      @internal
      */
      resolveOffset(offset, assoc) {
        let range = this.range, index = this.rangeIndex;
        let pos = this.pos + offset;
        while (pos < range.from) {
          if (!index)
            return null;
          let next = this.ranges[--index];
          pos -= range.from - next.to;
          range = next;
        }
        while (assoc < 0 ? pos > range.to : pos >= range.to) {
          if (index == this.ranges.length - 1)
            return null;
          let next = this.ranges[++index];
          pos += next.from - range.to;
          range = next;
        }
        return pos;
      }
      /**
      @internal
      */
      clipPos(pos) {
        if (pos >= this.range.from && pos < this.range.to)
          return pos;
        for (let range of this.ranges)
          if (range.to > pos)
            return Math.max(pos, range.from);
        return this.end;
      }
      /**
      Look at a code unit near the stream position. `.peek(0)` equals
      `.next`, `.peek(-1)` gives you the previous character, and so
      on.
      
      Note that looking around during tokenizing creates dependencies
      on potentially far-away content, which may reduce the
      effectiveness incremental parsingwhen looking forwardor even
      cause invalid reparses when looking backward more than 25 code
      units, since the library does not track lookbehind.
      */
      peek(offset) {
        let idx = this.chunkOff + offset, pos, result;
        if (idx >= 0 && idx < this.chunk.length) {
          pos = this.pos + offset;
          result = this.chunk.charCodeAt(idx);
        } else {
          let resolved2 = this.resolveOffset(offset, 1);
          if (resolved2 == null)
            return -1;
          pos = resolved2;
          if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
            result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
          } else {
            let i = this.rangeIndex, range = this.range;
            while (range.to <= pos)
              range = this.ranges[++i];
            this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
            if (pos + this.chunk2.length > range.to)
              this.chunk2 = this.chunk2.slice(0, range.to - pos);
            result = this.chunk2.charCodeAt(0);
          }
        }
        if (pos >= this.token.lookAhead)
          this.token.lookAhead = pos + 1;
        return result;
      }
      /**
      Accept a token. By default, the end of the token is set to the
      current stream position, but you can pass an offset (relative to
      the stream position) to change that.
      */
      acceptToken(token, endOffset = 0) {
        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
        if (end == null || end < this.token.start)
          throw new RangeError("Token end out of bounds");
        this.token.value = token;
        this.token.end = end;
      }
      /**
      Accept a token ending at a specific given position.
      */
      acceptTokenTo(token, endPos) {
        this.token.value = token;
        this.token.end = endPos;
      }
      getChunk() {
        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
          let { chunk, chunkPos } = this;
          this.chunk = this.chunk2;
          this.chunkPos = this.chunk2Pos;
          this.chunk2 = chunk;
          this.chunk2Pos = chunkPos;
          this.chunkOff = this.pos - this.chunkPos;
        } else {
          this.chunk2 = this.chunk;
          this.chunk2Pos = this.chunkPos;
          let nextChunk = this.input.chunk(this.pos);
          let end = this.pos + nextChunk.length;
          this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
          this.chunkPos = this.pos;
          this.chunkOff = 0;
        }
      }
      readNext() {
        if (this.chunkOff >= this.chunk.length) {
          this.getChunk();
          if (this.chunkOff == this.chunk.length)
            return this.next = -1;
        }
        return this.next = this.chunk.charCodeAt(this.chunkOff);
      }
      /**
      Move the stream forward N (defaults to 1) code units. Returns
      the new value of [`next`](#lr.InputStream.next).
      */
      advance(n = 1) {
        this.chunkOff += n;
        while (this.pos + n >= this.range.to) {
          if (this.rangeIndex == this.ranges.length - 1)
            return this.setDone();
          n -= this.range.to - this.pos;
          this.range = this.ranges[++this.rangeIndex];
          this.pos = this.range.from;
        }
        this.pos += n;
        if (this.pos >= this.token.lookAhead)
          this.token.lookAhead = this.pos + 1;
        return this.readNext();
      }
      setDone() {
        this.pos = this.chunkPos = this.end;
        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
        this.chunk = "";
        return this.next = -1;
      }
      /**
      @internal
      */
      reset(pos, token) {
        if (token) {
          this.token = token;
          token.start = pos;
          token.lookAhead = pos + 1;
          token.value = token.extended = -1;
        } else {
          this.token = nullToken;
        }
        if (this.pos != pos) {
          this.pos = pos;
          if (pos == this.end) {
            this.setDone();
            return this;
          }
          while (pos < this.range.from)
            this.range = this.ranges[--this.rangeIndex];
          while (pos >= this.range.to)
            this.range = this.ranges[++this.rangeIndex];
          if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
            this.chunkOff = pos - this.chunkPos;
          } else {
            this.chunk = "";
            this.chunkOff = 0;
          }
          this.readNext();
        }
        return this;
      }
      /**
      @internal
      */
      read(from2, to) {
        if (from2 >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
          return this.chunk.slice(from2 - this.chunkPos, to - this.chunkPos);
        if (from2 >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
          return this.chunk2.slice(from2 - this.chunk2Pos, to - this.chunk2Pos);
        if (from2 >= this.range.from && to <= this.range.to)
          return this.input.read(from2, to);
        let result = "";
        for (let r of this.ranges) {
          if (r.from >= to)
            break;
          if (r.to > from2)
            result += this.input.read(Math.max(r.from, from2), Math.min(r.to, to));
        }
        return result;
      }
    };
    TokenGroup = class {
      constructor(data2, id2) {
        this.data = data2;
        this.id = id2;
      }
      token(input2, stack) {
        let { parser: parser7 } = stack.p;
        readToken(this.data, input2, stack, this.id, parser7.data, parser7.tokenPrecTable);
      }
    };
    TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
    LocalTokenGroup = class {
      constructor(data2, precTable, elseToken) {
        this.precTable = precTable;
        this.elseToken = elseToken;
        this.data = typeof data2 == "string" ? decodeArray(data2) : data2;
      }
      token(input2, stack) {
        let start = input2.pos, skipped = 0;
        for (; ; ) {
          let atEof = input2.next < 0, nextPos = input2.resolveOffset(1, 1);
          readToken(this.data, input2, stack, 0, this.data, this.precTable);
          if (input2.token.value > -1)
            break;
          if (this.elseToken == null)
            return;
          if (!atEof)
            skipped++;
          if (nextPos == null)
            break;
          input2.reset(nextPos, input2.token);
        }
        if (skipped) {
          input2.reset(start, input2.token);
          input2.acceptToken(this.elseToken, skipped);
        }
      }
    };
    LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
    ExternalTokenizer = class {
      /**
      Create a tokenizer. The first argument is the function that,
      given an input stream, scans for the types of tokens it
      recognizes at the stream's position, and calls
      [`acceptToken`](#lr.InputStream.acceptToken) when it finds
      one.
      */
      constructor(token, options = {}) {
        this.token = token;
        this.contextual = !!options.contextual;
        this.fallback = !!options.fallback;
        this.extend = !!options.extend;
      }
    };
    verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
    stackIDs = null;
    FragmentCursor2 = class {
      constructor(fragments, nodeSet) {
        this.fragments = fragments;
        this.nodeSet = nodeSet;
        this.i = 0;
        this.fragment = null;
        this.safeFrom = -1;
        this.safeTo = -1;
        this.trees = [];
        this.start = [];
        this.index = [];
        this.nextFragment();
      }
      nextFragment() {
        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
        if (fr) {
          this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
          this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
          while (this.trees.length) {
            this.trees.pop();
            this.start.pop();
            this.index.pop();
          }
          this.trees.push(fr.tree);
          this.start.push(-fr.offset);
          this.index.push(0);
          this.nextStart = this.safeFrom;
        } else {
          this.nextStart = 1e9;
        }
      }
      // `pos` must be >= any previously given `pos` for this cursor
      nodeAt(pos) {
        if (pos < this.nextStart)
          return null;
        while (this.fragment && this.safeTo <= pos)
          this.nextFragment();
        if (!this.fragment)
          return null;
        for (; ; ) {
          let last4 = this.trees.length - 1;
          if (last4 < 0) {
            this.nextFragment();
            return null;
          }
          let top2 = this.trees[last4], index = this.index[last4];
          if (index == top2.children.length) {
            this.trees.pop();
            this.start.pop();
            this.index.pop();
            continue;
          }
          let next = top2.children[index];
          let start = this.start[last4] + top2.positions[index];
          if (start > pos) {
            this.nextStart = start;
            return null;
          }
          if (next instanceof Tree2) {
            if (start == pos) {
              if (start < this.safeFrom)
                return null;
              let end = start + next.length;
              if (end <= this.safeTo) {
                let lookAhead = next.prop(NodeProp.lookAhead);
                if (!lookAhead || end + lookAhead < this.fragment.to)
                  return next;
              }
            }
            this.index[last4]++;
            if (start + next.length >= Math.max(this.safeFrom, pos)) {
              this.trees.push(next);
              this.start.push(start);
              this.index.push(0);
            }
          } else {
            this.index[last4]++;
            this.nextStart = start + next.length;
          }
        }
      }
    };
    TokenCache = class {
      constructor(parser7, stream) {
        this.stream = stream;
        this.tokens = [];
        this.mainToken = null;
        this.actions = [];
        this.tokens = parser7.tokenizers.map((_) => new CachedToken());
      }
      getActions(stack) {
        let actionIndex = 0;
        let main = null;
        let { parser: parser7 } = stack.p, { tokenizers } = parser7;
        let mask = parser7.stateSlot(
          stack.state,
          3
          /* ParseState.TokenizerMask */
        );
        let context2 = stack.curContext ? stack.curContext.hash : 0;
        let lookAhead = 0;
        for (let i = 0; i < tokenizers.length; i++) {
          if ((1 << i & mask) == 0)
            continue;
          let tokenizer = tokenizers[i], token = this.tokens[i];
          if (main && !tokenizer.fallback)
            continue;
          if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context2) {
            this.updateCachedToken(token, tokenizer, stack);
            token.mask = mask;
            token.context = context2;
          }
          if (token.lookAhead > token.end + 25)
            lookAhead = Math.max(token.lookAhead, lookAhead);
          if (token.value != 0) {
            let startIndex = actionIndex;
            if (token.extended > -1)
              actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
            actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
            if (!tokenizer.extend) {
              main = token;
              if (actionIndex > startIndex)
                break;
            }
          }
        }
        while (this.actions.length > actionIndex)
          this.actions.pop();
        if (lookAhead)
          stack.setLookAhead(lookAhead);
        if (!main && stack.pos == this.stream.end) {
          main = new CachedToken();
          main.value = stack.p.parser.eofTerm;
          main.start = main.end = stack.pos;
          actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
        }
        this.mainToken = main;
        return this.actions;
      }
      getMainToken(stack) {
        if (this.mainToken)
          return this.mainToken;
        let main = new CachedToken(), { pos, p } = stack;
        main.start = pos;
        main.end = Math.min(pos + 1, p.stream.end);
        main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
        return main;
      }
      updateCachedToken(token, tokenizer, stack) {
        let start = this.stream.clipPos(stack.pos);
        tokenizer.token(this.stream.reset(start, token), stack);
        if (token.value > -1) {
          let { parser: parser7 } = stack.p;
          for (let i = 0; i < parser7.specialized.length; i++)
            if (parser7.specialized[i] == token.value) {
              let result = parser7.specializers[i](this.stream.read(token.start, token.end), stack);
              if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
                if ((result & 1) == 0)
                  token.value = result >> 1;
                else
                  token.extended = result >> 1;
                break;
              }
            }
        } else {
          token.value = 0;
          token.end = this.stream.clipPos(start + 1);
        }
      }
      putAction(action, token, end, index) {
        for (let i = 0; i < index; i += 3)
          if (this.actions[i] == action)
            return index;
        this.actions[index++] = action;
        this.actions[index++] = token;
        this.actions[index++] = end;
        return index;
      }
      addActions(stack, token, end, index) {
        let { state } = stack, { parser: parser7 } = stack.p, { data: data2 } = parser7;
        for (let set = 0; set < 2; set++) {
          for (let i = parser7.stateSlot(
            state,
            set ? 2 : 1
            /* ParseState.Actions */
          ); ; i += 3) {
            if (data2[i] == 65535) {
              if (data2[i + 1] == 1) {
                i = pair(data2, i + 2);
              } else {
                if (index == 0 && data2[i + 1] == 2)
                  index = this.putAction(pair(data2, i + 2), token, end, index);
                break;
              }
            }
            if (data2[i] == token)
              index = this.putAction(pair(data2, i + 1), token, end, index);
          }
        }
        return index;
      }
    };
    Parse = class {
      constructor(parser7, input2, fragments, ranges) {
        this.parser = parser7;
        this.input = input2;
        this.ranges = ranges;
        this.recovering = 0;
        this.nextStackID = 9812;
        this.minStackPos = 0;
        this.reused = [];
        this.stoppedAt = null;
        this.lastBigReductionStart = -1;
        this.lastBigReductionSize = 0;
        this.bigReductionCount = 0;
        this.stream = new InputStream(input2, ranges);
        this.tokens = new TokenCache(parser7, this.stream);
        this.topTerm = parser7.top[1];
        let { from: from2 } = ranges[0];
        this.stacks = [Stack.start(this, parser7.top[0], from2)];
        this.fragments = fragments.length && this.stream.end - from2 > parser7.bufferLength * 4 ? new FragmentCursor2(fragments, parser7.nodeSet) : null;
      }
      get parsedPos() {
        return this.minStackPos;
      }
      // Move the parser forward. This will process all parse stacks at
      // `this.pos` and try to advance them to a further position. If no
      // stack for such a position is found, it'll start error-recovery.
      //
      // When the parse is finished, this will return a syntax tree. When
      // not, it returns `null`.
      advance() {
        let stacks = this.stacks, pos = this.minStackPos;
        let newStacks = this.stacks = [];
        let stopped, stoppedTokens;
        if (this.bigReductionCount > 300 && stacks.length == 1) {
          let [s] = stacks;
          while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) {
          }
          this.bigReductionCount = this.lastBigReductionSize = 0;
        }
        for (let i = 0; i < stacks.length; i++) {
          let stack = stacks[i];
          for (; ; ) {
            this.tokens.mainToken = null;
            if (stack.pos > pos) {
              newStacks.push(stack);
            } else if (this.advanceStack(stack, newStacks, stacks)) {
              continue;
            } else {
              if (!stopped) {
                stopped = [];
                stoppedTokens = [];
              }
              stopped.push(stack);
              let tok = this.tokens.getMainToken(stack);
              stoppedTokens.push(tok.value, tok.end);
            }
            break;
          }
        }
        if (!newStacks.length) {
          let finished = stopped && findFinished(stopped);
          if (finished) {
            if (verbose)
              console.log("Finish with " + this.stackID(finished));
            return this.stackToTree(finished);
          }
          if (this.parser.strict) {
            if (verbose && stopped)
              console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
            throw new SyntaxError("No parse at " + pos);
          }
          if (!this.recovering)
            this.recovering = 5;
        }
        if (this.recovering && stopped) {
          let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
          if (finished) {
            if (verbose)
              console.log("Force-finish " + this.stackID(finished));
            return this.stackToTree(finished.forceAll());
          }
        }
        if (this.recovering) {
          let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
          if (newStacks.length > maxRemaining) {
            newStacks.sort((a, b) => b.score - a.score);
            while (newStacks.length > maxRemaining)
              newStacks.pop();
          }
          if (newStacks.some((s) => s.reducePos > pos))
            this.recovering--;
        } else if (newStacks.length > 1) {
          outer: for (let i = 0; i < newStacks.length - 1; i++) {
            let stack = newStacks[i];
            for (let j = i + 1; j < newStacks.length; j++) {
              let other = newStacks[j];
              if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
                if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                  newStacks.splice(j--, 1);
                } else {
                  newStacks.splice(i--, 1);
                  continue outer;
                }
              }
            }
          }
          if (newStacks.length > 12)
            newStacks.splice(
              12,
              newStacks.length - 12
              /* Rec.MaxStackCount */
            );
        }
        this.minStackPos = newStacks[0].pos;
        for (let i = 1; i < newStacks.length; i++)
          if (newStacks[i].pos < this.minStackPos)
            this.minStackPos = newStacks[i].pos;
        return null;
      }
      stopAt(pos) {
        if (this.stoppedAt != null && this.stoppedAt < pos)
          throw new RangeError("Can't move stoppedAt forward");
        this.stoppedAt = pos;
      }
      // Returns an updated version of the given stack, or null if the
      // stack can't advance normally. When `split` and `stacks` are
      // given, stacks split off by ambiguous operations will be pushed to
      // `split`, or added to `stacks` if they move `pos` forward.
      advanceStack(stack, stacks, split2) {
        let start = stack.pos, { parser: parser7 } = this;
        let base2 = verbose ? this.stackID(stack) + " -> " : "";
        if (this.stoppedAt != null && start > this.stoppedAt)
          return stack.forceReduce() ? stack : null;
        if (this.fragments) {
          let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
          for (let cached = this.fragments.nodeAt(start); cached; ) {
            let match2 = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser7.getGoto(stack.state, cached.type.id) : -1;
            if (match2 > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
              stack.useNode(cached, match2);
              if (verbose)
                console.log(base2 + this.stackID(stack) + ` (via reuse of ${parser7.getName(cached.type.id)})`);
              return true;
            }
            if (!(cached instanceof Tree2) || cached.children.length == 0 || cached.positions[0] > 0)
              break;
            let inner = cached.children[0];
            if (inner instanceof Tree2 && cached.positions[0] == 0)
              cached = inner;
            else
              break;
          }
        }
        let defaultReduce = parser7.stateSlot(
          stack.state,
          4
          /* ParseState.DefaultReduce */
        );
        if (defaultReduce > 0) {
          stack.reduce(defaultReduce);
          if (verbose)
            console.log(base2 + this.stackID(stack) + ` (via always-reduce ${parser7.getName(
              defaultReduce & 65535
              /* Action.ValueMask */
            )})`);
          return true;
        }
        if (stack.stack.length >= 8400) {
          while (stack.stack.length > 6e3 && stack.forceReduce()) {
          }
        }
        let actions = this.tokens.getActions(stack);
        for (let i = 0; i < actions.length; ) {
          let action = actions[i++], term = actions[i++], end = actions[i++];
          let last4 = i == actions.length || !split2;
          let localStack = last4 ? stack : stack.split();
          let main = this.tokens.mainToken;
          localStack.apply(action, term, main ? main.start : localStack.pos, end);
          if (verbose)
            console.log(base2 + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser7.getName(
              action & 65535
              /* Action.ValueMask */
            )}`} for ${parser7.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
          if (last4)
            return true;
          else if (localStack.pos > start)
            stacks.push(localStack);
          else
            split2.push(localStack);
        }
        return false;
      }
      // Advance a given stack forward as far as it will go. Returns the
      // (possibly updated) stack if it got stuck, or null if it moved
      // forward and was given to `pushStackDedup`.
      advanceFully(stack, newStacks) {
        let pos = stack.pos;
        for (; ; ) {
          if (!this.advanceStack(stack, null, null))
            return false;
          if (stack.pos > pos) {
            pushStackDedup(stack, newStacks);
            return true;
          }
        }
      }
      runRecovery(stacks, tokens, newStacks) {
        let finished = null, restarted = false;
        for (let i = 0; i < stacks.length; i++) {
          let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
          let base2 = verbose ? this.stackID(stack) + " -> " : "";
          if (stack.deadEnd) {
            if (restarted)
              continue;
            restarted = true;
            stack.restart();
            if (verbose)
              console.log(base2 + this.stackID(stack) + " (restarted)");
            let done = this.advanceFully(stack, newStacks);
            if (done)
              continue;
          }
          let force = stack.split(), forceBase = base2;
          for (let j = 0; force.forceReduce() && j < 10; j++) {
            if (verbose)
              console.log(forceBase + this.stackID(force) + " (via force-reduce)");
            let done = this.advanceFully(force, newStacks);
            if (done)
              break;
            if (verbose)
              forceBase = this.stackID(force) + " -> ";
          }
          for (let insert2 of stack.recoverByInsert(token)) {
            if (verbose)
              console.log(base2 + this.stackID(insert2) + " (via recover-insert)");
            this.advanceFully(insert2, newStacks);
          }
          if (this.stream.end > stack.pos) {
            if (tokenEnd == stack.pos) {
              tokenEnd++;
              token = 0;
            }
            stack.recoverByDelete(token, tokenEnd);
            if (verbose)
              console.log(base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
            pushStackDedup(stack, newStacks);
          } else if (!finished || finished.score < stack.score) {
            finished = stack;
          }
        }
        return finished;
      }
      // Convert the stack's buffer to a syntax tree.
      stackToTree(stack) {
        stack.close();
        return Tree2.build({
          buffer: StackBufferCursor.create(stack),
          nodeSet: this.parser.nodeSet,
          topID: this.topTerm,
          maxBufferLength: this.parser.bufferLength,
          reused: this.reused,
          start: this.ranges[0].from,
          length: stack.pos - this.ranges[0].from,
          minRepeatType: this.parser.minRepeatTerm
        });
      }
      stackID(stack) {
        let id2 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
        if (!id2)
          stackIDs.set(stack, id2 = String.fromCodePoint(this.nextStackID++));
        return id2 + stack;
      }
    };
    Dialect = class {
      constructor(source, flags, disabled) {
        this.source = source;
        this.flags = flags;
        this.disabled = disabled;
      }
      allows(term) {
        return !this.disabled || this.disabled[term] == 0;
      }
    };
    id = (x) => x;
    ContextTracker = class {
      /**
      Define a context tracker.
      */
      constructor(spec) {
        this.start = spec.start;
        this.shift = spec.shift || id;
        this.reduce = spec.reduce || id;
        this.reuse = spec.reuse || id;
        this.hash = spec.hash || (() => 0);
        this.strict = spec.strict !== false;
      }
    };
    LRParser = class _LRParser extends Parser {
      /**
      @internal
      */
      constructor(spec) {
        super();
        this.wrappers = [];
        if (spec.version != 14)
          throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
        let nodeNames = spec.nodeNames.split(" ");
        this.minRepeatTerm = nodeNames.length;
        for (let i = 0; i < spec.repeatNodeCount; i++)
          nodeNames.push("");
        let topTerms = Object.keys(spec.topRules).map((r) => spec.topRules[r][1]);
        let nodeProps = [];
        for (let i = 0; i < nodeNames.length; i++)
          nodeProps.push([]);
        function setProp(nodeID, prop, value) {
          nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
        }
        if (spec.nodeProps)
          for (let propSpec of spec.nodeProps) {
            let prop = propSpec[0];
            if (typeof prop == "string")
              prop = NodeProp[prop];
            for (let i = 1; i < propSpec.length; ) {
              let next = propSpec[i++];
              if (next >= 0) {
                setProp(next, prop, propSpec[i++]);
              } else {
                let value = propSpec[i + -next];
                for (let j = -next; j > 0; j--)
                  setProp(propSpec[i++], prop, value);
                i++;
              }
            }
          }
        this.nodeSet = new NodeSet(nodeNames.map((name2, i) => NodeType.define({
          name: i >= this.minRepeatTerm ? void 0 : name2,
          id: i,
          props: nodeProps[i],
          top: topTerms.indexOf(i) > -1,
          error: i == 0,
          skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
        })));
        if (spec.propSources)
          this.nodeSet = this.nodeSet.extend(...spec.propSources);
        this.strict = false;
        this.bufferLength = DefaultBufferLength;
        let tokenArray = decodeArray(spec.tokenData);
        this.context = spec.context;
        this.specializerSpecs = spec.specialized || [];
        this.specialized = new Uint16Array(this.specializerSpecs.length);
        for (let i = 0; i < this.specializerSpecs.length; i++)
          this.specialized[i] = this.specializerSpecs[i].term;
        this.specializers = this.specializerSpecs.map(getSpecializer);
        this.states = decodeArray(spec.states, Uint32Array);
        this.data = decodeArray(spec.stateData);
        this.goto = decodeArray(spec.goto);
        this.maxTerm = spec.maxTerm;
        this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
        this.topRules = spec.topRules;
        this.dialects = spec.dialects || {};
        this.dynamicPrecedences = spec.dynamicPrecedences || null;
        this.tokenPrecTable = spec.tokenPrec;
        this.termNames = spec.termNames || null;
        this.maxNode = this.nodeSet.types.length - 1;
        this.dialect = this.parseDialect();
        this.top = this.topRules[Object.keys(this.topRules)[0]];
      }
      createParse(input2, fragments, ranges) {
        let parse = new Parse(this, input2, fragments, ranges);
        for (let w of this.wrappers)
          parse = w(parse, input2, fragments, ranges);
        return parse;
      }
      /**
      Get a goto table entry @internal
      */
      getGoto(state, term, loose = false) {
        let table = this.goto;
        if (term >= table[0])
          return -1;
        for (let pos = table[term + 1]; ; ) {
          let groupTag = table[pos++], last4 = groupTag & 1;
          let target = table[pos++];
          if (last4 && loose)
            return target;
          for (let end = pos + (groupTag >> 1); pos < end; pos++)
            if (table[pos] == state)
              return target;
          if (last4)
            return -1;
        }
      }
      /**
      Check if this state has an action for a given terminal @internal
      */
      hasAction(state, terminal) {
        let data2 = this.data;
        for (let set = 0; set < 2; set++) {
          for (let i = this.stateSlot(
            state,
            set ? 2 : 1
            /* ParseState.Actions */
          ), next; ; i += 3) {
            if ((next = data2[i]) == 65535) {
              if (data2[i + 1] == 1)
                next = data2[i = pair(data2, i + 2)];
              else if (data2[i + 1] == 2)
                return pair(data2, i + 2);
              else
                break;
            }
            if (next == terminal || next == 0)
              return pair(data2, i + 1);
          }
        }
        return 0;
      }
      /**
      @internal
      */
      stateSlot(state, slot) {
        return this.states[state * 6 + slot];
      }
      /**
      @internal
      */
      stateFlag(state, flag) {
        return (this.stateSlot(
          state,
          0
          /* ParseState.Flags */
        ) & flag) > 0;
      }
      /**
      @internal
      */
      validAction(state, action) {
        return !!this.allActions(state, (a) => a == action ? true : null);
      }
      /**
      @internal
      */
      allActions(state, action) {
        let deflt = this.stateSlot(
          state,
          4
          /* ParseState.DefaultReduce */
        );
        let result = deflt ? action(deflt) : void 0;
        for (let i = this.stateSlot(
          state,
          1
          /* ParseState.Actions */
        ); result == null; i += 3) {
          if (this.data[i] == 65535) {
            if (this.data[i + 1] == 1)
              i = pair(this.data, i + 2);
            else
              break;
          }
          result = action(pair(this.data, i + 1));
        }
        return result;
      }
      /**
      Get the states that can follow this one through shift actions or
      goto jumps. @internal
      */
      nextStates(state) {
        let result = [];
        for (let i = this.stateSlot(
          state,
          1
          /* ParseState.Actions */
        ); ; i += 3) {
          if (this.data[i] == 65535) {
            if (this.data[i + 1] == 1)
              i = pair(this.data, i + 2);
            else
              break;
          }
          if ((this.data[i + 2] & 65536 >> 16) == 0) {
            let value = this.data[i + 1];
            if (!result.some((v, i2) => i2 & 1 && v == value))
              result.push(this.data[i], value);
          }
        }
        return result;
      }
      /**
      Configure the parser. Returns a new parser instance that has the
      given settings modified. Settings not provided in `config` are
      kept from the original parser.
      */
      configure(config3) {
        let copy = Object.assign(Object.create(_LRParser.prototype), this);
        if (config3.props)
          copy.nodeSet = this.nodeSet.extend(...config3.props);
        if (config3.top) {
          let info = this.topRules[config3.top];
          if (!info)
            throw new RangeError(`Invalid top rule name ${config3.top}`);
          copy.top = info;
        }
        if (config3.tokenizers)
          copy.tokenizers = this.tokenizers.map((t2) => {
            let found = config3.tokenizers.find((r) => r.from == t2);
            return found ? found.to : t2;
          });
        if (config3.specializers) {
          copy.specializers = this.specializers.slice();
          copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
            let found = config3.specializers.find((r) => r.from == s.external);
            if (!found)
              return s;
            let spec = Object.assign(Object.assign({}, s), { external: found.to });
            copy.specializers[i] = getSpecializer(spec);
            return spec;
          });
        }
        if (config3.contextTracker)
          copy.context = config3.contextTracker;
        if (config3.dialect)
          copy.dialect = this.parseDialect(config3.dialect);
        if (config3.strict != null)
          copy.strict = config3.strict;
        if (config3.wrap)
          copy.wrappers = copy.wrappers.concat(config3.wrap);
        if (config3.bufferLength != null)
          copy.bufferLength = config3.bufferLength;
        return copy;
      }
      /**
      Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
      are registered for this parser.
      */
      hasWrappers() {
        return this.wrappers.length > 0;
      }
      /**
      Returns the name associated with a given term. This will only
      work for all terms when the parser was generated with the
      `--names` option. By default, only the names of tagged terms are
      stored.
      */
      getName(term) {
        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
      }
      /**
      The eof term id is always allocated directly after the node
      types. @internal
      */
      get eofTerm() {
        return this.maxNode + 1;
      }
      /**
      The type of top node produced by the parser.
      */
      get topNode() {
        return this.nodeSet.types[this.top[1]];
      }
      /**
      @internal
      */
      dynamicPrecedence(term) {
        let prec2 = this.dynamicPrecedences;
        return prec2 == null ? 0 : prec2[term] || 0;
      }
      /**
      @internal
      */
      parseDialect(dialect) {
        let values2 = Object.keys(this.dialects), flags = values2.map(() => false);
        if (dialect)
          for (let part of dialect.split(" ")) {
            let id2 = values2.indexOf(part);
            if (id2 >= 0)
              flags[id2] = true;
          }
        let disabled = null;
        for (let i = 0; i < values2.length; i++)
          if (!flags[i]) {
            for (let j = this.dialects[values2[i]], id2; (id2 = this.data[j++]) != 65535; )
              (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
          }
        return new Dialect(dialect, flags, disabled);
      }
      /**
      Used by the output of the parser generator. Not available to
      user code. @hide
      */
      static deserialize(spec) {
        return new _LRParser(spec);
      }
    };
  }
});

// node_modules/@lezer/highlight/dist/index.js
function sameArray2(a, b) {
  return a.length == b.length && a.every((x, i) => x == b[i]);
}
function powerSet(array) {
  let sets = [[]];
  for (let i = 0; i < array.length; i++) {
    for (let j = 0, e = sets.length; j < e; j++) {
      sets.push(sets[j].concat(array[i]));
    }
  }
  return sets.sort((a, b) => b.length - a.length);
}
function styleTags(spec) {
  let byName = /* @__PURE__ */ Object.create(null);
  for (let prop in spec) {
    let tags3 = spec[prop];
    if (!Array.isArray(tags3))
      tags3 = [tags3];
    for (let part of prop.split(" "))
      if (part) {
        let pieces = [], mode = 2, rest = part;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m)
            throw new RangeError("Invalid path: " + part);
          pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
          pos += m[0].length;
          if (pos == part.length)
            break;
          let next = part[pos++];
          if (pos == part.length && next == "!") {
            mode = 0;
            break;
          }
          if (next != "/")
            throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last4 = pieces.length - 1, inner = pieces[last4];
        if (!inner)
          throw new RangeError("Invalid path: " + part);
        let rule = new Rule(tags3, mode, last4 > 0 ? pieces.slice(0, last4) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
  }
  return ruleNodeProp.add(byName);
}
function tagHighlighter(tags3, options) {
  let map2 = /* @__PURE__ */ Object.create(null);
  for (let style of tags3) {
    if (!Array.isArray(style.tag))
      map2[style.tag.id] = style.class;
    else
      for (let tag of style.tag)
        map2[tag.id] = style.class;
  }
  let { scope, all = null } = options || {};
  return {
    style: (tags4) => {
      let cls = all;
      for (let tag of tags4) {
        for (let sub of tag.set) {
          let tagClass = map2[sub.id];
          if (tagClass) {
            cls = cls ? cls + " " + tagClass : tagClass;
            break;
          }
        }
      }
      return cls;
    },
    scope
  };
}
function highlightTags(highlighters, tags3) {
  let result = null;
  for (let highlighter of highlighters) {
    let value = highlighter.style(tags3);
    if (value)
      result = result ? result + " " + value : value;
  }
  return result;
}
function highlightTree(tree2, highlighter, putStyle, from2 = 0, to = tree2.length) {
  let builder = new HighlightBuilder(from2, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
  builder.highlightRange(tree2.cursor(), from2, to, "", builder.highlighters);
  builder.flush(to);
}
function getStyleTags(node) {
  let rule = node.type.prop(ruleNodeProp);
  while (rule && rule.context && !node.matchContext(rule.context))
    rule = rule.next;
  return rule || null;
}
var nextTagID, Tag, nextModifierID, Modifier, ruleNodeProp, Rule, HighlightBuilder, t, comment, name, typeName, propertyName, literal, string, number, content, heading, keyword, operator, punctuation, bracket, meta, tags, classHighlighter;
var init_dist5 = __esm({
  "node_modules/@lezer/highlight/dist/index.js"() {
    "use strict";
    init_dist3();
    nextTagID = 0;
    Tag = class _Tag {
      /**
      @internal
      */
      constructor(name2, set, base2, modified) {
        this.name = name2;
        this.set = set;
        this.base = base2;
        this.modified = modified;
        this.id = nextTagID++;
      }
      toString() {
        let { name: name2 } = this;
        for (let mod of this.modified)
          if (mod.name)
            name2 = `${mod.name}(${name2})`;
        return name2;
      }
      static define(nameOrParent, parent) {
        let name2 = typeof nameOrParent == "string" ? nameOrParent : "?";
        if (nameOrParent instanceof _Tag)
          parent = nameOrParent;
        if (parent === null || parent === void 0 ? void 0 : parent.base)
          throw new Error("Can not derive from a modified tag");
        let tag = new _Tag(name2, [], null, []);
        tag.set.push(tag);
        if (parent)
          for (let t2 of parent.set)
            tag.set.push(t2);
        return tag;
      }
      /**
      Define a tag _modifier_, which is a function that, given a tag,
      will return a tag that is a subtag of the original. Applying the
      same modifier to a twice tag will return the same value (`m1(t1)
      == m1(t1)`) and applying multiple modifiers will, regardless or
      order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
      
      When multiple modifiers are applied to a given base tag, each
      smaller set of modifiers is registered as a parent, so that for
      example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
      `m1(m3(t1)`, and so on.
      */
      static defineModifier(name2) {
        let mod = new Modifier(name2);
        return (tag) => {
          if (tag.modified.indexOf(mod) > -1)
            return tag;
          return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
        };
      }
    };
    nextModifierID = 0;
    Modifier = class _Modifier {
      constructor(name2) {
        this.name = name2;
        this.instances = [];
        this.id = nextModifierID++;
      }
      static get(base2, mods) {
        if (!mods.length)
          return base2;
        let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray2(mods, t2.modified));
        if (exists)
          return exists;
        let set = [], tag = new Tag(base2.name, set, base2, mods);
        for (let m of mods)
          m.instances.push(tag);
        let configs = powerSet(mods);
        for (let parent of base2.set)
          if (!parent.modified.length)
            for (let config3 of configs)
              set.push(_Modifier.get(parent, config3));
        return tag;
      }
    };
    ruleNodeProp = new NodeProp({
      combine(a, b) {
        let cur2, root, take2;
        while (a || b) {
          if (!a || b && a.depth >= b.depth) {
            take2 = b;
            b = b.next;
          } else {
            take2 = a;
            a = a.next;
          }
          if (cur2 && cur2.mode == take2.mode && !take2.context && !cur2.context)
            continue;
          let copy = new Rule(take2.tags, take2.mode, take2.context);
          if (cur2)
            cur2.next = copy;
          else
            root = copy;
          cur2 = copy;
        }
        return root;
      }
    });
    Rule = class {
      constructor(tags3, mode, context2, next) {
        this.tags = tags3;
        this.mode = mode;
        this.context = context2;
        this.next = next;
      }
      get opaque() {
        return this.mode == 0;
      }
      get inherit() {
        return this.mode == 1;
      }
      sort(other) {
        if (!other || other.depth < this.depth) {
          this.next = other;
          return this;
        }
        other.next = this.sort(other.next);
        return other;
      }
      get depth() {
        return this.context ? this.context.length : 0;
      }
    };
    Rule.empty = new Rule([], 2, null);
    HighlightBuilder = class {
      constructor(at, highlighters, span) {
        this.at = at;
        this.highlighters = highlighters;
        this.span = span;
        this.class = "";
      }
      startSpan(at, cls) {
        if (cls != this.class) {
          this.flush(at);
          if (at > this.at)
            this.at = at;
          this.class = cls;
        }
      }
      flush(to) {
        if (to > this.at && this.class)
          this.span(this.at, to, this.class);
      }
      highlightRange(cursor2, from2, to, inheritedClass, highlighters) {
        let { type, from: start, to: end } = cursor2;
        if (start >= to || end <= from2)
          return;
        if (type.isTop)
          highlighters = this.highlighters.filter((h) => !h.scope || h.scope(type));
        let cls = inheritedClass;
        let rule = getStyleTags(cursor2) || Rule.empty;
        let tagCls = highlightTags(highlighters, rule.tags);
        if (tagCls) {
          if (cls)
            cls += " ";
          cls += tagCls;
          if (rule.mode == 1)
            inheritedClass += (inheritedClass ? " " : "") + tagCls;
        }
        this.startSpan(Math.max(from2, start), cls);
        if (rule.opaque)
          return;
        let mounted = cursor2.tree && cursor2.tree.prop(NodeProp.mounted);
        if (mounted && mounted.overlay) {
          let inner = cursor2.node.enter(mounted.overlay[0].from + start, 1);
          let innerHighlighters = this.highlighters.filter((h) => !h.scope || h.scope(mounted.tree.type));
          let hasChild2 = cursor2.firstChild();
          for (let i = 0, pos = start; ; i++) {
            let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
            let nextPos = next ? next.from + start : end;
            let rangeFrom2 = Math.max(from2, pos), rangeTo2 = Math.min(to, nextPos);
            if (rangeFrom2 < rangeTo2 && hasChild2) {
              while (cursor2.from < rangeTo2) {
                this.highlightRange(cursor2, rangeFrom2, rangeTo2, inheritedClass, highlighters);
                this.startSpan(Math.min(rangeTo2, cursor2.to), cls);
                if (cursor2.to >= nextPos || !cursor2.nextSibling())
                  break;
              }
            }
            if (!next || nextPos > to)
              break;
            pos = next.to + start;
            if (pos > from2) {
              this.highlightRange(inner.cursor(), Math.max(from2, next.from + start), Math.min(to, pos), "", innerHighlighters);
              this.startSpan(Math.min(to, pos), cls);
            }
          }
          if (hasChild2)
            cursor2.parent();
        } else if (cursor2.firstChild()) {
          if (mounted)
            inheritedClass = "";
          do {
            if (cursor2.to <= from2)
              continue;
            if (cursor2.from >= to)
              break;
            this.highlightRange(cursor2, from2, to, inheritedClass, highlighters);
            this.startSpan(Math.min(to, cursor2.to), cls);
          } while (cursor2.nextSibling());
          cursor2.parent();
        }
      }
    };
    t = Tag.define;
    comment = t();
    name = t();
    typeName = t(name);
    propertyName = t(name);
    literal = t();
    string = t(literal);
    number = t(literal);
    content = t();
    heading = t(content);
    keyword = t();
    operator = t();
    punctuation = t();
    bracket = t(punctuation);
    meta = t();
    tags = {
      /**
      A comment.
      */
      comment,
      /**
      A line [comment](#highlight.tags.comment).
      */
      lineComment: t(comment),
      /**
      A block [comment](#highlight.tags.comment).
      */
      blockComment: t(comment),
      /**
      A documentation [comment](#highlight.tags.comment).
      */
      docComment: t(comment),
      /**
      Any kind of identifier.
      */
      name,
      /**
      The [name](#highlight.tags.name) of a variable.
      */
      variableName: t(name),
      /**
      A type [name](#highlight.tags.name).
      */
      typeName,
      /**
      A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
      */
      tagName: t(typeName),
      /**
      A property or field [name](#highlight.tags.name).
      */
      propertyName,
      /**
      An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
      */
      attributeName: t(propertyName),
      /**
      The [name](#highlight.tags.name) of a class.
      */
      className: t(name),
      /**
      A label [name](#highlight.tags.name).
      */
      labelName: t(name),
      /**
      A namespace [name](#highlight.tags.name).
      */
      namespace: t(name),
      /**
      The [name](#highlight.tags.name) of a macro.
      */
      macroName: t(name),
      /**
      A literal value.
      */
      literal,
      /**
      A string [literal](#highlight.tags.literal).
      */
      string,
      /**
      A documentation [string](#highlight.tags.string).
      */
      docString: t(string),
      /**
      A character literal (subtag of [string](#highlight.tags.string)).
      */
      character: t(string),
      /**
      An attribute value (subtag of [string](#highlight.tags.string)).
      */
      attributeValue: t(string),
      /**
      A number [literal](#highlight.tags.literal).
      */
      number,
      /**
      An integer [number](#highlight.tags.number) literal.
      */
      integer: t(number),
      /**
      A floating-point [number](#highlight.tags.number) literal.
      */
      float: t(number),
      /**
      A boolean [literal](#highlight.tags.literal).
      */
      bool: t(literal),
      /**
      Regular expression [literal](#highlight.tags.literal).
      */
      regexp: t(literal),
      /**
      An escape [literal](#highlight.tags.literal), for example a
      backslash escape in a string.
      */
      escape: t(literal),
      /**
      A color [literal](#highlight.tags.literal).
      */
      color: t(literal),
      /**
      A URL [literal](#highlight.tags.literal).
      */
      url: t(literal),
      /**
      A language keyword.
      */
      keyword,
      /**
      The [keyword](#highlight.tags.keyword) for the self or this
      object.
      */
      self: t(keyword),
      /**
      The [keyword](#highlight.tags.keyword) for null.
      */
      null: t(keyword),
      /**
      A [keyword](#highlight.tags.keyword) denoting some atomic value.
      */
      atom: t(keyword),
      /**
      A [keyword](#highlight.tags.keyword) that represents a unit.
      */
      unit: t(keyword),
      /**
      A modifier [keyword](#highlight.tags.keyword).
      */
      modifier: t(keyword),
      /**
      A [keyword](#highlight.tags.keyword) that acts as an operator.
      */
      operatorKeyword: t(keyword),
      /**
      A control-flow related [keyword](#highlight.tags.keyword).
      */
      controlKeyword: t(keyword),
      /**
      A [keyword](#highlight.tags.keyword) that defines something.
      */
      definitionKeyword: t(keyword),
      /**
      A [keyword](#highlight.tags.keyword) related to defining or
      interfacing with modules.
      */
      moduleKeyword: t(keyword),
      /**
      An operator.
      */
      operator,
      /**
      An [operator](#highlight.tags.operator) that dereferences something.
      */
      derefOperator: t(operator),
      /**
      Arithmetic-related [operator](#highlight.tags.operator).
      */
      arithmeticOperator: t(operator),
      /**
      Logical [operator](#highlight.tags.operator).
      */
      logicOperator: t(operator),
      /**
      Bit [operator](#highlight.tags.operator).
      */
      bitwiseOperator: t(operator),
      /**
      Comparison [operator](#highlight.tags.operator).
      */
      compareOperator: t(operator),
      /**
      [Operator](#highlight.tags.operator) that updates its operand.
      */
      updateOperator: t(operator),
      /**
      [Operator](#highlight.tags.operator) that defines something.
      */
      definitionOperator: t(operator),
      /**
      Type-related [operator](#highlight.tags.operator).
      */
      typeOperator: t(operator),
      /**
      Control-flow [operator](#highlight.tags.operator).
      */
      controlOperator: t(operator),
      /**
      Program or markup punctuation.
      */
      punctuation,
      /**
      [Punctuation](#highlight.tags.punctuation) that separates
      things.
      */
      separator: t(punctuation),
      /**
      Bracket-style [punctuation](#highlight.tags.punctuation).
      */
      bracket,
      /**
      Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
      tokens).
      */
      angleBracket: t(bracket),
      /**
      Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
      tokens).
      */
      squareBracket: t(bracket),
      /**
      Parentheses (usually `(` and `)` tokens). Subtag of
      [bracket](#highlight.tags.bracket).
      */
      paren: t(bracket),
      /**
      Braces (usually `{` and `}` tokens). Subtag of
      [bracket](#highlight.tags.bracket).
      */
      brace: t(bracket),
      /**
      Content, for example plain text in XML or markup documents.
      */
      content,
      /**
      [Content](#highlight.tags.content) that represents a heading.
      */
      heading,
      /**
      A level 1 [heading](#highlight.tags.heading).
      */
      heading1: t(heading),
      /**
      A level 2 [heading](#highlight.tags.heading).
      */
      heading2: t(heading),
      /**
      A level 3 [heading](#highlight.tags.heading).
      */
      heading3: t(heading),
      /**
      A level 4 [heading](#highlight.tags.heading).
      */
      heading4: t(heading),
      /**
      A level 5 [heading](#highlight.tags.heading).
      */
      heading5: t(heading),
      /**
      A level 6 [heading](#highlight.tags.heading).
      */
      heading6: t(heading),
      /**
      A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
      */
      contentSeparator: t(content),
      /**
      [Content](#highlight.tags.content) that represents a list.
      */
      list: t(content),
      /**
      [Content](#highlight.tags.content) that represents a quote.
      */
      quote: t(content),
      /**
      [Content](#highlight.tags.content) that is emphasized.
      */
      emphasis: t(content),
      /**
      [Content](#highlight.tags.content) that is styled strong.
      */
      strong: t(content),
      /**
      [Content](#highlight.tags.content) that is part of a link.
      */
      link: t(content),
      /**
      [Content](#highlight.tags.content) that is styled as code or
      monospace.
      */
      monospace: t(content),
      /**
      [Content](#highlight.tags.content) that has a strike-through
      style.
      */
      strikethrough: t(content),
      /**
      Inserted text in a change-tracking format.
      */
      inserted: t(),
      /**
      Deleted text.
      */
      deleted: t(),
      /**
      Changed text.
      */
      changed: t(),
      /**
      An invalid or unsyntactic element.
      */
      invalid: t(),
      /**
      Metadata or meta-instruction.
      */
      meta,
      /**
      [Metadata](#highlight.tags.meta) that applies to the entire
      document.
      */
      documentMeta: t(meta),
      /**
      [Metadata](#highlight.tags.meta) that annotates or adds
      attributes to a given syntactic element.
      */
      annotation: t(meta),
      /**
      Processing instruction or preprocessor directive. Subtag of
      [meta](#highlight.tags.meta).
      */
      processingInstruction: t(meta),
      /**
      [Modifier](#highlight.Tag^defineModifier) that indicates that a
      given element is being defined. Expected to be used with the
      various [name](#highlight.tags.name) tags.
      */
      definition: Tag.defineModifier("definition"),
      /**
      [Modifier](#highlight.Tag^defineModifier) that indicates that
      something is constant. Mostly expected to be used with
      [variable names](#highlight.tags.variableName).
      */
      constant: Tag.defineModifier("constant"),
      /**
      [Modifier](#highlight.Tag^defineModifier) used to indicate that
      a [variable](#highlight.tags.variableName) or [property
      name](#highlight.tags.propertyName) is being called or defined
      as a function.
      */
      function: Tag.defineModifier("function"),
      /**
      [Modifier](#highlight.Tag^defineModifier) that can be applied to
      [names](#highlight.tags.name) to indicate that they belong to
      the language's standard environment.
      */
      standard: Tag.defineModifier("standard"),
      /**
      [Modifier](#highlight.Tag^defineModifier) that indicates a given
      [names](#highlight.tags.name) is local to some scope.
      */
      local: Tag.defineModifier("local"),
      /**
      A generic variant [modifier](#highlight.Tag^defineModifier) that
      can be used to tag language-specific alternative variants of
      some common tag. It is recommended for themes to define special
      forms of at least the [string](#highlight.tags.string) and
      [variable name](#highlight.tags.variableName) tags, since those
      come up a lot.
      */
      special: Tag.defineModifier("special")
    };
    for (let name2 in tags) {
      let val = tags[name2];
      if (val instanceof Tag)
        val.name = name2;
    }
    classHighlighter = tagHighlighter([
      { tag: tags.link, class: "tok-link" },
      { tag: tags.heading, class: "tok-heading" },
      { tag: tags.emphasis, class: "tok-emphasis" },
      { tag: tags.strong, class: "tok-strong" },
      { tag: tags.keyword, class: "tok-keyword" },
      { tag: tags.atom, class: "tok-atom" },
      { tag: tags.bool, class: "tok-bool" },
      { tag: tags.url, class: "tok-url" },
      { tag: tags.labelName, class: "tok-labelName" },
      { tag: tags.inserted, class: "tok-inserted" },
      { tag: tags.deleted, class: "tok-deleted" },
      { tag: tags.literal, class: "tok-literal" },
      { tag: tags.string, class: "tok-string" },
      { tag: tags.number, class: "tok-number" },
      { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
      { tag: tags.variableName, class: "tok-variableName" },
      { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
      { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
      { tag: tags.special(tags.variableName), class: "tok-variableName2" },
      { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
      { tag: tags.typeName, class: "tok-typeName" },
      { tag: tags.namespace, class: "tok-namespace" },
      { tag: tags.className, class: "tok-className" },
      { tag: tags.macroName, class: "tok-macroName" },
      { tag: tags.propertyName, class: "tok-propertyName" },
      { tag: tags.operator, class: "tok-operator" },
      { tag: tags.comment, class: "tok-comment" },
      { tag: tags.meta, class: "tok-meta" },
      { tag: tags.invalid, class: "tok-invalid" },
      { tag: tags.punctuation, class: "tok-punctuation" }
    ]);
  }
});

// node_modules/@lezer/javascript/dist/index.js
function identifierChar(ch, start) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch == 95 || ch >= 192 || !start && ch >= 48 && ch <= 57;
}
var noSemi, noSemiType, incdec, incdecPrefix, questionDot, JSXStartTag, insertSemi, spaces, newline, LineComment, BlockComment, Dialect_jsx, space, braceR, semicolon, slash, star, plus, minus, lt, comma, question, dot, bracketL, trackNewline, insertSemicolon, noSemicolon, noSemicolonType, operatorToken, jsx, jsHighlight, spec_identifier, spec_word, spec_LessThan, parser;
var init_dist6 = __esm({
  "node_modules/@lezer/javascript/dist/index.js"() {
    "use strict";
    init_dist4();
    init_dist5();
    noSemi = 316;
    noSemiType = 317;
    incdec = 1;
    incdecPrefix = 2;
    questionDot = 3;
    JSXStartTag = 4;
    insertSemi = 318;
    spaces = 320;
    newline = 321;
    LineComment = 5;
    BlockComment = 6;
    Dialect_jsx = 0;
    space = [
      9,
      10,
      11,
      12,
      13,
      32,
      133,
      160,
      5760,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8199,
      8200,
      8201,
      8202,
      8232,
      8233,
      8239,
      8287,
      12288
    ];
    braceR = 125;
    semicolon = 59;
    slash = 47;
    star = 42;
    plus = 43;
    minus = 45;
    lt = 60;
    comma = 44;
    question = 63;
    dot = 46;
    bracketL = 91;
    trackNewline = new ContextTracker({
      start: false,
      shift(context2, term) {
        return term == LineComment || term == BlockComment || term == spaces ? context2 : term == newline;
      },
      strict: false
    });
    insertSemicolon = new ExternalTokenizer((input2, stack) => {
      let { next } = input2;
      if (next == braceR || next == -1 || stack.context)
        input2.acceptToken(insertSemi);
    }, { contextual: true, fallback: true });
    noSemicolon = new ExternalTokenizer((input2, stack) => {
      let { next } = input2, after;
      if (space.indexOf(next) > -1) return;
      if (next == slash && ((after = input2.peek(1)) == slash || after == star)) return;
      if (next != braceR && next != semicolon && next != -1 && !stack.context)
        input2.acceptToken(noSemi);
    }, { contextual: true });
    noSemicolonType = new ExternalTokenizer((input2, stack) => {
      if (input2.next == bracketL && !stack.context) input2.acceptToken(noSemiType);
    }, { contextual: true });
    operatorToken = new ExternalTokenizer((input2, stack) => {
      let { next } = input2;
      if (next == plus || next == minus) {
        input2.advance();
        if (next == input2.next) {
          input2.advance();
          let mayPostfix = !stack.context && stack.canShift(incdec);
          input2.acceptToken(mayPostfix ? incdec : incdecPrefix);
        }
      } else if (next == question && input2.peek(1) == dot) {
        input2.advance();
        input2.advance();
        if (input2.next < 48 || input2.next > 57)
          input2.acceptToken(questionDot);
      }
    }, { contextual: true });
    jsx = new ExternalTokenizer((input2, stack) => {
      if (input2.next != lt || !stack.dialectEnabled(Dialect_jsx)) return;
      input2.advance();
      if (input2.next == slash) return;
      let back = 0;
      while (space.indexOf(input2.next) > -1) {
        input2.advance();
        back++;
      }
      if (identifierChar(input2.next, true)) {
        input2.advance();
        back++;
        while (identifierChar(input2.next, false)) {
          input2.advance();
          back++;
        }
        while (space.indexOf(input2.next) > -1) {
          input2.advance();
          back++;
        }
        if (input2.next == comma) return;
        for (let i = 0; ; i++) {
          if (i == 7) {
            if (!identifierChar(input2.next, true)) return;
            break;
          }
          if (input2.next != "extends".charCodeAt(i)) break;
          input2.advance();
          back++;
        }
      }
      input2.acceptToken(JSXStartTag, -back);
    });
    jsHighlight = styleTags({
      "get set async static": tags.modifier,
      "for while do if else switch try catch finally return throw break continue default case defer": tags.controlKeyword,
      "in of await yield void typeof delete instanceof as satisfies": tags.operatorKeyword,
      "let var const using function class extends": tags.definitionKeyword,
      "import export from": tags.moduleKeyword,
      "with debugger new": tags.keyword,
      TemplateString: tags.special(tags.string),
      super: tags.atom,
      BooleanLiteral: tags.bool,
      this: tags.self,
      null: tags.null,
      Star: tags.modifier,
      VariableName: tags.variableName,
      "CallExpression/VariableName TaggedTemplateExpression/VariableName": tags.function(tags.variableName),
      VariableDefinition: tags.definition(tags.variableName),
      Label: tags.labelName,
      PropertyName: tags.propertyName,
      PrivatePropertyName: tags.special(tags.propertyName),
      "CallExpression/MemberExpression/PropertyName": tags.function(tags.propertyName),
      "FunctionDeclaration/VariableDefinition": tags.function(tags.definition(tags.variableName)),
      "ClassDeclaration/VariableDefinition": tags.definition(tags.className),
      "NewExpression/VariableName": tags.className,
      PropertyDefinition: tags.definition(tags.propertyName),
      PrivatePropertyDefinition: tags.definition(tags.special(tags.propertyName)),
      UpdateOp: tags.updateOperator,
      "LineComment Hashbang": tags.lineComment,
      BlockComment: tags.blockComment,
      Number: tags.number,
      String: tags.string,
      Escape: tags.escape,
      ArithOp: tags.arithmeticOperator,
      LogicOp: tags.logicOperator,
      BitOp: tags.bitwiseOperator,
      CompareOp: tags.compareOperator,
      RegExp: tags.regexp,
      Equals: tags.definitionOperator,
      Arrow: tags.function(tags.punctuation),
      ": Spread": tags.punctuation,
      "( )": tags.paren,
      "[ ]": tags.squareBracket,
      "{ }": tags.brace,
      "InterpolationStart InterpolationEnd": tags.special(tags.brace),
      ".": tags.derefOperator,
      ", ;": tags.separator,
      "@": tags.meta,
      TypeName: tags.typeName,
      TypeDefinition: tags.definition(tags.typeName),
      "type enum interface implements namespace module declare": tags.definitionKeyword,
      "abstract global Privacy readonly override": tags.modifier,
      "is keyof unique infer asserts": tags.operatorKeyword,
      JSXAttributeValue: tags.attributeValue,
      JSXText: tags.content,
      "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": tags.angleBracket,
      "JSXIdentifier JSXNameSpacedName": tags.tagName,
      "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": tags.attributeName,
      "JSXBuiltin/JSXIdentifier": tags.standard(tags.tagName)
    });
    spec_identifier = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, in: 52, out: 55, const: 56, extends: 60, this: 64, true: 72, false: 72, null: 84, void: 88, typeof: 92, super: 108, new: 142, delete: 154, yield: 163, await: 167, class: 172, public: 235, private: 235, protected: 235, readonly: 237, instanceof: 256, satisfies: 259, import: 292, keyof: 349, unique: 353, infer: 359, asserts: 395, is: 397, abstract: 417, implements: 419, type: 421, let: 424, var: 426, using: 429, interface: 435, enum: 439, namespace: 445, module: 447, declare: 451, global: 455, defer: 471, for: 476, of: 485, while: 488, with: 492, do: 496, if: 500, else: 502, switch: 506, case: 512, try: 518, catch: 522, finally: 526, return: 530, throw: 534, break: 538, continue: 542, debugger: 546 };
    spec_word = { __proto__: null, async: 129, get: 131, set: 133, declare: 195, public: 197, private: 197, protected: 197, static: 199, abstract: 201, override: 203, readonly: 209, accessor: 211, new: 401 };
    spec_LessThan = { __proto__: null, "<": 193 };
    parser = LRParser.deserialize({
      version: 14,
      states: "$F|Q%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#DaO.QQlO'#DgO.bQlO'#DrO%[QlO'#DzO0fQlO'#ESOOQ!0Lf'#E['#E[O1PQ`O'#EXOOQO'#Ep'#EpOOQO'#Il'#IlO1XQ`O'#GsO1dQ`O'#EoO1iQ`O'#EoO3hQ!0MxO'#JrO6[Q!0MxO'#JsO6uQ`O'#F]O6zQ,UO'#FtOOQ!0Lf'#Ff'#FfO7VO7dO'#FfO9XQMhO'#F|O9`Q`O'#F{OOQ!0Lf'#Js'#JsOOQ!0Lb'#Jr'#JrO9eQ`O'#GwOOQ['#K_'#K_O9pQ`O'#IYO9uQ!0LrO'#IZOOQ['#J`'#J`OOQ['#I_'#I_Q`QlOOQ`QlOOO9}Q!L^O'#DvO:UQlO'#EOO:]QlO'#EQO9kQ`O'#GsO:dQMhO'#CoO:rQ`O'#EnO:}Q`O'#EyO;hQMhO'#FeO;xQ`O'#GsOOQO'#K`'#K`O;}Q`O'#K`O<]Q`O'#G{O<]Q`O'#G|O<]Q`O'#HOO9kQ`O'#HRO=SQ`O'#HUO>kQ`O'#CeO>{Q`O'#HcO?TQ`O'#HiO?TQ`O'#HkO`QlO'#HmO?TQ`O'#HoO?TQ`O'#HrO?YQ`O'#HxO?_Q!0LsO'#IOO%[QlO'#IQO?jQ!0LsO'#ISO?uQ!0LsO'#IUO9uQ!0LrO'#IWO@QQ!0MxO'#CiOASQpO'#DlQOQ`OOO%[QlO'#EQOAjQ`O'#ETO:dQMhO'#EnOAuQ`O'#EnOBQQ!bO'#FeOOQ['#Cg'#CgOOQ!0Lb'#Dq'#DqOOQ!0Lb'#Jv'#JvO%[QlO'#JvOOQO'#Jy'#JyOOQO'#Ih'#IhOCQQpO'#EgOOQ!0Lb'#Ef'#EfOOQ!0Lb'#J}'#J}OC|Q!0MSO'#EgODWQpO'#EWOOQO'#Jx'#JxODlQpO'#JyOEyQpO'#EWODWQpO'#EgPFWO&2DjO'#CbPOOO)CD})CD}OOOO'#I`'#I`OFcO#tO,59UOOQ!0Lh,59U,59UOOOO'#Ia'#IaOFqO&jO,59UOGPQ!L^O'#DcOOOO'#Ic'#IcOGWO#@ItO,59{OOQ!0Lf,59{,59{OGfQlO'#IdOGyQ`O'#JtOIxQ!fO'#JtO+}QlO'#JtOJPQ`O,5:ROJgQ`O'#EpOJtQ`O'#KTOKPQ`O'#KSOKPQ`O'#KSOKXQ`O,5;^OK^Q`O'#KROOQ!0Ln,5:^,5:^OKeQlO,5:^OMcQ!0MxO,5:fONSQ`O,5:nONmQ!0LrO'#KQONtQ`O'#KPO9eQ`O'#KPO! YQ`O'#KPO! bQ`O,5;]O! gQ`O'#KPO!#lQ!fO'#JsOOQ!0Lh'#Ci'#CiO%[QlO'#ESO!$[Q!fO,5:sOOQS'#Jz'#JzOOQO-E<j-E<jO9kQ`O,5=_O!$rQ`O,5=_O!$wQlO,5;ZO!&zQMhO'#EkO!(eQ`O,5;ZO!(jQlO'#DyO!(tQpO,5;dO!(|QpO,5;dO%[QlO,5;dOOQ['#FT'#FTOOQ['#FV'#FVO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eOOQ['#FZ'#FZO!)[QlO,5;tOOQ!0Lf,5;y,5;yOOQ!0Lf,5;z,5;zOOQ!0Lf,5;|,5;|O%[QlO'#IpO!+_Q!0LrO,5<iO%[QlO,5;eO!&zQMhO,5;eO!+|QMhO,5;eO!-nQMhO'#E^O%[QlO,5;wOOQ!0Lf,5;{,5;{O!-uQ,UO'#FjO!.rQ,UO'#KXO!.^Q,UO'#KXO!.yQ,UO'#KXOOQO'#KX'#KXO!/_Q,UO,5<SOOOW,5<`,5<`O!/pQlO'#FvOOOW'#Io'#IoO7VO7dO,5<QO!/wQ,UO'#FxOOQ!0Lf,5<Q,5<QO!0hQ$IUO'#CyOOQ!0Lh'#C}'#C}O!0{O#@ItO'#DRO!1iQMjO,5<eO!1pQ`O,5<hO!3YQ(CWO'#GXO!3jQ`O'#GYO!3oQ`O'#GYO!5_Q(CWO'#G^O!6dQpO'#GbOOQO'#Gn'#GnO!,TQMhO'#GmOOQO'#Gp'#GpO!,TQMhO'#GoO!7VQ$IUO'#JlOOQ!0Lh'#Jl'#JlO!7aQ`O'#JkO!7oQ`O'#JjO!7wQ`O'#CuOOQ!0Lh'#C{'#C{O!8YQ`O'#C}OOQ!0Lh'#DV'#DVOOQ!0Lh'#DX'#DXO!8_Q`O,5<eO1SQ`O'#DZO!,TQMhO'#GPO!,TQMhO'#GRO!8gQ`O'#GTO!8lQ`O'#GUO!3oQ`O'#G[O!,TQMhO'#GaO<]Q`O'#JkO!8qQ`O'#EqO!9`Q`O,5<gOOQ!0Lb'#Cr'#CrO!9hQ`O'#ErO!:bQpO'#EsOOQ!0Lb'#KR'#KRO!:iQ!0LrO'#KaO9uQ!0LrO,5=cO`QlO,5>tOOQ['#Jh'#JhOOQ[,5>u,5>uOOQ[-E<]-E<]O!<hQ!0MxO,5:bO!:]QpO,5:`O!?RQ!0MxO,5:jO%[QlO,5:jO!AiQ!0MxO,5:lOOQO,5@z,5@zO!BYQMhO,5=_O!BhQ!0LrO'#JiO9`Q`O'#JiO!ByQ!0LrO,59ZO!CUQpO,59ZO!C^QMhO,59ZO:dQMhO,59ZO!CiQ`O,5;ZO!CqQ`O'#HbO!DVQ`O'#KdO%[QlO,5;}O!:]QpO,5<PO!D_Q`O,5=zO!DdQ`O,5=zO!DiQ`O,5=zO!DwQ`O,5=zO9uQ!0LrO,5=zO<]Q`O,5=jOOQO'#Cy'#CyO!EOQpO,5=gO!EWQMhO,5=hO!EcQ`O,5=jO!EhQ!bO,5=mO!EpQ`O'#K`O?YQ`O'#HWO9kQ`O'#HYO!EuQ`O'#HYO:dQMhO'#H[O!EzQ`O'#H[OOQ[,5=p,5=pO!FPQ`O'#H]O!FbQ`O'#CoO!FgQ`O,59PO!FqQ`O,59PO!HvQlO,59POOQ[,59P,59PO!IWQ!0LrO,59PO%[QlO,59PO!KcQlO'#HeOOQ['#Hf'#HfOOQ['#Hg'#HgO`QlO,5=}O!KyQ`O,5=}O`QlO,5>TO`QlO,5>VO!LOQ`O,5>XO`QlO,5>ZO!LTQ`O,5>^O!LYQlO,5>dOOQ[,5>j,5>jO%[QlO,5>jO9uQ!0LrO,5>lOOQ[,5>n,5>nO#!dQ`O,5>nOOQ[,5>p,5>pO#!dQ`O,5>pOOQ[,5>r,5>rO##QQpO'#D_O%[QlO'#JvO##sQpO'#JvO##}QpO'#DmO#$`QpO'#DmO#&qQlO'#DmO#&xQ`O'#JuO#'QQ`O,5:WO#'VQ`O'#EtO#'eQ`O'#KUO#'mQ`O,5;_O#'rQpO'#DmO#(PQpO'#EVOOQ!0Lf,5:o,5:oO%[QlO,5:oO#(WQ`O,5:oO?YQ`O,5;YO!CUQpO,5;YO!C^QMhO,5;YO:dQMhO,5;YO#(`Q`O,5@bO#(eQ07dO,5:sOOQO-E<f-E<fO#)kQ!0MSO,5;RODWQpO,5:rO#)uQpO,5:rODWQpO,5;RO!ByQ!0LrO,5:rOOQ!0Lb'#Ej'#EjOOQO,5;R,5;RO%[QlO,5;RO#*SQ!0LrO,5;RO#*_Q!0LrO,5;RO!CUQpO,5:rOOQO,5;X,5;XO#*mQ!0LrO,5;RPOOO'#I^'#I^P#+RO&2DjO,58|POOO,58|,58|OOOO-E<^-E<^OOQ!0Lh1G.p1G.pOOOO-E<_-E<_OOOO,59},59}O#+^Q!bO,59}OOOO-E<a-E<aOOQ!0Lf1G/g1G/gO#+cQ!fO,5?OO+}QlO,5?OOOQO,5?U,5?UO#+mQlO'#IdOOQO-E<b-E<bO#+zQ`O,5@`O#,SQ!fO,5@`O#,ZQ`O,5@nOOQ!0Lf1G/m1G/mO%[QlO,5@oO#,cQ`O'#IjOOQO-E<h-E<hO#,ZQ`O,5@nOOQ!0Lb1G0x1G0xOOQ!0Ln1G/x1G/xOOQ!0Ln1G0Y1G0YO%[QlO,5@lO#,wQ!0LrO,5@lO#-YQ!0LrO,5@lO#-aQ`O,5@kO9eQ`O,5@kO#-iQ`O,5@kO#-wQ`O'#ImO#-aQ`O,5@kOOQ!0Lb1G0w1G0wO!(tQpO,5:uO!)PQpO,5:uOOQS,5:w,5:wO#.iQdO,5:wO#.qQMhO1G2yO9kQ`O1G2yOOQ!0Lf1G0u1G0uO#/PQ!0MxO1G0uO#0UQ!0MvO,5;VOOQ!0Lh'#GW'#GWO#0rQ!0MzO'#JlO!$wQlO1G0uO#2}Q!fO'#JwO%[QlO'#JwO#3XQ`O,5:eOOQ!0Lh'#D_'#D_OOQ!0Lf1G1O1G1OO%[QlO1G1OOOQ!0Lf1G1f1G1fO#3^Q`O1G1OO#5rQ!0MxO1G1PO#5yQ!0MxO1G1PO#8aQ!0MxO1G1PO#8hQ!0MxO1G1PO#;OQ!0MxO1G1PO#=fQ!0MxO1G1PO#=mQ!0MxO1G1PO#=tQ!0MxO1G1PO#@[Q!0MxO1G1PO#@cQ!0MxO1G1PO#BpQ?MtO'#CiO#DkQ?MtO1G1`O#DrQ?MtO'#JsO#EVQ!0MxO,5?[OOQ!0Lb-E<n-E<nO#GdQ!0MxO1G1PO#HaQ!0MzO1G1POOQ!0Lf1G1P1G1PO#IdQMjO'#J|O#InQ`O,5:xO#IsQ!0MxO1G1cO#JgQ,UO,5<WO#JoQ,UO,5<XO#JwQ,UO'#FoO#K`Q`O'#FnOOQO'#KY'#KYOOQO'#In'#InO#KeQ,UO1G1nOOQ!0Lf1G1n1G1nOOOW1G1y1G1yO#KvQ?MtO'#JrO#LQQ`O,5<bO!)[QlO,5<bOOOW-E<m-E<mOOQ!0Lf1G1l1G1lO#LVQpO'#KXOOQ!0Lf,5<d,5<dO#L_QpO,5<dO#LdQMhO'#DTOOOO'#Ib'#IbO#LkO#@ItO,59mOOQ!0Lh,59m,59mO%[QlO1G2PO!8lQ`O'#IrO#LvQ`O,5<zOOQ!0Lh,5<w,5<wO!,TQMhO'#IuO#MdQMjO,5=XO!,TQMhO'#IwO#NVQMjO,5=ZO!&zQMhO,5=]OOQO1G2S1G2SO#NaQ!dO'#CrO#NtQ(CWO'#ErO$ |QpO'#GbO$!dQ!dO,5<sO$!kQ`O'#K[O9eQ`O'#K[O$!yQ`O,5<uO$#aQ!dO'#C{O!,TQMhO,5<tO$#kQ`O'#GZO$$PQ`O,5<tO$$UQ!dO'#GWO$$cQ!dO'#K]O$$mQ`O'#K]O!&zQMhO'#K]O$$rQ`O,5<xO$$wQlO'#JvO$%RQpO'#GcO#$`QpO'#GcO$%dQ`O'#GgO!3oQ`O'#GkO$%iQ!0LrO'#ItO$%tQpO,5<|OOQ!0Lp,5<|,5<|O$%{QpO'#GcO$&YQpO'#GdO$&kQpO'#GdO$&pQMjO,5=XO$'QQMjO,5=ZOOQ!0Lh,5=^,5=^O!,TQMhO,5@VO!,TQMhO,5@VO$'bQ`O'#IyO$'vQ`O,5@UO$(OQ`O,59aOOQ!0Lh,59i,59iO$(TQ`O,5@VO$)TQ$IYO,59uOOQ!0Lh'#Jp'#JpO$)vQMjO,5<kO$*iQMjO,5<mO@zQ`O,5<oOOQ!0Lh,5<p,5<pO$*sQ`O,5<vO$*xQMjO,5<{O$+YQ`O'#KPO!$wQlO1G2RO$+_Q`O1G2RO9eQ`O'#KSO9eQ`O'#EtO%[QlO'#EtO9eQ`O'#I{O$+dQ!0LrO,5@{OOQ[1G2}1G2}OOQ[1G4`1G4`OOQ!0Lf1G/|1G/|OOQ!0Lf1G/z1G/zO$-fQ!0MxO1G0UOOQ[1G2y1G2yO!&zQMhO1G2yO%[QlO1G2yO#.tQ`O1G2yO$/jQMhO'#EkOOQ!0Lb,5@T,5@TO$/wQ!0LrO,5@TOOQ[1G.u1G.uO!ByQ!0LrO1G.uO!CUQpO1G.uO!C^QMhO1G.uO$0YQ`O1G0uO$0_Q`O'#CiO$0jQ`O'#KeO$0rQ`O,5=|O$0wQ`O'#KeO$0|Q`O'#KeO$1[Q`O'#JRO$1jQ`O,5AOO$1rQ!fO1G1iOOQ!0Lf1G1k1G1kO9kQ`O1G3fO@zQ`O1G3fO$1yQ`O1G3fO$2OQ`O1G3fO!DiQ`O1G3fO9uQ!0LrO1G3fOOQ[1G3f1G3fO!EcQ`O1G3UO!&zQMhO1G3RO$2TQ`O1G3ROOQ[1G3S1G3SO!&zQMhO1G3SO$2YQ`O1G3SO$2bQpO'#HQOOQ[1G3U1G3UO!6_QpO'#I}O!EhQ!bO1G3XOOQ[1G3X1G3XOOQ[,5=r,5=rO$2jQMhO,5=tO9kQ`O,5=tO$%dQ`O,5=vO9`Q`O,5=vO!CUQpO,5=vO!C^QMhO,5=vO:dQMhO,5=vO$2xQ`O'#KcO$3TQ`O,5=wOOQ[1G.k1G.kO$3YQ!0LrO1G.kO@zQ`O1G.kO$3eQ`O1G.kO9uQ!0LrO1G.kO$5mQ!fO,5AQO$5zQ`O,5AQO9eQ`O,5AQO$6VQlO,5>PO$6^Q`O,5>POOQ[1G3i1G3iO`QlO1G3iOOQ[1G3o1G3oOOQ[1G3q1G3qO?TQ`O1G3sO$6cQlO1G3uO$:gQlO'#HtOOQ[1G3x1G3xO$:tQ`O'#HzO?YQ`O'#H|OOQ[1G4O1G4OO$:|QlO1G4OO9uQ!0LrO1G4UOOQ[1G4W1G4WOOQ!0Lb'#G_'#G_O9uQ!0LrO1G4YO9uQ!0LrO1G4[O$?TQ`O,5@bO!)[QlO,5;`O9eQ`O,5;`O?YQ`O,5:XO!)[QlO,5:XO!CUQpO,5:XO$?YQ?MtO,5:XOOQO,5;`,5;`O$?dQpO'#IeO$?zQ`O,5@aOOQ!0Lf1G/r1G/rO$@SQpO'#IkO$@^Q`O,5@pOOQ!0Lb1G0y1G0yO#$`QpO,5:XOOQO'#Ig'#IgO$@fQpO,5:qOOQ!0Ln,5:q,5:qO#(ZQ`O1G0ZOOQ!0Lf1G0Z1G0ZO%[QlO1G0ZOOQ!0Lf1G0t1G0tO?YQ`O1G0tO!CUQpO1G0tO!C^QMhO1G0tOOQ!0Lb1G5|1G5|O!ByQ!0LrO1G0^OOQO1G0m1G0mO%[QlO1G0mO$@mQ!0LrO1G0mO$@xQ!0LrO1G0mO!CUQpO1G0^ODWQpO1G0^O$AWQ!0LrO1G0mOOQO1G0^1G0^O$AlQ!0MxO1G0mPOOO-E<[-E<[POOO1G.h1G.hOOOO1G/i1G/iO$AvQ!bO,5<iO$BOQ!fO1G4jOOQO1G4p1G4pO%[QlO,5?OO$BYQ`O1G5zO$BbQ`O1G6YO$BjQ!fO1G6ZO9eQ`O,5?UO$BtQ!0MxO1G6WO%[QlO1G6WO$CUQ!0LrO1G6WO$CgQ`O1G6VO$CgQ`O1G6VO9eQ`O1G6VO$CoQ`O,5?XO9eQ`O,5?XOOQO,5?X,5?XO$DTQ`O,5?XO$+YQ`O,5?XOOQO-E<k-E<kOOQS1G0a1G0aOOQS1G0c1G0cO#.lQ`O1G0cOOQ[7+(e7+(eO!&zQMhO7+(eO%[QlO7+(eO$DcQ`O7+(eO$DnQMhO7+(eO$D|Q!0MzO,5=XO$GXQ!0MzO,5=ZO$IdQ!0MzO,5=XO$KuQ!0MzO,5=ZO$NWQ!0MzO,59uO%!]Q!0MzO,5<kO%$hQ!0MzO,5<mO%&sQ!0MzO,5<{OOQ!0Lf7+&a7+&aO%)UQ!0MxO7+&aO%)xQlO'#IfO%*VQ`O,5@cO%*_Q!fO,5@cOOQ!0Lf1G0P1G0PO%*iQ`O7+&jOOQ!0Lf7+&j7+&jO%*nQ?MtO,5:fO%[QlO7+&zO%*xQ?MtO,5:bO%+VQ?MtO,5:jO%+aQ?MtO,5:lO%+kQMhO'#IiO%+uQ`O,5@hOOQ!0Lh1G0d1G0dOOQO1G1r1G1rOOQO1G1s1G1sO%+}Q!jO,5<ZO!)[QlO,5<YOOQO-E<l-E<lOOQ!0Lf7+'Y7+'YOOOW7+'e7+'eOOOW1G1|1G1|O%,YQ`O1G1|OOQ!0Lf1G2O1G2OOOOO,59o,59oO%,_Q!dO,59oOOOO-E<`-E<`OOQ!0Lh1G/X1G/XO%,fQ!0MxO7+'kOOQ!0Lh,5?^,5?^O%-YQMhO1G2fP%-aQ`O'#IrPOQ!0Lh-E<p-E<pO%-}QMjO,5?aOOQ!0Lh-E<s-E<sO%.pQMjO,5?cOOQ!0Lh-E<u-E<uO%.zQ!dO1G2wO%/RQ!dO'#CrO%/iQMhO'#KSO$$wQlO'#JvOOQ!0Lh1G2_1G2_O%/sQ`O'#IqO%0[Q`O,5@vO%0[Q`O,5@vO%0dQ`O,5@vO%0oQ`O,5@vOOQO1G2a1G2aO%0}QMjO1G2`O$+YQ`O'#K[O!,TQMhO1G2`O%1_Q(CWO'#IsO%1lQ`O,5@wO!&zQMhO,5@wO%1tQ!dO,5@wOOQ!0Lh1G2d1G2dO%4UQ!fO'#CiO%4`Q`O,5=POOQ!0Lb,5<},5<}O%4hQpO,5<}OOQ!0Lb,5=O,5=OOCwQ`O,5<}O%4sQpO,5<}OOQ!0Lb,5=R,5=RO$+YQ`O,5=VOOQO,5?`,5?`OOQO-E<r-E<rOOQ!0Lp1G2h1G2hO#$`QpO,5<}O$$wQlO,5=PO%5RQ`O,5=OO%5^QpO,5=OO!,TQMhO'#IuO%6WQMjO1G2sO!,TQMhO'#IwO%6yQMjO1G2uO%7TQMjO1G5qO%7_QMjO1G5qOOQO,5?e,5?eOOQO-E<w-E<wOOQO1G.{1G.{O!,TQMhO1G5qO!,TQMhO1G5qO!:]QpO,59wO%[QlO,59wOOQ!0Lh,5<j,5<jO%7lQ`O1G2ZO!,TQMhO1G2bO%7qQ!0MxO7+'mOOQ!0Lf7+'m7+'mO!$wQlO7+'mO%8eQ`O,5;`OOQ!0Lb,5?g,5?gOOQ!0Lb-E<y-E<yO%8jQ!dO'#K^O#(ZQ`O7+(eO4UQ!fO7+(eO$DfQ`O7+(eO%8tQ!0MvO'#CiO%9XQ!0MvO,5=SO%9lQ`O,5=SO%9tQ`O,5=SOOQ!0Lb1G5o1G5oOOQ[7+$a7+$aO!ByQ!0LrO7+$aO!CUQpO7+$aO!$wQlO7+&aO%9yQ`O'#JQO%:bQ`O,5APOOQO1G3h1G3hO9kQ`O,5APO%:bQ`O,5APO%:jQ`O,5APOOQO,5?m,5?mOOQO-E=P-E=POOQ!0Lf7+'T7+'TO%:oQ`O7+)QO9uQ!0LrO7+)QO9kQ`O7+)QO@zQ`O7+)QO%:tQ`O7+)QOOQ[7+)Q7+)QOOQ[7+(p7+(pO%:yQ!0MvO7+(mO!&zQMhO7+(mO!E^Q`O7+(nOOQ[7+(n7+(nO!&zQMhO7+(nO%;TQ`O'#KbO%;`Q`O,5=lOOQO,5?i,5?iOOQO-E<{-E<{OOQ[7+(s7+(sO%<rQpO'#HZOOQ[1G3`1G3`O!&zQMhO1G3`O%[QlO1G3`O%<yQ`O1G3`O%=UQMhO1G3`O9uQ!0LrO1G3bO$%dQ`O1G3bO9`Q`O1G3bO!CUQpO1G3bO!C^QMhO1G3bO%=dQ`O'#JPO%=xQ`O,5@}O%>QQpO,5@}OOQ!0Lb1G3c1G3cOOQ[7+$V7+$VO@zQ`O7+$VO9uQ!0LrO7+$VO%>]Q`O7+$VO%[QlO1G6lO%[QlO1G6mO%>bQ!0LrO1G6lO%>lQlO1G3kO%>sQ`O1G3kO%>xQlO1G3kOOQ[7+)T7+)TO9uQ!0LrO7+)_O`QlO7+)aOOQ['#Kh'#KhOOQ['#JS'#JSO%?PQlO,5>`OOQ[,5>`,5>`O%[QlO'#HuO%?^Q`O'#HwOOQ[,5>f,5>fO9eQ`O,5>fOOQ[,5>h,5>hOOQ[7+)j7+)jOOQ[7+)p7+)pOOQ[7+)t7+)tOOQ[7+)v7+)vO%?cQpO1G5|O%?}Q?MtO1G0zO%@XQ`O1G0zOOQO1G/s1G/sO%@dQ?MtO1G/sO?YQ`O1G/sO!)[QlO'#DmOOQO,5?P,5?POOQO-E<c-E<cOOQO,5?V,5?VOOQO-E<i-E<iO!CUQpO1G/sOOQO-E<e-E<eOOQ!0Ln1G0]1G0]OOQ!0Lf7+%u7+%uO#(ZQ`O7+%uOOQ!0Lf7+&`7+&`O?YQ`O7+&`O!CUQpO7+&`OOQO7+%x7+%xO$AlQ!0MxO7+&XOOQO7+&X7+&XO%[QlO7+&XO%@nQ!0LrO7+&XO!ByQ!0LrO7+%xO!CUQpO7+%xO%@yQ!0LrO7+&XO%AXQ!0MxO7++rO%[QlO7++rO%AiQ`O7++qO%AiQ`O7++qOOQO1G4s1G4sO9eQ`O1G4sO%AqQ`O1G4sOOQS7+%}7+%}O#(ZQ`O<<LPO4UQ!fO<<LPO%BPQ`O<<LPOOQ[<<LP<<LPO!&zQMhO<<LPO%[QlO<<LPO%BXQ`O<<LPO%BdQ!0MzO,5?aO%DoQ!0MzO,5?cO%FzQ!0MzO1G2`O%I]Q!0MzO1G2sO%KhQ!0MzO1G2uO%MsQ!fO,5?QO%[QlO,5?QOOQO-E<d-E<dO%M}Q`O1G5}OOQ!0Lf<<JU<<JUO%NVQ?MtO1G0uO&!^Q?MtO1G1PO&!eQ?MtO1G1PO&$fQ?MtO1G1PO&$mQ?MtO1G1PO&&nQ?MtO1G1PO&(oQ?MtO1G1PO&(vQ?MtO1G1PO&(}Q?MtO1G1PO&+OQ?MtO1G1PO&+VQ?MtO1G1PO&+^Q!0MxO<<JfO&-UQ?MtO1G1PO&.RQ?MvO1G1PO&/UQ?MvO'#JlO&1[Q?MtO1G1cO&1iQ?MtO1G0UO&1sQMjO,5?TOOQO-E<g-E<gO!)[QlO'#FqOOQO'#KZ'#KZOOQO1G1u1G1uO&1}Q`O1G1tO&2SQ?MtO,5?[OOOW7+'h7+'hOOOO1G/Z1G/ZO&2^Q!dO1G4xOOQ!0Lh7+(Q7+(QP!&zQMhO,5?^O!,TQMhO7+(cO&2eQ`O,5?]O9eQ`O,5?]O$+YQ`O,5?]OOQO-E<o-E<oO&2sQ`O1G6bO&2sQ`O1G6bO&2{Q`O1G6bO&3WQMjO7+'zO&3hQ!dO,5?_O&3rQ`O,5?_O!&zQMhO,5?_OOQO-E<q-E<qO&3wQ!dO1G6cO&4RQ`O1G6cO&4ZQ`O1G2kO!&zQMhO1G2kOOQ!0Lb1G2i1G2iOOQ!0Lb1G2j1G2jO%4hQpO1G2iO!CUQpO1G2iOCwQ`O1G2iOOQ!0Lb1G2q1G2qO&4`QpO1G2iO&4nQ`O1G2kO$+YQ`O1G2jOCwQ`O1G2jO$$wQlO1G2kO&4vQ`O1G2jO&5jQMjO,5?aOOQ!0Lh-E<t-E<tO&6]QMjO,5?cOOQ!0Lh-E<v-E<vO!,TQMhO7++]O&6gQMjO7++]O&6qQMjO7++]OOQ!0Lh1G/c1G/cO&7OQ`O1G/cOOQ!0Lh7+'u7+'uO&7TQMjO7+'|O&7eQ!0MxO<<KXOOQ!0Lf<<KX<<KXO&8XQ`O1G0zO!&zQMhO'#IzO&8^Q`O,5@xO&:`Q!fO<<LPO!&zQMhO1G2nO&:gQ!0LrO1G2nOOQ[<<G{<<G{O!ByQ!0LrO<<G{O&:xQ!0MxO<<I{OOQ!0Lf<<I{<<I{OOQO,5?l,5?lO&;lQ`O,5?lO&;qQ`O,5?lOOQO-E=O-E=OO&<PQ`O1G6kO&<PQ`O1G6kO9kQ`O1G6kO@zQ`O<<LlOOQ[<<Ll<<LlO&<XQ`O<<LlO9uQ!0LrO<<LlO9kQ`O<<LlOOQ[<<LX<<LXO%:yQ!0MvO<<LXOOQ[<<LY<<LYO!E^Q`O<<LYO&<^QpO'#I|O&<iQ`O,5@|O!)[QlO,5@|OOQ[1G3W1G3WOOQO'#JO'#JOO9uQ!0LrO'#JOO&<qQpO,5=uOOQ[,5=u,5=uO&<xQpO'#EgO&=PQpO'#GeO&=UQ`O7+(zO&=ZQ`O7+(zOOQ[7+(z7+(zO!&zQMhO7+(zO%[QlO7+(zO&=cQ`O7+(zOOQ[7+(|7+(|O9uQ!0LrO7+(|O$%dQ`O7+(|O9`Q`O7+(|O!CUQpO7+(|O&=nQ`O,5?kOOQO-E<}-E<}OOQO'#H^'#H^O&=yQ`O1G6iO9uQ!0LrO<<GqOOQ[<<Gq<<GqO@zQ`O<<GqO&>RQ`O7+,WO&>WQ`O7+,XO%[QlO7+,WO%[QlO7+,XOOQ[7+)V7+)VO&>]Q`O7+)VO&>bQlO7+)VO&>iQ`O7+)VOOQ[<<Ly<<LyOOQ[<<L{<<L{OOQ[-E=Q-E=QOOQ[1G3z1G3zO&>nQ`O,5>aOOQ[,5>c,5>cO&>sQ`O1G4QO9eQ`O7+&fO!)[QlO7+&fOOQO7+%_7+%_O&>xQ?MtO1G6ZO?YQ`O7+%_OOQ!0Lf<<Ia<<IaOOQ!0Lf<<Iz<<IzO?YQ`O<<IzOOQO<<Is<<IsO$AlQ!0MxO<<IsO%[QlO<<IsOOQO<<Id<<IdO!ByQ!0LrO<<IdO&?SQ!0LrO<<IsO&?_Q!0MxO<= ^O&?oQ`O<= ]OOQO7+*_7+*_O9eQ`O7+*_OOQ[ANAkANAkO&?wQ!fOANAkO!&zQMhOANAkO#(ZQ`OANAkO4UQ!fOANAkO&@OQ`OANAkO%[QlOANAkO&@WQ!0MzO7+'zO&BiQ!0MzO,5?aO&DtQ!0MzO,5?cO&GPQ!0MzO7+'|O&IbQ!fO1G4lO&IlQ?MtO7+&aO&KpQ?MvO,5=XO&MwQ?MvO,5=ZO&NXQ?MvO,5=XO&NiQ?MvO,5=ZO&NyQ?MvO,59uO'#PQ?MvO,5<kO'%SQ?MvO,5<mO''hQ?MvO,5<{O')^Q?MtO7+'kO')kQ?MtO7+'mO')xQ`O,5<]OOQO7+'`7+'`OOQ!0Lh7+*d7+*dO')}QMjO<<K}OOQO1G4w1G4wO'*UQ`O1G4wO'*aQ`O1G4wO'*oQ`O7++|O'*oQ`O7++|O!&zQMhO1G4yO'*wQ!dO1G4yO'+RQ`O7++}O'+ZQ`O7+(VO'+fQ!dO7+(VOOQ!0Lb7+(T7+(TOOQ!0Lb7+(U7+(UO!CUQpO7+(TOCwQ`O7+(TO'+pQ`O7+(VO!&zQMhO7+(VO$+YQ`O7+(UO'+uQ`O7+(VOCwQ`O7+(UO'+}QMjO<<NwO!,TQMhO<<NwOOQ!0Lh7+$}7+$}O',XQ!dO,5?fOOQO-E<x-E<xO',cQ!0MvO7+(YO!&zQMhO7+(YOOQ[AN=gAN=gO9kQ`O1G5WOOQO1G5W1G5WO',sQ`O1G5WO',xQ`O7+,VO',xQ`O7+,VO9uQ!0LrOANBWO@zQ`OANBWOOQ[ANBWANBWO'-QQ`OANBWOOQ[ANAsANAsOOQ[ANAtANAtO'-VQ`O,5?hOOQO-E<z-E<zO'-bQ?MtO1G6hOOQO,5?j,5?jOOQO-E<|-E<|OOQ[1G3a1G3aO'-lQ`O,5=POOQ[<<Lf<<LfO!&zQMhO<<LfO&=UQ`O<<LfO'-qQ`O<<LfO%[QlO<<LfOOQ[<<Lh<<LhO9uQ!0LrO<<LhO$%dQ`O<<LhO9`Q`O<<LhO'-yQpO1G5VO'.UQ`O7+,TOOQ[AN=]AN=]O9uQ!0LrOAN=]OOQ[<= r<= rOOQ[<= s<= sO'.^Q`O<= rO'.cQ`O<= sOOQ[<<Lq<<LqO'.hQ`O<<LqO'.mQlO<<LqOOQ[1G3{1G3{O?YQ`O7+)lO'.tQ`O<<JQO'/PQ?MtO<<JQOOQO<<Hy<<HyOOQ!0LfAN?fAN?fOOQOAN?_AN?_O$AlQ!0MxOAN?_OOQOAN?OAN?OO%[QlOAN?_OOQO<<My<<MyOOQ[G27VG27VO!&zQMhOG27VO#(ZQ`OG27VO'/ZQ!fOG27VO4UQ!fOG27VO'/bQ`OG27VO'/jQ?MtO<<JfO'/wQ?MvO1G2`O'1mQ?MvO,5?aO'3pQ?MvO,5?cO'5sQ?MvO1G2sO'7vQ?MvO1G2uO'9yQ?MtO<<KXO':WQ?MtO<<I{OOQO1G1w1G1wO!,TQMhOANAiOOQO7+*c7+*cO':eQ`O7+*cO':pQ`O<= hO':xQ!dO7+*eOOQ!0Lb<<Kq<<KqO$+YQ`O<<KqOCwQ`O<<KqO';SQ`O<<KqO!&zQMhO<<KqOOQ!0Lb<<Ko<<KoO!CUQpO<<KoO';_Q!dO<<KqOOQ!0Lb<<Kp<<KpO';iQ`O<<KqO!&zQMhO<<KqO$+YQ`O<<KpO';nQMjOANDcO';xQ!0MvO<<KtOOQO7+*r7+*rO9kQ`O7+*rO'<YQ`O<= qOOQ[G27rG27rO9uQ!0LrOG27rO@zQ`OG27rO!)[QlO1G5SO'<bQ`O7+,SO'<jQ`O1G2kO&=UQ`OANBQOOQ[ANBQANBQO!&zQMhOANBQO'<oQ`OANBQOOQ[ANBSANBSO9uQ!0LrOANBSO$%dQ`OANBSOOQO'#H_'#H_OOQO7+*q7+*qOOQ[G22wG22wOOQ[ANE^ANE^OOQ[ANE_ANE_OOQ[ANB]ANB]O'<wQ`OANB]OOQ[<<MW<<MWO!)[QlOAN?lOOQOG24yG24yO$AlQ!0MxOG24yO#(ZQ`OLD,qOOQ[LD,qLD,qO!&zQMhOLD,qO'<|Q!fOLD,qO'=TQ?MvO7+'zO'>yQ?MvO,5?aO'@|Q?MvO,5?cO'CPQ?MvO7+'|O'DuQMjOG27TOOQO<<M}<<M}OOQ!0LbANA]ANA]O$+YQ`OANA]OCwQ`OANA]O'EVQ!dOANA]OOQ!0LbANAZANAZO'E^Q`OANA]O!&zQMhOANA]O'EiQ!dOANA]OOQ!0LbANA[ANA[OOQO<<N^<<N^OOQ[LD-^LD-^O9uQ!0LrOLD-^O'EsQ?MtO7+*nOOQO'#Gf'#GfOOQ[G27lG27lO&=UQ`OG27lO!&zQMhOG27lOOQ[G27nG27nO9uQ!0LrOG27nOOQ[G27wG27wO'E}Q?MtOG25WOOQOLD*eLD*eOOQ[!$(!]!$(!]O#(ZQ`O!$(!]O!&zQMhO!$(!]O'FXQ!0MzOG27TOOQ!0LbG26wG26wO$+YQ`OG26wO'HjQ`OG26wOCwQ`OG26wO'HuQ!dOG26wO!&zQMhOG26wOOQ[!$(!x!$(!xOOQ[LD-WLD-WO&=UQ`OLD-WOOQ[LD-YLD-YOOQ[!)9Ew!)9EwO#(ZQ`O!)9EwOOQ!0LbLD,cLD,cO$+YQ`OLD,cOCwQ`OLD,cO'H|Q`OLD,cO'IXQ!dOLD,cOOQ[!$(!r!$(!rOOQ[!.K;c!.K;cO'I`Q?MvOG27TOOQ!0Lb!$( }!$( }O$+YQ`O!$( }OCwQ`O!$( }O'KUQ`O!$( }OOQ!0Lb!)9Ei!)9EiO$+YQ`O!)9EiOCwQ`O!)9EiOOQ!0Lb!.K;T!.K;TO$+YQ`O!.K;TOOQ!0Lb!4/0o!4/0oO!)[QlO'#DzO1PQ`O'#EXO'KaQ!fO'#JrO'KhQ!L^O'#DvO'KoQlO'#EOO'KvQ!fO'#CiO'N^Q!fO'#CiO!)[QlO'#EQO'NnQlO,5;ZO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO'#IpO(!qQ`O,5<iO!)[QlO,5;eO(!yQMhO,5;eO($dQMhO,5;eO!)[QlO,5;wO!&zQMhO'#GmO(!yQMhO'#GmO!&zQMhO'#GoO(!yQMhO'#GoO1SQ`O'#DZO1SQ`O'#DZO!&zQMhO'#GPO(!yQMhO'#GPO!&zQMhO'#GRO(!yQMhO'#GRO!&zQMhO'#GaO(!yQMhO'#GaO!)[QlO,5:jO($kQpO'#D_O($uQpO'#JvO!)[QlO,5@oO'NnQlO1G0uO(%PQ?MtO'#CiO!)[QlO1G2PO!&zQMhO'#IuO(!yQMhO'#IuO!&zQMhO'#IwO(!yQMhO'#IwO(%ZQ!dO'#CrO!&zQMhO,5<tO(!yQMhO,5<tO'NnQlO1G2RO!)[QlO7+&zO!&zQMhO1G2`O(!yQMhO1G2`O!&zQMhO'#IuO(!yQMhO'#IuO!&zQMhO'#IwO(!yQMhO'#IwO!&zQMhO1G2bO(!yQMhO1G2bO'NnQlO7+'mO'NnQlO7+&aO!&zQMhOANAiO(!yQMhOANAiO(%nQ`O'#EoO(%sQ`O'#EoO(%{Q`O'#F]O(&QQ`O'#EyO(&VQ`O'#KTO(&bQ`O'#KRO(&mQ`O,5;ZO(&rQMjO,5<eO(&yQ`O'#GYO('OQ`O'#GYO('TQ`O,5<eO(']Q`O,5<gO('eQ`O,5;ZO('mQ?MtO1G1`O('tQ`O,5<tO('yQ`O,5<tO((OQ`O,5<vO((TQ`O,5<vO((YQ`O1G2RO((_Q`O1G0uO((dQMjO<<K}O((kQMjO<<K}O((rQMhO'#F|O9`Q`O'#F{OAuQ`O'#EnO!)[QlO,5;tO!3oQ`O'#GYO!3oQ`O'#GYO!3oQ`O'#G[O!3oQ`O'#G[O!,TQMhO7+(cO!,TQMhO7+(cO%.zQ!dO1G2wO%.zQ!dO1G2wO!&zQMhO,5=]O!&zQMhO,5=]",
      stateData: "()x~O'|OS'}OSTOS(ORQ~OPYOQYOSfOY!VOaqOdzOeyOl!POpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O$W|O$niO%h}O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO&W!WO&^!XO&`!YO&b!ZO&d![O&g!]O&m!^O&s!_O&u!`O&w!aO&y!bO&{!cO(TSO(VTO(YUO(aVO(o[O~OWtO~P`OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa!wOs!nO!S!oO!b!yO!c!vO!d!vO!|<VO#T!pO#U!pO#V!xO#W!pO#X!pO#[!zO#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O(O!{O~OP]XR]X[]Xa]Xj]Xr]X!Q]X!S]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X'z]X(a]X(r]X(y]X(z]X~O!g%RX~P(qO_!}O(V#PO(W!}O(X#PO~O_#QO(X#PO(Y#PO(Z#QO~Ox#SO!U#TO(b#TO(c#VO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T<ZO(VTO(YUO(aVO(o[O~O![#ZO!]#WO!Y(hP!Y(vP~P+}O!^#cO~P`OPYOQYOSfOd!jOe!iOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(VTO(YUO(aVO(o[O~Op#mO![#iO!|]O#i#lO#j#iO(T<[O!k(sP~P.iO!l#oO(T#nO~O!x#sO!|]O%h#tO~O#k#uO~O!g#vO#k#uO~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!]$_O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa(fX'z(fX'w(fX!k(fX!Y(fX!_(fX%i(fX!g(fX~P1qO#S$dO#`$eO$Q$eOP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX!_(gX%i(gX~Oa(gX'z(gX'w(gX!Y(gX!k(gXv(gX!g(gX~P4UO#`$eO~O$]$hO$_$gO$f$mO~OSfO!_$nO$i$oO$k$qO~Oh%VOj%dOk%dOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T$sO(VTO(YUO(a$uO(y$}O(z%POg(^P~Ol%[O~P7eO!l%eO~O!S%hO!_%iO(T%gO~O!g%mO~Oa%nO'z%nO~O!Q%rO~P%[O(U!lO~P%[O%n%vO~P%[Oh%VO!l%eO(T%gO(U!lO~Oe%}O!l%eO(T%gO~Oj$RO~O!_&PO(T%gO(U!lO(VTO(YUO`)WP~O!Q&SO!l&RO%j&VO&T&WO~P;SO!x#sO~O%s&YO!S)SX!_)SX(T)SX~O(T&ZO~Ol!PO!u&`O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO~Od&eOe&dO!x&bO%h&cO%{&aO~P<bOd&hOeyOl!PO!_&gO!u&`O!xxO!|]O%h}O%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO~Ob&kO#`&nO%j&iO(U!lO~P=gO!l&oO!u&sO~O!l#oO~O!_XO~Oa%nO'x&{O'z%nO~Oa%nO'x'OO'z%nO~Oa%nO'x'QO'z%nO~O'w]X!Y]Xv]X!k]X&[]X!_]X%i]X!g]X~P(qO!b'_O!c'WO!d'WO(U!lO(VTO(YUO~Os'UO!S'TO!['XO(e'SO!^(iP!^(xP~P@nOn'bO!_'`O(T%gO~Oe'gO!l%eO(T%gO~O!Q&SO!l&RO~Os!nO!S!oO!|<VO#T!pO#U!pO#W!pO#X!pO(U!lO(VTO(YUO(e!mO(o!sO~O!b'mO!c'lO!d'lO#V!pO#['nO#]'nO~PBYOa%nOh%VO!g#vO!l%eO'z%nO(r'pO~O!p'tO#`'rO~PChOs!nO!S!oO(VTO(YUO(e!mO(o!sO~O!_XOs(mX!S(mX!b(mX!c(mX!d(mX!|(mX#T(mX#U(mX#V(mX#W(mX#X(mX#[(mX#](mX(U(mX(V(mX(Y(mX(e(mX(o(mX~O!c'lO!d'lO(U!lO~PDWO(P'xO(Q'xO(R'zO~O_!}O(V'|O(W!}O(X'|O~O_#QO(X'|O(Y'|O(Z#QO~Ov(OO~P%[Ox#SO!U#TO(b#TO(c(RO~O![(TO!Y'WX!Y'^X!]'WX!]'^X~P+}O!](VO!Y(hX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!](VO!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~O!Y(hX~PHRO!Y([O~O!Y(uX!](uX!g(uX!k(uX(r(uX~O#`(uX#k#dX!^(uX~PJUO#`(]O!Y(wX!](wX~O!](^O!Y(vX~O!Y(aO~O#`$eO~PJUO!^(bO~P`OR#zO!Q#yO!S#{O!l#xO(aVOP!na[!naj!nar!na!]!na!p!na#R!na#n!na#o!na#p!na#q!na#r!na#s!na#t!na#u!na#v!na#x!na#z!na#{!na(r!na(y!na(z!na~Oa!na'z!na'w!na!Y!na!k!nav!na!_!na%i!na!g!na~PKlO!k(cO~O!g#vO#`(dO(r'pO!](tXa(tX'z(tX~O!k(tX~PNXO!S%hO!_%iO!|]O#i(iO#j(hO(T%gO~O!](jO!k(sX~O!k(lO~O!S%hO!_%iO#j(hO(T%gO~OP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~O!g#vO!k(gX~P! uOR(nO!Q(mO!l#xO#S$dO!|!{a!S!{a~O!x!{a%h!{a!_!{a#i!{a#j!{a(T!{a~P!#vO!x(rO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~O#k(xO~O![(zO!k(kP~P%[O(e(|O(o[O~O!S)OO!l#xO(e(|O(o[O~OP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_!eO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(T)]O(VTO(YUO(aVO(o[O~O!]$_Oa$qa'z$qa'w$qa!k$qa!Y$qa!_$qa%i$qa!g$qa~Ol)dO~P!&zOh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Og(pP~P!,TO!Q)iO!g)hO!_$^X$Z$^X$]$^X$_$^X$f$^X~O!g)hO!_({X$Z({X$]({X$_({X$f({X~O!Q)iO~P!.^O!Q)iO!_({X$Z({X$]({X$_({X$f({X~O!_)kO$Z)oO$])jO$_)jO$f)pO~O![)sO~P!)[O$]$hO$_$gO$f)wO~On$zX!Q$zX#S$zX'y$zX(y$zX(z$zX~OgmXg$zXnmX!]mX#`mX~P!0SOx)yO(b)zO(c)|O~On*VO!Q*OO'y*PO(y$}O(z%PO~Og)}O~P!1WOg*WO~Oh%VOr%XOs$tOt$tOz%YO|%ZO!O<sO!S*YO!_*ZO!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op*`O![*^O(T*XO!k)OP~P!1uO#k*aO~O!l*bO~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(T*dO(VTO(YUO(a$uO(y$}O(z%PO~O![*gO!Y)PP~P!3tOr*sOs!nO!S*iO!b*qO!c*kO!d*kO!l*bO#[*rO%`*mO(U!lO(VTO(YUO(e!mO~O!^*pO~P!5iO#S$dOn(`X!Q(`X'y(`X(y(`X(z(`X!](`X#`(`X~Og(`X$O(`X~P!6kOn*xO#`*wOg(_X!](_X~O!]*yOg(^X~Oj%dOk%dOl%dO(T&ZOg(^P~Os*|O~Og)}O(T&ZO~O!l+SO~O(T(vO~Op+WO!S%hO![#iO!_%iO!|]O#i#lO#j#iO(T%gO!k(sP~O!g#vO#k+XO~O!S%hO![+ZO!](^O!_%iO(T%gO!Y(vP~Os'[O!S+]O![+[O(VTO(YUO(e(|O~O!^(xP~P!9|O!]+^Oa)TX'z)TX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa!ja!]!ja'z!ja'w!ja!Y!ja!k!jav!ja!_!ja%i!ja!g!ja~P!:tOR#zO!Q#yO!S#{O!l#xO(aVOP!ra[!raj!rar!ra!]!ra!p!ra#R!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#v!ra#x!ra#z!ra#{!ra(r!ra(y!ra(z!ra~Oa!ra'z!ra'w!ra!Y!ra!k!rav!ra!_!ra%i!ra!g!ra~P!=[OR#zO!Q#yO!S#{O!l#xO(aVOP!ta[!taj!tar!ta!]!ta!p!ta#R!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#t!ta#u!ta#v!ta#x!ta#z!ta#{!ta(r!ta(y!ta(z!ta~Oa!ta'z!ta'w!ta!Y!ta!k!tav!ta!_!ta%i!ta!g!ta~P!?rOh%VOn+gO!_'`O%i+fO~O!g+iOa(]X!_(]X'z(]X!](]X~Oa%nO!_XO'z%nO~Oh%VO!l%eO~Oh%VO!l%eO(T%gO~O!g#vO#k(xO~Ob+tO%j+uO(T+qO(VTO(YUO!^)XP~O!]+vO`)WX~O[+zO~O`+{O~O!_&PO(T%gO(U!lO`)WP~O%j,OO~P;SOh%VO#`,SO~Oh%VOn,VO!_$|O~O!_,XO~O!Q,ZO!_XO~O%n%vO~O!x,`O~Oe,eO~Ob,fO(T#nO(VTO(YUO!^)VP~Oe%}O~O%j!QO(T&ZO~P=gO[,kO`,jO~OPYOQYOSfOdzOeyOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!iuO!lZO!oYO!pYO!qYO!svO!xxO!|]O$niO%h}O(VTO(YUO(aVO(o[O~O!_!eO!u!gO$W!kO(T!dO~P!FyO`,jOa%nO'z%nO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa,pOl!OO!uwO%l!OO%m!OO%n!OO~P!IcO!l&oO~O&^,vO~O!_,xO~O&o,zO&q,{OP&laQ&laS&laY&laa&lad&lae&lal&lap&lar&las&lat&laz&la|&la!O&la!S&la!W&la!X&la!_&la!i&la!l&la!o&la!p&la!q&la!s&la!u&la!x&la!|&la$W&la$n&la%h&la%j&la%l&la%m&la%n&la%q&la%s&la%v&la%w&la%y&la&W&la&^&la&`&la&b&la&d&la&g&la&m&la&s&la&u&la&w&la&y&la&{&la'w&la(T&la(V&la(Y&la(a&la(o&la!^&la&e&lab&la&j&la~O(T-QO~Oh!eX!]!RX!^!RX!g!RX!g!eX!l!eX#`!RX~O!]!eX!^!eX~P#!iO!g-VO#`-UOh(jX!]#hX!^#hX!g(jX!l(jX~O!](jX!^(jX~P##[Oh%VO!g-XO!l%eO!]!aX!^!aX~Os!nO!S!oO(VTO(YUO(e!mO~OP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_!eO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(VTO(YUO(aVO(o[O~O(T=QO~P#$qO!]-]O!^(iX~O!^-_O~O!g-VO#`-UO!]#hX!^#hX~O!]-`O!^(xX~O!^-bO~O!c-cO!d-cO(U!lO~P#$`O!^-fO~P'_On-iO!_'`O~O!Y-nO~Os!{a!b!{a!c!{a!d!{a#T!{a#U!{a#V!{a#W!{a#X!{a#[!{a#]!{a(U!{a(V!{a(Y!{a(e!{a(o!{a~P!#vO!p-sO#`-qO~PChO!c-uO!d-uO(U!lO~PDWOa%nO#`-qO'z%nO~Oa%nO!g#vO#`-qO'z%nO~Oa%nO!g#vO!p-sO#`-qO'z%nO(r'pO~O(P'xO(Q'xO(R-zO~Ov-{O~O!Y'Wa!]'Wa~P!:tO![.PO!Y'WX!]'WX~P%[O!](VO!Y(ha~O!Y(ha~PHRO!](^O!Y(va~O!S%hO![.TO!_%iO(T%gO!Y'^X!]'^X~O#`.VO!](ta!k(taa(ta'z(ta~O!g#vO~P#,wO!](jO!k(sa~O!S%hO!_%iO#j.ZO(T%gO~Op.`O!S%hO![.]O!_%iO!|]O#i._O#j.]O(T%gO!]'aX!k'aX~OR.dO!l#xO~Oh%VOn.gO!_'`O%i.fO~Oa#ci!]#ci'z#ci'w#ci!Y#ci!k#civ#ci!_#ci%i#ci!g#ci~P!:tOn>]O!Q*OO'y*PO(y$}O(z%PO~O#k#_aa#_a#`#_a'z#_a!]#_a!k#_a!_#_a!Y#_a~P#/sO#k(`XP(`XR(`X[(`Xa(`Xj(`Xr(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X'z(`X(a(`X(r(`X!k(`X!Y(`X'w(`Xv(`X!_(`X%i(`X!g(`X~P!6kO!].tO!k(kX~P!:tO!k.wO~O!Y.yO~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mia#mij#mir#mi!]#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#n#mi~P#3cO#n$OO~P#3cOP$[OR#zOr$aO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO[#mia#mij#mi!]#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#r#mi~P#6QO#r$QO~P#6QOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO(aVOa#mi!]#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#v#mi~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO(aVO(z#}Oa#mi!]#mi#z#mi#{#mi'z#mi(r#mi(y#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#x$UO~P#;VO#x#mi~P#;VO#v$SO~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO(aVO(y#|O(z#}Oa#mi!]#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#z#mi~P#={O#z$WO~P#={OP]XR]X[]Xj]Xr]X!Q]X!S]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X!]]X!^]X~O$O]X~P#@jOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO#x<eO#z<gO#{<hO(aVO(r$YO(y#|O(z#}O~O$O.{O~P#BwO#S$dO#`<nO$Q<nO$O(gX!^(gX~P! uOa'da!]'da'z'da'w'da!k'da!Y'dav'da!_'da%i'da!g'da~P!:tO[#mia#mij#mir#mi!]#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO(y#mi(z#mi~P#EyOn>]O!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P#EyO!]/POg(pX~P!1WOg/RO~Oa$Pi!]$Pi'z$Pi'w$Pi!Y$Pi!k$Piv$Pi!_$Pi%i$Pi!g$Pi~P!:tO$]/SO$_/SO~O$]/TO$_/TO~O!g)hO#`/UO!_$cX$Z$cX$]$cX$_$cX$f$cX~O![/VO~O!_)kO$Z/XO$])jO$_)jO$f/YO~O!]<iO!^(fX~P#BwO!^/ZO~O!g)hO$f({X~O$f/]O~Ov/^O~P!&zOx)yO(b)zO(c/aO~O!S/dO~O(y$}On%aa!Q%aa'y%aa(z%aa!]%aa#`%aa~Og%aa$O%aa~P#L{O(z%POn%ca!Q%ca'y%ca(y%ca!]%ca#`%ca~Og%ca$O%ca~P#MnO!]fX!gfX!kfX!k$zX(rfX~P!0SOp%WO![/mO!](^O(T/lO!Y(vP!Y)PP~P!1uOr*sO!b*qO!c*kO!d*kO!l*bO#[*rO%`*mO(U!lO(VTO(YUO~Os<}O!S/nO![+[O!^*pO(e<|O!^(xP~P$ [O!k/oO~P#/sO!]/pO!g#vO(r'pO!k)OX~O!k/uO~OnoX!QoX'yoX(yoX(zoX~O!g#vO!koX~P$#OOp/wO!S%hO![*^O!_%iO(T%gO!k)OP~O#k/xO~O!Y$zX!]$zX!g%RX~P!0SO!]/yO!Y)PX~P#/sO!g/{O~O!Y/}O~OpkO(T0OO~P.iOh%VOr0TO!g#vO!l%eO(r'pO~O!g+iO~Oa%nO!]0XO'z%nO~O!^0ZO~P!5iO!c0[O!d0[O(U!lO~P#$`Os!nO!S0]O(VTO(YUO(e!mO~O#[0_O~Og%aa!]%aa#`%aa$O%aa~P!1WOg%ca!]%ca#`%ca$O%ca~P!1WOj%dOk%dOl%dO(T&ZOg'mX!]'mX~O!]*yOg(^a~Og0hO~On0jO#`0iOg(_a!](_a~OR0kO!Q0kO!S0lO#S$dOn}a'y}a(y}a(z}a!]}a#`}a~Og}a$O}a~P$(cO!Q*OO'y*POn$sa(y$sa(z$sa!]$sa#`$sa~Og$sa$O$sa~P$)_O!Q*OO'y*POn$ua(y$ua(z$ua!]$ua#`$ua~Og$ua$O$ua~P$*QO#k0oO~Og%Ta!]%Ta#`%Ta$O%Ta~P!1WO!g#vO~O#k0rO~O!]+^Oa)Ta'z)Ta~OR#zO!Q#yO!S#{O!l#xO(aVOP!ri[!rij!rir!ri!]!ri!p!ri#R!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#t!ri#u!ri#v!ri#x!ri#z!ri#{!ri(r!ri(y!ri(z!ri~Oa!ri'z!ri'w!ri!Y!ri!k!riv!ri!_!ri%i!ri!g!ri~P$+oOh%VOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op0{O%]0|O(T0zO~P$.VO!g+iOa(]a!_(]a'z(]a!](]a~O#k1SO~O[]X!]fX!^fX~O!]1TO!^)XX~O!^1VO~O[1WO~Ob1YO(T+qO(VTO(YUO~O!_&PO(T%gO`'uX!]'uX~O!]+vO`)Wa~O!k1]O~P!:tO[1`O~O`1aO~O#`1fO~On1iO!_$|O~O(e(|O!^)UP~Oh%VOn1rO!_1oO%i1qO~O[1|O!]1zO!^)VX~O!^1}O~O`2POa%nO'z%nO~O(T#nO(VTO(YUO~O#S$dO#`$eO$Q$eOP(gXR(gX[(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~Oj2SO&[2TOa(gX~P$3pOj2SO#`$eO&[2TO~Oa2VO~P%[Oa2XO~O&e2[OP&ciQ&ciS&ciY&cia&cid&cie&cil&cip&cir&cis&cit&ciz&ci|&ci!O&ci!S&ci!W&ci!X&ci!_&ci!i&ci!l&ci!o&ci!p&ci!q&ci!s&ci!u&ci!x&ci!|&ci$W&ci$n&ci%h&ci%j&ci%l&ci%m&ci%n&ci%q&ci%s&ci%v&ci%w&ci%y&ci&W&ci&^&ci&`&ci&b&ci&d&ci&g&ci&m&ci&s&ci&u&ci&w&ci&y&ci&{&ci'w&ci(T&ci(V&ci(Y&ci(a&ci(o&ci!^&cib&ci&j&ci~Ob2bO!^2`O&j2aO~P`O!_XO!l2dO~O&q,{OP&liQ&liS&liY&lia&lid&lie&lil&lip&lir&lis&lit&liz&li|&li!O&li!S&li!W&li!X&li!_&li!i&li!l&li!o&li!p&li!q&li!s&li!u&li!x&li!|&li$W&li$n&li%h&li%j&li%l&li%m&li%n&li%q&li%s&li%v&li%w&li%y&li&W&li&^&li&`&li&b&li&d&li&g&li&m&li&s&li&u&li&w&li&y&li&{&li'w&li(T&li(V&li(Y&li(a&li(o&li!^&li&e&lib&li&j&li~O!Y2jO~O!]!aa!^!aa~P#BwOs!nO!S!oO![2pO(e!mO!]'XX!^'XX~P@nO!]-]O!^(ia~O!]'_X!^'_X~P!9|O!]-`O!^(xa~O!^2wO~P'_Oa%nO#`3QO'z%nO~Oa%nO!g#vO#`3QO'z%nO~Oa%nO!g#vO!p3UO#`3QO'z%nO(r'pO~Oa%nO'z%nO~P!:tO!]$_Ov$qa~O!Y'Wi!]'Wi~P!:tO!](VO!Y(hi~O!](^O!Y(vi~O!Y(wi!](wi~P!:tO!](ti!k(tia(ti'z(ti~P!:tO#`3WO!](ti!k(tia(ti'z(ti~O!](jO!k(si~O!S%hO!_%iO!|]O#i3]O#j3[O(T%gO~O!S%hO!_%iO#j3[O(T%gO~On3dO!_'`O%i3cO~Oh%VOn3dO!_'`O%i3cO~O#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aav%aa!_%aa%i%aa!g%aa~P#L{O#k%caP%caR%ca[%caa%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%cav%ca!_%ca%i%ca!g%ca~P#MnO#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!]%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aa#`%aav%aa!_%aa%i%aa!g%aa~P#/sO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!]%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%ca#`%cav%ca!_%ca%i%ca!g%ca~P#/sO#k}aP}a[}aa}aj}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a'z}a(a}a(r}a!k}a!Y}a'w}av}a!_}a%i}a!g}a~P$(cO#k$saP$saR$sa[$saa$saj$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa'z$sa(a$sa(r$sa!k$sa!Y$sa'w$sav$sa!_$sa%i$sa!g$sa~P$)_O#k$uaP$uaR$ua[$uaa$uaj$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua'z$ua(a$ua(r$ua!k$ua!Y$ua'w$uav$ua!_$ua%i$ua!g$ua~P$*QO#k%TaP%TaR%Ta[%Taa%Taj%Tar%Ta!S%Ta!]%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta'z%Ta(a%Ta(r%Ta!k%Ta!Y%Ta'w%Ta#`%Tav%Ta!_%Ta%i%Ta!g%Ta~P#/sOa#cq!]#cq'z#cq'w#cq!Y#cq!k#cqv#cq!_#cq%i#cq!g#cq~P!:tO![3lO!]'YX!k'YX~P%[O!].tO!k(ka~O!].tO!k(ka~P!:tO!Y3oO~O$O!na!^!na~PKlO$O!ja!]!ja!^!ja~P#BwO$O!ra!^!ra~P!=[O$O!ta!^!ta~P!?rOg']X!]']X~P!,TO!]/POg(pa~OSfO!_4TO$d4UO~O!^4YO~Ov4ZO~P#/sOa$mq!]$mq'z$mq'w$mq!Y$mq!k$mqv$mq!_$mq%i$mq!g$mq~P!:tO!Y4]O~P!&zO!S4^O~O!Q*OO'y*PO(z%POn'ia(y'ia!]'ia#`'ia~Og'ia$O'ia~P%-fO!Q*OO'y*POn'ka(y'ka(z'ka!]'ka#`'ka~Og'ka$O'ka~P%.XO(r$YO~P#/sO!YfX!Y$zX!]fX!]$zX!g%RX#`fX~P!0SOp%WO(T=WO~P!1uOp4bO!S%hO![4aO!_%iO(T%gO!]'eX!k'eX~O!]/pO!k)Oa~O!]/pO!g#vO!k)Oa~O!]/pO!g#vO(r'pO!k)Oa~Og$|i!]$|i#`$|i$O$|i~P!1WO![4jO!Y'gX!]'gX~P!3tO!]/yO!Y)Pa~O!]/yO!Y)Pa~P#/sOP]XR]X[]Xj]Xr]X!Q]X!S]X!Y]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~Oj%YX!g%YX~P%2OOj4oO!g#vO~Oh%VO!g#vO!l%eO~Oh%VOr4tO!l%eO(r'pO~Or4yO!g#vO(r'pO~Os!nO!S4zO(VTO(YUO(e!mO~O(y$}On%ai!Q%ai'y%ai(z%ai!]%ai#`%ai~Og%ai$O%ai~P%5oO(z%POn%ci!Q%ci'y%ci(y%ci!]%ci#`%ci~Og%ci$O%ci~P%6bOg(_i!](_i~P!1WO#`5QOg(_i!](_i~P!1WO!k5VO~Oa$oq!]$oq'z$oq'w$oq!Y$oq!k$oqv$oq!_$oq%i$oq!g$oq~P!:tO!Y5ZO~O!]5[O!_)QX~P#/sOa$zX!_$zX%^]X'z$zX!]$zX~P!0SO%^5_OaoX!_oX'zoX!]oX~P$#OOp5`O(T#nO~O%^5_O~Ob5fO%j5gO(T+qO(VTO(YUO!]'tX!^'tX~O!]1TO!^)Xa~O[5kO~O`5lO~O[5pO~Oa%nO'z%nO~P#/sO!]5uO#`5wO!^)UX~O!^5xO~Or6OOs!nO!S*iO!b!yO!c!vO!d!vO!|<VO#T!pO#U!pO#V!pO#W!pO#X!pO#[5}O#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O!^5|O~P%;eOn6TO!_1oO%i6SO~Oh%VOn6TO!_1oO%i6SO~Ob6[O(T#nO(VTO(YUO!]'sX!^'sX~O!]1zO!^)Va~O(VTO(YUO(e6^O~O`6bO~Oj6eO&[6fO~PNXO!k6gO~P%[Oa6iO~Oa6iO~P%[Ob2bO!^6nO&j2aO~P`O!g6pO~O!g6rOh(ji!](ji!^(ji!g(ji!l(jir(ji(r(ji~O!]#hi!^#hi~P#BwO#`6sO!]#hi!^#hi~O!]!ai!^!ai~P#BwOa%nO#`6|O'z%nO~Oa%nO!g#vO#`6|O'z%nO~O!](tq!k(tqa(tq'z(tq~P!:tO!](jO!k(sq~O!S%hO!_%iO#j7TO(T%gO~O!_'`O%i7WO~On7[O!_'`O%i7WO~O#k'iaP'iaR'ia['iaa'iaj'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia'z'ia(a'ia(r'ia!k'ia!Y'ia'w'iav'ia!_'ia%i'ia!g'ia~P%-fO#k'kaP'kaR'ka['kaa'kaj'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka'z'ka(a'ka(r'ka!k'ka!Y'ka'w'kav'ka!_'ka%i'ka!g'ka~P%.XO#k$|iP$|iR$|i[$|ia$|ij$|ir$|i!S$|i!]$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i'z$|i(a$|i(r$|i!k$|i!Y$|i'w$|i#`$|iv$|i!_$|i%i$|i!g$|i~P#/sO#k%aiP%aiR%ai[%aia%aij%air%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai'z%ai(a%ai(r%ai!k%ai!Y%ai'w%aiv%ai!_%ai%i%ai!g%ai~P%5oO#k%ciP%ciR%ci[%cia%cij%cir%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci'z%ci(a%ci(r%ci!k%ci!Y%ci'w%civ%ci!_%ci%i%ci!g%ci~P%6bO!]'Ya!k'Ya~P!:tO!].tO!k(ki~O$O#ci!]#ci!^#ci~P#BwOP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mij#mir#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#n#mi~P%NdO#n<_O~P%NdOP$[OR#zOr<kO!Q#yO!S#{O!l#xO!p$[O#n<_O#o<`O#p<`O#q<`O(aVO[#mij#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#r#mi~P&!lO#r<aO~P&!lOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO(aVO#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#v#mi~P&$tOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO(aVO(z#}O#z#mi#{#mi$O#mi(r#mi(y#mi!]#mi!^#mi~O#x<eO~P&&uO#x#mi~P&&uO#v<cO~P&$tOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO#x<eO(aVO(y#|O(z#}O#{#mi$O#mi(r#mi!]#mi!^#mi~O#z#mi~P&)UO#z<gO~P&)UOa#|y!]#|y'z#|y'w#|y!Y#|y!k#|yv#|y!_#|y%i#|y!g#|y~P!:tO[#mij#mir#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi!]#mi!^#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n<_O#o<`O#p<`O#q<`O(aVO(y#mi(z#mi~P&,QOn>^O!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P&,QO#S$dOP(`XR(`X[(`Xj(`Xn(`Xr(`X!Q(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X$O(`X'y(`X(a(`X(r(`X(y(`X(z(`X!](`X!^(`X~O$O$Pi!]$Pi!^$Pi~P#BwO$O!ri!^!ri~P$+oOg']a!]']a~P!1WO!^7nO~O!]'da!^'da~P#BwO!Y7oO~P#/sO!g#vO(r'pO!]'ea!k'ea~O!]/pO!k)Oi~O!]/pO!g#vO!k)Oi~Og$|q!]$|q#`$|q$O$|q~P!1WO!Y'ga!]'ga~P#/sO!g7vO~O!]/yO!Y)Pi~P#/sO!]/yO!Y)Pi~O!Y7yO~Oh%VOr8OO!l%eO(r'pO~Oj8QO!g#vO~Or8TO!g#vO(r'pO~O!Q*OO'y*PO(z%POn'ja(y'ja!]'ja#`'ja~Og'ja$O'ja~P&5RO!Q*OO'y*POn'la(y'la(z'la!]'la#`'la~Og'la$O'la~P&5tOg(_q!](_q~P!1WO#`8VOg(_q!](_q~P!1WO!Y8WO~Og%Oq!]%Oq#`%Oq$O%Oq~P!1WOa$oy!]$oy'z$oy'w$oy!Y$oy!k$oyv$oy!_$oy%i$oy!g$oy~P!:tO!g6rO~O!]5[O!_)Qa~O!_'`OP$TaR$Ta[$Taj$Tar$Ta!Q$Ta!S$Ta!]$Ta!l$Ta!p$Ta#R$Ta#n$Ta#o$Ta#p$Ta#q$Ta#r$Ta#s$Ta#t$Ta#u$Ta#v$Ta#x$Ta#z$Ta#{$Ta(a$Ta(r$Ta(y$Ta(z$Ta~O%i7WO~P&8fO%^8[Oa%[i!_%[i'z%[i!]%[i~Oa#cy!]#cy'z#cy'w#cy!Y#cy!k#cyv#cy!_#cy%i#cy!g#cy~P!:tO[8^O~Ob8`O(T+qO(VTO(YUO~O!]1TO!^)Xi~O`8dO~O(e(|O!]'pX!^'pX~O!]5uO!^)Ua~O!^8nO~P%;eO(o!sO~P$&YO#[8oO~O!_1oO~O!_1oO%i8qO~On8tO!_1oO%i8qO~O[8yO!]'sa!^'sa~O!]1zO!^)Vi~O!k8}O~O!k9OO~O!k9RO~O!k9RO~P%[Oa9TO~O!g9UO~O!k9VO~O!](wi!^(wi~P#BwOa%nO#`9_O'z%nO~O!](ty!k(tya(ty'z(ty~P!:tO!](jO!k(sy~O%i9bO~P&8fO!_'`O%i9bO~O#k$|qP$|qR$|q[$|qa$|qj$|qr$|q!S$|q!]$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q'z$|q(a$|q(r$|q!k$|q!Y$|q'w$|q#`$|qv$|q!_$|q%i$|q!g$|q~P#/sO#k'jaP'jaR'ja['jaa'jaj'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja'z'ja(a'ja(r'ja!k'ja!Y'ja'w'jav'ja!_'ja%i'ja!g'ja~P&5RO#k'laP'laR'la['laa'laj'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la'z'la(a'la(r'la!k'la!Y'la'w'lav'la!_'la%i'la!g'la~P&5tO#k%OqP%OqR%Oq[%Oqa%Oqj%Oqr%Oq!S%Oq!]%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq'z%Oq(a%Oq(r%Oq!k%Oq!Y%Oq'w%Oq#`%Oqv%Oq!_%Oq%i%Oq!g%Oq~P#/sO!]'Yi!k'Yi~P!:tO$O#cq!]#cq!^#cq~P#BwO(y$}OP%aaR%aa[%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa$O%aa(a%aa(r%aa!]%aa!^%aa~On%aa!Q%aa'y%aa(z%aa~P&IyO(z%POP%caR%ca[%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca$O%ca(a%ca(r%ca!]%ca!^%ca~On%ca!Q%ca'y%ca(y%ca~P&LQOn>^O!Q*OO'y*PO(z%PO~P&IyOn>^O!Q*OO'y*PO(y$}O~P&LQOR0kO!Q0kO!S0lO#S$dOP}a[}aj}an}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a$O}a'y}a(a}a(r}a(y}a(z}a!]}a!^}a~O!Q*OO'y*POP$saR$sa[$saj$san$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa$O$sa(a$sa(r$sa(y$sa(z$sa!]$sa!^$sa~O!Q*OO'y*POP$uaR$ua[$uaj$uan$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua$O$ua(a$ua(r$ua(y$ua(z$ua!]$ua!^$ua~On>^O!Q*OO'y*PO(y$}O(z%PO~OP%TaR%Ta[%Taj%Tar%Ta!S%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta$O%Ta(a%Ta(r%Ta!]%Ta!^%Ta~P''VO$O$mq!]$mq!^$mq~P#BwO$O$oq!]$oq!^$oq~P#BwO!^9oO~O$O9pO~P!1WO!g#vO!]'ei!k'ei~O!g#vO(r'pO!]'ei!k'ei~O!]/pO!k)Oq~O!Y'gi!]'gi~P#/sO!]/yO!Y)Pq~Or9wO!g#vO(r'pO~O[9yO!Y9xO~P#/sO!Y9xO~Oj:PO!g#vO~Og(_y!](_y~P!1WO!]'na!_'na~P#/sOa%[q!_%[q'z%[q!]%[q~P#/sO[:UO~O!]1TO!^)Xq~O`:YO~O#`:ZO!]'pa!^'pa~O!]5uO!^)Ui~P#BwO!S:]O~O!_1oO%i:`O~O(VTO(YUO(e:eO~O!]1zO!^)Vq~O!k:hO~O!k:iO~O!k:jO~O!k:jO~P%[O#`:mO!]#hy!^#hy~O!]#hy!^#hy~P#BwO%i:rO~P&8fO!_'`O%i:rO~O$O#|y!]#|y!^#|y~P#BwOP$|iR$|i[$|ij$|ir$|i!S$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i$O$|i(a$|i(r$|i!]$|i!^$|i~P''VO!Q*OO'y*PO(z%POP'iaR'ia['iaj'ian'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia$O'ia(a'ia(r'ia(y'ia!]'ia!^'ia~O!Q*OO'y*POP'kaR'ka['kaj'kan'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka$O'ka(a'ka(r'ka(y'ka(z'ka!]'ka!^'ka~O(y$}OP%aiR%ai[%aij%ain%air%ai!Q%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai$O%ai'y%ai(a%ai(r%ai(z%ai!]%ai!^%ai~O(z%POP%ciR%ci[%cij%cin%cir%ci!Q%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci$O%ci'y%ci(a%ci(r%ci(y%ci!]%ci!^%ci~O$O$oy!]$oy!^$oy~P#BwO$O#cy!]#cy!^#cy~P#BwO!g#vO!]'eq!k'eq~O!]/pO!k)Oy~O!Y'gq!]'gq~P#/sOr:|O!g#vO(r'pO~O[;QO!Y;PO~P#/sO!Y;PO~Og(_!R!](_!R~P!1WOa%[y!_%[y'z%[y!]%[y~P#/sO!]1TO!^)Xy~O!]5uO!^)Uq~O(T;XO~O!_1oO%i;[O~O!k;_O~O%i;dO~P&8fOP$|qR$|q[$|qj$|qr$|q!S$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q$O$|q(a$|q(r$|q!]$|q!^$|q~P''VO!Q*OO'y*PO(z%POP'jaR'ja['jaj'jan'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja$O'ja(a'ja(r'ja(y'ja!]'ja!^'ja~O!Q*OO'y*POP'laR'la['laj'lan'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la$O'la(a'la(r'la(y'la(z'la!]'la!^'la~OP%OqR%Oq[%Oqj%Oqr%Oq!S%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq$O%Oq(a%Oq(r%Oq!]%Oq!^%Oq~P''VOg%e!Z!]%e!Z#`%e!Z$O%e!Z~P!1WO!Y;hO~P#/sOr;iO!g#vO(r'pO~O[;kO!Y;hO~P#/sO!]'pq!^'pq~P#BwO!]#h!Z!^#h!Z~P#BwO#k%e!ZP%e!ZR%e!Z[%e!Za%e!Zj%e!Zr%e!Z!S%e!Z!]%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z'z%e!Z(a%e!Z(r%e!Z!k%e!Z!Y%e!Z'w%e!Z#`%e!Zv%e!Z!_%e!Z%i%e!Z!g%e!Z~P#/sOr;tO!g#vO(r'pO~O!Y;uO~P#/sOr;|O!g#vO(r'pO~O!Y;}O~P#/sOP%e!ZR%e!Z[%e!Zj%e!Zr%e!Z!S%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z$O%e!Z(a%e!Z(r%e!Z!]%e!Z!^%e!Z~P''VOr<QO!g#vO(r'pO~Ov(fX~P1qO!Q%rO~P!)[O(U!lO~P!)[O!YfX!]fX#`fX~P%2OOP]XR]X[]Xj]Xr]X!Q]X!S]X!]]X!]fX!l]X!p]X#R]X#S]X#`]X#`fX#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~O!gfX!k]X!kfX(rfX~P'LTOP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_XO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(T)]O(VTO(YUO(aVO(o[O~O!]<iO!^$qa~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<tO!S${O!_$|O!i>WO!l$xO#j<zO$W%`O$t<vO$v<xO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Ol)dO~P(!yOr!eX(r!eX~P#!iOr(jX(r(jX~P##[O!^]X!^fX~P'LTO!YfX!Y$zX!]fX!]$zX#`fX~P!0SO#k<^O~O!g#vO#k<^O~O#`<nO~Oj<bO~O#`=OO!](wX!^(wX~O#`<nO!](uX!^(uX~O#k=PO~Og=RO~P!1WO#k=XO~O#k=YO~Og=RO(T&ZO~O!g#vO#k=ZO~O!g#vO#k=PO~O$O=[O~P#BwO#k=]O~O#k=^O~O#k=cO~O#k=dO~O#k=eO~O#k=fO~O$O=gO~P!1WO$O=hO~P!1WOl=sO~P7eOk#S#T#U#W#X#[#i#j#u$n$t$v$y%]%^%h%i%j%q%s%v%w%y%{~(OT#o!X'|(U#ps#n#qr!Q'}$]'}(T$_(e~",
      goto: "$9Y)]PPPPPP)^PP)aP)rP+W/]PPPP6mPP7TPP=QPPP@tPA^PA^PPPA^PCfPA^PA^PA^PCjPCoPD^PIWPPPI[PPPPI[L_PPPLeMVPI[PI[PP! eI[PPPI[PI[P!#lI[P!'S!(X!(bP!)U!)Y!)U!,gPPPPPPP!-W!(XPP!-h!/YP!2iI[I[!2n!5z!:h!:h!>gPPP!>oI[PPPPPPPPP!BOP!C]PPI[!DnPI[PI[I[I[I[I[PI[!FQP!I[P!LbP!Lf!Lp!Lt!LtP!IXP!Lx!LxP#!OP#!SI[PI[#!Y#%_CjA^PA^PA^A^P#&lA^A^#)OA^#+vA^#.SA^A^#.r#1W#1W#1]#1f#1W#1qPP#1WPA^#2ZA^#6YA^A^6mPPP#:_PPP#:x#:xP#:xP#;`#:xPP#;fP#;]P#;]#;y#;]#<e#<k#<n)aP#<q)aP#<z#<z#<zP)aP)aP)aP)aPP)aP#=Q#=TP#=T)aP#=XP#=[P)aP)aP)aP)aP)aP)a)aPP#=b#=h#=s#=y#>P#>V#>]#>k#>q#>{#?R#?]#?c#?s#?y#@k#@}#AT#AZ#Ai#BO#Cs#DR#DY#Et#FS#Gt#HS#HY#H`#Hf#Hp#Hv#H|#IW#Ij#IpPPPPPPPPPPP#IvPPPPPPP#Jk#Mx$ b$ i$ qPPP$']P$'f$*_$0x$0{$1O$1}$2Q$2X$2aP$2g$2jP$3W$3[$4S$5b$5g$5}PP$6S$6Y$6^$6a$6e$6i$7e$7|$8e$8i$8l$8o$8y$8|$9Q$9UR!|RoqOXst!Z#d%m&r&t&u&w,s,x2[2_Y!vQ'`-e1o5{Q%tvQ%|yQ&T|Q&j!VS'W!e-]Q'f!iS'l!r!yU*k$|*Z*oQ+o%}S+|&V&WQ,d&dQ-c'_Q-m'gQ-u'mQ0[*qQ1b,OQ1y,eR<{<Y%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+],p,s,x-i-q.P.V.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3l4z6T6e6f6i6|8t9T9_S#q]<V!r)_$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SU+P%]<s<tQ+t&PQ,f&gQ,m&oQ0x+gQ0}+iQ1Y+uQ2R,kQ3`.gQ5`0|Q5f1TQ6[1zQ7Y3dQ8`5gR9e7['QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S!S!nQ!r!v!y!z$|'W'_'`'l'm'n*k*o*q*r-]-c-e-u0[0_1o5{5}%[$ti#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^Q&X|Q'U!eS'[%i-`Q+t&PQ,P&WQ,f&gQ0n+SQ1Y+uQ1_+{Q2Q,jQ2R,kQ5f1TQ5o1aQ6[1zQ6_1|Q6`2PQ8`5gQ8c5lQ8|6bQ:X8dQ:f8yQ;V:YR<}*ZrnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_R,h&k&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'b'r(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>R>S[#]WZ#W#Z'X(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*b+Z+[+^,o-V.T.Z.[.]._/m/p2d3[3]4a6r7TQ%wxQ%{yW&Q|&V&W,OQ&_!TQ'c!hQ'e!iQ(q#sS+n%|%}Q+r&PQ,_&bQ,c&dS-l'f'gQ.i(rQ1R+oQ1X+uQ1Z+vQ1^+zQ1t,`S1x,d,eQ2|-mQ5e1TQ5i1WQ5n1`Q6Z1yQ8_5gQ8b5kQ8f5pQ:T8^R;T:U!U$zi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y!^%yy!i!u%{%|%}'V'e'f'g'k'u*j+n+o-Y-l-m-t0R0U1R2u2|3T4r4s4v7}9{Q+h%wQ,T&[Q,W&]Q,b&dQ.h(qQ1s,_U1w,c,d,eQ3e.iQ6U1tS6Y1x1yQ8x6Z#f>T#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^o>U<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hW%Ti%V*y>PS&[!Q&iQ&]!RQ&^!SU*}%[%d=sR,R&Y%]%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^T)z$u){V+P%]<s<tW'[!e%i*Z-`S(}#y#zQ+c%rQ+y&SS.b(m(nQ1j,XQ5T0kR8i5u'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S$i$^c#Y#e%q%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+d+x-Z-x-}.S.U.s.v.z.|.}/O/b0p2k2n3O3V3k3p3q3r3s3t3u3v3w3x3y3z3{3|4P4Q4X5X5c6u6{7Q7a7b7k7l8k9X9]9g9m9n:o;W;`<W=vT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ'Y!eR2q-]!W!nQ!e!r!v!y!z$|'W'_'`'l'm'n*Z*k*o*q*r-]-c-e-u0[0_1o5{5}R1l,ZnqOXst!Z#d%m&r&t&u&w,s,x2[2_Q&y!^Q'v!xS(s#u<^Q+l%zQ,]&_Q,^&aQ-j'dQ-w'oS.r(x=PS0q+X=ZQ1P+mQ1n,[Q2c,zQ2e,{Q2m-WQ2z-kQ2}-oS5Y0r=eQ5a1QS5d1S=fQ6t2oQ6x2{Q6}3SQ8]5bQ9Y6vQ9Z6yQ9^7OR:l9V$d$]c#Y#e%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+d+x-Z-x-}.S.U.s.v.z.}/O/b0p2k2n3O3V3k3p3q3r3s3t3u3v3w3x3y3z3{3|4P4Q4X5X5c6u6{7Q7a7b7k7l8k9X9]9g9m9n:o;W;`<W=vS(o#p'iQ)P#zS+b%q.|S.c(n(pR3^.d'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SS#q]<VQ&t!XQ&u!YQ&w![Q&x!]R2Z,vQ'a!hQ+e%wQ-h'cS.e(q+hQ2x-gW3b.h.i0w0yQ6w2yW7U3_3a3e5^U9a7V7X7ZU:q9c9d9fS;b:p:sQ;p;cR;x;qU!wQ'`-eT5y1o5{!Q_OXZ`st!V!Z#d#h%e%m&i&k&r&t&u&w(j,s,x.[2[2_]!pQ!r'`-e1o5{T#q]<V%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_S(}#y#zS.b(m(n!s=l$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SU$fd)_,mS(p#p'iU*v%R(w4OU0m+O.n7gQ5^0xQ7V3`Q9d7YR:s9em!tQ!r!v!y!z'`'l'm'n-e-u1o5{5}Q't!uS(f#g2US-s'k'wQ/s*]Q0R*jQ3U-vQ4f/tQ4r0TQ4s0UQ4x0^Q7r4`S7}4t4vS8R4y4{Q9r7sQ9v7yQ9{8OQ:Q8TS:{9w9xS;g:|;PS;s;h;iS;{;t;uS<P;|;}R<S<QQ#wbQ's!uS(e#g2US(g#m+WQ+Y%fQ+j%xQ+p&OU-r'k't'wQ.W(fU/r*]*`/wQ0S*jQ0V*lQ1O+kQ1u,aS3R-s-vQ3Z.`S4e/s/tQ4n0PS4q0R0^Q4u0WQ6W1vQ7P3US7q4`4bQ7u4fU7|4r4x4{Q8P4wQ8v6XS9q7r7sQ9u7yQ9}8RQ:O8SQ:c8wQ:y9rS:z9v9xQ;S:QQ;^:dS;f:{;PS;r;g;hS;z;s;uS<O;{;}Q<R<PQ<T<SQ=o=jQ={=tR=|=uV!wQ'`-e%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_S#wz!j!r=i$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SR=o>R%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_Q%fj!^%xy!i!u%{%|%}'V'e'f'g'k'u*j+n+o-Y-l-m-t0R0U1R2u2|3T4r4s4v7}9{S&Oz!jQ+k%yQ,a&dW1v,b,c,d,eU6X1w1x1yS8w6Y6ZQ:d8x!r=j$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ=t>QR=u>R%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_Y#bWZ#W#Z(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*b+Z+[+^,o-V.T.Z.[.]._/m/p2d3[3]4a6r7TQ,n&o!p=k$Z$n)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SR=n'XU']!e%i*ZR2s-`%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+],p,s,x-i-q.P.V.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3l4z6T6e6f6i6|8t9T9_!r)_$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ,m&oQ0x+gQ3`.gQ7Y3dR9e7[!b$Tc#Y%q(S(Y(t(y)Z)[)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<W!P<d)^)q-Z.|2k2n3p3y3z4P4X6u7b7k7l8k9X9g9m9n;W;`=v!f$Vc#Y%q(S(Y(t(y)W)X)Z)[)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<W!T<f)^)q-Z.|2k2n3p3v3w3y3z4P4X6u7b7k7l8k9X9g9m9n;W;`=v!^$Zc#Y%q(S(Y(t(y)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<WQ4_/kz>S)^)q-Z.|2k2n3p4P4X6u7b7k7l8k9X9g9m9n;W;`=vQ>X>ZR>Y>['QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SS$oh$pR4U/U'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/U/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>ST$kf$qQ$ifS)j$l)nR)v$qT$jf$qT)l$l)n'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/U/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>ST$oh$pQ$rhR)u$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_!s>Q$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S#glOPXZst!Z!`!o#S#d#o#{$n%m&k&n&o&r&t&u&w&{'T'b)O)s*i+]+g,p,s,x-i.g/V/n0]0l1r2S2T2V2X2[2_2a3d4T4z6T6e6f6i7[8t9T!U%Ri$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y#f(w#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^Q+T%aQ/c*Oo4O<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!U$yi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>YQ*c$zU*l$|*Z*oQ+U%bQ0W*m#f=q#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n=r<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hQ=w>TQ=x>UQ=y>VR=z>W!U%Ri$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y#f(w#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^o4O<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hnoOXst!Z#d%m&r&t&u&w,s,x2[2_S*f${*YQ-R'OQ-S'QR4i/y%[%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^Q,U&]Q1h,WQ5s1gR8h5tV*n$|*Z*oU*n$|*Z*oT5z1o5{S0P*i/nQ4w0]T8S4z:]Q+j%xQ0V*lQ1O+kQ1u,aQ6W1vQ8v6XQ:c8wR;^:d!U%Oi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Yx*R$v)e*S*u+V/v0d0e4R4g5R5S5W7p8U:R:x=p=}>OS0`*t0a#f<o#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n<p<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!d=S(u)c*[*e.j.m.q/_/k/|0v1e3h4[4h4l5r7]7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[`=T3}7c7f7j9h:t:w;yS=_.l3iT=`7e9k!U%Qi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y|*T$v)e*U*t+V/g/v0d0e4R4g4|5R5S5W7p8U:R:x=p=}>OS0b*u0c#f<q#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n<r<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!h=U(u)c*[*e.k.l.q/_/k/|0v1e3f3h4[4h4l5r7]7^7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[d=V3}7d7e7j9h9i:t:u:w;yS=a.m3jT=b7f9lrnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_Q&f!UR,p&ornOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_R&f!UQ,Y&^R1d,RsnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_Q1p,_S6R1s1tU8p6P6Q6US:_8r8sS;Y:^:aQ;m;ZR;w;nQ&m!VR,i&iR6_1|R:f8yW&Q|&V&W,OR1Z+vQ&r!WR,s&sR,y&xT2],x2_R,}&yQ,|&yR2f,}Q'y!{R-y'ySsOtQ#dXT%ps#dQ#OTR'{#OQ#RUR'}#RQ){$uR/`){Q#UVR(Q#UQ#XWU(W#X(X.QQ(X#YR.Q(YQ-^'YR2r-^Q.u(yS3m.u3nR3n.vQ-e'`R2v-eY!rQ'`-e1o5{R'j!rQ/Q)eR4S/QU#_W%h*YU(_#_(`.RQ(`#`R.R(ZQ-a']R2t-at`OXst!V!Z#d%m&i&k&r&t&u&w,s,x2[2_S#hZ%eU#r`#h.[R.[(jQ(k#jQ.X(gW.a(k.X3X7RQ3X.YR7R3YQ)n$lR/W)nQ$phR)t$pQ$`cU)a$`-|<jQ-|<WR<j)qQ/q*]W4c/q4d7t9sU4d/r/s/tS7t4e4fR9s7u$e*Q$v(u)c)e*[*e*t*u+Q+R+V.l.m.o.p.q/_/g/i/k/v/|0d0e0v1e3f3g3h3}4R4[4g4h4l4|5O5R5S5W5r7]7^7_7`7e7f7h7i7j7p7w7z8U8X8Z9h9i9j9t9|:R:S:t:u:v:w:x:};R;e;j;v;y=p=}>O>Z>[Q/z*eU4k/z4m7xQ4m/|R7x4lS*o$|*ZR0Y*ox*S$v)e*t*u+V/v0d0e4R4g5R5S5W7p8U:R:x=p=}>O!d.j(u)c*[*e.l.m.q/_/k/|0v1e3h4[4h4l5r7]7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[U/h*S.j7ca7c3}7e7f7j9h:t:w;yQ0a*tQ3i.lU4}0a3i9kR9k7e|*U$v)e*t*u+V/g/v0d0e4R4g4|5R5S5W7p8U:R:x=p=}>O!h.k(u)c*[*e.l.m.q/_/k/|0v1e3f3h4[4h4l5r7]7^7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[U/j*U.k7de7d3}7e7f7j9h9i:t:u:w;yQ0c*uQ3j.mU5P0c3j9lR9l7fQ*z%UR0g*zQ5]0vR8Y5]Q+_%kR0u+_Q5v1jS8j5v:[R:[8kQ,[&_R1m,[Q5{1oR8m5{Q1{,fS6]1{8zR8z6_Q1U+rW5h1U5j8a:VQ5j1XQ8a5iR:V8bQ+w&QR1[+wQ2_,xR6m2_YrOXst#dQ&v!ZQ+a%mQ,r&rQ,t&tQ,u&uQ,w&wQ2Y,sS2],x2_R6l2[Q%opQ&z!_Q&}!aQ'P!bQ'R!cQ'q!uQ+`%lQ+l%zQ,Q&XQ,h&mQ-P&|W-p'k's't'wQ-w'oQ0X*nQ1P+mQ1c,PS2O,i,lQ2g-OQ2h-RQ2i-SQ2}-oW3P-r-s-v-xQ5a1QQ5m1_Q5q1eQ6V1uQ6a2QQ6k2ZU6z3O3R3UQ6}3SQ8]5bQ8e5oQ8g5rQ8l5zQ8u6WQ8{6`S9[6{7PQ9^7OQ:W8cQ:b8vQ:g8|Q:n9]Q;U:XQ;]:cQ;a:oQ;l;VR;o;^Q%zyQ'd!iQ'o!uU+m%{%|%}Q-W'VU-k'e'f'gS-o'k'uQ0Q*jS1Q+n+oQ2o-YS2{-l-mQ3S-tS4p0R0UQ5b1RQ6v2uQ6y2|Q7O3TU7{4r4s4vQ9z7}R;O9{S$wi>PR*{%VU%Ui%V>PR0f*yQ$viS(u#v+iS)c$b$cQ)e$dQ*[$xS*e${*YQ*t%OQ*u%QQ+Q%^Q+R%_Q+V%cQ.l<oQ.m<qQ.o<uQ.p<wQ.q<yQ/_)yQ/g*RQ/i*TQ/k*VQ/v*aS/|*g/mQ0d*wQ0e*xl0v+f,V.f1i1q3c6S7W8q9b:`:r;[;dQ1e,SQ3f=SQ3g=UQ3h=XS3}<l<mQ4R/PS4[/d4^Q4g/xQ4h/yQ4l/{Q4|0`Q5O0bQ5R0iQ5S0jQ5W0oQ5r1fQ7]=]Q7^=_Q7_=aQ7`=cQ7e<pQ7f<rQ7h<vQ7i<xQ7j<zQ7p4_Q7w4jQ7z4oQ8U5QQ8X5[Q8Z5_Q9h=YQ9i=TQ9j=VQ9t7vQ9|8QQ:R8VQ:S8[Q:t=^Q:u=`Q:v=bQ:w=dQ:x9pQ:}9yQ;R:PQ;e=gQ;j;QQ;v;kQ;y=hQ=p>PQ=}>XQ>O>YQ>Z>]R>[>^Q+O%]Q.n<sR7g<tnpOXst!Z#d%m&r&t&u&w,s,x2[2_Q!fPS#fZ#oQ&|!`W'h!o*i0]4zQ(P#SQ)Q#{Q)r$nS,l&k&nQ,q&oQ-O&{S-T'T/nQ-g'bQ.x)OQ/[)sQ0s+]Q0y+gQ2W,pQ2y-iQ3a.gQ4W/VQ5U0lQ6Q1rQ6c2SQ6d2TQ6h2VQ6j2XQ6o2aQ7Z3dQ7m4TQ8s6TQ9P6eQ9Q6fQ9S6iQ9f7[Q:a8tR:k9T#[cOPXZst!Z!`!o#d#o#{%m&k&n&o&r&t&u&w&{'T'b)O*i+]+g,p,s,x-i.g/n0]0l1r2S2T2V2X2[2_2a3d4z6T6e6f6i7[8t9TQ#YWQ#eYQ%quQ%svS%uw!gS(S#W(VQ(Y#ZQ(t#uQ(y#xQ)R$OQ)S$PQ)T$QQ)U$RQ)V$SQ)W$TQ)X$UQ)Y$VQ)Z$WQ)[$XQ)^$ZQ)`$_Q)b$aQ)g$eW)q$n)s/V4TQ+d%tQ+x&RS-Z'X2pQ-x'rS-}(T.PQ.S(]Q.U(dQ.s(xQ.v(zQ.z<UQ.|<XQ.}<YQ/O<]Q/b)}Q0p+XQ2k-UQ2n-XQ3O-qQ3V.VQ3k.tQ3p<^Q3q<_Q3r<`Q3s<aQ3t<bQ3u<cQ3v<dQ3w<eQ3x<fQ3y<gQ3z<hQ3{.{Q3|<kQ4P<nQ4Q<{Q4X<iQ5X0rQ5c1SQ6u=OQ6{3QQ7Q3WQ7a3lQ7b=PQ7k=RQ7l=ZQ8k5wQ9X6sQ9]6|Q9g=[Q9m=eQ9n=fQ:o9_Q;W:ZQ;`:mQ<W#SR=v>SR#[WR'Z!el!tQ!r!v!y!z'`'l'm'n-e-u1o5{5}S'V!e-]U*j$|*Z*oS-Y'W'_S0U*k*qQ0^*rQ2u-cQ4v0[R4{0_R({#xQ!fQT-d'`-e]!qQ!r'`-e1o5{Q#p]R'i<VR)f$dY!uQ'`-e1o5{Q'k!rS'u!v!yS'w!z5}S-t'l'mQ-v'nR3T-uT#kZ%eS#jZ%eS%km,oU(g#h#i#lS.Y(h(iQ.^(jQ0t+^Q3Y.ZU3Z.[.]._S7S3[3]R9`7Td#^W#W#Z%h(T(^*Y+Z.T/mr#gZm#h#i#l%e(h(i(j+^.Z.[.]._3[3]7TS*]$x*bQ/t*^Q2U,oQ2l-VQ4`/pQ6q2dQ7s4aQ9W6rT=m'X+[V#aW%h*YU#`W%h*YS(U#W(^U(Z#Z+Z/mS-['X+[T.O(T.TV'^!e%i*ZQ$lfR)x$qT)m$l)nR4V/UT*_$x*bT*h${*YQ0w+fQ1g,VQ3_.fQ5t1iQ6P1qQ7X3cQ8r6SQ9c7WQ:^8qQ:p9bQ;Z:`Q;c:rQ;n;[R;q;dnqOXst!Z#d%m&r&t&u&w,s,x2[2_Q&l!VR,h&itmOXst!U!V!Z#d%m&i&r&t&u&w,s,x2[2_R,o&oT%lm,oR1k,XR,g&gQ&U|S+}&V&WR1^,OR+s&PT&p!W&sT&q!W&sT2^,x2_",
      nodeNames: "\u26A0 ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList in out const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration defer ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
      maxTerm: 380,
      context: trackNewline,
      nodeProps: [
        ["isolate", -8, 5, 6, 14, 37, 39, 51, 53, 55, ""],
        ["group", -26, 9, 17, 19, 68, 207, 211, 215, 216, 218, 221, 224, 234, 237, 243, 245, 247, 249, 252, 258, 264, 266, 268, 270, 272, 274, 275, "Statement", -34, 13, 14, 32, 35, 36, 42, 51, 54, 55, 57, 62, 70, 72, 76, 80, 82, 84, 85, 110, 111, 120, 121, 136, 139, 141, 142, 143, 144, 145, 147, 148, 167, 169, 171, "Expression", -23, 31, 33, 37, 41, 43, 45, 173, 175, 177, 178, 180, 181, 182, 184, 185, 186, 188, 189, 190, 201, 203, 205, 206, "Type", -3, 88, 103, 109, "ClassItem"],
        ["openedBy", 23, "<", 38, "InterpolationStart", 56, "[", 60, "{", 73, "(", 160, "JSXStartCloseTag"],
        ["closedBy", -2, 24, 168, ">", 40, "InterpolationEnd", 50, "]", 61, "}", 74, ")", 165, "JSXEndTag"]
      ],
      propSources: [jsHighlight],
      skippedNodes: [0, 5, 6, 278],
      repeatNodeCount: 37,
      tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$i&j(Wp(Z!b'|0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(X#S$i&j'}0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$i&j(Wp(Z!b'}0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$i&j!p),Q(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(V':f$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$i&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$d`$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$d``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$d`$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(Z!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$d`(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$i&j(Wp(Z!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$i&j(Wp(Z!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$i&j(Z!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$i&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(Z!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$i&j(WpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(WpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Wp(Z!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$i&j(o%1l(Wp(Z!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$i&j(Wp(Z!b$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$i&j(Wp(Z!b$]#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$i&j(Wp(Z!b#p(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$i&j$Q(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(z+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$i&j#z(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(Y';W$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$i&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$d`$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(WpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$d`(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$i&j(Wp(Z!b(U%&f#q(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$i&j(Wp(Z!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$i&j(Wp(Z!br+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!]+Jf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$i&j(Wp(Z!b!Q.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_![!L^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$i&j(Wp(Z!b#o(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$i&j(Z!b!X7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$i&j!X7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$i&j!X7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!X7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!X7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$i&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$i&j(Z!b!X7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(Z!b!X7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(Z!b!X7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(Z!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$i&j(Z!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$i&j(Wp!X7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$i&j(Wp!X7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Wp!X7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Wp!X7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(WpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$i&j(WpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$i&j(Wp(Z!b!X7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Wp(Z!b!X7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Wp(Z!b!X7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Wp(Z!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$i&j(Wp(Z!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$i&j(Wp(Z!b(O0/l!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$i&j(Wp(Z!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$i&j(Z!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$i&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(Z!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$i&j(WpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(WpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Wp(Z!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$i&j$Q(Ch(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Z#t$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!g$b$i&j$O)Lv(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#R-<U(Wp(Z!b$n7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$k&j(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#r(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$Q(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#s(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#`*!Y$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#k(Cl$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#s(Ch$f#|$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#s(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(r(Ct$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$i&j#{(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!|$Ip$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!S0,v$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$i&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$i&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$i&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$i&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$i&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!Y#)l$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#x(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$i&j(Wp(Z!b(a+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$i&j(Wp(Z!b(T,2j$_#t(e$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$i&j(Wp(Z!b$_#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!_#Hb(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(y+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!^(CdvBr$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!q7`$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$i&j(Wp(Z!b'|0/l$]#t(T,2j(e$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$i&j(Wp(Z!b'}0/l$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
      tokenizers: [noSemicolon, noSemicolonType, operatorToken, jsx, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, insertSemicolon, new LocalTokenGroup("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOx~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!U~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(c~~", 141, 340), new LocalTokenGroup("j~RQYZXz{^~^O(Q~~aP!P!Qd~iO(R~~", 25, 323)],
      topRules: { "Script": [0, 7], "SingleExpression": [1, 276], "SingleClassItem": [2, 277] },
      dialects: { jsx: 0, ts: 15175 },
      dynamicPrecedences: { "80": 1, "82": 1, "94": 1, "169": 1, "199": 1 },
      specialized: [{ term: 327, get: (value) => spec_identifier[value] || -1 }, { term: 343, get: (value) => spec_word[value] || -1 }, { term: 95, get: (value) => spec_LessThan[value] || -1 }],
      tokenPrec: 15201
    });
  }
});

// node_modules/@codemirror/language/dist/index.js
function defineLanguageFacet(baseData) {
  return Facet.define({
    combine: baseData ? (values2) => values2.concat(baseData) : void 0
  });
}
function topNodeAt(state, pos, side) {
  let topLang = state.facet(language), tree2 = syntaxTree(state).topNode;
  if (!topLang || topLang.allowsNesting) {
    for (let node = tree2; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))
      if (node.type.isTop)
        tree2 = node;
  }
  return tree2;
}
function syntaxTree(state) {
  let field = state.field(Language.state, false);
  return field ? field.tree : Tree2.empty;
}
function cutFragments(fragments, from2, to) {
  return TreeFragment.applyChanges(fragments, [{ fromA: from2, toA: to, fromB: from2, toB: to }]);
}
function getIndentUnit(state) {
  let unit = state.facet(indentUnit);
  return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
}
function indentString(state, cols) {
  let result = "", ts = state.tabSize, ch = state.facet(indentUnit)[0];
  if (ch == "	") {
    while (cols >= ts) {
      result += "	";
      cols -= ts;
    }
    ch = " ";
  }
  for (let i = 0; i < cols; i++)
    result += ch;
  return result;
}
function getIndentation(context2, pos) {
  if (context2 instanceof EditorState)
    context2 = new IndentContext(context2);
  for (let service of context2.state.facet(indentService)) {
    let result = service(context2, pos);
    if (result !== void 0)
      return result;
  }
  let tree2 = syntaxTree(context2.state);
  return tree2.length >= pos ? syntaxIndentation(context2, tree2, pos) : null;
}
function syntaxIndentation(cx, ast, pos) {
  let stack = ast.resolveStack(pos);
  let inner = ast.resolveInner(pos, -1).resolve(pos, 0).enterUnfinishedNodesBefore(pos);
  if (inner != stack.node) {
    let add2 = [];
    for (let cur2 = inner; cur2 && !(cur2.from < stack.node.from || cur2.to > stack.node.to || cur2.from == stack.node.from && cur2.type == stack.node.type); cur2 = cur2.parent)
      add2.push(cur2);
    for (let i = add2.length - 1; i >= 0; i--)
      stack = { node: add2[i], next: stack };
  }
  return indentFor(stack, cx, pos);
}
function indentFor(stack, cx, pos) {
  for (let cur2 = stack; cur2; cur2 = cur2.next) {
    let strategy = indentStrategy(cur2.node);
    if (strategy)
      return strategy(TreeIndentContext.create(cx, pos, cur2));
  }
  return 0;
}
function ignoreClosed(cx) {
  return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
}
function indentStrategy(tree2) {
  let strategy = tree2.type.prop(indentNodeProp);
  if (strategy)
    return strategy;
  let first2 = tree2.firstChild, close;
  if (first2 && (close = first2.type.prop(NodeProp.closedBy))) {
    let last4 = tree2.lastChild, closed = last4 && close.indexOf(last4.name) > -1;
    return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last4.from : void 0);
  }
  return tree2.parent == null ? topIndent : null;
}
function topIndent() {
  return 0;
}
function isParent(parent, of2) {
  for (let cur2 = of2; cur2; cur2 = cur2.parent)
    if (parent == cur2)
      return true;
  return false;
}
function bracketedAligned(context2) {
  let tree2 = context2.node;
  let openToken = tree2.childAfter(tree2.from), last4 = tree2.lastChild;
  if (!openToken)
    return null;
  let sim = context2.options.simulateBreak;
  let openLine = context2.state.doc.lineAt(openToken.from);
  let lineEnd2 = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
  for (let pos = openToken.to; ; ) {
    let next = tree2.childAfter(pos);
    if (!next || next == last4)
      return null;
    if (!next.type.isSkipped) {
      if (next.from >= lineEnd2)
        return null;
      let space5 = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length;
      return { from: openToken.from, to: openToken.to + space5 };
    }
    pos = next.to;
  }
}
function delimitedIndent({ closing: closing2, align = true, units = 1 }) {
  return (context2) => delimitedStrategy(context2, align, units, closing2);
}
function delimitedStrategy(context2, align, units, closing2, closedAt) {
  let after = context2.textAfter, space5 = after.match(/^\s*/)[0].length;
  let closed = closing2 && after.slice(space5, space5 + closing2.length) == closing2 || closedAt == context2.pos + space5;
  let aligned = align ? bracketedAligned(context2) : null;
  if (aligned)
    return closed ? context2.column(aligned.from) : context2.column(aligned.to);
  return context2.baseIndent + (closed ? 0 : context2.unit * units);
}
function continuedIndent({ except, units = 1 } = {}) {
  return (context2) => {
    let matchExcept = except && except.test(context2.textAfter);
    return context2.baseIndent + (matchExcept ? 0 : units * context2.unit);
  };
}
function indentOnInput() {
  return EditorState.transactionFilter.of((tr) => {
    if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
      return tr;
    let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
    if (!rules.length)
      return tr;
    let doc2 = tr.newDoc, { head } = tr.newSelection.main, line = doc2.lineAt(head);
    if (head > line.from + DontIndentBeyond)
      return tr;
    let lineStart = doc2.sliceString(line.from, head);
    if (!rules.some((r) => r.test(lineStart)))
      return tr;
    let { state } = tr, last4 = -1, changes = [];
    for (let { head: head2 } of state.selection.ranges) {
      let line2 = state.doc.lineAt(head2);
      if (line2.from == last4)
        continue;
      last4 = line2.from;
      let indent2 = getIndentation(state, line2.from);
      if (indent2 == null)
        continue;
      let cur2 = /^\s*/.exec(line2.text)[0];
      let norm = indentString(state, indent2);
      if (cur2 != norm)
        changes.push({ from: line2.from, to: line2.from + cur2.length, insert: norm });
    }
    return changes.length ? [tr, { changes, sequential: true }] : tr;
  });
}
function foldInside(node) {
  let first2 = node.firstChild, last4 = node.lastChild;
  return first2 && first2.to < last4.from ? { from: first2.to, to: last4.type.isError ? node.to : last4.from } : null;
}
function syntaxFolding(state, start, end) {
  let tree2 = syntaxTree(state);
  if (tree2.length < end)
    return null;
  let stack = tree2.resolveStack(end, 1);
  let found = null;
  for (let iter = stack; iter; iter = iter.next) {
    let cur2 = iter.node;
    if (cur2.to <= end || cur2.from > end)
      continue;
    if (found && cur2.from < start)
      break;
    let prop = cur2.type.prop(foldNodeProp);
    if (prop && (cur2.to < tree2.length - 50 || tree2.length == state.doc.length || !isUnfinished(cur2))) {
      let value = prop(cur2, state);
      if (value && value.from <= end && value.from >= start && value.to > end)
        found = value;
    }
  }
  return found;
}
function isUnfinished(node) {
  let ch = node.lastChild;
  return ch && ch.to == node.to && ch.type.isError;
}
function foldable(state, lineStart, lineEnd2) {
  for (let service of state.facet(foldService)) {
    let result = service(state, lineStart, lineEnd2);
    if (result)
      return result;
  }
  return syntaxFolding(state, lineStart, lineEnd2);
}
function mapRange(range, mapping) {
  let from2 = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
  return from2 >= to ? void 0 : { from: from2, to };
}
function selectedLines(view) {
  let lines = [];
  for (let { head } of view.state.selection.ranges) {
    if (lines.some((l) => l.from <= head && l.to >= head))
      continue;
    lines.push(view.lineBlockAt(head));
  }
  return lines;
}
function clearTouchedFolds(folded, from2, to = from2) {
  let touched = false;
  folded.between(from2, to, (a, b) => {
    if (a < to && b > from2)
      touched = true;
  });
  return !touched ? folded : folded.update({
    filterFrom: from2,
    filterTo: to,
    filter: (a, b) => a >= to || b <= from2
  });
}
function findFold(state, from2, to) {
  var _a2;
  let found = null;
  (_a2 = state.field(foldState, false)) === null || _a2 === void 0 ? void 0 : _a2.between(from2, to, (from3, to2) => {
    if (!found || found.from > from3)
      found = { from: from3, to: to2 };
  });
  return found;
}
function foldExists(folded, from2, to) {
  let found = false;
  folded.between(from2, from2, (a, b) => {
    if (a == from2 && b == to)
      found = true;
  });
  return found;
}
function maybeEnable(state, other) {
  return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
}
function announceFold(view, range, fold = true) {
  let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;
  return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
}
function codeFolding(config3) {
  let result = [foldState, baseTheme$12];
  if (config3)
    result.push(foldConfig.of(config3));
  return result;
}
function widgetToDOM(view, prepared) {
  let { state } = view, conf = state.facet(foldConfig);
  let onclick = (event) => {
    let line = view.lineBlockAt(view.posAtDOM(event.target));
    let folded = findFold(view.state, line.from, line.to);
    if (folded)
      view.dispatch({ effects: unfoldEffect.of(folded) });
    event.preventDefault();
  };
  if (conf.placeholderDOM)
    return conf.placeholderDOM(view, onclick, prepared);
  let element = document.createElement("span");
  element.textContent = conf.placeholderText;
  element.setAttribute("aria-label", state.phrase("folded code"));
  element.title = state.phrase("unfold");
  element.className = "cm-foldPlaceholder";
  element.onclick = onclick;
  return element;
}
function foldGutter(config3 = {}) {
  let fullConfig = __spreadValues(__spreadValues({}, foldGutterDefaults), config3);
  let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
  let markers = ViewPlugin.fromClass(class {
    constructor(view) {
      this.from = view.viewport.from;
      this.markers = this.buildMarkers(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update))
        this.markers = this.buildMarkers(update.view);
    }
    buildMarkers(view) {
      let builder = new RangeSetBuilder();
      for (let line of view.viewportLineBlocks) {
        let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;
        if (mark)
          builder.add(line.from, line.from, mark);
      }
      return builder.finish();
    }
  });
  let { domEventHandlers } = fullConfig;
  return [
    markers,
    gutter({
      class: "cm-foldGutter",
      markers(view) {
        var _a2;
        return ((_a2 = view.plugin(markers)) === null || _a2 === void 0 ? void 0 : _a2.markers) || RangeSet.empty;
      },
      initialSpacer() {
        return new FoldMarker(fullConfig, false);
      },
      domEventHandlers: __spreadProps(__spreadValues({}, domEventHandlers), {
        click: (view, line, event) => {
          if (domEventHandlers.click && domEventHandlers.click(view, line, event))
            return true;
          let folded = findFold(view.state, line.from, line.to);
          if (folded) {
            view.dispatch({ effects: unfoldEffect.of(folded) });
            return true;
          }
          let range = foldable(view.state, line.from, line.to);
          if (range) {
            view.dispatch({ effects: foldEffect.of(range) });
            return true;
          }
          return false;
        }
      })
    }),
    codeFolding()
  ];
}
function getHighlighters(state) {
  let main = state.facet(highlighterFacet);
  return main.length ? main : state.facet(fallbackHighlighter);
}
function syntaxHighlighting(highlighter, options) {
  let ext = [treeHighlighter], themeType;
  if (highlighter instanceof HighlightStyle) {
    if (highlighter.module)
      ext.push(EditorView.styleModule.of(highlighter.module));
    themeType = highlighter.themeType;
  }
  if (options === null || options === void 0 ? void 0 : options.fallback)
    ext.push(fallbackHighlighter.of(highlighter));
  else if (themeType)
    ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state) => {
      return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
    }));
  else
    ext.push(highlighterFacet.of(highlighter));
  return ext;
}
function defaultRenderMatch(match2) {
  let decorations2 = [];
  let mark = match2.matched ? matchingMark : nonmatchingMark;
  decorations2.push(mark.range(match2.start.from, match2.start.to));
  if (match2.end)
    decorations2.push(mark.range(match2.end.from, match2.end.to));
  return decorations2;
}
function bracketMatching(config3 = {}) {
  return [bracketMatchingConfig.of(config3), bracketMatchingUnique];
}
function matchingNodes(node, dir, brackets) {
  let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
  if (byProp)
    return byProp;
  if (node.name.length == 1) {
    let index = brackets.indexOf(node.name);
    if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))
      return [brackets[index + dir]];
  }
  return null;
}
function findHandle(node) {
  let hasHandle = node.type.prop(bracketMatchingHandle);
  return hasHandle ? hasHandle(node.node) : node;
}
function matchBrackets(state, pos, dir, config3 = {}) {
  let maxScanDistance = config3.maxScanDistance || DefaultScanDist, brackets = config3.brackets || DefaultBrackets;
  let tree2 = syntaxTree(state), node = tree2.resolveInner(pos, dir);
  for (let cur2 = node; cur2; cur2 = cur2.parent) {
    let matches = matchingNodes(cur2.type, dir, brackets);
    if (matches && cur2.from < cur2.to) {
      let handle = findHandle(cur2);
      if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
        return matchMarkedBrackets(state, pos, dir, cur2, handle, matches, brackets);
    }
  }
  return matchPlainBrackets(state, pos, dir, tree2, node.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
  let parent = token.parent, firstToken = { from: handle.from, to: handle.to };
  let depth = 0, cursor2 = parent === null || parent === void 0 ? void 0 : parent.cursor();
  if (cursor2 && (dir < 0 ? cursor2.childBefore(token.from) : cursor2.childAfter(token.to)))
    do {
      if (dir < 0 ? cursor2.to <= token.from : cursor2.from >= token.to) {
        if (depth == 0 && matching.indexOf(cursor2.type.name) > -1 && cursor2.from < cursor2.to) {
          let endHandle = findHandle(cursor2);
          return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : void 0, matched: true };
        } else if (matchingNodes(cursor2.type, dir, brackets)) {
          depth++;
        } else if (matchingNodes(cursor2.type, -dir, brackets)) {
          if (depth == 0) {
            let endHandle = findHandle(cursor2);
            return {
              start: firstToken,
              end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : void 0,
              matched: false
            };
          }
          depth--;
        }
      }
    } while (dir < 0 ? cursor2.prevSibling() : cursor2.nextSibling());
  return { start: firstToken, matched: false };
}
function matchPlainBrackets(state, pos, dir, tree2, tokenType, maxScanDistance, brackets) {
  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
  let bracket2 = brackets.indexOf(startCh);
  if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
    return null;
  let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
  for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
    let text = iter.value;
    if (dir < 0)
      distance += text.length;
    let basePos = pos + distance * dir;
    for (let pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos2 != end; pos2 += dir) {
      let found = brackets.indexOf(text[pos2]);
      if (found < 0 || tree2.resolveInner(basePos + pos2, 1).type != tokenType)
        continue;
      if (found % 2 == 0 == dir > 0) {
        depth++;
      } else if (depth == 1) {
        return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket2 >> 1 };
      } else {
        depth--;
      }
    }
    if (dir > 0)
      distance += text.length;
  }
  return iter.done ? { start: startToken, matched: false } : null;
}
function warnForPart(part, msg) {
  if (warned.indexOf(part) > -1)
    return;
  warned.push(part);
  console.warn(msg);
}
function createTokenType(extra, tagStr) {
  let tags$1 = [];
  for (let name3 of tagStr.split(" ")) {
    let found = [];
    for (let part of name3.split(".")) {
      let value = extra[part] || tags[part];
      if (!value) {
        warnForPart(part, `Unknown highlighting tag ${part}`);
      } else if (typeof value == "function") {
        if (!found.length)
          warnForPart(part, `Modifier ${part} used at start of tag`);
        else
          found = found.map(value);
      } else {
        if (found.length)
          warnForPart(part, `Tag ${part} used as modifier`);
        else
          found = Array.isArray(value) ? value : [value];
      }
    }
    for (let tag of found)
      tags$1.push(tag);
  }
  if (!tags$1.length)
    return 0;
  let name2 = tagStr.replace(/ /g, "_"), key = name2 + " " + tags$1.map((t2) => t2.id);
  let known = byTag[key];
  if (known)
    return known.id;
  let type = byTag[key] = NodeType.define({
    id: typeArray.length,
    name: name2,
    props: [styleTags({ [name2]: tags$1 })]
  });
  typeArray.push(type);
  return type.id;
}
var _a, languageDataProp, sublanguageProp, Language, LRLanguage, DocInput, currentContext, ParseContext, LanguageState, requestIdle, isInputPending, parseWorker, language, LanguageSupport, LanguageDescription, indentService, indentUnit, IndentContext, indentNodeProp, TreeIndentContext, flatIndent, DontIndentBeyond, foldService, foldNodeProp, foldEffect, unfoldEffect, foldState, foldCode, unfoldCode, foldAll, unfoldAll, foldKeymap, defaultConfig, foldConfig, foldWidget, PreparedFoldWidget, foldGutterDefaults, FoldMarker, baseTheme$12, HighlightStyle, highlighterFacet, fallbackHighlighter, TreeHighlighter, treeHighlighter, defaultHighlightStyle, baseTheme2, DefaultScanDist, DefaultBrackets, bracketMatchingConfig, matchingMark, nonmatchingMark, bracketMatchingState, bracketMatchingUnique, bracketMatchingHandle, noTokens, typeArray, warned, byTag, defaultTable, marks;
var init_dist7 = __esm({
  "node_modules/@codemirror/language/dist/index.js"() {
    "use strict";
    init_dist3();
    init_dist();
    init_dist2();
    init_dist5();
    init_style_mod();
    languageDataProp = /* @__PURE__ */ new NodeProp();
    sublanguageProp = /* @__PURE__ */ new NodeProp();
    Language = class {
      /**
      Construct a language object. If you need to invoke this
      directly, first define a data facet with
      [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
      configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
      to the language's outer syntax node.
      */
      constructor(data2, parser7, extraExtensions = [], name2 = "") {
        this.data = data2;
        this.name = name2;
        if (!EditorState.prototype.hasOwnProperty("tree"))
          Object.defineProperty(EditorState.prototype, "tree", { get() {
            return syntaxTree(this);
          } });
        this.parser = parser7;
        this.extension = [
          language.of(this),
          EditorState.languageData.of((state, pos, side) => {
            let top2 = topNodeAt(state, pos, side), data3 = top2.type.prop(languageDataProp);
            if (!data3)
              return [];
            let base2 = state.facet(data3), sub = top2.type.prop(sublanguageProp);
            if (sub) {
              let innerNode = top2.resolve(pos - top2.from, side);
              for (let sublang of sub)
                if (sublang.test(innerNode, state)) {
                  let data4 = state.facet(sublang.facet);
                  return sublang.type == "replace" ? data4 : data4.concat(base2);
                }
            }
            return base2;
          })
        ].concat(extraExtensions);
      }
      /**
      Query whether this language is active at the given position.
      */
      isActiveAt(state, pos, side = -1) {
        return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
      }
      /**
      Find the document regions that were parsed using this language.
      The returned regions will _include_ any nested languages rooted
      in this language, when those exist.
      */
      findRegions(state) {
        let lang = state.facet(language);
        if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
          return [{ from: 0, to: state.doc.length }];
        if (!lang || !lang.allowsNesting)
          return [];
        let result = [];
        let explore = (tree2, from2) => {
          if (tree2.prop(languageDataProp) == this.data) {
            result.push({ from: from2, to: from2 + tree2.length });
            return;
          }
          let mount = tree2.prop(NodeProp.mounted);
          if (mount) {
            if (mount.tree.prop(languageDataProp) == this.data) {
              if (mount.overlay)
                for (let r of mount.overlay)
                  result.push({ from: r.from + from2, to: r.to + from2 });
              else
                result.push({ from: from2, to: from2 + tree2.length });
              return;
            } else if (mount.overlay) {
              let size = result.length;
              explore(mount.tree, mount.overlay[0].from + from2);
              if (result.length > size)
                return;
            }
          }
          for (let i = 0; i < tree2.children.length; i++) {
            let ch = tree2.children[i];
            if (ch instanceof Tree2)
              explore(ch, tree2.positions[i] + from2);
          }
        };
        explore(syntaxTree(state), 0);
        return result;
      }
      /**
      Indicates whether this language allows nested languages. The
      default implementation returns true.
      */
      get allowsNesting() {
        return true;
      }
    };
    Language.setState = /* @__PURE__ */ StateEffect.define();
    LRLanguage = class _LRLanguage extends Language {
      constructor(data2, parser7, name2) {
        super(data2, parser7, [], name2);
        this.parser = parser7;
      }
      /**
      Define a language from a parser.
      */
      static define(spec) {
        let data2 = defineLanguageFacet(spec.languageData);
        return new _LRLanguage(data2, spec.parser.configure({
          props: [languageDataProp.add((type) => type.isTop ? data2 : void 0)]
        }), spec.name);
      }
      /**
      Create a new instance of this language with a reconfigured
      version of its parser and optionally a new name.
      */
      configure(options, name2) {
        return new _LRLanguage(this.data, this.parser.configure(options), name2 || this.name);
      }
      get allowsNesting() {
        return this.parser.hasWrappers();
      }
    };
    DocInput = class {
      /**
      Create an input object for the given document.
      */
      constructor(doc2) {
        this.doc = doc2;
        this.cursorPos = 0;
        this.string = "";
        this.cursor = doc2.iter();
      }
      get length() {
        return this.doc.length;
      }
      syncTo(pos) {
        this.string = this.cursor.next(pos - this.cursorPos).value;
        this.cursorPos = pos + this.string.length;
        return this.cursorPos - this.string.length;
      }
      chunk(pos) {
        this.syncTo(pos);
        return this.string;
      }
      get lineChunks() {
        return true;
      }
      read(from2, to) {
        let stringStart2 = this.cursorPos - this.string.length;
        if (from2 < stringStart2 || to >= this.cursorPos)
          return this.doc.sliceString(from2, to);
        else
          return this.string.slice(from2 - stringStart2, to - stringStart2);
      }
    };
    currentContext = null;
    ParseContext = class _ParseContext {
      constructor(parser7, state, fragments = [], tree2, treeLen, viewport, skipped, scheduleOn) {
        this.parser = parser7;
        this.state = state;
        this.fragments = fragments;
        this.tree = tree2;
        this.treeLen = treeLen;
        this.viewport = viewport;
        this.skipped = skipped;
        this.scheduleOn = scheduleOn;
        this.parse = null;
        this.tempSkipped = [];
      }
      /**
      @internal
      */
      static create(parser7, state, viewport) {
        return new _ParseContext(parser7, state, [], Tree2.empty, 0, viewport, [], null);
      }
      startParse() {
        return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
      }
      /**
      @internal
      */
      work(until, upto) {
        if (upto != null && upto >= this.state.doc.length)
          upto = void 0;
        if (this.tree != Tree2.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
          this.takeTree();
          return true;
        }
        return this.withContext(() => {
          var _a2;
          if (typeof until == "number") {
            let endTime = Date.now() + until;
            until = () => Date.now() > endTime;
          }
          if (!this.parse)
            this.parse = this.startParse();
          if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
            this.parse.stopAt(upto);
          for (; ; ) {
            let done = this.parse.advance();
            if (done) {
              this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
              this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
              this.tree = done;
              this.parse = null;
              if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
                this.parse = this.startParse();
              else
                return true;
            }
            if (until())
              return false;
          }
        });
      }
      /**
      @internal
      */
      takeTree() {
        let pos, tree2;
        if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
          if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
            this.parse.stopAt(pos);
          this.withContext(() => {
            while (!(tree2 = this.parse.advance())) {
            }
          });
          this.treeLen = pos;
          this.tree = tree2;
          this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
          this.parse = null;
        }
      }
      withContext(f) {
        let prev = currentContext;
        currentContext = this;
        try {
          return f();
        } finally {
          currentContext = prev;
        }
      }
      withoutTempSkipped(fragments) {
        for (let r; r = this.tempSkipped.pop(); )
          fragments = cutFragments(fragments, r.from, r.to);
        return fragments;
      }
      /**
      @internal
      */
      changes(changes, newState) {
        let { fragments, tree: tree2, treeLen, viewport, skipped } = this;
        this.takeTree();
        if (!changes.empty) {
          let ranges = [];
          changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
          fragments = TreeFragment.applyChanges(fragments, ranges);
          tree2 = Tree2.empty;
          treeLen = 0;
          viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
          if (this.skipped.length) {
            skipped = [];
            for (let r of this.skipped) {
              let from2 = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
              if (from2 < to)
                skipped.push({ from: from2, to });
            }
          }
        }
        return new _ParseContext(this.parser, newState, fragments, tree2, treeLen, viewport, skipped, this.scheduleOn);
      }
      /**
      @internal
      */
      updateViewport(viewport) {
        if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
          return false;
        this.viewport = viewport;
        let startLen = this.skipped.length;
        for (let i = 0; i < this.skipped.length; i++) {
          let { from: from2, to } = this.skipped[i];
          if (from2 < viewport.to && to > viewport.from) {
            this.fragments = cutFragments(this.fragments, from2, to);
            this.skipped.splice(i--, 1);
          }
        }
        if (this.skipped.length >= startLen)
          return false;
        this.reset();
        return true;
      }
      /**
      @internal
      */
      reset() {
        if (this.parse) {
          this.takeTree();
          this.parse = null;
        }
      }
      /**
      Notify the parse scheduler that the given region was skipped
      because it wasn't in view, and the parse should be restarted
      when it comes into view.
      */
      skipUntilInView(from2, to) {
        this.skipped.push({ from: from2, to });
      }
      /**
      Returns a parser intended to be used as placeholder when
      asynchronously loading a nested parser. It'll skip its input and
      mark it as not-really-parsed, so that the next update will parse
      it again.
      
      When `until` is given, a reparse will be scheduled when that
      promise resolves.
      */
      static getSkippingParser(until) {
        return new class extends Parser {
          createParse(input2, fragments, ranges) {
            let from2 = ranges[0].from, to = ranges[ranges.length - 1].to;
            let parser7 = {
              parsedPos: from2,
              advance() {
                let cx = currentContext;
                if (cx) {
                  for (let r of ranges)
                    cx.tempSkipped.push(r);
                  if (until)
                    cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
                }
                this.parsedPos = to;
                return new Tree2(NodeType.none, [], [], to - from2);
              },
              stoppedAt: null,
              stopAt() {
              }
            };
            return parser7;
          }
        }();
      }
      /**
      @internal
      */
      isDone(upto) {
        upto = Math.min(upto, this.state.doc.length);
        let frags = this.fragments;
        return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
      }
      /**
      Get the context for the current parse, or `null` if no editor
      parse is in progress.
      */
      static get() {
        return currentContext;
      }
    };
    LanguageState = class _LanguageState {
      constructor(context2) {
        this.context = context2;
        this.tree = context2.tree;
      }
      apply(tr) {
        if (!tr.docChanged && this.tree == this.context.tree)
          return this;
        let newCx = this.context.changes(tr.changes, tr.state);
        let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
        if (!newCx.work(20, upto))
          newCx.takeTree();
        return new _LanguageState(newCx);
      }
      static init(state) {
        let vpTo = Math.min(3e3, state.doc.length);
        let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
        if (!parseState.work(20, vpTo))
          parseState.takeTree();
        return new _LanguageState(parseState);
      }
    };
    Language.state = /* @__PURE__ */ StateField.define({
      create: LanguageState.init,
      update(value, tr) {
        for (let e of tr.effects)
          if (e.is(Language.setState))
            return e.value;
        if (tr.startState.facet(language) != tr.state.facet(language))
          return LanguageState.init(tr.state);
        return value.apply(tr);
      }
    });
    requestIdle = (callback) => {
      let timeout = setTimeout(
        () => callback(),
        500
        /* Work.MaxPause */
      );
      return () => clearTimeout(timeout);
    };
    if (typeof requestIdleCallback != "undefined")
      requestIdle = (callback) => {
        let idle = -1, timeout = setTimeout(
          () => {
            idle = requestIdleCallback(callback, {
              timeout: 500 - 100
              /* Work.MinPause */
            });
          },
          100
          /* Work.MinPause */
        );
        return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
      };
    isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
    parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
      constructor(view) {
        this.view = view;
        this.working = null;
        this.workScheduled = 0;
        this.chunkEnd = -1;
        this.chunkBudget = -1;
        this.work = this.work.bind(this);
        this.scheduleWork();
      }
      update(update) {
        let cx = this.view.state.field(Language.state).context;
        if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
          this.scheduleWork();
        if (update.docChanged || update.selectionSet) {
          if (this.view.hasFocus)
            this.chunkBudget += 50;
          this.scheduleWork();
        }
        this.checkAsyncSchedule(cx);
      }
      scheduleWork() {
        if (this.working)
          return;
        let { state } = this.view, field = state.field(Language.state);
        if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
          this.working = requestIdle(this.work);
      }
      work(deadline) {
        this.working = null;
        let now = Date.now();
        if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
          this.chunkEnd = now + 3e4;
          this.chunkBudget = 3e3;
        }
        if (this.chunkBudget <= 0)
          return;
        let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
        if (field.tree == field.context.tree && field.context.isDone(
          vpTo + 1e5
          /* Work.MaxParseAhead */
        ))
          return;
        let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
        let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
        let done = field.context.work(() => {
          return isInputPending && isInputPending() || Date.now() > endTime;
        }, vpTo + (viewportFirst ? 0 : 1e5));
        this.chunkBudget -= Date.now() - now;
        if (done || this.chunkBudget <= 0) {
          field.context.takeTree();
          this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
        }
        if (this.chunkBudget > 0 && !(done && !viewportFirst))
          this.scheduleWork();
        this.checkAsyncSchedule(field.context);
      }
      checkAsyncSchedule(cx) {
        if (cx.scheduleOn) {
          this.workScheduled++;
          cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
          cx.scheduleOn = null;
        }
      }
      destroy() {
        if (this.working)
          this.working();
      }
      isWorking() {
        return !!(this.working || this.workScheduled > 0);
      }
    }, {
      eventHandlers: { focus() {
        this.scheduleWork();
      } }
    });
    language = /* @__PURE__ */ Facet.define({
      combine(languages) {
        return languages.length ? languages[0] : null;
      },
      enables: (language2) => [
        Language.state,
        parseWorker,
        EditorView.contentAttributes.compute([language2], (state) => {
          let lang = state.facet(language2);
          return lang && lang.name ? { "data-language": lang.name } : {};
        })
      ]
    });
    LanguageSupport = class {
      /**
      Create a language support object.
      */
      constructor(language2, support = []) {
        this.language = language2;
        this.support = support;
        this.extension = [language2, support];
      }
    };
    LanguageDescription = class _LanguageDescription {
      constructor(name2, alias, extensions, filename, loadFunc, support = void 0) {
        this.name = name2;
        this.alias = alias;
        this.extensions = extensions;
        this.filename = filename;
        this.loadFunc = loadFunc;
        this.support = support;
        this.loading = null;
      }
      /**
      Start loading the the language. Will return a promise that
      resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
      object when the language successfully loads.
      */
      load() {
        return this.loading || (this.loading = this.loadFunc().then((support) => this.support = support, (err) => {
          this.loading = null;
          throw err;
        }));
      }
      /**
      Create a language description.
      */
      static of(spec) {
        let { load: load2, support } = spec;
        if (!load2) {
          if (!support)
            throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
          load2 = () => Promise.resolve(support);
        }
        return new _LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map((s) => s.toLowerCase()), spec.extensions || [], spec.filename, load2, support);
      }
      /**
      Look for a language in the given array of descriptions that
      matches the filename. Will first match
      [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
      and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
      and return the first language that matches.
      */
      static matchFilename(descs, filename) {
        for (let d of descs)
          if (d.filename && d.filename.test(filename))
            return d;
        let ext = /\.([^.]+)$/.exec(filename);
        if (ext) {
          for (let d of descs)
            if (d.extensions.indexOf(ext[1]) > -1)
              return d;
        }
        return null;
      }
      /**
      Look for a language whose name or alias matches the the given
      name (case-insensitively). If `fuzzy` is true, and no direct
      matchs is found, this'll also search for a language whose name
      or alias occurs in the string (for names shorter than three
      characters, only when surrounded by non-word characters).
      */
      static matchLanguageName(descs, name2, fuzzy = true) {
        name2 = name2.toLowerCase();
        for (let d of descs)
          if (d.alias.some((a) => a == name2))
            return d;
        if (fuzzy)
          for (let d of descs)
            for (let a of d.alias) {
              let found = name2.indexOf(a);
              if (found > -1 && (a.length > 2 || !/\w/.test(name2[found - 1]) && !/\w/.test(name2[found + a.length])))
                return d;
            }
        return null;
      }
    };
    indentService = /* @__PURE__ */ Facet.define();
    indentUnit = /* @__PURE__ */ Facet.define({
      combine: (values2) => {
        if (!values2.length)
          return "  ";
        let unit = values2[0];
        if (!unit || /\S/.test(unit) || Array.from(unit).some((e) => e != unit[0]))
          throw new Error("Invalid indent unit: " + JSON.stringify(values2[0]));
        return unit;
      }
    });
    IndentContext = class {
      /**
      Create an indent context.
      */
      constructor(state, options = {}) {
        this.state = state;
        this.options = options;
        this.unit = getIndentUnit(state);
      }
      /**
      Get a description of the line at the given position, taking
      [simulated line
      breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
      into account. If there is such a break at `pos`, the `bias`
      argument determines whether the part of the line line before or
      after the break is used.
      */
      lineAt(pos, bias = 1) {
        let line = this.state.doc.lineAt(pos);
        let { simulateBreak, simulateDoubleBreak } = this.options;
        if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
          if (simulateDoubleBreak && simulateBreak == pos)
            return { text: "", from: pos };
          else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
            return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
          else
            return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
        }
        return line;
      }
      /**
      Get the text directly after `pos`, either the entire line
      or the next 100 characters, whichever is shorter.
      */
      textAfterPos(pos, bias = 1) {
        if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
          return "";
        let { text, from: from2 } = this.lineAt(pos, bias);
        return text.slice(pos - from2, Math.min(text.length, pos + 100 - from2));
      }
      /**
      Find the column for the given position.
      */
      column(pos, bias = 1) {
        let { text, from: from2 } = this.lineAt(pos, bias);
        let result = this.countColumn(text, pos - from2);
        let override = this.options.overrideIndentation ? this.options.overrideIndentation(from2) : -1;
        if (override > -1)
          result += override - this.countColumn(text, text.search(/\S|$/));
        return result;
      }
      /**
      Find the column position (taking tabs into account) of the given
      position in the given string.
      */
      countColumn(line, pos = line.length) {
        return countColumn(line, this.state.tabSize, pos);
      }
      /**
      Find the indentation column of the line at the given point.
      */
      lineIndent(pos, bias = 1) {
        let { text, from: from2 } = this.lineAt(pos, bias);
        let override = this.options.overrideIndentation;
        if (override) {
          let overriden = override(from2);
          if (overriden > -1)
            return overriden;
        }
        return this.countColumn(text, text.search(/\S|$/));
      }
      /**
      Returns the [simulated line
      break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
      for this context, if any.
      */
      get simulatedBreak() {
        return this.options.simulateBreak || null;
      }
    };
    indentNodeProp = /* @__PURE__ */ new NodeProp();
    TreeIndentContext = class _TreeIndentContext extends IndentContext {
      constructor(base2, pos, context2) {
        super(base2.state, base2.options);
        this.base = base2;
        this.pos = pos;
        this.context = context2;
      }
      /**
      The syntax tree node to which the indentation strategy
      applies.
      */
      get node() {
        return this.context.node;
      }
      /**
      @internal
      */
      static create(base2, pos, context2) {
        return new _TreeIndentContext(base2, pos, context2);
      }
      /**
      Get the text directly after `this.pos`, either the entire line
      or the next 100 characters, whichever is shorter.
      */
      get textAfter() {
        return this.textAfterPos(this.pos);
      }
      /**
      Get the indentation at the reference line for `this.node`, which
      is the line on which it starts, unless there is a node that is
      _not_ a parent of this node covering the start of that line. If
      so, the line at the start of that node is tried, again skipping
      on if it is covered by another such node.
      */
      get baseIndent() {
        return this.baseIndentFor(this.node);
      }
      /**
      Get the indentation for the reference line of the given node
      (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
      */
      baseIndentFor(node) {
        let line = this.state.doc.lineAt(node.from);
        for (; ; ) {
          let atBreak = node.resolve(line.from);
          while (atBreak.parent && atBreak.parent.from == atBreak.from)
            atBreak = atBreak.parent;
          if (isParent(atBreak, node))
            break;
          line = this.state.doc.lineAt(atBreak.from);
        }
        return this.lineIndent(line.from);
      }
      /**
      Continue looking for indentations in the node's parent nodes,
      and return the result of that.
      */
      continue() {
        return indentFor(this.context.next, this.base, this.pos);
      }
    };
    flatIndent = (context2) => context2.baseIndent;
    DontIndentBeyond = 200;
    foldService = /* @__PURE__ */ Facet.define();
    foldNodeProp = /* @__PURE__ */ new NodeProp();
    foldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
    unfoldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
    foldState = /* @__PURE__ */ StateField.define({
      create() {
        return Decoration.none;
      },
      update(folded, tr) {
        if (tr.isUserEvent("delete"))
          tr.changes.iterChangedRanges((fromA, toA) => folded = clearTouchedFolds(folded, fromA, toA));
        folded = folded.map(tr.changes);
        for (let e of tr.effects) {
          if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {
            let { preparePlaceholder } = tr.state.facet(foldConfig);
            let widget = !preparePlaceholder ? foldWidget : Decoration.replace({ widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value)) });
            folded = folded.update({ add: [widget.range(e.value.from, e.value.to)] });
          } else if (e.is(unfoldEffect)) {
            folded = folded.update({
              filter: (from2, to) => e.value.from != from2 || e.value.to != to,
              filterFrom: e.value.from,
              filterTo: e.value.to
            });
          }
        }
        if (tr.selection)
          folded = clearTouchedFolds(folded, tr.selection.main.head);
        return folded;
      },
      provide: (f) => EditorView.decorations.from(f),
      toJSON(folded, state) {
        let ranges = [];
        folded.between(0, state.doc.length, (from2, to) => {
          ranges.push(from2, to);
        });
        return ranges;
      },
      fromJSON(value) {
        if (!Array.isArray(value) || value.length % 2)
          throw new RangeError("Invalid JSON for fold state");
        let ranges = [];
        for (let i = 0; i < value.length; ) {
          let from2 = value[i++], to = value[i++];
          if (typeof from2 != "number" || typeof to != "number")
            throw new RangeError("Invalid JSON for fold state");
          ranges.push(foldWidget.range(from2, to));
        }
        return Decoration.set(ranges, true);
      }
    });
    foldCode = (view) => {
      for (let line of selectedLines(view)) {
        let range = foldable(view.state, line.from, line.to);
        if (range) {
          view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });
          return true;
        }
      }
      return false;
    };
    unfoldCode = (view) => {
      if (!view.state.field(foldState, false))
        return false;
      let effects = [];
      for (let line of selectedLines(view)) {
        let folded = findFold(view.state, line.from, line.to);
        if (folded)
          effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
      }
      if (effects.length)
        view.dispatch({ effects });
      return effects.length > 0;
    };
    foldAll = (view) => {
      let { state } = view, effects = [];
      for (let pos = 0; pos < state.doc.length; ) {
        let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);
        if (range)
          effects.push(foldEffect.of(range));
        pos = (range ? view.lineBlockAt(range.to) : line).to + 1;
      }
      if (effects.length)
        view.dispatch({ effects: maybeEnable(view.state, effects) });
      return !!effects.length;
    };
    unfoldAll = (view) => {
      let field = view.state.field(foldState, false);
      if (!field || !field.size)
        return false;
      let effects = [];
      field.between(0, view.state.doc.length, (from2, to) => {
        effects.push(unfoldEffect.of({ from: from2, to }));
      });
      view.dispatch({ effects });
      return true;
    };
    foldKeymap = [
      { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
      { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
      { key: "Ctrl-Alt-[", run: foldAll },
      { key: "Ctrl-Alt-]", run: unfoldAll }
    ];
    defaultConfig = {
      placeholderDOM: null,
      preparePlaceholder: null,
      placeholderText: "\u2026"
    };
    foldConfig = /* @__PURE__ */ Facet.define({
      combine(values2) {
        return combineConfig(values2, defaultConfig);
      }
    });
    foldWidget = /* @__PURE__ */ Decoration.replace({ widget: /* @__PURE__ */ new class extends WidgetType {
      toDOM(view) {
        return widgetToDOM(view, null);
      }
    }() });
    PreparedFoldWidget = class extends WidgetType {
      constructor(value) {
        super();
        this.value = value;
      }
      eq(other) {
        return this.value == other.value;
      }
      toDOM(view) {
        return widgetToDOM(view, this.value);
      }
    };
    foldGutterDefaults = {
      openText: "\u2304",
      closedText: "\u203A",
      markerDOM: null,
      domEventHandlers: {},
      foldingChanged: () => false
    };
    FoldMarker = class extends GutterMarker {
      constructor(config3, open) {
        super();
        this.config = config3;
        this.open = open;
      }
      eq(other) {
        return this.config == other.config && this.open == other.open;
      }
      toDOM(view) {
        if (this.config.markerDOM)
          return this.config.markerDOM(this.open);
        let span = document.createElement("span");
        span.textContent = this.open ? this.config.openText : this.config.closedText;
        span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
        return span;
      }
    };
    baseTheme$12 = /* @__PURE__ */ EditorView.baseTheme({
      ".cm-foldPlaceholder": {
        backgroundColor: "#eee",
        border: "1px solid #ddd",
        color: "#888",
        borderRadius: ".2em",
        margin: "0 1px",
        padding: "0 1px",
        cursor: "pointer"
      },
      ".cm-foldGutter span": {
        padding: "0 1px",
        cursor: "pointer"
      }
    });
    HighlightStyle = class _HighlightStyle {
      constructor(specs, options) {
        this.specs = specs;
        let modSpec;
        function def(spec) {
          let cls = StyleModule.newName();
          (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec;
          return cls;
        }
        const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : void 0;
        const scopeOpt = options.scope;
        this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
        this.style = tagHighlighter(specs.map((style) => ({
          tag: style.tag,
          class: style.class || def(Object.assign({}, style, { tag: null }))
        })), {
          all
        }).style;
        this.module = modSpec ? new StyleModule(modSpec) : null;
        this.themeType = options.themeType;
      }
      /**
      Create a highlighter style that associates the given styles to
      the given tags. The specs must be objects that hold a style tag
      or array of tags in their `tag` property, and either a single
      `class` property providing a static CSS class (for highlighter
      that rely on external styling), or a
      [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
      set of CSS properties (which define the styling for those tags).
      
      The CSS rules created for a highlighter will be emitted in the
      order of the spec's properties. That means that for elements that
      have multiple tags associated with them, styles defined further
      down in the list will have a higher CSS precedence than styles
      defined earlier.
      */
      static define(specs, options) {
        return new _HighlightStyle(specs, options || {});
      }
    };
    highlighterFacet = /* @__PURE__ */ Facet.define();
    fallbackHighlighter = /* @__PURE__ */ Facet.define({
      combine(values2) {
        return values2.length ? [values2[0]] : null;
      }
    });
    TreeHighlighter = class {
      constructor(view) {
        this.markCache = /* @__PURE__ */ Object.create(null);
        this.tree = syntaxTree(view.state);
        this.decorations = this.buildDeco(view, getHighlighters(view.state));
        this.decoratedTo = view.viewport.to;
      }
      update(update) {
        let tree2 = syntaxTree(update.state), highlighters = getHighlighters(update.state);
        let styleChange = highlighters != getHighlighters(update.startState);
        let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);
        if (tree2.length < viewport.to && !styleChange && tree2.type == this.tree.type && decoratedToMapped >= viewport.to) {
          this.decorations = this.decorations.map(update.changes);
          this.decoratedTo = decoratedToMapped;
        } else if (tree2 != this.tree || update.viewportChanged || styleChange) {
          this.tree = tree2;
          this.decorations = this.buildDeco(update.view, highlighters);
          this.decoratedTo = viewport.to;
        }
      }
      buildDeco(view, highlighters) {
        if (!highlighters || !this.tree.length)
          return Decoration.none;
        let builder = new RangeSetBuilder();
        for (let { from: from2, to } of view.visibleRanges) {
          highlightTree(this.tree, highlighters, (from3, to2, style) => {
            builder.add(from3, to2, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));
          }, from2, to);
        }
        return builder.finish();
      }
    };
    treeHighlighter = /* @__PURE__ */ Prec.high(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
      decorations: (v) => v.decorations
    }));
    defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
      {
        tag: tags.meta,
        color: "#404740"
      },
      {
        tag: tags.link,
        textDecoration: "underline"
      },
      {
        tag: tags.heading,
        textDecoration: "underline",
        fontWeight: "bold"
      },
      {
        tag: tags.emphasis,
        fontStyle: "italic"
      },
      {
        tag: tags.strong,
        fontWeight: "bold"
      },
      {
        tag: tags.strikethrough,
        textDecoration: "line-through"
      },
      {
        tag: tags.keyword,
        color: "#708"
      },
      {
        tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
        color: "#219"
      },
      {
        tag: [tags.literal, tags.inserted],
        color: "#164"
      },
      {
        tag: [tags.string, tags.deleted],
        color: "#a11"
      },
      {
        tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
        color: "#e40"
      },
      {
        tag: /* @__PURE__ */ tags.definition(tags.variableName),
        color: "#00f"
      },
      {
        tag: /* @__PURE__ */ tags.local(tags.variableName),
        color: "#30a"
      },
      {
        tag: [tags.typeName, tags.namespace],
        color: "#085"
      },
      {
        tag: tags.className,
        color: "#167"
      },
      {
        tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
        color: "#256"
      },
      {
        tag: /* @__PURE__ */ tags.definition(tags.propertyName),
        color: "#00c"
      },
      {
        tag: tags.comment,
        color: "#940"
      },
      {
        tag: tags.invalid,
        color: "#f00"
      }
    ]);
    baseTheme2 = /* @__PURE__ */ EditorView.baseTheme({
      "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
      "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
    });
    DefaultScanDist = 1e4;
    DefaultBrackets = "()[]{}";
    bracketMatchingConfig = /* @__PURE__ */ Facet.define({
      combine(configs) {
        return combineConfig(configs, {
          afterCursor: true,
          brackets: DefaultBrackets,
          maxScanDistance: DefaultScanDist,
          renderMatch: defaultRenderMatch
        });
      }
    });
    matchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-matchingBracket" });
    nonmatchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-nonmatchingBracket" });
    bracketMatchingState = /* @__PURE__ */ StateField.define({
      create() {
        return Decoration.none;
      },
      update(deco, tr) {
        if (!tr.docChanged && !tr.selection)
          return deco;
        let decorations2 = [];
        let config3 = tr.state.facet(bracketMatchingConfig);
        for (let range of tr.state.selection.ranges) {
          if (!range.empty)
            continue;
          let match2 = matchBrackets(tr.state, range.head, -1, config3) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config3) || config3.afterCursor && (matchBrackets(tr.state, range.head, 1, config3) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config3));
          if (match2)
            decorations2 = decorations2.concat(config3.renderMatch(match2, tr.state));
        }
        return Decoration.set(decorations2, true);
      },
      provide: (f) => EditorView.decorations.from(f)
    });
    bracketMatchingUnique = [
      bracketMatchingState,
      baseTheme2
    ];
    bracketMatchingHandle = /* @__PURE__ */ new NodeProp();
    noTokens = /* @__PURE__ */ Object.create(null);
    typeArray = [NodeType.none];
    warned = [];
    byTag = /* @__PURE__ */ Object.create(null);
    defaultTable = /* @__PURE__ */ Object.create(null);
    for (let [legacyName, name2] of [
      ["variable", "variableName"],
      ["variable-2", "variableName.special"],
      ["string-2", "string.special"],
      ["def", "variableName.definition"],
      ["tag", "tagName"],
      ["attribute", "attributeName"],
      ["type", "typeName"],
      ["builtin", "variableName.standard"],
      ["qualifier", "modifier"],
      ["error", "invalid"],
      ["header", "heading"],
      ["property", "propertyName"]
    ])
      defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name2);
    marks = {
      rtl: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "rtl" }, bidiIsolate: Direction.RTL }),
      ltr: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "ltr" }, bidiIsolate: Direction.LTR }),
      auto: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "auto" }, bidiIsolate: null })
    };
  }
});

// node_modules/@codemirror/autocomplete/dist/index.js
function toSet(chars) {
  let flat = Object.keys(chars).join("");
  let words = /\w/.test(flat);
  if (words)
    flat = flat.replace(/\w/g, "");
  return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options) {
  let first2 = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
  for (let { label } of options) {
    first2[label[0]] = true;
    for (let i = 1; i < label.length; i++)
      rest[label[i]] = true;
  }
  let source = toSet(first2) + toSet(rest) + "*$";
  return [new RegExp("^" + source), new RegExp(source)];
}
function completeFromList(list) {
  let options = list.map((o) => typeof o == "string" ? { label: o } : o);
  let [validFor, match2] = options.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
  return (context2) => {
    let token = context2.matchBefore(match2);
    return token || context2.explicit ? { from: token ? token.from : context2.pos, options, validFor } : null;
  };
}
function ifNotIn(nodes, source) {
  return (context2) => {
    for (let pos = syntaxTree(context2.state).resolveInner(context2.pos, -1); pos; pos = pos.parent) {
      if (nodes.indexOf(pos.name) > -1)
        return null;
      if (pos.type.isTop)
        break;
    }
    return source(context2);
  };
}
function cur(state) {
  return state.selection.main.from;
}
function ensureAnchor(expr, start) {
  var _a2;
  let { source } = expr;
  let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
  if (!addStart && !addEnd)
    return expr;
  return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a2 = expr.flags) !== null && _a2 !== void 0 ? _a2 : expr.ignoreCase ? "i" : "");
}
function insertCompletionText(state, text, from2, to) {
  let { main } = state.selection, fromOff = from2 - main.from, toOff = to - main.from;
  return __spreadProps(__spreadValues({}, state.changeByRange((range) => {
    if (range != main && from2 != to && state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from2, to))
      return { range };
    let lines = state.toText(text);
    return {
      changes: { from: range.from + fromOff, to: to == main.from ? range.to : range.from + toOff, insert: lines },
      range: EditorSelection.cursor(range.from + fromOff + lines.length)
    };
  })), {
    scrollIntoView: true,
    userEvent: "input.complete"
  });
}
function asSource(source) {
  if (!Array.isArray(source))
    return source;
  let known = SourceCache.get(source);
  if (!known)
    SourceCache.set(source, known = completeFromList(source));
  return known;
}
function joinClass(a, b) {
  return a ? b ? a + " " + b : a : b;
}
function defaultPositionInfo(view, list, option, info, space5, tooltip) {
  let rtl = view.textDirection == Direction.RTL, left = rtl, narrow = false;
  let side = "top", offset, maxWidth;
  let spaceLeft = list.left - space5.left, spaceRight = space5.right - list.right;
  let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;
  if (left && spaceLeft < Math.min(infoWidth, spaceRight))
    left = false;
  else if (!left && spaceRight < Math.min(infoWidth, spaceLeft))
    left = true;
  if (infoWidth <= (left ? spaceLeft : spaceRight)) {
    offset = Math.max(space5.top, Math.min(option.top, space5.bottom - infoHeight)) - list.top;
    maxWidth = Math.min(400, left ? spaceLeft : spaceRight);
  } else {
    narrow = true;
    maxWidth = Math.min(
      400,
      (rtl ? list.right : space5.right - list.left) - 30
      /* Info.Margin */
    );
    let spaceBelow = space5.bottom - list.bottom;
    if (spaceBelow >= infoHeight || spaceBelow > list.top) {
      offset = option.bottom - list.top;
    } else {
      side = "bottom";
      offset = list.bottom - option.top;
    }
  }
  let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;
  let scaleX = (list.right - list.left) / tooltip.offsetWidth;
  return {
    style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,
    class: "cm-completionInfo-" + (narrow ? rtl ? "left-narrow" : "right-narrow" : left ? "left" : "right")
  };
}
function optionContent(config3) {
  let content2 = config3.addToOptions.slice();
  if (config3.icons)
    content2.push({
      render(completion) {
        let icon = document.createElement("div");
        icon.classList.add("cm-completionIcon");
        if (completion.type)
          icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
        icon.setAttribute("aria-hidden", "true");
        return icon;
      },
      position: 20
    });
  content2.push({
    render(completion, _s, _v, match2) {
      let labelElt = document.createElement("span");
      labelElt.className = "cm-completionLabel";
      let label = completion.displayLabel || completion.label, off = 0;
      for (let j = 0; j < match2.length; ) {
        let from2 = match2[j++], to = match2[j++];
        if (from2 > off)
          labelElt.appendChild(document.createTextNode(label.slice(off, from2)));
        let span = labelElt.appendChild(document.createElement("span"));
        span.appendChild(document.createTextNode(label.slice(from2, to)));
        span.className = "cm-completionMatchedText";
        off = to;
      }
      if (off < label.length)
        labelElt.appendChild(document.createTextNode(label.slice(off)));
      return labelElt;
    },
    position: 50
  }, {
    render(completion) {
      if (!completion.detail)
        return null;
      let detailElt = document.createElement("span");
      detailElt.className = "cm-completionDetail";
      detailElt.textContent = completion.detail;
      return detailElt;
    },
    position: 80
  });
  return content2.sort((a, b) => a.position - b.position).map((a) => a.render);
}
function rangeAroundSelected(total, selected, max) {
  if (total <= max)
    return { from: 0, to: total };
  if (selected < 0)
    selected = 0;
  if (selected <= total >> 1) {
    let off2 = Math.floor(selected / max);
    return { from: off2 * max, to: (off2 + 1) * max };
  }
  let off = Math.floor((total - selected) / max);
  return { from: total - (off + 1) * max, to: total - off * max };
}
function completionTooltip(stateField, applyCompletion2) {
  return (view) => new CompletionTooltip(view, stateField, applyCompletion2);
}
function scrollIntoView2(container, element) {
  let parent = container.getBoundingClientRect();
  let self2 = element.getBoundingClientRect();
  let scaleY = parent.height / container.offsetHeight;
  if (self2.top < parent.top)
    container.scrollTop -= (parent.top - self2.top) / scaleY;
  else if (self2.bottom > parent.bottom)
    container.scrollTop += (self2.bottom - parent.bottom) / scaleY;
}
function score(option) {
  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
}
function sortOptions(active, state) {
  let options = [];
  let sections = null, dynamicSectionScore = null;
  let addOption = (option) => {
    options.push(option);
    let { section } = option.completion;
    if (section) {
      if (!sections)
        sections = [];
      let name2 = typeof section == "string" ? section : section.name;
      if (!sections.some((s) => s.name == name2))
        sections.push(typeof section == "string" ? { name: name2 } : section);
    }
  };
  let conf = state.facet(completionConfig);
  for (let a of active)
    if (a.hasResult()) {
      let getMatch = a.result.getMatch;
      if (a.result.filter === false) {
        for (let option of a.result.options) {
          addOption(new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options.length));
        }
      } else {
        let pattern = state.sliceDoc(a.from, a.to), match2;
        let matcher = conf.filterStrict ? new StrictMatcher(pattern) : new FuzzyMatcher(pattern);
        for (let option of a.result.options)
          if (match2 = matcher.match(option.label)) {
            let matched = !option.displayLabel ? match2.matched : getMatch ? getMatch(option, match2.matched) : [];
            let score2 = match2.score + (option.boost || 0);
            addOption(new Option(option, a.source, matched, score2));
            if (typeof option.section == "object" && option.section.rank === "dynamic") {
              let { name: name2 } = option.section;
              if (!dynamicSectionScore)
                dynamicSectionScore = /* @__PURE__ */ Object.create(null);
              dynamicSectionScore[name2] = Math.max(score2, dynamicSectionScore[name2] || -1e9);
            }
          }
      }
    }
  if (sections) {
    let sectionOrder = /* @__PURE__ */ Object.create(null), pos = 0;
    let cmp = (a, b) => {
      return (a.rank === "dynamic" && b.rank === "dynamic" ? dynamicSectionScore[b.name] - dynamicSectionScore[a.name] : 0) || (typeof a.rank == "number" ? a.rank : 1e9) - (typeof b.rank == "number" ? b.rank : 1e9) || (a.name < b.name ? -1 : 1);
    };
    for (let s of sections.sort(cmp)) {
      pos -= 1e5;
      sectionOrder[s.name] = pos;
    }
    for (let option of options) {
      let { section } = option.completion;
      if (section)
        option.score += sectionOrder[typeof section == "string" ? section : section.name];
    }
  }
  let result = [], prev = null;
  let compare3 = conf.compareCompletions;
  for (let opt of options.sort((a, b) => b.score - a.score || compare3(a.completion, b.completion))) {
    let cur2 = opt.completion;
    if (!prev || prev.label != cur2.label || prev.detail != cur2.detail || prev.type != null && cur2.type != null && prev.type != cur2.type || prev.apply != cur2.apply || prev.boost != cur2.boost)
      result.push(opt);
    else if (score(opt.completion) > score(prev))
      result[result.length - 1] = opt;
    prev = opt.completion;
  }
  return result;
}
function sameResults(a, b) {
  if (a == b)
    return true;
  for (let iA = 0, iB = 0; ; ) {
    while (iA < a.length && !a[iA].hasResult())
      iA++;
    while (iB < b.length && !b[iB].hasResult())
      iB++;
    let endA = iA == a.length, endB = iB == b.length;
    if (endA || endB)
      return endA == endB;
    if (a[iA++].result != b[iB++].result)
      return false;
  }
}
function makeAttrs(id2, selected) {
  let result = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": id2
  };
  if (selected > -1)
    result["aria-activedescendant"] = id2 + "-" + selected;
  return result;
}
function getUpdateType(tr, conf) {
  if (tr.isUserEvent("input.complete")) {
    let completion = tr.annotation(pickedCompletion);
    if (completion && conf.activateOnCompletion(completion))
      return 4 | 8;
  }
  let typing = tr.isUserEvent("input.type");
  return typing && conf.activateOnTyping ? 4 | 1 : typing ? 1 : tr.isUserEvent("delete.backward") ? 2 : tr.selection ? 8 : tr.docChanged ? 16 : 0;
}
function checkValid(validFor, state, from2, to) {
  if (!validFor)
    return false;
  let text = state.sliceDoc(from2, to);
  return typeof validFor == "function" ? validFor(text, from2, to, state) : ensureAnchor(validFor, true).test(text);
}
function applyCompletion(view, option) {
  const apply = option.completion.apply || option.completion.label;
  let result = view.state.field(completionState).active.find((a) => a.source == option.source);
  if (!(result instanceof ActiveResult))
    return false;
  if (typeof apply == "string")
    view.dispatch(__spreadProps(__spreadValues({}, insertCompletionText(view.state, apply, result.from, result.to)), {
      annotations: pickedCompletion.of(option.completion)
    }));
  else
    apply(view, option.completion, result.from, result.to);
  return true;
}
function moveCompletionSelection(forward, by = "option") {
  return (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
      return false;
    let step = 1, tooltip;
    if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip)))
      step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
    let { length } = cState.open.options;
    let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;
    if (selected < 0)
      selected = by == "page" ? 0 : length - 1;
    else if (selected >= length)
      selected = by == "page" ? length - 1 : 0;
    view.dispatch({ effects: setSelectedEffect.of(selected) });
    return true;
  };
}
function fieldSelection(ranges, field) {
  return EditorSelection.create(ranges.filter((r) => r.field == field).map((r) => EditorSelection.range(r.from, r.to)));
}
function snippet(template) {
  let snippet2 = Snippet.parse(template);
  return (editor, completion, from2, to) => {
    let { text, ranges } = snippet2.instantiate(editor.state, from2);
    let { main } = editor.state.selection;
    let spec = {
      changes: { from: from2, to: to == main.from ? main.to : to, insert: Text2.of(text) },
      scrollIntoView: true,
      annotations: completion ? [pickedCompletion.of(completion), Transaction.userEvent.of("input.complete")] : void 0
    };
    if (ranges.length)
      spec.selection = fieldSelection(ranges, 0);
    if (ranges.some((r) => r.field > 0)) {
      let active = new ActiveSnippet(ranges, 0);
      let effects = spec.effects = [setActive.of(active)];
      if (editor.state.field(snippetState, false) === void 0)
        effects.push(StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme3]));
    }
    editor.dispatch(editor.state.update(spec));
  };
}
function moveField(dir) {
  return ({ state, dispatch }) => {
    let active = state.field(snippetState, false);
    if (!active || dir < 0 && active.active == 0)
      return false;
    let next = active.active + dir, last4 = dir > 0 && !active.ranges.some((r) => r.field == next + dir);
    dispatch(state.update({
      selection: fieldSelection(active.ranges, next),
      effects: setActive.of(last4 ? null : new ActiveSnippet(active.ranges, next)),
      scrollIntoView: true
    }));
    return true;
  };
}
function snippetCompletion(template, completion) {
  return __spreadProps(__spreadValues({}, completion), { apply: snippet(template) });
}
function closeBrackets() {
  return [inputHandler2, bracketState];
}
function closing(ch) {
  for (let i = 0; i < definedClosing.length; i += 2)
    if (definedClosing.charCodeAt(i) == ch)
      return definedClosing.charAt(i + 1);
  return fromCodePoint(ch < 128 ? ch : ch + 1);
}
function config2(state, pos) {
  return state.languageDataAt("closeBrackets", pos)[0] || defaults2;
}
function insertBracket(state, bracket2) {
  let conf = config2(state, state.selection.main.head);
  let tokens = conf.brackets || defaults2.brackets;
  for (let tok of tokens) {
    let closed = closing(codePointAt2(tok, 0));
    if (bracket2 == tok)
      return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults2.before);
    if (bracket2 == closed && closedBracketAt(state, state.selection.main.from))
      return handleClose(state, tok, closed);
  }
  return null;
}
function closedBracketAt(state, pos) {
  let found = false;
  state.field(bracketState).between(0, state.doc.length, (from2) => {
    if (from2 == pos)
      found = true;
  });
  return found;
}
function nextChar(doc2, pos) {
  let next = doc2.sliceString(pos, pos + 2);
  return next.slice(0, codePointSize2(codePointAt2(next, 0)));
}
function prevChar(doc2, pos) {
  let prev = doc2.sliceString(pos - 2, pos);
  return codePointSize2(codePointAt2(prev, 0)) == prev.length ? prev : prev.slice(1);
}
function handleOpen(state, open, close, closeBefore) {
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],
        effects: closeBracketEffect.of(range.to + open.length),
        range: EditorSelection.range(range.anchor + open.length, range.head + open.length)
      };
    let next = nextChar(state.doc, range.head);
    if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
      return {
        changes: { insert: open + close, from: range.head },
        effects: closeBracketEffect.of(range.head + open.length),
        range: EditorSelection.cursor(range.head + open.length)
      };
    return { range: dont = range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleClose(state, _open, close) {
  let dont = null, changes = state.changeByRange((range) => {
    if (range.empty && nextChar(state.doc, range.head) == close)
      return {
        changes: { from: range.head, to: range.head + close.length, insert: close },
        range: EditorSelection.cursor(range.head + close.length)
      };
    return dont = { range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleSame(state, token, allowTriple, config3) {
  let stringPrefixes = config3.stringPrefixes || defaults2.stringPrefixes;
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],
        effects: closeBracketEffect.of(range.to + token.length),
        range: EditorSelection.range(range.anchor + token.length, range.head + token.length)
      };
    let pos = range.head, next = nextChar(state.doc, pos), start;
    if (next == token) {
      if (nodeStart(state, pos)) {
        return {
          changes: { insert: token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
      } else if (closedBracketAt(state, pos)) {
        let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
        let content2 = isTriple ? token + token + token : token;
        return {
          changes: { from: pos, to: pos + content2.length, insert: content2 },
          range: EditorSelection.cursor(pos + content2.length)
        };
      }
    } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {
      return {
        changes: { insert: token + token + token + token, from: pos },
        effects: closeBracketEffect.of(pos + token.length),
        range: EditorSelection.cursor(pos + token.length)
      };
    } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {
      if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))
        return {
          changes: { insert: token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
    }
    return { range: dont = range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function nodeStart(state, pos) {
  let tree2 = syntaxTree(state).resolveInner(pos + 1);
  return tree2.parent && tree2.from == pos;
}
function probablyInString(state, pos, quoteToken, prefixes) {
  let node = syntaxTree(state).resolveInner(pos, -1);
  let maxPrefix = prefixes.reduce((m, p) => Math.max(m, p.length), 0);
  for (let i = 0; i < 5; i++) {
    let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
    let quotePos = start.indexOf(quoteToken);
    if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
      let first2 = node.firstChild;
      while (first2 && first2.from == node.from && first2.to - first2.from > quoteToken.length + quotePos) {
        if (state.sliceDoc(first2.to - quoteToken.length, first2.to) == quoteToken)
          return false;
        first2 = first2.firstChild;
      }
      return true;
    }
    let parent = node.to == pos && node.parent;
    if (!parent)
      break;
    node = parent;
  }
  return false;
}
function canStartStringAt(state, pos, prefixes) {
  let charCat = state.charCategorizer(pos);
  if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word)
    return pos;
  for (let prefix of prefixes) {
    let start = pos - prefix.length;
    if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word)
      return start;
  }
  return -1;
}
function autocompletion(config3 = {}) {
  return [
    commitCharacters,
    completionState,
    completionConfig.of(config3),
    completionPlugin,
    completionKeymapExt,
    baseTheme3
  ];
}
var CompletionContext, Option, pickedCompletion, SourceCache, startCompletionEffect, closeCompletionEffect, FuzzyMatcher, StrictMatcher, completionConfig, CompletionTooltip, CompletionDialog, CompletionState, baseAttrs, noAttrs2, none2, ActiveSource, ActiveResult, setActiveEffect, setSelectedEffect, completionState, createTooltip, acceptCompletion, startCompletion, closeCompletion, RunningQuery, MaxUpdateCount, MinAbortTime, completionPlugin, windows, commitCharacters, baseTheme3, FieldPos, FieldRange, Snippet, fieldMarker, fieldRange, ActiveSnippet, setActive, moveToField, snippetState, clearSnippet, nextSnippetField, prevSnippetField, defaultSnippetKeymap, snippetKeymap, addSnippetKeymap, snippetPointerHandler, defaults2, closeBracketEffect, closedBracket, bracketState, definedClosing, android, inputHandler2, deleteBracketPair, closeBracketsKeymap, completionKeymap, completionKeymapExt;
var init_dist8 = __esm({
  "node_modules/@codemirror/autocomplete/dist/index.js"() {
    "use strict";
    init_dist();
    init_dist2();
    init_dist7();
    CompletionContext = class {
      /**
      Create a new completion context. (Mostly useful for testing
      completion sourcesin the editor, the extension will create
      these for you.)
      */
      constructor(state, pos, explicit, view) {
        this.state = state;
        this.pos = pos;
        this.explicit = explicit;
        this.view = view;
        this.abortListeners = [];
        this.abortOnDocChange = false;
      }
      /**
      Get the extent, content, and (if there is a token) type of the
      token before `this.pos`.
      */
      tokenBefore(types2) {
        let token = syntaxTree(this.state).resolveInner(this.pos, -1);
        while (token && types2.indexOf(token.name) < 0)
          token = token.parent;
        return token ? {
          from: token.from,
          to: this.pos,
          text: this.state.sliceDoc(token.from, this.pos),
          type: token.type
        } : null;
      }
      /**
      Get the match of the given expression directly before the
      cursor.
      */
      matchBefore(expr) {
        let line = this.state.doc.lineAt(this.pos);
        let start = Math.max(line.from, this.pos - 250);
        let str = line.text.slice(start - line.from, this.pos - line.from);
        let found = str.search(ensureAnchor(expr, false));
        return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };
      }
      /**
      Yields true when the query has been aborted. Can be useful in
      asynchronous queries to avoid doing work that will be ignored.
      */
      get aborted() {
        return this.abortListeners == null;
      }
      /**
      Allows you to register abort handlers, which will be called when
      the query is
      [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
      
      By default, running queries will not be aborted for regular
      typing or backspacing, on the assumption that they are likely to
      return a result with a
      [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
      allows the result to be used after all. Passing `onDocChange:
      true` will cause this query to be aborted for any document
      change.
      */
      addEventListener(type, listener, options) {
        if (type == "abort" && this.abortListeners) {
          this.abortListeners.push(listener);
          if (options && options.onDocChange)
            this.abortOnDocChange = true;
        }
      }
    };
    Option = class {
      constructor(completion, source, match2, score2) {
        this.completion = completion;
        this.source = source;
        this.match = match2;
        this.score = score2;
      }
    };
    pickedCompletion = /* @__PURE__ */ Annotation.define();
    SourceCache = /* @__PURE__ */ new WeakMap();
    startCompletionEffect = /* @__PURE__ */ StateEffect.define();
    closeCompletionEffect = /* @__PURE__ */ StateEffect.define();
    FuzzyMatcher = class {
      constructor(pattern) {
        this.pattern = pattern;
        this.chars = [];
        this.folded = [];
        this.any = [];
        this.precise = [];
        this.byWord = [];
        this.score = 0;
        this.matched = [];
        for (let p = 0; p < pattern.length; ) {
          let char = codePointAt2(pattern, p), size = codePointSize2(char);
          this.chars.push(char);
          let part = pattern.slice(p, p + size), upper = part.toUpperCase();
          this.folded.push(codePointAt2(upper == part ? part.toLowerCase() : upper, 0));
          p += size;
        }
        this.astral = pattern.length != this.chars.length;
      }
      ret(score2, matched) {
        this.score = score2;
        this.matched = matched;
        return this;
      }
      // Matches a given word (completion) against the pattern (input).
      // Will return a boolean indicating whether there was a match and,
      // on success, set `this.score` to the score, `this.matched` to an
      // array of `from, to` pairs indicating the matched parts of `word`.
      //
      // The score is a number that is more negative the worse the match
      // is. See `Penalty` above.
      match(word) {
        if (this.pattern.length == 0)
          return this.ret(-100, []);
        if (word.length < this.pattern.length)
          return null;
        let { chars, folded, any, precise, byWord } = this;
        if (chars.length == 1) {
          let first2 = codePointAt2(word, 0), firstSize = codePointSize2(first2);
          let score2 = firstSize == word.length ? 0 : -100;
          if (first2 == chars[0]) ;
          else if (first2 == folded[0])
            score2 += -200;
          else
            return null;
          return this.ret(score2, [0, firstSize]);
        }
        let direct = word.indexOf(this.pattern);
        if (direct == 0)
          return this.ret(word.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
        let len = chars.length, anyTo = 0;
        if (direct < 0) {
          for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len; ) {
            let next = codePointAt2(word, i);
            if (next == chars[anyTo] || next == folded[anyTo])
              any[anyTo++] = i;
            i += codePointSize2(next);
          }
          if (anyTo < len)
            return null;
        }
        let preciseTo = 0;
        let byWordTo = 0, byWordFolded = false;
        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
        let hasLower = /[a-z]/.test(word), wordAdjacent = true;
        for (let i = 0, e = Math.min(word.length, 200), prevType = 0; i < e && byWordTo < len; ) {
          let next = codePointAt2(word, i);
          if (direct < 0) {
            if (preciseTo < len && next == chars[preciseTo])
              precise[preciseTo++] = i;
            if (adjacentTo < len) {
              if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
                if (adjacentTo == 0)
                  adjacentStart = i;
                adjacentEnd = i + 1;
                adjacentTo++;
              } else {
                adjacentTo = 0;
              }
            }
          }
          let ch, type = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
          if (!i || type == 1 && hasLower || prevType == 0 && type != 0) {
            if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))
              byWord[byWordTo++] = i;
            else if (byWord.length)
              wordAdjacent = false;
          }
          prevType = type;
          i += codePointSize2(next);
        }
        if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
          return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
        if (adjacentTo == len && adjacentStart == 0)
          return this.ret(-200 - word.length + (adjacentEnd == word.length ? 0 : -100), [0, adjacentEnd]);
        if (direct > -1)
          return this.ret(-700 - word.length, [direct, direct + this.pattern.length]);
        if (adjacentTo == len)
          return this.ret(-200 + -700 - word.length, [adjacentStart, adjacentEnd]);
        if (byWordTo == len)
          return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
        return chars.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
      }
      result(score2, positions, word) {
        let result = [], i = 0;
        for (let pos of positions) {
          let to = pos + (this.astral ? codePointSize2(codePointAt2(word, pos)) : 1);
          if (i && result[i - 1] == pos)
            result[i - 1] = to;
          else {
            result[i++] = pos;
            result[i++] = to;
          }
        }
        return this.ret(score2 - word.length, result);
      }
    };
    StrictMatcher = class {
      constructor(pattern) {
        this.pattern = pattern;
        this.matched = [];
        this.score = 0;
        this.folded = pattern.toLowerCase();
      }
      match(word) {
        if (word.length < this.pattern.length)
          return null;
        let start = word.slice(0, this.pattern.length);
        let match2 = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200 : null;
        if (match2 == null)
          return null;
        this.matched = [0, start.length];
        this.score = match2 + (word.length == this.pattern.length ? 0 : -100);
        return this;
      }
    };
    completionConfig = /* @__PURE__ */ Facet.define({
      combine(configs) {
        return combineConfig(configs, {
          activateOnTyping: true,
          activateOnCompletion: () => false,
          activateOnTypingDelay: 100,
          selectOnOpen: true,
          override: null,
          closeOnBlur: true,
          maxRenderedOptions: 100,
          defaultKeymap: true,
          tooltipClass: () => "",
          optionClass: () => "",
          aboveCursor: false,
          icons: true,
          addToOptions: [],
          positionInfo: defaultPositionInfo,
          filterStrict: false,
          compareCompletions: (a, b) => a.label.localeCompare(b.label),
          interactionDelay: 75,
          updateSyncTime: 100
        }, {
          defaultKeymap: (a, b) => a && b,
          closeOnBlur: (a, b) => a && b,
          icons: (a, b) => a && b,
          tooltipClass: (a, b) => (c) => joinClass(a(c), b(c)),
          optionClass: (a, b) => (c) => joinClass(a(c), b(c)),
          addToOptions: (a, b) => a.concat(b),
          filterStrict: (a, b) => a || b
        });
      }
    });
    CompletionTooltip = class {
      constructor(view, stateField, applyCompletion2) {
        this.view = view;
        this.stateField = stateField;
        this.applyCompletion = applyCompletion2;
        this.info = null;
        this.infoDestroy = null;
        this.placeInfoReq = {
          read: () => this.measureInfo(),
          write: (pos) => this.placeInfo(pos),
          key: this
        };
        this.space = null;
        this.currentClass = "";
        let cState = view.state.field(stateField);
        let { options, selected } = cState.open;
        let config3 = view.state.facet(completionConfig);
        this.optionContent = optionContent(config3);
        this.optionClass = config3.optionClass;
        this.tooltipClass = config3.tooltipClass;
        this.range = rangeAroundSelected(options.length, selected, config3.maxRenderedOptions);
        this.dom = document.createElement("div");
        this.dom.className = "cm-tooltip-autocomplete";
        this.updateTooltipClass(view.state);
        this.dom.addEventListener("mousedown", (e) => {
          let { options: options2 } = view.state.field(stateField).open;
          for (let dom = e.target, match2; dom && dom != this.dom; dom = dom.parentNode) {
            if (dom.nodeName == "LI" && (match2 = /-(\d+)$/.exec(dom.id)) && +match2[1] < options2.length) {
              this.applyCompletion(view, options2[+match2[1]]);
              e.preventDefault();
              return;
            }
          }
        });
        this.dom.addEventListener("focusout", (e) => {
          let state = view.state.field(this.stateField, false);
          if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur && e.relatedTarget != view.contentDOM)
            view.dispatch({ effects: closeCompletionEffect.of(null) });
        });
        this.showOptions(options, cState.id);
      }
      mount() {
        this.updateSel();
      }
      showOptions(options, id2) {
        if (this.list)
          this.list.remove();
        this.list = this.dom.appendChild(this.createListBox(options, id2, this.range));
        this.list.addEventListener("scroll", () => {
          if (this.info)
            this.view.requestMeasure(this.placeInfoReq);
        });
      }
      update(update) {
        var _a2;
        let cState = update.state.field(this.stateField);
        let prevState = update.startState.field(this.stateField);
        this.updateTooltipClass(update.state);
        if (cState != prevState) {
          let { options, selected, disabled } = cState.open;
          if (!prevState.open || prevState.open.options != options) {
            this.range = rangeAroundSelected(options.length, selected, update.state.facet(completionConfig).maxRenderedOptions);
            this.showOptions(options, cState.id);
          }
          this.updateSel();
          if (disabled != ((_a2 = prevState.open) === null || _a2 === void 0 ? void 0 : _a2.disabled))
            this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!disabled);
        }
      }
      updateTooltipClass(state) {
        let cls = this.tooltipClass(state);
        if (cls != this.currentClass) {
          for (let c of this.currentClass.split(" "))
            if (c)
              this.dom.classList.remove(c);
          for (let c of cls.split(" "))
            if (c)
              this.dom.classList.add(c);
          this.currentClass = cls;
        }
      }
      positioned(space5) {
        this.space = space5;
        if (this.info)
          this.view.requestMeasure(this.placeInfoReq);
      }
      updateSel() {
        let cState = this.view.state.field(this.stateField), open = cState.open;
        if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
          this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
          this.showOptions(open.options, cState.id);
        }
        let newSel = this.updateSelectedOption(open.selected);
        if (newSel) {
          this.destroyInfo();
          let { completion } = open.options[open.selected];
          let { info } = completion;
          if (!info)
            return;
          let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
          if (!infoResult)
            return;
          if ("then" in infoResult) {
            infoResult.then((obj) => {
              if (obj && this.view.state.field(this.stateField, false) == cState)
                this.addInfoPane(obj, completion);
            }).catch((e) => logException(this.view.state, e, "completion info"));
          } else {
            this.addInfoPane(infoResult, completion);
            newSel.setAttribute("aria-describedby", this.info.id);
          }
        }
      }
      addInfoPane(content2, completion) {
        this.destroyInfo();
        let wrap = this.info = document.createElement("div");
        wrap.className = "cm-tooltip cm-completionInfo";
        wrap.id = "cm-completionInfo-" + Math.floor(Math.random() * 65535).toString(16);
        if (content2.nodeType != null) {
          wrap.appendChild(content2);
          this.infoDestroy = null;
        } else {
          let { dom, destroy } = content2;
          wrap.appendChild(dom);
          this.infoDestroy = destroy || null;
        }
        this.dom.appendChild(wrap);
        this.view.requestMeasure(this.placeInfoReq);
      }
      updateSelectedOption(selected) {
        let set = null;
        for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
          if (opt.nodeName != "LI" || !opt.id) {
            i--;
          } else if (i == selected) {
            if (!opt.hasAttribute("aria-selected")) {
              opt.setAttribute("aria-selected", "true");
              set = opt;
            }
          } else {
            if (opt.hasAttribute("aria-selected")) {
              opt.removeAttribute("aria-selected");
              opt.removeAttribute("aria-describedby");
            }
          }
        }
        if (set)
          scrollIntoView2(this.list, set);
        return set;
      }
      measureInfo() {
        let sel = this.dom.querySelector("[aria-selected]");
        if (!sel || !this.info)
          return null;
        let listRect = this.dom.getBoundingClientRect();
        let infoRect = this.info.getBoundingClientRect();
        let selRect = sel.getBoundingClientRect();
        let space5 = this.space;
        if (!space5) {
          let docElt = this.dom.ownerDocument.documentElement;
          space5 = { left: 0, top: 0, right: docElt.clientWidth, bottom: docElt.clientHeight };
        }
        if (selRect.top > Math.min(space5.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space5.top, listRect.top) + 10)
          return null;
        return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space5, this.dom);
      }
      placeInfo(pos) {
        if (this.info) {
          if (pos) {
            if (pos.style)
              this.info.style.cssText = pos.style;
            this.info.className = "cm-tooltip cm-completionInfo " + (pos.class || "");
          } else {
            this.info.style.cssText = "top: -1e6px";
          }
        }
      }
      createListBox(options, id2, range) {
        const ul = document.createElement("ul");
        ul.id = id2;
        ul.setAttribute("role", "listbox");
        ul.setAttribute("aria-expanded", "true");
        ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
        ul.addEventListener("mousedown", (e) => {
          if (e.target == ul)
            e.preventDefault();
        });
        let curSection = null;
        for (let i = range.from; i < range.to; i++) {
          let { completion, match: match2 } = options[i], { section } = completion;
          if (section) {
            let name2 = typeof section == "string" ? section : section.name;
            if (name2 != curSection && (i > range.from || range.from == 0)) {
              curSection = name2;
              if (typeof section != "string" && section.header) {
                ul.appendChild(section.header(section));
              } else {
                let header = ul.appendChild(document.createElement("completion-section"));
                header.textContent = name2;
              }
            }
          }
          const li = ul.appendChild(document.createElement("li"));
          li.id = id2 + "-" + i;
          li.setAttribute("role", "option");
          let cls = this.optionClass(completion);
          if (cls)
            li.className = cls;
          for (let source of this.optionContent) {
            let node = source(completion, this.view.state, this.view, match2);
            if (node)
              li.appendChild(node);
          }
        }
        if (range.from)
          ul.classList.add("cm-completionListIncompleteTop");
        if (range.to < options.length)
          ul.classList.add("cm-completionListIncompleteBottom");
        return ul;
      }
      destroyInfo() {
        if (this.info) {
          if (this.infoDestroy)
            this.infoDestroy();
          this.info.remove();
          this.info = null;
        }
      }
      destroy() {
        this.destroyInfo();
      }
    };
    CompletionDialog = class _CompletionDialog {
      constructor(options, attrs, tooltip, timestamp, selected, disabled) {
        this.options = options;
        this.attrs = attrs;
        this.tooltip = tooltip;
        this.timestamp = timestamp;
        this.selected = selected;
        this.disabled = disabled;
      }
      setSelected(selected, id2) {
        return selected == this.selected || selected >= this.options.length ? this : new _CompletionDialog(this.options, makeAttrs(id2, selected), this.tooltip, this.timestamp, selected, this.disabled);
      }
      static build(active, state, id2, prev, conf, didSetActive) {
        if (prev && !didSetActive && active.some((s) => s.isPending))
          return prev.setDisabled();
        let options = sortOptions(active, state);
        if (!options.length)
          return prev && active.some((a) => a.isPending) ? prev.setDisabled() : null;
        let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
        if (prev && prev.selected != selected && prev.selected != -1) {
          let selectedValue = prev.options[prev.selected].completion;
          for (let i = 0; i < options.length; i++)
            if (options[i].completion == selectedValue) {
              selected = i;
              break;
            }
        }
        return new _CompletionDialog(options, makeAttrs(id2, selected), {
          pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),
          create: createTooltip,
          above: conf.aboveCursor
        }, prev ? prev.timestamp : Date.now(), selected, false);
      }
      map(changes) {
        return new _CompletionDialog(this.options, this.attrs, __spreadProps(__spreadValues({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
      }
      setDisabled() {
        return new _CompletionDialog(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);
      }
    };
    CompletionState = class _CompletionState {
      constructor(active, id2, open) {
        this.active = active;
        this.id = id2;
        this.open = open;
      }
      static start() {
        return new _CompletionState(none2, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
      }
      update(tr) {
        let { state } = tr, conf = state.facet(completionConfig);
        let sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
        let active = sources.map((source) => {
          let value = this.active.find((s) => s.source == source) || new ActiveSource(
            source,
            this.active.some(
              (a) => a.state != 0
              /* State.Inactive */
            ) ? 1 : 0
            /* State.Inactive */
          );
          return value.update(tr, conf);
        });
        if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))
          active = this.active;
        let open = this.open, didSet = tr.effects.some((e) => e.is(setActiveEffect));
        if (open && tr.docChanged)
          open = open.map(tr.changes);
        if (tr.selection || active.some((a) => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active) || didSet)
          open = CompletionDialog.build(active, state, this.id, open, conf, didSet);
        else if (open && open.disabled && !active.some((a) => a.isPending))
          open = null;
        if (!open && active.every((a) => !a.isPending) && active.some((a) => a.hasResult()))
          active = active.map((a) => a.hasResult() ? new ActiveSource(
            a.source,
            0
            /* State.Inactive */
          ) : a);
        for (let effect2 of tr.effects)
          if (effect2.is(setSelectedEffect))
            open = open && open.setSelected(effect2.value, this.id);
        return active == this.active && open == this.open ? this : new _CompletionState(active, this.id, open);
      }
      get tooltip() {
        return this.open ? this.open.tooltip : null;
      }
      get attrs() {
        return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs2;
      }
    };
    baseAttrs = {
      "aria-autocomplete": "list"
    };
    noAttrs2 = {};
    none2 = [];
    ActiveSource = class _ActiveSource {
      constructor(source, state, explicit = false) {
        this.source = source;
        this.state = state;
        this.explicit = explicit;
      }
      hasResult() {
        return false;
      }
      get isPending() {
        return this.state == 1;
      }
      update(tr, conf) {
        let type = getUpdateType(tr, conf), value = this;
        if (type & 8 || type & 16 && this.touches(tr))
          value = new _ActiveSource(
            value.source,
            0
            /* State.Inactive */
          );
        if (type & 4 && value.state == 0)
          value = new _ActiveSource(
            this.source,
            1
            /* State.Pending */
          );
        value = value.updateFor(tr, type);
        for (let effect2 of tr.effects) {
          if (effect2.is(startCompletionEffect))
            value = new _ActiveSource(value.source, 1, effect2.value);
          else if (effect2.is(closeCompletionEffect))
            value = new _ActiveSource(
              value.source,
              0
              /* State.Inactive */
            );
          else if (effect2.is(setActiveEffect)) {
            for (let active of effect2.value)
              if (active.source == value.source)
                value = active;
          }
        }
        return value;
      }
      updateFor(tr, type) {
        return this.map(tr.changes);
      }
      map(changes) {
        return this;
      }
      touches(tr) {
        return tr.changes.touchesRange(cur(tr.state));
      }
    };
    ActiveResult = class _ActiveResult extends ActiveSource {
      constructor(source, explicit, limit, result, from2, to) {
        super(source, 3, explicit);
        this.limit = limit;
        this.result = result;
        this.from = from2;
        this.to = to;
      }
      hasResult() {
        return true;
      }
      updateFor(tr, type) {
        var _a2;
        if (!(type & 3))
          return this.map(tr.changes);
        let result = this.result;
        if (result.map && !tr.changes.empty)
          result = result.map(result, tr.changes);
        let from2 = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
        let pos = cur(tr.state);
        if (pos > to || !result || type & 2 && (cur(tr.startState) == this.from || pos < this.limit))
          return new ActiveSource(
            this.source,
            type & 4 ? 1 : 0
            /* State.Inactive */
          );
        let limit = tr.changes.mapPos(this.limit);
        if (checkValid(result.validFor, tr.state, from2, to))
          return new _ActiveResult(this.source, this.explicit, limit, result, from2, to);
        if (result.update && (result = result.update(result, from2, to, new CompletionContext(tr.state, pos, false))))
          return new _ActiveResult(this.source, this.explicit, limit, result, result.from, (_a2 = result.to) !== null && _a2 !== void 0 ? _a2 : cur(tr.state));
        return new ActiveSource(this.source, 1, this.explicit);
      }
      map(mapping) {
        if (mapping.empty)
          return this;
        let result = this.result.map ? this.result.map(this.result, mapping) : this.result;
        if (!result)
          return new ActiveSource(
            this.source,
            0
            /* State.Inactive */
          );
        return new _ActiveResult(this.source, this.explicit, mapping.mapPos(this.limit), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
      }
      touches(tr) {
        return tr.changes.touchesRange(this.from, this.to);
      }
    };
    setActiveEffect = /* @__PURE__ */ StateEffect.define({
      map(sources, mapping) {
        return sources.map((s) => s.map(mapping));
      }
    });
    setSelectedEffect = /* @__PURE__ */ StateEffect.define();
    completionState = /* @__PURE__ */ StateField.define({
      create() {
        return CompletionState.start();
      },
      update(value, tr) {
        return value.update(tr);
      },
      provide: (f) => [
        showTooltip.from(f, (val) => val.tooltip),
        EditorView.contentAttributes.from(f, (state) => state.attrs)
      ]
    });
    createTooltip = /* @__PURE__ */ completionTooltip(completionState, applyCompletion);
    acceptCompletion = (view) => {
      let cState = view.state.field(completionState, false);
      if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
        return false;
      return applyCompletion(view, cState.open.options[cState.open.selected]);
    };
    startCompletion = (view) => {
      let cState = view.state.field(completionState, false);
      if (!cState)
        return false;
      view.dispatch({ effects: startCompletionEffect.of(true) });
      return true;
    };
    closeCompletion = (view) => {
      let cState = view.state.field(completionState, false);
      if (!cState || !cState.active.some(
        (a) => a.state != 0
        /* State.Inactive */
      ))
        return false;
      view.dispatch({ effects: closeCompletionEffect.of(null) });
      return true;
    };
    RunningQuery = class {
      constructor(active, context2) {
        this.active = active;
        this.context = context2;
        this.time = Date.now();
        this.updates = [];
        this.done = void 0;
      }
    };
    MaxUpdateCount = 50;
    MinAbortTime = 1e3;
    completionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.debounceUpdate = -1;
        this.running = [];
        this.debounceAccept = -1;
        this.pendingStart = false;
        this.composing = 0;
        for (let active of view.state.field(completionState).active)
          if (active.isPending)
            this.startQuery(active);
      }
      update(update) {
        let cState = update.state.field(completionState);
        let conf = update.state.facet(completionConfig);
        if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
          return;
        let doesReset = update.transactions.some((tr) => {
          let type = getUpdateType(tr, conf);
          return type & 8 || (tr.selection || tr.docChanged) && !(type & 3);
        });
        for (let i = 0; i < this.running.length; i++) {
          let query = this.running[i];
          if (doesReset || query.context.abortOnDocChange && update.docChanged || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
            for (let handler of query.context.abortListeners) {
              try {
                handler();
              } catch (e) {
                logException(this.view.state, e);
              }
            }
            query.context.abortListeners = null;
            this.running.splice(i--, 1);
          } else {
            query.updates.push(...update.transactions);
          }
        }
        if (this.debounceUpdate > -1)
          clearTimeout(this.debounceUpdate);
        if (update.transactions.some((tr) => tr.effects.some((e) => e.is(startCompletionEffect))))
          this.pendingStart = true;
        let delay = this.pendingStart ? 50 : conf.activateOnTypingDelay;
        this.debounceUpdate = cState.active.some((a) => a.isPending && !this.running.some((q) => q.active.source == a.source)) ? setTimeout(() => this.startUpdate(), delay) : -1;
        if (this.composing != 0)
          for (let tr of update.transactions) {
            if (tr.isUserEvent("input.type"))
              this.composing = 2;
            else if (this.composing == 2 && tr.selection)
              this.composing = 3;
          }
      }
      startUpdate() {
        this.debounceUpdate = -1;
        this.pendingStart = false;
        let { state } = this.view, cState = state.field(completionState);
        for (let active of cState.active) {
          if (active.isPending && !this.running.some((r) => r.active.source == active.source))
            this.startQuery(active);
        }
        if (this.running.length && cState.open && cState.open.disabled)
          this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
      }
      startQuery(active) {
        let { state } = this.view, pos = cur(state);
        let context2 = new CompletionContext(state, pos, active.explicit, this.view);
        let pending = new RunningQuery(active, context2);
        this.running.push(pending);
        Promise.resolve(active.source(context2)).then((result) => {
          if (!pending.context.aborted) {
            pending.done = result || null;
            this.scheduleAccept();
          }
        }, (err) => {
          this.view.dispatch({ effects: closeCompletionEffect.of(null) });
          logException(this.view.state, err);
        });
      }
      scheduleAccept() {
        if (this.running.every((q) => q.done !== void 0))
          this.accept();
        else if (this.debounceAccept < 0)
          this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
      }
      // For each finished query in this.running, try to create a result
      // or, if appropriate, restart the query.
      accept() {
        var _a2;
        if (this.debounceAccept > -1)
          clearTimeout(this.debounceAccept);
        this.debounceAccept = -1;
        let updated = [];
        let conf = this.view.state.facet(completionConfig), cState = this.view.state.field(completionState);
        for (let i = 0; i < this.running.length; i++) {
          let query = this.running[i];
          if (query.done === void 0)
            continue;
          this.running.splice(i--, 1);
          if (query.done) {
            let pos = cur(query.updates.length ? query.updates[0].startState : this.view.state);
            let limit = Math.min(pos, query.done.from + (query.active.explicit ? 0 : 1));
            let active = new ActiveResult(query.active.source, query.active.explicit, limit, query.done, query.done.from, (_a2 = query.done.to) !== null && _a2 !== void 0 ? _a2 : pos);
            for (let tr of query.updates)
              active = active.update(tr, conf);
            if (active.hasResult()) {
              updated.push(active);
              continue;
            }
          }
          let current = cState.active.find((a) => a.source == query.active.source);
          if (current && current.isPending) {
            if (query.done == null) {
              let active = new ActiveSource(
                query.active.source,
                0
                /* State.Inactive */
              );
              for (let tr of query.updates)
                active = active.update(tr, conf);
              if (!active.isPending)
                updated.push(active);
            } else {
              this.startQuery(current);
            }
          }
        }
        if (updated.length || cState.open && cState.open.disabled)
          this.view.dispatch({ effects: setActiveEffect.of(updated) });
      }
    }, {
      eventHandlers: {
        blur(event) {
          let state = this.view.state.field(completionState, false);
          if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {
            let dialog = state.open && getTooltip(this.view, state.open.tooltip);
            if (!dialog || !dialog.dom.contains(event.relatedTarget))
              setTimeout(() => this.view.dispatch({ effects: closeCompletionEffect.of(null) }), 10);
          }
        },
        compositionstart() {
          this.composing = 1;
        },
        compositionend() {
          if (this.composing == 3) {
            setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
          }
          this.composing = 0;
        }
      }
    });
    windows = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform);
    commitCharacters = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.domEventHandlers({
      keydown(event, view) {
        let field = view.state.field(completionState, false);
        if (!field || !field.open || field.open.disabled || field.open.selected < 0 || event.key.length > 1 || event.ctrlKey && !(windows && event.altKey) || event.metaKey)
          return false;
        let option = field.open.options[field.open.selected];
        let result = field.active.find((a) => a.source == option.source);
        let commitChars = option.completion.commitCharacters || result.result.commitCharacters;
        if (commitChars && commitChars.indexOf(event.key) > -1)
          applyCompletion(view, option);
        return false;
      }
    }));
    baseTheme3 = /* @__PURE__ */ EditorView.baseTheme({
      ".cm-tooltip.cm-tooltip-autocomplete": {
        "& > ul": {
          fontFamily: "monospace",
          whiteSpace: "nowrap",
          overflow: "hidden auto",
          maxWidth_fallback: "700px",
          maxWidth: "min(700px, 95vw)",
          minWidth: "250px",
          maxHeight: "10em",
          height: "100%",
          listStyle: "none",
          margin: 0,
          padding: 0,
          "& > li, & > completion-section": {
            padding: "1px 3px",
            lineHeight: 1.2
          },
          "& > li": {
            overflowX: "hidden",
            textOverflow: "ellipsis",
            cursor: "pointer"
          },
          "& > completion-section": {
            display: "list-item",
            borderBottom: "1px solid silver",
            paddingLeft: "0.5em",
            opacity: 0.7
          }
        }
      },
      "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
        background: "#17c",
        color: "white"
      },
      "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
        background: "#777"
      },
      "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
        background: "#347",
        color: "white"
      },
      "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
        background: "#444"
      },
      ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
        content: '"\xB7\xB7\xB7"',
        opacity: 0.5,
        display: "block",
        textAlign: "center"
      },
      ".cm-tooltip.cm-completionInfo": {
        position: "absolute",
        padding: "3px 9px",
        width: "max-content",
        maxWidth: `${400}px`,
        boxSizing: "border-box",
        whiteSpace: "pre-line"
      },
      ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
      ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
      ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
      ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
      "&light .cm-snippetField": { backgroundColor: "#00000022" },
      "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
      ".cm-snippetFieldPosition": {
        verticalAlign: "text-top",
        width: 0,
        height: "1.15em",
        display: "inline-block",
        margin: "0 -0.7px -.7em",
        borderLeft: "1.4px dotted #888"
      },
      ".cm-completionMatchedText": {
        textDecoration: "underline"
      },
      ".cm-completionDetail": {
        marginLeft: "0.5em",
        fontStyle: "italic"
      },
      ".cm-completionIcon": {
        fontSize: "90%",
        width: ".8em",
        display: "inline-block",
        textAlign: "center",
        paddingRight: ".6em",
        opacity: "0.6",
        boxSizing: "content-box"
      },
      ".cm-completionIcon-function, .cm-completionIcon-method": {
        "&:after": { content: "'\u0192'" }
      },
      ".cm-completionIcon-class": {
        "&:after": { content: "'\u25CB'" }
      },
      ".cm-completionIcon-interface": {
        "&:after": { content: "'\u25CC'" }
      },
      ".cm-completionIcon-variable": {
        "&:after": { content: "'\u{1D465}'" }
      },
      ".cm-completionIcon-constant": {
        "&:after": { content: "'\u{1D436}'" }
      },
      ".cm-completionIcon-type": {
        "&:after": { content: "'\u{1D461}'" }
      },
      ".cm-completionIcon-enum": {
        "&:after": { content: "'\u222A'" }
      },
      ".cm-completionIcon-property": {
        "&:after": { content: "'\u25A1'" }
      },
      ".cm-completionIcon-keyword": {
        "&:after": { content: "'\u{1F511}\uFE0E'" }
        // Disable emoji rendering
      },
      ".cm-completionIcon-namespace": {
        "&:after": { content: "'\u25A2'" }
      },
      ".cm-completionIcon-text": {
        "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
      }
    });
    FieldPos = class {
      constructor(field, line, from2, to) {
        this.field = field;
        this.line = line;
        this.from = from2;
        this.to = to;
      }
    };
    FieldRange = class _FieldRange {
      constructor(field, from2, to) {
        this.field = field;
        this.from = from2;
        this.to = to;
      }
      map(changes) {
        let from2 = changes.mapPos(this.from, -1, MapMode.TrackDel);
        let to = changes.mapPos(this.to, 1, MapMode.TrackDel);
        return from2 == null || to == null ? null : new _FieldRange(this.field, from2, to);
      }
    };
    Snippet = class _Snippet {
      constructor(lines, fieldPositions) {
        this.lines = lines;
        this.fieldPositions = fieldPositions;
      }
      instantiate(state, pos) {
        let text = [], lineStart = [pos];
        let lineObj = state.doc.lineAt(pos), baseIndent = /^\s*/.exec(lineObj.text)[0];
        for (let line of this.lines) {
          if (text.length) {
            let indent2 = baseIndent, tabs = /^\t*/.exec(line)[0].length;
            for (let i = 0; i < tabs; i++)
              indent2 += state.facet(indentUnit);
            lineStart.push(pos + indent2.length - tabs);
            line = indent2 + line.slice(tabs);
          }
          text.push(line);
          pos += line.length + 1;
        }
        let ranges = this.fieldPositions.map((pos2) => new FieldRange(pos2.field, lineStart[pos2.line] + pos2.from, lineStart[pos2.line] + pos2.to));
        return { text, ranges };
      }
      static parse(template) {
        let fields = [];
        let lines = [], positions = [], m;
        for (let line of template.split(/\r\n?|\n/)) {
          while (m = /[#$]\{(?:(\d+)(?::([^{}]*))?|((?:\\[{}]|[^{}])*))\}/.exec(line)) {
            let seq = m[1] ? +m[1] : null, rawName = m[2] || m[3] || "", found = -1;
            let name2 = rawName.replace(/\\[{}]/g, (m2) => m2[1]);
            for (let i = 0; i < fields.length; i++) {
              if (seq != null ? fields[i].seq == seq : name2 ? fields[i].name == name2 : false)
                found = i;
            }
            if (found < 0) {
              let i = 0;
              while (i < fields.length && (seq == null || fields[i].seq != null && fields[i].seq < seq))
                i++;
              fields.splice(i, 0, { seq, name: name2 });
              found = i;
              for (let pos of positions)
                if (pos.field >= found)
                  pos.field++;
            }
            for (let pos of positions)
              if (pos.line == lines.length && pos.from > m.index) {
                let snip = m[2] ? 3 + (m[1] || "").length : 2;
                pos.from -= snip;
                pos.to -= snip;
              }
            positions.push(new FieldPos(found, lines.length, m.index, m.index + name2.length));
            line = line.slice(0, m.index) + rawName + line.slice(m.index + m[0].length);
          }
          line = line.replace(/\\([{}])/g, (_, brace, index) => {
            for (let pos of positions)
              if (pos.line == lines.length && pos.from > index) {
                pos.from--;
                pos.to--;
              }
            return brace;
          });
          lines.push(line);
        }
        return new _Snippet(lines, positions);
      }
    };
    fieldMarker = /* @__PURE__ */ Decoration.widget({ widget: /* @__PURE__ */ new class extends WidgetType {
      toDOM() {
        let span = document.createElement("span");
        span.className = "cm-snippetFieldPosition";
        return span;
      }
      ignoreEvent() {
        return false;
      }
    }() });
    fieldRange = /* @__PURE__ */ Decoration.mark({ class: "cm-snippetField" });
    ActiveSnippet = class _ActiveSnippet {
      constructor(ranges, active) {
        this.ranges = ranges;
        this.active = active;
        this.deco = Decoration.set(ranges.map((r) => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)), true);
      }
      map(changes) {
        let ranges = [];
        for (let r of this.ranges) {
          let mapped = r.map(changes);
          if (!mapped)
            return null;
          ranges.push(mapped);
        }
        return new _ActiveSnippet(ranges, this.active);
      }
      selectionInsideField(sel) {
        return sel.ranges.every((range) => this.ranges.some((r) => r.field == this.active && r.from <= range.from && r.to >= range.to));
      }
    };
    setActive = /* @__PURE__ */ StateEffect.define({
      map(value, changes) {
        return value && value.map(changes);
      }
    });
    moveToField = /* @__PURE__ */ StateEffect.define();
    snippetState = /* @__PURE__ */ StateField.define({
      create() {
        return null;
      },
      update(value, tr) {
        for (let effect2 of tr.effects) {
          if (effect2.is(setActive))
            return effect2.value;
          if (effect2.is(moveToField) && value)
            return new ActiveSnippet(value.ranges, effect2.value);
        }
        if (value && tr.docChanged)
          value = value.map(tr.changes);
        if (value && tr.selection && !value.selectionInsideField(tr.selection))
          value = null;
        return value;
      },
      provide: (f) => EditorView.decorations.from(f, (val) => val ? val.deco : Decoration.none)
    });
    clearSnippet = ({ state, dispatch }) => {
      let active = state.field(snippetState, false);
      if (!active)
        return false;
      dispatch(state.update({ effects: setActive.of(null) }));
      return true;
    };
    nextSnippetField = /* @__PURE__ */ moveField(1);
    prevSnippetField = /* @__PURE__ */ moveField(-1);
    defaultSnippetKeymap = [
      { key: "Tab", run: nextSnippetField, shift: prevSnippetField },
      { key: "Escape", run: clearSnippet }
    ];
    snippetKeymap = /* @__PURE__ */ Facet.define({
      combine(maps) {
        return maps.length ? maps[0] : defaultSnippetKeymap;
      }
    });
    addSnippetKeymap = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.compute([snippetKeymap], (state) => state.facet(snippetKeymap)));
    snippetPointerHandler = /* @__PURE__ */ EditorView.domEventHandlers({
      mousedown(event, view) {
        let active = view.state.field(snippetState, false), pos;
        if (!active || (pos = view.posAtCoords({ x: event.clientX, y: event.clientY })) == null)
          return false;
        let match2 = active.ranges.find((r) => r.from <= pos && r.to >= pos);
        if (!match2 || match2.field == active.active)
          return false;
        view.dispatch({
          selection: fieldSelection(active.ranges, match2.field),
          effects: setActive.of(active.ranges.some((r) => r.field > match2.field) ? new ActiveSnippet(active.ranges, match2.field) : null),
          scrollIntoView: true
        });
        return true;
      }
    });
    defaults2 = {
      brackets: ["(", "[", "{", "'", '"'],
      before: ")]}:;>",
      stringPrefixes: []
    };
    closeBracketEffect = /* @__PURE__ */ StateEffect.define({
      map(value, mapping) {
        let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
        return mapped == null ? void 0 : mapped;
      }
    });
    closedBracket = /* @__PURE__ */ new class extends RangeValue {
    }();
    closedBracket.startSide = 1;
    closedBracket.endSide = -1;
    bracketState = /* @__PURE__ */ StateField.define({
      create() {
        return RangeSet.empty;
      },
      update(value, tr) {
        value = value.map(tr.changes);
        if (tr.selection) {
          let line = tr.state.doc.lineAt(tr.selection.main.head);
          value = value.update({ filter: (from2) => from2 >= line.from && from2 <= line.to });
        }
        for (let effect2 of tr.effects)
          if (effect2.is(closeBracketEffect))
            value = value.update({ add: [closedBracket.range(effect2.value, effect2.value + 1)] });
        return value;
      }
    });
    definedClosing = "()[]{}<>\xAB\xBB\xBB\xAB\uFF3B\uFF3D\uFF5B\uFF5D";
    android = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
    inputHandler2 = /* @__PURE__ */ EditorView.inputHandler.of((view, from2, to, insert2) => {
      if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)
        return false;
      let sel = view.state.selection.main;
      if (insert2.length > 2 || insert2.length == 2 && codePointSize2(codePointAt2(insert2, 0)) == 1 || from2 != sel.from || to != sel.to)
        return false;
      let tr = insertBracket(view.state, insert2);
      if (!tr)
        return false;
      view.dispatch(tr);
      return true;
    });
    deleteBracketPair = ({ state, dispatch }) => {
      if (state.readOnly)
        return false;
      let conf = config2(state, state.selection.main.head);
      let tokens = conf.brackets || defaults2.brackets;
      let dont = null, changes = state.changeByRange((range) => {
        if (range.empty) {
          let before = prevChar(state.doc, range.head);
          for (let token of tokens) {
            if (token == before && nextChar(state.doc, range.head) == closing(codePointAt2(token, 0)))
              return {
                changes: { from: range.head - token.length, to: range.head + token.length },
                range: EditorSelection.cursor(range.head - token.length)
              };
          }
        }
        return { range: dont = range };
      });
      if (!dont)
        dispatch(state.update(changes, { scrollIntoView: true, userEvent: "delete.backward" }));
      return !dont;
    };
    closeBracketsKeymap = [
      { key: "Backspace", run: deleteBracketPair }
    ];
    completionKeymap = [
      { key: "Ctrl-Space", run: startCompletion },
      { mac: "Alt-`", run: startCompletion },
      { mac: "Alt-i", run: startCompletion },
      { key: "Escape", run: closeCompletion },
      { key: "ArrowDown", run: /* @__PURE__ */ moveCompletionSelection(true) },
      { key: "ArrowUp", run: /* @__PURE__ */ moveCompletionSelection(false) },
      { key: "PageDown", run: /* @__PURE__ */ moveCompletionSelection(true, "page") },
      { key: "PageUp", run: /* @__PURE__ */ moveCompletionSelection(false, "page") },
      { key: "Enter", run: acceptCompletion }
    ];
    completionKeymapExt = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.computeN([completionConfig], (state) => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));
  }
});

// node_modules/@codemirror/lang-javascript/dist/index.js
function defID(type) {
  return (node, def) => {
    let id2 = node.node.getChild("VariableDefinition");
    if (id2)
      def(id2, type);
    return true;
  };
}
function getScope(doc2, node) {
  let cached = cache.get(node);
  if (cached)
    return cached;
  let completions = [], top2 = true;
  function def(node2, type) {
    let name2 = doc2.sliceString(node2.from, node2.to);
    completions.push({ label: name2, type });
  }
  node.cursor(IterMode.IncludeAnonymous).iterate((node2) => {
    if (top2) {
      top2 = false;
    } else if (node2.name) {
      let gather = gatherCompletions[node2.name];
      if (gather && gather(node2, def) || ScopeNodes.has(node2.name))
        return false;
    } else if (node2.to - node2.from > 8192) {
      for (let c of getScope(doc2, node2.node))
        completions.push(c);
      return false;
    }
  });
  cache.set(node, completions);
  return completions;
}
function localCompletionSource(context2) {
  let inner = syntaxTree(context2.state).resolveInner(context2.pos, -1);
  if (dontComplete.indexOf(inner.name) > -1)
    return null;
  let isWord = inner.name == "VariableName" || inner.to - inner.from < 20 && Identifier.test(context2.state.sliceDoc(inner.from, inner.to));
  if (!isWord && !context2.explicit)
    return null;
  let options = [];
  for (let pos = inner; pos; pos = pos.parent) {
    if (ScopeNodes.has(pos.name))
      options = options.concat(getScope(context2.state.doc, pos));
  }
  return {
    options,
    from: isWord ? inner.from : context2.pos,
    validFor: Identifier
  };
}
function javascript(config3 = {}) {
  let lang = config3.jsx ? config3.typescript ? tsxLanguage : jsxLanguage : config3.typescript ? typescriptLanguage : javascriptLanguage;
  let completions = config3.typescript ? typescriptSnippets.concat(typescriptKeywords) : snippets.concat(keywords);
  return new LanguageSupport(lang, [
    javascriptLanguage.data.of({
      autocomplete: ifNotIn(dontComplete, completeFromList(completions))
    }),
    javascriptLanguage.data.of({
      autocomplete: localCompletionSource
    }),
    config3.jsx ? autoCloseTags : []
  ]);
}
function findOpenTag(node) {
  for (; ; ) {
    if (node.name == "JSXOpenTag" || node.name == "JSXSelfClosingTag" || node.name == "JSXFragmentTag")
      return node;
    if (node.name == "JSXEscape" || !node.parent)
      return null;
    node = node.parent;
  }
}
function elementName(doc2, tree2, max = doc2.length) {
  for (let ch = tree2 === null || tree2 === void 0 ? void 0 : tree2.firstChild; ch; ch = ch.nextSibling) {
    if (ch.name == "JSXIdentifier" || ch.name == "JSXBuiltin" || ch.name == "JSXNamespacedName" || ch.name == "JSXMemberExpression")
      return doc2.sliceString(ch.from, Math.min(ch.to, max));
  }
  return "";
}
var snippets, typescriptSnippets, cache, ScopeNodes, functionContext, gatherCompletions, Identifier, dontComplete, javascriptLanguage, jsxSublanguage, typescriptLanguage, jsxLanguage, tsxLanguage, kwCompletion, keywords, typescriptKeywords, android2, autoCloseTags;
var init_dist9 = __esm({
  "node_modules/@codemirror/lang-javascript/dist/index.js"() {
    "use strict";
    init_dist6();
    init_dist7();
    init_dist();
    init_dist2();
    init_dist8();
    init_dist3();
    snippets = [
      /* @__PURE__ */ snippetCompletion("function ${name}(${params}) {\n	${}\n}", {
        label: "function",
        detail: "definition",
        type: "keyword"
      }),
      /* @__PURE__ */ snippetCompletion("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
        label: "for",
        detail: "loop",
        type: "keyword"
      }),
      /* @__PURE__ */ snippetCompletion("for (let ${name} of ${collection}) {\n	${}\n}", {
        label: "for",
        detail: "of loop",
        type: "keyword"
      }),
      /* @__PURE__ */ snippetCompletion("do {\n	${}\n} while (${})", {
        label: "do",
        detail: "loop",
        type: "keyword"
      }),
      /* @__PURE__ */ snippetCompletion("while (${}) {\n	${}\n}", {
        label: "while",
        detail: "loop",
        type: "keyword"
      }),
      /* @__PURE__ */ snippetCompletion("try {\n	${}\n} catch (${error}) {\n	${}\n}", {
        label: "try",
        detail: "/ catch block",
        type: "keyword"
      }),
      /* @__PURE__ */ snippetCompletion("if (${}) {\n	${}\n}", {
        label: "if",
        detail: "block",
        type: "keyword"
      }),
      /* @__PURE__ */ snippetCompletion("if (${}) {\n	${}\n} else {\n	${}\n}", {
        label: "if",
        detail: "/ else block",
        type: "keyword"
      }),
      /* @__PURE__ */ snippetCompletion("class ${name} {\n	constructor(${params}) {\n		${}\n	}\n}", {
        label: "class",
        detail: "definition",
        type: "keyword"
      }),
      /* @__PURE__ */ snippetCompletion('import {${names}} from "${module}"\n${}', {
        label: "import",
        detail: "named",
        type: "keyword"
      }),
      /* @__PURE__ */ snippetCompletion('import ${name} from "${module}"\n${}', {
        label: "import",
        detail: "default",
        type: "keyword"
      })
    ];
    typescriptSnippets = /* @__PURE__ */ snippets.concat([
      /* @__PURE__ */ snippetCompletion("interface ${name} {\n	${}\n}", {
        label: "interface",
        detail: "definition",
        type: "keyword"
      }),
      /* @__PURE__ */ snippetCompletion("type ${name} = ${type}", {
        label: "type",
        detail: "definition",
        type: "keyword"
      }),
      /* @__PURE__ */ snippetCompletion("enum ${name} {\n	${}\n}", {
        label: "enum",
        detail: "definition",
        type: "keyword"
      })
    ]);
    cache = /* @__PURE__ */ new NodeWeakMap();
    ScopeNodes = /* @__PURE__ */ new Set([
      "Script",
      "Block",
      "FunctionExpression",
      "FunctionDeclaration",
      "ArrowFunction",
      "MethodDeclaration",
      "ForStatement"
    ]);
    functionContext = ["FunctionDeclaration"];
    gatherCompletions = {
      FunctionDeclaration: /* @__PURE__ */ defID("function"),
      ClassDeclaration: /* @__PURE__ */ defID("class"),
      ClassExpression: () => true,
      EnumDeclaration: /* @__PURE__ */ defID("constant"),
      TypeAliasDeclaration: /* @__PURE__ */ defID("type"),
      NamespaceDeclaration: /* @__PURE__ */ defID("namespace"),
      VariableDefinition(node, def) {
        if (!node.matchContext(functionContext))
          def(node, "variable");
      },
      TypeDefinition(node, def) {
        def(node, "type");
      },
      __proto__: null
    };
    Identifier = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/;
    dontComplete = [
      "TemplateString",
      "String",
      "RegExp",
      "LineComment",
      "BlockComment",
      "VariableDefinition",
      "TypeDefinition",
      "Label",
      "PropertyDefinition",
      "PropertyName",
      "PrivatePropertyDefinition",
      "PrivatePropertyName",
      "JSXText",
      "JSXAttributeValue",
      "JSXOpenTag",
      "JSXCloseTag",
      "JSXSelfClosingTag",
      ".",
      "?."
    ];
    javascriptLanguage = /* @__PURE__ */ LRLanguage.define({
      name: "javascript",
      parser: /* @__PURE__ */ parser.configure({
        props: [
          /* @__PURE__ */ indentNodeProp.add({
            IfStatement: /* @__PURE__ */ continuedIndent({ except: /^\s*({|else\b)/ }),
            TryStatement: /* @__PURE__ */ continuedIndent({ except: /^\s*({|catch\b|finally\b)/ }),
            LabeledStatement: flatIndent,
            SwitchBody: (context2) => {
              let after = context2.textAfter, closed = /^\s*\}/.test(after), isCase = /^\s*(case|default)\b/.test(after);
              return context2.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context2.unit;
            },
            Block: /* @__PURE__ */ delimitedIndent({ closing: "}" }),
            ArrowFunction: (cx) => cx.baseIndent + cx.unit,
            "TemplateString BlockComment": () => null,
            "Statement Property": /* @__PURE__ */ continuedIndent({ except: /^\s*{/ }),
            JSXElement(context2) {
              let closed = /^\s*<\//.test(context2.textAfter);
              return context2.lineIndent(context2.node.from) + (closed ? 0 : context2.unit);
            },
            JSXEscape(context2) {
              let closed = /\s*\}/.test(context2.textAfter);
              return context2.lineIndent(context2.node.from) + (closed ? 0 : context2.unit);
            },
            "JSXOpenTag JSXSelfClosingTag"(context2) {
              return context2.column(context2.node.from) + context2.unit;
            }
          }),
          /* @__PURE__ */ foldNodeProp.add({
            "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": foldInside,
            BlockComment(tree2) {
              return { from: tree2.from + 2, to: tree2.to - 2 };
            }
          })
        ]
      }),
      languageData: {
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
        commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
        indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
        wordChars: "$"
      }
    });
    jsxSublanguage = {
      test: (node) => /^JSX/.test(node.name),
      facet: /* @__PURE__ */ defineLanguageFacet({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
    };
    typescriptLanguage = /* @__PURE__ */ javascriptLanguage.configure({ dialect: "ts" }, "typescript");
    jsxLanguage = /* @__PURE__ */ javascriptLanguage.configure({
      dialect: "jsx",
      props: [/* @__PURE__ */ sublanguageProp.add((n) => n.isTop ? [jsxSublanguage] : void 0)]
    });
    tsxLanguage = /* @__PURE__ */ javascriptLanguage.configure({
      dialect: "jsx ts",
      props: [/* @__PURE__ */ sublanguageProp.add((n) => n.isTop ? [jsxSublanguage] : void 0)]
    }, "typescript");
    kwCompletion = (name2) => ({ label: name2, type: "keyword" });
    keywords = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(kwCompletion);
    typescriptKeywords = /* @__PURE__ */ keywords.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(kwCompletion));
    android2 = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
    autoCloseTags = /* @__PURE__ */ EditorView.inputHandler.of((view, from2, to, text, defaultInsert) => {
      if ((android2 ? view.composing : view.compositionStarted) || view.state.readOnly || from2 != to || text != ">" && text != "/" || !javascriptLanguage.isActiveAt(view.state, from2, -1))
        return false;
      let base2 = defaultInsert(), { state } = base2;
      let closeTags = state.changeByRange((range) => {
        var _a2;
        let { head } = range, around = syntaxTree(state).resolveInner(head - 1, -1), name2;
        if (around.name == "JSXStartTag")
          around = around.parent;
        if (state.doc.sliceString(head - 1, head) != text || around.name == "JSXAttributeValue" && around.to > head) ;
        else if (text == ">" && around.name == "JSXFragmentTag") {
          return { range, changes: { from: head, insert: `</>` } };
        } else if (text == "/" && around.name == "JSXStartCloseTag") {
          let empty2 = around.parent, base3 = empty2.parent;
          if (base3 && empty2.from == head - 2 && ((name2 = elementName(state.doc, base3.firstChild, head)) || ((_a2 = base3.firstChild) === null || _a2 === void 0 ? void 0 : _a2.name) == "JSXFragmentTag")) {
            let insert2 = `${name2}>`;
            return { range: EditorSelection.cursor(head + insert2.length, -1), changes: { from: head, insert: insert2 } };
          }
        } else if (text == ">") {
          let openTag = findOpenTag(around);
          if (openTag && openTag.name == "JSXOpenTag" && !/^\/?>|^<\//.test(state.doc.sliceString(head, head + 2)) && (name2 = elementName(state.doc, openTag, head)))
            return { range, changes: { from: head, insert: `</${name2}>` } };
        }
        return { range };
      });
      if (closeTags.changes.empty)
        return false;
      view.dispatch([
        base2,
        state.update(closeTags, { userEvent: "input.complete", scrollIntoView: true })
      ]);
      return true;
    });
  }
});

// node_modules/@lezer/python/dist/index.js
function isLineBreak(ch) {
  return ch == newline2 || ch == carriageReturn;
}
function isHex(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function Context(parent, indent2, flags) {
  this.parent = parent;
  this.indent = indent2;
  this.flags = flags;
  this.hash = (parent ? parent.hash + parent.hash << 8 : 0) + indent2 + (indent2 << 4) + flags + (flags << 6);
}
function countIndent(space5) {
  let depth = 0;
  for (let i = 0; i < space5.length; i++)
    depth += space5.charCodeAt(i) == tab ? 8 - depth % 8 : 1;
  return depth;
}
function skipEscape(input2, ch) {
  if (ch == letter_o) {
    for (let i = 0; i < 2 && input2.next >= 48 && input2.next <= 55; i++) input2.advance();
  } else if (ch == letter_x) {
    for (let i = 0; i < 2 && isHex(input2.next); i++) input2.advance();
  } else if (ch == letter_u) {
    for (let i = 0; i < 4 && isHex(input2.next); i++) input2.advance();
  } else if (ch == letter_U) {
    for (let i = 0; i < 8 && isHex(input2.next); i++) input2.advance();
  } else if (ch == letter_N) {
    if (input2.next == braceOpen) {
      input2.advance();
      while (input2.next >= 0 && input2.next != braceClose && input2.next != singleQuote && input2.next != doubleQuote && input2.next != newline2) input2.advance();
      if (input2.next == braceClose) input2.advance();
    }
  }
}
var printKeyword, indent, dedent, newline$1, blankLineStart, newlineBracketed, eof, stringContent, Escape, replacementStart, stringEnd, ParenL, ParenthesizedExpression, TupleExpression, ComprehensionExpression, BracketL, ArrayExpression, ArrayComprehensionExpression, BraceL, DictionaryExpression, DictionaryComprehensionExpression, SetExpression, SetComprehensionExpression, ArgList, subscript, String$1, stringStart, stringStartD, stringStartL, stringStartLD, stringStartR, stringStartRD, stringStartRL, stringStartRLD, FormatString, stringStartF, stringStartFD, stringStartFL, stringStartFLD, stringStartFR, stringStartFRD, stringStartFRL, stringStartFRLD, FormatReplacement, nestedFormatReplacement, importList, TypeParamList, ParamList, SequencePattern, MappingPattern, PatternArgList, newline2, carriageReturn, space2, tab, hash, parenOpen, dot2, braceOpen, braceClose, singleQuote, doubleQuote, backslash, letter_o, letter_x, letter_N, letter_u, letter_U, bracketed, newlines, indentation, cx_Bracketed, cx_String, cx_DoubleQuote, cx_Long, cx_Raw, cx_Format, topIndent2, stringFlags, trackIndent, legacyPrint, strings, pythonHighlighting, spec_identifier2, parser2;
var init_dist10 = __esm({
  "node_modules/@lezer/python/dist/index.js"() {
    "use strict";
    init_dist4();
    init_dist5();
    printKeyword = 1;
    indent = 194;
    dedent = 195;
    newline$1 = 196;
    blankLineStart = 197;
    newlineBracketed = 198;
    eof = 199;
    stringContent = 200;
    Escape = 2;
    replacementStart = 3;
    stringEnd = 201;
    ParenL = 24;
    ParenthesizedExpression = 25;
    TupleExpression = 49;
    ComprehensionExpression = 50;
    BracketL = 55;
    ArrayExpression = 56;
    ArrayComprehensionExpression = 57;
    BraceL = 59;
    DictionaryExpression = 60;
    DictionaryComprehensionExpression = 61;
    SetExpression = 62;
    SetComprehensionExpression = 63;
    ArgList = 65;
    subscript = 238;
    String$1 = 71;
    stringStart = 241;
    stringStartD = 242;
    stringStartL = 243;
    stringStartLD = 244;
    stringStartR = 245;
    stringStartRD = 246;
    stringStartRL = 247;
    stringStartRLD = 248;
    FormatString = 72;
    stringStartF = 249;
    stringStartFD = 250;
    stringStartFL = 251;
    stringStartFLD = 252;
    stringStartFR = 253;
    stringStartFRD = 254;
    stringStartFRL = 255;
    stringStartFRLD = 256;
    FormatReplacement = 73;
    nestedFormatReplacement = 77;
    importList = 263;
    TypeParamList = 112;
    ParamList = 130;
    SequencePattern = 151;
    MappingPattern = 152;
    PatternArgList = 155;
    newline2 = 10;
    carriageReturn = 13;
    space2 = 32;
    tab = 9;
    hash = 35;
    parenOpen = 40;
    dot2 = 46;
    braceOpen = 123;
    braceClose = 125;
    singleQuote = 39;
    doubleQuote = 34;
    backslash = 92;
    letter_o = 111;
    letter_x = 120;
    letter_N = 78;
    letter_u = 117;
    letter_U = 85;
    bracketed = /* @__PURE__ */ new Set([
      ParenthesizedExpression,
      TupleExpression,
      ComprehensionExpression,
      importList,
      ArgList,
      ParamList,
      ArrayExpression,
      ArrayComprehensionExpression,
      subscript,
      SetExpression,
      SetComprehensionExpression,
      FormatString,
      FormatReplacement,
      nestedFormatReplacement,
      DictionaryExpression,
      DictionaryComprehensionExpression,
      SequencePattern,
      MappingPattern,
      PatternArgList,
      TypeParamList
    ]);
    newlines = new ExternalTokenizer((input2, stack) => {
      let prev;
      if (input2.next < 0) {
        input2.acceptToken(eof);
      } else if (stack.context.flags & cx_Bracketed) {
        if (isLineBreak(input2.next)) input2.acceptToken(newlineBracketed, 1);
      } else if (((prev = input2.peek(-1)) < 0 || isLineBreak(prev)) && stack.canShift(blankLineStart)) {
        let spaces2 = 0;
        while (input2.next == space2 || input2.next == tab) {
          input2.advance();
          spaces2++;
        }
        if (input2.next == newline2 || input2.next == carriageReturn || input2.next == hash)
          input2.acceptToken(blankLineStart, -spaces2);
      } else if (isLineBreak(input2.next)) {
        input2.acceptToken(newline$1, 1);
      }
    }, { contextual: true });
    indentation = new ExternalTokenizer((input2, stack) => {
      let context2 = stack.context;
      if (context2.flags) return;
      let prev = input2.peek(-1);
      if (prev == newline2 || prev == carriageReturn) {
        let depth = 0, chars = 0;
        for (; ; ) {
          if (input2.next == space2) depth++;
          else if (input2.next == tab) depth += 8 - depth % 8;
          else break;
          input2.advance();
          chars++;
        }
        if (depth != context2.indent && input2.next != newline2 && input2.next != carriageReturn && input2.next != hash) {
          if (depth < context2.indent) input2.acceptToken(dedent, -chars);
          else input2.acceptToken(indent);
        }
      }
    });
    cx_Bracketed = 1;
    cx_String = 2;
    cx_DoubleQuote = 4;
    cx_Long = 8;
    cx_Raw = 16;
    cx_Format = 32;
    topIndent2 = new Context(null, 0, 0);
    stringFlags = new Map([
      [stringStart, 0],
      [stringStartD, cx_DoubleQuote],
      [stringStartL, cx_Long],
      [stringStartLD, cx_Long | cx_DoubleQuote],
      [stringStartR, cx_Raw],
      [stringStartRD, cx_Raw | cx_DoubleQuote],
      [stringStartRL, cx_Raw | cx_Long],
      [stringStartRLD, cx_Raw | cx_Long | cx_DoubleQuote],
      [stringStartF, cx_Format],
      [stringStartFD, cx_Format | cx_DoubleQuote],
      [stringStartFL, cx_Format | cx_Long],
      [stringStartFLD, cx_Format | cx_Long | cx_DoubleQuote],
      [stringStartFR, cx_Format | cx_Raw],
      [stringStartFRD, cx_Format | cx_Raw | cx_DoubleQuote],
      [stringStartFRL, cx_Format | cx_Raw | cx_Long],
      [stringStartFRLD, cx_Format | cx_Raw | cx_Long | cx_DoubleQuote]
    ].map(([term, flags]) => [term, flags | cx_String]));
    trackIndent = new ContextTracker({
      start: topIndent2,
      reduce(context2, term, _, input2) {
        if (context2.flags & cx_Bracketed && bracketed.has(term) || (term == String$1 || term == FormatString) && context2.flags & cx_String)
          return context2.parent;
        return context2;
      },
      shift(context2, term, stack, input2) {
        if (term == indent)
          return new Context(context2, countIndent(input2.read(input2.pos, stack.pos)), 0);
        if (term == dedent)
          return context2.parent;
        if (term == ParenL || term == BracketL || term == BraceL || term == replacementStart)
          return new Context(context2, 0, cx_Bracketed);
        if (stringFlags.has(term))
          return new Context(context2, 0, stringFlags.get(term) | context2.flags & cx_Bracketed);
        return context2;
      },
      hash(context2) {
        return context2.hash;
      }
    });
    legacyPrint = new ExternalTokenizer((input2) => {
      for (let i = 0; i < 5; i++) {
        if (input2.next != "print".charCodeAt(i)) return;
        input2.advance();
      }
      if (/\w/.test(String.fromCharCode(input2.next))) return;
      for (let off = 0; ; off++) {
        let next = input2.peek(off);
        if (next == space2 || next == tab) continue;
        if (next != parenOpen && next != dot2 && next != newline2 && next != carriageReturn && next != hash)
          input2.acceptToken(printKeyword);
        return;
      }
    });
    strings = new ExternalTokenizer((input2, stack) => {
      let { flags } = stack.context;
      let quote = flags & cx_DoubleQuote ? doubleQuote : singleQuote;
      let long = (flags & cx_Long) > 0;
      let escapes = !(flags & cx_Raw);
      let format = (flags & cx_Format) > 0;
      let start = input2.pos;
      for (; ; ) {
        if (input2.next < 0) {
          break;
        } else if (format && input2.next == braceOpen) {
          if (input2.peek(1) == braceOpen) {
            input2.advance(2);
          } else {
            if (input2.pos == start) {
              input2.acceptToken(replacementStart, 1);
              return;
            }
            break;
          }
        } else if (escapes && input2.next == backslash) {
          if (input2.pos == start) {
            input2.advance();
            let escaped = input2.next;
            if (escaped >= 0) {
              input2.advance();
              skipEscape(input2, escaped);
            }
            input2.acceptToken(Escape);
            return;
          }
          break;
        } else if (input2.next == backslash && !escapes && input2.peek(1) > -1) {
          input2.advance(2);
        } else if (input2.next == quote && (!long || input2.peek(1) == quote && input2.peek(2) == quote)) {
          if (input2.pos == start) {
            input2.acceptToken(stringEnd, long ? 3 : 1);
            return;
          }
          break;
        } else if (input2.next == newline2) {
          if (long) {
            input2.advance();
          } else if (input2.pos == start) {
            input2.acceptToken(stringEnd);
            return;
          }
          break;
        } else {
          input2.advance();
        }
      }
      if (input2.pos > start) input2.acceptToken(stringContent);
    });
    pythonHighlighting = styleTags({
      'async "*" "**" FormatConversion FormatSpec': tags.modifier,
      "for while if elif else try except finally return raise break continue with pass assert await yield match case": tags.controlKeyword,
      "in not and or is del": tags.operatorKeyword,
      "from def class global nonlocal lambda": tags.definitionKeyword,
      import: tags.moduleKeyword,
      "with as print": tags.keyword,
      Boolean: tags.bool,
      None: tags.null,
      VariableName: tags.variableName,
      "CallExpression/VariableName": tags.function(tags.variableName),
      "FunctionDefinition/VariableName": tags.function(tags.definition(tags.variableName)),
      "ClassDefinition/VariableName": tags.definition(tags.className),
      PropertyName: tags.propertyName,
      "CallExpression/MemberExpression/PropertyName": tags.function(tags.propertyName),
      Comment: tags.lineComment,
      Number: tags.number,
      String: tags.string,
      FormatString: tags.special(tags.string),
      Escape: tags.escape,
      UpdateOp: tags.updateOperator,
      "ArithOp!": tags.arithmeticOperator,
      BitOp: tags.bitwiseOperator,
      CompareOp: tags.compareOperator,
      AssignOp: tags.definitionOperator,
      Ellipsis: tags.punctuation,
      At: tags.meta,
      "( )": tags.paren,
      "[ ]": tags.squareBracket,
      "{ }": tags.brace,
      ".": tags.derefOperator,
      ", ;": tags.separator
    });
    spec_identifier2 = { __proto__: null, await: 44, or: 54, and: 56, in: 60, not: 62, is: 64, if: 70, else: 72, lambda: 76, yield: 94, from: 96, async: 102, for: 104, None: 162, True: 164, False: 164, del: 178, pass: 182, break: 186, continue: 190, return: 194, raise: 202, import: 206, as: 208, global: 212, nonlocal: 214, assert: 218, type: 223, elif: 236, while: 240, try: 246, except: 248, finally: 250, with: 254, def: 258, class: 268, match: 279, case: 285 };
    parser2 = LRParser.deserialize({
      version: 14,
      states: "##jO`QeOOP$}OSOOO&WQtO'#HUOOQS'#Co'#CoOOQS'#Cp'#CpO'vQdO'#CnO*UQtO'#HTOOQS'#HU'#HUOOQS'#DU'#DUOOQS'#HT'#HTO*rQdO'#D_O+VQdO'#DfO+gQdO'#DjO+zOWO'#DuO,VOWO'#DvO.[QtO'#GuOOQS'#Gu'#GuO'vQdO'#GtO0ZQtO'#GtOOQS'#Eb'#EbO0rQdO'#EcOOQS'#Gs'#GsO0|QdO'#GrOOQV'#Gr'#GrO1XQdO'#FYOOQS'#G^'#G^O1^QdO'#FXOOQV'#IS'#ISOOQV'#Gq'#GqOOQV'#Fq'#FqQ`QeOOO'vQdO'#CqO1lQdO'#C}O1sQdO'#DRO2RQdO'#HYO2cQtO'#EVO'vQdO'#EWOOQS'#EY'#EYOOQS'#E['#E[OOQS'#E^'#E^O2wQdO'#E`O3_QdO'#EdO3rQdO'#EfO3zQtO'#EfO1XQdO'#EiO0rQdO'#ElO1XQdO'#EnO0rQdO'#EtO0rQdO'#EwO4VQdO'#EyO4^QdO'#FOO4iQdO'#EzO0rQdO'#FOO1XQdO'#FQO1XQdO'#FVO4nQdO'#F[P4uOdO'#GpPOOO)CBd)CBdOOQS'#Ce'#CeOOQS'#Cf'#CfOOQS'#Cg'#CgOOQS'#Ch'#ChOOQS'#Ci'#CiOOQS'#Cj'#CjOOQS'#Cl'#ClO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO5TQdO'#DoOOQS,5:Y,5:YO5hQdO'#HdOOQS,5:],5:]O5uQ!fO,5:]O5zQtO,59YO1lQdO,59bO1lQdO,59bO1lQdO,59bO8jQdO,59bO8oQdO,59bO8vQdO,59jO8}QdO'#HTO:TQdO'#HSOOQS'#HS'#HSOOQS'#D['#D[O:lQdO,59aO'vQdO,59aO:zQdO,59aOOQS,59y,59yO;PQdO,5:RO'vQdO,5:ROOQS,5:Q,5:QO;_QdO,5:QO;dQdO,5:XO'vQdO,5:XO'vQdO,5:VOOQS,5:U,5:UO;uQdO,5:UO;zQdO,5:WOOOW'#Fy'#FyO<POWO,5:aOOQS,5:a,5:aO<[QdO'#HwOOOW'#Dw'#DwOOOW'#Fz'#FzO<lOWO,5:bOOQS,5:b,5:bOOQS'#F}'#F}O<zQtO,5:iO?lQtO,5=`O@VQ#xO,5=`O@vQtO,5=`OOQS,5:},5:}OA_QeO'#GWOBqQdO,5;^OOQV,5=^,5=^OB|QtO'#IPOCkQdO,5;tOOQS-E:[-E:[OOQV,5;s,5;sO4dQdO'#FQOOQV-E9o-E9oOCsQtO,59]OEzQtO,59iOFeQdO'#HVOFpQdO'#HVO1XQdO'#HVOF{QdO'#DTOGTQdO,59mOGYQdO'#HZO'vQdO'#HZO0rQdO,5=tOOQS,5=t,5=tO0rQdO'#EROOQS'#ES'#ESOGwQdO'#GPOHXQdO,58|OHXQdO,58|O*xQdO,5:oOHgQtO'#H]OOQS,5:r,5:rOOQS,5:z,5:zOHzQdO,5;OOI]QdO'#IOO1XQdO'#H}OOQS,5;Q,5;QOOQS'#GT'#GTOIqQtO,5;QOJPQdO,5;QOJUQdO'#IQOOQS,5;T,5;TOJdQdO'#H|OOQS,5;W,5;WOJuQdO,5;YO4iQdO,5;`O4iQdO,5;cOJ}QtO'#ITO'vQdO'#ITOKXQdO,5;eO4VQdO,5;eO0rQdO,5;jO1XQdO,5;lOK^QeO'#EuOLjQgO,5;fO!!kQdO'#IUO4iQdO,5;jO!!vQdO,5;lO!#OQdO,5;qO!#ZQtO,5;vO'vQdO,5;vPOOO,5=[,5=[P!#bOSO,5=[P!#jOdO,5=[O!&bQtO1G.jO!&iQtO1G.jO!)YQtO1G.jO!)dQtO1G.jO!+}QtO1G.jO!,bQtO1G.jO!,uQdO'#HcO!-TQtO'#GuO0rQdO'#HcO!-_QdO'#HbOOQS,5:Z,5:ZO!-gQdO,5:ZO!-lQdO'#HeO!-wQdO'#HeO!.[QdO,5>OOOQS'#Ds'#DsOOQS1G/w1G/wOOQS1G.|1G.|O!/[QtO1G.|O!/cQtO1G.|O1lQdO1G.|O!0OQdO1G/UOOQS'#DZ'#DZO0rQdO,59tOOQS1G.{1G.{O!0VQdO1G/eO!0gQdO1G/eO!0oQdO1G/fO'vQdO'#H[O!0tQdO'#H[O!0yQtO1G.{O!1ZQdO,59iO!2aQdO,5=zO!2qQdO,5=zO!2yQdO1G/mO!3OQtO1G/mOOQS1G/l1G/lO!3`QdO,5=uO!4VQdO,5=uO0rQdO1G/qO!4tQdO1G/sO!4yQtO1G/sO!5ZQtO1G/qOOQS1G/p1G/pOOQS1G/r1G/rOOOW-E9w-E9wOOQS1G/{1G/{O!5kQdO'#HxO0rQdO'#HxO!5|QdO,5>cOOOW-E9x-E9xOOQS1G/|1G/|OOQS-E9{-E9{O!6[Q#xO1G2zO!6{QtO1G2zO'vQdO,5<jOOQS,5<j,5<jOOQS-E9|-E9|OOQS,5<r,5<rOOQS-E:U-E:UOOQV1G0x1G0xO1XQdO'#GRO!7dQtO,5>kOOQS1G1`1G1`O!8RQdO1G1`OOQS'#DV'#DVO0rQdO,5=qOOQS,5=q,5=qO!8WQdO'#FrO!8cQdO,59oO!8kQdO1G/XO!8uQtO,5=uOOQS1G3`1G3`OOQS,5:m,5:mO!9fQdO'#GtOOQS,5<k,5<kOOQS-E9}-E9}O!9wQdO1G.hOOQS1G0Z1G0ZO!:VQdO,5=wO!:gQdO,5=wO0rQdO1G0jO0rQdO1G0jO!:xQdO,5>jO!;ZQdO,5>jO1XQdO,5>jO!;lQdO,5>iOOQS-E:R-E:RO!;qQdO1G0lO!;|QdO1G0lO!<RQdO,5>lO!<aQdO,5>lO!<oQdO,5>hO!=VQdO,5>hO!=hQdO'#EpO0rQdO1G0tO!=sQdO1G0tO!=xQgO1G0zO!AvQgO1G0}O!EqQdO,5>oO!E{QdO,5>oO!FTQtO,5>oO0rQdO1G1PO!F_QdO1G1PO4iQdO1G1UO!!vQdO1G1WOOQV,5;a,5;aO!FdQfO,5;aO!FiQgO1G1QO!JjQdO'#GZO4iQdO1G1QO4iQdO1G1QO!JzQdO,5>pO!KXQdO,5>pO1XQdO,5>pOOQV1G1U1G1UO!KaQdO'#FSO!KrQ!fO1G1WO!KzQdO1G1WOOQV1G1]1G1]O4iQdO1G1]O!LPQdO1G1]O!LXQdO'#F^OOQV1G1b1G1bO!#ZQtO1G1bPOOO1G2v1G2vP!L^OSO1G2vOOQS,5=},5=}OOQS'#Dp'#DpO0rQdO,5=}O!LfQdO,5=|O!LyQdO,5=|OOQS1G/u1G/uO!MRQdO,5>PO!McQdO,5>PO!MkQdO,5>PO!NOQdO,5>PO!N`QdO,5>POOQS1G3j1G3jOOQS7+$h7+$hO!8kQdO7+$pO#!RQdO1G.|O#!YQdO1G.|OOQS1G/`1G/`OOQS,5<`,5<`O'vQdO,5<`OOQS7+%P7+%PO#!aQdO7+%POOQS-E9r-E9rOOQS7+%Q7+%QO#!qQdO,5=vO'vQdO,5=vOOQS7+$g7+$gO#!vQdO7+%PO##OQdO7+%QO##TQdO1G3fOOQS7+%X7+%XO##eQdO1G3fO##mQdO7+%XOOQS,5<_,5<_O'vQdO,5<_O##rQdO1G3aOOQS-E9q-E9qO#$iQdO7+%]OOQS7+%_7+%_O#$wQdO1G3aO#%fQdO7+%_O#%kQdO1G3gO#%{QdO1G3gO#&TQdO7+%]O#&YQdO,5>dO#&sQdO,5>dO#&sQdO,5>dOOQS'#Dx'#DxO#'UO&jO'#DzO#'aO`O'#HyOOOW1G3}1G3}O#'fQdO1G3}O#'nQdO1G3}O#'yQ#xO7+(fO#(jQtO1G2UP#)TQdO'#GOOOQS,5<m,5<mOOQS-E:P-E:POOQS7+&z7+&zOOQS1G3]1G3]OOQS,5<^,5<^OOQS-E9p-E9pOOQS7+$s7+$sO#)bQdO,5=`O#){QdO,5=`O#*^QtO,5<aO#*qQdO1G3cOOQS-E9s-E9sOOQS7+&U7+&UO#+RQdO7+&UO#+aQdO,5<nO#+uQdO1G4UOOQS-E:Q-E:QO#,WQdO1G4UOOQS1G4T1G4TOOQS7+&W7+&WO#,iQdO7+&WOOQS,5<p,5<pO#,tQdO1G4WOOQS-E:S-E:SOOQS,5<l,5<lO#-SQdO1G4SOOQS-E:O-E:OO1XQdO'#EqO#-jQdO'#EqO#-uQdO'#IRO#-}QdO,5;[OOQS7+&`7+&`O0rQdO7+&`O#.SQgO7+&fO!JmQdO'#GXO4iQdO7+&fO4iQdO7+&iO#2QQtO,5<tO'vQdO,5<tO#2[QdO1G4ZOOQS-E:W-E:WO#2fQdO1G4ZO4iQdO7+&kO0rQdO7+&kOOQV7+&p7+&pO!KrQ!fO7+&rO!KzQdO7+&rO`QeO1G0{OOQV-E:X-E:XO4iQdO7+&lO4iQdO7+&lOOQV,5<u,5<uO#2nQdO,5<uO!JmQdO,5<uOOQV7+&l7+&lO#2yQgO7+&lO#6tQdO,5<vO#7PQdO1G4[OOQS-E:Y-E:YO#7^QdO1G4[O#7fQdO'#IWO#7tQdO'#IWO1XQdO'#IWOOQS'#IW'#IWO#8PQdO'#IVOOQS,5;n,5;nO#8XQdO,5;nO0rQdO'#FUOOQV7+&r7+&rO4iQdO7+&rOOQV7+&w7+&wO4iQdO7+&wO#8^QfO,5;xOOQV7+&|7+&|POOO7+(b7+(bO#8cQdO1G3iOOQS,5<c,5<cO#8qQdO1G3hOOQS-E9u-E9uO#9UQdO,5<dO#9aQdO,5<dO#9tQdO1G3kOOQS-E9v-E9vO#:UQdO1G3kO#:^QdO1G3kO#:nQdO1G3kO#:UQdO1G3kOOQS<<H[<<H[O#:yQtO1G1zOOQS<<Hk<<HkP#;WQdO'#FtO8vQdO1G3bO#;eQdO1G3bO#;jQdO<<HkOOQS<<Hl<<HlO#;zQdO7+)QOOQS<<Hs<<HsO#<[QtO1G1yP#<{QdO'#FsO#=YQdO7+)RO#=jQdO7+)RO#=rQdO<<HwO#=wQdO7+({OOQS<<Hy<<HyO#>nQdO,5<bO'vQdO,5<bOOQS-E9t-E9tOOQS<<Hw<<HwOOQS,5<g,5<gO0rQdO,5<gO#>sQdO1G4OOOQS-E9y-E9yO#?^QdO1G4OO<[QdO'#H{OOOO'#D{'#D{OOOO'#F|'#F|O#?oO&jO,5:fOOOW,5>e,5>eOOOW7+)i7+)iO#?zQdO7+)iO#@SQdO1G2zO#@mQdO1G2zP'vQdO'#FuO0rQdO<<IpO1XQdO1G2YP1XQdO'#GSO#AOQdO7+)pO#AaQdO7+)pOOQS<<Ir<<IrP1XQdO'#GUP0rQdO'#GQOOQS,5;],5;]O#ArQdO,5>mO#BQQdO,5>mOOQS1G0v1G0vOOQS<<Iz<<IzOOQV-E:V-E:VO4iQdO<<JQOOQV,5<s,5<sO4iQdO,5<sOOQV<<JQ<<JQOOQV<<JT<<JTO#BYQtO1G2`P#BdQdO'#GYO#BkQdO7+)uO#BuQgO<<JVO4iQdO<<JVOOQV<<J^<<J^O4iQdO<<J^O!KrQ!fO<<J^O#FpQgO7+&gOOQV<<JW<<JWO#FzQgO<<JWOOQV1G2a1G2aO1XQdO1G2aO#JuQdO1G2aO4iQdO<<JWO1XQdO1G2bP0rQdO'#G[O#KQQdO7+)vO#K_QdO7+)vOOQS'#FT'#FTO0rQdO,5>rO#KgQdO,5>rO#KrQdO,5>rO#K}QdO,5>qO#L`QdO,5>qOOQS1G1Y1G1YOOQS,5;p,5;pOOQV<<Jc<<JcO#LhQdO1G1dOOQS7+)T7+)TP#LmQdO'#FwO#L}QdO1G2OO#MbQdO1G2OO#MrQdO1G2OP#M}QdO'#FxO#N[QdO7+)VO#NlQdO7+)VO#NlQdO7+)VO#NtQdO7+)VO$ UQdO7+(|O8vQdO7+(|OOQSAN>VAN>VO$ oQdO<<LmOOQSAN>cAN>cO0rQdO1G1|O$!PQtO1G1|P$!ZQdO'#FvOOQS1G2R1G2RP$!hQdO'#F{O$!uQdO7+)jO$#`QdO,5>gOOOO-E9z-E9zOOOW<<MT<<MTO$#nQdO7+(fOOQSAN?[AN?[OOQS7+'t7+'tO$$XQdO<<M[OOQS,5<q,5<qO$$jQdO1G4XOOQS-E:T-E:TOOQVAN?lAN?lOOQV1G2_1G2_O4iQdOAN?qO$$xQgOAN?qOOQVAN?xAN?xO4iQdOAN?xOOQV<<JR<<JRO4iQdOAN?rO4iQdO7+'{OOQV7+'{7+'{O1XQdO7+'{OOQVAN?rAN?rOOQS7+'|7+'|O$(sQdO<<MbOOQS1G4^1G4^O0rQdO1G4^OOQS,5<w,5<wO$)QQdO1G4]OOQS-E:Z-E:ZOOQU'#G_'#G_O$)cQfO7+'OO$)nQdO'#F_O$*uQdO7+'jO$+VQdO7+'jOOQS7+'j7+'jO$+bQdO<<LqO$+rQdO<<LqO$+rQdO<<LqO$+zQdO'#H^OOQS<<Lh<<LhO$,UQdO<<LhOOQS7+'h7+'hOOQS'#D|'#D|OOOO1G4R1G4RO$,oQdO1G4RO$,wQdO1G4RP!=hQdO'#GVOOQVG25]G25]O4iQdOG25]OOQVG25dG25dOOQVG25^G25^OOQV<<Kg<<KgO4iQdO<<KgOOQS7+)x7+)xP$-SQdO'#G]OOQU-E:]-E:]OOQV<<Jj<<JjO$-vQtO'#FaOOQS'#Fc'#FcO$.WQdO'#FbO$.xQdO'#FbOOQS'#Fb'#FbO$.}QdO'#IYO$)nQdO'#FiO$)nQdO'#FiO$/fQdO'#FjO$)nQdO'#FkO$/mQdO'#IZOOQS'#IZ'#IZO$0[QdO,5;yOOQS<<KU<<KUO$0dQdO<<KUO$0tQdOANB]O$1UQdOANB]O$1^QdO'#H_OOQS'#H_'#H_O1sQdO'#DcO$1wQdO,5=xOOQSANBSANBSOOOO7+)m7+)mO$2`QdO7+)mOOQVLD*wLD*wOOQVANARANARO5uQ!fO'#GaO$2hQtO,5<SO$)nQdO'#FmOOQS,5<W,5<WOOQS'#Fd'#FdO$3YQdO,5;|O$3_QdO,5;|OOQS'#Fg'#FgO$)nQdO'#G`O$4PQdO,5<QO$4kQdO,5>tO$4{QdO,5>tO1XQdO,5<PO$5^QdO,5<TO$5cQdO,5<TO$)nQdO'#I[O$5hQdO'#I[O$5mQdO,5<UOOQS,5<V,5<VO0rQdO'#FpOOQU1G1e1G1eO4iQdO1G1eOOQSAN@pAN@pO$5rQdOG27wO$6SQdO,59}OOQS1G3d1G3dOOOO<<MX<<MXOOQS,5<{,5<{OOQS-E:_-E:_O$6XQtO'#FaO$6`QdO'#I]O$6nQdO'#I]O$6vQdO,5<XOOQS1G1h1G1hO$6{QdO1G1hO$7QQdO,5<zOOQS-E:^-E:^O$7lQdO,5=OO$8TQdO1G4`OOQS-E:b-E:bOOQS1G1k1G1kOOQS1G1o1G1oO$8eQdO,5>vO$)nQdO,5>vOOQS1G1p1G1pOOQS,5<[,5<[OOQU7+'P7+'PO$+zQdO1G/iO$)nQdO,5<YO$8sQdO,5>wO$8zQdO,5>wOOQS1G1s1G1sOOQS7+'S7+'SP$)nQdO'#GdO$9SQdO1G4bO$9^QdO1G4bO$9fQdO1G4bOOQS7+%T7+%TO$9tQdO1G1tO$:SQtO'#FaO$:ZQdO,5<}OOQS,5<},5<}O$:iQdO1G4cOOQS-E:a-E:aO$)nQdO,5<|O$:pQdO,5<|O$:uQdO7+)|OOQS-E:`-E:`O$;PQdO7+)|O$)nQdO,5<ZP$)nQdO'#GcO$;XQdO1G2hO$)nQdO1G2hP$;gQdO'#GbO$;nQdO<<MhO$;xQdO1G1uO$<WQdO7+(SO8vQdO'#C}O8vQdO,59bO8vQdO,59bO8vQdO,59bO$<fQtO,5=`O8vQdO1G.|O0rQdO1G/XO0rQdO7+$pP$<yQdO'#GOO'vQdO'#GtO$=WQdO,59bO$=]QdO,59bO$=dQdO,59mO$=iQdO1G/UO1sQdO'#DRO8vQdO,59j",
      stateData: "$>S~O%cOS%^OSSOS%]PQ~OPdOVaOfoOhYOopOs!POvqO!PrO!Q{O!T!SO!U!RO!XZO!][O!h`O!r`O!s`O!t`O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#l!QO#o!TO#s!UO#u!VO#z!WO#}hO$P!XO%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~O%]!YO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%j![O%k!]O%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aO~Ok%xXl%xXm%xXn%xXo%xXp%xXs%xXz%xX{%xX!x%xX#g%xX%[%xX%_%xX%z%xXg%xX!T%xX!U%xX%{%xX!W%xX![%xX!Q%xX#[%xXt%xX!m%xX~P%SOfoOhYO!XZO!][O!h`O!r`O!s`O!t`O%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~Oz%wX{%wX#g%wX%[%wX%_%wX%z%wX~Ok!pOl!qOm!oOn!oOo!rOp!sOs!tO!x%wX~P)pOV!zOg!|Oo0cOv0qO!PrO~P'vOV#OOo0cOv0qO!W#PO~P'vOV#SOa#TOo0cOv0qO![#UO~P'vOQ#XO%`#XO%a#ZO~OQ#^OR#[O%`#^O%a#`O~OV%iX_%iXa%iXh%iXk%iXl%iXm%iXn%iXo%iXp%iXs%iXz%iX!X%iX!f%iX%j%iX%k%iX%l%iX%m%iX%n%iX%o%iX%p%iX%q%iX%r%iX%s%iXg%iX!T%iX!U%iX~O&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O{%iX!x%iX#g%iX%[%iX%_%iX%z%iX%{%iX!W%iX![%iX!Q%iX#[%iXt%iX!m%iX~P,eOz#dO{%hX!x%hX#g%hX%[%hX%_%hX%z%hX~Oo0cOv0qO~P'vO#g#gO%[#iO%_#iO~O%uWO~O!T#nO#u!VO#z!WO#}hO~OopO~P'vOV#sOa#tO%uWO{wP~OV#xOo0cOv0qO!Q#yO~P'vO{#{O!x$QO%z#|O#g!yX%[!yX%_!yX~OV#xOo0cOv0qO#g#SX%[#SX%_#SX~P'vOo0cOv0qO#g#WX%[#WX%_#WX~P'vOh$WO%uWO~O!f$YO!r$YO%uWO~OV$eO~P'vO!U$gO#s$hO#u$iO~O{$jO~OV$qO~P'vOS$sO%[$rO%_$rO%c$tO~OV$}Oa$}Og%POo0cOv0qO~P'vOo0cOv0qO{%SO~P'vO&Y%UO~Oa!bOh!iO!X!kO!f!mOVba_bakbalbambanbaobapbasbazba{ba!xba#gba%[ba%_ba%jba%kba%lba%mba%nba%oba%pba%qba%rba%sba%zbagba!Tba!Uba%{ba!Wba![ba!Qba#[batba!mba~On%ZO~Oo%ZO~P'vOo0cO~P'vOk0eOl0fOm0dOn0dOo0mOp0nOs0rOg%wX!T%wX!U%wX%{%wX!W%wX![%wX!Q%wX#[%wX!m%wX~P)pO%{%]Og%vXz%vX!T%vX!U%vX!W%vX{%vX~Og%_Oz%`O!T%dO!U%cO~Og%_O~Oz%gO!T%dO!U%cO!W&SX~O!W%kO~Oz%lO{%nO!T%dO!U%cO![%}X~O![%rO~O![%sO~OQ#XO%`#XO%a%uO~OV%wOo0cOv0qO!PrO~P'vOQ#^OR#[O%`#^O%a%zO~OV!qa_!qaa!qah!qak!qal!qam!qan!qao!qap!qas!qaz!qa{!qa!X!qa!f!qa!x!qa#g!qa%[!qa%_!qa%j!qa%k!qa%l!qa%m!qa%n!qa%o!qa%p!qa%q!qa%r!qa%s!qa%z!qag!qa!T!qa!U!qa%{!qa!W!qa![!qa!Q!qa#[!qat!qa!m!qa~P#yOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P%SOV&OOopOvqO{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P'vOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#g$zX%[$zX%_$zX~P'vO#g#gO%[&TO%_&TO~O!f&UOh&sX%[&sXz&sX#[&sX#g&sX%_&sX#Z&sXg&sX~Oh!iO%[&WO~Okealeameaneaoeapeaseazea{ea!xea#gea%[ea%_ea%zeagea!Tea!Uea%{ea!Wea![ea!Qea#[eatea!mea~P%SOsqazqa{qa#gqa%[qa%_qa%zqa~Ok!pOl!qOm!oOn!oOo!rOp!sO!xqa~PEcO%z&YOz%yX{%yX~O%uWOz%yX{%yX~Oz&]O{wX~O{&_O~Oz%lO#g%}X%[%}X%_%}Xg%}X{%}X![%}X!m%}X%z%}X~OV0lOo0cOv0qO!PrO~P'vO%z#|O#gUa%[Ua%_Ua~Oz&hO#g&PX%[&PX%_&PXn&PX~P%SOz&kO!Q&jO#g#Wa%[#Wa%_#Wa~Oz&lO#[&nO#g&rX%[&rX%_&rXg&rX~O!f$YO!r$YO#Z&qO%uWO~O#Z&qO~Oz&sO#g&tX%[&tX%_&tX~Oz&uO#g&pX%[&pX%_&pX{&pX~O!X&wO%z&xO~Oz&|On&wX~P%SOn'PO~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO%['UO~P'vOt'YO#p'WO#q'XOP#naV#naf#nah#nao#nas#nav#na!P#na!Q#na!T#na!U#na!X#na!]#na!h#na!r#na!s#na!t#na!{#na!}#na#P#na#R#na#T#na#X#na#Z#na#^#na#_#na#a#na#c#na#l#na#o#na#s#na#u#na#z#na#}#na$P#na%X#na%o#na%p#na%t#na%u#na&Z#na&[#na&]#na&^#na&_#na&`#na&a#na&b#na&c#na&d#na&e#na&f#na&g#na&h#na&i#na&j#na%Z#na%_#na~Oz'ZO#[']O{&xX~Oh'_O!X&wO~Oh!iO{$jO!X&wO~O{'eO~P%SO%['hO%_'hO~OS'iO%['hO%_'hO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%k!]O~P!#uO%kWi~P!#uOV!aO_!aOa!bOh!iO!X!kO!f!mO%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%m!_O%n!_O~P!&pO%mWi%nWi~P!&pOa!bOh!iO!X!kO!f!mOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%mWi%nWi%oWi%pWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~OV!aO_!aO%q!aO%r!aO%s!aO~P!)nOVWi_Wi%qWi%rWi%sWi~P!)nO!T%dO!U%cOg&VXz&VX~O%z'kO%{'kO~P,eOz'mOg&UX~Og'oO~Oz'pO{'rO!W&XX~Oo0cOv0qOz'pO{'sO!W&XX~P'vO!W'uO~Om!oOn!oOo!rOp!sOkjisjizji{ji!xji#gji%[ji%_ji%zji~Ol!qO~P!.aOlji~P!.aOk0eOl0fOm0dOn0dOo0mOp0nO~Ot'wO~P!/jOV'|Og'}Oo0cOv0qO~P'vOg'}Oz(OO~Og(QO~O!U(SO~Og(TOz(OO!T%dO!U%cO~P%SOk0eOl0fOm0dOn0dOo0mOp0nOgqa!Tqa!Uqa%{qa!Wqa![qa!Qqa#[qatqa!mqa~PEcOV'|Oo0cOv0qO!W&Sa~P'vOz(WO!W&Sa~O!W(XO~Oz(WO!T%dO!U%cO!W&Sa~P%SOV(]Oo0cOv0qO![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~P'vOz(^O![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~O![(aO~Oz(^O!T%dO!U%cO![%}a~P%SOz(dO!T%dO!U%cO![&Ta~P%SOz(gO{&lX![&lX!m&lX%z&lX~O{(kO![(mO!m(nO%z(jO~OV&OOopOvqO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~P'vOz(pO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~O!f&UOh&sa%[&saz&sa#[&sa#g&sa%_&sa#Z&sag&sa~O%[(uO~OV#sOa#tO%uWO~Oz&]O{wa~OopOvqO~P'vOz(^O#g%}a%[%}a%_%}ag%}a{%}a![%}a!m%}a%z%}a~P%SOz(zO#g%hX%[%hX%_%hX%z%hX~O%z#|O#gUi%[Ui%_Ui~O#g&Pa%[&Pa%_&Pan&Pa~P'vOz(}O#g&Pa%[&Pa%_&Pan&Pa~O%uWO#g&ra%[&ra%_&rag&ra~Oz)SO#g&ra%[&ra%_&rag&ra~Og)VO~OV)WOh$WO%uWO~O#Z)XO~O%uWO#g&ta%[&ta%_&ta~Oz)ZO#g&ta%[&ta%_&ta~Oo0cOv0qO#g&pa%[&pa%_&pa{&pa~P'vOz)^O#g&pa%[&pa%_&pa{&pa~OV)`Oa)`O%uWO~O%z)eO~Ot)hO#j)gOP#hiV#hif#hih#hio#his#hiv#hi!P#hi!Q#hi!T#hi!U#hi!X#hi!]#hi!h#hi!r#hi!s#hi!t#hi!{#hi!}#hi#P#hi#R#hi#T#hi#X#hi#Z#hi#^#hi#_#hi#a#hi#c#hi#l#hi#o#hi#s#hi#u#hi#z#hi#}#hi$P#hi%X#hi%o#hi%p#hi%t#hi%u#hi&Z#hi&[#hi&]#hi&^#hi&_#hi&`#hi&a#hi&b#hi&c#hi&d#hi&e#hi&f#hi&g#hi&h#hi&i#hi&j#hi%Z#hi%_#hi~Ot)iOP#kiV#kif#kih#kio#kis#kiv#ki!P#ki!Q#ki!T#ki!U#ki!X#ki!]#ki!h#ki!r#ki!s#ki!t#ki!{#ki!}#ki#P#ki#R#ki#T#ki#X#ki#Z#ki#^#ki#_#ki#a#ki#c#ki#l#ki#o#ki#s#ki#u#ki#z#ki#}#ki$P#ki%X#ki%o#ki%p#ki%t#ki%u#ki&Z#ki&[#ki&]#ki&^#ki&_#ki&`#ki&a#ki&b#ki&c#ki&d#ki&e#ki&f#ki&g#ki&h#ki&i#ki&j#ki%Z#ki%_#ki~OV)kOn&wa~P'vOz)lOn&wa~Oz)lOn&wa~P%SOn)pO~O%Y)tO~Ot)wO#p'WO#q)vOP#niV#nif#nih#nio#nis#niv#ni!P#ni!Q#ni!T#ni!U#ni!X#ni!]#ni!h#ni!r#ni!s#ni!t#ni!{#ni!}#ni#P#ni#R#ni#T#ni#X#ni#Z#ni#^#ni#_#ni#a#ni#c#ni#l#ni#o#ni#s#ni#u#ni#z#ni#}#ni$P#ni%X#ni%o#ni%p#ni%t#ni%u#ni&Z#ni&[#ni&]#ni&^#ni&_#ni&`#ni&a#ni&b#ni&c#ni&d#ni&e#ni&f#ni&g#ni&h#ni&i#ni&j#ni%Z#ni%_#ni~OV)zOo0cOv0qO{$jO~P'vOo0cOv0qO{&xa~P'vOz*OO{&xa~OV*SOa*TOg*WO%q*UO%uWO~O{$jO&{*YO~Oh'_O~Oh!iO{$jO~O%[*_O~O%[*aO%_*aO~OV$}Oa$}Oo0cOv0qOg&Ua~P'vOz*dOg&Ua~Oo0cOv0qO{*gO!W&Xa~P'vOz*hO!W&Xa~Oo0cOv0qOz*hO{*kO!W&Xa~P'vOo0cOv0qOz*hO!W&Xa~P'vOz*hO{*kO!W&Xa~Om0dOn0dOo0mOp0nOgjikjisjizji!Tji!Uji%{ji!Wji{ji![ji#gji%[ji%_ji!Qji#[jitji!mji%zji~Ol0fO~P!NkOlji~P!NkOV'|Og*pOo0cOv0qO~P'vOn*rO~Og*pOz*tO~Og*uO~OV'|Oo0cOv0qO!W&Si~P'vOz*vO!W&Si~O!W*wO~OV(]Oo0cOv0qO![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~P'vOz*zO!T%dO!U%cO![&Ti~Oz*}O![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~O![+OO~Oa+QOo0cOv0qO![&Ti~P'vOz*zO![&Ti~O![+SO~OV+UOo0cOv0qO{&la![&la!m&la%z&la~P'vOz+VO{&la![&la!m&la%z&la~O!]+YO&n+[O![!nX~O![+^O~O{(kO![+_O~O{(kO![+_O!m+`O~OV&OOopOvqO{%hq!x%hq#g%hq%[%hq%_%hq%z%hq~P'vOz$ri{$ri!x$ri#g$ri%[$ri%_$ri%z$ri~P%SOV&OOopOvqO~P'vOV&OOo0cOv0qO#g%ha%[%ha%_%ha%z%ha~P'vOz+aO#g%ha%[%ha%_%ha%z%ha~Oz$ia#g$ia%[$ia%_$ian$ia~P%SO#g&Pi%[&Pi%_&Pin&Pi~P'vOz+dO#g#Wq%[#Wq%_#Wq~O#[+eOz$va#g$va%[$va%_$vag$va~O%uWO#g&ri%[&ri%_&rig&ri~Oz+gO#g&ri%[&ri%_&rig&ri~OV+iOh$WO%uWO~O%uWO#g&ti%[&ti%_&ti~Oo0cOv0qO#g&pi%[&pi%_&pi{&pi~P'vO{#{Oz#eX!W#eX~Oz+mO!W&uX~O!W+oO~Ot+rO#j)gOP#hqV#hqf#hqh#hqo#hqs#hqv#hq!P#hq!Q#hq!T#hq!U#hq!X#hq!]#hq!h#hq!r#hq!s#hq!t#hq!{#hq!}#hq#P#hq#R#hq#T#hq#X#hq#Z#hq#^#hq#_#hq#a#hq#c#hq#l#hq#o#hq#s#hq#u#hq#z#hq#}#hq$P#hq%X#hq%o#hq%p#hq%t#hq%u#hq&Z#hq&[#hq&]#hq&^#hq&_#hq&`#hq&a#hq&b#hq&c#hq&d#hq&e#hq&f#hq&g#hq&h#hq&i#hq&j#hq%Z#hq%_#hq~On$|az$|a~P%SOV)kOn&wi~P'vOz+yOn&wi~Oz,TO{$jO#[,TO~O#q,VOP#nqV#nqf#nqh#nqo#nqs#nqv#nq!P#nq!Q#nq!T#nq!U#nq!X#nq!]#nq!h#nq!r#nq!s#nq!t#nq!{#nq!}#nq#P#nq#R#nq#T#nq#X#nq#Z#nq#^#nq#_#nq#a#nq#c#nq#l#nq#o#nq#s#nq#u#nq#z#nq#}#nq$P#nq%X#nq%o#nq%p#nq%t#nq%u#nq&Z#nq&[#nq&]#nq&^#nq&_#nq&`#nq&a#nq&b#nq&c#nq&d#nq&e#nq&f#nq&g#nq&h#nq&i#nq&j#nq%Z#nq%_#nq~O#[,WOz%Oa{%Oa~Oo0cOv0qO{&xi~P'vOz,YO{&xi~O{#{O%z,[Og&zXz&zX~O%uWOg&zXz&zX~Oz,`Og&yX~Og,bO~O%Y,eO~O!T%dO!U%cOg&Viz&Vi~OV$}Oa$}Oo0cOv0qOg&Ui~P'vO{,hOz$la!W$la~Oo0cOv0qO{,iOz$la!W$la~P'vOo0cOv0qO{*gO!W&Xi~P'vOz,lO!W&Xi~Oo0cOv0qOz,lO!W&Xi~P'vOz,lO{,oO!W&Xi~Og$hiz$hi!W$hi~P%SOV'|Oo0cOv0qO~P'vOn,qO~OV'|Og,rOo0cOv0qO~P'vOV'|Oo0cOv0qO!W&Sq~P'vOz$gi![$gi#g$gi%[$gi%_$gig$gi{$gi!m$gi%z$gi~P%SOV(]Oo0cOv0qO~P'vOa+QOo0cOv0qO![&Tq~P'vOz,sO![&Tq~O![,tO~OV(]Oo0cOv0qO![%}q#g%}q%[%}q%_%}qg%}q{%}q!m%}q%z%}q~P'vO{,uO~OV+UOo0cOv0qO{&li![&li!m&li%z&li~P'vOz,zO{&li![&li!m&li%z&li~O!]+YO&n+[O![!na~O{(kO![,}O~OV&OOo0cOv0qO#g%hi%[%hi%_%hi%z%hi~P'vOz-OO#g%hi%[%hi%_%hi%z%hi~O%uWO#g&rq%[&rq%_&rqg&rq~Oz-RO#g&rq%[&rq%_&rqg&rq~OV)`Oa)`O%uWO!W&ua~Oz-TO!W&ua~On$|iz$|i~P%SOV)kO~P'vOV)kOn&wq~P'vOt-XOP#myV#myf#myh#myo#mys#myv#my!P#my!Q#my!T#my!U#my!X#my!]#my!h#my!r#my!s#my!t#my!{#my!}#my#P#my#R#my#T#my#X#my#Z#my#^#my#_#my#a#my#c#my#l#my#o#my#s#my#u#my#z#my#}#my$P#my%X#my%o#my%p#my%t#my%u#my&Z#my&[#my&]#my&^#my&_#my&`#my&a#my&b#my&c#my&d#my&e#my&f#my&g#my&h#my&i#my&j#my%Z#my%_#my~O%Z-]O%_-]O~P`O#q-^OP#nyV#nyf#nyh#nyo#nys#nyv#ny!P#ny!Q#ny!T#ny!U#ny!X#ny!]#ny!h#ny!r#ny!s#ny!t#ny!{#ny!}#ny#P#ny#R#ny#T#ny#X#ny#Z#ny#^#ny#_#ny#a#ny#c#ny#l#ny#o#ny#s#ny#u#ny#z#ny#}#ny$P#ny%X#ny%o#ny%p#ny%t#ny%u#ny&Z#ny&[#ny&]#ny&^#ny&_#ny&`#ny&a#ny&b#ny&c#ny&d#ny&e#ny&f#ny&g#ny&h#ny&i#ny&j#ny%Z#ny%_#ny~Oz-aO{$jO#[-aO~Oo0cOv0qO{&xq~P'vOz-dO{&xq~O%z,[Og&zaz&za~O{#{Og&zaz&za~OV*SOa*TO%q*UO%uWOg&ya~Oz-hOg&ya~O$S-lO~OV$}Oa$}Oo0cOv0qO~P'vOo0cOv0qO{-mOz$li!W$li~P'vOo0cOv0qOz$li!W$li~P'vO{-mOz$li!W$li~Oo0cOv0qO{*gO~P'vOo0cOv0qO{*gO!W&Xq~P'vOz-pO!W&Xq~Oo0cOv0qOz-pO!W&Xq~P'vOs-sO!T%dO!U%cOg&Oq!W&Oq![&Oqz&Oq~P!/jOa+QOo0cOv0qO![&Ty~P'vOz$ji![$ji~P%SOa+QOo0cOv0qO~P'vOV+UOo0cOv0qO~P'vOV+UOo0cOv0qO{&lq![&lq!m&lq%z&lq~P'vO{(kO![-xO!m-yO%z-wO~OV&OOo0cOv0qO#g%hq%[%hq%_%hq%z%hq~P'vO%uWO#g&ry%[&ry%_&ryg&ry~OV)`Oa)`O%uWO!W&ui~Ot-}OP#m!RV#m!Rf#m!Rh#m!Ro#m!Rs#m!Rv#m!R!P#m!R!Q#m!R!T#m!R!U#m!R!X#m!R!]#m!R!h#m!R!r#m!R!s#m!R!t#m!R!{#m!R!}#m!R#P#m!R#R#m!R#T#m!R#X#m!R#Z#m!R#^#m!R#_#m!R#a#m!R#c#m!R#l#m!R#o#m!R#s#m!R#u#m!R#z#m!R#}#m!R$P#m!R%X#m!R%o#m!R%p#m!R%t#m!R%u#m!R&Z#m!R&[#m!R&]#m!R&^#m!R&_#m!R&`#m!R&a#m!R&b#m!R&c#m!R&d#m!R&e#m!R&f#m!R&g#m!R&h#m!R&i#m!R&j#m!R%Z#m!R%_#m!R~Oo0cOv0qO{&xy~P'vOV*SOa*TO%q*UO%uWOg&yi~O$S-lO%Z.VO%_.VO~OV.aOh._O!X.^O!].`O!h.YO!s.[O!t.[O%p.XO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O~Oo0cOv0qOz$lq!W$lq~P'vO{.fOz$lq!W$lq~Oo0cOv0qO{*gO!W&Xy~P'vOz.gO!W&Xy~Oo0cOv.kO~P'vOs-sO!T%dO!U%cOg&Oy!W&Oy![&Oyz&Oy~P!/jO{(kO![.nO~O{(kO![.nO!m.oO~OV*SOa*TO%q*UO%uWO~Oh.tO!f.rOz$TX#[$TX%j$TXg$TX~Os$TX{$TX!W$TX![$TX~P$-bO%o.vO%p.vOs$UXz$UX{$UX#[$UX%j$UX!W$UXg$UX![$UX~O!h.xO~Oz.|O#[/OO%j.yOs&|X{&|X!W&|Xg&|X~Oa/RO~P$)zOh.tOs&}Xz&}X{&}X#[&}X%j&}X!W&}Xg&}X![&}X~Os/VO{$jO~Oo0cOv0qOz$ly!W$ly~P'vOo0cOv0qO{*gO!W&X!R~P'vOz/ZO!W&X!R~Og&RXs&RX!T&RX!U&RX!W&RX![&RXz&RX~P!/jOs-sO!T%dO!U%cOg&Qa!W&Qa![&Qaz&Qa~O{(kO![/^O~O!f.rOh$[as$[az$[a{$[a#[$[a%j$[a!W$[ag$[a![$[a~O!h/eO~O%o.vO%p.vOs$Uaz$Ua{$Ua#[$Ua%j$Ua!W$Uag$Ua![$Ua~O%j.yOs$Yaz$Ya{$Ya#[$Ya!W$Yag$Ya![$Ya~Os&|a{&|a!W&|ag&|a~P$)nOz/jOs&|a{&|a!W&|ag&|a~O!W/mO~Og/mO~O{/oO~O![/pO~Oo0cOv0qO{*gO!W&X!Z~P'vO{/sO~O%z/tO~P$-bOz/uO#[/OO%j.yOg'PX~Oz/uOg'PX~Og/wO~O!h/xO~O#[/OOs%Saz%Sa{%Sa%j%Sa!W%Sag%Sa![%Sa~O#[/OO%j.yOs%Waz%Wa{%Wa!W%Wag%Wa~Os&|i{&|i!W&|ig&|i~P$)nOz/zO#[/OO%j.yO!['Oa~Og'Pa~P$)nOz0SOg'Pa~Oa0UO!['Oi~P$)zOz0WO!['Oi~Oz0WO#[/OO%j.yO!['Oi~O#[/OO%j.yOg$biz$bi~O%z0ZO~P$-bO#[/OO%j.yOg%Vaz%Va~Og'Pi~P$)nO{0^O~Oa0UO!['Oq~P$)zOz0`O!['Oq~O#[/OO%j.yOz%Ui![%Ui~Oa0UO~P$)zOa0UO!['Oy~P$)zO#[/OO%j.yOg$ciz$ci~O#[/OO%j.yOz%Uq![%Uq~Oz+aO#g%ha%[%ha%_%ha%z%ha~P%SOV&OOo0cOv0qO~P'vOn0hO~Oo0hO~P'vO{0iO~Ot0jO~P!/jO&]&Z&j&h&i&g&f&d&e&c&b&`&a&_&^&[%u~",
      goto: "!=j'QPPPPPP'RP'Z*s+[+t,_,y-fP.SP'Z.r.r'ZPPP'Z2[PPPPPP2[5PPP5PP7b7k=sPP=v>h>kPP'Z'ZPP>zPP'Z'ZPP'Z'Z'Z'Z'Z?O?w'ZP?zP@QDXGuGyPG|HWH['ZPPPH_Hk'RP'R'RP'RP'RP'RP'RP'R'R'RP'RPP'RPP'RP'RPHqH}IVPI^IdPI^PI^I^PPPI^PKrPK{LVL]KrPI^LfPI^PLmLsPLwM]MzNeLwLwNkNxLwLwLwLw! ^! d! g! l! o! y!!P!!]!!o!!u!#P!#V!#s!#y!$P!$Z!$a!$g!$y!%T!%Z!%a!%k!%q!%w!%}!&T!&Z!&e!&k!&u!&{!'U!'[!'k!'s!'}!(UPPPPPPPPPPP!([!(_!(e!(n!(x!)TPPPPPPPPPPPP!-u!/Z!3^!6oPP!6w!7W!7a!8Y!8P!8c!8i!8l!8o!8r!8z!9jPPPPPPPPPPPPPPPPP!9m!9q!9wP!:]!:a!:m!:v!;S!;j!;m!;p!;v!;|!<S!<VP!<_!<h!=d!=g]eOn#g$j)t,P'}`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r{!cQ#c#p$R$d$p%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g}!dQ#c#p$R$d$p$u%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!P!eQ#c#p$R$d$p$u$v%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!R!fQ#c#p$R$d$p$u$v$w%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!T!gQ#c#p$R$d$p$u$v$w$x%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!V!hQ#c#p$R$d$p$u$v$w$x$y%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!Z!hQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g'}TOTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r&eVOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0n0r%oXOYZ[dnrxy}!P!Q!U!i!k#[#d#g#y#{#}$Q$h$j$}%S%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/V/Z0i0j0kQ#vqQ/[.kR0o0q't`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rh#jhz{$W$Z&l&q)S)X+f+g-RW#rq&].k0qQ$]|Q$a!OQ$n!VQ$o!WW$|!i'm*d,gS&[#s#tQ'S$iQ(s&UQ)U&nU)Y&s)Z+jW)a&w+m-T-{Q*Q']W*R'_,`-h.TQ+l)`S,_*S*TQ-Q+eQ-_,TQ-c,WQ.R-al.W-l.^._.a.z.|/R/j/o/t/y0U0Z0^Q/S.`Q/a.tQ/l/OU0P/u0S0[X0V/z0W0_0`R&Z#r!_!wYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZR%^!vQ!{YQ%x#[Q&d#}Q&g$QR,{+YT.j-s/s!Y!jQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0gQ&X#kQ'c$oR*^'dR'l$|Q%V!mR/_.r'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rS#a_#b!P.[-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rT#a_#bT#^^#_R(o%xa(l%x(n(o+`,{-y-z.oT+[(k+]R-z,{Q$PsQ+l)aQ,^*RR-e,_X#}s$O$P&fQ&y$aQ'a$nQ'd$oR)s'SQ)b&wV-S+m-T-{ZgOn$j)t,PXkOn)t,PQ$k!TQ&z$bQ&{$cQ'^$mQ'b$oQ)q'RQ)x'WQ){'XQ)|'YQ*Z'`S*]'c'dQ+s)gQ+u)hQ+v)iQ+z)oS+|)r*[Q,Q)vQ,R)wS,S)y)zQ,d*^Q-V+rQ-W+tQ-Y+{S-Z+},OQ-`,UQ-b,VQ-|-XQ.O-[Q.P-^Q.Q-_Q.p-}Q.q.RQ/W.dR/r/XWkOn)t,PR#mjQ'`$nS)r'S'aR,O)sQ,]*RR-f,^Q*['`Q+})rR-[,OZiOjn)t,PQ'f$pR*`'gT-j,e-ku.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^t.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^Q/S.`X0V/z0W0_0`!P.Z-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`Q.w.YR/f.xg.z.].{/b/i/n/|0O0Q0]0a0bu.b-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^X.u.W.b/a0PR/c.tV0R/u0S0[R/X.dQnOS#on,PR,P)tQ&^#uR(x&^S%m#R#wS(_%m(bT(b%p&`Q%a!yQ%h!}W(P%a%h(U(YQ(U%eR(Y%jQ&i$RR)O&iQ(e%qQ*{(`T+R(e*{Q'n%OR*e'nS'q%R%SY*i'q*j,m-q.hU*j'r's'tU,m*k*l*mS-q,n,oR.h-rQ#Y]R%t#YQ#_^R%y#_Q(h%vS+W(h+XR+X(iQ+](kR,|+]Q#b_R%{#bQ#ebQ%}#cW&Q#e%}({+bQ({&cR+b0gQ$OsS&e$O&fR&f$PQ&v$_R)_&vQ&V#jR(t&VQ&m$VS)T&m+hR+h)UQ$Z{R&p$ZQ&t$]R)[&tQ+n)bR-U+nQ#hfR&S#hQ)f&zR+q)fQ&}$dS)m&})nR)n'OQ'V$kR)u'VQ'[$lS*P'[,ZR,Z*QQ,a*VR-i,aWjOn)t,PR#ljQ-k,eR.U-kd.{.]/b/i/n/|0O0Q0]0a0bR/h.{U.s.W/a0PR/`.sQ/{/nS0X/{0YR0Y/|S/v/b/cR0T/vQ.}.]R/k.}R!ZPXmOn)t,PWlOn)t,PR'T$jYfOn$j)t,PR&R#g[sOn#g$j)t,PR&d#}&dQOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0n0rQ!nTQ#caQ#poU$Rt%c(SS$d!R$gQ$p!XQ$u!cQ$v!dQ$w!eQ$x!fQ$y!gQ$z!hQ%e!zQ%j#OQ%p#SQ%q#TQ&`#xQ'O$eQ'g$qQ(q&OU(|&h(}+cW)j&|)l+x+yQ*o'|Q*x(]Q+w)kQ,v+QR0g0lQ!yYQ!}ZQ$b!PQ$c!QQ%R!kQ't%S^'{%`%g(O(W*q*t*v^*f'p*h,k,l-p.g/ZQ*l'rQ*m'sQ+t)gQ,j*gQ,n*kQ-n,hQ-o,iQ-r,oQ.e-mR/Y.f[bOn#g$j)t,P!^!vYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZQ#R[Q#fdS#wrxQ$UyW$_}$Q'P)pS$l!U$hW${!i'm*d,gS%v#[+Y`&P#d%|(p(r(z+a-O0kQ&a#yQ&b#{Q&c#}Q'j$}Q'z%^W([%l(^*y*}Q(`%nQ(i%wQ(v&ZS(y&_0iQ)P&jQ)Q&kU)]&u)^+kQ)d&xQ)y'WY)}'Z*O,X,Y-dQ*b'lS*n'w0jW+P(d*z,s,wW+T(g+V,y,zQ+p)eQ,U)zQ,c*YQ,x+UQ-P+dQ-e,]Q-v,uQ.S-fR/q/VhUOn#d#g$j%|&_'w(p(r)t,P%U!uYZ[drxy}!P!Q!U!i!k#[#y#{#}$Q$h$}%S%^%`%g%l%n%w&Z&j&k&u&x'P'W'Z'l'm'p'r's(O(W(^(d(g(z)^)e)g)p)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/V/Z0i0j0kQ#qpW%W!o!s0d0nQ%X!pQ%Y!qQ%[!tQ%f0cS'v%Z0hQ'x0eQ'y0fQ,p*rQ-u,qS.i-s/sR0p0rU#uq.k0qR(w&][cOn#g$j)t,PZ!xY#[#}$Q+YQ#W[Q#zrR$TxQ%b!yQ%i!}Q%o#RQ'j${Q(V%eQ(Z%jQ(c%pQ(f%qQ*|(`Q,f*bQ-t,pQ.m-uR/].lQ$StQ(R%cR*s(SQ.l-sR/}/sR#QZR#V[R%Q!iQ%O!iV*c'm*d,g!Z!lQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0gR%T!kT#]^#_Q%x#[R,{+YQ(m%xS+_(n(oQ,}+`Q-x,{S.n-y-zR/^.oT+Z(k+]Q$`}Q&g$QQ)o'PR+{)pQ$XzQ)W&qR+i)XQ$XzQ&o$WQ)W&qR+i)XQ#khW$Vz$W&q)XQ$[{Q&r$ZZ)R&l)S+f+g-RR$^|R)c&wXlOn)t,PQ$f!RR'Q$gQ$m!UR'R$hR*X'_Q*V'_V-g,`-h.TQ.d-lQ/P.^R/Q._U.]-l.^._Q/U.aQ/b.tQ/g.zU/i.|/j/yQ/n/RQ/|/oQ0O/tU0Q/u0S0[Q0]0UQ0a0ZR0b0^R/T.`R/d.t",
      nodeNames: "\u26A0 print Escape { Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatSelfDoc FormatConversion FormatSpec FormatReplacement FormatSelfDoc ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert TypeDefinition type TypeParamList TypeParam StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard",
      maxTerm: 277,
      context: trackIndent,
      nodeProps: [
        ["isolate", -5, 4, 71, 72, 73, 77, ""],
        ["group", -15, 6, 85, 87, 88, 90, 92, 94, 96, 98, 99, 100, 102, 105, 108, 110, "Statement Statement", -22, 8, 18, 21, 25, 40, 49, 50, 56, 57, 60, 61, 62, 63, 64, 67, 70, 71, 72, 79, 80, 81, 82, "Expression", -10, 114, 116, 119, 121, 122, 126, 128, 133, 135, 138, "Statement", -9, 143, 144, 147, 148, 150, 151, 152, 153, 154, "Pattern"],
        ["openedBy", 23, "(", 54, "[", 58, "{"],
        ["closedBy", 24, ")", 55, "]", 59, "}"]
      ],
      propSources: [pythonHighlighting],
      skippedNodes: [0, 4],
      repeatNodeCount: 34,
      tokenData: "!2|~R!`OX%TXY%oY[%T[]%o]p%Tpq%oqr'ars)Yst*xtu%Tuv,dvw-hwx.Uxy/tyz0[z{0r{|2S|}2p}!O3W!O!P4_!P!Q:Z!Q!R;k!R![>_![!]Do!]!^Es!^!_FZ!_!`Gk!`!aHX!a!b%T!b!cIf!c!dJU!d!eK^!e!hJU!h!i!#f!i!tJU!t!u!,|!u!wJU!w!x!.t!x!}JU!}#O!0S#O#P&o#P#Q!0j#Q#R!1Q#R#SJU#S#T%T#T#UJU#U#VK^#V#YJU#Y#Z!#f#Z#fJU#f#g!,|#g#iJU#i#j!.t#j#oJU#o#p!1n#p#q!1s#q#r!2a#r#s!2f#s$g%T$g;'SJU;'S;=`KW<%lOJU`%YT&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T`%lP;=`<%l%To%v]&n`%c_OX%TXY%oY[%T[]%o]p%Tpq%oq#O%T#O#P&o#P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To&tX&n`OY%TYZ%oZ]%T]^%o^#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc'f[&n`O!_%T!_!`([!`#T%T#T#U(r#U#f%T#f#g(r#g#h(r#h#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(cTmR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(yT!mR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk)aV&n`&[ZOr%Trs)vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk){V&n`Or%Trs*bs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk*iT&n`&^ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To+PZS_&n`OY*xYZ%TZ]*x]^%T^#o*x#o#p+r#p#q*x#q#r+r#r;'S*x;'S;=`,^<%lO*x_+wTS_OY+rZ]+r^;'S+r;'S;=`,W<%lO+r_,ZP;=`<%l+ro,aP;=`<%l*xj,kV%rQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-XT!xY&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-oV%lQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.]V&n`&ZZOw%Twx.rx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.wV&n`Ow%Twx/^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/eT&n`&]ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/{ThZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc0cTgR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk0yXVZ&n`Oz%Tz{1f{!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk1mVaR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk2ZV%oZ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc2wTzR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To3_W%pZ&n`O!_%T!_!`-Q!`!a3w!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Td4OT&{S&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk4fX!fQ&n`O!O%T!O!P5R!P!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5WV&n`O!O%T!O!P5m!P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5tT!rZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti6[a!hX&n`O!Q%T!Q![6T![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S6T#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti7fZ&n`O{%T{|8X|}%T}!O8X!O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8^V&n`O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8z]!hX&n`O!Q%T!Q![8s![!l%T!l!m9s!m#R%T#R#S8s#S#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti9zT!hX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk:bX%qR&n`O!P%T!P!Q:}!Q!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj;UV%sQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti;ro!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!d%T!d!e?q!e!g%T!g!h7a!h!l%T!l!m9s!m!q%T!q!rA]!r!z%T!z!{Bq!{#R%T#R#S>_#S#U%T#U#V?q#V#X%T#X#Y7a#Y#^%T#^#_9s#_#c%T#c#dA]#d#l%T#l#mBq#m#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti=xV&n`O!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti>fc!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S>_#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti?vY&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti@mY!hX&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiAbX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBUX!hX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBv]&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiCv]!hX&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToDvV{_&n`O!_%T!_!`E]!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TcEdT%{R&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkEzT#gZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkFbXmR&n`O!^%T!^!_F}!_!`([!`!a([!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjGUV%mQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkGrV%zZ&n`O!_%T!_!`([!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkH`WmR&n`O!_%T!_!`([!`!aHx!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjIPV%nQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkIoV_Q#}P&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToJ_]&n`&YS%uZO!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoKZP;=`<%lJUoKge&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!tJU!t!uLx!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#gLx#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoMRa&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUkN_V&n`&`ZOr%TrsNts#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkNyV&n`Or%Trs! `s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! gT&n`&bZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! }V&n`&_ZOw%Twx!!dx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!!iV&n`Ow%Twx!#Ox#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!#VT&n`&aZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!#oe&n`&YS%uZOr%Trs!%Qsw%Twx!&px!Q%T!Q![JU![!c%T!c!tJU!t!u!(`!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#g!(`#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!%XV&n`&dZOr%Trs!%ns#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!%sV&n`Or%Trs!&Ys#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&aT&n`&fZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&wV&n`&cZOw%Twx!'^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!'cV&n`Ow%Twx!'xx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!(PT&n`&eZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!(ia&n`&YS%uZOr%Trs!)nsw%Twx!+^x!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!)uV&n`&hZOr%Trs!*[s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*aV&n`Or%Trs!*vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*}T&n`&jZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!+eV&n`&gZOw%Twx!+zx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,PV&n`Ow%Twx!,fx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,mT&n`&iZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!-Vi&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!dJU!d!eLx!e!hJU!h!i!(`!i!}JU!}#R%T#R#SJU#S#T%T#T#UJU#U#VLx#V#YJU#Y#Z!(`#Z#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUo!.}a&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!0ZT!XZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc!0qT!WR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj!1XV%kQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!1sO!]~k!1zV%jR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!2fO![~i!2mT%tX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T",
      tokenizers: [legacyPrint, indentation, newlines, strings, 0, 1, 2, 3, 4],
      topRules: { "Script": [0, 5] },
      specialized: [{ term: 221, get: (value) => spec_identifier2[value] || -1 }],
      tokenPrec: 7668
    });
  }
});

// node_modules/@codemirror/lang-python/dist/index.js
function defID2(type) {
  return (node, def, outer) => {
    if (outer)
      return false;
    let id2 = node.node.getChild("VariableName");
    if (id2)
      def(id2, type);
    return true;
  };
}
function getScope2(doc2, node) {
  let cached = cache2.get(node);
  if (cached)
    return cached;
  let completions = [], top2 = true;
  function def(node2, type) {
    let name2 = doc2.sliceString(node2.from, node2.to);
    completions.push({ label: name2, type });
  }
  node.cursor(IterMode.IncludeAnonymous).iterate((node2) => {
    if (node2.name) {
      let gather = gatherCompletions2[node2.name];
      if (gather && gather(node2, def, top2) || !top2 && ScopeNodes2.has(node2.name))
        return false;
      top2 = false;
    } else if (node2.to - node2.from > 8192) {
      for (let c of getScope2(doc2, node2.node))
        completions.push(c);
      return false;
    }
  });
  cache2.set(node, completions);
  return completions;
}
function localCompletionSource2(context2) {
  let inner = syntaxTree(context2.state).resolveInner(context2.pos, -1);
  if (dontComplete2.indexOf(inner.name) > -1)
    return null;
  let isWord = inner.name == "VariableName" || inner.to - inner.from < 20 && Identifier2.test(context2.state.sliceDoc(inner.from, inner.to));
  if (!isWord && !context2.explicit)
    return null;
  let options = [];
  for (let pos = inner; pos; pos = pos.parent) {
    if (ScopeNodes2.has(pos.name))
      options = options.concat(getScope2(context2.state.doc, pos));
  }
  return {
    options,
    from: isWord ? inner.from : context2.pos,
    validFor: Identifier2
  };
}
function innerBody(context2) {
  let { node, pos } = context2;
  let lineIndent = context2.lineIndent(pos, -1);
  let found = null;
  for (; ; ) {
    let before = node.childBefore(pos);
    if (!before) {
      break;
    } else if (before.name == "Comment") {
      pos = before.from;
    } else if (before.name == "Body" || before.name == "MatchBody") {
      if (context2.baseIndentFor(before) + context2.unit <= lineIndent)
        found = before;
      node = before;
    } else if (before.name == "MatchClause") {
      node = before;
    } else if (before.type.is("Statement")) {
      node = before;
    } else {
      break;
    }
  }
  return found;
}
function indentBody(context2, node) {
  let base2 = context2.baseIndentFor(node);
  let line = context2.lineAt(context2.pos, -1), to = line.from + line.text.length;
  if (/^\s*($|#)/.test(line.text) && context2.node.to < to + 100 && !/\S/.test(context2.state.sliceDoc(to, context2.node.to)) && context2.lineIndent(context2.pos, -1) <= base2)
    return null;
  if (/^\s*(else:|elif |except |finally:|case\s+[^=:]+:)/.test(context2.textAfter) && context2.lineIndent(context2.pos, -1) > base2)
    return null;
  return base2 + context2.unit;
}
function python() {
  return new LanguageSupport(pythonLanguage, [
    pythonLanguage.data.of({ autocomplete: localCompletionSource2 }),
    pythonLanguage.data.of({ autocomplete: globalCompletion })
  ]);
}
var cache2, ScopeNodes2, gatherCompletions2, Identifier2, dontComplete2, globals, snippets2, globalCompletion, pythonLanguage;
var init_dist11 = __esm({
  "node_modules/@codemirror/lang-python/dist/index.js"() {
    "use strict";
    init_dist10();
    init_dist7();
    init_dist3();
    init_dist8();
    cache2 = /* @__PURE__ */ new NodeWeakMap();
    ScopeNodes2 = /* @__PURE__ */ new Set([
      "Script",
      "Body",
      "FunctionDefinition",
      "ClassDefinition",
      "LambdaExpression",
      "ForStatement",
      "MatchClause"
    ]);
    gatherCompletions2 = {
      FunctionDefinition: /* @__PURE__ */ defID2("function"),
      ClassDefinition: /* @__PURE__ */ defID2("class"),
      ForStatement(node, def, outer) {
        if (outer)
          for (let child = node.node.firstChild; child; child = child.nextSibling) {
            if (child.name == "VariableName")
              def(child, "variable");
            else if (child.name == "in")
              break;
          }
      },
      ImportStatement(_node, def) {
        var _a2, _b;
        let { node } = _node;
        let isFrom = ((_a2 = node.firstChild) === null || _a2 === void 0 ? void 0 : _a2.name) == "from";
        for (let ch = node.getChild("import"); ch; ch = ch.nextSibling) {
          if (ch.name == "VariableName" && ((_b = ch.nextSibling) === null || _b === void 0 ? void 0 : _b.name) != "as")
            def(ch, isFrom ? "variable" : "namespace");
        }
      },
      AssignStatement(node, def) {
        for (let child = node.node.firstChild; child; child = child.nextSibling) {
          if (child.name == "VariableName")
            def(child, "variable");
          else if (child.name == ":" || child.name == "AssignOp")
            break;
        }
      },
      ParamList(node, def) {
        for (let prev = null, child = node.node.firstChild; child; child = child.nextSibling) {
          if (child.name == "VariableName" && (!prev || !/\*|AssignOp/.test(prev.name)))
            def(child, "variable");
          prev = child;
        }
      },
      CapturePattern: /* @__PURE__ */ defID2("variable"),
      AsPattern: /* @__PURE__ */ defID2("variable"),
      __proto__: null
    };
    Identifier2 = /^[\w\xa1-\uffff][\w\d\xa1-\uffff]*$/;
    dontComplete2 = ["String", "FormatString", "Comment", "PropertyName"];
    globals = /* @__PURE__ */ [
      "__annotations__",
      "__builtins__",
      "__debug__",
      "__doc__",
      "__import__",
      "__name__",
      "__loader__",
      "__package__",
      "__spec__",
      "False",
      "None",
      "True"
    ].map((n) => ({ label: n, type: "constant" })).concat(/* @__PURE__ */ [
      "ArithmeticError",
      "AssertionError",
      "AttributeError",
      "BaseException",
      "BlockingIOError",
      "BrokenPipeError",
      "BufferError",
      "BytesWarning",
      "ChildProcessError",
      "ConnectionAbortedError",
      "ConnectionError",
      "ConnectionRefusedError",
      "ConnectionResetError",
      "DeprecationWarning",
      "EOFError",
      "Ellipsis",
      "EncodingWarning",
      "EnvironmentError",
      "Exception",
      "FileExistsError",
      "FileNotFoundError",
      "FloatingPointError",
      "FutureWarning",
      "GeneratorExit",
      "IOError",
      "ImportError",
      "ImportWarning",
      "IndentationError",
      "IndexError",
      "InterruptedError",
      "IsADirectoryError",
      "KeyError",
      "KeyboardInterrupt",
      "LookupError",
      "MemoryError",
      "ModuleNotFoundError",
      "NameError",
      "NotADirectoryError",
      "NotImplemented",
      "NotImplementedError",
      "OSError",
      "OverflowError",
      "PendingDeprecationWarning",
      "PermissionError",
      "ProcessLookupError",
      "RecursionError",
      "ReferenceError",
      "ResourceWarning",
      "RuntimeError",
      "RuntimeWarning",
      "StopAsyncIteration",
      "StopIteration",
      "SyntaxError",
      "SyntaxWarning",
      "SystemError",
      "SystemExit",
      "TabError",
      "TimeoutError",
      "TypeError",
      "UnboundLocalError",
      "UnicodeDecodeError",
      "UnicodeEncodeError",
      "UnicodeError",
      "UnicodeTranslateError",
      "UnicodeWarning",
      "UserWarning",
      "ValueError",
      "Warning",
      "ZeroDivisionError"
    ].map((n) => ({ label: n, type: "type" }))).concat(/* @__PURE__ */ [
      "bool",
      "bytearray",
      "bytes",
      "classmethod",
      "complex",
      "float",
      "frozenset",
      "int",
      "list",
      "map",
      "memoryview",
      "object",
      "range",
      "set",
      "staticmethod",
      "str",
      "super",
      "tuple",
      "type"
    ].map((n) => ({ label: n, type: "class" }))).concat(/* @__PURE__ */ [
      "abs",
      "aiter",
      "all",
      "anext",
      "any",
      "ascii",
      "bin",
      "breakpoint",
      "callable",
      "chr",
      "compile",
      "delattr",
      "dict",
      "dir",
      "divmod",
      "enumerate",
      "eval",
      "exec",
      "exit",
      "filter",
      "format",
      "getattr",
      "globals",
      "hasattr",
      "hash",
      "help",
      "hex",
      "id",
      "input",
      "isinstance",
      "issubclass",
      "iter",
      "len",
      "license",
      "locals",
      "max",
      "min",
      "next",
      "oct",
      "open",
      "ord",
      "pow",
      "print",
      "property",
      "quit",
      "repr",
      "reversed",
      "round",
      "setattr",
      "slice",
      "sorted",
      "sum",
      "vars",
      "zip"
    ].map((n) => ({ label: n, type: "function" })));
    snippets2 = [
      /* @__PURE__ */ snippetCompletion("def ${name}(${params}):\n	${}", {
        label: "def",
        detail: "function",
        type: "keyword"
      }),
      /* @__PURE__ */ snippetCompletion("for ${name} in ${collection}:\n	${}", {
        label: "for",
        detail: "loop",
        type: "keyword"
      }),
      /* @__PURE__ */ snippetCompletion("while ${}:\n	${}", {
        label: "while",
        detail: "loop",
        type: "keyword"
      }),
      /* @__PURE__ */ snippetCompletion("try:\n	${}\nexcept ${error}:\n	${}", {
        label: "try",
        detail: "/ except block",
        type: "keyword"
      }),
      /* @__PURE__ */ snippetCompletion("if ${}:\n	\n", {
        label: "if",
        detail: "block",
        type: "keyword"
      }),
      /* @__PURE__ */ snippetCompletion("if ${}:\n	${}\nelse:\n	${}", {
        label: "if",
        detail: "/ else block",
        type: "keyword"
      }),
      /* @__PURE__ */ snippetCompletion("class ${name}:\n	def __init__(self, ${params}):\n			${}", {
        label: "class",
        detail: "definition",
        type: "keyword"
      }),
      /* @__PURE__ */ snippetCompletion("import ${module}", {
        label: "import",
        detail: "statement",
        type: "keyword"
      }),
      /* @__PURE__ */ snippetCompletion("from ${module} import ${names}", {
        label: "from",
        detail: "import",
        type: "keyword"
      })
    ];
    globalCompletion = /* @__PURE__ */ ifNotIn(dontComplete2, /* @__PURE__ */ completeFromList(/* @__PURE__ */ globals.concat(snippets2)));
    pythonLanguage = /* @__PURE__ */ LRLanguage.define({
      name: "python",
      parser: /* @__PURE__ */ parser2.configure({
        props: [
          /* @__PURE__ */ indentNodeProp.add({
            Body: (context2) => {
              var _a2;
              let body = /^\s*(#|$)/.test(context2.textAfter) && innerBody(context2) || context2.node;
              return (_a2 = indentBody(context2, body)) !== null && _a2 !== void 0 ? _a2 : context2.continue();
            },
            MatchBody: (context2) => {
              var _a2;
              let inner = innerBody(context2);
              return (_a2 = indentBody(context2, inner || context2.node)) !== null && _a2 !== void 0 ? _a2 : context2.continue();
            },
            IfStatement: (cx) => /^\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
            "ForStatement WhileStatement": (cx) => /^\s*else:/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
            TryStatement: (cx) => /^\s*(except[ :]|finally:|else:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
            MatchStatement: (cx) => {
              if (/^\s*case /.test(cx.textAfter))
                return cx.baseIndent + cx.unit;
              return cx.continue();
            },
            "TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": /* @__PURE__ */ delimitedIndent({ closing: ")" }),
            "DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": /* @__PURE__ */ delimitedIndent({ closing: "}" }),
            "ArrayExpression ArrayComprehensionExpression": /* @__PURE__ */ delimitedIndent({ closing: "]" }),
            MemberExpression: (cx) => cx.baseIndent + cx.unit,
            "String FormatString": () => null,
            Script: (context2) => {
              var _a2;
              let inner = innerBody(context2);
              return (_a2 = inner && indentBody(context2, inner)) !== null && _a2 !== void 0 ? _a2 : context2.continue();
            }
          }),
          /* @__PURE__ */ foldNodeProp.add({
            "ArrayExpression DictionaryExpression SetExpression TupleExpression": foldInside,
            Body: (node, state) => ({ from: node.from + 1, to: node.to - (node.to == state.doc.length ? 0 : 1) }),
            "String FormatString": (node, state) => ({ from: state.doc.lineAt(node.from).to, to: node.to })
          })
        ]
      }),
      languageData: {
        closeBrackets: {
          brackets: ["(", "[", "{", "'", '"', "'''", '"""'],
          stringPrefixes: [
            "f",
            "fr",
            "rf",
            "r",
            "u",
            "b",
            "br",
            "rb",
            "F",
            "FR",
            "RF",
            "R",
            "U",
            "B",
            "BR",
            "RB"
          ]
        },
        commentTokens: { line: "#" },
        // Indent logic logic are triggered upon below input patterns
        indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:|case\s+[^:]*:?)$/
      }
    });
  }
});

// node_modules/@lezer/html/dist/index.js
function nameChar(ch) {
  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161;
}
function tagNameAfter(input2, offset) {
  let pos = input2.pos + offset;
  if (cachedPos == pos && cachedInput == input2) return cachedName;
  let next = input2.peek(offset), name2 = "";
  for (; ; ) {
    if (!nameChar(next)) break;
    name2 += String.fromCharCode(next);
    next = input2.peek(++offset);
  }
  cachedInput = input2;
  cachedPos = pos;
  return cachedName = name2 ? name2.toLowerCase() : next == question2 || next == bang ? void 0 : null;
}
function ElementContext(name2, parent) {
  this.name = name2;
  this.parent = parent;
}
function inForeignElement(context2) {
  for (; context2; context2 = context2.parent)
    if (context2.name == "svg" || context2.name == "math") return true;
  return false;
}
function contentTokenizer(tag, textToken, endToken) {
  let lastState = 2 + tag.length;
  return new ExternalTokenizer((input2) => {
    for (let state = 0, matchedLen = 0, i = 0; ; i++) {
      if (input2.next < 0) {
        if (i) input2.acceptToken(textToken);
        break;
      }
      if (state == 0 && input2.next == lessThan || state == 1 && input2.next == slash2 || state >= 2 && state < lastState && input2.next == tag.charCodeAt(state - 2)) {
        state++;
        matchedLen++;
      } else if (state == lastState && input2.next == greaterThan) {
        if (i > matchedLen)
          input2.acceptToken(textToken, -matchedLen);
        else
          input2.acceptToken(endToken, -(matchedLen - 2));
        break;
      } else if ((input2.next == 10 || input2.next == 13) && i) {
        input2.acceptToken(textToken, 1);
        break;
      } else {
        state = matchedLen = 0;
      }
      input2.advance();
    }
  });
}
function getAttrs2(openTag, input2) {
  let attrs = /* @__PURE__ */ Object.create(null);
  for (let att of openTag.getChildren(Attribute2)) {
    let name2 = att.getChild(AttributeName), value = att.getChild(AttributeValue) || att.getChild(UnquotedAttributeValue);
    if (name2) attrs[input2.read(name2.from, name2.to)] = !value ? "" : value.type.id == AttributeValue ? input2.read(value.from + 1, value.to - 1) : input2.read(value.from, value.to);
  }
  return attrs;
}
function findTagName(openTag, input2) {
  let tagNameNode = openTag.getChild(TagName);
  return tagNameNode ? input2.read(tagNameNode.from, tagNameNode.to) : " ";
}
function maybeNest(node, input2, tags3) {
  let attrs;
  for (let tag of tags3) {
    if (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs2(node.node.parent.firstChild, input2))))
      return { parser: tag.parser };
  }
  return null;
}
function configureNesting(tags3 = [], attributes = []) {
  let script = [], style = [], textarea = [], other = [];
  for (let tag of tags3) {
    let array = tag.tag == "script" ? script : tag.tag == "style" ? style : tag.tag == "textarea" ? textarea : other;
    array.push(tag);
  }
  let attrs = attributes.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let attr of attributes) (attrs[attr.name] || (attrs[attr.name] = [])).push(attr);
  return parseMixed((node, input2) => {
    let id2 = node.type.id;
    if (id2 == ScriptText) return maybeNest(node, input2, script);
    if (id2 == StyleText) return maybeNest(node, input2, style);
    if (id2 == TextareaText) return maybeNest(node, input2, textarea);
    if (id2 == Element2 && other.length) {
      let n = node.node, open = n.firstChild, tagName = open && findTagName(open, input2), attrs2;
      if (tagName) for (let tag of other) {
        if (tag.tag == tagName && (!tag.attrs || tag.attrs(attrs2 || (attrs2 = getAttrs2(open, input2))))) {
          let close = n.lastChild;
          let to = close.type.id == CloseTag ? close.from : n.to;
          if (to > open.to)
            return { parser: tag.parser, overlay: [{ from: open.to, to }] };
        }
      }
    }
    if (attrs && id2 == Attribute2) {
      let n = node.node, nameNode;
      if (nameNode = n.firstChild) {
        let matches = attrs[input2.read(nameNode.from, nameNode.to)];
        if (matches) for (let attr of matches) {
          if (attr.tagName && attr.tagName != findTagName(n.parent, input2)) continue;
          let value = n.lastChild;
          if (value.type.id == AttributeValue) {
            let from2 = value.from + 1;
            let last4 = value.lastChild, to = value.to - (last4 && last4.isError ? 0 : 1);
            if (to > from2) return { parser: attr.parser, overlay: [{ from: from2, to }] };
          } else if (value.type.id == UnquotedAttributeValue) {
            return { parser: attr.parser, overlay: [{ from: value.from, to: value.to }] };
          }
        }
      }
    }
    return null;
  });
}
var scriptText, StartCloseScriptTag, styleText, StartCloseStyleTag, textareaText, StartCloseTextareaTag, EndTag, SelfClosingEndTag, StartTag, StartScriptTag, StartStyleTag, StartTextareaTag, StartSelfClosingTag, StartCloseTag, NoMatchStartCloseTag, MismatchedStartCloseTag, missingCloseTag, IncompleteTag, IncompleteCloseTag, commentContent$1, Element2, TagName, Attribute2, AttributeName, AttributeValue, UnquotedAttributeValue, ScriptText, StyleText, TextareaText, OpenTag, CloseTag, Dialect_noMatch, Dialect_selfClosing, selfClosers, implicitlyClosed, closeOnOpen, cachedName, cachedInput, cachedPos, lessThan, greaterThan, slash2, question2, bang, dash, startTagTerms, elementContext, tagStart, commentContent, endTag, scriptTokens, styleTokens, textareaTokens, htmlHighlighting, parser3;
var init_dist12 = __esm({
  "node_modules/@lezer/html/dist/index.js"() {
    "use strict";
    init_dist4();
    init_dist5();
    init_dist3();
    scriptText = 55;
    StartCloseScriptTag = 1;
    styleText = 56;
    StartCloseStyleTag = 2;
    textareaText = 57;
    StartCloseTextareaTag = 3;
    EndTag = 4;
    SelfClosingEndTag = 5;
    StartTag = 6;
    StartScriptTag = 7;
    StartStyleTag = 8;
    StartTextareaTag = 9;
    StartSelfClosingTag = 10;
    StartCloseTag = 11;
    NoMatchStartCloseTag = 12;
    MismatchedStartCloseTag = 13;
    missingCloseTag = 58;
    IncompleteTag = 14;
    IncompleteCloseTag = 15;
    commentContent$1 = 59;
    Element2 = 21;
    TagName = 23;
    Attribute2 = 24;
    AttributeName = 25;
    AttributeValue = 27;
    UnquotedAttributeValue = 28;
    ScriptText = 29;
    StyleText = 32;
    TextareaText = 35;
    OpenTag = 37;
    CloseTag = 38;
    Dialect_noMatch = 0;
    Dialect_selfClosing = 1;
    selfClosers = {
      area: true,
      base: true,
      br: true,
      col: true,
      command: true,
      embed: true,
      frame: true,
      hr: true,
      img: true,
      input: true,
      keygen: true,
      link: true,
      meta: true,
      param: true,
      source: true,
      track: true,
      wbr: true,
      menuitem: true
    };
    implicitlyClosed = {
      dd: true,
      li: true,
      optgroup: true,
      option: true,
      p: true,
      rp: true,
      rt: true,
      tbody: true,
      td: true,
      tfoot: true,
      th: true,
      tr: true
    };
    closeOnOpen = {
      dd: { dd: true, dt: true },
      dt: { dd: true, dt: true },
      li: { li: true },
      option: { option: true, optgroup: true },
      optgroup: { optgroup: true },
      p: {
        address: true,
        article: true,
        aside: true,
        blockquote: true,
        dir: true,
        div: true,
        dl: true,
        fieldset: true,
        footer: true,
        form: true,
        h1: true,
        h2: true,
        h3: true,
        h4: true,
        h5: true,
        h6: true,
        header: true,
        hgroup: true,
        hr: true,
        menu: true,
        nav: true,
        ol: true,
        p: true,
        pre: true,
        section: true,
        table: true,
        ul: true
      },
      rp: { rp: true, rt: true },
      rt: { rp: true, rt: true },
      tbody: { tbody: true, tfoot: true },
      td: { td: true, th: true },
      tfoot: { tbody: true },
      th: { td: true, th: true },
      thead: { tbody: true, tfoot: true },
      tr: { tr: true }
    };
    cachedName = null;
    cachedInput = null;
    cachedPos = 0;
    lessThan = 60;
    greaterThan = 62;
    slash2 = 47;
    question2 = 63;
    bang = 33;
    dash = 45;
    startTagTerms = [StartTag, StartSelfClosingTag, StartScriptTag, StartStyleTag, StartTextareaTag];
    elementContext = new ContextTracker({
      start: null,
      shift(context2, term, stack, input2) {
        return startTagTerms.indexOf(term) > -1 ? new ElementContext(tagNameAfter(input2, 1) || "", context2) : context2;
      },
      reduce(context2, term) {
        return term == Element2 && context2 ? context2.parent : context2;
      },
      reuse(context2, node, stack, input2) {
        let type = node.type.id;
        return type == StartTag || type == OpenTag ? new ElementContext(tagNameAfter(input2, 1) || "", context2) : context2;
      },
      strict: false
    });
    tagStart = new ExternalTokenizer((input2, stack) => {
      if (input2.next != lessThan) {
        if (input2.next < 0 && stack.context) input2.acceptToken(missingCloseTag);
        return;
      }
      input2.advance();
      let close = input2.next == slash2;
      if (close) input2.advance();
      let name2 = tagNameAfter(input2, 0);
      if (name2 === void 0) return;
      if (!name2) return input2.acceptToken(close ? IncompleteCloseTag : IncompleteTag);
      let parent = stack.context ? stack.context.name : null;
      if (close) {
        if (name2 == parent) return input2.acceptToken(StartCloseTag);
        if (parent && implicitlyClosed[parent]) return input2.acceptToken(missingCloseTag, -2);
        if (stack.dialectEnabled(Dialect_noMatch)) return input2.acceptToken(NoMatchStartCloseTag);
        for (let cx = stack.context; cx; cx = cx.parent) if (cx.name == name2) return;
        input2.acceptToken(MismatchedStartCloseTag);
      } else {
        if (name2 == "script") return input2.acceptToken(StartScriptTag);
        if (name2 == "style") return input2.acceptToken(StartStyleTag);
        if (name2 == "textarea") return input2.acceptToken(StartTextareaTag);
        if (selfClosers.hasOwnProperty(name2)) return input2.acceptToken(StartSelfClosingTag);
        if (parent && closeOnOpen[parent] && closeOnOpen[parent][name2]) input2.acceptToken(missingCloseTag, -1);
        else input2.acceptToken(StartTag);
      }
    }, { contextual: true });
    commentContent = new ExternalTokenizer((input2) => {
      for (let dashes = 0, i = 0; ; i++) {
        if (input2.next < 0) {
          if (i) input2.acceptToken(commentContent$1);
          break;
        }
        if (input2.next == dash) {
          dashes++;
        } else if (input2.next == greaterThan && dashes >= 2) {
          if (i >= 3) input2.acceptToken(commentContent$1, -2);
          break;
        } else {
          dashes = 0;
        }
        input2.advance();
      }
    });
    endTag = new ExternalTokenizer((input2, stack) => {
      if (input2.next == slash2 && input2.peek(1) == greaterThan) {
        let selfClosing = stack.dialectEnabled(Dialect_selfClosing) || inForeignElement(stack.context);
        input2.acceptToken(selfClosing ? SelfClosingEndTag : EndTag, 2);
      } else if (input2.next == greaterThan) {
        input2.acceptToken(EndTag, 1);
      }
    });
    scriptTokens = contentTokenizer("script", scriptText, StartCloseScriptTag);
    styleTokens = contentTokenizer("style", styleText, StartCloseStyleTag);
    textareaTokens = contentTokenizer("textarea", textareaText, StartCloseTextareaTag);
    htmlHighlighting = styleTags({
      "Text RawText IncompleteTag IncompleteCloseTag": tags.content,
      "StartTag StartCloseTag SelfClosingEndTag EndTag": tags.angleBracket,
      TagName: tags.tagName,
      "MismatchedCloseTag/TagName": [tags.tagName, tags.invalid],
      AttributeName: tags.attributeName,
      "AttributeValue UnquotedAttributeValue": tags.attributeValue,
      Is: tags.definitionOperator,
      "EntityReference CharacterReference": tags.character,
      Comment: tags.blockComment,
      ProcessingInst: tags.processingInstruction,
      DoctypeDecl: tags.documentMeta
    });
    parser3 = LRParser.deserialize({
      version: 14,
      states: ",xOVO!rOOO!ZQ#tO'#CrO!`Q#tO'#C{O!eQ#tO'#DOO!jQ#tO'#DRO!oQ#tO'#DTO!tOaO'#CqO#PObO'#CqO#[OdO'#CqO$kO!rO'#CqOOO`'#Cq'#CqO$rO$fO'#DUO$zQ#tO'#DWO%PQ#tO'#DXOOO`'#Dl'#DlOOO`'#DZ'#DZQVO!rOOO%UQ&rO,59^O%aQ&rO,59gO%lQ&rO,59jO%wQ&rO,59mO&SQ&rO,59oOOOa'#D_'#D_O&_OaO'#CyO&jOaO,59]OOOb'#D`'#D`O&rObO'#C|O&}ObO,59]OOOd'#Da'#DaO'VOdO'#DPO'bOdO,59]OOO`'#Db'#DbO'jO!rO,59]O'qQ#tO'#DSOOO`,59],59]OOOp'#Dc'#DcO'vO$fO,59pOOO`,59p,59pO(OQ#|O,59rO(TQ#|O,59sOOO`-E7X-E7XO(YQ&rO'#CtOOQW'#D['#D[O(hQ&rO1G.xOOOa1G.x1G.xOOO`1G/Z1G/ZO(sQ&rO1G/ROOOb1G/R1G/RO)OQ&rO1G/UOOOd1G/U1G/UO)ZQ&rO1G/XOOO`1G/X1G/XO)fQ&rO1G/ZOOOa-E7]-E7]O)qQ#tO'#CzOOO`1G.w1G.wOOOb-E7^-E7^O)vQ#tO'#C}OOOd-E7_-E7_O){Q#tO'#DQOOO`-E7`-E7`O*QQ#|O,59nOOOp-E7a-E7aOOO`1G/[1G/[OOO`1G/^1G/^OOO`1G/_1G/_O*VQ,UO,59`OOQW-E7Y-E7YOOOa7+$d7+$dOOO`7+$u7+$uOOOb7+$m7+$mOOOd7+$p7+$pOOO`7+$s7+$sO*bQ#|O,59fO*gQ#|O,59iO*lQ#|O,59lOOO`1G/Y1G/YO*qO7[O'#CwO+SOMhO'#CwOOQW1G.z1G.zOOO`1G/Q1G/QOOO`1G/T1G/TOOO`1G/W1G/WOOOO'#D]'#D]O+eO7[O,59cOOQW,59c,59cOOOO'#D^'#D^O+vOMhO,59cOOOO-E7Z-E7ZOOQW1G.}1G.}OOOO-E7[-E7[",
      stateData: ",c~O!_OS~OUSOVPOWQOXROYTO[]O][O^^O_^Oa^Ob^Oc^Od^Oy^O|_O!eZO~OgaO~OgbO~OgcO~OgdO~OgeO~O!XfOPmP![mP~O!YiOQpP![pP~O!ZlORsP![sP~OUSOVPOWQOXROYTOZqO[]O][O^^O_^Oa^Ob^Oc^Od^Oy^O!eZO~O![rO~P#gO!]sO!fuO~OgvO~OgwO~OS|OT}OiyO~OS!POT}OiyO~OS!ROT}OiyO~OS!TOT}OiyO~OS}OT}OiyO~O!XfOPmX![mX~OP!WO![!XO~O!YiOQpX![pX~OQ!ZO![!XO~O!ZlORsX![sX~OR!]O![!XO~O![!XO~P#gOg!_O~O!]sO!f!aO~OS!bO~OS!cO~Oj!dOShXThXihX~OS!fOT!gOiyO~OS!hOT!gOiyO~OS!iOT!gOiyO~OS!jOT!gOiyO~OS!gOT!gOiyO~Og!kO~Og!lO~Og!mO~OS!nO~Ol!qO!a!oO!c!pO~OS!rO~OS!sO~OS!tO~Ob!uOc!uOd!uO!a!wO!b!uO~Ob!xOc!xOd!xO!c!wO!d!xO~Ob!uOc!uOd!uO!a!{O!b!uO~Ob!xOc!xOd!xO!c!{O!d!xO~OT~cbd!ey|!e~",
      goto: "%q!aPPPPPPPPPPPPPPPPPPPPP!b!hP!nPP!zP!}#Q#T#Z#^#a#g#j#m#s#y!bP!b!bP$P$V$m$s$y%P%V%]%cPPPPPPPP%iX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
      nodeNames: "\u26A0 StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
      maxTerm: 68,
      context: elementContext,
      nodeProps: [
        ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 22, 31, 34, 37, "CloseTag"],
        ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 30, 33, 36, 38, "OpenTag"],
        ["group", -10, 14, 15, 18, 19, 20, 21, 40, 41, 42, 43, "Entity", 17, "Entity TextContent", -3, 29, 32, 35, "TextContent Entity"],
        ["isolate", -11, 22, 30, 31, 33, 34, 36, 37, 38, 39, 42, 43, "ltr", -3, 27, 28, 40, ""]
      ],
      propSources: [htmlHighlighting],
      skippedNodes: [0],
      repeatNodeCount: 9,
      tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|caPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bXaP!b`!dpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UVaP!dpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pTaPOv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!dpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({WaP!b`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!b`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!b`!dpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYlWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]`aP!b`!dp!_^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljiSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebiSlWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXiSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vciSaP!b`!dpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!ahaP!dpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WiiSlWd!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zblWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOb!R!R7tP;=`<%l7S!Z8OYlWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{iiSlWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbiSlWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QciSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXiSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhiSlWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TalWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOc!R!RAwP;=`<%lAY!ZBRYlWc!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhiSlWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbiSlWc!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbiSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXiSc!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!cxaP!b`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYliSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_kiSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_XaP!b`!dp!fQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZiSgQaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!b`!dpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!b`!dpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!b`!dpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!b`!dp!ePOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!b`!dpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!b`!dpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!b`!dpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!b`!dpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!b`!dpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!b`!dpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!b`!dpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!dpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO|PP!-nP;=`<%l!-Sq!-xS!dp|POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!b`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!b`|POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!b`!dp|POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!b`!dpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!b`!dpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!b`!dpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!b`!dpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!b`!dpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!b`!dpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!b`!dpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!dpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOyPP!7TP;=`<%l!6Vq!7]V!dpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!dpyPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!b`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!b`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!b`yPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!b`!dpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!b`!dpyPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXjSaP!b`!dpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
      tokenizers: [scriptTokens, styleTokens, textareaTokens, endTag, tagStart, commentContent, 0, 1, 2, 3, 4, 5],
      topRules: { "Document": [0, 16] },
      dialects: { noMatch: 0, selfClosing: 515 },
      tokenPrec: 517
    });
  }
});

// node_modules/@lezer/css/dist/index.js
function isAlpha(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 161;
}
function isDigit(ch) {
  return ch >= 48 && ch <= 57;
}
function isHex2(ch) {
  return isDigit(ch) || ch >= 97 && ch <= 102 || ch >= 65 && ch <= 70;
}
var descendantOp, Unit, identifier, callee, VariableName, queryIdentifier, queryVariableName, QueryCallee, space3, colon, parenL, underscore, bracketL2, dash2, period, hash2, percent, ampersand, backslash2, newline3, asterisk, identifierTokens, identifiers, queryIdentifiers, descendant, unitToken, cssHighlighting, spec_callee, spec_queryIdentifier, spec_QueryCallee, spec_AtKeyword, spec_identifier3, parser4;
var init_dist13 = __esm({
  "node_modules/@lezer/css/dist/index.js"() {
    "use strict";
    init_dist4();
    init_dist5();
    descendantOp = 122;
    Unit = 1;
    identifier = 123;
    callee = 124;
    VariableName = 2;
    queryIdentifier = 125;
    queryVariableName = 3;
    QueryCallee = 4;
    space3 = [
      9,
      10,
      11,
      12,
      13,
      32,
      133,
      160,
      5760,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8199,
      8200,
      8201,
      8202,
      8232,
      8233,
      8239,
      8287,
      12288
    ];
    colon = 58;
    parenL = 40;
    underscore = 95;
    bracketL2 = 91;
    dash2 = 45;
    period = 46;
    hash2 = 35;
    percent = 37;
    ampersand = 38;
    backslash2 = 92;
    newline3 = 10;
    asterisk = 42;
    identifierTokens = (id2, varName, callee2) => (input2, stack) => {
      for (let inside2 = false, dashes = 0, i = 0; ; i++) {
        let { next } = input2;
        if (isAlpha(next) || next == dash2 || next == underscore || inside2 && isDigit(next)) {
          if (!inside2 && (next != dash2 || i > 0)) inside2 = true;
          if (dashes === i && next == dash2) dashes++;
          input2.advance();
        } else if (next == backslash2 && input2.peek(1) != newline3) {
          input2.advance();
          if (isHex2(input2.next)) {
            do {
              input2.advance();
            } while (isHex2(input2.next));
            if (input2.next == 32) input2.advance();
          } else if (input2.next > -1) {
            input2.advance();
          }
          inside2 = true;
        } else {
          if (inside2) input2.acceptToken(
            dashes == 2 && stack.canShift(VariableName) ? varName : next == parenL ? callee2 : id2
          );
          break;
        }
      }
    };
    identifiers = new ExternalTokenizer(
      identifierTokens(identifier, VariableName, callee)
    );
    queryIdentifiers = new ExternalTokenizer(
      identifierTokens(queryIdentifier, queryVariableName, QueryCallee)
    );
    descendant = new ExternalTokenizer((input2) => {
      if (space3.includes(input2.peek(-1))) {
        let { next } = input2;
        if (isAlpha(next) || next == underscore || next == hash2 || next == period || next == asterisk || next == bracketL2 || next == colon && isAlpha(input2.peek(1)) || next == dash2 || next == ampersand)
          input2.acceptToken(descendantOp);
      }
    });
    unitToken = new ExternalTokenizer((input2) => {
      if (!space3.includes(input2.peek(-1))) {
        let { next } = input2;
        if (next == percent) {
          input2.advance();
          input2.acceptToken(Unit);
        }
        if (isAlpha(next)) {
          do {
            input2.advance();
          } while (isAlpha(input2.next) || isDigit(input2.next));
          input2.acceptToken(Unit);
        }
      }
    });
    cssHighlighting = styleTags({
      "AtKeyword import charset namespace keyframes media supports": tags.definitionKeyword,
      "from to selector": tags.keyword,
      NamespaceName: tags.namespace,
      KeyframeName: tags.labelName,
      KeyframeRangeName: tags.operatorKeyword,
      TagName: tags.tagName,
      ClassName: tags.className,
      PseudoClassName: tags.constant(tags.className),
      IdName: tags.labelName,
      "FeatureName PropertyName": tags.propertyName,
      AttributeName: tags.attributeName,
      NumberLiteral: tags.number,
      KeywordQuery: tags.keyword,
      UnaryQueryOp: tags.operatorKeyword,
      "CallTag ValueName": tags.atom,
      VariableName: tags.variableName,
      Callee: tags.operatorKeyword,
      Unit: tags.unit,
      "UniversalSelector NestingSelector": tags.definitionOperator,
      "MatchOp CompareOp": tags.compareOperator,
      "ChildOp SiblingOp, LogicOp": tags.logicOperator,
      BinOp: tags.arithmeticOperator,
      Important: tags.modifier,
      Comment: tags.blockComment,
      ColorLiteral: tags.color,
      "ParenthesizedContent StringLiteral": tags.string,
      ":": tags.punctuation,
      "PseudoOp #": tags.derefOperator,
      "; ,": tags.separator,
      "( )": tags.paren,
      "[ ]": tags.squareBracket,
      "{ }": tags.brace
    });
    spec_callee = { __proto__: null, lang: 38, "nth-child": 38, "nth-last-child": 38, "nth-of-type": 38, "nth-last-of-type": 38, dir: 38, "host-context": 38, if: 84, url: 124, "url-prefix": 124, domain: 124, regexp: 124 };
    spec_queryIdentifier = { __proto__: null, or: 98, and: 98, not: 106, only: 106, layer: 170 };
    spec_QueryCallee = { __proto__: null, selector: 112, layer: 166 };
    spec_AtKeyword = { __proto__: null, "@import": 162, "@media": 174, "@charset": 178, "@namespace": 182, "@keyframes": 188, "@supports": 200, "@scope": 204 };
    spec_identifier3 = { __proto__: null, to: 207 };
    parser4 = LRParser.deserialize({
      version: 14,
      states: "EbQYQdOOO#qQdOOP#xO`OOOOQP'#Cf'#CfOOQP'#Ce'#CeO#}QdO'#ChO$nQaO'#CcO$xQdO'#CkO%TQdO'#DpO%YQdO'#DrO%_QdO'#DuO%_QdO'#DxOOQP'#FV'#FVO&eQhO'#EhOOQS'#FU'#FUOOQS'#Ek'#EkQYQdOOO&lQdO'#EOO&PQhO'#EUO&lQdO'#EWO'aQdO'#EYO'lQdO'#E]O'tQhO'#EcO(VQdO'#EeO(bQaO'#CfO)VQ`O'#D{O)[Q`O'#F`O)gQdO'#F`QOQ`OOP)qO&jO'#CaPOOO)C@t)C@tOOQP'#Cj'#CjOOQP,59S,59SO#}QdO,59SO)|QdO,59VO%TQdO,5:[O%YQdO,5:^O%_QdO,5:aO%_QdO,5:cO%_QdO,5:dO%_QdO'#ErO*XQ`O,58}O*aQdO'#DzOOQS,58},58}OOQP'#Cn'#CnOOQO'#Dn'#DnOOQP,59V,59VO*hQ`O,59VO*mQ`O,59VOOQP'#Dq'#DqOOQP,5:[,5:[OOQO'#Ds'#DsO*rQpO,5:^O+]QaO,5:aO+sQaO,5:dOOQW'#DZ'#DZO,ZQhO'#DdO,xQhO'#FaO'tQhO'#DbO-WQ`O'#DhOOQW'#F['#F[O-]Q`O,5;SO-eQ`O'#DeOOQS-E8i-E8iOOQ['#Cs'#CsO-jQdO'#CtO.QQdO'#CzO.hQdO'#C}O/OQ!pO'#DPO1RQ!jO,5:jOOQO'#DU'#DUO*mQ`O'#DTO1cQ!nO'#FXO3`Q`O'#DVO3eQ`O'#DkOOQ['#FX'#FXO-`Q`O,5:pO3jQ!bO,5:rOOQS'#E['#E[O3rQ`O,5:tO3wQdO,5:tOOQO'#E_'#E_O4PQ`O,5:wO4UQhO,5:}O%_QdO'#DgOOQS,5;P,5;PO-eQ`O,5;PO4^QdO,5;PO4fQdO,5:gO4vQdO'#EtO5TQ`O,5;zO5TQ`O,5;zPOOO'#Ej'#EjP5`O&jO,58{POOO,58{,58{OOQP1G.n1G.nOOQP1G.q1G.qO*hQ`O1G.qO*mQ`O1G.qOOQP1G/v1G/vO5kQpO1G/xO5sQaO1G/{O6ZQaO1G/}O6qQaO1G0OO7XQaO,5;^OOQO-E8p-E8pOOQS1G.i1G.iO7cQ`O,5:fO7hQdO'#DoO7oQdO'#CrOOQP1G/x1G/xO&lQdO1G/xO7vQ!jO'#DZO8UQ!bO,59vO8^QhO,5:OOOQO'#F]'#F]O8XQ!bO,59zO'tQhO,59xO8fQhO'#EvO8sQ`O,5;{O9OQhO,59|O9uQhO'#DiOOQW,5:S,5:SOOQS1G0n1G0nOOQW,5:P,5:PO9|Q!fO'#FYOOQS'#FY'#FYOOQS'#Em'#EmO;^QdO,59`OOQ[,59`,59`O;tQdO,59fOOQ[,59f,59fO<[QdO,59iOOQ[,59i,59iOOQ[,59k,59kO&lQdO,59mO<rQhO'#EQOOQW'#EQ'#EQO=WQ`O1G0UO1[QhO1G0UOOQ[,59o,59oO'tQhO'#DXOOQ[,59q,59qO=]Q#tO,5:VOOQS1G0[1G0[OOQS1G0^1G0^OOQS1G0`1G0`O=hQ`O1G0`O=mQdO'#E`OOQS1G0c1G0cOOQS1G0i1G0iO=xQaO,5:RO-`Q`O1G0kOOQS1G0k1G0kO-eQ`O1G0kO>PQ!fO1G0ROOQO1G0R1G0ROOQO,5;`,5;`O>gQdO,5;`OOQO-E8r-E8rO>tQ`O1G1fPOOO-E8h-E8hPOOO1G.g1G.gOOQP7+$]7+$]OOQP7+%d7+%dO&lQdO7+%dOOQS1G0Q1G0QO?PQaO'#F_O?ZQ`O,5:ZO?`Q!fO'#ElO@^QdO'#FWO@hQ`O,59^O@mQ!bO7+%dO&lQdO1G/bO@uQhO1G/fOOQW1G/j1G/jOOQW1G/d1G/dOAWQhO,5;bOOQO-E8t-E8tOAfQhO'#DZOAtQhO'#F^OBPQ`O'#F^OBUQ`O,5:TOOQS-E8k-E8kOOQ[1G.z1G.zOOQ[1G/Q1G/QOOQ[1G/T1G/TOOQ[1G/X1G/XOBZQdO,5:lOOQS7+%p7+%pOB`Q`O7+%pOBeQhO'#DYOBmQ`O,59sO'tQhO,59sOOQ[1G/q1G/qOBuQ`O1G/qOOQS7+%z7+%zOBzQbO'#DPOOQO'#Eb'#EbOCYQ`O'#EaOOQO'#Ea'#EaOCeQ`O'#EwOCmQdO,5:zOOQS,5:z,5:zOOQ[1G/m1G/mOOQS7+&V7+&VO-`Q`O7+&VOCxQ!fO'#EsO&lQdO'#EsOEPQdO7+%mOOQO7+%m7+%mOOQO1G0z1G0zOEdQ!bO<<IOOElQdO'#EqOEvQ`O,5;yOOQP1G/u1G/uOOQS-E8j-E8jOFOQdO'#EpOFYQ`O,5;rOOQ]1G.x1G.xOOQP<<IO<<IOOFbQdO7+$|OOQO'#D]'#D]OFiQ!bO7+%QOFqQhO'#EoOF{Q`O,5;xO&lQdO,5;xOOQW1G/o1G/oOOQO'#ES'#ESOGTQ`O1G0WOOQS<<I[<<I[O&lQdO,59tOGnQhO1G/_OOQ[1G/_1G/_OGuQ`O1G/_OOQW-E8l-E8lOOQ[7+%]7+%]OOQO,5:{,5:{O=pQdO'#ExOCeQ`O,5;cOOQS,5;c,5;cOOQS-E8u-E8uOOQS1G0f1G0fOOQS<<Iq<<IqOG}Q!fO,5;_OOQS-E8q-E8qOOQO<<IX<<IXOOQPAN>jAN>jOIUQaO,5;]OOQO-E8o-E8oOI`QdO,5;[OOQO-E8n-E8nOOQW<<Hh<<HhOOQW<<Hl<<HlOIjQhO<<HlOI{QhO,5;ZOJWQ`O,5;ZOOQO-E8m-E8mOJ]QdO1G1dOBZQdO'#EuOJgQ`O7+%rOOQW7+%r7+%rOJoQ!bO1G/`OOQ[7+$y7+$yOJzQhO7+$yPKRQ`O'#EnOOQO,5;d,5;dOOQO-E8v-E8vOOQS1G0}1G0}OKWQ`OAN>WO&lQdO1G0uOK]Q`O7+'OOOQO,5;a,5;aOOQO-E8s-E8sOOQW<<I^<<I^OOQ[<<He<<HePOQW,5;Y,5;YOOQWG23rG23rOKeQdO7+&a",
      stateData: "Kx~O#sOS#tQQ~OW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#oRO~OQiOW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#ohO~O#m$SP~P!dO#tmO~O#ooO~O]qO`rOarOjsOmtO!juO!mwO#nvO~OpzO!^xO~P$SOc!QO#o|O#p}O~O#o!RO~O#o!TO~OW[OZ[O]TO`VOaVOjWOmXO!jYO!mZO#oRO~OS!]Oe!YO!V![O!Y!`O#q!XOp$TP~Ok$TP~P&POQ!jOe!cOm!dOp!eOr!mOt!mOz!kO!`!lO#o!bO#p!hO#}!fO~Ot!qO!`!lO#o!pO~Ot!sO#o!sO~OS!]Oe!YO!V![O!Y!`O#q!XO~Oe!vOpzO#Z!xO~O]YX`YX`!pXaYXjYXmYXpYX!^YX!jYX!mYX#nYX~O`!zO~Ok!{O#m$SXo$SX~O#m$SXo$SX~P!dO#u#OO#v#OO#w#QO~Oc#UO#o|O#p}O~OpzO!^xO~Oo$SP~P!dOe#`O~Oe#aO~Ol#bO!h#cO~O]qO`rOarOjsOmtO~Op!ia!^!ia!j!ia!m!ia#n!iad!ia~P*zOp!la!^!la!j!la!m!la#n!lad!la~P*zOR#gOS!]Oe!YOr#gOt#gO!V![O!Y!`O#q#dO#}!fO~O!R#iO!^#jOk$TXp$TX~Oe#mO~Ok#oOpzO~Oe!vO~O]#rO`#rOd#uOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl#wO~P&lO]#rO`#rOi#rOj#rOk#rOo#yO~P&lOP#zOSsXesXksXvsX!VsX!YsX!usX!wsX#qsX!TsXQsX]sX`sXdsXisXjsXmsXpsXrsXtsXzsX!`sX#osX#psX#}sXlsXosX!^sX!qsX#msX~Ov#{O!u#|O!w#}Ok$TP~P'tOe#aOS#{Xk#{Xv#{X!V#{X!Y#{X!u#{X!w#{X#q#{XQ#{X]#{X`#{Xd#{Xi#{Xj#{Xm#{Xp#{Xr#{Xt#{Xz#{X!`#{X#o#{X#p#{X#}#{Xl#{Xo#{X!^#{X!q#{X#m#{X~Oe$RO~Oe$TO~Ok$VOv#{O~Ok$WO~Ot$XO!`!lO~Op$YO~OpzO!R#iO~OpzO#Z$`O~O!q$bOk!oa#m!oao!oa~P&lOk#hX#m#hXo#hX~P!dOk!{O#m$Sao$Sa~O#u#OO#v#OO#w$hO~Ol$jO!h$kO~Op!ii!^!ii!j!ii!m!ii#n!iid!ii~P*zOp!ki!^!ki!j!ki!m!ki#n!kid!ki~P*zOp!li!^!li!j!li!m!li#n!lid!li~P*zOp#fa!^#fa~P$SOo$lO~Od$RP~P%_Od#zP~P&lO`!PXd}X!R}X!T!PX~O`$sO!T$tO~Od$uO!R#iO~Ok#jXp#jX!^#jX~P'tO!^#jOk$Tap$Ta~O!R#iOk!Uap!Ua!^!Uad!Ua`!Ua~OS!]Oe!YO!V![O!Y!`O#q$yO~Od$QP~P9dOv#{OQ#|X]#|X`#|Xd#|Xe#|Xi#|Xj#|Xk#|Xm#|Xp#|Xr#|Xt#|Xz#|X!`#|X#o#|X#p#|X#}#|Xl#|Xo#|X~O]#rO`#rOd%OOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl%PO~P&lO]#rO`#rOi#rOj#rOk#rOo%QO~P&lOe%SOS!tXk!tX!V!tX!Y!tX#q!tX~Ok%TO~Od%YOt%ZO!a%ZO~Ok%[O~Oo%cO#o%^O#}%]O~Od%dO~P$SOv#{O!^%hO!q%jOk!oi#m!oio!oi~P&lOk#ha#m#hao#ha~P!dOk!{O#m$Sio$Si~O!^%mOd$RX~P$SOd%oO~Ov#{OQ#`Xd#`Xe#`Xm#`Xp#`Xr#`Xt#`Xz#`X!^#`X!`#`X#o#`X#p#`X#}#`X~O!^%qOd#zX~P&lOd%sO~Ol%tOv#{O~OR#gOr#gOt#gO#q%vO#}!fO~O!R#iOk#jap#ja!^#ja~O`!PXd}X!R}X!^}X~O!R#iO!^%xOd$QX~O`%zO~Od%{O~O#o%|O~Ok&OO~O`&PO!R#iO~Od&ROk&QO~Od&UO~OP#zOpsX!^sXdsX~O#}%]Op#TX!^#TX~OpzO!^&WO~Oo&[O#o%^O#}%]O~Ov#{OQ#gXe#gXk#gXm#gXp#gXr#gXt#gXz#gX!^#gX!`#gX!q#gX#m#gX#o#gX#p#gX#}#gXo#gX~O!^%hO!q&`Ok!oq#m!oqo!oq~P&lOl&aOv#{O~Od#eX!^#eX~P%_O!^%mOd$Ra~Od#dX!^#dX~P&lO!^%qOd#za~Od&fO~P&lOd&gO!T&hO~Od#cX!^#cX~P9dO!^%xOd$Qa~O]&mOd&oO~OS#bae#ba!V#ba!Y#ba#q#ba~Od&qO~PG]Od&qOk&rO~Ov#{OQ#gae#gak#gam#gap#gar#gat#gaz#ga!^#ga!`#ga!q#ga#m#ga#o#ga#p#ga#}#gao#ga~Od#ea!^#ea~P$SOd#da!^#da~P&lOR#gOr#gOt#gO#q%vO#}%]O~O!R#iOd#ca!^#ca~O`&xO~O!^%xOd$Qi~P&lO]&mOd&|O~Ov#{Od|ik|i~Od&}O~PG]Ok'OO~Od'PO~O!^%xOd$Qq~Od#cq!^#cq~P&lO#s!a#t#}]#}v!m~",
      goto: "2h$UPPPPP$VP$YP$c$uP$cP%X$cPP%_PPP%e%o%oPPPPP%oPP%oP&]P%oP%o'W%oP't'w'}'}(^'}P'}P'}P'}'}P(m'}(yP(|PP)p)v$c)|$c*SP$cP$c$cP*Y*{+YP$YP+aP+dP$YP$YP$YP+j$YP+m+p+s+z$YP$YPP$YP,P,V,f,|-[-b-l-r-x.O.U.`.f.l.rPPPPPPPPPPP.x/R/w/z0|P1U1u2O2R2U2[RnQ_^OP`kz!{$dq[OPYZ`kuvwxz!v!{#`$d%mqSOPYZ`kuvwxz!v!{#`$d%mQpTR#RqQ!OVR#SrQ#S!QS$Q!i!jR$i#U!V!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'Q!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QU#g!Y$t&hU%`$Y%b&WR&V%_!V!iac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QR$S!kQ%W$RR&S%Xk!^]bf!Y![!g#i#j#m$P$R%X%xQ#e!YQ${#mQ%w$tQ&j%xR&w&hQ!ygQ#p!`Q$^!xR%f$`R#n!]!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QQ!qdR$X!rQ!PVR#TrQ#S!PR$i#TQ!SWR#VsQ!UXR#WtQ{UQ!wgQ#^yQ#o!_Q$U!nQ$[!uQ$_!yQ%e$^Q&Y%aQ&]%fR&v&XSjPzQ!}kQ$c!{R%k$dZiPkz!{$dR$P!gQ%}%SR&z&mR!rdR!teR$Z!tS%a$Y%bR&t&WV%_$Y%b&WQ#PmR$g#PQ`OSkPzU!a`k$dR$d!{Q$p#aY%p$p%u&d&l'QQ%u$sQ&d%qQ&l%zR'Q&xQ#t!cQ#v!dQ#x!eV$}#t#v#xQ%X$RR&T%XQ%y$zS&k%y&yR&y&lQ%r$pR&e%rQ%n$mR&c%nQyUR#]yQ%i$aR&_%iQ!|jS$e!|$fR$f!}Q&n%}R&{&nQ#k!ZR$x#kQ%b$YR&Z%bQ&X%aR&u&X__OP`kz!{$d^UOP`kz!{$dQ!VYQ!WZQ#XuQ#YvQ#ZwQ#[xQ$]!vQ$m#`R&b%mR$q#aQ!gaQ!oc[#q!c!d!e#t#v#xQ$a!zd$o#a$p$s%q%u%z&d&l&x'QQ$r#cQ%R#{S%g$a%iQ%l$kQ&^%hR&p&P]#s!c!d!e#t#v#xW!Z]b!g$PQ!ufQ#f!YQ#l![Q$v#iQ$w#jQ$z#mS%V$R%XR&i%xQ#h!YQ%w$tR&w&hR$|#mR$n#`QlPR#_zQ!_]Q!nbQ$O!gR%U$P",
      nodeNames: "\u26A0 Unit VariableName VariableName QueryCallee Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector . ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue AtKeyword # ; ] [ BracketedValue } { BracedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee IfExpression if ArgList IfBranch KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp ComparisonQuery CompareOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector ParenthesizedSelector CallQuery ArgList , CallLiteral CallTag ParenthesizedContent PseudoClassName ArgList IdSelector IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp Block Declaration PropertyName Important ImportStatement import Layer layer LayerName layer MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports ScopeStatement scope to AtRule Styles",
      maxTerm: 143,
      nodeProps: [
        ["isolate", -2, 5, 36, ""],
        ["openedBy", 20, "(", 28, "[", 31, "{"],
        ["closedBy", 21, ")", 29, "]", 32, "}"]
      ],
      propSources: [cssHighlighting],
      skippedNodes: [0, 5, 106],
      repeatNodeCount: 15,
      tokenData: "JQ~R!YOX$qX^%i^p$qpq%iqr({rs-ust/itu6Wuv$qvw7Qwx7cxy9Qyz9cz{9h{|:R|}>t}!O?V!O!P?t!P!Q@]!Q![AU![!]BP!]!^B{!^!_C^!_!`DY!`!aDm!a!b$q!b!cEn!c!}$q!}#OG{#O#P$q#P#QH^#Q#R6W#R#o$q#o#pHo#p#q6W#q#rIQ#r#sIc#s#y$q#y#z%i#z$f$q$f$g%i$g#BY$q#BY#BZ%i#BZ$IS$q$IS$I_%i$I_$I|$q$I|$JO%i$JO$JT$q$JT$JU%i$JU$KV$q$KV$KW%i$KW&FU$q&FU&FV%i&FV;'S$q;'S;=`Iz<%lO$q`$tSOy%Qz;'S%Q;'S;=`%c<%lO%Q`%VS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q`%fP;=`<%l%Q~%nh#s~OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Q~'ah#s~!a`OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Qj)OUOy%Qz#]%Q#]#^)b#^;'S%Q;'S;=`%c<%lO%Qj)gU!a`Oy%Qz#a%Q#a#b)y#b;'S%Q;'S;=`%c<%lO%Qj*OU!a`Oy%Qz#d%Q#d#e*b#e;'S%Q;'S;=`%c<%lO%Qj*gU!a`Oy%Qz#c%Q#c#d*y#d;'S%Q;'S;=`%c<%lO%Qj+OU!a`Oy%Qz#f%Q#f#g+b#g;'S%Q;'S;=`%c<%lO%Qj+gU!a`Oy%Qz#h%Q#h#i+y#i;'S%Q;'S;=`%c<%lO%Qj,OU!a`Oy%Qz#T%Q#T#U,b#U;'S%Q;'S;=`%c<%lO%Qj,gU!a`Oy%Qz#b%Q#b#c,y#c;'S%Q;'S;=`%c<%lO%Qj-OU!a`Oy%Qz#h%Q#h#i-b#i;'S%Q;'S;=`%c<%lO%Qj-iS!qY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q~-xWOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c<%lO-u~.gOt~~.jRO;'S-u;'S;=`.s;=`O-u~.vXOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c;=`<%l-u<%lO-u~/fP;=`<%l-uj/nYjYOy%Qz!Q%Q!Q![0^![!c%Q!c!i0^!i#T%Q#T#Z0^#Z;'S%Q;'S;=`%c<%lO%Qj0cY!a`Oy%Qz!Q%Q!Q![1R![!c%Q!c!i1R!i#T%Q#T#Z1R#Z;'S%Q;'S;=`%c<%lO%Qj1WY!a`Oy%Qz!Q%Q!Q![1v![!c%Q!c!i1v!i#T%Q#T#Z1v#Z;'S%Q;'S;=`%c<%lO%Qj1}YrY!a`Oy%Qz!Q%Q!Q![2m![!c%Q!c!i2m!i#T%Q#T#Z2m#Z;'S%Q;'S;=`%c<%lO%Qj2tYrY!a`Oy%Qz!Q%Q!Q![3d![!c%Q!c!i3d!i#T%Q#T#Z3d#Z;'S%Q;'S;=`%c<%lO%Qj3iY!a`Oy%Qz!Q%Q!Q![4X![!c%Q!c!i4X!i#T%Q#T#Z4X#Z;'S%Q;'S;=`%c<%lO%Qj4`YrY!a`Oy%Qz!Q%Q!Q![5O![!c%Q!c!i5O!i#T%Q#T#Z5O#Z;'S%Q;'S;=`%c<%lO%Qj5TY!a`Oy%Qz!Q%Q!Q![5s![!c%Q!c!i5s!i#T%Q#T#Z5s#Z;'S%Q;'S;=`%c<%lO%Qj5zSrY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qd6ZUOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qd6tS!hS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qb7VSZQOy%Qz;'S%Q;'S;=`%c<%lO%Q~7fWOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z<%lO7c~8RRO;'S7c;'S;=`8[;=`O7c~8_XOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z;=`<%l7c<%lO7c~8}P;=`<%l7cj9VSeYOy%Qz;'S%Q;'S;=`%c<%lO%Q~9hOd~n9oUWQvWOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qj:YWvW!mQOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj:wU!a`Oy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Qj;bY!a`#}YOy%Qz!Q%Q!Q![;Z![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj<VY!a`Oy%Qz{%Q{|<u|}%Q}!O<u!O!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj<zU!a`Oy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj=eU!a`#}YOy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj>O[!a`#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj>yS!^YOy%Qz;'S%Q;'S;=`%c<%lO%Qj?[WvWOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj?yU]YOy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Q~@bTvWOy%Qz{@q{;'S%Q;'S;=`%c<%lO%Q~@xS!a`#t~Oy%Qz;'S%Q;'S;=`%c<%lO%QjAZ[#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%QjBUU`YOy%Qz![%Q![!]Bh!];'S%Q;'S;=`%c<%lO%QbBoSaQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjCQSkYOy%Qz;'S%Q;'S;=`%c<%lO%QhCcU!TWOy%Qz!_%Q!_!`Cu!`;'S%Q;'S;=`%c<%lO%QhC|S!TW!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QlDaS!TW!hSOy%Qz;'S%Q;'S;=`%c<%lO%QjDtV!jQ!TWOy%Qz!_%Q!_!`Cu!`!aEZ!a;'S%Q;'S;=`%c<%lO%QbEbS!jQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjEqYOy%Qz}%Q}!OFa!O!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjFfW!a`Oy%Qz!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjGV[iY!a`Oy%Qz}%Q}!OGO!O!Q%Q!Q![GO![!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjHQSmYOy%Qz;'S%Q;'S;=`%c<%lO%QnHcSl^Oy%Qz;'S%Q;'S;=`%c<%lO%QjHtSpYOy%Qz;'S%Q;'S;=`%c<%lO%QjIVSoYOy%Qz;'S%Q;'S;=`%c<%lO%QfIhU!mQOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Q`I}P;=`<%l$q",
      tokenizers: [descendant, unitToken, identifiers, queryIdentifiers, 1, 2, 3, 4, new LocalTokenGroup("m~RRYZ[z{a~~g~aO#v~~dP!P!Qg~lO#w~~", 28, 129)],
      topRules: { "StyleSheet": [0, 6], "Styles": [1, 105] },
      specialized: [{ term: 124, get: (value) => spec_callee[value] || -1 }, { term: 125, get: (value) => spec_queryIdentifier[value] || -1 }, { term: 4, get: (value) => spec_QueryCallee[value] || -1 }, { term: 25, get: (value) => spec_AtKeyword[value] || -1 }, { term: 123, get: (value) => spec_identifier3[value] || -1 }],
      tokenPrec: 1963
    });
  }
});

// node_modules/@codemirror/lang-css/dist/index.js
function properties() {
  if (!_properties && typeof document == "object" && document.body) {
    let { style } = document.body, names = [], seen = /* @__PURE__ */ new Set();
    for (let prop in style)
      if (prop != "cssText" && prop != "cssFloat") {
        if (typeof style[prop] == "string") {
          if (/[A-Z]/.test(prop))
            prop = prop.replace(/[A-Z]/g, (ch) => "-" + ch.toLowerCase());
          if (!seen.has(prop)) {
            names.push(prop);
            seen.add(prop);
          }
        }
      }
    _properties = names.sort().map((name2) => ({ type: "property", label: name2, apply: name2 + ": " }));
  }
  return _properties || [];
}
function isVarArg(node, doc2) {
  var _a2;
  if (node.name == "(" || node.type.isError)
    node = node.parent || node;
  if (node.name != "ArgList")
    return false;
  let callee2 = (_a2 = node.parent) === null || _a2 === void 0 ? void 0 : _a2.firstChild;
  if ((callee2 === null || callee2 === void 0 ? void 0 : callee2.name) != "Callee")
    return false;
  return doc2.sliceString(callee2.from, callee2.to) == "var";
}
function astTop(node) {
  for (let cur2 = node; ; ) {
    if (cur2.type.isTop)
      return cur2;
    if (!(cur2 = cur2.parent))
      return node;
  }
}
function variableNames(doc2, node, isVariable) {
  if (node.to - node.from > 4096) {
    let known = VariablesByNode.get(node);
    if (known)
      return known;
    let result = [], seen = /* @__PURE__ */ new Set(), cursor2 = node.cursor(IterMode.IncludeAnonymous);
    if (cursor2.firstChild())
      do {
        for (let option of variableNames(doc2, cursor2.node, isVariable))
          if (!seen.has(option.label)) {
            seen.add(option.label);
            result.push(option);
          }
      } while (cursor2.nextSibling());
    VariablesByNode.set(node, result);
    return result;
  } else {
    let result = [], seen = /* @__PURE__ */ new Set();
    node.cursor().iterate((node2) => {
      var _a2;
      if (isVariable(node2) && node2.matchContext(declSelector) && ((_a2 = node2.node.nextSibling) === null || _a2 === void 0 ? void 0 : _a2.name) == ":") {
        let name2 = doc2.sliceString(node2.from, node2.to);
        if (!seen.has(name2)) {
          seen.add(name2);
          result.push({ label: name2, type: "variable" });
        }
      }
    });
    return result;
  }
}
function css() {
  return new LanguageSupport(cssLanguage, cssLanguage.data.of({ autocomplete: cssCompletionSource }));
}
var _properties, pseudoClasses, values, tags2, atRules, identifier2, variable, VariablesByNode, declSelector, defineCSSCompletionSource, cssCompletionSource, cssLanguage;
var init_dist14 = __esm({
  "node_modules/@codemirror/lang-css/dist/index.js"() {
    "use strict";
    init_dist13();
    init_dist7();
    init_dist3();
    _properties = null;
    pseudoClasses = /* @__PURE__ */ [
      "active",
      "after",
      "any-link",
      "autofill",
      "backdrop",
      "before",
      "checked",
      "cue",
      "default",
      "defined",
      "disabled",
      "empty",
      "enabled",
      "file-selector-button",
      "first",
      "first-child",
      "first-letter",
      "first-line",
      "first-of-type",
      "focus",
      "focus-visible",
      "focus-within",
      "fullscreen",
      "has",
      "host",
      "host-context",
      "hover",
      "in-range",
      "indeterminate",
      "invalid",
      "is",
      "lang",
      "last-child",
      "last-of-type",
      "left",
      "link",
      "marker",
      "modal",
      "not",
      "nth-child",
      "nth-last-child",
      "nth-last-of-type",
      "nth-of-type",
      "only-child",
      "only-of-type",
      "optional",
      "out-of-range",
      "part",
      "placeholder",
      "placeholder-shown",
      "read-only",
      "read-write",
      "required",
      "right",
      "root",
      "scope",
      "selection",
      "slotted",
      "target",
      "target-text",
      "valid",
      "visited",
      "where"
    ].map((name2) => ({ type: "class", label: name2 }));
    values = /* @__PURE__ */ [
      "above",
      "absolute",
      "activeborder",
      "additive",
      "activecaption",
      "after-white-space",
      "ahead",
      "alias",
      "all",
      "all-scroll",
      "alphabetic",
      "alternate",
      "always",
      "antialiased",
      "appworkspace",
      "asterisks",
      "attr",
      "auto",
      "auto-flow",
      "avoid",
      "avoid-column",
      "avoid-page",
      "avoid-region",
      "axis-pan",
      "background",
      "backwards",
      "baseline",
      "below",
      "bidi-override",
      "blink",
      "block",
      "block-axis",
      "bold",
      "bolder",
      "border",
      "border-box",
      "both",
      "bottom",
      "break",
      "break-all",
      "break-word",
      "bullets",
      "button",
      "button-bevel",
      "buttonface",
      "buttonhighlight",
      "buttonshadow",
      "buttontext",
      "calc",
      "capitalize",
      "caps-lock-indicator",
      "caption",
      "captiontext",
      "caret",
      "cell",
      "center",
      "checkbox",
      "circle",
      "cjk-decimal",
      "clear",
      "clip",
      "close-quote",
      "col-resize",
      "collapse",
      "color",
      "color-burn",
      "color-dodge",
      "column",
      "column-reverse",
      "compact",
      "condensed",
      "contain",
      "content",
      "contents",
      "content-box",
      "context-menu",
      "continuous",
      "copy",
      "counter",
      "counters",
      "cover",
      "crop",
      "cross",
      "crosshair",
      "currentcolor",
      "cursive",
      "cyclic",
      "darken",
      "dashed",
      "decimal",
      "decimal-leading-zero",
      "default",
      "default-button",
      "dense",
      "destination-atop",
      "destination-in",
      "destination-out",
      "destination-over",
      "difference",
      "disc",
      "discard",
      "disclosure-closed",
      "disclosure-open",
      "document",
      "dot-dash",
      "dot-dot-dash",
      "dotted",
      "double",
      "down",
      "e-resize",
      "ease",
      "ease-in",
      "ease-in-out",
      "ease-out",
      "element",
      "ellipse",
      "ellipsis",
      "embed",
      "end",
      "ethiopic-abegede-gez",
      "ethiopic-halehame-aa-er",
      "ethiopic-halehame-gez",
      "ew-resize",
      "exclusion",
      "expanded",
      "extends",
      "extra-condensed",
      "extra-expanded",
      "fantasy",
      "fast",
      "fill",
      "fill-box",
      "fixed",
      "flat",
      "flex",
      "flex-end",
      "flex-start",
      "footnotes",
      "forwards",
      "from",
      "geometricPrecision",
      "graytext",
      "grid",
      "groove",
      "hand",
      "hard-light",
      "help",
      "hidden",
      "hide",
      "higher",
      "highlight",
      "highlighttext",
      "horizontal",
      "hsl",
      "hsla",
      "hue",
      "icon",
      "ignore",
      "inactiveborder",
      "inactivecaption",
      "inactivecaptiontext",
      "infinite",
      "infobackground",
      "infotext",
      "inherit",
      "initial",
      "inline",
      "inline-axis",
      "inline-block",
      "inline-flex",
      "inline-grid",
      "inline-table",
      "inset",
      "inside",
      "intrinsic",
      "invert",
      "italic",
      "justify",
      "keep-all",
      "landscape",
      "large",
      "larger",
      "left",
      "level",
      "lighter",
      "lighten",
      "line-through",
      "linear",
      "linear-gradient",
      "lines",
      "list-item",
      "listbox",
      "listitem",
      "local",
      "logical",
      "loud",
      "lower",
      "lower-hexadecimal",
      "lower-latin",
      "lower-norwegian",
      "lowercase",
      "ltr",
      "luminosity",
      "manipulation",
      "match",
      "matrix",
      "matrix3d",
      "medium",
      "menu",
      "menutext",
      "message-box",
      "middle",
      "min-intrinsic",
      "mix",
      "monospace",
      "move",
      "multiple",
      "multiple_mask_images",
      "multiply",
      "n-resize",
      "narrower",
      "ne-resize",
      "nesw-resize",
      "no-close-quote",
      "no-drop",
      "no-open-quote",
      "no-repeat",
      "none",
      "normal",
      "not-allowed",
      "nowrap",
      "ns-resize",
      "numbers",
      "numeric",
      "nw-resize",
      "nwse-resize",
      "oblique",
      "opacity",
      "open-quote",
      "optimizeLegibility",
      "optimizeSpeed",
      "outset",
      "outside",
      "outside-shape",
      "overlay",
      "overline",
      "padding",
      "padding-box",
      "painted",
      "page",
      "paused",
      "perspective",
      "pinch-zoom",
      "plus-darker",
      "plus-lighter",
      "pointer",
      "polygon",
      "portrait",
      "pre",
      "pre-line",
      "pre-wrap",
      "preserve-3d",
      "progress",
      "push-button",
      "radial-gradient",
      "radio",
      "read-only",
      "read-write",
      "read-write-plaintext-only",
      "rectangle",
      "region",
      "relative",
      "repeat",
      "repeating-linear-gradient",
      "repeating-radial-gradient",
      "repeat-x",
      "repeat-y",
      "reset",
      "reverse",
      "rgb",
      "rgba",
      "ridge",
      "right",
      "rotate",
      "rotate3d",
      "rotateX",
      "rotateY",
      "rotateZ",
      "round",
      "row",
      "row-resize",
      "row-reverse",
      "rtl",
      "run-in",
      "running",
      "s-resize",
      "sans-serif",
      "saturation",
      "scale",
      "scale3d",
      "scaleX",
      "scaleY",
      "scaleZ",
      "screen",
      "scroll",
      "scrollbar",
      "scroll-position",
      "se-resize",
      "self-start",
      "self-end",
      "semi-condensed",
      "semi-expanded",
      "separate",
      "serif",
      "show",
      "single",
      "skew",
      "skewX",
      "skewY",
      "skip-white-space",
      "slide",
      "slider-horizontal",
      "slider-vertical",
      "sliderthumb-horizontal",
      "sliderthumb-vertical",
      "slow",
      "small",
      "small-caps",
      "small-caption",
      "smaller",
      "soft-light",
      "solid",
      "source-atop",
      "source-in",
      "source-out",
      "source-over",
      "space",
      "space-around",
      "space-between",
      "space-evenly",
      "spell-out",
      "square",
      "start",
      "static",
      "status-bar",
      "stretch",
      "stroke",
      "stroke-box",
      "sub",
      "subpixel-antialiased",
      "svg_masks",
      "super",
      "sw-resize",
      "symbolic",
      "symbols",
      "system-ui",
      "table",
      "table-caption",
      "table-cell",
      "table-column",
      "table-column-group",
      "table-footer-group",
      "table-header-group",
      "table-row",
      "table-row-group",
      "text",
      "text-bottom",
      "text-top",
      "textarea",
      "textfield",
      "thick",
      "thin",
      "threeddarkshadow",
      "threedface",
      "threedhighlight",
      "threedlightshadow",
      "threedshadow",
      "to",
      "top",
      "transform",
      "translate",
      "translate3d",
      "translateX",
      "translateY",
      "translateZ",
      "transparent",
      "ultra-condensed",
      "ultra-expanded",
      "underline",
      "unidirectional-pan",
      "unset",
      "up",
      "upper-latin",
      "uppercase",
      "url",
      "var",
      "vertical",
      "vertical-text",
      "view-box",
      "visible",
      "visibleFill",
      "visiblePainted",
      "visibleStroke",
      "visual",
      "w-resize",
      "wait",
      "wave",
      "wider",
      "window",
      "windowframe",
      "windowtext",
      "words",
      "wrap",
      "wrap-reverse",
      "x-large",
      "x-small",
      "xor",
      "xx-large",
      "xx-small"
    ].map((name2) => ({ type: "keyword", label: name2 })).concat(/* @__PURE__ */ [
      "aliceblue",
      "antiquewhite",
      "aqua",
      "aquamarine",
      "azure",
      "beige",
      "bisque",
      "black",
      "blanchedalmond",
      "blue",
      "blueviolet",
      "brown",
      "burlywood",
      "cadetblue",
      "chartreuse",
      "chocolate",
      "coral",
      "cornflowerblue",
      "cornsilk",
      "crimson",
      "cyan",
      "darkblue",
      "darkcyan",
      "darkgoldenrod",
      "darkgray",
      "darkgreen",
      "darkkhaki",
      "darkmagenta",
      "darkolivegreen",
      "darkorange",
      "darkorchid",
      "darkred",
      "darksalmon",
      "darkseagreen",
      "darkslateblue",
      "darkslategray",
      "darkturquoise",
      "darkviolet",
      "deeppink",
      "deepskyblue",
      "dimgray",
      "dodgerblue",
      "firebrick",
      "floralwhite",
      "forestgreen",
      "fuchsia",
      "gainsboro",
      "ghostwhite",
      "gold",
      "goldenrod",
      "gray",
      "grey",
      "green",
      "greenyellow",
      "honeydew",
      "hotpink",
      "indianred",
      "indigo",
      "ivory",
      "khaki",
      "lavender",
      "lavenderblush",
      "lawngreen",
      "lemonchiffon",
      "lightblue",
      "lightcoral",
      "lightcyan",
      "lightgoldenrodyellow",
      "lightgray",
      "lightgreen",
      "lightpink",
      "lightsalmon",
      "lightseagreen",
      "lightskyblue",
      "lightslategray",
      "lightsteelblue",
      "lightyellow",
      "lime",
      "limegreen",
      "linen",
      "magenta",
      "maroon",
      "mediumaquamarine",
      "mediumblue",
      "mediumorchid",
      "mediumpurple",
      "mediumseagreen",
      "mediumslateblue",
      "mediumspringgreen",
      "mediumturquoise",
      "mediumvioletred",
      "midnightblue",
      "mintcream",
      "mistyrose",
      "moccasin",
      "navajowhite",
      "navy",
      "oldlace",
      "olive",
      "olivedrab",
      "orange",
      "orangered",
      "orchid",
      "palegoldenrod",
      "palegreen",
      "paleturquoise",
      "palevioletred",
      "papayawhip",
      "peachpuff",
      "peru",
      "pink",
      "plum",
      "powderblue",
      "purple",
      "rebeccapurple",
      "red",
      "rosybrown",
      "royalblue",
      "saddlebrown",
      "salmon",
      "sandybrown",
      "seagreen",
      "seashell",
      "sienna",
      "silver",
      "skyblue",
      "slateblue",
      "slategray",
      "snow",
      "springgreen",
      "steelblue",
      "tan",
      "teal",
      "thistle",
      "tomato",
      "turquoise",
      "violet",
      "wheat",
      "white",
      "whitesmoke",
      "yellow",
      "yellowgreen"
    ].map((name2) => ({ type: "constant", label: name2 })));
    tags2 = /* @__PURE__ */ [
      "a",
      "abbr",
      "address",
      "article",
      "aside",
      "b",
      "bdi",
      "bdo",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "col",
      "colgroup",
      "dd",
      "del",
      "details",
      "dfn",
      "dialog",
      "div",
      "dl",
      "dt",
      "em",
      "figcaption",
      "figure",
      "footer",
      "form",
      "header",
      "hgroup",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "hr",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "meter",
      "nav",
      "ol",
      "output",
      "p",
      "pre",
      "ruby",
      "section",
      "select",
      "small",
      "source",
      "span",
      "strong",
      "sub",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "template",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "tr",
      "u",
      "ul"
    ].map((name2) => ({ type: "type", label: name2 }));
    atRules = /* @__PURE__ */ [
      "@charset",
      "@color-profile",
      "@container",
      "@counter-style",
      "@font-face",
      "@font-feature-values",
      "@font-palette-values",
      "@import",
      "@keyframes",
      "@layer",
      "@media",
      "@namespace",
      "@page",
      "@position-try",
      "@property",
      "@scope",
      "@starting-style",
      "@supports",
      "@view-transition"
    ].map((label) => ({ type: "keyword", label }));
    identifier2 = /^(\w[\w-]*|-\w[\w-]*|)$/;
    variable = /^-(-[\w-]*)?$/;
    VariablesByNode = /* @__PURE__ */ new NodeWeakMap();
    declSelector = ["Declaration"];
    defineCSSCompletionSource = (isVariable) => (context2) => {
      let { state, pos } = context2, node = syntaxTree(state).resolveInner(pos, -1);
      let isDash = node.type.isError && node.from == node.to - 1 && state.doc.sliceString(node.from, node.to) == "-";
      if (node.name == "PropertyName" || (isDash || node.name == "TagName") && /^(Block|Styles)$/.test(node.resolve(node.to).name))
        return { from: node.from, options: properties(), validFor: identifier2 };
      if (node.name == "ValueName")
        return { from: node.from, options: values, validFor: identifier2 };
      if (node.name == "PseudoClassName")
        return { from: node.from, options: pseudoClasses, validFor: identifier2 };
      if (isVariable(node) || (context2.explicit || isDash) && isVarArg(node, state.doc))
        return {
          from: isVariable(node) || isDash ? node.from : pos,
          options: variableNames(state.doc, astTop(node), isVariable),
          validFor: variable
        };
      if (node.name == "TagName") {
        for (let { parent } = node; parent; parent = parent.parent)
          if (parent.name == "Block")
            return { from: node.from, options: properties(), validFor: identifier2 };
        return { from: node.from, options: tags2, validFor: identifier2 };
      }
      if (node.name == "AtKeyword")
        return { from: node.from, options: atRules, validFor: identifier2 };
      if (!context2.explicit)
        return null;
      let above = node.resolve(pos), before = above.childBefore(pos);
      if (before && before.name == ":" && above.name == "PseudoClassSelector")
        return { from: pos, options: pseudoClasses, validFor: identifier2 };
      if (before && before.name == ":" && above.name == "Declaration" || above.name == "ArgList")
        return { from: pos, options: values, validFor: identifier2 };
      if (above.name == "Block" || above.name == "Styles")
        return { from: pos, options: properties(), validFor: identifier2 };
      return null;
    };
    cssCompletionSource = /* @__PURE__ */ defineCSSCompletionSource((n) => n.name == "VariableName");
    cssLanguage = /* @__PURE__ */ LRLanguage.define({
      name: "css",
      parser: /* @__PURE__ */ parser4.configure({
        props: [
          /* @__PURE__ */ indentNodeProp.add({
            Declaration: /* @__PURE__ */ continuedIndent()
          }),
          /* @__PURE__ */ foldNodeProp.add({
            "Block KeyframeList": foldInside
          })
        ]
      }),
      languageData: {
        commentTokens: { block: { open: "/*", close: "*/" } },
        indentOnInput: /^\s*\}$/,
        wordChars: "-"
      }
    });
  }
});

// node_modules/@codemirror/lang-html/dist/index.js
function elementName2(doc2, tree2, max = doc2.length) {
  if (!tree2)
    return "";
  let tag = tree2.firstChild;
  let name2 = tag && tag.getChild("TagName");
  return name2 ? doc2.sliceString(name2.from, Math.min(name2.to, max)) : "";
}
function findParentElement(tree2, skip = false) {
  for (; tree2; tree2 = tree2.parent)
    if (tree2.name == "Element") {
      if (skip)
        skip = false;
      else
        return tree2;
    }
  return null;
}
function allowedChildren(doc2, tree2, schema) {
  let parentInfo = schema.tags[elementName2(doc2, findParentElement(tree2))];
  return (parentInfo === null || parentInfo === void 0 ? void 0 : parentInfo.children) || schema.allTags;
}
function openTags(doc2, tree2) {
  let open = [];
  for (let parent = findParentElement(tree2); parent && !parent.type.isTop; parent = findParentElement(parent.parent)) {
    let tagName = elementName2(doc2, parent);
    if (tagName && parent.lastChild.name == "CloseTag")
      break;
    if (tagName && open.indexOf(tagName) < 0 && (tree2.name == "EndTag" || tree2.from >= parent.firstChild.to))
      open.push(tagName);
  }
  return open;
}
function completeTag(state, schema, tree2, from2, to) {
  let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
  let parent = findParentElement(tree2, tree2.name == "StartTag" || tree2.name == "TagName");
  return {
    from: from2,
    to,
    options: allowedChildren(state.doc, parent, schema).map((tagName) => ({ label: tagName, type: "type" })).concat(openTags(state.doc, tree2).map((tag, i) => ({
      label: "/" + tag,
      apply: "/" + tag + end,
      type: "type",
      boost: 99 - i
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function completeCloseTag(state, tree2, from2, to) {
  let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
  return {
    from: from2,
    to,
    options: openTags(state.doc, tree2).map((tag, i) => ({ label: tag, apply: tag + end, type: "type", boost: 99 - i })),
    validFor: identifier3
  };
}
function completeStartTag(state, schema, tree2, pos) {
  let options = [], level = 0;
  for (let tagName of allowedChildren(state.doc, tree2, schema))
    options.push({ label: "<" + tagName, type: "type" });
  for (let open of openTags(state.doc, tree2))
    options.push({ label: "</" + open + ">", type: "type", boost: 99 - level++ });
  return { from: pos, to: pos, options, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function completeAttrName(state, schema, tree2, from2, to) {
  let elt2 = findParentElement(tree2), info = elt2 ? schema.tags[elementName2(state.doc, elt2)] : null;
  let localAttrs = info && info.attrs ? Object.keys(info.attrs) : [];
  let names = info && info.globalAttrs === false ? localAttrs : localAttrs.length ? localAttrs.concat(schema.globalAttrNames) : schema.globalAttrNames;
  return {
    from: from2,
    to,
    options: names.map((attrName) => ({ label: attrName, type: "property" })),
    validFor: identifier3
  };
}
function completeAttrValue(state, schema, tree2, from2, to) {
  var _a2;
  let nameNode = (_a2 = tree2.parent) === null || _a2 === void 0 ? void 0 : _a2.getChild("AttributeName");
  let options = [], token = void 0;
  if (nameNode) {
    let attrName = state.sliceDoc(nameNode.from, nameNode.to);
    let attrs = schema.globalAttrs[attrName];
    if (!attrs) {
      let elt2 = findParentElement(tree2), info = elt2 ? schema.tags[elementName2(state.doc, elt2)] : null;
      attrs = (info === null || info === void 0 ? void 0 : info.attrs) && info.attrs[attrName];
    }
    if (attrs) {
      let base2 = state.sliceDoc(from2, to).toLowerCase(), quoteStart = '"', quoteEnd = '"';
      if (/^['"]/.test(base2)) {
        token = base2[0] == '"' ? /^[^"]*$/ : /^[^']*$/;
        quoteStart = "";
        quoteEnd = state.sliceDoc(to, to + 1) == base2[0] ? "" : base2[0];
        base2 = base2.slice(1);
        from2++;
      } else {
        token = /^[^\s<>='"]*$/;
      }
      for (let value of attrs)
        options.push({ label: value, apply: quoteStart + value + quoteEnd, type: "constant" });
    }
  }
  return { from: from2, to, options, validFor: token };
}
function htmlCompletionFor(schema, context2) {
  let { state, pos } = context2, tree2 = syntaxTree(state).resolveInner(pos, -1), around = tree2.resolve(pos);
  for (let scan2 = pos, before; around == tree2 && (before = tree2.childBefore(scan2)); ) {
    let last4 = before.lastChild;
    if (!last4 || !last4.type.isError || last4.from < last4.to)
      break;
    around = tree2 = before;
    scan2 = last4.from;
  }
  if (tree2.name == "TagName") {
    return tree2.parent && /CloseTag$/.test(tree2.parent.name) ? completeCloseTag(state, tree2, tree2.from, pos) : completeTag(state, schema, tree2, tree2.from, pos);
  } else if (tree2.name == "StartTag" || tree2.name == "IncompleteTag") {
    return completeTag(state, schema, tree2, pos, pos);
  } else if (tree2.name == "StartCloseTag" || tree2.name == "IncompleteCloseTag") {
    return completeCloseTag(state, tree2, pos, pos);
  } else if (tree2.name == "OpenTag" || tree2.name == "SelfClosingTag" || tree2.name == "AttributeName") {
    return completeAttrName(state, schema, tree2, tree2.name == "AttributeName" ? tree2.from : pos, pos);
  } else if (tree2.name == "Is" || tree2.name == "AttributeValue" || tree2.name == "UnquotedAttributeValue") {
    return completeAttrValue(state, schema, tree2, tree2.name == "Is" ? pos : tree2.from, pos);
  } else if (context2.explicit && (around.name == "Element" || around.name == "Text" || around.name == "Document")) {
    return completeStartTag(state, schema, tree2, pos);
  } else {
    return null;
  }
}
function htmlCompletionSource(context2) {
  return htmlCompletionFor(Schema.default, context2);
}
function htmlCompletionSourceWith(config3) {
  let { extraTags, extraGlobalAttributes: extraAttrs } = config3;
  let schema = extraAttrs || extraTags ? new Schema(extraTags, extraAttrs) : Schema.default;
  return (context2) => htmlCompletionFor(schema, context2);
}
function html(config3 = {}) {
  let dialect = "", wrap;
  if (config3.matchClosingTags === false)
    dialect = "noMatch";
  if (config3.selfClosingTags === true)
    dialect = (dialect ? dialect + " " : "") + "selfClosing";
  if (config3.nestedLanguages && config3.nestedLanguages.length || config3.nestedAttributes && config3.nestedAttributes.length)
    wrap = configureNesting((config3.nestedLanguages || []).concat(defaultNesting), (config3.nestedAttributes || []).concat(defaultAttrs));
  let lang = wrap ? htmlPlain.configure({ wrap, dialect }) : dialect ? htmlLanguage.configure({ dialect }) : htmlLanguage;
  return new LanguageSupport(lang, [
    htmlLanguage.data.of({ autocomplete: htmlCompletionSourceWith(config3) }),
    config3.autoCloseTags !== false ? autoCloseTags2 : [],
    javascript().support,
    css().support
  ]);
}
var Targets, Charsets, Methods, Encs, Bool, S, Tags, GlobalAttrs, eventAttributes, Schema, identifier3, jsonParser, defaultNesting, defaultAttrs, htmlPlain, htmlLanguage, selfClosers2, autoCloseTags2;
var init_dist15 = __esm({
  "node_modules/@codemirror/lang-html/dist/index.js"() {
    "use strict";
    init_dist12();
    init_dist14();
    init_dist9();
    init_dist2();
    init_dist();
    init_dist7();
    Targets = ["_blank", "_self", "_top", "_parent"];
    Charsets = ["ascii", "utf-8", "utf-16", "latin1", "latin1"];
    Methods = ["get", "post", "put", "delete"];
    Encs = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"];
    Bool = ["true", "false"];
    S = {};
    Tags = {
      a: {
        attrs: {
          href: null,
          ping: null,
          type: null,
          media: null,
          target: Targets,
          hreflang: null
        }
      },
      abbr: S,
      address: S,
      area: {
        attrs: {
          alt: null,
          coords: null,
          href: null,
          target: null,
          ping: null,
          media: null,
          hreflang: null,
          type: null,
          shape: ["default", "rect", "circle", "poly"]
        }
      },
      article: S,
      aside: S,
      audio: {
        attrs: {
          src: null,
          mediagroup: null,
          crossorigin: ["anonymous", "use-credentials"],
          preload: ["none", "metadata", "auto"],
          autoplay: ["autoplay"],
          loop: ["loop"],
          controls: ["controls"]
        }
      },
      b: S,
      base: { attrs: { href: null, target: Targets } },
      bdi: S,
      bdo: S,
      blockquote: { attrs: { cite: null } },
      body: S,
      br: S,
      button: {
        attrs: {
          form: null,
          formaction: null,
          name: null,
          value: null,
          autofocus: ["autofocus"],
          disabled: ["autofocus"],
          formenctype: Encs,
          formmethod: Methods,
          formnovalidate: ["novalidate"],
          formtarget: Targets,
          type: ["submit", "reset", "button"]
        }
      },
      canvas: { attrs: { width: null, height: null } },
      caption: S,
      center: S,
      cite: S,
      code: S,
      col: { attrs: { span: null } },
      colgroup: { attrs: { span: null } },
      command: {
        attrs: {
          type: ["command", "checkbox", "radio"],
          label: null,
          icon: null,
          radiogroup: null,
          command: null,
          title: null,
          disabled: ["disabled"],
          checked: ["checked"]
        }
      },
      data: { attrs: { value: null } },
      datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
      datalist: { attrs: { data: null } },
      dd: S,
      del: { attrs: { cite: null, datetime: null } },
      details: { attrs: { open: ["open"] } },
      dfn: S,
      div: S,
      dl: S,
      dt: S,
      em: S,
      embed: { attrs: { src: null, type: null, width: null, height: null } },
      eventsource: { attrs: { src: null } },
      fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
      figcaption: S,
      figure: S,
      footer: S,
      form: {
        attrs: {
          action: null,
          name: null,
          "accept-charset": Charsets,
          autocomplete: ["on", "off"],
          enctype: Encs,
          method: Methods,
          novalidate: ["novalidate"],
          target: Targets
        }
      },
      h1: S,
      h2: S,
      h3: S,
      h4: S,
      h5: S,
      h6: S,
      head: {
        children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
      },
      header: S,
      hgroup: S,
      hr: S,
      html: {
        attrs: { manifest: null }
      },
      i: S,
      iframe: {
        attrs: {
          src: null,
          srcdoc: null,
          name: null,
          width: null,
          height: null,
          sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
          seamless: ["seamless"]
        }
      },
      img: {
        attrs: {
          alt: null,
          src: null,
          ismap: null,
          usemap: null,
          width: null,
          height: null,
          crossorigin: ["anonymous", "use-credentials"]
        }
      },
      input: {
        attrs: {
          alt: null,
          dirname: null,
          form: null,
          formaction: null,
          height: null,
          list: null,
          max: null,
          maxlength: null,
          min: null,
          name: null,
          pattern: null,
          placeholder: null,
          size: null,
          src: null,
          step: null,
          value: null,
          width: null,
          accept: ["audio/*", "video/*", "image/*"],
          autocomplete: ["on", "off"],
          autofocus: ["autofocus"],
          checked: ["checked"],
          disabled: ["disabled"],
          formenctype: Encs,
          formmethod: Methods,
          formnovalidate: ["novalidate"],
          formtarget: Targets,
          multiple: ["multiple"],
          readonly: ["readonly"],
          required: ["required"],
          type: [
            "hidden",
            "text",
            "search",
            "tel",
            "url",
            "email",
            "password",
            "datetime",
            "date",
            "month",
            "week",
            "time",
            "datetime-local",
            "number",
            "range",
            "color",
            "checkbox",
            "radio",
            "file",
            "submit",
            "image",
            "reset",
            "button"
          ]
        }
      },
      ins: { attrs: { cite: null, datetime: null } },
      kbd: S,
      keygen: {
        attrs: {
          challenge: null,
          form: null,
          name: null,
          autofocus: ["autofocus"],
          disabled: ["disabled"],
          keytype: ["RSA"]
        }
      },
      label: { attrs: { for: null, form: null } },
      legend: S,
      li: { attrs: { value: null } },
      link: {
        attrs: {
          href: null,
          type: null,
          hreflang: null,
          media: null,
          sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
        }
      },
      map: { attrs: { name: null } },
      mark: S,
      menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
      meta: {
        attrs: {
          content: null,
          charset: Charsets,
          name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
          "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
        }
      },
      meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
      nav: S,
      noscript: S,
      object: {
        attrs: {
          data: null,
          type: null,
          name: null,
          usemap: null,
          form: null,
          width: null,
          height: null,
          typemustmatch: ["typemustmatch"]
        }
      },
      ol: {
        attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
        children: ["li", "script", "template", "ul", "ol"]
      },
      optgroup: { attrs: { disabled: ["disabled"], label: null } },
      option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
      output: { attrs: { for: null, form: null, name: null } },
      p: S,
      param: { attrs: { name: null, value: null } },
      pre: S,
      progress: { attrs: { value: null, max: null } },
      q: { attrs: { cite: null } },
      rp: S,
      rt: S,
      ruby: S,
      samp: S,
      script: {
        attrs: {
          type: ["text/javascript"],
          src: null,
          async: ["async"],
          defer: ["defer"],
          charset: Charsets
        }
      },
      section: S,
      select: {
        attrs: {
          form: null,
          name: null,
          size: null,
          autofocus: ["autofocus"],
          disabled: ["disabled"],
          multiple: ["multiple"]
        }
      },
      slot: { attrs: { name: null } },
      small: S,
      source: { attrs: { src: null, type: null, media: null } },
      span: S,
      strong: S,
      style: {
        attrs: {
          type: ["text/css"],
          media: null,
          scoped: null
        }
      },
      sub: S,
      summary: S,
      sup: S,
      table: S,
      tbody: S,
      td: { attrs: { colspan: null, rowspan: null, headers: null } },
      template: S,
      textarea: {
        attrs: {
          dirname: null,
          form: null,
          maxlength: null,
          name: null,
          placeholder: null,
          rows: null,
          cols: null,
          autofocus: ["autofocus"],
          disabled: ["disabled"],
          readonly: ["readonly"],
          required: ["required"],
          wrap: ["soft", "hard"]
        }
      },
      tfoot: S,
      th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
      thead: S,
      time: { attrs: { datetime: null } },
      title: S,
      tr: S,
      track: {
        attrs: {
          src: null,
          label: null,
          default: null,
          kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
          srclang: null
        }
      },
      ul: { children: ["li", "script", "template", "ul", "ol"] },
      var: S,
      video: {
        attrs: {
          src: null,
          poster: null,
          width: null,
          height: null,
          crossorigin: ["anonymous", "use-credentials"],
          preload: ["auto", "metadata", "none"],
          autoplay: ["autoplay"],
          mediagroup: ["movie"],
          muted: ["muted"],
          controls: ["controls"]
        }
      },
      wbr: S
    };
    GlobalAttrs = {
      accesskey: null,
      class: null,
      contenteditable: Bool,
      contextmenu: null,
      dir: ["ltr", "rtl", "auto"],
      draggable: ["true", "false", "auto"],
      dropzone: ["copy", "move", "link", "string:", "file:"],
      hidden: ["hidden"],
      id: null,
      inert: ["inert"],
      itemid: null,
      itemprop: null,
      itemref: null,
      itemscope: ["itemscope"],
      itemtype: null,
      lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
      spellcheck: Bool,
      autocorrect: Bool,
      autocapitalize: Bool,
      style: null,
      tabindex: null,
      title: null,
      translate: ["yes", "no"],
      rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
      role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
      "aria-activedescendant": null,
      "aria-atomic": Bool,
      "aria-autocomplete": ["inline", "list", "both", "none"],
      "aria-busy": Bool,
      "aria-checked": ["true", "false", "mixed", "undefined"],
      "aria-controls": null,
      "aria-describedby": null,
      "aria-disabled": Bool,
      "aria-dropeffect": null,
      "aria-expanded": ["true", "false", "undefined"],
      "aria-flowto": null,
      "aria-grabbed": ["true", "false", "undefined"],
      "aria-haspopup": Bool,
      "aria-hidden": Bool,
      "aria-invalid": ["true", "false", "grammar", "spelling"],
      "aria-label": null,
      "aria-labelledby": null,
      "aria-level": null,
      "aria-live": ["off", "polite", "assertive"],
      "aria-multiline": Bool,
      "aria-multiselectable": Bool,
      "aria-owns": null,
      "aria-posinset": null,
      "aria-pressed": ["true", "false", "mixed", "undefined"],
      "aria-readonly": Bool,
      "aria-relevant": null,
      "aria-required": Bool,
      "aria-selected": ["true", "false", "undefined"],
      "aria-setsize": null,
      "aria-sort": ["ascending", "descending", "none", "other"],
      "aria-valuemax": null,
      "aria-valuemin": null,
      "aria-valuenow": null,
      "aria-valuetext": null
    };
    eventAttributes = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((n) => "on" + n);
    for (let a of eventAttributes)
      GlobalAttrs[a] = null;
    Schema = class {
      constructor(extraTags, extraAttrs) {
        this.tags = __spreadValues(__spreadValues({}, Tags), extraTags);
        this.globalAttrs = __spreadValues(__spreadValues({}, GlobalAttrs), extraAttrs);
        this.allTags = Object.keys(this.tags);
        this.globalAttrNames = Object.keys(this.globalAttrs);
      }
    };
    Schema.default = /* @__PURE__ */ new Schema();
    identifier3 = /^[:\-\.\w\u00b7-\uffff]*$/;
    jsonParser = /* @__PURE__ */ javascriptLanguage.parser.configure({ top: "SingleExpression" });
    defaultNesting = [
      {
        tag: "script",
        attrs: (attrs) => attrs.type == "text/typescript" || attrs.lang == "ts",
        parser: typescriptLanguage.parser
      },
      {
        tag: "script",
        attrs: (attrs) => attrs.type == "text/babel" || attrs.type == "text/jsx",
        parser: jsxLanguage.parser
      },
      {
        tag: "script",
        attrs: (attrs) => attrs.type == "text/typescript-jsx",
        parser: tsxLanguage.parser
      },
      {
        tag: "script",
        attrs(attrs) {
          return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(attrs.type);
        },
        parser: jsonParser
      },
      {
        tag: "script",
        attrs(attrs) {
          return !attrs.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(attrs.type);
        },
        parser: javascriptLanguage.parser
      },
      {
        tag: "style",
        attrs(attrs) {
          return (!attrs.lang || attrs.lang == "css") && (!attrs.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(attrs.type));
        },
        parser: cssLanguage.parser
      }
    ];
    defaultAttrs = /* @__PURE__ */ [
      {
        name: "style",
        parser: /* @__PURE__ */ cssLanguage.parser.configure({ top: "Styles" })
      }
    ].concat(/* @__PURE__ */ eventAttributes.map((name2) => ({ name: name2, parser: javascriptLanguage.parser })));
    htmlPlain = /* @__PURE__ */ LRLanguage.define({
      name: "html",
      parser: /* @__PURE__ */ parser3.configure({
        props: [
          /* @__PURE__ */ indentNodeProp.add({
            Element(context2) {
              let after = /^(\s*)(<\/)?/.exec(context2.textAfter);
              if (context2.node.to <= context2.pos + after[0].length)
                return context2.continue();
              return context2.lineIndent(context2.node.from) + (after[2] ? 0 : context2.unit);
            },
            "OpenTag CloseTag SelfClosingTag"(context2) {
              return context2.column(context2.node.from) + context2.unit;
            },
            Document(context2) {
              if (context2.pos + /\s*/.exec(context2.textAfter)[0].length < context2.node.to)
                return context2.continue();
              let endElt = null, close;
              for (let cur2 = context2.node; ; ) {
                let last4 = cur2.lastChild;
                if (!last4 || last4.name != "Element" || last4.to != cur2.to)
                  break;
                endElt = cur2 = last4;
              }
              if (endElt && !((close = endElt.lastChild) && (close.name == "CloseTag" || close.name == "SelfClosingTag")))
                return context2.lineIndent(endElt.from) + context2.unit;
              return null;
            }
          }),
          /* @__PURE__ */ foldNodeProp.add({
            Element(node) {
              let first2 = node.firstChild, last4 = node.lastChild;
              if (!first2 || first2.name != "OpenTag")
                return null;
              return { from: first2.to, to: last4.name == "CloseTag" ? last4.from : node.to };
            }
          }),
          /* @__PURE__ */ bracketMatchingHandle.add({
            "OpenTag CloseTag": (node) => node.getChild("TagName")
          })
        ]
      }),
      languageData: {
        commentTokens: { block: { open: "<!--", close: "-->" } },
        indentOnInput: /^\s*<\/\w+\W$/,
        wordChars: "-_"
      }
    });
    htmlLanguage = /* @__PURE__ */ htmlPlain.configure({
      wrap: /* @__PURE__ */ configureNesting(defaultNesting, defaultAttrs)
    });
    selfClosers2 = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" "));
    autoCloseTags2 = /* @__PURE__ */ EditorView.inputHandler.of((view, from2, to, text, insertTransaction) => {
      if (view.composing || view.state.readOnly || from2 != to || text != ">" && text != "/" || !htmlLanguage.isActiveAt(view.state, from2, -1))
        return false;
      let base2 = insertTransaction(), { state } = base2;
      let closeTags = state.changeByRange((range) => {
        var _a2, _b, _c;
        let didType = state.doc.sliceString(range.from - 1, range.to) == text;
        let { head } = range, after = syntaxTree(state).resolveInner(head, -1), name2;
        if (didType && text == ">" && after.name == "EndTag") {
          let tag = after.parent;
          if (((_b = (_a2 = tag.parent) === null || _a2 === void 0 ? void 0 : _a2.lastChild) === null || _b === void 0 ? void 0 : _b.name) != "CloseTag" && (name2 = elementName2(state.doc, tag.parent, head)) && !selfClosers2.has(name2)) {
            let to2 = head + (state.doc.sliceString(head, head + 1) === ">" ? 1 : 0);
            let insert2 = `</${name2}>`;
            return { range, changes: { from: head, to: to2, insert: insert2 } };
          }
        } else if (didType && text == "/" && after.name == "IncompleteCloseTag") {
          let tag = after.parent;
          if (after.from == head - 2 && ((_c = tag.lastChild) === null || _c === void 0 ? void 0 : _c.name) != "CloseTag" && (name2 = elementName2(state.doc, tag, head)) && !selfClosers2.has(name2)) {
            let to2 = head + (state.doc.sliceString(head, head + 1) === ">" ? 1 : 0);
            let insert2 = `${name2}>`;
            return {
              range: EditorSelection.cursor(head + insert2.length, -1),
              changes: { from: head, to: to2, insert: insert2 }
            };
          }
        }
        return { range };
      });
      if (closeTags.changes.empty)
        return false;
      view.dispatch([
        base2,
        state.update(closeTags, {
          userEvent: "input.complete",
          scrollIntoView: true
        })
      ]);
      return true;
    });
  }
});

// node_modules/@lezer/json/dist/index.js
var jsonHighlighting, parser5;
var init_dist16 = __esm({
  "node_modules/@lezer/json/dist/index.js"() {
    "use strict";
    init_dist4();
    init_dist5();
    jsonHighlighting = styleTags({
      String: tags.string,
      Number: tags.number,
      "True False": tags.bool,
      PropertyName: tags.propertyName,
      Null: tags.null,
      ", :": tags.separator,
      "[ ]": tags.squareBracket,
      "{ }": tags.brace
    });
    parser5 = LRParser.deserialize({
      version: 14,
      states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#ClOOQO'#Cr'#CrQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CtOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59W,59WO!iQPO,59WOVQPO,59QOqQPO'#CmO!nQPO,59`OOQO1G.k1G.kOVQPO'#CnO!vQPO,59aOOQO1G.r1G.rOOQO1G.l1G.lOOQO,59X,59XOOQO-E6k-E6kOOQO,59Y,59YOOQO-E6l-E6l",
      stateData: "#O~OeOS~OQSORSOSSOTSOWQO_ROgPO~OVXOgUO~O^[O~PVO[^O~O]_OVhX~OVaO~O]bO^iX~O^dO~O]_OVha~O]bO^ia~O",
      goto: "!kjPPPPPPkPPkqwPPPPk{!RPPP!XP!e!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
      nodeNames: "\u26A0 JsonText True False Null Number String } { Object Property PropertyName : , ] [ Array",
      maxTerm: 25,
      nodeProps: [
        ["isolate", -2, 6, 11, ""],
        ["openedBy", 7, "{", 14, "["],
        ["closedBy", 8, "}", 15, "]"]
      ],
      propSources: [jsonHighlighting],
      skippedNodes: [0],
      repeatNodeCount: 2,
      tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oe~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Og~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zO]~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yO[~~'OO_~~'TO^~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
      tokenizers: [0],
      topRules: { "JsonText": [0, 1] },
      tokenPrec: 0
    });
  }
});

// node_modules/@codemirror/lang-json/dist/index.js
function json() {
  return new LanguageSupport(jsonLanguage);
}
var jsonLanguage;
var init_dist17 = __esm({
  "node_modules/@codemirror/lang-json/dist/index.js"() {
    "use strict";
    init_dist16();
    init_dist7();
    jsonLanguage = /* @__PURE__ */ LRLanguage.define({
      name: "json",
      parser: /* @__PURE__ */ parser5.configure({
        props: [
          /* @__PURE__ */ indentNodeProp.add({
            Object: /* @__PURE__ */ continuedIndent({ except: /^\s*\}/ }),
            Array: /* @__PURE__ */ continuedIndent({ except: /^\s*\]/ })
          }),
          /* @__PURE__ */ foldNodeProp.add({
            "Object Array": foldInside
          })
        ]
      }),
      languageData: {
        closeBrackets: { brackets: ["[", "{", '"'] },
        indentOnInput: /^\s*[\}\]]$/
      }
    });
  }
});

// node_modules/@lezer/markdown/dist/index.js
function skipForList(bl, cx, line) {
  if (line.pos == line.text.length || bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent)
    return true;
  if (line.indent >= line.baseIndent + 4)
    return false;
  let size = (bl.type == Type2.OrderedList ? isOrderedList : isBulletList)(line, cx, false);
  return size > 0 && (bl.type != Type2.BulletList || isHorizontalRule(line, cx, false) < 0) && line.text.charCodeAt(line.pos + size - 1) == bl.value;
}
function space4(ch) {
  return ch == 32 || ch == 9 || ch == 10 || ch == 13;
}
function skipSpace(line, i = 0) {
  while (i < line.length && space4(line.charCodeAt(i)))
    i++;
  return i;
}
function skipSpaceBack(line, i, to) {
  while (i > to && space4(line.charCodeAt(i - 1)))
    i--;
  return i;
}
function isFencedCode(line) {
  if (line.next != 96 && line.next != 126)
    return -1;
  let pos = line.pos + 1;
  while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)
    pos++;
  if (pos < line.pos + 3)
    return -1;
  if (line.next == 96) {
    for (let i = pos; i < line.text.length; i++)
      if (line.text.charCodeAt(i) == 96)
        return -1;
  }
  return pos;
}
function isBlockquote(line) {
  return line.next != 62 ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;
}
function isHorizontalRule(line, cx, breaking) {
  if (line.next != 42 && line.next != 45 && line.next != 95)
    return -1;
  let count2 = 1;
  for (let pos = line.pos + 1; pos < line.text.length; pos++) {
    let ch = line.text.charCodeAt(pos);
    if (ch == line.next)
      count2++;
    else if (!space4(ch))
      return -1;
  }
  if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length && cx.parser.leafBlockParsers.indexOf(DefaultLeafBlocks.SetextHeading) > -1)
    return -1;
  return count2 < 3 ? -1 : 1;
}
function inList(cx, type) {
  for (let i = cx.stack.length - 1; i >= 0; i--)
    if (cx.stack[i].type == type)
      return true;
  return false;
}
function isBulletList(line, cx, breaking) {
  return (line.next == 45 || line.next == 43 || line.next == 42) && (line.pos == line.text.length - 1 || space4(line.text.charCodeAt(line.pos + 1))) && (!breaking || inList(cx, Type2.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;
}
function isOrderedList(line, cx, breaking) {
  let pos = line.pos, next = line.next;
  for (; ; ) {
    if (next >= 48 && next <= 57)
      pos++;
    else
      break;
    if (pos == line.text.length)
      return -1;
    next = line.text.charCodeAt(pos);
  }
  if (pos == line.pos || pos > line.pos + 9 || next != 46 && next != 41 || pos < line.text.length - 1 && !space4(line.text.charCodeAt(pos + 1)) || breaking && !inList(cx, Type2.OrderedList) && (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49))
    return -1;
  return pos + 1 - line.pos;
}
function isAtxHeading(line) {
  if (line.next != 35)
    return -1;
  let pos = line.pos + 1;
  while (pos < line.text.length && line.text.charCodeAt(pos) == 35)
    pos++;
  if (pos < line.text.length && line.text.charCodeAt(pos) != 32)
    return -1;
  let size = pos - line.pos;
  return size > 6 ? -1 : size;
}
function isSetextUnderline(line) {
  if (line.next != 45 && line.next != 61 || line.indent >= line.baseIndent + 4)
    return -1;
  let pos = line.pos + 1;
  while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)
    pos++;
  let end = pos;
  while (pos < line.text.length && space4(line.text.charCodeAt(pos)))
    pos++;
  return pos == line.text.length ? end : -1;
}
function isHTMLBlock(line, _cx, breaking) {
  if (line.next != 60)
    return -1;
  let rest = line.text.slice(line.pos);
  for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)
    if (HTMLBlockStyle[i][0].test(rest))
      return i;
  return -1;
}
function getListIndent(line, pos) {
  let indentAfter = line.countIndent(pos, line.pos, line.indent);
  let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);
  return indented >= indentAfter + 5 ? indentAfter + 1 : indented;
}
function addCodeText(marks2, from2, to) {
  let last4 = marks2.length - 1;
  if (last4 >= 0 && marks2[last4].to == from2 && marks2[last4].type == Type2.CodeText)
    marks2[last4].to = to;
  else
    marks2.push(elt(Type2.CodeText, from2, to));
}
function lineEnd(text, pos) {
  for (; pos < text.length; pos++) {
    let next = text.charCodeAt(pos);
    if (next == 10)
      break;
    if (!space4(next))
      return -1;
  }
  return pos;
}
function injectGaps(ranges, rangeI, tree2, offset, dummies) {
  let rangeEnd2 = ranges[rangeI].to;
  let children = [], positions = [], start = tree2.from + offset;
  function movePastNext(upto, inclusive) {
    while (inclusive ? upto >= rangeEnd2 : upto > rangeEnd2) {
      let size = ranges[rangeI + 1].from - rangeEnd2;
      offset += size;
      upto += size;
      rangeI++;
      rangeEnd2 = ranges[rangeI].to;
    }
  }
  for (let ch = tree2.firstChild; ch; ch = ch.nextSibling) {
    movePastNext(ch.from + offset, true);
    let from2 = ch.from + offset, node, reuse = dummies.get(ch.tree);
    if (reuse) {
      node = reuse;
    } else if (ch.to + offset > rangeEnd2) {
      node = injectGaps(ranges, rangeI, ch, offset, dummies);
      movePastNext(ch.to + offset, false);
    } else {
      node = ch.toTree();
    }
    children.push(node);
    positions.push(from2 - start);
  }
  movePastNext(tree2.to + offset, false);
  return new Tree2(tree2.type, children, positions, tree2.to + offset - start, tree2.tree ? tree2.tree.propValues : void 0);
}
function nonEmpty(a) {
  return a != null && a.length > 0;
}
function resolveConfig(spec) {
  if (!Array.isArray(spec))
    return spec;
  if (spec.length == 0)
    return null;
  let conf = resolveConfig(spec[0]);
  if (spec.length == 1)
    return conf;
  let rest = resolveConfig(spec.slice(1));
  if (!rest || !conf)
    return conf || rest;
  let conc2 = (a, b) => (a || none3).concat(b || none3);
  let wrapA = conf.wrap, wrapB = rest.wrap;
  return {
    props: conc2(conf.props, rest.props),
    defineNodes: conc2(conf.defineNodes, rest.defineNodes),
    parseBlock: conc2(conf.parseBlock, rest.parseBlock),
    parseInline: conc2(conf.parseInline, rest.parseInline),
    remove: conc2(conf.remove, rest.remove),
    wrap: !wrapA ? wrapB : !wrapB ? wrapA : (inner, input2, fragments, ranges) => wrapA(wrapB(inner, input2, fragments, ranges), input2, fragments, ranges)
  };
}
function findName(names, name2) {
  let found = names.indexOf(name2);
  if (found < 0)
    throw new RangeError(`Position specified relative to unknown parser ${name2}`);
  return found;
}
function elt(type, from2, to, children) {
  return new Element3(type, from2, to, children);
}
function finishLink(cx, content2, type, start, startPos) {
  let { text } = cx, next = cx.char(startPos), endPos = startPos;
  content2.unshift(elt(Type2.LinkMark, start, start + (type == Type2.Image ? 2 : 1)));
  content2.push(elt(Type2.LinkMark, startPos - 1, startPos));
  if (next == 40) {
    let pos = cx.skipSpace(startPos + 1);
    let dest = parseURL(text, pos - cx.offset, cx.offset), title;
    if (dest) {
      pos = cx.skipSpace(dest.to);
      if (pos != dest.to) {
        title = parseLinkTitle(text, pos - cx.offset, cx.offset);
        if (title)
          pos = cx.skipSpace(title.to);
      }
    }
    if (cx.char(pos) == 41) {
      content2.push(elt(Type2.LinkMark, startPos, startPos + 1));
      endPos = pos + 1;
      if (dest)
        content2.push(dest);
      if (title)
        content2.push(title);
      content2.push(elt(Type2.LinkMark, pos, endPos));
    }
  } else if (next == 91) {
    let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);
    if (label) {
      content2.push(label);
      endPos = label.to;
    }
  }
  return elt(type, start, endPos, content2);
}
function parseURL(text, start, offset) {
  let next = text.charCodeAt(start);
  if (next == 60) {
    for (let pos = start + 1; pos < text.length; pos++) {
      let ch = text.charCodeAt(pos);
      if (ch == 62)
        return elt(Type2.URL, start + offset, pos + 1 + offset);
      if (ch == 60 || ch == 10)
        return false;
    }
    return null;
  } else {
    let depth = 0, pos = start;
    for (let escaped = false; pos < text.length; pos++) {
      let ch = text.charCodeAt(pos);
      if (space4(ch)) {
        break;
      } else if (escaped) {
        escaped = false;
      } else if (ch == 40) {
        depth++;
      } else if (ch == 41) {
        if (!depth)
          break;
        depth--;
      } else if (ch == 92) {
        escaped = true;
      }
    }
    return pos > start ? elt(Type2.URL, start + offset, pos + offset) : pos == text.length ? null : false;
  }
}
function parseLinkTitle(text, start, offset) {
  let next = text.charCodeAt(start);
  if (next != 39 && next != 34 && next != 40)
    return false;
  let end = next == 40 ? 41 : next;
  for (let pos = start + 1, escaped = false; pos < text.length; pos++) {
    let ch = text.charCodeAt(pos);
    if (escaped)
      escaped = false;
    else if (ch == end)
      return elt(Type2.LinkTitle, start + offset, pos + 1 + offset);
    else if (ch == 92)
      escaped = true;
  }
  return null;
}
function parseLinkLabel(text, start, offset, requireNonWS) {
  for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {
    let ch = text.charCodeAt(pos);
    if (escaped)
      escaped = false;
    else if (ch == 93)
      return requireNonWS ? false : elt(Type2.LinkLabel, start + offset, pos + 1 + offset);
    else {
      if (requireNonWS && !space4(ch))
        requireNonWS = false;
      if (ch == 91)
        return false;
      else if (ch == 92)
        escaped = true;
    }
  }
  return null;
}
function injectMarks(elements, marks2) {
  if (!marks2.length)
    return elements;
  if (!elements.length)
    return marks2;
  let elts = elements.slice(), eI = 0;
  for (let mark of marks2) {
    while (eI < elts.length && elts[eI].to < mark.to)
      eI++;
    if (eI < elts.length && elts[eI].from < mark.from) {
      let e = elts[eI];
      if (e instanceof Element3)
        elts[eI] = new Element3(e.type, e.from, e.to, injectMarks(e.children, [mark]));
    } else {
      elts.splice(eI++, 0, mark);
    }
  }
  return elts;
}
function toRelative(abs, ranges) {
  let pos = abs;
  for (let i = 1; i < ranges.length; i++) {
    let gapFrom = ranges[i - 1].to, gapTo = ranges[i].from;
    if (gapFrom < abs)
      pos -= gapTo - gapFrom;
  }
  return pos;
}
function leftOverSpace(node, from2, to) {
  let ranges = [];
  for (let n = node.firstChild, pos = from2; ; n = n.nextSibling) {
    let nextPos = n ? n.from : to;
    if (nextPos > pos)
      ranges.push({ from: pos, to: nextPos });
    if (!n)
      break;
    pos = n.to;
  }
  return ranges;
}
function parseCode(config3) {
  let { codeParser, htmlParser } = config3;
  let wrap = parseMixed((node, input2) => {
    let id2 = node.type.id;
    if (codeParser && (id2 == Type2.CodeBlock || id2 == Type2.FencedCode)) {
      let info = "";
      if (id2 == Type2.FencedCode) {
        let infoNode = node.node.getChild(Type2.CodeInfo);
        if (infoNode)
          info = input2.read(infoNode.from, infoNode.to);
      }
      let parser7 = codeParser(info);
      if (parser7)
        return { parser: parser7, overlay: (node2) => node2.type.id == Type2.CodeText };
    } else if (htmlParser && (id2 == Type2.HTMLBlock || id2 == Type2.HTMLTag || id2 == Type2.CommentBlock)) {
      return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };
    }
    return null;
  });
  return { wrap };
}
function parseRow(cx, line, startI = 0, elts, offset = 0) {
  let count2 = 0, first2 = true, cellStart = -1, cellEnd = -1, esc = false;
  let parseCell = () => {
    elts.push(cx.elt("TableCell", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));
  };
  for (let i = startI; i < line.length; i++) {
    let next = line.charCodeAt(i);
    if (next == 124 && !esc) {
      if (!first2 || cellStart > -1)
        count2++;
      first2 = false;
      if (elts) {
        if (cellStart > -1)
          parseCell();
        elts.push(cx.elt("TableDelimiter", i + offset, i + offset + 1));
      }
      cellStart = cellEnd = -1;
    } else if (esc || next != 32 && next != 9) {
      if (cellStart < 0)
        cellStart = i;
      cellEnd = i + 1;
    }
    esc = !esc && next == 92;
  }
  if (cellStart > -1) {
    count2++;
    if (elts)
      parseCell();
  }
  return count2;
}
function hasPipe(str, start) {
  for (let i = start; i < str.length; i++) {
    let next = str.charCodeAt(i);
    if (next == 124)
      return true;
    if (next == 92)
      i++;
  }
  return false;
}
function count(str, from2, to, ch) {
  let result = 0;
  for (let i = from2; i < to; i++)
    if (str[i] == ch)
      result++;
  return result;
}
function autolinkURLEnd(text, from2) {
  urlRE.lastIndex = from2;
  let m = urlRE.exec(text);
  if (!m || lastTwoDomainWords.exec(m[0])[0].indexOf("_") > -1)
    return -1;
  let end = from2 + m[0].length;
  for (; ; ) {
    let last4 = text[end - 1], m2;
    if (/[?!.,:*_~]/.test(last4) || last4 == ")" && count(text, from2, end, ")") > count(text, from2, end, "("))
      end--;
    else if (last4 == ";" && (m2 = /&(?:#\d+|#x[a-f\d]+|\w+);$/.exec(text.slice(from2, end))))
      end = from2 + m2.index;
    else
      break;
  }
  return end;
}
function autolinkEmailEnd(text, from2) {
  emailRE.lastIndex = from2;
  let m = emailRE.exec(text);
  if (!m)
    return -1;
  let last4 = m[0][m[0].length - 1];
  return last4 == "_" || last4 == "-" ? -1 : from2 + m[0].length - (last4 == "." ? 1 : 0);
}
function parseSubSuper(ch, node, mark) {
  return (cx, next, pos) => {
    if (next != ch || cx.char(pos + 1) == ch)
      return -1;
    let elts = [cx.elt(mark, pos, pos + 1)];
    for (let i = pos + 1; i < cx.end; i++) {
      let next2 = cx.char(i);
      if (next2 == ch)
        return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));
      if (next2 == 92)
        elts.push(cx.elt("Escape", i, i++ + 2));
      if (space4(next2))
        break;
    }
    return -1;
  };
}
var CompositeBlock, Type2, LeafBlock, Line2, DefaultSkipMarkup, EmptyLine, CommentEnd, ProcessingEnd, HTMLBlockStyle, DefaultBlockParsers, LinkReferenceParser, SetextHeadingParser, DefaultLeafBlocks, DefaultEndLeaf, scanLineResult, BlockContext, MarkdownParser, nodeTypes, none3, Buffer2, Element3, TreeElement, EmphasisUnderscore, EmphasisAsterisk, LinkStart, ImageStart, InlineDelimiter, Escapable, Punctuation, DefaultInline, InlineContext, NotLast, FragmentCursor3, markdownHighlighting, parser6, StrikethroughDelim, Strikethrough, delimiterLine, TableParser, Table, TaskParser, TaskList, autolinkRE, urlRE, lastTwoDomainWords, emailRE, xmppResourceRE, Autolink, GFM, Superscript, Subscript, Emoji;
var init_dist18 = __esm({
  "node_modules/@lezer/markdown/dist/index.js"() {
    "use strict";
    init_dist3();
    init_dist5();
    CompositeBlock = class _CompositeBlock {
      static create(type, value, from2, parentHash, end) {
        let hash3 = parentHash + (parentHash << 8) + type + (value << 4) | 0;
        return new _CompositeBlock(type, value, from2, hash3, end, [], []);
      }
      constructor(type, value, from2, hash3, end, children, positions) {
        this.type = type;
        this.value = value;
        this.from = from2;
        this.hash = hash3;
        this.end = end;
        this.children = children;
        this.positions = positions;
        this.hashProp = [[NodeProp.contextHash, hash3]];
      }
      addChild(child, pos) {
        if (child.prop(NodeProp.contextHash) != this.hash)
          child = new Tree2(child.type, child.children, child.positions, child.length, this.hashProp);
        this.children.push(child);
        this.positions.push(pos);
      }
      toTree(nodeSet, end = this.end) {
        let last4 = this.children.length - 1;
        if (last4 >= 0)
          end = Math.max(end, this.positions[last4] + this.children[last4].length + this.from);
        return new Tree2(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({
          makeTree: (children, positions, length) => new Tree2(NodeType.none, children, positions, length, this.hashProp)
        });
      }
    };
    (function(Type3) {
      Type3[Type3["Document"] = 1] = "Document";
      Type3[Type3["CodeBlock"] = 2] = "CodeBlock";
      Type3[Type3["FencedCode"] = 3] = "FencedCode";
      Type3[Type3["Blockquote"] = 4] = "Blockquote";
      Type3[Type3["HorizontalRule"] = 5] = "HorizontalRule";
      Type3[Type3["BulletList"] = 6] = "BulletList";
      Type3[Type3["OrderedList"] = 7] = "OrderedList";
      Type3[Type3["ListItem"] = 8] = "ListItem";
      Type3[Type3["ATXHeading1"] = 9] = "ATXHeading1";
      Type3[Type3["ATXHeading2"] = 10] = "ATXHeading2";
      Type3[Type3["ATXHeading3"] = 11] = "ATXHeading3";
      Type3[Type3["ATXHeading4"] = 12] = "ATXHeading4";
      Type3[Type3["ATXHeading5"] = 13] = "ATXHeading5";
      Type3[Type3["ATXHeading6"] = 14] = "ATXHeading6";
      Type3[Type3["SetextHeading1"] = 15] = "SetextHeading1";
      Type3[Type3["SetextHeading2"] = 16] = "SetextHeading2";
      Type3[Type3["HTMLBlock"] = 17] = "HTMLBlock";
      Type3[Type3["LinkReference"] = 18] = "LinkReference";
      Type3[Type3["Paragraph"] = 19] = "Paragraph";
      Type3[Type3["CommentBlock"] = 20] = "CommentBlock";
      Type3[Type3["ProcessingInstructionBlock"] = 21] = "ProcessingInstructionBlock";
      Type3[Type3["Escape"] = 22] = "Escape";
      Type3[Type3["Entity"] = 23] = "Entity";
      Type3[Type3["HardBreak"] = 24] = "HardBreak";
      Type3[Type3["Emphasis"] = 25] = "Emphasis";
      Type3[Type3["StrongEmphasis"] = 26] = "StrongEmphasis";
      Type3[Type3["Link"] = 27] = "Link";
      Type3[Type3["Image"] = 28] = "Image";
      Type3[Type3["InlineCode"] = 29] = "InlineCode";
      Type3[Type3["HTMLTag"] = 30] = "HTMLTag";
      Type3[Type3["Comment"] = 31] = "Comment";
      Type3[Type3["ProcessingInstruction"] = 32] = "ProcessingInstruction";
      Type3[Type3["Autolink"] = 33] = "Autolink";
      Type3[Type3["HeaderMark"] = 34] = "HeaderMark";
      Type3[Type3["QuoteMark"] = 35] = "QuoteMark";
      Type3[Type3["ListMark"] = 36] = "ListMark";
      Type3[Type3["LinkMark"] = 37] = "LinkMark";
      Type3[Type3["EmphasisMark"] = 38] = "EmphasisMark";
      Type3[Type3["CodeMark"] = 39] = "CodeMark";
      Type3[Type3["CodeText"] = 40] = "CodeText";
      Type3[Type3["CodeInfo"] = 41] = "CodeInfo";
      Type3[Type3["LinkTitle"] = 42] = "LinkTitle";
      Type3[Type3["LinkLabel"] = 43] = "LinkLabel";
      Type3[Type3["URL"] = 44] = "URL";
    })(Type2 || (Type2 = {}));
    LeafBlock = class {
      /**
      @internal
      */
      constructor(start, content2) {
        this.start = start;
        this.content = content2;
        this.marks = [];
        this.parsers = [];
      }
    };
    Line2 = class {
      constructor() {
        this.text = "";
        this.baseIndent = 0;
        this.basePos = 0;
        this.depth = 0;
        this.markers = [];
        this.pos = 0;
        this.indent = 0;
        this.next = -1;
      }
      /**
      @internal
      */
      forward() {
        if (this.basePos > this.pos)
          this.forwardInner();
      }
      /**
      @internal
      */
      forwardInner() {
        let newPos = this.skipSpace(this.basePos);
        this.indent = this.countIndent(newPos, this.pos, this.indent);
        this.pos = newPos;
        this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);
      }
      /**
      Skip whitespace after the given position, return the position of
      the next non-space character or the end of the line if there's
      only space after `from`.
      */
      skipSpace(from2) {
        return skipSpace(this.text, from2);
      }
      /**
      @internal
      */
      reset(text) {
        this.text = text;
        this.baseIndent = this.basePos = this.pos = this.indent = 0;
        this.forwardInner();
        this.depth = 1;
        while (this.markers.length)
          this.markers.pop();
      }
      /**
      Move the line's base position forward to the given position.
      This should only be called by composite [block
      parsers](#BlockParser.parse) or [markup skipping
      functions](#NodeSpec.composite).
      */
      moveBase(to) {
        this.basePos = to;
        this.baseIndent = this.countIndent(to, this.pos, this.indent);
      }
      /**
      Move the line's base position forward to the given _column_.
      */
      moveBaseColumn(indent2) {
        this.baseIndent = indent2;
        this.basePos = this.findColumn(indent2);
      }
      /**
      Store a composite-block-level marker. Should be called from
      [markup skipping functions](#NodeSpec.composite) when they
      consume any non-whitespace characters.
      */
      addMarker(elt2) {
        this.markers.push(elt2);
      }
      /**
      Find the column position at `to`, optionally starting at a given
      position and column.
      */
      countIndent(to, from2 = 0, indent2 = 0) {
        for (let i = from2; i < to; i++)
          indent2 += this.text.charCodeAt(i) == 9 ? 4 - indent2 % 4 : 1;
        return indent2;
      }
      /**
      Find the position corresponding to the given column.
      */
      findColumn(goal) {
        let i = 0;
        for (let indent2 = 0; i < this.text.length && indent2 < goal; i++)
          indent2 += this.text.charCodeAt(i) == 9 ? 4 - indent2 % 4 : 1;
        return i;
      }
      /**
      @internal
      */
      scrub() {
        if (!this.baseIndent)
          return this.text;
        let result = "";
        for (let i = 0; i < this.basePos; i++)
          result += " ";
        return result + this.text.slice(this.basePos);
      }
    };
    DefaultSkipMarkup = {
      [Type2.Blockquote](bl, cx, line) {
        if (line.next != 62)
          return false;
        line.markers.push(elt(Type2.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));
        line.moveBase(line.pos + (space4(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));
        bl.end = cx.lineStart + line.text.length;
        return true;
      },
      [Type2.ListItem](bl, _cx, line) {
        if (line.indent < line.baseIndent + bl.value && line.next > -1)
          return false;
        line.moveBaseColumn(line.baseIndent + bl.value);
        return true;
      },
      [Type2.OrderedList]: skipForList,
      [Type2.BulletList]: skipForList,
      [Type2.Document]() {
        return true;
      }
    };
    EmptyLine = /^[ \t]*$/;
    CommentEnd = /-->/;
    ProcessingEnd = /\?>/;
    HTMLBlockStyle = [
      [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
      [/^\s*<!--/, CommentEnd],
      [/^\s*<\?/, ProcessingEnd],
      [/^\s*<![A-Z]/, />/],
      [/^\s*<!\[CDATA\[/, /\]\]>/],
      [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, EmptyLine],
      [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, EmptyLine]
    ];
    DefaultBlockParsers = {
      LinkReference: void 0,
      IndentedCode(cx, line) {
        let base2 = line.baseIndent + 4;
        if (line.indent < base2)
          return false;
        let start = line.findColumn(base2);
        let from2 = cx.lineStart + start, to = cx.lineStart + line.text.length;
        let marks2 = [], pendingMarks = [];
        addCodeText(marks2, from2, to);
        while (cx.nextLine() && line.depth >= cx.stack.length) {
          if (line.pos == line.text.length) {
            addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);
            for (let m of line.markers)
              pendingMarks.push(m);
          } else if (line.indent < base2) {
            break;
          } else {
            if (pendingMarks.length) {
              for (let m of pendingMarks) {
                if (m.type == Type2.CodeText)
                  addCodeText(marks2, m.from, m.to);
                else
                  marks2.push(m);
              }
              pendingMarks = [];
            }
            addCodeText(marks2, cx.lineStart - 1, cx.lineStart);
            for (let m of line.markers)
              marks2.push(m);
            to = cx.lineStart + line.text.length;
            let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);
            if (codeStart < to)
              addCodeText(marks2, codeStart, to);
          }
        }
        if (pendingMarks.length) {
          pendingMarks = pendingMarks.filter((m) => m.type != Type2.CodeText);
          if (pendingMarks.length)
            line.markers = pendingMarks.concat(line.markers);
        }
        cx.addNode(cx.buffer.writeElements(marks2, -from2).finish(Type2.CodeBlock, to - from2), from2);
        return true;
      },
      FencedCode(cx, line) {
        let fenceEnd = isFencedCode(line);
        if (fenceEnd < 0)
          return false;
        let from2 = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;
        let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);
        let marks2 = [elt(Type2.CodeMark, from2, from2 + len)];
        if (infoFrom < infoTo)
          marks2.push(elt(Type2.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));
        for (let first2 = true; cx.nextLine() && line.depth >= cx.stack.length; first2 = false) {
          let i = line.pos;
          if (line.indent - line.baseIndent < 4)
            while (i < line.text.length && line.text.charCodeAt(i) == ch)
              i++;
          if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {
            for (let m of line.markers)
              marks2.push(m);
            marks2.push(elt(Type2.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));
            cx.nextLine();
            break;
          } else {
            if (!first2)
              addCodeText(marks2, cx.lineStart - 1, cx.lineStart);
            for (let m of line.markers)
              marks2.push(m);
            let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;
            if (textStart < textEnd)
              addCodeText(marks2, textStart, textEnd);
          }
        }
        cx.addNode(cx.buffer.writeElements(marks2, -from2).finish(Type2.FencedCode, cx.prevLineEnd() - from2), from2);
        return true;
      },
      Blockquote(cx, line) {
        let size = isBlockquote(line);
        if (size < 0)
          return false;
        cx.startContext(Type2.Blockquote, line.pos);
        cx.addNode(Type2.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);
        line.moveBase(line.pos + size);
        return null;
      },
      HorizontalRule(cx, line) {
        if (isHorizontalRule(line, cx, false) < 0)
          return false;
        let from2 = cx.lineStart + line.pos;
        cx.nextLine();
        cx.addNode(Type2.HorizontalRule, from2);
        return true;
      },
      BulletList(cx, line) {
        let size = isBulletList(line, cx, false);
        if (size < 0)
          return false;
        if (cx.block.type != Type2.BulletList)
          cx.startContext(Type2.BulletList, line.basePos, line.next);
        let newBase = getListIndent(line, line.pos + 1);
        cx.startContext(Type2.ListItem, line.basePos, newBase - line.baseIndent);
        cx.addNode(Type2.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);
        line.moveBaseColumn(newBase);
        return null;
      },
      OrderedList(cx, line) {
        let size = isOrderedList(line, cx, false);
        if (size < 0)
          return false;
        if (cx.block.type != Type2.OrderedList)
          cx.startContext(Type2.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));
        let newBase = getListIndent(line, line.pos + size);
        cx.startContext(Type2.ListItem, line.basePos, newBase - line.baseIndent);
        cx.addNode(Type2.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);
        line.moveBaseColumn(newBase);
        return null;
      },
      ATXHeading(cx, line) {
        let size = isAtxHeading(line);
        if (size < 0)
          return false;
        let off = line.pos, from2 = cx.lineStart + off;
        let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;
        while (after > off && line.text.charCodeAt(after - 1) == line.next)
          after--;
        if (after == endOfSpace || after == off || !space4(line.text.charCodeAt(after - 1)))
          after = line.text.length;
        let buf = cx.buffer.write(Type2.HeaderMark, 0, size).writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from2 + size + 1), -from2);
        if (after < line.text.length)
          buf.write(Type2.HeaderMark, after - off, endOfSpace - off);
        let node = buf.finish(Type2.ATXHeading1 - 1 + size, line.text.length - off);
        cx.nextLine();
        cx.addNode(node, from2);
        return true;
      },
      HTMLBlock(cx, line) {
        let type = isHTMLBlock(line, cx, false);
        if (type < 0)
          return false;
        let from2 = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];
        let marks2 = [], trailing = end != EmptyLine;
        while (!end.test(line.text) && cx.nextLine()) {
          if (line.depth < cx.stack.length) {
            trailing = false;
            break;
          }
          for (let m of line.markers)
            marks2.push(m);
        }
        if (trailing)
          cx.nextLine();
        let nodeType = end == CommentEnd ? Type2.CommentBlock : end == ProcessingEnd ? Type2.ProcessingInstructionBlock : Type2.HTMLBlock;
        let to = cx.prevLineEnd();
        cx.addNode(cx.buffer.writeElements(marks2, -from2).finish(nodeType, to - from2), from2);
        return true;
      },
      SetextHeading: void 0
      // Specifies relative precedence for block-continue function
    };
    LinkReferenceParser = class {
      constructor(leaf) {
        this.stage = 0;
        this.elts = [];
        this.pos = 0;
        this.start = leaf.start;
        this.advance(leaf.content);
      }
      nextLine(cx, line, leaf) {
        if (this.stage == -1)
          return false;
        let content2 = leaf.content + "\n" + line.scrub();
        let finish = this.advance(content2);
        if (finish > -1 && finish < content2.length)
          return this.complete(cx, leaf, finish);
        return false;
      }
      finish(cx, leaf) {
        if ((this.stage == 2 || this.stage == 3) && skipSpace(leaf.content, this.pos) == leaf.content.length)
          return this.complete(cx, leaf, leaf.content.length);
        return false;
      }
      complete(cx, leaf, len) {
        cx.addLeafElement(leaf, elt(Type2.LinkReference, this.start, this.start + len, this.elts));
        return true;
      }
      nextStage(elt2) {
        if (elt2) {
          this.pos = elt2.to - this.start;
          this.elts.push(elt2);
          this.stage++;
          return true;
        }
        if (elt2 === false)
          this.stage = -1;
        return false;
      }
      advance(content2) {
        for (; ; ) {
          if (this.stage == -1) {
            return -1;
          } else if (this.stage == 0) {
            if (!this.nextStage(parseLinkLabel(content2, this.pos, this.start, true)))
              return -1;
            if (content2.charCodeAt(this.pos) != 58)
              return this.stage = -1;
            this.elts.push(elt(Type2.LinkMark, this.pos + this.start, this.pos + this.start + 1));
            this.pos++;
          } else if (this.stage == 1) {
            if (!this.nextStage(parseURL(content2, skipSpace(content2, this.pos), this.start)))
              return -1;
          } else if (this.stage == 2) {
            let skip = skipSpace(content2, this.pos), end = 0;
            if (skip > this.pos) {
              let title = parseLinkTitle(content2, skip, this.start);
              if (title) {
                let titleEnd = lineEnd(content2, title.to - this.start);
                if (titleEnd > 0) {
                  this.nextStage(title);
                  end = titleEnd;
                }
              }
            }
            if (!end)
              end = lineEnd(content2, this.pos);
            return end > 0 && end < content2.length ? end : -1;
          } else {
            return lineEnd(content2, this.pos);
          }
        }
      }
    };
    SetextHeadingParser = class {
      nextLine(cx, line, leaf) {
        let underline2 = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);
        let next = line.next;
        if (underline2 < 0)
          return false;
        let underlineMark = elt(Type2.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline2);
        cx.nextLine();
        cx.addLeafElement(leaf, elt(next == 61 ? Type2.SetextHeading1 : Type2.SetextHeading2, leaf.start, cx.prevLineEnd(), [
          ...cx.parser.parseInline(leaf.content, leaf.start),
          underlineMark
        ]));
        return true;
      }
      finish() {
        return false;
      }
    };
    DefaultLeafBlocks = {
      LinkReference(_, leaf) {
        return leaf.content.charCodeAt(0) == 91 ? new LinkReferenceParser(leaf) : null;
      },
      SetextHeading() {
        return new SetextHeadingParser();
      }
    };
    DefaultEndLeaf = [
      (_, line) => isAtxHeading(line) >= 0,
      (_, line) => isFencedCode(line) >= 0,
      (_, line) => isBlockquote(line) >= 0,
      (p, line) => isBulletList(line, p, true) >= 0,
      (p, line) => isOrderedList(line, p, true) >= 0,
      (p, line) => isHorizontalRule(line, p, true) >= 0,
      (p, line) => isHTMLBlock(line, p, true) >= 0
    ];
    scanLineResult = { text: "", end: 0 };
    BlockContext = class {
      /**
      @internal
      */
      constructor(parser7, input2, fragments, ranges) {
        this.parser = parser7;
        this.input = input2;
        this.ranges = ranges;
        this.line = new Line2();
        this.atEnd = false;
        this.reusePlaceholders = /* @__PURE__ */ new Map();
        this.stoppedAt = null;
        this.rangeI = 0;
        this.to = ranges[ranges.length - 1].to;
        this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;
        this.block = CompositeBlock.create(Type2.Document, 0, this.lineStart, 0, 0);
        this.stack = [this.block];
        this.fragments = fragments.length ? new FragmentCursor3(fragments, input2) : null;
        this.readLine();
      }
      get parsedPos() {
        return this.absoluteLineStart;
      }
      advance() {
        if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
          return this.finish();
        let { line } = this;
        for (; ; ) {
          for (let markI = 0; ; ) {
            let next = line.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
            while (markI < line.markers.length && (!next || line.markers[markI].from < next.end)) {
              let mark = line.markers[markI++];
              this.addNode(mark.type, mark.from, mark.to);
            }
            if (!next)
              break;
            this.finishContext();
          }
          if (line.pos < line.text.length)
            break;
          if (!this.nextLine())
            return this.finish();
        }
        if (this.fragments && this.reuseFragment(line.basePos))
          return null;
        start: for (; ; ) {
          for (let type of this.parser.blockParsers)
            if (type) {
              let result = type(this, line);
              if (result != false) {
                if (result == true)
                  return null;
                line.forward();
                continue start;
              }
            }
          break;
        }
        let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));
        for (let parse of this.parser.leafBlockParsers)
          if (parse) {
            let parser7 = parse(this, leaf);
            if (parser7)
              leaf.parsers.push(parser7);
          }
        lines: while (this.nextLine()) {
          if (line.pos == line.text.length)
            break;
          if (line.indent < line.baseIndent + 4) {
            for (let stop of this.parser.endLeafBlock)
              if (stop(this, line, leaf))
                break lines;
          }
          for (let parser7 of leaf.parsers)
            if (parser7.nextLine(this, line, leaf))
              return null;
          leaf.content += "\n" + line.scrub();
          for (let m of line.markers)
            leaf.marks.push(m);
        }
        this.finishLeaf(leaf);
        return null;
      }
      stopAt(pos) {
        if (this.stoppedAt != null && this.stoppedAt < pos)
          throw new RangeError("Can't move stoppedAt forward");
        this.stoppedAt = pos;
      }
      reuseFragment(start) {
        if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
          return false;
        let taken = this.fragments.takeNodes(this);
        if (!taken)
          return false;
        this.absoluteLineStart += taken;
        this.lineStart = toRelative(this.absoluteLineStart, this.ranges);
        this.moveRangeI();
        if (this.absoluteLineStart < this.to) {
          this.lineStart++;
          this.absoluteLineStart++;
          this.readLine();
        } else {
          this.atEnd = true;
          this.readLine();
        }
        return true;
      }
      /**
      The number of parent blocks surrounding the current block.
      */
      get depth() {
        return this.stack.length;
      }
      /**
      Get the type of the parent block at the given depth. When no
      depth is passed, return the type of the innermost parent.
      */
      parentType(depth = this.depth - 1) {
        return this.parser.nodeSet.types[this.stack[depth].type];
      }
      /**
      Move to the next input line. This should only be called by
      (non-composite) [block parsers](#BlockParser.parse) that consume
      the line directly, or leaf block parser
      [`nextLine`](#LeafBlockParser.nextLine) methods when they
      consume the current line (and return true).
      */
      nextLine() {
        this.lineStart += this.line.text.length;
        if (this.absoluteLineEnd >= this.to) {
          this.absoluteLineStart = this.absoluteLineEnd;
          this.atEnd = true;
          this.readLine();
          return false;
        } else {
          this.lineStart++;
          this.absoluteLineStart = this.absoluteLineEnd + 1;
          this.moveRangeI();
          this.readLine();
          return true;
        }
      }
      /**
      Retrieve the text of the line after the current one, without
      actually moving the context's current line forward.
      */
      peekLine() {
        return this.scanLine(this.absoluteLineEnd + 1).text;
      }
      moveRangeI() {
        while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {
          this.rangeI++;
          this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
        }
      }
      /**
      @internal
      Collect the text for the next line.
      */
      scanLine(start) {
        let r = scanLineResult;
        r.end = start;
        if (start >= this.to) {
          r.text = "";
        } else {
          r.text = this.lineChunkAt(start);
          r.end += r.text.length;
          if (this.ranges.length > 1) {
            let textOffset = this.absoluteLineStart, rangeI = this.rangeI;
            while (this.ranges[rangeI].to < r.end) {
              rangeI++;
              let nextFrom = this.ranges[rangeI].from;
              let after = this.lineChunkAt(nextFrom);
              r.end = nextFrom + after.length;
              r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;
              textOffset = r.end - r.text.length;
            }
          }
        }
        return r;
      }
      /**
      @internal
      Populate this.line with the content of the next line. Skip
      leading characters covered by composite blocks.
      */
      readLine() {
        let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);
        this.absoluteLineEnd = end;
        line.reset(text);
        for (; line.depth < this.stack.length; line.depth++) {
          let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];
          if (!handler)
            throw new Error("Unhandled block context " + Type2[cx.type]);
          if (!handler(cx, this, line))
            break;
          line.forward();
        }
      }
      lineChunkAt(pos) {
        let next = this.input.chunk(pos), text;
        if (!this.input.lineChunks) {
          let eol = next.indexOf("\n");
          text = eol < 0 ? next : next.slice(0, eol);
        } else {
          text = next == "\n" ? "" : next;
        }
        return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;
      }
      /**
      The end position of the previous line.
      */
      prevLineEnd() {
        return this.atEnd ? this.lineStart : this.lineStart - 1;
      }
      /**
      @internal
      */
      startContext(type, start, value = 0) {
        this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);
        this.stack.push(this.block);
      }
      /**
      Start a composite block. Should only be called from [block
      parser functions](#BlockParser.parse) that return null.
      */
      startComposite(type, start, value = 0) {
        this.startContext(this.parser.getNodeType(type), start, value);
      }
      /**
      @internal
      */
      addNode(block, from2, to) {
        if (typeof block == "number")
          block = new Tree2(this.parser.nodeSet.types[block], none3, none3, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from2);
        this.block.addChild(block, from2 - this.block.from);
      }
      /**
      Add a block element. Can be called by [block
      parsers](#BlockParser.parse).
      */
      addElement(elt2) {
        this.block.addChild(elt2.toTree(this.parser.nodeSet), elt2.from - this.block.from);
      }
      /**
      Add a block element from a [leaf parser](#LeafBlockParser). This
      makes sure any extra composite block markup (such as blockquote
      markers) inside the block are also added to the syntax tree.
      */
      addLeafElement(leaf, elt2) {
        this.addNode(this.buffer.writeElements(injectMarks(elt2.children, leaf.marks), -elt2.from).finish(elt2.type, elt2.to - elt2.from), elt2.from);
      }
      /**
      @internal
      */
      finishContext() {
        let cx = this.stack.pop();
        let top2 = this.stack[this.stack.length - 1];
        top2.addChild(cx.toTree(this.parser.nodeSet), cx.from - top2.from);
        this.block = top2;
      }
      finish() {
        while (this.stack.length > 1)
          this.finishContext();
        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
      }
      addGaps(tree2) {
        return this.ranges.length > 1 ? injectGaps(this.ranges, 0, tree2.topNode, this.ranges[0].from, this.reusePlaceholders) : tree2;
      }
      /**
      @internal
      */
      finishLeaf(leaf) {
        for (let parser7 of leaf.parsers)
          if (parser7.finish(this, leaf))
            return;
        let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);
        this.addNode(this.buffer.writeElements(inline, -leaf.start).finish(Type2.Paragraph, leaf.content.length), leaf.start);
      }
      elt(type, from2, to, children) {
        if (typeof type == "string")
          return elt(this.parser.getNodeType(type), from2, to, children);
        return new TreeElement(type, from2);
      }
      /**
      @internal
      */
      get buffer() {
        return new Buffer2(this.parser.nodeSet);
      }
    };
    MarkdownParser = class _MarkdownParser extends Parser {
      /**
      @internal
      */
      constructor(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers) {
        super();
        this.nodeSet = nodeSet;
        this.blockParsers = blockParsers;
        this.leafBlockParsers = leafBlockParsers;
        this.blockNames = blockNames;
        this.endLeafBlock = endLeafBlock;
        this.skipContextMarkup = skipContextMarkup;
        this.inlineParsers = inlineParsers;
        this.inlineNames = inlineNames;
        this.wrappers = wrappers;
        this.nodeTypes = /* @__PURE__ */ Object.create(null);
        for (let t2 of nodeSet.types)
          this.nodeTypes[t2.name] = t2.id;
      }
      createParse(input2, fragments, ranges) {
        let parse = new BlockContext(this, input2, fragments, ranges);
        for (let w of this.wrappers)
          parse = w(parse, input2, fragments, ranges);
        return parse;
      }
      /**
      Reconfigure the parser.
      */
      configure(spec) {
        let config3 = resolveConfig(spec);
        if (!config3)
          return this;
        let { nodeSet, skipContextMarkup } = this;
        let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;
        if (nonEmpty(config3.defineNodes)) {
          skipContextMarkup = Object.assign({}, skipContextMarkup);
          let nodeTypes2 = nodeSet.types.slice(), styles;
          for (let s of config3.defineNodes) {
            let { name: name2, block, composite, style } = typeof s == "string" ? { name: s } : s;
            if (nodeTypes2.some((t2) => t2.name == name2))
              continue;
            if (composite)
              skipContextMarkup[nodeTypes2.length] = (bl, cx, line) => composite(cx, line, bl.value);
            let id2 = nodeTypes2.length;
            let group = composite ? ["Block", "BlockContext"] : !block ? void 0 : id2 >= Type2.ATXHeading1 && id2 <= Type2.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"];
            nodeTypes2.push(NodeType.define({
              id: id2,
              name: name2,
              props: group && [[NodeProp.group, group]]
            }));
            if (style) {
              if (!styles)
                styles = {};
              if (Array.isArray(style) || style instanceof Tag)
                styles[name2] = style;
              else
                Object.assign(styles, style);
            }
          }
          nodeSet = new NodeSet(nodeTypes2);
          if (styles)
            nodeSet = nodeSet.extend(styleTags(styles));
        }
        if (nonEmpty(config3.props))
          nodeSet = nodeSet.extend(...config3.props);
        if (nonEmpty(config3.remove)) {
          for (let rm2 of config3.remove) {
            let block = this.blockNames.indexOf(rm2), inline = this.inlineNames.indexOf(rm2);
            if (block > -1)
              blockParsers[block] = leafBlockParsers[block] = void 0;
            if (inline > -1)
              inlineParsers[inline] = void 0;
          }
        }
        if (nonEmpty(config3.parseBlock)) {
          for (let spec2 of config3.parseBlock) {
            let found = blockNames.indexOf(spec2.name);
            if (found > -1) {
              blockParsers[found] = spec2.parse;
              leafBlockParsers[found] = spec2.leaf;
            } else {
              let pos = spec2.before ? findName(blockNames, spec2.before) : spec2.after ? findName(blockNames, spec2.after) + 1 : blockNames.length - 1;
              blockParsers.splice(pos, 0, spec2.parse);
              leafBlockParsers.splice(pos, 0, spec2.leaf);
              blockNames.splice(pos, 0, spec2.name);
            }
            if (spec2.endLeaf)
              endLeafBlock.push(spec2.endLeaf);
          }
        }
        if (nonEmpty(config3.parseInline)) {
          for (let spec2 of config3.parseInline) {
            let found = inlineNames.indexOf(spec2.name);
            if (found > -1) {
              inlineParsers[found] = spec2.parse;
            } else {
              let pos = spec2.before ? findName(inlineNames, spec2.before) : spec2.after ? findName(inlineNames, spec2.after) + 1 : inlineNames.length - 1;
              inlineParsers.splice(pos, 0, spec2.parse);
              inlineNames.splice(pos, 0, spec2.name);
            }
          }
        }
        if (config3.wrap)
          wrappers = wrappers.concat(config3.wrap);
        return new _MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);
      }
      /**
      @internal
      */
      getNodeType(name2) {
        let found = this.nodeTypes[name2];
        if (found == null)
          throw new RangeError(`Unknown node type '${name2}'`);
        return found;
      }
      /**
      Parse the given piece of inline text at the given offset,
      returning an array of [`Element`](#Element) objects representing
      the inline content.
      */
      parseInline(text, offset) {
        let cx = new InlineContext(this, text, offset);
        outer: for (let pos = offset; pos < cx.end; ) {
          let next = cx.char(pos);
          for (let token of this.inlineParsers)
            if (token) {
              let result = token(cx, next, pos);
              if (result >= 0) {
                pos = result;
                continue outer;
              }
            }
          pos++;
        }
        return cx.resolveMarkers(0);
      }
    };
    nodeTypes = [NodeType.none];
    for (let i = 1, name2; name2 = Type2[i]; i++) {
      nodeTypes[i] = NodeType.define({
        id: i,
        name: name2,
        props: i >= Type2.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]],
        top: name2 == "Document"
      });
    }
    none3 = [];
    Buffer2 = class {
      constructor(nodeSet) {
        this.nodeSet = nodeSet;
        this.content = [];
        this.nodes = [];
      }
      write(type, from2, to, children = 0) {
        this.content.push(type, from2, to, 4 + children * 4);
        return this;
      }
      writeElements(elts, offset = 0) {
        for (let e of elts)
          e.writeTo(this, offset);
        return this;
      }
      finish(type, length) {
        return Tree2.build({
          buffer: this.content,
          nodeSet: this.nodeSet,
          reused: this.nodes,
          topID: type,
          length
        });
      }
    };
    Element3 = class {
      /**
      @internal
      */
      constructor(type, from2, to, children = none3) {
        this.type = type;
        this.from = from2;
        this.to = to;
        this.children = children;
      }
      /**
      @internal
      */
      writeTo(buf, offset) {
        let startOff = buf.content.length;
        buf.writeElements(this.children, offset);
        buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);
      }
      /**
      @internal
      */
      toTree(nodeSet) {
        return new Buffer2(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
      }
    };
    TreeElement = class {
      constructor(tree2, from2) {
        this.tree = tree2;
        this.from = from2;
      }
      get to() {
        return this.from + this.tree.length;
      }
      get type() {
        return this.tree.type.id;
      }
      get children() {
        return none3;
      }
      writeTo(buf, offset) {
        buf.nodes.push(this.tree);
        buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);
      }
      toTree() {
        return this.tree;
      }
    };
    EmphasisUnderscore = { resolve: "Emphasis", mark: "EmphasisMark" };
    EmphasisAsterisk = { resolve: "Emphasis", mark: "EmphasisMark" };
    LinkStart = {};
    ImageStart = {};
    InlineDelimiter = class {
      constructor(type, from2, to, side) {
        this.type = type;
        this.from = from2;
        this.to = to;
        this.side = side;
      }
    };
    Escapable = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
    Punctuation = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
    try {
      Punctuation = new RegExp("[\\p{S}|\\p{P}]", "u");
    } catch (_) {
    }
    DefaultInline = {
      Escape(cx, next, start) {
        if (next != 92 || start == cx.end - 1)
          return -1;
        let escaped = cx.char(start + 1);
        for (let i = 0; i < Escapable.length; i++)
          if (Escapable.charCodeAt(i) == escaped)
            return cx.append(elt(Type2.Escape, start, start + 2));
        return -1;
      },
      Entity(cx, next, start) {
        if (next != 38)
          return -1;
        let m = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(cx.slice(start + 1, start + 31));
        return m ? cx.append(elt(Type2.Entity, start, start + 1 + m[0].length)) : -1;
      },
      InlineCode(cx, next, start) {
        if (next != 96 || start && cx.char(start - 1) == 96)
          return -1;
        let pos = start + 1;
        while (pos < cx.end && cx.char(pos) == 96)
          pos++;
        let size = pos - start, curSize = 0;
        for (; pos < cx.end; pos++) {
          if (cx.char(pos) == 96) {
            curSize++;
            if (curSize == size && cx.char(pos + 1) != 96)
              return cx.append(elt(Type2.InlineCode, start, pos + 1, [
                elt(Type2.CodeMark, start, start + size),
                elt(Type2.CodeMark, pos + 1 - size, pos + 1)
              ]));
          } else {
            curSize = 0;
          }
        }
        return -1;
      },
      HTMLTag(cx, next, start) {
        if (next != 60 || start == cx.end - 1)
          return -1;
        let after = cx.slice(start + 1, cx.end);
        let url = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(after);
        if (url) {
          return cx.append(elt(Type2.Autolink, start, start + 1 + url[0].length, [
            elt(Type2.LinkMark, start, start + 1),
            // url[0] includes the closing bracket, so exclude it from this slice
            elt(Type2.URL, start + 1, start + url[0].length),
            elt(Type2.LinkMark, start + url[0].length, start + 1 + url[0].length)
          ]));
        }
        let comment2 = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);
        if (comment2)
          return cx.append(elt(Type2.Comment, start, start + 1 + comment2[0].length));
        let procInst = /^\?[^]*?\?>/.exec(after);
        if (procInst)
          return cx.append(elt(Type2.ProcessingInstruction, start, start + 1 + procInst[0].length));
        let m = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(after);
        if (!m)
          return -1;
        return cx.append(elt(Type2.HTMLTag, start, start + 1 + m[0].length));
      },
      Emphasis(cx, next, start) {
        if (next != 95 && next != 42)
          return -1;
        let pos = start + 1;
        while (cx.char(pos) == next)
          pos++;
        let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);
        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);
        let sBefore = /\s|^$/.test(before), sAfter = /\s|^$/.test(after);
        let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);
        let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);
        let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);
        let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);
        return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 : 0) | (canClose ? 2 : 0)));
      },
      HardBreak(cx, next, start) {
        if (next == 92 && cx.char(start + 1) == 10)
          return cx.append(elt(Type2.HardBreak, start, start + 2));
        if (next == 32) {
          let pos = start + 1;
          while (cx.char(pos) == 32)
            pos++;
          if (cx.char(pos) == 10 && pos >= start + 2)
            return cx.append(elt(Type2.HardBreak, start, pos + 1));
        }
        return -1;
      },
      Link(cx, next, start) {
        return next == 91 ? cx.append(new InlineDelimiter(
          LinkStart,
          start,
          start + 1,
          1
          /* Mark.Open */
        )) : -1;
      },
      Image(cx, next, start) {
        return next == 33 && cx.char(start + 1) == 91 ? cx.append(new InlineDelimiter(
          ImageStart,
          start,
          start + 2,
          1
          /* Mark.Open */
        )) : -1;
      },
      LinkEnd(cx, next, start) {
        if (next != 93)
          return -1;
        for (let i = cx.parts.length - 1; i >= 0; i--) {
          let part = cx.parts[i];
          if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {
            if (!part.side || cx.skipSpace(part.to) == start && !/[(\[]/.test(cx.slice(start + 1, start + 2))) {
              cx.parts[i] = null;
              return -1;
            }
            let content2 = cx.takeContent(i);
            let link = cx.parts[i] = finishLink(cx, content2, part.type == LinkStart ? Type2.Link : Type2.Image, part.from, start + 1);
            if (part.type == LinkStart)
              for (let j = 0; j < i; j++) {
                let p = cx.parts[j];
                if (p instanceof InlineDelimiter && p.type == LinkStart)
                  p.side = 0;
              }
            return link.to;
          }
        }
        return -1;
      }
    };
    InlineContext = class {
      /**
      @internal
      */
      constructor(parser7, text, offset) {
        this.parser = parser7;
        this.text = text;
        this.offset = offset;
        this.parts = [];
      }
      /**
      Get the character code at the given (document-relative)
      position.
      */
      char(pos) {
        return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset);
      }
      /**
      The position of the end of this inline section.
      */
      get end() {
        return this.offset + this.text.length;
      }
      /**
      Get a substring of this inline section. Again uses
      document-relative positions.
      */
      slice(from2, to) {
        return this.text.slice(from2 - this.offset, to - this.offset);
      }
      /**
      @internal
      */
      append(elt2) {
        this.parts.push(elt2);
        return elt2.to;
      }
      /**
      Add a [delimiter](#DelimiterType) at this given position. `open`
      and `close` indicate whether this delimiter is opening, closing,
      or both. Returns the end of the delimiter, for convenient
      returning from [parse functions](#InlineParser.parse).
      */
      addDelimiter(type, from2, to, open, close) {
        return this.append(new InlineDelimiter(type, from2, to, (open ? 1 : 0) | (close ? 2 : 0)));
      }
      /**
      Returns true when there is an unmatched link or image opening
      token before the current position.
      */
      get hasOpenLink() {
        for (let i = this.parts.length - 1; i >= 0; i--) {
          let part = this.parts[i];
          if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart))
            return true;
        }
        return false;
      }
      /**
      Add an inline element. Returns the end of the element.
      */
      addElement(elt2) {
        return this.append(elt2);
      }
      /**
      Resolve markers between this.parts.length and from, wrapping matched markers in the
      appropriate node and updating the content of this.parts. @internal
      */
      resolveMarkers(from2) {
        for (let i = from2; i < this.parts.length; i++) {
          let close = this.parts[i];
          if (!(close instanceof InlineDelimiter && close.type.resolve && close.side & 2))
            continue;
          let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;
          let closeSize = close.to - close.from;
          let open, j = i - 1;
          for (; j >= from2; j--) {
            let part = this.parts[j];
            if (part instanceof InlineDelimiter && part.side & 1 && part.type == close.type && // Ignore emphasis delimiters where the character count doesn't match
            !(emp && (close.side & 1 || part.side & 2) && (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))) {
              open = part;
              break;
            }
          }
          if (!open)
            continue;
          let type = close.type.resolve, content2 = [];
          let start = open.from, end = close.to;
          if (emp) {
            let size = Math.min(2, open.to - open.from, closeSize);
            start = open.to - size;
            end = close.from + size;
            type = size == 1 ? "Emphasis" : "StrongEmphasis";
          }
          if (open.type.mark)
            content2.push(this.elt(open.type.mark, start, open.to));
          for (let k = j + 1; k < i; k++) {
            if (this.parts[k] instanceof Element3)
              content2.push(this.parts[k]);
            this.parts[k] = null;
          }
          if (close.type.mark)
            content2.push(this.elt(close.type.mark, close.from, end));
          let element = this.elt(type, start, end, content2);
          this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;
          let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;
          if (keep)
            this.parts.splice(i, 0, element);
          else
            this.parts[i] = element;
        }
        let result = [];
        for (let i = from2; i < this.parts.length; i++) {
          let part = this.parts[i];
          if (part instanceof Element3)
            result.push(part);
        }
        return result;
      }
      /**
      Find an opening delimiter of the given type. Returns `null` if
      no delimiter is found, or an index that can be passed to
      [`takeContent`](#InlineContext.takeContent) otherwise.
      */
      findOpeningDelimiter(type) {
        for (let i = this.parts.length - 1; i >= 0; i--) {
          let part = this.parts[i];
          if (part instanceof InlineDelimiter && part.type == type && part.side & 1)
            return i;
        }
        return null;
      }
      /**
      Remove all inline elements and delimiters starting from the
      given index (which you should get from
      [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),
      resolve delimiters inside of them, and return them as an array
      of elements.
      */
      takeContent(startIndex) {
        let content2 = this.resolveMarkers(startIndex);
        this.parts.length = startIndex;
        return content2;
      }
      /**
      Return the delimiter at the given index. Mostly useful to get
      additional info out of a delimiter index returned by
      [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter).
      Returns null if there is no delimiter at this index.
      */
      getDelimiterAt(index) {
        let part = this.parts[index];
        return part instanceof InlineDelimiter ? part : null;
      }
      /**
      Skip space after the given (document) position, returning either
      the position of the next non-space character or the end of the
      section.
      */
      skipSpace(from2) {
        return skipSpace(this.text, from2 - this.offset) + this.offset;
      }
      elt(type, from2, to, children) {
        if (typeof type == "string")
          return elt(this.parser.getNodeType(type), from2, to, children);
        return new TreeElement(type, from2);
      }
    };
    NotLast = [Type2.CodeBlock, Type2.ListItem, Type2.OrderedList, Type2.BulletList];
    FragmentCursor3 = class {
      constructor(fragments, input2) {
        this.fragments = fragments;
        this.input = input2;
        this.i = 0;
        this.fragment = null;
        this.fragmentEnd = -1;
        this.cursor = null;
        if (fragments.length)
          this.fragment = fragments[this.i++];
      }
      nextFragment() {
        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;
        this.cursor = null;
        this.fragmentEnd = -1;
      }
      moveTo(pos, lineStart) {
        while (this.fragment && this.fragment.to <= pos)
          this.nextFragment();
        if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))
          return false;
        if (this.fragmentEnd < 0) {
          let end = this.fragment.to;
          while (end > 0 && this.input.read(end - 1, end) != "\n")
            end--;
          this.fragmentEnd = end ? end - 1 : 0;
        }
        let c = this.cursor;
        if (!c) {
          c = this.cursor = this.fragment.tree.cursor();
          c.firstChild();
        }
        let rPos = pos + this.fragment.offset;
        while (c.to <= rPos)
          if (!c.parent())
            return false;
        for (; ; ) {
          if (c.from >= rPos)
            return this.fragment.from <= lineStart;
          if (!c.childAfter(rPos))
            return false;
        }
      }
      matches(hash3) {
        let tree2 = this.cursor.tree;
        return tree2 && tree2.prop(NodeProp.contextHash) == hash3;
      }
      takeNodes(cx) {
        let cur2 = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);
        let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;
        let prevEnd = end, prevI = blockI;
        for (; ; ) {
          if (cur2.to - off > fragEnd) {
            if (cur2.type.isAnonymous && cur2.firstChild())
              continue;
            break;
          }
          let pos = toRelative(cur2.from - off, cx.ranges);
          if (cur2.to - off <= cx.ranges[cx.rangeI].to) {
            cx.addNode(cur2.tree, pos);
          } else {
            let dummy = new Tree2(cx.parser.nodeSet.types[Type2.Paragraph], [], [], 0, cx.block.hashProp);
            cx.reusePlaceholders.set(dummy, cur2.tree);
            cx.addNode(dummy, pos);
          }
          if (cur2.type.is("Block")) {
            if (NotLast.indexOf(cur2.type.id) < 0) {
              end = cur2.to - off;
              blockI = cx.block.children.length;
            } else {
              end = prevEnd;
              blockI = prevI;
              prevEnd = cur2.to - off;
              prevI = cx.block.children.length;
            }
          }
          if (!cur2.nextSibling())
            break;
        }
        while (cx.block.children.length > blockI) {
          cx.block.children.pop();
          cx.block.positions.pop();
        }
        return end - start;
      }
    };
    markdownHighlighting = styleTags({
      "Blockquote/...": tags.quote,
      HorizontalRule: tags.contentSeparator,
      "ATXHeading1/... SetextHeading1/...": tags.heading1,
      "ATXHeading2/... SetextHeading2/...": tags.heading2,
      "ATXHeading3/...": tags.heading3,
      "ATXHeading4/...": tags.heading4,
      "ATXHeading5/...": tags.heading5,
      "ATXHeading6/...": tags.heading6,
      "Comment CommentBlock": tags.comment,
      Escape: tags.escape,
      Entity: tags.character,
      "Emphasis/...": tags.emphasis,
      "StrongEmphasis/...": tags.strong,
      "Link/... Image/...": tags.link,
      "OrderedList/... BulletList/...": tags.list,
      "BlockQuote/...": tags.quote,
      "InlineCode CodeText": tags.monospace,
      "URL Autolink": tags.url,
      "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": tags.processingInstruction,
      "CodeInfo LinkLabel": tags.labelName,
      LinkTitle: tags.string,
      Paragraph: tags.content
    });
    parser6 = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map((n) => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map((n) => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map((n) => DefaultInline[n]), Object.keys(DefaultInline), []);
    StrikethroughDelim = { resolve: "Strikethrough", mark: "StrikethroughMark" };
    Strikethrough = {
      defineNodes: [{
        name: "Strikethrough",
        style: { "Strikethrough/...": tags.strikethrough }
      }, {
        name: "StrikethroughMark",
        style: tags.processingInstruction
      }],
      parseInline: [{
        name: "Strikethrough",
        parse(cx, next, pos) {
          if (next != 126 || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126)
            return -1;
          let before = cx.slice(pos - 1, pos), after = cx.slice(pos + 2, pos + 3);
          let sBefore = /\s|^$/.test(before), sAfter = /\s|^$/.test(after);
          let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);
          return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter && (!pAfter || sBefore || pBefore), !sBefore && (!pBefore || sAfter || pAfter));
        },
        after: "Emphasis"
      }]
    };
    delimiterLine = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
    TableParser = class {
      constructor() {
        this.rows = null;
      }
      nextLine(cx, line, leaf) {
        if (this.rows == null) {
          this.rows = false;
          let lineText;
          if ((line.next == 45 || line.next == 58 || line.next == 124) && delimiterLine.test(lineText = line.text.slice(line.pos))) {
            let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);
            if (firstCount == parseRow(cx, lineText, line.pos))
              this.rows = [
                cx.elt("TableHeader", leaf.start, leaf.start + leaf.content.length, firstRow),
                cx.elt("TableDelimiter", cx.lineStart + line.pos, cx.lineStart + line.text.length)
              ];
          }
        } else if (this.rows) {
          let content2 = [];
          parseRow(cx, line.text, line.pos, content2, cx.lineStart);
          this.rows.push(cx.elt("TableRow", cx.lineStart + line.pos, cx.lineStart + line.text.length, content2));
        }
        return false;
      }
      finish(cx, leaf) {
        if (!this.rows)
          return false;
        cx.addLeafElement(leaf, cx.elt("Table", leaf.start, leaf.start + leaf.content.length, this.rows));
        return true;
      }
    };
    Table = {
      defineNodes: [
        { name: "Table", block: true },
        { name: "TableHeader", style: { "TableHeader/...": tags.heading } },
        "TableRow",
        { name: "TableCell", style: tags.content },
        { name: "TableDelimiter", style: tags.processingInstruction }
      ],
      parseBlock: [{
        name: "Table",
        leaf(_, leaf) {
          return hasPipe(leaf.content, 0) ? new TableParser() : null;
        },
        endLeaf(cx, line, leaf) {
          if (leaf.parsers.some((p) => p instanceof TableParser) || !hasPipe(line.text, line.basePos))
            return false;
          let next = cx.peekLine();
          return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);
        },
        before: "SetextHeading"
      }]
    };
    TaskParser = class {
      nextLine() {
        return false;
      }
      finish(cx, leaf) {
        cx.addLeafElement(leaf, cx.elt("Task", leaf.start, leaf.start + leaf.content.length, [
          cx.elt("TaskMarker", leaf.start, leaf.start + 3),
          ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)
        ]));
        return true;
      }
    };
    TaskList = {
      defineNodes: [
        { name: "Task", block: true, style: tags.list },
        { name: "TaskMarker", style: tags.atom }
      ],
      parseBlock: [{
        name: "TaskList",
        leaf(cx, leaf) {
          return /^\[[ xX]\][ \t]/.test(leaf.content) && cx.parentType().name == "ListItem" ? new TaskParser() : null;
        },
        after: "SetextHeading"
      }]
    };
    autolinkRE = /(www\.)|(https?:\/\/)|([\w.+-]{1,100}@)|(mailto:|xmpp:)/gy;
    urlRE = /[\w-]+(\.[\w-]+)+(\/[^\s<]*)?/gy;
    lastTwoDomainWords = /[\w-]+\.[\w-]+($|\/)/;
    emailRE = /[\w.+-]+@[\w-]+(\.[\w.-]+)+/gy;
    xmppResourceRE = /\/[a-zA-Z\d@.]+/gy;
    Autolink = {
      parseInline: [{
        name: "Autolink",
        parse(cx, next, absPos) {
          let pos = absPos - cx.offset;
          if (pos && /\w/.test(cx.text[pos - 1]))
            return -1;
          autolinkRE.lastIndex = pos;
          let m = autolinkRE.exec(cx.text), end = -1;
          if (!m)
            return -1;
          if (m[1] || m[2]) {
            end = autolinkURLEnd(cx.text, pos + m[0].length);
            if (end > -1 && cx.hasOpenLink) {
              let noBracket = /([^\[\]]|\[[^\]]*\])*/.exec(cx.text.slice(pos, end));
              end = pos + noBracket[0].length;
            }
          } else if (m[3]) {
            end = autolinkEmailEnd(cx.text, pos);
          } else {
            end = autolinkEmailEnd(cx.text, pos + m[0].length);
            if (end > -1 && m[0] == "xmpp:") {
              xmppResourceRE.lastIndex = end;
              m = xmppResourceRE.exec(cx.text);
              if (m)
                end = m.index + m[0].length;
            }
          }
          if (end < 0)
            return -1;
          cx.addElement(cx.elt("URL", absPos, end + cx.offset));
          return end + cx.offset;
        }
      }]
    };
    GFM = [Table, TaskList, Strikethrough, Autolink];
    Superscript = {
      defineNodes: [
        { name: "Superscript", style: tags.special(tags.content) },
        { name: "SuperscriptMark", style: tags.processingInstruction }
      ],
      parseInline: [{
        name: "Superscript",
        parse: parseSubSuper(94, "Superscript", "SuperscriptMark")
      }]
    };
    Subscript = {
      defineNodes: [
        { name: "Subscript", style: tags.special(tags.content) },
        { name: "SubscriptMark", style: tags.processingInstruction }
      ],
      parseInline: [{
        name: "Subscript",
        parse: parseSubSuper(126, "Subscript", "SubscriptMark")
      }]
    };
    Emoji = {
      defineNodes: [{ name: "Emoji", style: tags.character }],
      parseInline: [{
        name: "Emoji",
        parse(cx, next, pos) {
          let match2;
          if (next != 58 || !(match2 = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))
            return -1;
          return cx.addElement(cx.elt("Emoji", pos, pos + 1 + match2[0].length));
        }
      }]
    };
  }
});

// node_modules/@codemirror/lang-markdown/dist/index.js
function isHeading(type) {
  let match2 = /^(?:ATX|Setext)Heading(\d)$/.exec(type.name);
  return match2 ? +match2[1] : void 0;
}
function isList(type) {
  return type.name == "OrderedList" || type.name == "BulletList";
}
function findSectionEnd(headerNode, level) {
  let last4 = headerNode;
  for (; ; ) {
    let next = last4.nextSibling, heading2;
    if (!next || (heading2 = isHeading(next.type)) != null && heading2 <= level)
      break;
    last4 = next;
  }
  return last4.to;
}
function mkLang(parser7) {
  return new Language(data, parser7, [], "markdown");
}
function getCodeParser(languages, defaultLanguage) {
  return (info) => {
    if (info && languages) {
      let found = null;
      info = /\S*/.exec(info)[0];
      if (typeof languages == "function")
        found = languages(info);
      else
        found = LanguageDescription.matchLanguageName(languages, info, true);
      if (found instanceof LanguageDescription)
        return found.support ? found.support.language.parser : ParseContext.getSkippingParser(found.load());
      else if (found)
        return found.parser;
    }
    return defaultLanguage ? defaultLanguage.parser : null;
  };
}
function getContext2(node, doc2) {
  let nodes = [], context2 = [];
  for (let cur2 = node; cur2; cur2 = cur2.parent) {
    if (cur2.name == "FencedCode")
      return context2;
    if (cur2.name == "ListItem" || cur2.name == "Blockquote")
      nodes.push(cur2);
  }
  for (let i = nodes.length - 1; i >= 0; i--) {
    let node2 = nodes[i], match2;
    let line = doc2.lineAt(node2.from), startPos = node2.from - line.from;
    if (node2.name == "Blockquote" && (match2 = /^ *>( ?)/.exec(line.text.slice(startPos)))) {
      context2.push(new Context2(node2, startPos, startPos + match2[0].length, "", match2[1], ">", null));
    } else if (node2.name == "ListItem" && node2.parent.name == "OrderedList" && (match2 = /^( *)\d+([.)])( *)/.exec(line.text.slice(startPos)))) {
      let after = match2[3], len = match2[0].length;
      if (after.length >= 4) {
        after = after.slice(0, after.length - 4);
        len -= 4;
      }
      context2.push(new Context2(node2.parent, startPos, startPos + len, match2[1], after, match2[2], node2));
    } else if (node2.name == "ListItem" && node2.parent.name == "BulletList" && (match2 = /^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(line.text.slice(startPos)))) {
      let after = match2[4], len = match2[0].length;
      if (after.length > 4) {
        after = after.slice(0, after.length - 4);
        len -= 4;
      }
      let type = match2[2];
      if (match2[3])
        type += match2[3].replace(/[xX]/, " ");
      context2.push(new Context2(node2.parent, startPos, startPos + len, match2[1], after, type, node2));
    }
  }
  return context2;
}
function itemNumber(item, doc2) {
  return /^(\s*)(\d+)(?=[.)])/.exec(doc2.sliceString(item.from, item.from + 10));
}
function renumberList(after, doc2, changes, offset = 0) {
  for (let prev = -1, node = after; ; ) {
    if (node.name == "ListItem") {
      let m = itemNumber(node, doc2);
      let number2 = +m[2];
      if (prev >= 0) {
        if (number2 != prev + 1)
          return;
        changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });
      }
      prev = number2;
    }
    let next = node.nextSibling;
    if (!next)
      break;
    node = next;
  }
}
function normalizeIndent(content2, state) {
  let blank = /^[ \t]*/.exec(content2)[0].length;
  if (!blank || state.facet(indentUnit) != "	")
    return content2;
  let col = countColumn(content2, 4, blank);
  let space5 = "";
  for (let i = col; i > 0; ) {
    if (i >= 4) {
      space5 += "	";
      i -= 4;
    } else {
      space5 += " ";
      i--;
    }
  }
  return space5 + content2.slice(blank);
}
function isMark(node) {
  return node.name == "QuoteMark" || node.name == "ListMark";
}
function nonTightList(node, doc2) {
  if (node.name != "OrderedList" && node.name != "BulletList")
    return false;
  let first2 = node.firstChild, second = node.getChild("ListItem", "ListItem");
  if (!second)
    return false;
  let line1 = doc2.lineAt(first2.to), line2 = doc2.lineAt(second.from);
  let empty2 = /^[\s>]*$/.test(line1.text);
  return line1.number + (empty2 ? 0 : 1) < line2.number;
}
function blankLine(context2, state, line) {
  let insert2 = "";
  for (let i = 0, e = context2.length - 2; i <= e; i++) {
    insert2 += context2[i].blank(i < e ? countColumn(line.text, 4, context2[i + 1].from) - insert2.length : null, i < e);
  }
  return normalizeIndent(insert2, state);
}
function contextNodeForDelete(tree2, pos) {
  let node = tree2.resolveInner(pos, -1), scan2 = pos;
  if (isMark(node)) {
    scan2 = node.from;
    node = node.parent;
  }
  for (let prev; prev = node.childBefore(scan2); ) {
    if (isMark(prev)) {
      scan2 = prev.from;
    } else if (prev.name == "OrderedList" || prev.name == "BulletList") {
      node = prev.lastChild;
      scan2 = node.to;
    } else {
      break;
    }
  }
  return node;
}
function markdown(config3 = {}) {
  let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser: parser7 } = commonmarkLanguage, completeHTMLTags = true, pasteURLAsLink: pasteURL = true, htmlTagLanguage = htmlNoMatch } = config3;
  if (!(parser7 instanceof MarkdownParser))
    throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
  let extensions = config3.extensions ? [config3.extensions] : [];
  let support = [htmlTagLanguage.support, headerIndent], defaultCode;
  if (pasteURL)
    support.push(pasteURLAsLink);
  if (defaultCodeLanguage instanceof LanguageSupport) {
    support.push(defaultCodeLanguage.support);
    defaultCode = defaultCodeLanguage.language;
  } else if (defaultCodeLanguage) {
    defaultCode = defaultCodeLanguage;
  }
  let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : void 0;
  extensions.push(parseCode({ codeParser, htmlParser: htmlTagLanguage.language.parser }));
  if (addKeymap)
    support.push(Prec.high(keymap.of(markdownKeymap)));
  let lang = mkLang(parser7.configure(extensions));
  if (completeHTMLTags)
    support.push(lang.data.of({ autocomplete: htmlTagCompletion }));
  return new LanguageSupport(lang, support);
}
function htmlTagCompletion(context2) {
  let { state, pos } = context2, m = /<[:\-\.\w\u00b7-\uffff]*$/.exec(state.sliceDoc(pos - 25, pos));
  if (!m)
    return null;
  let tree2 = syntaxTree(state).resolveInner(pos, -1);
  while (tree2 && !tree2.type.isTop) {
    if (tree2.name == "CodeBlock" || tree2.name == "FencedCode" || tree2.name == "ProcessingInstructionBlock" || tree2.name == "CommentBlock" || tree2.name == "Link" || tree2.name == "Image")
      return null;
    tree2 = tree2.parent;
  }
  return {
    from: pos - m[0].length,
    to: pos,
    options: htmlTagCompletions(),
    validFor: /^<[:\-\.\w\u00b7-\uffff]*$/
  };
}
function htmlTagCompletions() {
  if (_tagCompletions)
    return _tagCompletions;
  let result = htmlCompletionSource(new CompletionContext(EditorState.create({ extensions: htmlNoMatch }), 0, true));
  return _tagCompletions = result ? result.options : [];
}
var data, headingProp, commonmark, headerIndent, commonmarkLanguage, extended, markdownLanguage, Context2, insertNewlineContinueMarkupCommand, insertNewlineContinueMarkup, deleteMarkupBackward, markdownKeymap, htmlNoMatch, _tagCompletions, nonPlainText, pasteURLAsLink;
var init_dist19 = __esm({
  "node_modules/@codemirror/lang-markdown/dist/index.js"() {
    "use strict";
    init_dist();
    init_dist2();
    init_dist7();
    init_dist8();
    init_dist18();
    init_dist15();
    init_dist3();
    data = /* @__PURE__ */ defineLanguageFacet({ commentTokens: { block: { open: "<!--", close: "-->" } } });
    headingProp = /* @__PURE__ */ new NodeProp();
    commonmark = /* @__PURE__ */ parser6.configure({
      props: [
        /* @__PURE__ */ foldNodeProp.add((type) => {
          return !type.is("Block") || type.is("Document") || isHeading(type) != null || isList(type) ? void 0 : (tree2, state) => ({ from: state.doc.lineAt(tree2.from).to, to: tree2.to });
        }),
        /* @__PURE__ */ headingProp.add(isHeading),
        /* @__PURE__ */ indentNodeProp.add({
          Document: () => null
        }),
        /* @__PURE__ */ languageDataProp.add({
          Document: data
        })
      ]
    });
    headerIndent = /* @__PURE__ */ foldService.of((state, start, end) => {
      for (let node = syntaxTree(state).resolveInner(end, -1); node; node = node.parent) {
        if (node.from < start)
          break;
        let heading2 = node.type.prop(headingProp);
        if (heading2 == null)
          continue;
        let upto = findSectionEnd(node, heading2);
        if (upto > end)
          return { from: end, to: upto };
      }
      return null;
    });
    commonmarkLanguage = /* @__PURE__ */ mkLang(commonmark);
    extended = /* @__PURE__ */ commonmark.configure([GFM, Subscript, Superscript, Emoji, {
      props: [
        /* @__PURE__ */ foldNodeProp.add({
          Table: (tree2, state) => ({ from: state.doc.lineAt(tree2.from).to, to: tree2.to })
        })
      ]
    }]);
    markdownLanguage = /* @__PURE__ */ mkLang(extended);
    Context2 = class {
      constructor(node, from2, to, spaceBefore, spaceAfter, type, item) {
        this.node = node;
        this.from = from2;
        this.to = to;
        this.spaceBefore = spaceBefore;
        this.spaceAfter = spaceAfter;
        this.type = type;
        this.item = item;
      }
      blank(maxWidth, trailing = true) {
        let result = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
        if (maxWidth != null) {
          while (result.length < maxWidth)
            result += " ";
          return result;
        } else {
          for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)
            result += " ";
          return result + (trailing ? this.spaceAfter : "");
        }
      }
      marker(doc2, add2) {
        let number2 = this.node.name == "OrderedList" ? String(+itemNumber(this.item, doc2)[2] + add2) : "";
        return this.spaceBefore + number2 + this.type + this.spaceAfter;
      }
    };
    insertNewlineContinueMarkupCommand = (config3 = {}) => ({ state, dispatch }) => {
      let tree2 = syntaxTree(state), { doc: doc2 } = state;
      let dont = null, changes = state.changeByRange((range) => {
        if (!range.empty || !markdownLanguage.isActiveAt(state, range.from, -1) && !markdownLanguage.isActiveAt(state, range.from, 1))
          return dont = { range };
        let pos = range.from, line = doc2.lineAt(pos);
        let context2 = getContext2(tree2.resolveInner(pos, -1), doc2);
        while (context2.length && context2[context2.length - 1].from > pos - line.from)
          context2.pop();
        if (!context2.length)
          return dont = { range };
        let inner = context2[context2.length - 1];
        if (inner.to - inner.spaceAfter.length > pos - line.from)
          return dont = { range };
        let emptyLine = pos >= inner.to - inner.spaceAfter.length && !/\S/.test(line.text.slice(inner.to));
        if (inner.item && emptyLine) {
          let first2 = inner.node.firstChild, second = inner.node.getChild("ListItem", "ListItem");
          if (first2.to >= pos || second && second.to < pos || line.from > 0 && !/[^\s>]/.test(doc2.lineAt(line.from - 1).text) || config3.nonTightLists === false) {
            let next = context2.length > 1 ? context2[context2.length - 2] : null;
            let delTo, insert3 = "";
            if (next && next.item) {
              delTo = line.from + next.from;
              insert3 = next.marker(doc2, 1);
            } else {
              delTo = line.from + (next ? next.to : 0);
            }
            let changes3 = [{ from: delTo, to: pos, insert: insert3 }];
            if (inner.node.name == "OrderedList")
              renumberList(inner.item, doc2, changes3, -2);
            if (next && next.node.name == "OrderedList")
              renumberList(next.item, doc2, changes3);
            return { range: EditorSelection.cursor(delTo + insert3.length), changes: changes3 };
          } else {
            let insert3 = blankLine(context2, state, line);
            return {
              range: EditorSelection.cursor(pos + insert3.length + 1),
              changes: { from: line.from, insert: insert3 + state.lineBreak }
            };
          }
        }
        if (inner.node.name == "Blockquote" && emptyLine && line.from) {
          let prevLine = doc2.lineAt(line.from - 1), quoted = />\s*$/.exec(prevLine.text);
          if (quoted && quoted.index == inner.from) {
            let changes3 = state.changes([
              { from: prevLine.from + quoted.index, to: prevLine.to },
              { from: line.from + inner.from, to: line.to }
            ]);
            return { range: range.map(changes3), changes: changes3 };
          }
        }
        let changes2 = [];
        if (inner.node.name == "OrderedList")
          renumberList(inner.item, doc2, changes2);
        let continued = inner.item && inner.item.from < line.from;
        let insert2 = "";
        if (!continued || /^[\s\d.)\-+*>]*/.exec(line.text)[0].length >= inner.to) {
          for (let i = 0, e = context2.length - 1; i <= e; i++) {
            insert2 += i == e && !continued ? context2[i].marker(doc2, 1) : context2[i].blank(i < e ? countColumn(line.text, 4, context2[i + 1].from) - insert2.length : null);
          }
        }
        let from2 = pos;
        while (from2 > line.from && /\s/.test(line.text.charAt(from2 - line.from - 1)))
          from2--;
        insert2 = normalizeIndent(insert2, state);
        if (nonTightList(inner.node, state.doc))
          insert2 = blankLine(context2, state, line) + state.lineBreak + insert2;
        changes2.push({ from: from2, to: pos, insert: state.lineBreak + insert2 });
        return { range: EditorSelection.cursor(from2 + insert2.length + 1), changes: changes2 };
      });
      if (dont)
        return false;
      dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
      return true;
    };
    insertNewlineContinueMarkup = /* @__PURE__ */ insertNewlineContinueMarkupCommand();
    deleteMarkupBackward = ({ state, dispatch }) => {
      let tree2 = syntaxTree(state);
      let dont = null, changes = state.changeByRange((range) => {
        let pos = range.from, { doc: doc2 } = state;
        if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {
          let line = doc2.lineAt(pos);
          let context2 = getContext2(contextNodeForDelete(tree2, pos), doc2);
          if (context2.length) {
            let inner = context2[context2.length - 1];
            let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);
            if (pos - line.from > spaceEnd && !/\S/.test(line.text.slice(spaceEnd, pos - line.from)))
              return {
                range: EditorSelection.cursor(line.from + spaceEnd),
                changes: { from: line.from + spaceEnd, to: pos }
              };
            if (pos - line.from == spaceEnd && // Only apply this if we're on the line that has the
            // construct's syntax, or there's only indentation in the
            // target range
            (!inner.item || line.from <= inner.item.from || !/\S/.test(line.text.slice(0, inner.to)))) {
              let start = line.from + inner.from;
              if (inner.item && inner.node.from < inner.item.from && /\S/.test(line.text.slice(inner.from, inner.to))) {
                let insert2 = inner.blank(countColumn(line.text, 4, inner.to) - countColumn(line.text, 4, inner.from));
                if (start == line.from)
                  insert2 = normalizeIndent(insert2, state);
                return {
                  range: EditorSelection.cursor(start + insert2.length),
                  changes: { from: start, to: line.from + inner.to, insert: insert2 }
                };
              }
              if (start < pos)
                return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } };
            }
          }
        }
        return dont = { range };
      });
      if (dont)
        return false;
      dispatch(state.update(changes, { scrollIntoView: true, userEvent: "delete" }));
      return true;
    };
    markdownKeymap = [
      { key: "Enter", run: insertNewlineContinueMarkup },
      { key: "Backspace", run: deleteMarkupBackward }
    ];
    htmlNoMatch = /* @__PURE__ */ html({ matchClosingTags: false });
    _tagCompletions = null;
    nonPlainText = /code|horizontalrule|html|link|comment|processing|escape|entity|image|mark|url/i;
    pasteURLAsLink = /* @__PURE__ */ EditorView.domEventHandlers({
      paste: (event, view) => {
        var _a2;
        let { main } = view.state.selection;
        if (main.empty)
          return false;
        let link = (_a2 = event.clipboardData) === null || _a2 === void 0 ? void 0 : _a2.getData("text/plain");
        if (!link || !/^(https?:\/\/|mailto:|xmpp:|www\.)/.test(link))
          return false;
        if (/^www\./.test(link))
          link = "https://" + link;
        if (!markdownLanguage.isActiveAt(view.state, main.from, 1))
          return false;
        let tree2 = syntaxTree(view.state), crossesNode = false;
        tree2.iterate({
          from: main.from,
          to: main.to,
          enter: (node) => {
            if (node.from > main.from || nonPlainText.test(node.name))
              crossesNode = true;
          },
          leave: (node) => {
            if (node.to < main.to)
              crossesNode = true;
          }
        });
        if (crossesNode)
          return false;
        view.dispatch({
          changes: [{ from: main.from, insert: "[" }, { from: main.to, insert: `](${link})` }],
          userEvent: "input.paste",
          scrollIntoView: true
        });
        return true;
      }
    });
  }
});

// node_modules/@codemirror/theme-one-dark/dist/index.js
var chalky, coral, cyan, invalid, ivory, stone, malibu, sage, whiskey, violet, darkBackground, highlightBackground, background, tooltipBackground, selection, cursor, oneDarkTheme, oneDarkHighlightStyle, oneDark;
var init_dist20 = __esm({
  "node_modules/@codemirror/theme-one-dark/dist/index.js"() {
    "use strict";
    init_dist2();
    init_dist7();
    init_dist5();
    chalky = "#e5c07b";
    coral = "#e06c75";
    cyan = "#56b6c2";
    invalid = "#ffffff";
    ivory = "#abb2bf";
    stone = "#7d8799";
    malibu = "#61afef";
    sage = "#98c379";
    whiskey = "#d19a66";
    violet = "#c678dd";
    darkBackground = "#21252b";
    highlightBackground = "#2c313a";
    background = "#282c34";
    tooltipBackground = "#353a42";
    selection = "#3E4451";
    cursor = "#528bff";
    oneDarkTheme = /* @__PURE__ */ EditorView.theme({
      "&": {
        color: ivory,
        backgroundColor: background
      },
      ".cm-content": {
        caretColor: cursor
      },
      ".cm-cursor, .cm-dropCursor": { borderLeftColor: cursor },
      "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: selection },
      ".cm-panels": { backgroundColor: darkBackground, color: ivory },
      ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
      ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
      ".cm-searchMatch": {
        backgroundColor: "#72a1ff59",
        outline: "1px solid #457dff"
      },
      ".cm-searchMatch.cm-searchMatch-selected": {
        backgroundColor: "#6199ff2f"
      },
      ".cm-activeLine": { backgroundColor: "#6699ff0b" },
      ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
      "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
        backgroundColor: "#bad0f847"
      },
      ".cm-gutters": {
        backgroundColor: background,
        color: stone,
        border: "none"
      },
      ".cm-activeLineGutter": {
        backgroundColor: highlightBackground
      },
      ".cm-foldPlaceholder": {
        backgroundColor: "transparent",
        border: "none",
        color: "#ddd"
      },
      ".cm-tooltip": {
        border: "none",
        backgroundColor: tooltipBackground
      },
      ".cm-tooltip .cm-tooltip-arrow:before": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent"
      },
      ".cm-tooltip .cm-tooltip-arrow:after": {
        borderTopColor: tooltipBackground,
        borderBottomColor: tooltipBackground
      },
      ".cm-tooltip-autocomplete": {
        "& > ul > li[aria-selected]": {
          backgroundColor: highlightBackground,
          color: ivory
        }
      }
    }, { dark: true });
    oneDarkHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
      {
        tag: tags.keyword,
        color: violet
      },
      {
        tag: [tags.name, tags.deleted, tags.character, tags.propertyName, tags.macroName],
        color: coral
      },
      {
        tag: [/* @__PURE__ */ tags.function(tags.variableName), tags.labelName],
        color: malibu
      },
      {
        tag: [tags.color, /* @__PURE__ */ tags.constant(tags.name), /* @__PURE__ */ tags.standard(tags.name)],
        color: whiskey
      },
      {
        tag: [/* @__PURE__ */ tags.definition(tags.name), tags.separator],
        color: ivory
      },
      {
        tag: [tags.typeName, tags.className, tags.number, tags.changed, tags.annotation, tags.modifier, tags.self, tags.namespace],
        color: chalky
      },
      {
        tag: [tags.operator, tags.operatorKeyword, tags.url, tags.escape, tags.regexp, tags.link, /* @__PURE__ */ tags.special(tags.string)],
        color: cyan
      },
      {
        tag: [tags.meta, tags.comment],
        color: stone
      },
      {
        tag: tags.strong,
        fontWeight: "bold"
      },
      {
        tag: tags.emphasis,
        fontStyle: "italic"
      },
      {
        tag: tags.strikethrough,
        textDecoration: "line-through"
      },
      {
        tag: tags.link,
        color: stone,
        textDecoration: "underline"
      },
      {
        tag: tags.heading,
        fontWeight: "bold",
        color: coral
      },
      {
        tag: [tags.atom, tags.bool, /* @__PURE__ */ tags.special(tags.variableName)],
        color: whiskey
      },
      {
        tag: [tags.processingInstruction, tags.string, tags.inserted],
        color: sage
      },
      {
        tag: tags.invalid,
        color: invalid
      }
    ]);
    oneDark = [oneDarkTheme, /* @__PURE__ */ syntaxHighlighting(oneDarkHighlightStyle)];
  }
});

// node_modules/@codemirror/commands/dist/index.js
function command(f, option) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let tr = f(option, state);
    if (!tr)
      return false;
    dispatch(state.update(tr));
    return true;
  };
}
function getConfig(state, pos) {
  let data2 = state.languageDataAt("commentTokens", pos, 1);
  return data2.length ? data2[0] : {};
}
function findBlockComment(state, { open, close }, from2, to) {
  let textBefore = state.sliceDoc(from2 - SearchMargin, from2);
  let textAfter = state.sliceDoc(to, to + SearchMargin);
  let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
  let beforeOff = textBefore.length - spaceBefore;
  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
    return {
      open: { pos: from2 - spaceBefore, margin: spaceBefore && 1 },
      close: { pos: to + spaceAfter, margin: spaceAfter && 1 }
    };
  }
  let startText, endText;
  if (to - from2 <= 2 * SearchMargin) {
    startText = endText = state.sliceDoc(from2, to);
  } else {
    startText = state.sliceDoc(from2, from2 + SearchMargin);
    endText = state.sliceDoc(to - SearchMargin, to);
  }
  let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
  let endOff = endText.length - endSpace - close.length;
  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
    return {
      open: {
        pos: from2 + startSpace + open.length,
        margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
      },
      close: {
        pos: to - endSpace - close.length,
        margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
      }
    };
  }
  return null;
}
function selectedLineRanges(state) {
  let ranges = [];
  for (let r of state.selection.ranges) {
    let fromLine = state.doc.lineAt(r.from);
    let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
    if (toLine.from > fromLine.from && toLine.from == r.to)
      toLine = r.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r.to - 1);
    let last4 = ranges.length - 1;
    if (last4 >= 0 && ranges[last4].to > fromLine.from)
      ranges[last4].to = toLine.to;
    else
      ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to });
  }
  return ranges;
}
function changeBlockComment(option, state, ranges = state.selection.ranges) {
  let tokens = ranges.map((r) => getConfig(state, r.from).block);
  if (!tokens.every((c) => c))
    return null;
  let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
  if (option != 2 && !comments.every((c) => c)) {
    return { changes: state.changes(ranges.map((range, i) => {
      if (comments[i])
        return [];
      return [{ from: range.from, insert: tokens[i].open + " " }, { from: range.to, insert: " " + tokens[i].close }];
    })) };
  } else if (option != 1 && comments.some((c) => c)) {
    let changes = [];
    for (let i = 0, comment2; i < comments.length; i++)
      if (comment2 = comments[i]) {
        let token = tokens[i], { open, close } = comment2;
        changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
      }
    return { changes };
  }
  return null;
}
function changeLineComment(option, state, ranges = state.selection.ranges) {
  let lines = [];
  let prevLine = -1;
  for (let { from: from2, to } of ranges) {
    let startI = lines.length, minIndent = 1e9;
    let token = getConfig(state, from2).line;
    if (!token)
      continue;
    for (let pos = from2; pos <= to; ) {
      let line = state.doc.lineAt(pos);
      if (line.from > prevLine && (from2 == to || to > line.from)) {
        prevLine = line.from;
        let indent2 = /^\s*/.exec(line.text)[0].length;
        let empty2 = indent2 == line.length;
        let comment2 = line.text.slice(indent2, indent2 + token.length) == token ? indent2 : -1;
        if (indent2 < line.text.length && indent2 < minIndent)
          minIndent = indent2;
        lines.push({ line, comment: comment2, token, indent: indent2, empty: empty2, single: false });
      }
      pos = line.to + 1;
    }
    if (minIndent < 1e9) {
      for (let i = startI; i < lines.length; i++)
        if (lines[i].indent < lines[i].line.text.length)
          lines[i].indent = minIndent;
    }
    if (lines.length == startI + 1)
      lines[startI].single = true;
  }
  if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
    let changes = [];
    for (let { line, token, indent: indent2, empty: empty2, single } of lines)
      if (single || !empty2)
        changes.push({ from: line.from + indent2, insert: token + " " });
    let changeSet = state.changes(changes);
    return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
  } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
    let changes = [];
    for (let { line, comment: comment2, token } of lines)
      if (comment2 >= 0) {
        let from2 = line.from + comment2, to = from2 + token.length;
        if (line.text[to - line.from] == " ")
          to++;
        changes.push({ from: from2, to });
      }
    return { changes };
  }
  return null;
}
function history(config3 = {}) {
  return [
    historyField_,
    historyConfig.of(config3),
    EditorView.domEventHandlers({
      beforeinput(e, view) {
        let command2 = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
        if (!command2)
          return false;
        e.preventDefault();
        return command2(view);
      }
    })
  ];
}
function cmd(side, selection2) {
  return function({ state, dispatch }) {
    if (!selection2 && state.readOnly)
      return false;
    let historyState = state.field(historyField_, false);
    if (!historyState)
      return false;
    let tr = historyState.pop(side, state, selection2);
    if (!tr)
      return false;
    dispatch(tr);
    return true;
  };
}
function updateBranch(branch, to, maxLen, newEvent) {
  let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
  let newBranch = branch.slice(start, to);
  newBranch.push(newEvent);
  return newBranch;
}
function isAdjacent(a, b) {
  let ranges = [], isAdjacent2 = false;
  a.iterChangedRanges((f, t2) => ranges.push(f, t2));
  b.iterChangedRanges((_f, _t, f, t2) => {
    for (let i = 0; i < ranges.length; ) {
      let from2 = ranges[i++], to = ranges[i++];
      if (t2 >= from2 && f <= to)
        isAdjacent2 = true;
    }
  });
  return isAdjacent2;
}
function eqSelectionShape(a, b) {
  return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
}
function conc(a, b) {
  return !a.length ? b : !b.length ? a : a.concat(b);
}
function addSelection(branch, selection2) {
  if (!branch.length) {
    return [HistEvent.selection([selection2])];
  } else {
    let lastEvent = branch[branch.length - 1];
    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
    if (sels.length && sels[sels.length - 1].eq(selection2))
      return branch;
    sels.push(selection2);
    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
  }
}
function popSelection(branch) {
  let last4 = branch[branch.length - 1];
  let newBranch = branch.slice();
  newBranch[branch.length - 1] = last4.setSelAfter(last4.selectionsAfter.slice(0, last4.selectionsAfter.length - 1));
  return newBranch;
}
function addMappingToBranch(branch, mapping) {
  if (!branch.length)
    return branch;
  let length = branch.length, selections = none4;
  while (length) {
    let event = mapEvent(branch[length - 1], mapping, selections);
    if (event.changes && !event.changes.empty || event.effects.length) {
      let result = branch.slice(0, length);
      result[length - 1] = event;
      return result;
    } else {
      mapping = event.mapped;
      length--;
      selections = event.selectionsAfter;
    }
  }
  return selections.length ? [HistEvent.selection(selections)] : none4;
}
function mapEvent(event, mapping, extraSelections) {
  let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s) => s.map(mapping)) : none4, extraSelections);
  if (!event.changes)
    return HistEvent.selection(selections);
  let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
  let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
  return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
function updateSel(sel, by) {
  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection2) {
  return state.update({ selection: selection2, scrollIntoView: true, userEvent: "select" });
}
function moveSel({ state, dispatch }, how) {
  let selection2 = updateSel(state.selection, how);
  if (selection2.eq(state.selection, true))
    return false;
  dispatch(setSel(state, selection2));
  return true;
}
function rangeEnd(range, forward) {
  return EditorSelection.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
function ltrAtCursor(view) {
  return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
}
function cursorByGroup(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
function interestingNode(state, node, bracketProp) {
  if (node.type.prop(bracketProp))
    return true;
  let len = node.to - node.from;
  return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state, start, forward) {
  let pos = syntaxTree(state).resolveInner(start.head);
  let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
  for (let at = start.head; ; ) {
    let next = forward ? pos.childAfter(at) : pos.childBefore(at);
    if (!next)
      break;
    if (interestingNode(state, next, bracketProp))
      pos = next;
    else
      at = forward ? next.to : next.from;
  }
  let bracket2 = pos.type.prop(bracketProp), match2, newPos;
  if (bracket2 && (match2 = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match2.matched)
    newPos = forward ? match2.end.to : match2.end.from;
  else
    newPos = forward ? pos.to : pos.from;
  return EditorSelection.cursor(newPos, forward ? -1 : 1);
}
function cursorByLine(view, forward) {
  return moveSel(view, (range) => {
    if (!range.empty)
      return rangeEnd(range, forward);
    let moved = view.moveVertically(range, forward);
    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
  });
}
function pageInfo(view) {
  let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
  let marginTop = 0, marginBottom = 0, height;
  if (selfScroll) {
    for (let source of view.state.facet(EditorView.scrollMargins)) {
      let margins = source(view);
      if (margins === null || margins === void 0 ? void 0 : margins.top)
        marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
      if (margins === null || margins === void 0 ? void 0 : margins.bottom)
        marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
    }
    height = view.scrollDOM.clientHeight - marginTop - marginBottom;
  } else {
    height = (view.dom.ownerDocument.defaultView || window).innerHeight;
  }
  return {
    marginTop,
    marginBottom,
    selfScroll,
    height: Math.max(view.defaultLineHeight, height - 5)
  };
}
function cursorByPage(view, forward) {
  let page = pageInfo(view);
  let { state } = view, selection2 = updateSel(state.selection, (range) => {
    return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);
  });
  if (selection2.eq(state.selection))
    return false;
  let effect2;
  if (page.selfScroll) {
    let startPos = view.coordsAtPos(state.selection.main.head);
    let scrollRect = view.scrollDOM.getBoundingClientRect();
    let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
    if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
      effect2 = EditorView.scrollIntoView(selection2.main.head, { y: "start", yMargin: startPos.top - scrollTop });
  }
  view.dispatch(setSel(state, selection2), { effects: effect2 });
  return true;
}
function moveByLineBoundary(view, start, forward) {
  let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
  if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
    moved = view.moveToLineBoundary(start, forward, false);
  if (!forward && moved.head == line.from && line.length) {
    let space5 = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
    if (space5 && start.head != line.from + space5)
      moved = EditorSelection.cursor(line.from + space5);
  }
  return moved;
}
function toMatchingBracket(state, dispatch, extend) {
  let found = false, selection2 = updateSel(state.selection, (range) => {
    let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
    if (!matching || !matching.end)
      return range;
    found = true;
    let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
    return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
  });
  if (!found)
    return false;
  dispatch(setSel(state, selection2));
  return true;
}
function extendSel(target, how) {
  let selection2 = updateSel(target.state.selection, (range) => {
    let head = how(range);
    return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
  });
  if (selection2.eq(target.state.selection))
    return false;
  target.dispatch(setSel(target.state, selection2));
  return true;
}
function selectByChar(view, forward) {
  return extendSel(view, (range) => view.moveByChar(range, forward));
}
function selectByGroup(view, forward) {
  return extendSel(view, (range) => view.moveByGroup(range, forward));
}
function selectByLine(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward));
}
function selectByPage(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward, pageInfo(view).height));
}
function addCursorVertically(view, forward) {
  let { state } = view, sel = state.selection, ranges = state.selection.ranges.slice();
  for (let range of state.selection.ranges) {
    let line = state.doc.lineAt(range.head);
    if (forward ? line.to < view.state.doc.length : line.from > 0)
      for (let cur2 = range; ; ) {
        let next = view.moveVertically(cur2, forward);
        if (next.head < line.from || next.head > line.to) {
          if (!ranges.some((r) => r.head == next.head))
            ranges.push(next);
          break;
        } else if (next.head == cur2.head) {
          break;
        } else {
          cur2 = next;
        }
      }
  }
  if (ranges.length == sel.ranges.length)
    return false;
  view.dispatch(setSel(state, EditorSelection.create(ranges, ranges.length - 1)));
  return true;
}
function deleteBy(target, by) {
  if (target.state.readOnly)
    return false;
  let event = "delete.selection", { state } = target;
  let changes = state.changeByRange((range) => {
    let { from: from2, to } = range;
    if (from2 == to) {
      let towards = by(range);
      if (towards < from2) {
        event = "delete.backward";
        towards = skipAtomic(target, towards, false);
      } else if (towards > from2) {
        event = "delete.forward";
        towards = skipAtomic(target, towards, true);
      }
      from2 = Math.min(from2, towards);
      to = Math.max(to, towards);
    } else {
      from2 = skipAtomic(target, from2, false);
      to = skipAtomic(target, to, true);
    }
    return from2 == to ? { range } : { changes: { from: from2, to }, range: EditorSelection.cursor(from2, from2 < range.head ? -1 : 1) };
  });
  if (changes.changes.empty)
    return false;
  target.dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: event,
    effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
  }));
  return true;
}
function skipAtomic(target, pos, forward) {
  if (target instanceof EditorView)
    for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target)))
      ranges.between(pos, pos, (from2, to) => {
        if (from2 < pos && to > pos)
          pos = forward ? to : from2;
      });
  return pos;
}
function selectedLineBlocks(state) {
  let blocks = [], upto = -1;
  for (let range of state.selection.ranges) {
    let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
    if (!range.empty && range.to == endLine.from)
      endLine = state.doc.lineAt(range.to - 1);
    if (upto >= startLine.number) {
      let prev = blocks[blocks.length - 1];
      prev.to = endLine.to;
      prev.ranges.push(range);
    } else {
      blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
    }
    upto = endLine.number + 1;
  }
  return blocks;
}
function moveLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [], ranges = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward ? block.to == state.doc.length : block.from == 0)
      continue;
    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
    let size = nextLine.length + 1;
    if (forward) {
      changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
      for (let r of block.ranges)
        ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
    } else {
      changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
      for (let r of block.ranges)
        ranges.push(EditorSelection.range(r.anchor - size, r.head - size));
    }
  }
  if (!changes.length)
    return false;
  dispatch(state.update({
    changes,
    scrollIntoView: true,
    selection: EditorSelection.create(ranges, state.selection.mainIndex),
    userEvent: "move.line"
  }));
  return true;
}
function copyLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward)
      changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
    else
      changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
  }
  dispatch(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
  return true;
}
function isBetweenBrackets(state, pos) {
  if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
    return { from: pos, to: pos };
  let context2 = syntaxTree(state).resolveInner(pos);
  let before = context2.childBefore(pos), after = context2.childAfter(pos), closedBy;
  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\S/.test(state.sliceDoc(before.to, after.from)))
    return { from: before.to, to: after.from };
  return null;
}
function newlineAndIndent(atEof) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      let { from: from2, to } = range, line = state.doc.lineAt(from2);
      let explode = !atEof && from2 == to && isBetweenBrackets(state, from2);
      if (atEof)
        from2 = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
      let cx = new IndentContext(state, { simulateBreak: from2, simulateDoubleBreak: !!explode });
      let indent2 = getIndentation(cx, from2);
      if (indent2 == null)
        indent2 = countColumn(/^\s*/.exec(state.doc.lineAt(from2).text)[0], state.tabSize);
      while (to < line.to && /\s/.test(line.text[to - line.from]))
        to++;
      if (explode)
        ({ from: from2, to } = explode);
      else if (from2 > line.from && from2 < line.from + 100 && !/\S/.test(line.text.slice(0, from2)))
        from2 = line.from;
      let insert2 = ["", indentString(state, indent2)];
      if (explode)
        insert2.push(indentString(state, cx.lineIndent(line.from, -1)));
      return {
        changes: { from: from2, to, insert: Text2.of(insert2) },
        range: EditorSelection.cursor(from2 + 1 + insert2[1].length)
      };
    });
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
}
function changeBySelectedLine(state, f) {
  let atLine = -1;
  return state.changeByRange((range) => {
    let changes = [];
    for (let pos = range.from; pos <= range.to; ) {
      let line = state.doc.lineAt(pos);
      if (line.number > atLine && (range.empty || range.to > line.from)) {
        f(line, changes, range);
        atLine = line.number;
      }
      pos = line.to + 1;
    }
    let changeSet = state.changes(changes);
    return {
      changes,
      range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
    };
  });
}
var toggleComment, toggleLineComment, toggleBlockComment, toggleBlockCommentByLine, SearchMargin, fromHistory, isolateHistory, invertedEffects, historyConfig, historyField_, undo, redo, undoSelection, redoSelection, HistEvent, none4, MaxSelectionsPerEvent, joinableUserEvent, HistoryState, historyKeymap, cursorCharLeft, cursorCharRight, cursorGroupLeft, cursorGroupRight, segmenter, cursorSyntaxLeft, cursorSyntaxRight, cursorLineUp, cursorLineDown, cursorPageUp, cursorPageDown, cursorLineBoundaryForward, cursorLineBoundaryBackward, cursorLineBoundaryLeft, cursorLineBoundaryRight, cursorLineStart, cursorLineEnd, cursorMatchingBracket, selectCharLeft, selectCharRight, selectGroupLeft, selectGroupRight, selectSyntaxLeft, selectSyntaxRight, selectLineUp, selectLineDown, selectPageUp, selectPageDown, selectLineBoundaryForward, selectLineBoundaryBackward, selectLineBoundaryLeft, selectLineBoundaryRight, selectLineStart, selectLineEnd, cursorDocStart, cursorDocEnd, selectDocStart, selectDocEnd, selectAll, selectLine, selectParentSyntax, addCursorAbove, addCursorBelow, simplifySelection, deleteByChar, deleteCharBackward, deleteCharForward, deleteByGroup, deleteGroupBackward, deleteGroupForward, deleteToLineEnd, deleteLineBoundaryBackward, deleteLineBoundaryForward, splitLine, transposeChars, moveLineUp, moveLineDown, copyLineUp, copyLineDown, deleteLine, insertNewlineAndIndent, insertBlankLine, indentSelection, indentMore, indentLess, toggleTabFocusMode, emacsStyleKeymap, standardKeymap, defaultKeymap, indentWithTab;
var init_dist21 = __esm({
  "node_modules/@codemirror/commands/dist/index.js"() {
    "use strict";
    init_dist();
    init_dist2();
    init_dist7();
    init_dist3();
    toggleComment = (target) => {
      let { state } = target, line = state.doc.lineAt(state.selection.main.from), config3 = getConfig(target.state, line.from);
      return config3.line ? toggleLineComment(target) : config3.block ? toggleBlockCommentByLine(target) : false;
    };
    toggleLineComment = /* @__PURE__ */ command(
      changeLineComment,
      0
      /* CommentOption.Toggle */
    );
    toggleBlockComment = /* @__PURE__ */ command(
      changeBlockComment,
      0
      /* CommentOption.Toggle */
    );
    toggleBlockCommentByLine = /* @__PURE__ */ command(
      (o, s) => changeBlockComment(o, s, selectedLineRanges(s)),
      0
      /* CommentOption.Toggle */
    );
    SearchMargin = 50;
    fromHistory = /* @__PURE__ */ Annotation.define();
    isolateHistory = /* @__PURE__ */ Annotation.define();
    invertedEffects = /* @__PURE__ */ Facet.define();
    historyConfig = /* @__PURE__ */ Facet.define({
      combine(configs) {
        return combineConfig(configs, {
          minDepth: 100,
          newGroupDelay: 500,
          joinToEvent: (_t, isAdjacent2) => isAdjacent2
        }, {
          minDepth: Math.max,
          newGroupDelay: Math.min,
          joinToEvent: (a, b) => (tr, adj) => a(tr, adj) || b(tr, adj)
        });
      }
    });
    historyField_ = /* @__PURE__ */ StateField.define({
      create() {
        return HistoryState.empty;
      },
      update(state, tr) {
        let config3 = tr.state.facet(historyConfig);
        let fromHist = tr.annotation(fromHistory);
        if (fromHist) {
          let item = HistEvent.fromTransaction(tr, fromHist.selection), from2 = fromHist.side;
          let other = from2 == 0 ? state.undone : state.done;
          if (item)
            other = updateBranch(other, other.length, config3.minDepth, item);
          else
            other = addSelection(other, tr.startState.selection);
          return new HistoryState(from2 == 0 ? fromHist.rest : other, from2 == 0 ? other : fromHist.rest);
        }
        let isolate = tr.annotation(isolateHistory);
        if (isolate == "full" || isolate == "before")
          state = state.isolate();
        if (tr.annotation(Transaction.addToHistory) === false)
          return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
        let event = HistEvent.fromTransaction(tr);
        let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
        if (event)
          state = state.addChanges(event, time, userEvent, config3, tr);
        else if (tr.selection)
          state = state.addSelection(tr.startState.selection, time, userEvent, config3.newGroupDelay);
        if (isolate == "full" || isolate == "after")
          state = state.isolate();
        return state;
      },
      toJSON(value) {
        return { done: value.done.map((e) => e.toJSON()), undone: value.undone.map((e) => e.toJSON()) };
      },
      fromJSON(json2) {
        return new HistoryState(json2.done.map(HistEvent.fromJSON), json2.undone.map(HistEvent.fromJSON));
      }
    });
    undo = /* @__PURE__ */ cmd(0, false);
    redo = /* @__PURE__ */ cmd(1, false);
    undoSelection = /* @__PURE__ */ cmd(0, true);
    redoSelection = /* @__PURE__ */ cmd(1, true);
    HistEvent = class _HistEvent {
      constructor(changes, effects, mapped, startSelection, selectionsAfter) {
        this.changes = changes;
        this.effects = effects;
        this.mapped = mapped;
        this.startSelection = startSelection;
        this.selectionsAfter = selectionsAfter;
      }
      setSelAfter(after) {
        return new _HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
      }
      toJSON() {
        var _a2, _b, _c;
        return {
          changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
          mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
          startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
          selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
        };
      }
      static fromJSON(json2) {
        return new _HistEvent(json2.changes && ChangeSet.fromJSON(json2.changes), [], json2.mapped && ChangeDesc.fromJSON(json2.mapped), json2.startSelection && EditorSelection.fromJSON(json2.startSelection), json2.selectionsAfter.map(EditorSelection.fromJSON));
      }
      // This does not check `addToHistory` and such, it assumes the
      // transaction needs to be converted to an item. Returns null when
      // there are no changes or effects in the transaction.
      static fromTransaction(tr, selection2) {
        let effects = none4;
        for (let invert of tr.startState.facet(invertedEffects)) {
          let result = invert(tr);
          if (result.length)
            effects = effects.concat(result);
        }
        if (!effects.length && tr.changes.empty)
          return null;
        return new _HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection2 || tr.startState.selection, none4);
      }
      static selection(selections) {
        return new _HistEvent(void 0, none4, void 0, void 0, selections);
      }
    };
    none4 = [];
    MaxSelectionsPerEvent = 200;
    joinableUserEvent = /^(input\.type|delete)($|\.)/;
    HistoryState = class _HistoryState {
      constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
        this.done = done;
        this.undone = undone;
        this.prevTime = prevTime;
        this.prevUserEvent = prevUserEvent;
      }
      isolate() {
        return this.prevTime ? new _HistoryState(this.done, this.undone) : this;
      }
      addChanges(event, time, userEvent, config3, tr) {
        let done = this.done, lastEvent = done[done.length - 1];
        if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config3.newGroupDelay && config3.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event
        userEvent == "input.type.compose")) {
          done = updateBranch(done, done.length - 1, config3.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none4));
        } else {
          done = updateBranch(done, done.length, config3.minDepth, event);
        }
        return new _HistoryState(done, none4, time, userEvent);
      }
      addSelection(selection2, time, userEvent, newGroupDelay) {
        let last4 = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none4;
        if (last4.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last4[last4.length - 1], selection2))
          return this;
        return new _HistoryState(addSelection(this.done, selection2), this.undone, time, userEvent);
      }
      addMapping(mapping) {
        return new _HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
      }
      pop(side, state, onlySelection) {
        let branch = side == 0 ? this.done : this.undone;
        if (branch.length == 0)
          return null;
        let event = branch[branch.length - 1], selection2 = event.selectionsAfter[0] || state.selection;
        if (onlySelection && event.selectionsAfter.length) {
          return state.update({
            selection: event.selectionsAfter[event.selectionsAfter.length - 1],
            annotations: fromHistory.of({ side, rest: popSelection(branch), selection: selection2 }),
            userEvent: side == 0 ? "select.undo" : "select.redo",
            scrollIntoView: true
          });
        } else if (!event.changes) {
          return null;
        } else {
          let rest = branch.length == 1 ? none4 : branch.slice(0, branch.length - 1);
          if (event.mapped)
            rest = addMappingToBranch(rest, event.mapped);
          return state.update({
            changes: event.changes,
            selection: event.startSelection,
            effects: event.effects,
            annotations: fromHistory.of({ side, rest, selection: selection2 }),
            filter: false,
            userEvent: side == 0 ? "undo" : "redo",
            scrollIntoView: true
          });
        }
      }
    };
    HistoryState.empty = /* @__PURE__ */ new HistoryState(none4, none4);
    historyKeymap = [
      { key: "Mod-z", run: undo, preventDefault: true },
      { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
      { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
      { key: "Mod-u", run: undoSelection, preventDefault: true },
      { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
    ];
    cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
    cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
    cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
    cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
    segmenter = typeof Intl != "undefined" && Intl.Segmenter ? /* @__PURE__ */ new Intl.Segmenter(void 0, { granularity: "word" }) : null;
    cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
    cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
    cursorLineUp = (view) => cursorByLine(view, false);
    cursorLineDown = (view) => cursorByLine(view, true);
    cursorPageUp = (view) => cursorByPage(view, false);
    cursorPageDown = (view) => cursorByPage(view, true);
    cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
    cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
    cursorLineBoundaryLeft = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
    cursorLineBoundaryRight = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
    cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
    cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
    cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
    selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
    selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
    selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
    selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
    selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
    selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
    selectLineUp = (view) => selectByLine(view, false);
    selectLineDown = (view) => selectByLine(view, true);
    selectPageUp = (view) => selectByPage(view, false);
    selectPageDown = (view) => selectByPage(view, true);
    selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
    selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
    selectLineBoundaryLeft = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
    selectLineBoundaryRight = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
    selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
    selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
    cursorDocStart = ({ state, dispatch }) => {
      dispatch(setSel(state, { anchor: 0 }));
      return true;
    };
    cursorDocEnd = ({ state, dispatch }) => {
      dispatch(setSel(state, { anchor: state.doc.length }));
      return true;
    };
    selectDocStart = ({ state, dispatch }) => {
      dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
      return true;
    };
    selectDocEnd = ({ state, dispatch }) => {
      dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
      return true;
    };
    selectAll = ({ state, dispatch }) => {
      dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
      return true;
    };
    selectLine = ({ state, dispatch }) => {
      let ranges = selectedLineBlocks(state).map(({ from: from2, to }) => EditorSelection.range(from2, Math.min(to + 1, state.doc.length)));
      dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
      return true;
    };
    selectParentSyntax = ({ state, dispatch }) => {
      let selection2 = updateSel(state.selection, (range) => {
        let tree2 = syntaxTree(state), stack = tree2.resolveStack(range.from, 1);
        if (range.empty) {
          let stackBefore = tree2.resolveStack(range.from, -1);
          if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to)
            stack = stackBefore;
        }
        for (let cur2 = stack; cur2; cur2 = cur2.next) {
          let { node } = cur2;
          if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && cur2.next)
            return EditorSelection.range(node.to, node.from);
        }
        return range;
      });
      if (selection2.eq(state.selection))
        return false;
      dispatch(setSel(state, selection2));
      return true;
    };
    addCursorAbove = (view) => addCursorVertically(view, false);
    addCursorBelow = (view) => addCursorVertically(view, true);
    simplifySelection = ({ state, dispatch }) => {
      let cur2 = state.selection, selection2 = null;
      if (cur2.ranges.length > 1)
        selection2 = EditorSelection.create([cur2.main]);
      else if (!cur2.main.empty)
        selection2 = EditorSelection.create([EditorSelection.cursor(cur2.main.head)]);
      if (!selection2)
        return false;
      dispatch(setSel(state, selection2));
      return true;
    };
    deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, (range) => {
      let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;
      if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
        if (before[before.length - 1] == "	")
          return pos - 1;
        let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
        for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
          pos--;
        targetPos = pos;
      } else {
        targetPos = findClusterBreak2(line.text, pos - line.from, forward, forward) + line.from;
        if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
          targetPos += forward ? 1 : -1;
        else if (!forward && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from)))
          targetPos = findClusterBreak2(line.text, targetPos - line.from, false, false) + line.from;
      }
      return targetPos;
    });
    deleteCharBackward = (view) => deleteByChar(view, false, true);
    deleteCharForward = (view) => deleteByChar(view, true, false);
    deleteByGroup = (target, forward) => deleteBy(target, (range) => {
      let pos = range.head, { state } = target, line = state.doc.lineAt(pos);
      let categorize = state.charCategorizer(pos);
      for (let cat = null; ; ) {
        if (pos == (forward ? line.to : line.from)) {
          if (pos == range.head && line.number != (forward ? state.doc.lines : 1))
            pos += forward ? 1 : -1;
          break;
        }
        let next = findClusterBreak2(line.text, pos - line.from, forward) + line.from;
        let nextChar2 = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
        let nextCat = categorize(nextChar2);
        if (cat != null && nextCat != cat)
          break;
        if (nextChar2 != " " || pos != range.head)
          cat = nextCat;
        pos = next;
      }
      return pos;
    });
    deleteGroupBackward = (target) => deleteByGroup(target, false);
    deleteGroupForward = (target) => deleteByGroup(target, true);
    deleteToLineEnd = (view) => deleteBy(view, (range) => {
      let lineEnd2 = view.lineBlockAt(range.head).to;
      return range.head < lineEnd2 ? lineEnd2 : Math.min(view.state.doc.length, range.head + 1);
    });
    deleteLineBoundaryBackward = (view) => deleteBy(view, (range) => {
      let lineStart = view.moveToLineBoundary(range, false).head;
      return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
    });
    deleteLineBoundaryForward = (view) => deleteBy(view, (range) => {
      let lineStart = view.moveToLineBoundary(range, true).head;
      return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);
    });
    splitLine = ({ state, dispatch }) => {
      if (state.readOnly)
        return false;
      let changes = state.changeByRange((range) => {
        return {
          changes: { from: range.from, to: range.to, insert: Text2.of(["", ""]) },
          range: EditorSelection.cursor(range.from)
        };
      });
      dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
      return true;
    };
    transposeChars = ({ state, dispatch }) => {
      if (state.readOnly)
        return false;
      let changes = state.changeByRange((range) => {
        if (!range.empty || range.from == 0 || range.from == state.doc.length)
          return { range };
        let pos = range.from, line = state.doc.lineAt(pos);
        let from2 = pos == line.from ? pos - 1 : findClusterBreak2(line.text, pos - line.from, false) + line.from;
        let to = pos == line.to ? pos + 1 : findClusterBreak2(line.text, pos - line.from, true) + line.from;
        return {
          changes: { from: from2, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from2, pos)) },
          range: EditorSelection.cursor(to)
        };
      });
      if (changes.changes.empty)
        return false;
      dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
      return true;
    };
    moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
    moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
    copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
    copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
    deleteLine = (view) => {
      if (view.state.readOnly)
        return false;
      let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from: from2, to }) => {
        if (from2 > 0)
          from2--;
        else if (to < state.doc.length)
          to++;
        return { from: from2, to };
      }));
      let selection2 = updateSel(state.selection, (range) => {
        let dist2 = void 0;
        if (view.lineWrapping) {
          let block = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);
          if (pos)
            dist2 = block.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2;
        }
        return view.moveVertically(range, true, dist2);
      }).map(changes);
      view.dispatch({ changes, selection: selection2, scrollIntoView: true, userEvent: "delete.line" });
      return true;
    };
    insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
    insertBlankLine = /* @__PURE__ */ newlineAndIndent(true);
    indentSelection = ({ state, dispatch }) => {
      if (state.readOnly)
        return false;
      let updated = /* @__PURE__ */ Object.create(null);
      let context2 = new IndentContext(state, { overrideIndentation: (start) => {
        let found = updated[start];
        return found == null ? -1 : found;
      } });
      let changes = changeBySelectedLine(state, (line, changes2, range) => {
        let indent2 = getIndentation(context2, line.from);
        if (indent2 == null)
          return;
        if (!/\S/.test(line.text))
          indent2 = 0;
        let cur2 = /^\s*/.exec(line.text)[0];
        let norm = indentString(state, indent2);
        if (cur2 != norm || range.from < line.from + cur2.length) {
          updated[line.from] = indent2;
          changes2.push({ from: line.from, to: line.from + cur2.length, insert: norm });
        }
      });
      if (!changes.changes.empty)
        dispatch(state.update(changes, { userEvent: "indent" }));
      return true;
    };
    indentMore = ({ state, dispatch }) => {
      if (state.readOnly)
        return false;
      dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
        changes.push({ from: line.from, insert: state.facet(indentUnit) });
      }), { userEvent: "input.indent" }));
      return true;
    };
    indentLess = ({ state, dispatch }) => {
      if (state.readOnly)
        return false;
      dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
        let space5 = /^\s*/.exec(line.text)[0];
        if (!space5)
          return;
        let col = countColumn(space5, state.tabSize), keep = 0;
        let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
        while (keep < space5.length && keep < insert2.length && space5.charCodeAt(keep) == insert2.charCodeAt(keep))
          keep++;
        changes.push({ from: line.from + keep, to: line.from + space5.length, insert: insert2.slice(keep) });
      }), { userEvent: "delete.dedent" }));
      return true;
    };
    toggleTabFocusMode = (view) => {
      view.setTabFocusMode();
      return true;
    };
    emacsStyleKeymap = [
      { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
      { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
      { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
      { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
      { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
      { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
      { key: "Ctrl-d", run: deleteCharForward },
      { key: "Ctrl-h", run: deleteCharBackward },
      { key: "Ctrl-k", run: deleteToLineEnd },
      { key: "Ctrl-Alt-h", run: deleteGroupBackward },
      { key: "Ctrl-o", run: splitLine },
      { key: "Ctrl-t", run: transposeChars },
      { key: "Ctrl-v", run: cursorPageDown }
    ];
    standardKeymap = /* @__PURE__ */ [
      { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
      { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
      { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
      { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
      { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
      { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
      { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
      { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
      { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
      { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
      { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
      { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
      { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
      { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
      { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
      { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
      { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
      { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
      { key: "Enter", run: insertNewlineAndIndent, shift: insertNewlineAndIndent },
      { key: "Mod-a", run: selectAll },
      { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward, preventDefault: true },
      { key: "Delete", run: deleteCharForward, preventDefault: true },
      { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward, preventDefault: true },
      { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward, preventDefault: true },
      { mac: "Mod-Backspace", run: deleteLineBoundaryBackward, preventDefault: true },
      { mac: "Mod-Delete", run: deleteLineBoundaryForward, preventDefault: true }
    ].concat(/* @__PURE__ */ emacsStyleKeymap.map((b) => ({ mac: b.key, run: b.run, shift: b.shift })));
    defaultKeymap = /* @__PURE__ */ [
      { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
      { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
      { key: "Alt-ArrowUp", run: moveLineUp },
      { key: "Shift-Alt-ArrowUp", run: copyLineUp },
      { key: "Alt-ArrowDown", run: moveLineDown },
      { key: "Shift-Alt-ArrowDown", run: copyLineDown },
      { key: "Mod-Alt-ArrowUp", run: addCursorAbove },
      { key: "Mod-Alt-ArrowDown", run: addCursorBelow },
      { key: "Escape", run: simplifySelection },
      { key: "Mod-Enter", run: insertBlankLine },
      { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
      { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
      { key: "Mod-[", run: indentLess },
      { key: "Mod-]", run: indentMore },
      { key: "Mod-Alt-\\", run: indentSelection },
      { key: "Shift-Mod-k", run: deleteLine },
      { key: "Shift-Mod-\\", run: cursorMatchingBracket },
      { key: "Mod-/", run: toggleComment },
      { key: "Alt-A", run: toggleBlockComment },
      { key: "Ctrl-m", mac: "Shift-Alt-m", run: toggleTabFocusMode }
    ].concat(standardKeymap);
    indentWithTab = { key: "Tab", run: indentMore, shift: indentLess };
  }
});

// node_modules/@codemirror/search/dist/index.js
function validRegExp(source) {
  try {
    new RegExp(source, baseFlags);
    return true;
  } catch (_a2) {
    return false;
  }
}
function toCharEnd(text, pos) {
  if (pos >= text.length)
    return pos;
  let line = text.lineAt(pos), next;
  while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344)
    pos++;
  return pos;
}
function createLineDialog(view) {
  let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);
  let input2 = crelt("input", { class: "cm-textfield", name: "line", value: line });
  let dom = crelt("form", {
    class: "cm-gotoLine",
    onkeydown: (event) => {
      if (event.keyCode == 27) {
        event.preventDefault();
        view.dispatch({ effects: dialogEffect.of(false) });
        view.focus();
      } else if (event.keyCode == 13) {
        event.preventDefault();
        go();
      }
    },
    onsubmit: (event) => {
      event.preventDefault();
      go();
    }
  }, crelt("label", view.state.phrase("Go to line"), ": ", input2), " ", crelt("button", { class: "cm-button", type: "submit" }, view.state.phrase("go")), crelt("button", {
    name: "close",
    onclick: () => {
      view.dispatch({ effects: dialogEffect.of(false) });
      view.focus();
    },
    "aria-label": view.state.phrase("close"),
    type: "button"
  }, ["\xD7"]));
  function go() {
    let match2 = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input2.value);
    if (!match2)
      return;
    let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);
    let [, sign, ln, cl, percent2] = match2;
    let col = cl ? +cl.slice(1) : 0;
    let line2 = ln ? +ln : startLine.number;
    if (ln && percent2) {
      let pc = line2 / 100;
      if (sign)
        pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
      line2 = Math.round(state.doc.lines * pc);
    } else if (ln && sign) {
      line2 = line2 * (sign == "-" ? -1 : 1) + startLine.number;
    }
    let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line2)));
    let selection2 = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
    view.dispatch({
      effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection2.from, { y: "center" })],
      selection: selection2
    });
    view.focus();
  }
  return { dom };
}
function highlightSelectionMatches(options) {
  let ext = [defaultTheme, matchHighlighter];
  if (options)
    ext.push(highlightConfig.of(options));
  return ext;
}
function insideWordBoundaries(check, state, from2, to) {
  return (from2 == 0 || check(state.sliceDoc(from2 - 1, from2)) != CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);
}
function insideWord(check, state, from2, to) {
  return check(state.sliceDoc(from2, from2 + 1)) == CharCategory.Word && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;
}
function findNextOccurrence(state, query) {
  let { main, ranges } = state.selection;
  let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
  for (let cycled = false, cursor2 = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to); ; ) {
    cursor2.next();
    if (cursor2.done) {
      if (cycled)
        return null;
      cursor2 = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
      cycled = true;
    } else {
      if (cycled && ranges.some((r) => r.from == cursor2.value.from))
        continue;
      if (fullWord) {
        let word2 = state.wordAt(cursor2.value.from);
        if (!word2 || word2.from != cursor2.value.from || word2.to != cursor2.value.to)
          continue;
      }
      return cursor2.value;
    }
  }
}
function stringCursor(spec, state, from2, to) {
  return new SearchCursor(state.doc, spec.unquoted, from2, to, spec.caseSensitive ? void 0 : (x) => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : void 0);
}
function stringWordTest(doc2, categorizer) {
  return (from2, to, buf, bufPos) => {
    if (bufPos > from2 || bufPos + buf.length < to) {
      bufPos = Math.max(0, from2 - 2);
      buf = doc2.sliceString(bufPos, Math.min(doc2.length, to + 2));
    }
    return (categorizer(charBefore(buf, from2 - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from2 - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);
  };
}
function regexpCursor(spec, state, from2, to) {
  return new RegExpCursor(state.doc, spec.search, {
    ignoreCase: !spec.caseSensitive,
    test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : void 0
  }, from2, to);
}
function charBefore(str, index) {
  return str.slice(findClusterBreak2(str, index, false), index);
}
function charAfter(str, index) {
  return str.slice(index, findClusterBreak2(str, index));
}
function regexpWordTest(categorizer) {
  return (_from, _to, match2) => !match2[0].length || (categorizer(charBefore(match2.input, match2.index)) != CharCategory.Word || categorizer(charAfter(match2.input, match2.index)) != CharCategory.Word) && (categorizer(charAfter(match2.input, match2.index + match2[0].length)) != CharCategory.Word || categorizer(charBefore(match2.input, match2.index + match2[0].length)) != CharCategory.Word);
}
function searchCommand(f) {
  return (view) => {
    let state = view.state.field(searchState, false);
    return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
  };
}
function createSearchPanel(view) {
  return view.state.facet(searchConfigFacet).createPanel(view);
}
function defaultQuery(state, fallback) {
  var _a2, _b, _c, _d, _e;
  let sel = state.selection.main;
  let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
  if (fallback && !selText)
    return fallback;
  let config3 = state.facet(searchConfigFacet);
  return new SearchQuery({
    search: ((_a2 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a2 !== void 0 ? _a2 : config3.literal) ? selText : selText.replace(/\n/g, "\\n"),
    caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config3.caseSensitive,
    literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config3.literal,
    regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config3.regexp,
    wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config3.wholeWord
  });
}
function getSearchInput(view) {
  let panel = getPanel(view, createSearchPanel);
  return panel && panel.dom.querySelector("[main-field]");
}
function selectSearchInput(view) {
  let input2 = getSearchInput(view);
  if (input2 && input2 == view.root.activeElement)
    input2.select();
}
function phrase(view, phrase2) {
  return view.state.phrase(phrase2);
}
function announceMatch(view, { from: from2, to }) {
  let line = view.state.doc.lineAt(from2), lineEnd2 = view.state.doc.lineAt(to).to;
  let start = Math.max(line.from, from2 - AnnounceMargin), end = Math.min(lineEnd2, to + AnnounceMargin);
  let text = view.state.sliceDoc(start, end);
  if (start != line.from) {
    for (let i = 0; i < AnnounceMargin; i++)
      if (!Break.test(text[i + 1]) && Break.test(text[i])) {
        text = text.slice(i);
        break;
      }
  }
  if (end != lineEnd2) {
    for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)
      if (!Break.test(text[i - 1]) && Break.test(text[i])) {
        text = text.slice(0, i);
        break;
      }
  }
  return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line.number}.`);
}
var basicNormalize, SearchCursor, empty, baseFlags, RegExpCursor, flattened, FlattenedDoc, MultilineRegExpCursor, dialogEffect, dialogField, gotoLine, baseTheme$13, defaultHighlightOptions, highlightConfig, matchDeco, mainMatchDeco, matchHighlighter, defaultTheme, selectWord, selectNextOccurrence, searchConfigFacet, SearchQuery, QueryType2, StringQuery, RegExpQuery, setSearchQuery, togglePanel, searchState, SearchState, matchMark, selectedMatchMark, searchHighlighter, findNext, findPrevious, selectMatches, selectSelectionMatches, replaceNext, replaceAll, openSearchPanel, closeSearchPanel, searchKeymap, SearchPanel, AnnounceMargin, Break, baseTheme4, searchExtensions;
var init_dist22 = __esm({
  "node_modules/@codemirror/search/dist/index.js"() {
    "use strict";
    init_dist2();
    init_dist();
    init_crelt();
    basicNormalize = typeof String.prototype.normalize == "function" ? (x) => x.normalize("NFKD") : (x) => x;
    SearchCursor = class {
      /**
      Create a text cursor. The query is the search string, `from` to
      `to` provides the region to search.
      
      When `normalize` is given, it will be called, on both the query
      string and the content it is matched against, before comparing.
      You can, for example, create a case-insensitive search by
      passing `s => s.toLowerCase()`.
      
      Text is always normalized with
      [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
      (when supported).
      */
      constructor(text, query, from2 = 0, to = text.length, normalize, test) {
        this.test = test;
        this.value = { from: 0, to: 0 };
        this.done = false;
        this.matches = [];
        this.buffer = "";
        this.bufferPos = 0;
        this.iter = text.iterRange(from2, to);
        this.bufferStart = from2;
        this.normalize = normalize ? (x) => normalize(basicNormalize(x)) : basicNormalize;
        this.query = this.normalize(query);
      }
      peek() {
        if (this.bufferPos == this.buffer.length) {
          this.bufferStart += this.buffer.length;
          this.iter.next();
          if (this.iter.done)
            return -1;
          this.bufferPos = 0;
          this.buffer = this.iter.value;
        }
        return codePointAt2(this.buffer, this.bufferPos);
      }
      /**
      Look for the next match. Updates the iterator's
      [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
      [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
      at least once before using the cursor.
      */
      next() {
        while (this.matches.length)
          this.matches.pop();
        return this.nextOverlapping();
      }
      /**
      The `next` method will ignore matches that partially overlap a
      previous match. This method behaves like `next`, but includes
      such matches.
      */
      nextOverlapping() {
        for (; ; ) {
          let next = this.peek();
          if (next < 0) {
            this.done = true;
            return this;
          }
          let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
          this.bufferPos += codePointSize2(next);
          let norm = this.normalize(str);
          if (norm.length)
            for (let i = 0, pos = start; ; i++) {
              let code = norm.charCodeAt(i);
              let match2 = this.match(code, pos, this.bufferPos + this.bufferStart);
              if (i == norm.length - 1) {
                if (match2) {
                  this.value = match2;
                  return this;
                }
                break;
              }
              if (pos == start && i < str.length && str.charCodeAt(i) == code)
                pos++;
            }
        }
      }
      match(code, pos, end) {
        let match2 = null;
        for (let i = 0; i < this.matches.length; i += 2) {
          let index = this.matches[i], keep = false;
          if (this.query.charCodeAt(index) == code) {
            if (index == this.query.length - 1) {
              match2 = { from: this.matches[i + 1], to: end };
            } else {
              this.matches[i]++;
              keep = true;
            }
          }
          if (!keep) {
            this.matches.splice(i, 2);
            i -= 2;
          }
        }
        if (this.query.charCodeAt(0) == code) {
          if (this.query.length == 1)
            match2 = { from: pos, to: end };
          else
            this.matches.push(1, pos);
        }
        if (match2 && this.test && !this.test(match2.from, match2.to, this.buffer, this.bufferStart))
          match2 = null;
        return match2;
      }
    };
    if (typeof Symbol != "undefined")
      SearchCursor.prototype[Symbol.iterator] = function() {
        return this;
      };
    empty = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") };
    baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
    RegExpCursor = class {
      /**
      Create a cursor that will search the given range in the given
      document. `query` should be the raw pattern (as you'd pass it to
      `new RegExp`).
      */
      constructor(text, query, options, from2 = 0, to = text.length) {
        this.text = text;
        this.to = to;
        this.curLine = "";
        this.done = false;
        this.value = empty;
        if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
          return new MultilineRegExpCursor(text, query, options, from2, to);
        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
        this.test = options === null || options === void 0 ? void 0 : options.test;
        this.iter = text.iter();
        let startLine = text.lineAt(from2);
        this.curLineStart = startLine.from;
        this.matchPos = toCharEnd(text, from2);
        this.getLine(this.curLineStart);
      }
      getLine(skip) {
        this.iter.next(skip);
        if (this.iter.lineBreak) {
          this.curLine = "";
        } else {
          this.curLine = this.iter.value;
          if (this.curLineStart + this.curLine.length > this.to)
            this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
          this.iter.next();
        }
      }
      nextLine() {
        this.curLineStart = this.curLineStart + this.curLine.length + 1;
        if (this.curLineStart > this.to)
          this.curLine = "";
        else
          this.getLine(0);
      }
      /**
      Move to the next match, if there is one.
      */
      next() {
        for (let off = this.matchPos - this.curLineStart; ; ) {
          this.re.lastIndex = off;
          let match2 = this.matchPos <= this.to && this.re.exec(this.curLine);
          if (match2) {
            let from2 = this.curLineStart + match2.index, to = from2 + match2[0].length;
            this.matchPos = toCharEnd(this.text, to + (from2 == to ? 1 : 0));
            if (from2 == this.curLineStart + this.curLine.length)
              this.nextLine();
            if ((from2 < to || from2 > this.value.to) && (!this.test || this.test(from2, to, match2))) {
              this.value = { from: from2, to, match: match2 };
              return this;
            }
            off = this.matchPos - this.curLineStart;
          } else if (this.curLineStart + this.curLine.length < this.to) {
            this.nextLine();
            off = 0;
          } else {
            this.done = true;
            return this;
          }
        }
      }
    };
    flattened = /* @__PURE__ */ new WeakMap();
    FlattenedDoc = class _FlattenedDoc {
      constructor(from2, text) {
        this.from = from2;
        this.text = text;
      }
      get to() {
        return this.from + this.text.length;
      }
      static get(doc2, from2, to) {
        let cached = flattened.get(doc2);
        if (!cached || cached.from >= to || cached.to <= from2) {
          let flat = new _FlattenedDoc(from2, doc2.sliceString(from2, to));
          flattened.set(doc2, flat);
          return flat;
        }
        if (cached.from == from2 && cached.to == to)
          return cached;
        let { text, from: cachedFrom } = cached;
        if (cachedFrom > from2) {
          text = doc2.sliceString(from2, cachedFrom) + text;
          cachedFrom = from2;
        }
        if (cached.to < to)
          text += doc2.sliceString(cached.to, to);
        flattened.set(doc2, new _FlattenedDoc(cachedFrom, text));
        return new _FlattenedDoc(from2, text.slice(from2 - cachedFrom, to - cachedFrom));
      }
    };
    MultilineRegExpCursor = class {
      constructor(text, query, options, from2, to) {
        this.text = text;
        this.to = to;
        this.done = false;
        this.value = empty;
        this.matchPos = toCharEnd(text, from2);
        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
        this.test = options === null || options === void 0 ? void 0 : options.test;
        this.flat = FlattenedDoc.get(text, from2, this.chunkEnd(
          from2 + 5e3
          /* Chunk.Base */
        ));
      }
      chunkEnd(pos) {
        return pos >= this.to ? this.to : this.text.lineAt(pos).to;
      }
      next() {
        for (; ; ) {
          let off = this.re.lastIndex = this.matchPos - this.flat.from;
          let match2 = this.re.exec(this.flat.text);
          if (match2 && !match2[0] && match2.index == off) {
            this.re.lastIndex = off + 1;
            match2 = this.re.exec(this.flat.text);
          }
          if (match2) {
            let from2 = this.flat.from + match2.index, to = from2 + match2[0].length;
            if ((this.flat.to >= this.to || match2.index + match2[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from2, to, match2))) {
              this.value = { from: from2, to, match: match2 };
              this.matchPos = toCharEnd(this.text, to + (from2 == to ? 1 : 0));
              return this;
            }
          }
          if (this.flat.to == this.to) {
            this.done = true;
            return this;
          }
          this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
        }
      }
    };
    if (typeof Symbol != "undefined") {
      RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
        return this;
      };
    }
    dialogEffect = /* @__PURE__ */ StateEffect.define();
    dialogField = /* @__PURE__ */ StateField.define({
      create() {
        return true;
      },
      update(value, tr) {
        for (let e of tr.effects)
          if (e.is(dialogEffect))
            value = e.value;
        return value;
      },
      provide: (f) => showPanel.from(f, (val) => val ? createLineDialog : null)
    });
    gotoLine = (view) => {
      let panel = getPanel(view, createLineDialog);
      if (!panel) {
        let effects = [dialogEffect.of(true)];
        if (view.state.field(dialogField, false) == null)
          effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$13]));
        view.dispatch({ effects });
        panel = getPanel(view, createLineDialog);
      }
      if (panel)
        panel.dom.querySelector("input").select();
      return true;
    };
    baseTheme$13 = /* @__PURE__ */ EditorView.baseTheme({
      ".cm-panel.cm-gotoLine": {
        padding: "2px 6px 4px",
        position: "relative",
        "& label": { fontSize: "80%" },
        "& [name=close]": {
          position: "absolute",
          top: "0",
          bottom: "0",
          right: "4px",
          backgroundColor: "inherit",
          border: "none",
          font: "inherit",
          padding: "0"
        }
      }
    });
    defaultHighlightOptions = {
      highlightWordAroundCursor: false,
      minSelectionLength: 1,
      maxMatches: 100,
      wholeWords: false
    };
    highlightConfig = /* @__PURE__ */ Facet.define({
      combine(options) {
        return combineConfig(options, defaultHighlightOptions, {
          highlightWordAroundCursor: (a, b) => a || b,
          minSelectionLength: Math.min,
          maxMatches: Math.min
        });
      }
    });
    matchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch" });
    mainMatchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
    matchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
      constructor(view) {
        this.decorations = this.getDeco(view);
      }
      update(update) {
        if (update.selectionSet || update.docChanged || update.viewportChanged)
          this.decorations = this.getDeco(update.view);
      }
      getDeco(view) {
        let conf = view.state.facet(highlightConfig);
        let { state } = view, sel = state.selection;
        if (sel.ranges.length > 1)
          return Decoration.none;
        let range = sel.main, query, check = null;
        if (range.empty) {
          if (!conf.highlightWordAroundCursor)
            return Decoration.none;
          let word = state.wordAt(range.head);
          if (!word)
            return Decoration.none;
          check = state.charCategorizer(range.head);
          query = state.sliceDoc(word.from, word.to);
        } else {
          let len = range.to - range.from;
          if (len < conf.minSelectionLength || len > 200)
            return Decoration.none;
          if (conf.wholeWords) {
            query = state.sliceDoc(range.from, range.to);
            check = state.charCategorizer(range.head);
            if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to)))
              return Decoration.none;
          } else {
            query = state.sliceDoc(range.from, range.to);
            if (!query)
              return Decoration.none;
          }
        }
        let deco = [];
        for (let part of view.visibleRanges) {
          let cursor2 = new SearchCursor(state.doc, query, part.from, part.to);
          while (!cursor2.next().done) {
            let { from: from2, to } = cursor2.value;
            if (!check || insideWordBoundaries(check, state, from2, to)) {
              if (range.empty && from2 <= range.from && to >= range.to)
                deco.push(mainMatchDeco.range(from2, to));
              else if (from2 >= range.to || to <= range.from)
                deco.push(matchDeco.range(from2, to));
              if (deco.length > conf.maxMatches)
                return Decoration.none;
            }
          }
        }
        return Decoration.set(deco);
      }
    }, {
      decorations: (v) => v.decorations
    });
    defaultTheme = /* @__PURE__ */ EditorView.baseTheme({
      ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
      ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
    });
    selectWord = ({ state, dispatch }) => {
      let { selection: selection2 } = state;
      let newSel = EditorSelection.create(selection2.ranges.map((range) => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection2.mainIndex);
      if (newSel.eq(selection2))
        return false;
      dispatch(state.update({ selection: newSel }));
      return true;
    };
    selectNextOccurrence = ({ state, dispatch }) => {
      let { ranges } = state.selection;
      if (ranges.some((sel) => sel.from === sel.to))
        return selectWord({ state, dispatch });
      let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
      if (state.selection.ranges.some((r) => state.sliceDoc(r.from, r.to) != searchedText))
        return false;
      let range = findNextOccurrence(state, searchedText);
      if (!range)
        return false;
      dispatch(state.update({
        selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),
        effects: EditorView.scrollIntoView(range.to)
      }));
      return true;
    };
    searchConfigFacet = /* @__PURE__ */ Facet.define({
      combine(configs) {
        return combineConfig(configs, {
          top: false,
          caseSensitive: false,
          literal: false,
          regexp: false,
          wholeWord: false,
          createPanel: (view) => new SearchPanel(view),
          scrollToMatch: (range) => EditorView.scrollIntoView(range)
        });
      }
    });
    SearchQuery = class {
      /**
      Create a query object.
      */
      constructor(config3) {
        this.search = config3.search;
        this.caseSensitive = !!config3.caseSensitive;
        this.literal = !!config3.literal;
        this.regexp = !!config3.regexp;
        this.replace = config3.replace || "";
        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
        this.unquoted = this.unquote(this.search);
        this.wholeWord = !!config3.wholeWord;
      }
      /**
      @internal
      */
      unquote(text) {
        return this.literal ? text : text.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
      }
      /**
      Compare this query to another query.
      */
      eq(other) {
        return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
      }
      /**
      @internal
      */
      create() {
        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
      }
      /**
      Get a search cursor for this query, searching through the given
      range in the given state.
      */
      getCursor(state, from2 = 0, to) {
        let st = state.doc ? state : EditorState.create({ doc: state });
        if (to == null)
          to = st.doc.length;
        return this.regexp ? regexpCursor(this, st, from2, to) : stringCursor(this, st, from2, to);
      }
    };
    QueryType2 = class {
      constructor(spec) {
        this.spec = spec;
      }
    };
    StringQuery = class extends QueryType2 {
      constructor(spec) {
        super(spec);
      }
      nextMatch(state, curFrom, curTo) {
        let cursor2 = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
        if (cursor2.done) {
          let end = Math.min(state.doc.length, curFrom + this.spec.unquoted.length);
          cursor2 = stringCursor(this.spec, state, 0, end).nextOverlapping();
        }
        return cursor2.done || cursor2.value.from == curFrom && cursor2.value.to == curTo ? null : cursor2.value;
      }
      // Searching in reverse is, rather than implementing an inverted search
      // cursor, done by scanning chunk after chunk forward.
      prevMatchInRange(state, from2, to) {
        for (let pos = to; ; ) {
          let start = Math.max(from2, pos - 1e4 - this.spec.unquoted.length);
          let cursor2 = stringCursor(this.spec, state, start, pos), range = null;
          while (!cursor2.nextOverlapping().done)
            range = cursor2.value;
          if (range)
            return range;
          if (start == from2)
            return null;
          pos -= 1e4;
        }
      }
      prevMatch(state, curFrom, curTo) {
        let found = this.prevMatchInRange(state, 0, curFrom);
        if (!found)
          found = this.prevMatchInRange(state, Math.max(0, curTo - this.spec.unquoted.length), state.doc.length);
        return found && (found.from != curFrom || found.to != curTo) ? found : null;
      }
      getReplacement(_result) {
        return this.spec.unquote(this.spec.replace);
      }
      matchAll(state, limit) {
        let cursor2 = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
        while (!cursor2.next().done) {
          if (ranges.length >= limit)
            return null;
          ranges.push(cursor2.value);
        }
        return ranges;
      }
      highlight(state, from2, to, add2) {
        let cursor2 = stringCursor(this.spec, state, Math.max(0, from2 - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));
        while (!cursor2.next().done)
          add2(cursor2.value.from, cursor2.value.to);
      }
    };
    RegExpQuery = class extends QueryType2 {
      nextMatch(state, curFrom, curTo) {
        let cursor2 = regexpCursor(this.spec, state, curTo, state.doc.length).next();
        if (cursor2.done)
          cursor2 = regexpCursor(this.spec, state, 0, curFrom).next();
        return cursor2.done ? null : cursor2.value;
      }
      prevMatchInRange(state, from2, to) {
        for (let size = 1; ; size++) {
          let start = Math.max(
            from2,
            to - size * 1e4
            /* FindPrev.ChunkSize */
          );
          let cursor2 = regexpCursor(this.spec, state, start, to), range = null;
          while (!cursor2.next().done)
            range = cursor2.value;
          if (range && (start == from2 || range.from > start + 10))
            return range;
          if (start == from2)
            return null;
        }
      }
      prevMatch(state, curFrom, curTo) {
        return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
      }
      getReplacement(result) {
        return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (m, i) => {
          if (i == "&")
            return result.match[0];
          if (i == "$")
            return "$";
          for (let l = i.length; l > 0; l--) {
            let n = +i.slice(0, l);
            if (n > 0 && n < result.match.length)
              return result.match[n] + i.slice(l);
          }
          return m;
        });
      }
      matchAll(state, limit) {
        let cursor2 = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
        while (!cursor2.next().done) {
          if (ranges.length >= limit)
            return null;
          ranges.push(cursor2.value);
        }
        return ranges;
      }
      highlight(state, from2, to, add2) {
        let cursor2 = regexpCursor(this.spec, state, Math.max(
          0,
          from2 - 250
          /* RegExp.HighlightMargin */
        ), Math.min(to + 250, state.doc.length));
        while (!cursor2.next().done)
          add2(cursor2.value.from, cursor2.value.to);
      }
    };
    setSearchQuery = /* @__PURE__ */ StateEffect.define();
    togglePanel = /* @__PURE__ */ StateEffect.define();
    searchState = /* @__PURE__ */ StateField.define({
      create(state) {
        return new SearchState(defaultQuery(state).create(), null);
      },
      update(value, tr) {
        for (let effect2 of tr.effects) {
          if (effect2.is(setSearchQuery))
            value = new SearchState(effect2.value.create(), value.panel);
          else if (effect2.is(togglePanel))
            value = new SearchState(value.query, effect2.value ? createSearchPanel : null);
        }
        return value;
      },
      provide: (f) => showPanel.from(f, (val) => val.panel)
    });
    SearchState = class {
      constructor(query, panel) {
        this.query = query;
        this.panel = panel;
      }
    };
    matchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch" });
    selectedMatchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
    searchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.decorations = this.highlight(view.state.field(searchState));
      }
      update(update) {
        let state = update.state.field(searchState);
        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
          this.decorations = this.highlight(state);
      }
      highlight({ query, panel }) {
        if (!panel || !query.spec.valid)
          return Decoration.none;
        let { view } = this;
        let builder = new RangeSetBuilder();
        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {
          let { from: from2, to } = ranges[i];
          while (i < l - 1 && to > ranges[i + 1].from - 2 * 250)
            to = ranges[++i].to;
          query.highlight(view.state, from2, to, (from3, to2) => {
            let selected = view.state.selection.ranges.some((r) => r.from == from3 && r.to == to2);
            builder.add(from3, to2, selected ? selectedMatchMark : matchMark);
          });
        }
        return builder.finish();
      }
    }, {
      decorations: (v) => v.decorations
    });
    findNext = /* @__PURE__ */ searchCommand((view, { query }) => {
      let { to } = view.state.selection.main;
      let next = query.nextMatch(view.state, to, to);
      if (!next)
        return false;
      let selection2 = EditorSelection.single(next.from, next.to);
      let config3 = view.state.facet(searchConfigFacet);
      view.dispatch({
        selection: selection2,
        effects: [announceMatch(view, next), config3.scrollToMatch(selection2.main, view)],
        userEvent: "select.search"
      });
      selectSearchInput(view);
      return true;
    });
    findPrevious = /* @__PURE__ */ searchCommand((view, { query }) => {
      let { state } = view, { from: from2 } = state.selection.main;
      let prev = query.prevMatch(state, from2, from2);
      if (!prev)
        return false;
      let selection2 = EditorSelection.single(prev.from, prev.to);
      let config3 = view.state.facet(searchConfigFacet);
      view.dispatch({
        selection: selection2,
        effects: [announceMatch(view, prev), config3.scrollToMatch(selection2.main, view)],
        userEvent: "select.search"
      });
      selectSearchInput(view);
      return true;
    });
    selectMatches = /* @__PURE__ */ searchCommand((view, { query }) => {
      let ranges = query.matchAll(view.state, 1e3);
      if (!ranges || !ranges.length)
        return false;
      view.dispatch({
        selection: EditorSelection.create(ranges.map((r) => EditorSelection.range(r.from, r.to))),
        userEvent: "select.search.matches"
      });
      return true;
    });
    selectSelectionMatches = ({ state, dispatch }) => {
      let sel = state.selection;
      if (sel.ranges.length > 1 || sel.main.empty)
        return false;
      let { from: from2, to } = sel.main;
      let ranges = [], main = 0;
      for (let cur2 = new SearchCursor(state.doc, state.sliceDoc(from2, to)); !cur2.next().done; ) {
        if (ranges.length > 1e3)
          return false;
        if (cur2.value.from == from2)
          main = ranges.length;
        ranges.push(EditorSelection.range(cur2.value.from, cur2.value.to));
      }
      dispatch(state.update({
        selection: EditorSelection.create(ranges, main),
        userEvent: "select.search.matches"
      }));
      return true;
    };
    replaceNext = /* @__PURE__ */ searchCommand((view, { query }) => {
      let { state } = view, { from: from2, to } = state.selection.main;
      if (state.readOnly)
        return false;
      let match2 = query.nextMatch(state, from2, from2);
      if (!match2)
        return false;
      let next = match2;
      let changes = [], selection2, replacement;
      let effects = [];
      if (next.from == from2 && next.to == to) {
        replacement = state.toText(query.getReplacement(next));
        changes.push({ from: next.from, to: next.to, insert: replacement });
        next = query.nextMatch(state, next.from, next.to);
        effects.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from2).number) + "."));
      }
      let changeSet = view.state.changes(changes);
      if (next) {
        selection2 = EditorSelection.single(next.from, next.to).map(changeSet);
        effects.push(announceMatch(view, next));
        effects.push(state.facet(searchConfigFacet).scrollToMatch(selection2.main, view));
      }
      view.dispatch({
        changes: changeSet,
        selection: selection2,
        effects,
        userEvent: "input.replace"
      });
      return true;
    });
    replaceAll = /* @__PURE__ */ searchCommand((view, { query }) => {
      if (view.state.readOnly)
        return false;
      let changes = query.matchAll(view.state, 1e9).map((match2) => {
        let { from: from2, to } = match2;
        return { from: from2, to, insert: query.getReplacement(match2) };
      });
      if (!changes.length)
        return false;
      let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
      view.dispatch({
        changes,
        effects: EditorView.announce.of(announceText),
        userEvent: "input.replace.all"
      });
      return true;
    });
    openSearchPanel = (view) => {
      let state = view.state.field(searchState, false);
      if (state && state.panel) {
        let searchInput = getSearchInput(view);
        if (searchInput && searchInput != view.root.activeElement) {
          let query = defaultQuery(view.state, state.query.spec);
          if (query.valid)
            view.dispatch({ effects: setSearchQuery.of(query) });
          searchInput.focus();
          searchInput.select();
        }
      } else {
        view.dispatch({ effects: [
          togglePanel.of(true),
          state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
        ] });
      }
      return true;
    };
    closeSearchPanel = (view) => {
      let state = view.state.field(searchState, false);
      if (!state || !state.panel)
        return false;
      let panel = getPanel(view, createSearchPanel);
      if (panel && panel.dom.contains(view.root.activeElement))
        view.focus();
      view.dispatch({ effects: togglePanel.of(false) });
      return true;
    };
    searchKeymap = [
      { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
      { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
      { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
      { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
      { key: "Mod-Shift-l", run: selectSelectionMatches },
      { key: "Mod-Alt-g", run: gotoLine },
      { key: "Mod-d", run: selectNextOccurrence, preventDefault: true }
    ];
    SearchPanel = class {
      constructor(view) {
        this.view = view;
        let query = this.query = view.state.field(searchState).query.spec;
        this.commit = this.commit.bind(this);
        this.searchField = crelt("input", {
          value: query.search,
          placeholder: phrase(view, "Find"),
          "aria-label": phrase(view, "Find"),
          class: "cm-textfield",
          name: "search",
          form: "",
          "main-field": "true",
          onchange: this.commit,
          onkeyup: this.commit
        });
        this.replaceField = crelt("input", {
          value: query.replace,
          placeholder: phrase(view, "Replace"),
          "aria-label": phrase(view, "Replace"),
          class: "cm-textfield",
          name: "replace",
          form: "",
          onchange: this.commit,
          onkeyup: this.commit
        });
        this.caseField = crelt("input", {
          type: "checkbox",
          name: "case",
          form: "",
          checked: query.caseSensitive,
          onchange: this.commit
        });
        this.reField = crelt("input", {
          type: "checkbox",
          name: "re",
          form: "",
          checked: query.regexp,
          onchange: this.commit
        });
        this.wordField = crelt("input", {
          type: "checkbox",
          name: "word",
          form: "",
          checked: query.wholeWord,
          onchange: this.commit
        });
        function button(name2, onclick, content2) {
          return crelt("button", { class: "cm-button", name: name2, onclick, type: "button" }, content2);
        }
        this.dom = crelt("div", { onkeydown: (e) => this.keydown(e), class: "cm-search" }, [
          this.searchField,
          button("next", () => findNext(view), [phrase(view, "next")]),
          button("prev", () => findPrevious(view), [phrase(view, "previous")]),
          button("select", () => selectMatches(view), [phrase(view, "all")]),
          crelt("label", null, [this.caseField, phrase(view, "match case")]),
          crelt("label", null, [this.reField, phrase(view, "regexp")]),
          crelt("label", null, [this.wordField, phrase(view, "by word")]),
          ...view.state.readOnly ? [] : [
            crelt("br"),
            this.replaceField,
            button("replace", () => replaceNext(view), [phrase(view, "replace")]),
            button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])
          ],
          crelt("button", {
            name: "close",
            onclick: () => closeSearchPanel(view),
            "aria-label": phrase(view, "close"),
            type: "button"
          }, ["\xD7"])
        ]);
      }
      commit() {
        let query = new SearchQuery({
          search: this.searchField.value,
          caseSensitive: this.caseField.checked,
          regexp: this.reField.checked,
          wholeWord: this.wordField.checked,
          replace: this.replaceField.value
        });
        if (!query.eq(this.query)) {
          this.query = query;
          this.view.dispatch({ effects: setSearchQuery.of(query) });
        }
      }
      keydown(e) {
        if (runScopeHandlers(this.view, e, "search-panel")) {
          e.preventDefault();
        } else if (e.keyCode == 13 && e.target == this.searchField) {
          e.preventDefault();
          (e.shiftKey ? findPrevious : findNext)(this.view);
        } else if (e.keyCode == 13 && e.target == this.replaceField) {
          e.preventDefault();
          replaceNext(this.view);
        }
      }
      update(update) {
        for (let tr of update.transactions)
          for (let effect2 of tr.effects) {
            if (effect2.is(setSearchQuery) && !effect2.value.eq(this.query))
              this.setQuery(effect2.value);
          }
      }
      setQuery(query) {
        this.query = query;
        this.searchField.value = query.search;
        this.replaceField.value = query.replace;
        this.caseField.checked = query.caseSensitive;
        this.reField.checked = query.regexp;
        this.wordField.checked = query.wholeWord;
      }
      mount() {
        this.searchField.select();
      }
      get pos() {
        return 80;
      }
      get top() {
        return this.view.state.facet(searchConfigFacet).top;
      }
    };
    AnnounceMargin = 30;
    Break = /[\s\.,:;?!]/;
    baseTheme4 = /* @__PURE__ */ EditorView.baseTheme({
      ".cm-panel.cm-search": {
        padding: "2px 6px 4px",
        position: "relative",
        "& [name=close]": {
          position: "absolute",
          top: "0",
          right: "4px",
          backgroundColor: "inherit",
          border: "none",
          font: "inherit",
          padding: 0,
          margin: 0
        },
        "& input, & button, & label": {
          margin: ".2em .6em .2em 0"
        },
        "& input[type=checkbox]": {
          marginRight: ".2em"
        },
        "& label": {
          fontSize: "80%",
          whiteSpace: "pre"
        }
      },
      "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
      "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
      "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
      "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
    });
    searchExtensions = [
      searchState,
      /* @__PURE__ */ Prec.low(searchHighlighter),
      baseTheme4
    ];
  }
});

// node_modules/@codemirror/lint/dist/index.js
function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
  let found = null;
  diagnostics.between(after, 1e9, (from2, to, { spec }) => {
    if (diagnostic && spec.diagnostics.indexOf(diagnostic) < 0)
      return;
    if (!found)
      found = new SelectedDiagnostic(from2, to, diagnostic || spec.diagnostics[0]);
    else if (spec.diagnostics.indexOf(found.diagnostic) < 0)
      return false;
    else
      found = new SelectedDiagnostic(found.from, to, found.diagnostic);
  });
  return found;
}
function hideTooltip(tr, tooltip) {
  let from2 = tooltip.pos, to = tooltip.end || from2;
  let result = tr.state.facet(lintConfig).hideOn(tr, from2, to);
  if (result != null)
    return result;
  let line = tr.startState.doc.lineAt(tooltip.pos);
  return !!(tr.effects.some((e) => e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, Math.max(line.to, to)));
}
function maybeEnableLint(state, effects) {
  return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of(lintExtensions));
}
function lintTooltip(view, pos, side) {
  let { diagnostics } = view.state.field(lintState);
  let found, start = -1, end = -1;
  diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from2, to, { spec }) => {
    if (pos >= from2 && pos <= to && (from2 == to || (pos > from2 || side > 0) && (pos < to || side < 0))) {
      found = spec.diagnostics;
      start = from2;
      end = to;
      return false;
    }
  });
  let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
  if (found && diagnosticFilter)
    found = diagnosticFilter(found, view.state);
  if (!found)
    return null;
  return {
    pos: start,
    end,
    above: view.state.doc.lineAt(start).to < end,
    create() {
      return { dom: diagnosticsTooltip(view, found) };
    }
  };
}
function diagnosticsTooltip(view, diagnostics) {
  return crelt("ul", { class: "cm-tooltip-lint" }, diagnostics.map((d) => renderDiagnostic(view, d, false)));
}
function combineFilter(a, b) {
  return !a ? b : !b ? a : (d, s) => b(a(d, s), s);
}
function assignKeys(actions) {
  let assigned = [];
  if (actions)
    actions: for (let { name: name2 } of actions) {
      for (let i = 0; i < name2.length; i++) {
        let ch = name2[i];
        if (/[a-zA-Z]/.test(ch) && !assigned.some((c) => c.toLowerCase() == ch.toLowerCase())) {
          assigned.push(ch);
          continue actions;
        }
      }
      assigned.push("");
    }
  return assigned;
}
function renderDiagnostic(view, diagnostic, inPanel) {
  var _a2;
  let keys2 = inPanel ? assignKeys(diagnostic.actions) : [];
  return crelt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, crelt("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage(view) : diagnostic.message), (_a2 = diagnostic.actions) === null || _a2 === void 0 ? void 0 : _a2.map((action, i) => {
    let fired = false, click = (e) => {
      e.preventDefault();
      if (fired)
        return;
      fired = true;
      let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
      if (found)
        action.apply(view, found.from, found.to);
    };
    let { name: name2 } = action, keyIndex = keys2[i] ? name2.indexOf(keys2[i]) : -1;
    let nameElt = keyIndex < 0 ? name2 : [
      name2.slice(0, keyIndex),
      crelt("u", name2.slice(keyIndex, keyIndex + 1)),
      name2.slice(keyIndex + 1)
    ];
    let markClass = action.markClass ? " " + action.markClass : "";
    return crelt("button", {
      type: "button",
      class: "cm-diagnosticAction" + markClass,
      onclick: click,
      onmousedown: click,
      "aria-label": ` Action: ${name2}${keyIndex < 0 ? "" : ` (access key "${keys2[i]})"`}.`
    }, nameElt);
  }), diagnostic.source && crelt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
}
function svg(content2, attrs = `viewBox="0 0 40 40"`) {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content2)}</svg>')`;
}
function underline(color) {
  return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
}
function severityWeight(sev) {
  return sev == "error" ? 4 : sev == "warning" ? 3 : sev == "info" ? 2 : 1;
}
function maxSeverity(diagnostics) {
  let sev = "hint", weight = 1;
  for (let d of diagnostics) {
    let w = severityWeight(d.severity);
    if (w > weight) {
      weight = w;
      sev = d.severity;
    }
  }
  return sev;
}
var SelectedDiagnostic, LintState, setDiagnosticsEffect, togglePanel2, movePanelSelection, lintState, activeMark, openLintPanel, closeLintPanel, nextDiagnostic, lintKeymap, lintConfig, DiagnosticWidget, PanelItem, LintPanel, baseTheme5, lintExtensions;
var init_dist23 = __esm({
  "node_modules/@codemirror/lint/dist/index.js"() {
    "use strict";
    init_dist2();
    init_dist();
    init_crelt();
    SelectedDiagnostic = class {
      constructor(from2, to, diagnostic) {
        this.from = from2;
        this.to = to;
        this.diagnostic = diagnostic;
      }
    };
    LintState = class _LintState {
      constructor(diagnostics, panel, selected) {
        this.diagnostics = diagnostics;
        this.panel = panel;
        this.selected = selected;
      }
      static init(diagnostics, panel, state) {
        let diagnosticFilter = state.facet(lintConfig).markerFilter;
        if (diagnosticFilter)
          diagnostics = diagnosticFilter(diagnostics, state);
        let sorted = diagnostics.slice().sort((a, b) => a.from - b.from || a.to - b.to);
        let deco = new RangeSetBuilder(), active = [], pos = 0;
        let scan2 = state.doc.iter(), scanPos = 0;
        for (let i = 0; ; ) {
          let next = i == sorted.length ? null : sorted[i];
          if (!next && !active.length)
            break;
          let from2, to;
          if (active.length) {
            from2 = pos;
            to = active.reduce((p, d) => Math.min(p, d.to), next && next.from > from2 ? next.from : 1e8);
          } else {
            from2 = next.from;
            to = next.to;
            active.push(next);
            i++;
          }
          while (i < sorted.length) {
            let next2 = sorted[i];
            if (next2.from == from2 && (next2.to > next2.from || next2.to == from2)) {
              active.push(next2);
              i++;
              to = Math.min(next2.to, to);
            } else {
              to = Math.min(next2.from, to);
              break;
            }
          }
          let widget = false;
          if (active.some((d) => d.from == from2 && d.to == to)) {
            widget = from2 == to;
            if (!widget && to - from2 < 10) {
              let behind = from2 - (scanPos + scan2.value.length);
              if (behind > 0) {
                scan2.next(behind);
                scanPos = from2;
              }
              for (let check = from2; ; ) {
                if (check >= to) {
                  widget = true;
                  break;
                }
                if (!scan2.lineBreak && scanPos + scan2.value.length > check)
                  break;
                check = scanPos + scan2.value.length;
                scanPos += scan2.value.length;
                scan2.next();
              }
            }
          }
          let sev = maxSeverity(active);
          if (widget) {
            deco.add(from2, from2, Decoration.widget({
              widget: new DiagnosticWidget(sev),
              diagnostics: active.slice()
            }));
          } else {
            let markClass = active.reduce((c, d) => d.markClass ? c + " " + d.markClass : c, "");
            deco.add(from2, to, Decoration.mark({
              class: "cm-lintRange cm-lintRange-" + sev + markClass,
              diagnostics: active.slice(),
              inclusiveEnd: active.some((a) => a.to > to)
            }));
          }
          pos = to;
          for (let i2 = 0; i2 < active.length; i2++)
            if (active[i2].to <= pos)
              active.splice(i2--, 1);
        }
        let set = deco.finish();
        return new _LintState(set, panel, findDiagnostic(set));
      }
    };
    setDiagnosticsEffect = /* @__PURE__ */ StateEffect.define();
    togglePanel2 = /* @__PURE__ */ StateEffect.define();
    movePanelSelection = /* @__PURE__ */ StateEffect.define();
    lintState = /* @__PURE__ */ StateField.define({
      create() {
        return new LintState(Decoration.none, null, null);
      },
      update(value, tr) {
        if (tr.docChanged && value.diagnostics.size) {
          let mapped = value.diagnostics.map(tr.changes), selected = null, panel = value.panel;
          if (value.selected) {
            let selPos = tr.changes.mapPos(value.selected.from, 1);
            selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
          }
          if (!mapped.size && panel && tr.state.facet(lintConfig).autoPanel)
            panel = null;
          value = new LintState(mapped, panel, selected);
        }
        for (let effect2 of tr.effects) {
          if (effect2.is(setDiagnosticsEffect)) {
            let panel = !tr.state.facet(lintConfig).autoPanel ? value.panel : effect2.value.length ? LintPanel.open : null;
            value = LintState.init(effect2.value, panel, tr.state);
          } else if (effect2.is(togglePanel2)) {
            value = new LintState(value.diagnostics, effect2.value ? LintPanel.open : null, value.selected);
          } else if (effect2.is(movePanelSelection)) {
            value = new LintState(value.diagnostics, value.panel, effect2.value);
          }
        }
        return value;
      },
      provide: (f) => [
        showPanel.from(f, (val) => val.panel),
        EditorView.decorations.from(f, (s) => s.diagnostics)
      ]
    });
    activeMark = /* @__PURE__ */ Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
    openLintPanel = (view) => {
      let field = view.state.field(lintState, false);
      if (!field || !field.panel)
        view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel2.of(true)]) });
      let panel = getPanel(view, LintPanel.open);
      if (panel)
        panel.dom.querySelector(".cm-panel-lint ul").focus();
      return true;
    };
    closeLintPanel = (view) => {
      let field = view.state.field(lintState, false);
      if (!field || !field.panel)
        return false;
      view.dispatch({ effects: togglePanel2.of(false) });
      return true;
    };
    nextDiagnostic = (view) => {
      let field = view.state.field(lintState, false);
      if (!field)
        return false;
      let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
      if (!next.value) {
        next = field.diagnostics.iter(0);
        if (!next.value || next.from == sel.from && next.to == sel.to)
          return false;
      }
      view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });
      return true;
    };
    lintKeymap = [
      { key: "Mod-Shift-m", run: openLintPanel, preventDefault: true },
      { key: "F8", run: nextDiagnostic }
    ];
    lintConfig = /* @__PURE__ */ Facet.define({
      combine(input2) {
        return __spreadValues({
          sources: input2.map((i) => i.source).filter((x) => x != null)
        }, combineConfig(input2.map((i) => i.config), {
          delay: 750,
          markerFilter: null,
          tooltipFilter: null,
          needsRefresh: null,
          hideOn: () => null
        }, {
          delay: Math.max,
          markerFilter: combineFilter,
          tooltipFilter: combineFilter,
          needsRefresh: (a, b) => !a ? b : !b ? a : (u2) => a(u2) || b(u2),
          hideOn: (a, b) => !a ? b : !b ? a : (t2, x, y) => a(t2, x, y) || b(t2, x, y),
          autoPanel: (a, b) => a || b
        }));
      }
    });
    DiagnosticWidget = class extends WidgetType {
      constructor(sev) {
        super();
        this.sev = sev;
      }
      eq(other) {
        return other.sev == this.sev;
      }
      toDOM() {
        return crelt("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
      }
    };
    PanelItem = class {
      constructor(view, diagnostic) {
        this.diagnostic = diagnostic;
        this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
        this.dom = renderDiagnostic(view, diagnostic, true);
        this.dom.id = this.id;
        this.dom.setAttribute("role", "option");
      }
    };
    LintPanel = class _LintPanel {
      constructor(view) {
        this.view = view;
        this.items = [];
        let onkeydown = (event) => {
          if (event.keyCode == 27) {
            closeLintPanel(this.view);
            this.view.focus();
          } else if (event.keyCode == 38 || event.keyCode == 33) {
            this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
          } else if (event.keyCode == 40 || event.keyCode == 34) {
            this.moveSelection((this.selectedIndex + 1) % this.items.length);
          } else if (event.keyCode == 36) {
            this.moveSelection(0);
          } else if (event.keyCode == 35) {
            this.moveSelection(this.items.length - 1);
          } else if (event.keyCode == 13) {
            this.view.focus();
          } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
            let { diagnostic } = this.items[this.selectedIndex], keys2 = assignKeys(diagnostic.actions);
            for (let i = 0; i < keys2.length; i++)
              if (keys2[i].toUpperCase().charCodeAt(0) == event.keyCode) {
                let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
                if (found)
                  diagnostic.actions[i].apply(view, found.from, found.to);
              }
          } else {
            return;
          }
          event.preventDefault();
        };
        let onclick = (event) => {
          for (let i = 0; i < this.items.length; i++) {
            if (this.items[i].dom.contains(event.target))
              this.moveSelection(i);
          }
        };
        this.list = crelt("ul", {
          tabIndex: 0,
          role: "listbox",
          "aria-label": this.view.state.phrase("Diagnostics"),
          onkeydown,
          onclick
        });
        this.dom = crelt("div", { class: "cm-panel-lint" }, this.list, crelt("button", {
          type: "button",
          name: "close",
          "aria-label": this.view.state.phrase("close"),
          onclick: () => closeLintPanel(this.view)
        }, "\xD7"));
        this.update();
      }
      get selectedIndex() {
        let selected = this.view.state.field(lintState).selected;
        if (!selected)
          return -1;
        for (let i = 0; i < this.items.length; i++)
          if (this.items[i].diagnostic == selected.diagnostic)
            return i;
        return -1;
      }
      update() {
        let { diagnostics, selected } = this.view.state.field(lintState);
        let i = 0, needsSync = false, newSelectedItem = null;
        let seen = /* @__PURE__ */ new Set();
        diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
          for (let diagnostic of spec.diagnostics) {
            if (seen.has(diagnostic))
              continue;
            seen.add(diagnostic);
            let found = -1, item;
            for (let j = i; j < this.items.length; j++)
              if (this.items[j].diagnostic == diagnostic) {
                found = j;
                break;
              }
            if (found < 0) {
              item = new PanelItem(this.view, diagnostic);
              this.items.splice(i, 0, item);
              needsSync = true;
            } else {
              item = this.items[found];
              if (found > i) {
                this.items.splice(i, found - i);
                needsSync = true;
              }
            }
            if (selected && item.diagnostic == selected.diagnostic) {
              if (!item.dom.hasAttribute("aria-selected")) {
                item.dom.setAttribute("aria-selected", "true");
                newSelectedItem = item;
              }
            } else if (item.dom.hasAttribute("aria-selected")) {
              item.dom.removeAttribute("aria-selected");
            }
            i++;
          }
        });
        while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
          needsSync = true;
          this.items.pop();
        }
        if (this.items.length == 0) {
          this.items.push(new PanelItem(this.view, {
            from: -1,
            to: -1,
            severity: "info",
            message: this.view.state.phrase("No diagnostics")
          }));
          needsSync = true;
        }
        if (newSelectedItem) {
          this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
          this.view.requestMeasure({
            key: this,
            read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
            write: ({ sel, panel }) => {
              let scaleY = panel.height / this.list.offsetHeight;
              if (sel.top < panel.top)
                this.list.scrollTop -= (panel.top - sel.top) / scaleY;
              else if (sel.bottom > panel.bottom)
                this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;
            }
          });
        } else if (this.selectedIndex < 0) {
          this.list.removeAttribute("aria-activedescendant");
        }
        if (needsSync)
          this.sync();
      }
      sync() {
        let domPos = this.list.firstChild;
        function rm2() {
          let prev = domPos;
          domPos = prev.nextSibling;
          prev.remove();
        }
        for (let item of this.items) {
          if (item.dom.parentNode == this.list) {
            while (domPos != item.dom)
              rm2();
            domPos = item.dom.nextSibling;
          } else {
            this.list.insertBefore(item.dom, domPos);
          }
        }
        while (domPos)
          rm2();
      }
      moveSelection(selectedIndex) {
        if (this.selectedIndex < 0)
          return;
        let field = this.view.state.field(lintState);
        let selection2 = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
        if (!selection2)
          return;
        this.view.dispatch({
          selection: { anchor: selection2.from, head: selection2.to },
          scrollIntoView: true,
          effects: movePanelSelection.of(selection2)
        });
      }
      static open(view) {
        return new _LintPanel(view);
      }
    };
    baseTheme5 = /* @__PURE__ */ EditorView.baseTheme({
      ".cm-diagnostic": {
        padding: "3px 6px 3px 8px",
        marginLeft: "-1px",
        display: "block",
        whiteSpace: "pre-wrap"
      },
      ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
      ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
      ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
      ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
      ".cm-diagnosticAction": {
        font: "inherit",
        border: "none",
        padding: "2px 4px",
        backgroundColor: "#444",
        color: "white",
        borderRadius: "3px",
        marginLeft: "8px",
        cursor: "pointer"
      },
      ".cm-diagnosticSource": {
        fontSize: "70%",
        opacity: 0.7
      },
      ".cm-lintRange": {
        backgroundPosition: "left bottom",
        backgroundRepeat: "repeat-x",
        paddingBottom: "0.7px"
      },
      ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ underline("#d11") },
      ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ underline("orange") },
      ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ underline("#999") },
      ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ underline("#66d") },
      ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
      ".cm-tooltip-lint": {
        padding: 0,
        margin: 0
      },
      ".cm-lintPoint": {
        position: "relative",
        "&:after": {
          content: '""',
          position: "absolute",
          bottom: 0,
          left: "-2px",
          borderLeft: "3px solid transparent",
          borderRight: "3px solid transparent",
          borderBottom: "4px solid #d11"
        }
      },
      ".cm-lintPoint-warning": {
        "&:after": { borderBottomColor: "orange" }
      },
      ".cm-lintPoint-info": {
        "&:after": { borderBottomColor: "#999" }
      },
      ".cm-lintPoint-hint": {
        "&:after": { borderBottomColor: "#66d" }
      },
      ".cm-panel.cm-panel-lint": {
        position: "relative",
        "& ul": {
          maxHeight: "100px",
          overflowY: "auto",
          "& [aria-selected]": {
            backgroundColor: "#ddd",
            "& u": { textDecoration: "underline" }
          },
          "&:focus [aria-selected]": {
            background_fallback: "#bdf",
            backgroundColor: "Highlight",
            color_fallback: "white",
            color: "HighlightText"
          },
          "& u": { textDecoration: "none" },
          padding: 0,
          margin: 0
        },
        "& [name=close]": {
          position: "absolute",
          top: "0",
          right: "2px",
          background: "inherit",
          border: "none",
          font: "inherit",
          padding: 0,
          margin: 0
        }
      }
    });
    lintExtensions = [
      lintState,
      /* @__PURE__ */ EditorView.decorations.compute([lintState], (state) => {
        let { selected, panel } = state.field(lintState);
        return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
          activeMark.range(selected.from, selected.to)
        ]);
      }),
      /* @__PURE__ */ hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
      baseTheme5
    ];
  }
});

// src/app/dashboard/notepad.component.ts
function NotepadComponent_div_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 35);
    \u0275\u0275listener("click", function NotepadComponent_div_16_Template_div_click_0_listener() {
      const tab_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.switchTab(tab_r3.id));
    })("dblclick", function NotepadComponent_div_16_Template_div_dblclick_0_listener() {
      const tab_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.renameTab(tab_r3.id));
    });
    \u0275\u0275elementStart(1, "span", 36);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "button", 37);
    \u0275\u0275listener("click", function NotepadComponent_div_16_Template_button_click_3_listener($event) {
      const tab_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.closeTab(tab_r3.id, $event));
    });
    \u0275\u0275element(4, "i", 38);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const tab_r3 = ctx.$implicit;
    \u0275\u0275classProp("active", tab_r3.isActive)("inactive", !tab_r3.isActive);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(tab_r3.name);
  }
}
function NotepadComponent_option_24_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 39);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const lang_r5 = ctx.$implicit;
    \u0275\u0275property("value", lang_r5.value);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", lang_r5.label, " ");
  }
}
function NotepadComponent_div_56_div_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 52)(1, "input", 53);
    \u0275\u0275twoWayListener("ngModelChange", function NotepadComponent_div_56_div_12_Template_input_ngModelChange_1_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r3 = \u0275\u0275nextContext(2);
      \u0275\u0275twoWayBindingSet(ctx_r3.popupInputValue, $event) || (ctx_r3.popupInputValue = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("keydown", function NotepadComponent_div_56_div_12_Template_input_keydown_1_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.onPromptKeydown($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("ngModel", ctx_r3.popupInputValue);
    \u0275\u0275property("placeholder", (ctx_r3.popupData == null ? null : ctx_r3.popupData.inputPlaceholder) || "Enter value...");
  }
}
function NotepadComponent_div_56_button_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 54);
    \u0275\u0275listener("click", function NotepadComponent_div_56_button_14_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r8);
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.handlePopupCancel());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", (ctx_r3.popupData == null ? null : ctx_r3.popupData.cancelText) || "Cancel", " ");
  }
}
function NotepadComponent_div_56_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 40);
    \u0275\u0275listener("click", function NotepadComponent_div_56_Template_div_click_0_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView($event.target === $event.currentTarget && ctx_r3.handlePopupCancel());
    })("keydown", function NotepadComponent_div_56_Template_div_keydown_0_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.onPopupKeydown($event));
    });
    \u0275\u0275elementStart(1, "div", 41);
    \u0275\u0275listener("click", function NotepadComponent_div_56_Template_div_click_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      return \u0275\u0275resetView($event.stopPropagation());
    });
    \u0275\u0275elementStart(2, "div", 42)(3, "div", 4);
    \u0275\u0275element(4, "i", 43);
    \u0275\u0275elementStart(5, "h3", 44);
    \u0275\u0275text(6);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "button", 45);
    \u0275\u0275listener("click", function NotepadComponent_div_56_Template_button_click_7_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.handlePopupCancel());
    });
    \u0275\u0275element(8, "i", 12);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(9, "div", 46)(10, "p", 47);
    \u0275\u0275text(11);
    \u0275\u0275elementEnd();
    \u0275\u0275template(12, NotepadComponent_div_56_div_12_Template, 2, 2, "div", 48);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "div", 49);
    \u0275\u0275template(14, NotepadComponent_div_56_button_14_Template, 2, 1, "button", 50);
    \u0275\u0275elementStart(15, "button", 51);
    \u0275\u0275listener("click", function NotepadComponent_div_56_Template_button_click_15_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.handlePopupConfirm());
    });
    \u0275\u0275text(16);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance(4);
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction3(7, _c12, (ctx_r3.popupData == null ? null : ctx_r3.popupData.type) === "alert", (ctx_r3.popupData == null ? null : ctx_r3.popupData.type) === "confirm", (ctx_r3.popupData == null ? null : ctx_r3.popupData.type) === "prompt"));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r3.popupData == null ? null : ctx_r3.popupData.title);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(ctx_r3.popupData == null ? null : ctx_r3.popupData.message);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", (ctx_r3.popupData == null ? null : ctx_r3.popupData.type) === "prompt");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", (ctx_r3.popupData == null ? null : ctx_r3.popupData.type) !== "alert");
    \u0275\u0275advance();
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction2(11, _c2, (ctx_r3.popupData == null ? null : ctx_r3.popupData.type) === "alert" || (ctx_r3.popupData == null ? null : ctx_r3.popupData.type) === "prompt", (ctx_r3.popupData == null ? null : ctx_r3.popupData.type) === "confirm"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", (ctx_r3.popupData == null ? null : ctx_r3.popupData.confirmText) || "OK", " ");
  }
}
var _c02, _c12, _c2, NotepadComponent;
var init_notepad_component = __esm({
  "src/app/dashboard/notepad.component.ts"() {
    "use strict";
    init_core();
    init_common();
    init_forms();
    init_dist2();
    init_dist();
    init_dist9();
    init_dist11();
    init_dist15();
    init_dist14();
    init_dist17();
    init_dist19();
    init_dist20();
    init_dist21();
    init_dist22();
    init_dist8();
    init_dist23();
    init_dist7();
    init_core();
    init_common();
    init_forms();
    _c02 = ["editorContainer"];
    _c12 = (a0, a1, a2) => ({ "ph-info text-sky-400": a0, "ph-question text-yellow-400": a1, "ph-pencil-simple text-blue-400": a2 });
    _c2 = (a0, a1) => ({ "bg-sky-600 hover:bg-sky-500 text-white": a0, "bg-gradient-to-r from-sky-600 to-blue-600 hover:from-sky-500 hover:to-blue-500 text-white shadow-lg shadow-sky-500/30": a1 });
    NotepadComponent = class _NotepadComponent {
      close = new EventEmitter();
      editorContainer;
      tabs = [];
      activeTabId = "";
      editorView = null;
      isDarkTheme = true;
      isFullscreen = false;
      showSettings = false;
      // Popup state
      showPopup = false;
      popupData = null;
      popupInputValue = "";
      languageCompartment = new Compartment();
      themeCompartment = new Compartment();
      languages = [
        { value: "plaintext", label: "Plain Text", extension: null },
        { value: "javascript", label: "JavaScript", extension: javascript },
        { value: "typescript", label: "TypeScript", extension: javascript({ typescript: true }) },
        { value: "python", label: "Python", extension: python },
        { value: "html", label: "HTML", extension: html },
        { value: "css", label: "CSS", extension: css },
        { value: "json", label: "JSON", extension: json },
        { value: "markdown", label: "Markdown", extension: markdown }
      ];
      constructor() {
      }
      ngOnInit() {
        this.loadFromLocalStorage();
        if (this.tabs.length === 0) {
          this.addTab("Notes", "plaintext");
          this.addTab("Code", "javascript");
        }
        if (this.tabs.length > 0 && !this.activeTabId) {
          this.activeTabId = this.tabs[0].id;
          this.tabs[0].isActive = true;
        }
      }
      ngAfterViewInit() {
        setTimeout(() => {
          this.initializeEditor();
        }, 100);
      }
      ngOnDestroy() {
        this.saveToLocalStorage();
        if (this.editorView) {
          this.editorView.destroy();
        }
      }
      initializeEditor() {
        if (!this.editorContainer)
          return;
        const activeTab = this.getActiveTab();
        if (!activeTab)
          return;
        const languageExtension = this.getLanguageExtension(activeTab.language);
        const extensions = [
          lineNumbers(),
          highlightActiveLineGutter(),
          highlightSpecialChars(),
          history(),
          foldGutter(),
          drawSelection(),
          dropCursor(),
          EditorState.allowMultipleSelections.of(true),
          indentOnInput(),
          syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
          bracketMatching(),
          closeBrackets(),
          autocompletion(),
          rectangularSelection(),
          crosshairCursor(),
          highlightActiveLine(),
          highlightSelectionMatches(),
          keymap.of([
            ...defaultKeymap,
            ...historyKeymap,
            ...foldKeymap,
            ...searchKeymap,
            ...completionKeymap,
            ...closeBracketsKeymap,
            ...lintKeymap,
            indentWithTab
          ]),
          this.languageCompartment.of(languageExtension ? [languageExtension()] : []),
          this.themeCompartment.of(this.isDarkTheme ? oneDark : []),
          EditorView.updateListener.of((update) => {
            if (update.docChanged) {
              this.onEditorChange(update.state.doc.toString());
            }
          }),
          // Enable scrolling with custom theme
          EditorView.theme({
            "&": {
              height: "100%"
            },
            ".cm-scroller": {
              overflow: "auto"
            }
          })
        ];
        const state = EditorState.create({
          doc: activeTab.content,
          extensions
        });
        this.editorView = new EditorView({
          state,
          parent: this.editorContainer.nativeElement
        });
      }
      getLanguageExtension(language2) {
        const lang = this.languages.find((l) => l.value === language2);
        return lang?.extension || null;
      }
      onEditorChange(content2) {
        const activeTab = this.getActiveTab();
        if (activeTab) {
          activeTab.content = content2;
          this.autoSave();
        }
      }
      addTab(name2, language2) {
        const tabCount = this.tabs.length + 1;
        const newTab = {
          id: `tab-${Date.now()}`,
          name: name2 || `Untitled ${tabCount}`,
          language: language2 || "plaintext",
          content: "",
          isActive: false
        };
        this.tabs.push(newTab);
        this.switchTab(newTab.id);
        this.saveToLocalStorage();
      }
      switchTab(tabId) {
        if (this.editorView) {
          const currentTab = this.getActiveTab();
          if (currentTab) {
            currentTab.content = this.editorView.state.doc.toString();
          }
        }
        this.tabs.forEach((tab2) => {
          tab2.isActive = tab2.id === tabId;
        });
        this.activeTabId = tabId;
        const newActiveTab = this.getActiveTab();
        if (newActiveTab && this.editorView) {
          const languageExtension = this.getLanguageExtension(newActiveTab.language);
          this.editorView.dispatch({
            changes: {
              from: 0,
              to: this.editorView.state.doc.length,
              insert: newActiveTab.content
            },
            effects: [
              this.languageCompartment.reconfigure(languageExtension ? [languageExtension()] : [])
            ]
          });
        }
        this.saveToLocalStorage();
      }
      closeTab(tabId, event) {
        if (event) {
          event.stopPropagation();
        }
        const index = this.tabs.findIndex((t2) => t2.id === tabId);
        if (index === -1)
          return;
        if (this.tabs.length === 1) {
          this.showAlertPopup("Cannot Close Tab", "You cannot close the last tab. At least one tab must remain open.");
          return;
        }
        this.tabs.splice(index, 1);
        if (tabId === this.activeTabId) {
          const newActiveIndex = Math.max(0, index - 1);
          this.switchTab(this.tabs[newActiveIndex].id);
        }
        this.saveToLocalStorage();
      }
      renameTab(tabId) {
        const tab2 = this.tabs.find((t2) => t2.id === tabId);
        if (!tab2)
          return;
        this.showPromptPopup("Rename Tab", "Enter a new name for this tab:", tab2.name, (newName) => {
          if (newName && newName.trim()) {
            tab2.name = newName.trim();
            this.saveToLocalStorage();
          }
        });
      }
      changeLanguage(language2) {
        const activeTab = this.getActiveTab();
        if (!activeTab)
          return;
        activeTab.language = language2;
        if (this.editorView) {
          const languageExtension = this.getLanguageExtension(language2);
          this.editorView.dispatch({
            effects: this.languageCompartment.reconfigure(languageExtension ? [languageExtension()] : [])
          });
        }
        this.saveToLocalStorage();
      }
      toggleTheme() {
        this.isDarkTheme = !this.isDarkTheme;
        if (this.editorView) {
          this.editorView.dispatch({
            effects: this.themeCompartment.reconfigure(this.isDarkTheme ? oneDark : [])
          });
        }
        this.saveToLocalStorage();
      }
      toggleFullscreen() {
        this.isFullscreen = !this.isFullscreen;
      }
      exportFile() {
        const activeTab = this.getActiveTab();
        if (!activeTab)
          return;
        const content2 = this.editorView?.state.doc.toString() || activeTab.content;
        const blob = new Blob([content2], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${activeTab.name}.txt`;
        a.click();
        URL.revokeObjectURL(url);
      }
      importFile() {
        const input2 = document.createElement("input");
        input2.type = "file";
        input2.accept = ".txt,.js,.ts,.py,.html,.css,.json,.md";
        input2.onchange = (e) => {
          const file = e.target.files[0];
          if (!file)
            return;
          const reader = new FileReader();
          reader.onload = (event) => {
            const content2 = event.target.result;
            const fileName = file.name.replace(/\.[^/.]+$/, "");
            const extension = file.name.split(".").pop()?.toLowerCase();
            let language2 = "plaintext";
            if (extension === "js")
              language2 = "javascript";
            else if (extension === "ts")
              language2 = "typescript";
            else if (extension === "py")
              language2 = "python";
            else if (extension === "html")
              language2 = "html";
            else if (extension === "css")
              language2 = "css";
            else if (extension === "json")
              language2 = "json";
            else if (extension === "md")
              language2 = "markdown";
            this.addTab(fileName, language2);
            const activeTab = this.getActiveTab();
            if (activeTab && this.editorView) {
              activeTab.content = content2;
              this.editorView.dispatch({
                changes: {
                  from: 0,
                  to: this.editorView.state.doc.length,
                  insert: content2
                }
              });
            }
          };
          reader.readAsText(file);
        };
        input2.click();
      }
      clearContent() {
        this.showConfirmPopup("Clear Content", "Are you sure you want to clear all content in the current tab? This action cannot be undone.", () => {
          const activeTab = this.getActiveTab();
          if (activeTab && this.editorView) {
            activeTab.content = "";
            this.editorView.dispatch({
              changes: {
                from: 0,
                to: this.editorView.state.doc.length,
                insert: ""
              }
            });
            this.saveToLocalStorage();
          }
        });
      }
      getActiveTab() {
        return this.tabs.find((t2) => t2.id === this.activeTabId);
      }
      autoSave() {
        if (this.autoSaveTimeout) {
          clearTimeout(this.autoSaveTimeout);
        }
        this.autoSaveTimeout = setTimeout(() => {
          this.saveToLocalStorage();
        }, 1e3);
      }
      saveToLocalStorage() {
        try {
          const data2 = {
            tabs: this.tabs,
            activeTabId: this.activeTabId,
            isDarkTheme: this.isDarkTheme
          };
          localStorage.setItem("notepad-data", JSON.stringify(data2));
        } catch (error) {
          console.error("Failed to save to localStorage:", error);
        }
      }
      loadFromLocalStorage() {
        try {
          const data2 = localStorage.getItem("notepad-data");
          if (data2) {
            const parsed = JSON.parse(data2);
            this.tabs = parsed.tabs || [];
            this.activeTabId = parsed.activeTabId || "";
            this.isDarkTheme = parsed.isDarkTheme !== void 0 ? parsed.isDarkTheme : true;
          }
        } catch (error) {
          console.error("Failed to load from localStorage:", error);
        }
      }
      closeNotepad() {
        this.saveToLocalStorage();
        this.close.emit();
      }
      get activeTab() {
        return this.getActiveTab();
      }
      // Popup methods
      showAlertPopup(title, message) {
        this.popupData = {
          type: "alert",
          title,
          message,
          confirmText: "OK"
        };
        this.showPopup = true;
      }
      showConfirmPopup(title, message, onConfirm, onCancel) {
        this.popupData = {
          type: "confirm",
          title,
          message,
          confirmText: "Yes",
          cancelText: "No",
          onConfirm,
          onCancel
        };
        this.showPopup = true;
      }
      showPromptPopup(title, message, defaultValue, onConfirm, onCancel) {
        this.popupInputValue = defaultValue;
        this.popupData = {
          type: "prompt",
          title,
          message,
          inputValue: defaultValue,
          inputPlaceholder: "Enter value...",
          confirmText: "OK",
          cancelText: "Cancel",
          onConfirm,
          onCancel
        };
        this.showPopup = true;
      }
      closePopup() {
        this.showPopup = false;
        this.popupData = null;
        this.popupInputValue = "";
      }
      handlePopupConfirm() {
        if (!this.popupData)
          return;
        if (this.popupData.type === "prompt") {
          this.popupData.onConfirm?.(this.popupInputValue);
        } else {
          this.popupData.onConfirm?.();
        }
        this.closePopup();
      }
      handlePopupCancel() {
        this.popupData?.onCancel?.();
        this.closePopup();
      }
      onPopupKeydown(event) {
        if (event.key === "Escape") {
          this.handlePopupCancel();
        } else if (event.key === "Enter" && this.popupData?.type !== "prompt") {
          this.handlePopupConfirm();
        }
      }
      onPromptKeydown(event) {
        if (event.key === "Enter") {
          event.preventDefault();
          this.handlePopupConfirm();
        }
      }
      static \u0275fac = function NotepadComponent_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _NotepadComponent)();
      };
      static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NotepadComponent, selectors: [["app-notepad"]], viewQuery: function NotepadComponent_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuery(_c02, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.editorContainer = _t.first);
        }
      }, outputs: { close: "close" }, decls: 57, vars: 16, consts: [["editorContainer", ""], [1, "notepad-overlay", "fixed", "inset-0", "bg-black/80", "backdrop-blur-sm", "z-[9999]", "flex", "items-center", "justify-center", "p-4", 3, "click"], [1, "notepad-container", "bg-slate-900", "rounded-xl", "shadow-2xl", "border", "border-sky-500/30", "flex", "flex-col", "overflow-hidden"], [1, "notepad-header", "bg-slate-800/90", "border-b", "border-sky-500/20", "px-4", "py-3", "flex", "items-center", "justify-between", "shrink-0"], [1, "flex", "items-center", "gap-3"], [1, "ph", "ph-note-pencil", "text-2xl", "text-sky-400"], [1, "text-xl", "font-bold", "text-white"], [1, "flex", "items-center", "gap-2"], ["title", "Toggle Theme", 1, "p-2", "rounded-lg", "hover:bg-slate-700", "transition-colors", "text-sky-400", 3, "click"], [1, "ph", "text-xl", 3, "ngClass"], ["title", "Toggle Fullscreen", 1, "p-2", "rounded-lg", "hover:bg-slate-700", "transition-colors", "text-sky-400", 3, "click"], ["title", "Close Notepad", 1, "p-2", "rounded-lg", "hover:bg-red-600", "transition-colors", "text-red-400", "hover:text-white", 3, "click"], [1, "ph", "ph-x", "text-xl"], [1, "tabs-bar", "bg-slate-800/50", "border-b", "border-sky-500/10", "px-4", "py-2", "flex", "items-center", "gap-2", "overflow-x-auto", "shrink-0"], [1, "flex", "items-center", "gap-1", "flex-1", "overflow-x-auto"], ["class", "tab-item group relative flex items-center gap-2 px-4 py-2 rounded-t-lg cursor-pointer transition-all", 3, "active", "inactive", "click", "dblclick", 4, "ngFor", "ngForOf"], ["title", "Add New Tab", 1, "add-tab-btn", "p-2", "rounded-lg", "hover:bg-sky-600/20", "transition-colors", "text-sky-400", "shrink-0", 3, "click"], [1, "ph", "ph-plus", "text-lg"], [1, "toolbar", "bg-slate-800/30", "border-b", "border-sky-500/10", "px-4", "py-2", "flex", "items-center", "justify-between", "gap-4", "shrink-0"], [1, "text-sm", "text-slate-400"], [1, "px-3", "py-1.5", "rounded-lg", "bg-slate-700", "text-white", "text-sm", "border", "border-sky-500/20", "focus:border-sky-500", "focus:outline-none", 3, "change", "value"], [3, "value", 4, "ngFor", "ngForOf"], ["title", "Import File", 1, "toolbar-btn", "px-3", "py-1.5", "rounded-lg", "hover:bg-slate-700", "transition-colors", "text-sky-400", "text-sm", "flex", "items-center", "gap-2", 3, "click"], [1, "ph", "ph-upload-simple"], [1, "hidden", "sm:inline"], ["title", "Export File", 1, "toolbar-btn", "px-3", "py-1.5", "rounded-lg", "hover:bg-slate-700", "transition-colors", "text-sky-400", "text-sm", "flex", "items-center", "gap-2", 3, "click"], [1, "ph", "ph-download-simple"], ["title", "Clear Content", 1, "toolbar-btn", "px-3", "py-1.5", "rounded-lg", "hover:bg-red-600/20", "transition-colors", "text-red-400", "text-sm", "flex", "items-center", "gap-2", 3, "click"], [1, "ph", "ph-trash"], [1, "editor-wrapper", "flex-1", "overflow-hidden", "bg-slate-900"], [1, "editor-container", "h-full", "w-full"], [1, "status-bar", "bg-slate-800/50", "border-t", "border-sky-500/10", "px-4", "py-2", "flex", "items-center", "justify-between", "text-xs", "text-slate-400", "shrink-0"], [1, "flex", "items-center", "gap-4"], [1, "text-sky-400"], ["class", "popup-overlay fixed inset-0 bg-black/90 backdrop-blur-sm z-[10000] flex items-center justify-center p-4 animate-fadeIn", 3, "click", "keydown", 4, "ngIf"], [1, "tab-item", "group", "relative", "flex", "items-center", "gap-2", "px-4", "py-2", "rounded-t-lg", "cursor-pointer", "transition-all", 3, "click", "dblclick"], [1, "text-sm", "font-medium", "whitespace-nowrap"], ["title", "Close Tab", 1, "close-tab-btn", "opacity-0", "group-hover:opacity-100", "p-1", "rounded", "hover:bg-red-500/20", "transition-all", 3, "click"], [1, "ph", "ph-x", "text-xs"], [3, "value"], [1, "popup-overlay", "fixed", "inset-0", "bg-black/90", "backdrop-blur-sm", "z-[10000]", "flex", "items-center", "justify-center", "p-4", "animate-fadeIn", 3, "click", "keydown"], [1, "popup-modal", "bg-slate-800", "rounded-xl", "shadow-2xl", "border", "border-sky-500/30", "max-w-md", "w-full", "animate-scaleIn", 3, "click"], [1, "popup-header", "bg-gradient-to-r", "from-sky-600/20", "to-blue-600/20", "border-b", "border-sky-500/20", "px-6", "py-4", "flex", "items-center", "justify-between"], [1, "ph", "text-2xl", 3, "ngClass"], [1, "text-lg", "font-bold", "text-white"], ["title", "Close", 1, "p-1.5", "rounded-lg", "hover:bg-slate-700", "transition-colors", "text-slate-400", "hover:text-white", 3, "click"], [1, "popup-body", "px-6", "py-5"], [1, "text-slate-300", "text-base", "leading-relaxed", "mb-4"], ["class", "mt-4", 4, "ngIf"], [1, "popup-footer", "bg-slate-900/50", "border-t", "border-sky-500/10", "px-6", "py-4", "flex", "items-center", "justify-end", "gap-3"], ["class", "px-5 py-2.5 rounded-lg bg-slate-700 hover:bg-slate-600 text-slate-300 hover:text-white font-medium transition-all transform hover:scale-105 active:scale-95", 3, "click", 4, "ngIf"], [1, "px-5", "py-2.5", "rounded-lg", "font-medium", "transition-all", "transform", "hover:scale-105", "active:scale-95", 3, "click", "ngClass"], [1, "mt-4"], ["type", "text", "autofocus", "", 1, "w-full", "px-4", "py-3", "rounded-lg", "bg-slate-900", "text-white", "border", "border-sky-500/30", "focus:border-sky-500", "focus:outline-none", "focus:ring-2", "focus:ring-sky-500/20", "transition-all", 3, "ngModelChange", "keydown", "ngModel", "placeholder"], [1, "px-5", "py-2.5", "rounded-lg", "bg-slate-700", "hover:bg-slate-600", "text-slate-300", "hover:text-white", "font-medium", "transition-all", "transform", "hover:scale-105", "active:scale-95", 3, "click"]], template: function NotepadComponent_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = \u0275\u0275getCurrentView();
          \u0275\u0275elementStart(0, "div", 1);
          \u0275\u0275listener("click", function NotepadComponent_Template_div_click_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView($event.target === $event.currentTarget && ctx.closeNotepad());
          });
          \u0275\u0275elementStart(1, "div", 2)(2, "div", 3)(3, "div", 4);
          \u0275\u0275element(4, "i", 5);
          \u0275\u0275elementStart(5, "h2", 6);
          \u0275\u0275text(6, "Smart Notepad");
          \u0275\u0275elementEnd()();
          \u0275\u0275elementStart(7, "div", 7)(8, "button", 8);
          \u0275\u0275listener("click", function NotepadComponent_Template_button_click_8_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.toggleTheme());
          });
          \u0275\u0275element(9, "i", 9);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(10, "button", 10);
          \u0275\u0275listener("click", function NotepadComponent_Template_button_click_10_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.toggleFullscreen());
          });
          \u0275\u0275element(11, "i", 9);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(12, "button", 11);
          \u0275\u0275listener("click", function NotepadComponent_Template_button_click_12_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.closeNotepad());
          });
          \u0275\u0275element(13, "i", 12);
          \u0275\u0275elementEnd()()();
          \u0275\u0275elementStart(14, "div", 13)(15, "div", 14);
          \u0275\u0275template(16, NotepadComponent_div_16_Template, 5, 5, "div", 15);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(17, "button", 16);
          \u0275\u0275listener("click", function NotepadComponent_Template_button_click_17_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.addTab());
          });
          \u0275\u0275element(18, "i", 17);
          \u0275\u0275elementEnd()();
          \u0275\u0275elementStart(19, "div", 18)(20, "div", 7)(21, "label", 19);
          \u0275\u0275text(22, "Language:");
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(23, "select", 20);
          \u0275\u0275listener("change", function NotepadComponent_Template_select_change_23_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.changeLanguage($event.target.value));
          });
          \u0275\u0275template(24, NotepadComponent_option_24_Template, 2, 2, "option", 21);
          \u0275\u0275elementEnd()();
          \u0275\u0275elementStart(25, "div", 7)(26, "button", 22);
          \u0275\u0275listener("click", function NotepadComponent_Template_button_click_26_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.importFile());
          });
          \u0275\u0275element(27, "i", 23);
          \u0275\u0275elementStart(28, "span", 24);
          \u0275\u0275text(29, "Import");
          \u0275\u0275elementEnd()();
          \u0275\u0275elementStart(30, "button", 25);
          \u0275\u0275listener("click", function NotepadComponent_Template_button_click_30_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.exportFile());
          });
          \u0275\u0275element(31, "i", 26);
          \u0275\u0275elementStart(32, "span", 24);
          \u0275\u0275text(33, "Export");
          \u0275\u0275elementEnd()();
          \u0275\u0275elementStart(34, "button", 27);
          \u0275\u0275listener("click", function NotepadComponent_Template_button_click_34_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.clearContent());
          });
          \u0275\u0275element(35, "i", 28);
          \u0275\u0275elementStart(36, "span", 24);
          \u0275\u0275text(37, "Clear");
          \u0275\u0275elementEnd()()()();
          \u0275\u0275elementStart(38, "div", 29);
          \u0275\u0275element(39, "div", 30, 0);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(41, "div", 31)(42, "div", 32)(43, "span");
          \u0275\u0275text(44, "Tab: ");
          \u0275\u0275elementStart(45, "strong", 33);
          \u0275\u0275text(46);
          \u0275\u0275elementEnd()();
          \u0275\u0275elementStart(47, "span");
          \u0275\u0275text(48, "Language: ");
          \u0275\u0275elementStart(49, "strong", 33);
          \u0275\u0275text(50);
          \u0275\u0275elementEnd()()();
          \u0275\u0275elementStart(51, "div", 32)(52, "span");
          \u0275\u0275text(53, "Auto-save enabled");
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(54, "span");
          \u0275\u0275text(55);
          \u0275\u0275elementEnd()()()()();
          \u0275\u0275template(56, NotepadComponent_div_56_Template, 17, 14, "div", 34);
        }
        if (rf & 2) {
          \u0275\u0275classProp("fullscreen", ctx.isFullscreen);
          \u0275\u0275advance();
          \u0275\u0275classProp("fullscreen-container", ctx.isFullscreen)("normal-container", !ctx.isFullscreen);
          \u0275\u0275advance(8);
          \u0275\u0275property("ngClass", ctx.isDarkTheme ? "ph-sun" : "ph-moon");
          \u0275\u0275advance(2);
          \u0275\u0275property("ngClass", ctx.isFullscreen ? "ph-arrows-in" : "ph-arrows-out");
          \u0275\u0275advance(5);
          \u0275\u0275property("ngForOf", ctx.tabs);
          \u0275\u0275advance(7);
          \u0275\u0275property("value", ctx.activeTab == null ? null : ctx.activeTab.language);
          \u0275\u0275advance();
          \u0275\u0275property("ngForOf", ctx.languages);
          \u0275\u0275advance(22);
          \u0275\u0275textInterpolate(ctx.activeTab == null ? null : ctx.activeTab.name);
          \u0275\u0275advance(4);
          \u0275\u0275textInterpolate(ctx.activeTab == null ? null : ctx.activeTab.language);
          \u0275\u0275advance(5);
          \u0275\u0275textInterpolate2("", ctx.tabs.length, " tab", ctx.tabs.length !== 1 ? "s" : "");
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.showPopup);
        }
      }, dependencies: [CommonModule, NgClass, NgForOf, NgIf, FormsModule, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, NgControlStatus, NgModel], styles: ['\n\n.notepad-overlay[_ngcontent-%COMP%] {\n  animation: _ngcontent-%COMP%_fadeIn 0.2s ease-out;\n}\n.notepad-overlay.fullscreen[_ngcontent-%COMP%] {\n  padding: 0;\n}\n.notepad-container[_ngcontent-%COMP%] {\n  transition: all 0.3s ease;\n}\n.notepad-container.normal-container[_ngcontent-%COMP%] {\n  width: 90vw;\n  max-width: 1400px;\n  height: 85vh;\n  max-height: 900px;\n}\n.notepad-container.fullscreen-container[_ngcontent-%COMP%] {\n  width: 100vw;\n  height: 100vh;\n  max-width: 100vw;\n  max-height: 100vh;\n  border-radius: 0;\n}\n.notepad-header[_ngcontent-%COMP%] {\n  -webkit-user-select: none;\n  user-select: none;\n}\n.notepad-header[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:hover {\n  transform: scale(1.05);\n}\n.notepad-header[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:active {\n  transform: scale(0.95);\n}\n.tabs-bar[_ngcontent-%COMP%] {\n  scrollbar-width: thin;\n  scrollbar-color: rgba(56, 189, 248, 0.3) transparent;\n}\n.tabs-bar[_ngcontent-%COMP%]::-webkit-scrollbar {\n  height: 4px;\n}\n.tabs-bar[_ngcontent-%COMP%]::-webkit-scrollbar-track {\n  background: transparent;\n}\n.tabs-bar[_ngcontent-%COMP%]::-webkit-scrollbar-thumb {\n  background: rgba(56, 189, 248, 0.3);\n  border-radius: 2px;\n}\n.tabs-bar[_ngcontent-%COMP%]::-webkit-scrollbar-thumb:hover {\n  background: rgba(56, 189, 248, 0.5);\n}\n.tab-item[_ngcontent-%COMP%] {\n  position: relative;\n  min-width: 120px;\n  max-width: 200px;\n}\n.tab-item.active[_ngcontent-%COMP%] {\n  background:\n    linear-gradient(\n      to bottom,\n      rgba(14, 165, 233, 0.2),\n      rgba(14, 165, 233, 0.1));\n  border: 1px solid rgba(56, 189, 248, 0.3);\n  border-bottom: none;\n  color: #38bdf8;\n}\n.tab-item.active[_ngcontent-%COMP%]::after {\n  content: "";\n  position: absolute;\n  bottom: -1px;\n  left: 0;\n  right: 0;\n  height: 2px;\n  background: #0f172a;\n}\n.tab-item.inactive[_ngcontent-%COMP%] {\n  background: rgba(30, 41, 59, 0.5);\n  color: #94a3b8;\n  border: 1px solid transparent;\n}\n.tab-item.inactive[_ngcontent-%COMP%]:hover {\n  background: rgba(30, 41, 59, 0.8);\n  border-color: rgba(56, 189, 248, 0.2);\n  color: #cbd5e1;\n}\n.tab-item[_ngcontent-%COMP%]   .close-tab-btn[_ngcontent-%COMP%] {\n  color: #94a3b8;\n}\n.tab-item[_ngcontent-%COMP%]   .close-tab-btn[_ngcontent-%COMP%]:hover {\n  color: #ef4444;\n}\n.add-tab-btn[_ngcontent-%COMP%]:hover {\n  transform: scale(1.1);\n}\n.add-tab-btn[_ngcontent-%COMP%]:active {\n  transform: scale(0.9);\n}\n.toolbar[_ngcontent-%COMP%]   select[_ngcontent-%COMP%] {\n  cursor: pointer;\n  transition: all 0.2s;\n}\n.toolbar[_ngcontent-%COMP%]   select[_ngcontent-%COMP%]:hover {\n  border-color: rgba(56, 189, 248, 0.5);\n}\n.toolbar[_ngcontent-%COMP%]   select[_ngcontent-%COMP%]:focus {\n  box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.1);\n}\n.toolbar[_ngcontent-%COMP%]   .toolbar-btn[_ngcontent-%COMP%] {\n  transition: all 0.2s;\n}\n.toolbar[_ngcontent-%COMP%]   .toolbar-btn[_ngcontent-%COMP%]:hover {\n  transform: translateY(-1px);\n  box-shadow: 0 2px 8px rgba(56, 189, 248, 0.2);\n}\n.toolbar[_ngcontent-%COMP%]   .toolbar-btn[_ngcontent-%COMP%]:active {\n  transform: translateY(0);\n}\n.editor-wrapper[_ngcontent-%COMP%] {\n  position: relative;\n  overflow: hidden;\n}\n.editor-wrapper[_ngcontent-%COMP%]   .editor-container[_ngcontent-%COMP%] {\n  font-family:\n    "Consolas",\n    "Monaco",\n    "Courier New",\n    monospace;\n  font-size: 14px;\n  line-height: 1.6;\n  height: 100%;\n  overflow: hidden;\n}\n.editor-wrapper[_ngcontent-%COMP%]   .editor-container[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:deep(.cm-editor) {\n  height: 100%;\n  font-size: 14px;\n}\n.editor-wrapper[_ngcontent-%COMP%]   .editor-container[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:deep(.cm-editor)   .cm-scroller[_ngcontent-%COMP%] {\n  overflow-y: auto !important;\n  overflow-x: auto !important;\n  font-family:\n    "Consolas",\n    "Monaco",\n    "Courier New",\n    monospace;\n  height: 100%;\n  scrollbar-width: auto;\n  scrollbar-color: rgba(56, 189, 248, 0.4) rgba(15, 23, 42, 0.5);\n}\n.editor-wrapper[_ngcontent-%COMP%]   .editor-container[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:deep(.cm-editor)   .cm-scroller[_ngcontent-%COMP%]::-webkit-scrollbar {\n  width: 12px;\n  height: 12px;\n}\n.editor-wrapper[_ngcontent-%COMP%]   .editor-container[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:deep(.cm-editor)   .cm-scroller[_ngcontent-%COMP%]::-webkit-scrollbar-track {\n  background: rgba(15, 23, 42, 0.5);\n  border-radius: 0;\n}\n.editor-wrapper[_ngcontent-%COMP%]   .editor-container[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:deep(.cm-editor)   .cm-scroller[_ngcontent-%COMP%]::-webkit-scrollbar-thumb {\n  background: rgba(56, 189, 248, 0.4);\n  border-radius: 6px;\n  border: 2px solid rgba(15, 23, 42, 0.5);\n}\n.editor-wrapper[_ngcontent-%COMP%]   .editor-container[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:deep(.cm-editor)   .cm-scroller[_ngcontent-%COMP%]::-webkit-scrollbar-thumb:hover {\n  background: rgba(56, 189, 248, 0.6);\n}\n.editor-wrapper[_ngcontent-%COMP%]   .editor-container[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:deep(.cm-editor)   .cm-scroller[_ngcontent-%COMP%]::-webkit-scrollbar-thumb:active {\n  background: rgba(56, 189, 248, 0.8);\n}\n.editor-wrapper[_ngcontent-%COMP%]   .editor-container[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:deep(.cm-editor)   .cm-gutters[_ngcontent-%COMP%] {\n  background: rgba(15, 23, 42, 0.5);\n  border-right: 1px solid rgba(56, 189, 248, 0.1);\n}\n.editor-wrapper[_ngcontent-%COMP%]   .editor-container[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:deep(.cm-editor)   .cm-activeLineGutter[_ngcontent-%COMP%] {\n  background: rgba(56, 189, 248, 0.1);\n}\n.editor-wrapper[_ngcontent-%COMP%]   .editor-container[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:deep(.cm-editor)   .cm-activeLine[_ngcontent-%COMP%] {\n  background: rgba(56, 189, 248, 0.05);\n}\n.editor-wrapper[_ngcontent-%COMP%]   .editor-container[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:deep(.cm-editor)   .cm-selectionBackground[_ngcontent-%COMP%] {\n  background: rgba(56, 189, 248, 0.2) !important;\n}\n.editor-wrapper[_ngcontent-%COMP%]   .editor-container[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:deep(.cm-editor)   .cm-cursor[_ngcontent-%COMP%] {\n  border-left-color: #38bdf8;\n}\n.editor-wrapper[_ngcontent-%COMP%]   .editor-container[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:deep(.cm-editor)   .cm-focused[_ngcontent-%COMP%] {\n  outline: none;\n}\n.editor-wrapper[_ngcontent-%COMP%]   .editor-container[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:deep(.cm-editor)   .cm-panel[_ngcontent-%COMP%] {\n  background: rgba(30, 41, 59, 0.95);\n  border: 1px solid rgba(56, 189, 248, 0.2);\n}\n.editor-wrapper[_ngcontent-%COMP%]   .editor-container[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:deep(.cm-editor)   .cm-panel[_ngcontent-%COMP%]   input[_ngcontent-%COMP%] {\n  background: rgba(15, 23, 42, 0.8);\n  border: 1px solid rgba(56, 189, 248, 0.2);\n  color: #e2e8f0;\n  padding: 4px 8px;\n  border-radius: 4px;\n}\n.editor-wrapper[_ngcontent-%COMP%]   .editor-container[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:deep(.cm-editor)   .cm-panel[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]:focus {\n  outline: none;\n  border-color: #38bdf8;\n}\n.editor-wrapper[_ngcontent-%COMP%]   .editor-container[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:deep(.cm-editor)   .cm-panel[_ngcontent-%COMP%]   button[_ngcontent-%COMP%] {\n  background: rgba(56, 189, 248, 0.1);\n  border: 1px solid rgba(56, 189, 248, 0.2);\n  color: #38bdf8;\n  padding: 4px 12px;\n  border-radius: 4px;\n  cursor: pointer;\n  transition: all 0.2s;\n}\n.editor-wrapper[_ngcontent-%COMP%]   .editor-container[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:deep(.cm-editor)   .cm-panel[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:hover {\n  background: rgba(56, 189, 248, 0.2);\n  border-color: #38bdf8;\n}\n.editor-wrapper[_ngcontent-%COMP%]   .editor-container[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:deep(.cm-editor:not(.cm-focused))   .cm-gutters[_ngcontent-%COMP%] {\n  background: rgba(241, 245, 249, 0.5);\n}\n.status-bar[_ngcontent-%COMP%] {\n  -webkit-user-select: none;\n  user-select: none;\n}\n.status-bar[_ngcontent-%COMP%]   strong[_ngcontent-%COMP%] {\n  font-weight: 600;\n}\n.popup-overlay[_ngcontent-%COMP%] {\n  animation: _ngcontent-%COMP%_fadeIn 0.2s ease-out;\n}\n.popup-overlay[_ngcontent-%COMP%]   .popup-modal[_ngcontent-%COMP%] {\n  animation: _ngcontent-%COMP%_scaleIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);\n  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);\n}\n.popup-header[_ngcontent-%COMP%] {\n  -webkit-user-select: none;\n  user-select: none;\n}\n.popup-header[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:hover {\n  transform: scale(1.1);\n}\n.popup-header[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:active {\n  transform: scale(0.9);\n}\n.popup-body[_ngcontent-%COMP%]   p[_ngcontent-%COMP%] {\n  word-wrap: break-word;\n}\n.popup-body[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]::placeholder {\n  color: rgba(148, 163, 184, 0.5);\n}\n.popup-body[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]:focus {\n  box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.1);\n}\n.popup-footer[_ngcontent-%COMP%]   button[_ngcontent-%COMP%] {\n  cursor: pointer;\n  -webkit-user-select: none;\n  user-select: none;\n}\n.popup-footer[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:focus {\n  outline: none;\n  box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.2);\n}\n.popup-footer[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n  transform: none !important;\n}\n@keyframes _ngcontent-%COMP%_fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n@keyframes _ngcontent-%COMP%_scaleIn {\n  from {\n    opacity: 0;\n    transform: scale(0.9) translateY(-20px);\n  }\n  to {\n    opacity: 1;\n    transform: scale(1) translateY(0);\n  }\n}\n@media (max-width: 768px) {\n  .notepad-container.normal-container[_ngcontent-%COMP%] {\n    width: 100vw;\n    height: 100vh;\n    max-width: 100vw;\n    max-height: 100vh;\n    border-radius: 0;\n  }\n  .tab-item[_ngcontent-%COMP%] {\n    min-width: 100px;\n    max-width: 150px;\n    font-size: 0.875rem;\n  }\n  .toolbar[_ngcontent-%COMP%] {\n    flex-wrap: wrap;\n    gap: 0.5rem;\n  }\n  .status-bar[_ngcontent-%COMP%] {\n    flex-direction: column;\n    align-items: flex-start;\n    gap: 0.5rem;\n  }\n}\n[_ngcontent-%COMP%]::-webkit-scrollbar {\n  width: 8px;\n  height: 8px;\n}\n[_ngcontent-%COMP%]::-webkit-scrollbar-track {\n  background: rgba(15, 23, 42, 0.5);\n}\n[_ngcontent-%COMP%]::-webkit-scrollbar-thumb {\n  background: rgba(56, 189, 248, 0.3);\n  border-radius: 4px;\n}\n[_ngcontent-%COMP%]::-webkit-scrollbar-thumb:hover {\n  background: rgba(56, 189, 248, 0.5);\n}\n*[_ngcontent-%COMP%] {\n  scrollbar-width: thin;\n  scrollbar-color: rgba(56, 189, 248, 0.3) rgba(15, 23, 42, 0.5);\n}\n/*# sourceMappingURL=notepad.component.css.map */'] });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NotepadComponent, [{
        type: Component,
        args: [{ selector: "app-notepad", standalone: true, imports: [CommonModule, FormsModule], template: `<!-- Notepad Modal Overlay -->\r
<div class="notepad-overlay fixed inset-0 bg-black/80 backdrop-blur-sm z-[9999] flex items-center justify-center p-4"\r
     [class.fullscreen]="isFullscreen"\r
     (click)="$event.target === $event.currentTarget && closeNotepad()">\r
  \r
  <!-- Notepad Container -->\r
  <div class="notepad-container bg-slate-900 rounded-xl shadow-2xl border border-sky-500/30 flex flex-col overflow-hidden"\r
       [class.fullscreen-container]="isFullscreen"\r
       [class.normal-container]="!isFullscreen">\r
    \r
    <!-- Header -->\r
    <div class="notepad-header bg-slate-800/90 border-b border-sky-500/20 px-4 py-3 flex items-center justify-between shrink-0">\r
      <div class="flex items-center gap-3">\r
        <i class="ph ph-note-pencil text-2xl text-sky-400"></i>\r
        <h2 class="text-xl font-bold text-white">Smart Notepad</h2>\r
      </div>\r
      \r
      <div class="flex items-center gap-2">\r
        <!-- Theme Toggle -->\r
        <button (click)="toggleTheme()" \r
                class="p-2 rounded-lg hover:bg-slate-700 transition-colors text-sky-400"\r
                title="Toggle Theme">\r
          <i class="ph text-xl" [ngClass]="isDarkTheme ? 'ph-sun' : 'ph-moon'"></i>\r
        </button>\r
        \r
        <!-- Fullscreen Toggle -->\r
        <button (click)="toggleFullscreen()" \r
                class="p-2 rounded-lg hover:bg-slate-700 transition-colors text-sky-400"\r
                title="Toggle Fullscreen">\r
          <i class="ph text-xl" [ngClass]="isFullscreen ? 'ph-arrows-in' : 'ph-arrows-out'"></i>\r
        </button>\r
        \r
        <!-- Close Button -->\r
        <button (click)="closeNotepad()" \r
                class="p-2 rounded-lg hover:bg-red-600 transition-colors text-red-400 hover:text-white"\r
                title="Close Notepad">\r
          <i class="ph ph-x text-xl"></i>\r
        </button>\r
      </div>\r
    </div>\r
\r
    <!-- Tabs Bar -->\r
    <div class="tabs-bar bg-slate-800/50 border-b border-sky-500/10 px-4 py-2 flex items-center gap-2 overflow-x-auto shrink-0">\r
      <div class="flex items-center gap-1 flex-1 overflow-x-auto">\r
        <div *ngFor="let tab of tabs" \r
             class="tab-item group relative flex items-center gap-2 px-4 py-2 rounded-t-lg cursor-pointer transition-all"\r
             [class.active]="tab.isActive"\r
             [class.inactive]="!tab.isActive"\r
             (click)="switchTab(tab.id)"\r
             (dblclick)="renameTab(tab.id)">\r
          <span class="text-sm font-medium whitespace-nowrap">{{ tab.name }}</span>\r
          <button (click)="closeTab(tab.id, $event)" \r
                  class="close-tab-btn opacity-0 group-hover:opacity-100 p-1 rounded hover:bg-red-500/20 transition-all"\r
                  title="Close Tab">\r
            <i class="ph ph-x text-xs"></i>\r
          </button>\r
        </div>\r
      </div>\r
      \r
      <!-- Add Tab Button -->\r
      <button (click)="addTab()" \r
              class="add-tab-btn p-2 rounded-lg hover:bg-sky-600/20 transition-colors text-sky-400 shrink-0"\r
              title="Add New Tab">\r
        <i class="ph ph-plus text-lg"></i>\r
      </button>\r
    </div>\r
\r
    <!-- Toolbar -->\r
    <div class="toolbar bg-slate-800/30 border-b border-sky-500/10 px-4 py-2 flex items-center justify-between gap-4 shrink-0">\r
      <!-- Language Selector -->\r
      <div class="flex items-center gap-2">\r
        <label class="text-sm text-slate-400">Language:</label>\r
        <select [value]="activeTab?.language" \r
                (change)="changeLanguage($any($event.target).value)"\r
                class="px-3 py-1.5 rounded-lg bg-slate-700 text-white text-sm border border-sky-500/20 focus:border-sky-500 focus:outline-none">\r
          <option *ngFor="let lang of languages" [value]="lang.value">\r
            {{ lang.label }}\r
          </option>\r
        </select>\r
      </div>\r
\r
      <!-- Action Buttons -->\r
      <div class="flex items-center gap-2">\r
        <button (click)="importFile()" \r
                class="toolbar-btn px-3 py-1.5 rounded-lg hover:bg-slate-700 transition-colors text-sky-400 text-sm flex items-center gap-2"\r
                title="Import File">\r
          <i class="ph ph-upload-simple"></i>\r
          <span class="hidden sm:inline">Import</span>\r
        </button>\r
        \r
        <button (click)="exportFile()" \r
                class="toolbar-btn px-3 py-1.5 rounded-lg hover:bg-slate-700 transition-colors text-sky-400 text-sm flex items-center gap-2"\r
                title="Export File">\r
          <i class="ph ph-download-simple"></i>\r
          <span class="hidden sm:inline">Export</span>\r
        </button>\r
        \r
        <button (click)="clearContent()" \r
                class="toolbar-btn px-3 py-1.5 rounded-lg hover:bg-red-600/20 transition-colors text-red-400 text-sm flex items-center gap-2"\r
                title="Clear Content">\r
          <i class="ph ph-trash"></i>\r
          <span class="hidden sm:inline">Clear</span>\r
        </button>\r
      </div>\r
    </div>\r
\r
    <!-- Editor Container -->\r
    <div class="editor-wrapper flex-1 overflow-hidden bg-slate-900">\r
      <div #editorContainer class="editor-container h-full w-full"></div>\r
    </div>\r
\r
    <!-- Status Bar -->\r
    <div class="status-bar bg-slate-800/50 border-t border-sky-500/10 px-4 py-2 flex items-center justify-between text-xs text-slate-400 shrink-0">\r
      <div class="flex items-center gap-4">\r
        <span>Tab: <strong class="text-sky-400">{{ activeTab?.name }}</strong></span>\r
        <span>Language: <strong class="text-sky-400">{{ activeTab?.language }}</strong></span>\r
      </div>\r
      <div class="flex items-center gap-4">\r
        <span>Auto-save enabled</span>\r
        <span>{{ tabs.length }} tab{{ tabs.length !== 1 ? 's' : '' }}</span>\r
      </div>\r
    </div>\r
  </div>\r
</div>\r
\r
<!-- Custom Popup Modal -->\r
<div *ngIf="showPopup" \r
     class="popup-overlay fixed inset-0 bg-black/90 backdrop-blur-sm z-[10000] flex items-center justify-center p-4 animate-fadeIn"\r
     (click)="$event.target === $event.currentTarget && handlePopupCancel()"\r
     (keydown)="onPopupKeydown($event)">\r
  \r
  <div class="popup-modal bg-slate-800 rounded-xl shadow-2xl border border-sky-500/30 max-w-md w-full animate-scaleIn"\r
       (click)="$event.stopPropagation()">\r
    \r
    <!-- Popup Header -->\r
    <div class="popup-header bg-gradient-to-r from-sky-600/20 to-blue-600/20 border-b border-sky-500/20 px-6 py-4 flex items-center justify-between">\r
      <div class="flex items-center gap-3">\r
        <i class="ph text-2xl" \r
           [ngClass]="{\r
             'ph-info text-sky-400': popupData?.type === 'alert',\r
             'ph-question text-yellow-400': popupData?.type === 'confirm',\r
             'ph-pencil-simple text-blue-400': popupData?.type === 'prompt'\r
           }"></i>\r
        <h3 class="text-lg font-bold text-white">{{ popupData?.title }}</h3>\r
      </div>\r
      <button (click)="handlePopupCancel()" \r
              class="p-1.5 rounded-lg hover:bg-slate-700 transition-colors text-slate-400 hover:text-white"\r
              title="Close">\r
        <i class="ph ph-x text-xl"></i>\r
      </button>\r
    </div>\r
\r
    <!-- Popup Body -->\r
    <div class="popup-body px-6 py-5">\r
      <p class="text-slate-300 text-base leading-relaxed mb-4">{{ popupData?.message }}</p>\r
      \r
      <!-- Input field for prompt type -->\r
      <div *ngIf="popupData?.type === 'prompt'" class="mt-4">\r
        <input \r
          type="text" \r
          [(ngModel)]="popupInputValue"\r
          [placeholder]="popupData?.inputPlaceholder || 'Enter value...'"\r
          (keydown)="onPromptKeydown($event)"\r
          class="w-full px-4 py-3 rounded-lg bg-slate-900 text-white border border-sky-500/30 focus:border-sky-500 focus:outline-none focus:ring-2 focus:ring-sky-500/20 transition-all"\r
          autofocus>\r
      </div>\r
    </div>\r
\r
    <!-- Popup Footer -->\r
    <div class="popup-footer bg-slate-900/50 border-t border-sky-500/10 px-6 py-4 flex items-center justify-end gap-3">\r
      <!-- Cancel button (for confirm and prompt types) -->\r
      <button *ngIf="popupData?.type !== 'alert'"\r
              (click)="handlePopupCancel()"\r
              class="px-5 py-2.5 rounded-lg bg-slate-700 hover:bg-slate-600 text-slate-300 hover:text-white font-medium transition-all transform hover:scale-105 active:scale-95">\r
        {{ popupData?.cancelText || 'Cancel' }}\r
      </button>\r
      \r
      <!-- Confirm button -->\r
      <button (click)="handlePopupConfirm()"\r
              class="px-5 py-2.5 rounded-lg font-medium transition-all transform hover:scale-105 active:scale-95"\r
              [ngClass]="{\r
                'bg-sky-600 hover:bg-sky-500 text-white': popupData?.type === 'alert' || popupData?.type === 'prompt',\r
                'bg-gradient-to-r from-sky-600 to-blue-600 hover:from-sky-500 hover:to-blue-500 text-white shadow-lg shadow-sky-500/30': popupData?.type === 'confirm'\r
              }">\r
        {{ popupData?.confirmText || 'OK' }}\r
      </button>\r
    </div>\r
  </div>\r
</div>\r
`, styles: ['/* src/app/dashboard/notepad.component.scss */\n.notepad-overlay {\n  animation: fadeIn 0.2s ease-out;\n}\n.notepad-overlay.fullscreen {\n  padding: 0;\n}\n.notepad-container {\n  transition: all 0.3s ease;\n}\n.notepad-container.normal-container {\n  width: 90vw;\n  max-width: 1400px;\n  height: 85vh;\n  max-height: 900px;\n}\n.notepad-container.fullscreen-container {\n  width: 100vw;\n  height: 100vh;\n  max-width: 100vw;\n  max-height: 100vh;\n  border-radius: 0;\n}\n.notepad-header {\n  -webkit-user-select: none;\n  user-select: none;\n}\n.notepad-header button:hover {\n  transform: scale(1.05);\n}\n.notepad-header button:active {\n  transform: scale(0.95);\n}\n.tabs-bar {\n  scrollbar-width: thin;\n  scrollbar-color: rgba(56, 189, 248, 0.3) transparent;\n}\n.tabs-bar::-webkit-scrollbar {\n  height: 4px;\n}\n.tabs-bar::-webkit-scrollbar-track {\n  background: transparent;\n}\n.tabs-bar::-webkit-scrollbar-thumb {\n  background: rgba(56, 189, 248, 0.3);\n  border-radius: 2px;\n}\n.tabs-bar::-webkit-scrollbar-thumb:hover {\n  background: rgba(56, 189, 248, 0.5);\n}\n.tab-item {\n  position: relative;\n  min-width: 120px;\n  max-width: 200px;\n}\n.tab-item.active {\n  background:\n    linear-gradient(\n      to bottom,\n      rgba(14, 165, 233, 0.2),\n      rgba(14, 165, 233, 0.1));\n  border: 1px solid rgba(56, 189, 248, 0.3);\n  border-bottom: none;\n  color: #38bdf8;\n}\n.tab-item.active::after {\n  content: "";\n  position: absolute;\n  bottom: -1px;\n  left: 0;\n  right: 0;\n  height: 2px;\n  background: #0f172a;\n}\n.tab-item.inactive {\n  background: rgba(30, 41, 59, 0.5);\n  color: #94a3b8;\n  border: 1px solid transparent;\n}\n.tab-item.inactive:hover {\n  background: rgba(30, 41, 59, 0.8);\n  border-color: rgba(56, 189, 248, 0.2);\n  color: #cbd5e1;\n}\n.tab-item .close-tab-btn {\n  color: #94a3b8;\n}\n.tab-item .close-tab-btn:hover {\n  color: #ef4444;\n}\n.add-tab-btn:hover {\n  transform: scale(1.1);\n}\n.add-tab-btn:active {\n  transform: scale(0.9);\n}\n.toolbar select {\n  cursor: pointer;\n  transition: all 0.2s;\n}\n.toolbar select:hover {\n  border-color: rgba(56, 189, 248, 0.5);\n}\n.toolbar select:focus {\n  box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.1);\n}\n.toolbar .toolbar-btn {\n  transition: all 0.2s;\n}\n.toolbar .toolbar-btn:hover {\n  transform: translateY(-1px);\n  box-shadow: 0 2px 8px rgba(56, 189, 248, 0.2);\n}\n.toolbar .toolbar-btn:active {\n  transform: translateY(0);\n}\n.editor-wrapper {\n  position: relative;\n  overflow: hidden;\n}\n.editor-wrapper .editor-container {\n  font-family:\n    "Consolas",\n    "Monaco",\n    "Courier New",\n    monospace;\n  font-size: 14px;\n  line-height: 1.6;\n  height: 100%;\n  overflow: hidden;\n}\n.editor-wrapper .editor-container :deep(.cm-editor) {\n  height: 100%;\n  font-size: 14px;\n}\n.editor-wrapper .editor-container :deep(.cm-editor) .cm-scroller {\n  overflow-y: auto !important;\n  overflow-x: auto !important;\n  font-family:\n    "Consolas",\n    "Monaco",\n    "Courier New",\n    monospace;\n  height: 100%;\n  scrollbar-width: auto;\n  scrollbar-color: rgba(56, 189, 248, 0.4) rgba(15, 23, 42, 0.5);\n}\n.editor-wrapper .editor-container :deep(.cm-editor) .cm-scroller::-webkit-scrollbar {\n  width: 12px;\n  height: 12px;\n}\n.editor-wrapper .editor-container :deep(.cm-editor) .cm-scroller::-webkit-scrollbar-track {\n  background: rgba(15, 23, 42, 0.5);\n  border-radius: 0;\n}\n.editor-wrapper .editor-container :deep(.cm-editor) .cm-scroller::-webkit-scrollbar-thumb {\n  background: rgba(56, 189, 248, 0.4);\n  border-radius: 6px;\n  border: 2px solid rgba(15, 23, 42, 0.5);\n}\n.editor-wrapper .editor-container :deep(.cm-editor) .cm-scroller::-webkit-scrollbar-thumb:hover {\n  background: rgba(56, 189, 248, 0.6);\n}\n.editor-wrapper .editor-container :deep(.cm-editor) .cm-scroller::-webkit-scrollbar-thumb:active {\n  background: rgba(56, 189, 248, 0.8);\n}\n.editor-wrapper .editor-container :deep(.cm-editor) .cm-gutters {\n  background: rgba(15, 23, 42, 0.5);\n  border-right: 1px solid rgba(56, 189, 248, 0.1);\n}\n.editor-wrapper .editor-container :deep(.cm-editor) .cm-activeLineGutter {\n  background: rgba(56, 189, 248, 0.1);\n}\n.editor-wrapper .editor-container :deep(.cm-editor) .cm-activeLine {\n  background: rgba(56, 189, 248, 0.05);\n}\n.editor-wrapper .editor-container :deep(.cm-editor) .cm-selectionBackground {\n  background: rgba(56, 189, 248, 0.2) !important;\n}\n.editor-wrapper .editor-container :deep(.cm-editor) .cm-cursor {\n  border-left-color: #38bdf8;\n}\n.editor-wrapper .editor-container :deep(.cm-editor) .cm-focused {\n  outline: none;\n}\n.editor-wrapper .editor-container :deep(.cm-editor) .cm-panel {\n  background: rgba(30, 41, 59, 0.95);\n  border: 1px solid rgba(56, 189, 248, 0.2);\n}\n.editor-wrapper .editor-container :deep(.cm-editor) .cm-panel input {\n  background: rgba(15, 23, 42, 0.8);\n  border: 1px solid rgba(56, 189, 248, 0.2);\n  color: #e2e8f0;\n  padding: 4px 8px;\n  border-radius: 4px;\n}\n.editor-wrapper .editor-container :deep(.cm-editor) .cm-panel input:focus {\n  outline: none;\n  border-color: #38bdf8;\n}\n.editor-wrapper .editor-container :deep(.cm-editor) .cm-panel button {\n  background: rgba(56, 189, 248, 0.1);\n  border: 1px solid rgba(56, 189, 248, 0.2);\n  color: #38bdf8;\n  padding: 4px 12px;\n  border-radius: 4px;\n  cursor: pointer;\n  transition: all 0.2s;\n}\n.editor-wrapper .editor-container :deep(.cm-editor) .cm-panel button:hover {\n  background: rgba(56, 189, 248, 0.2);\n  border-color: #38bdf8;\n}\n.editor-wrapper .editor-container :deep(.cm-editor:not(.cm-focused)) .cm-gutters {\n  background: rgba(241, 245, 249, 0.5);\n}\n.status-bar {\n  -webkit-user-select: none;\n  user-select: none;\n}\n.status-bar strong {\n  font-weight: 600;\n}\n.popup-overlay {\n  animation: fadeIn 0.2s ease-out;\n}\n.popup-overlay .popup-modal {\n  animation: scaleIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);\n  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);\n}\n.popup-header {\n  -webkit-user-select: none;\n  user-select: none;\n}\n.popup-header button:hover {\n  transform: scale(1.1);\n}\n.popup-header button:active {\n  transform: scale(0.9);\n}\n.popup-body p {\n  word-wrap: break-word;\n}\n.popup-body input::placeholder {\n  color: rgba(148, 163, 184, 0.5);\n}\n.popup-body input:focus {\n  box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.1);\n}\n.popup-footer button {\n  cursor: pointer;\n  -webkit-user-select: none;\n  user-select: none;\n}\n.popup-footer button:focus {\n  outline: none;\n  box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.2);\n}\n.popup-footer button:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n  transform: none !important;\n}\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n@keyframes scaleIn {\n  from {\n    opacity: 0;\n    transform: scale(0.9) translateY(-20px);\n  }\n  to {\n    opacity: 1;\n    transform: scale(1) translateY(0);\n  }\n}\n@media (max-width: 768px) {\n  .notepad-container.normal-container {\n    width: 100vw;\n    height: 100vh;\n    max-width: 100vw;\n    max-height: 100vh;\n    border-radius: 0;\n  }\n  .tab-item {\n    min-width: 100px;\n    max-width: 150px;\n    font-size: 0.875rem;\n  }\n  .toolbar {\n    flex-wrap: wrap;\n    gap: 0.5rem;\n  }\n  .status-bar {\n    flex-direction: column;\n    align-items: flex-start;\n    gap: 0.5rem;\n  }\n}\n::-webkit-scrollbar {\n  width: 8px;\n  height: 8px;\n}\n::-webkit-scrollbar-track {\n  background: rgba(15, 23, 42, 0.5);\n}\n::-webkit-scrollbar-thumb {\n  background: rgba(56, 189, 248, 0.3);\n  border-radius: 4px;\n}\n::-webkit-scrollbar-thumb:hover {\n  background: rgba(56, 189, 248, 0.5);\n}\n* {\n  scrollbar-width: thin;\n  scrollbar-color: rgba(56, 189, 248, 0.3) rgba(15, 23, 42, 0.5);\n}\n/*# sourceMappingURL=notepad.component.css.map */\n'] }]
      }], () => [], { close: [{
        type: Output
      }], editorContainer: [{
        type: ViewChild,
        args: ["editorContainer", { static: false }]
      }] });
    })();
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NotepadComponent, { className: "NotepadComponent", filePath: "src/app/dashboard/notepad.component.ts", lineNumber: 52 });
    })();
  }
});

// node_modules/@mediapipe/face_mesh/face_mesh.js
var require_face_mesh = __commonJS({
  "node_modules/@mediapipe/face_mesh/face_mesh.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      var v;
      function aa(a) {
        var b = 0;
        return function() {
          return b < a.length ? { done: false, value: a[b++] } : { done: true };
        };
      }
      var ba = "function" == typeof Object.defineProperties ? Object.defineProperty : function(a, b, c) {
        if (a == Array.prototype || a == Object.prototype) return a;
        a[b] = c.value;
        return a;
      };
      function ca(a) {
        a = ["object" == typeof globalThis && globalThis, a, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global];
        for (var b = 0; b < a.length; ++b) {
          var c = a[b];
          if (c && c.Math == Math) return c;
        }
        throw Error("Cannot find global object");
      }
      var G = ca(this);
      function J(a, b) {
        if (b) a: {
          var c = G;
          a = a.split(".");
          for (var d = 0; d < a.length - 1; d++) {
            var e = a[d];
            if (!(e in c)) break a;
            c = c[e];
          }
          a = a[a.length - 1];
          d = c[a];
          b = b(d);
          b != d && null != b && ba(c, a, { configurable: true, writable: true, value: b });
        }
      }
      J("Symbol", function(a) {
        function b(g) {
          if (this instanceof b) throw new TypeError("Symbol is not a constructor");
          return new c(d + (g || "") + "_" + e++, g);
        }
        function c(g, f) {
          this.g = g;
          ba(this, "description", { configurable: true, writable: true, value: f });
        }
        if (a) return a;
        c.prototype.toString = function() {
          return this.g;
        };
        var d = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", e = 0;
        return b;
      });
      J("Symbol.iterator", function(a) {
        if (a) return a;
        a = Symbol("Symbol.iterator");
        for (var b = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), c = 0; c < b.length; c++) {
          var d = G[b[c]];
          "function" === typeof d && "function" != typeof d.prototype[a] && ba(d.prototype, a, { configurable: true, writable: true, value: function() {
            return da(aa(this));
          } });
        }
        return a;
      });
      function da(a) {
        a = { next: a };
        a[Symbol.iterator] = function() {
          return this;
        };
        return a;
      }
      function K(a) {
        var b = "undefined" != typeof Symbol && Symbol.iterator && a[Symbol.iterator];
        return b ? b.call(a) : { next: aa(a) };
      }
      function L(a) {
        if (!(a instanceof Array)) {
          a = K(a);
          for (var b, c = []; !(b = a.next()).done; ) c.push(b.value);
          a = c;
        }
        return a;
      }
      var ea = "function" == typeof Object.create ? Object.create : function(a) {
        function b() {
        }
        b.prototype = a;
        return new b();
      }, fa;
      if ("function" == typeof Object.setPrototypeOf) fa = Object.setPrototypeOf;
      else {
        var ha;
        a: {
          var ia = { a: true }, ja = {};
          try {
            ja.__proto__ = ia;
            ha = ja.a;
            break a;
          } catch (a) {
          }
          ha = false;
        }
        fa = ha ? function(a, b) {
          a.__proto__ = b;
          if (a.__proto__ !== b) throw new TypeError(a + " is not extensible");
          return a;
        } : null;
      }
      var ka = fa;
      function M(a, b) {
        a.prototype = ea(b.prototype);
        a.prototype.constructor = a;
        if (ka) ka(a, b);
        else for (var c in b) if ("prototype" != c) if (Object.defineProperties) {
          var d = Object.getOwnPropertyDescriptor(b, c);
          d && Object.defineProperty(a, c, d);
        } else a[c] = b[c];
        a.ea = b.prototype;
      }
      function ma() {
        this.l = false;
        this.i = null;
        this.h = void 0;
        this.g = 1;
        this.s = this.m = 0;
        this.j = null;
      }
      function na(a) {
        if (a.l) throw new TypeError("Generator is already running");
        a.l = true;
      }
      ma.prototype.o = function(a) {
        this.h = a;
      };
      function oa(a, b) {
        a.j = { U: b, V: true };
        a.g = a.m || a.s;
      }
      ma.prototype.return = function(a) {
        this.j = { return: a };
        this.g = this.s;
      };
      function N(a, b, c) {
        a.g = c;
        return { value: b };
      }
      function pa(a) {
        this.g = new ma();
        this.h = a;
      }
      function qa(a, b) {
        na(a.g);
        var c = a.g.i;
        if (c) return ra(a, "return" in c ? c["return"] : function(d) {
          return { value: d, done: true };
        }, b, a.g.return);
        a.g.return(b);
        return sa(a);
      }
      function ra(a, b, c, d) {
        try {
          var e = b.call(a.g.i, c);
          if (!(e instanceof Object)) throw new TypeError("Iterator result " + e + " is not an object");
          if (!e.done) return a.g.l = false, e;
          var g = e.value;
        } catch (f) {
          return a.g.i = null, oa(a.g, f), sa(a);
        }
        a.g.i = null;
        d.call(a.g, g);
        return sa(a);
      }
      function sa(a) {
        for (; a.g.g; ) try {
          var b = a.h(a.g);
          if (b) return a.g.l = false, { value: b.value, done: false };
        } catch (c) {
          a.g.h = void 0, oa(a.g, c);
        }
        a.g.l = false;
        if (a.g.j) {
          b = a.g.j;
          a.g.j = null;
          if (b.V) throw b.U;
          return { value: b.return, done: true };
        }
        return { value: void 0, done: true };
      }
      function ta(a) {
        this.next = function(b) {
          na(a.g);
          a.g.i ? b = ra(a, a.g.i.next, b, a.g.o) : (a.g.o(b), b = sa(a));
          return b;
        };
        this.throw = function(b) {
          na(a.g);
          a.g.i ? b = ra(a, a.g.i["throw"], b, a.g.o) : (oa(a.g, b), b = sa(a));
          return b;
        };
        this.return = function(b) {
          return qa(a, b);
        };
        this[Symbol.iterator] = function() {
          return this;
        };
      }
      function O(a, b) {
        b = new ta(new pa(b));
        ka && a.prototype && ka(b, a.prototype);
        return b;
      }
      function ua(a, b) {
        a instanceof String && (a += "");
        var c = 0, d = false, e = { next: function() {
          if (!d && c < a.length) {
            var g = c++;
            return { value: b(g, a[g]), done: false };
          }
          d = true;
          return { done: true, value: void 0 };
        } };
        e[Symbol.iterator] = function() {
          return e;
        };
        return e;
      }
      var va = "function" == typeof Object.assign ? Object.assign : function(a, b) {
        for (var c = 1; c < arguments.length; c++) {
          var d = arguments[c];
          if (d) for (var e in d) Object.prototype.hasOwnProperty.call(d, e) && (a[e] = d[e]);
        }
        return a;
      };
      J("Object.assign", function(a) {
        return a || va;
      });
      J("Promise", function(a) {
        function b(f) {
          this.h = 0;
          this.i = void 0;
          this.g = [];
          this.o = false;
          var h = this.j();
          try {
            f(h.resolve, h.reject);
          } catch (k) {
            h.reject(k);
          }
        }
        function c() {
          this.g = null;
        }
        function d(f) {
          return f instanceof b ? f : new b(function(h) {
            h(f);
          });
        }
        if (a) return a;
        c.prototype.h = function(f) {
          if (null == this.g) {
            this.g = [];
            var h = this;
            this.i(function() {
              h.l();
            });
          }
          this.g.push(f);
        };
        var e = G.setTimeout;
        c.prototype.i = function(f) {
          e(f, 0);
        };
        c.prototype.l = function() {
          for (; this.g && this.g.length; ) {
            var f = this.g;
            this.g = [];
            for (var h = 0; h < f.length; ++h) {
              var k = f[h];
              f[h] = null;
              try {
                k();
              } catch (l) {
                this.j(l);
              }
            }
          }
          this.g = null;
        };
        c.prototype.j = function(f) {
          this.i(function() {
            throw f;
          });
        };
        b.prototype.j = function() {
          function f(l) {
            return function(n) {
              k || (k = true, l.call(h, n));
            };
          }
          var h = this, k = false;
          return { resolve: f(this.C), reject: f(this.l) };
        };
        b.prototype.C = function(f) {
          if (f === this) this.l(new TypeError("A Promise cannot resolve to itself"));
          else if (f instanceof b) this.F(f);
          else {
            a: switch (typeof f) {
              case "object":
                var h = null != f;
                break a;
              case "function":
                h = true;
                break a;
              default:
                h = false;
            }
            h ? this.u(f) : this.m(f);
          }
        };
        b.prototype.u = function(f) {
          var h = void 0;
          try {
            h = f.then;
          } catch (k) {
            this.l(k);
            return;
          }
          "function" == typeof h ? this.G(h, f) : this.m(f);
        };
        b.prototype.l = function(f) {
          this.s(2, f);
        };
        b.prototype.m = function(f) {
          this.s(1, f);
        };
        b.prototype.s = function(f, h) {
          if (0 != this.h) throw Error("Cannot settle(" + f + ", " + h + "): Promise already settled in state" + this.h);
          this.h = f;
          this.i = h;
          2 === this.h && this.D();
          this.A();
        };
        b.prototype.D = function() {
          var f = this;
          e(function() {
            if (f.B()) {
              var h = G.console;
              "undefined" !== typeof h && h.error(f.i);
            }
          }, 1);
        };
        b.prototype.B = function() {
          if (this.o) return false;
          var f = G.CustomEvent, h = G.Event, k = G.dispatchEvent;
          if ("undefined" === typeof k) return true;
          "function" === typeof f ? f = new f("unhandledrejection", { cancelable: true }) : "function" === typeof h ? f = new h("unhandledrejection", { cancelable: true }) : (f = G.document.createEvent("CustomEvent"), f.initCustomEvent("unhandledrejection", false, true, f));
          f.promise = this;
          f.reason = this.i;
          return k(f);
        };
        b.prototype.A = function() {
          if (null != this.g) {
            for (var f = 0; f < this.g.length; ++f) g.h(this.g[f]);
            this.g = null;
          }
        };
        var g = new c();
        b.prototype.F = function(f) {
          var h = this.j();
          f.J(h.resolve, h.reject);
        };
        b.prototype.G = function(f, h) {
          var k = this.j();
          try {
            f.call(h, k.resolve, k.reject);
          } catch (l) {
            k.reject(l);
          }
        };
        b.prototype.then = function(f, h) {
          function k(w, r) {
            return "function" == typeof w ? function(y) {
              try {
                l(w(y));
              } catch (m) {
                n(m);
              }
            } : r;
          }
          var l, n, u2 = new b(function(w, r) {
            l = w;
            n = r;
          });
          this.J(k(f, l), k(h, n));
          return u2;
        };
        b.prototype.catch = function(f) {
          return this.then(void 0, f);
        };
        b.prototype.J = function(f, h) {
          function k() {
            switch (l.h) {
              case 1:
                f(l.i);
                break;
              case 2:
                h(l.i);
                break;
              default:
                throw Error("Unexpected state: " + l.h);
            }
          }
          var l = this;
          null == this.g ? g.h(k) : this.g.push(k);
          this.o = true;
        };
        b.resolve = d;
        b.reject = function(f) {
          return new b(function(h, k) {
            k(f);
          });
        };
        b.race = function(f) {
          return new b(function(h, k) {
            for (var l = K(f), n = l.next(); !n.done; n = l.next()) d(n.value).J(h, k);
          });
        };
        b.all = function(f) {
          var h = K(f), k = h.next();
          return k.done ? d([]) : new b(function(l, n) {
            function u2(y) {
              return function(m) {
                w[y] = m;
                r--;
                0 == r && l(w);
              };
            }
            var w = [], r = 0;
            do
              w.push(void 0), r++, d(k.value).J(u2(w.length - 1), n), k = h.next();
            while (!k.done);
          });
        };
        return b;
      });
      J("Object.is", function(a) {
        return a ? a : function(b, c) {
          return b === c ? 0 !== b || 1 / b === 1 / c : b !== b && c !== c;
        };
      });
      J("Array.prototype.includes", function(a) {
        return a ? a : function(b, c) {
          var d = this;
          d instanceof String && (d = String(d));
          var e = d.length;
          c = c || 0;
          for (0 > c && (c = Math.max(c + e, 0)); c < e; c++) {
            var g = d[c];
            if (g === b || Object.is(g, b)) return true;
          }
          return false;
        };
      });
      J("String.prototype.includes", function(a) {
        return a ? a : function(b, c) {
          if (null == this) throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");
          if (b instanceof RegExp) throw new TypeError("First argument to String.prototype.includes must not be a regular expression");
          return -1 !== this.indexOf(b, c || 0);
        };
      });
      J("Array.prototype.keys", function(a) {
        return a ? a : function() {
          return ua(this, function(b) {
            return b;
          });
        };
      });
      var wa = this || self;
      function P(a, b) {
        a = a.split(".");
        var c = wa;
        a[0] in c || "undefined" == typeof c.execScript || c.execScript("var " + a[0]);
        for (var d; a.length && (d = a.shift()); ) a.length || void 0 === b ? c[d] && c[d] !== Object.prototype[d] ? c = c[d] : c = c[d] = {} : c[d] = b;
      }
      ;
      function xa(a, b) {
        b = String.fromCharCode.apply(null, b);
        return null == a ? b : a + b;
      }
      var ya, za = "undefined" !== typeof TextDecoder, Aa, Ba = "undefined" !== typeof TextEncoder;
      function Ca(a) {
        if (Ba) a = (Aa || (Aa = new TextEncoder())).encode(a);
        else {
          var b = void 0;
          b = void 0 === b ? false : b;
          for (var c = 0, d = new Uint8Array(3 * a.length), e = 0; e < a.length; e++) {
            var g = a.charCodeAt(e);
            if (128 > g) d[c++] = g;
            else {
              if (2048 > g) d[c++] = g >> 6 | 192;
              else {
                if (55296 <= g && 57343 >= g) {
                  if (56319 >= g && e < a.length) {
                    var f = a.charCodeAt(++e);
                    if (56320 <= f && 57343 >= f) {
                      g = 1024 * (g - 55296) + f - 56320 + 65536;
                      d[c++] = g >> 18 | 240;
                      d[c++] = g >> 12 & 63 | 128;
                      d[c++] = g >> 6 & 63 | 128;
                      d[c++] = g & 63 | 128;
                      continue;
                    } else e--;
                  }
                  if (b) throw Error("Found an unpaired surrogate");
                  g = 65533;
                }
                d[c++] = g >> 12 | 224;
                d[c++] = g >> 6 & 63 | 128;
              }
              d[c++] = g & 63 | 128;
            }
          }
          a = d.subarray(0, c);
        }
        return a;
      }
      ;
      var Da = {}, Ea = null;
      function Fa(a, b) {
        void 0 === b && (b = 0);
        Ga();
        b = Da[b];
        for (var c = Array(Math.floor(a.length / 3)), d = b[64] || "", e = 0, g = 0; e < a.length - 2; e += 3) {
          var f = a[e], h = a[e + 1], k = a[e + 2], l = b[f >> 2];
          f = b[(f & 3) << 4 | h >> 4];
          h = b[(h & 15) << 2 | k >> 6];
          k = b[k & 63];
          c[g++] = l + f + h + k;
        }
        l = 0;
        k = d;
        switch (a.length - e) {
          case 2:
            l = a[e + 1], k = b[(l & 15) << 2] || d;
          case 1:
            a = a[e], c[g] = b[a >> 2] + b[(a & 3) << 4 | l >> 4] + k + d;
        }
        return c.join("");
      }
      function Ha(a) {
        var b = a.length, c = 3 * b / 4;
        c % 3 ? c = Math.floor(c) : -1 != "=.".indexOf(a[b - 1]) && (c = -1 != "=.".indexOf(a[b - 2]) ? c - 2 : c - 1);
        var d = new Uint8Array(c), e = 0;
        Ia(a, function(g) {
          d[e++] = g;
        });
        return d.subarray(0, e);
      }
      function Ia(a, b) {
        function c(k) {
          for (; d < a.length; ) {
            var l = a.charAt(d++), n = Ea[l];
            if (null != n) return n;
            if (!/^[\s\xa0]*$/.test(l)) throw Error("Unknown base64 encoding at char: " + l);
          }
          return k;
        }
        Ga();
        for (var d = 0; ; ) {
          var e = c(-1), g = c(0), f = c(64), h = c(64);
          if (64 === h && -1 === e) break;
          b(e << 2 | g >> 4);
          64 != f && (b(g << 4 & 240 | f >> 2), 64 != h && b(f << 6 & 192 | h));
        }
      }
      function Ga() {
        if (!Ea) {
          Ea = {};
          for (var a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), b = ["+/=", "+/", "-_=", "-_.", "-_"], c = 0; 5 > c; c++) {
            var d = a.concat(b[c].split(""));
            Da[c] = d;
            for (var e = 0; e < d.length; e++) {
              var g = d[e];
              void 0 === Ea[g] && (Ea[g] = e);
            }
          }
        }
      }
      ;
      var Ja = "function" === typeof Uint8Array.prototype.slice, Ka;
      function La(a, b, c) {
        return b === c ? Ka || (Ka = new Uint8Array(0)) : Ja ? a.slice(b, c) : new Uint8Array(a.subarray(b, c));
      }
      var Q = 0, R = 0;
      function Ma(a, b) {
        b = void 0 === b ? {} : b;
        b = void 0 === b.v ? false : b.v;
        this.h = null;
        this.g = this.j = this.l = 0;
        this.m = false;
        this.v = b;
        a && Na(this, a);
      }
      function Na(a, b) {
        b = b.constructor === Uint8Array ? b : b.constructor === ArrayBuffer ? new Uint8Array(b) : b.constructor === Array ? new Uint8Array(b) : b.constructor === String ? Ha(b) : b instanceof Uint8Array ? new Uint8Array(b.buffer, b.byteOffset, b.byteLength) : new Uint8Array(0);
        a.h = b;
        a.l = 0;
        a.j = a.h.length;
        a.g = a.l;
      }
      Ma.prototype.reset = function() {
        this.g = this.l;
      };
      function Oa(a) {
        for (var b = 128, c = 0, d = 0, e = 0; 4 > e && 128 <= b; e++) b = a.h[a.g++], c |= (b & 127) << 7 * e;
        128 <= b && (b = a.h[a.g++], c |= (b & 127) << 28, d |= (b & 127) >> 4);
        if (128 <= b) for (e = 0; 5 > e && 128 <= b; e++) b = a.h[a.g++], d |= (b & 127) << 7 * e + 3;
        if (128 > b) {
          a = c >>> 0;
          b = d >>> 0;
          if (d = b & 2147483648) a = ~a + 1 >>> 0, b = ~b >>> 0, 0 == a && (b = b + 1 >>> 0);
          a = 4294967296 * b + (a >>> 0);
          return d ? -a : a;
        }
        a.m = true;
      }
      Ma.prototype.i = function() {
        var a = this.h, b = a[this.g], c = b & 127;
        if (128 > b) return this.g += 1, c;
        b = a[this.g + 1];
        c |= (b & 127) << 7;
        if (128 > b) return this.g += 2, c;
        b = a[this.g + 2];
        c |= (b & 127) << 14;
        if (128 > b) return this.g += 3, c;
        b = a[this.g + 3];
        c |= (b & 127) << 21;
        if (128 > b) return this.g += 4, c;
        b = a[this.g + 4];
        c |= (b & 15) << 28;
        if (128 > b) return this.g += 5, c >>> 0;
        this.g += 5;
        128 <= a[this.g++] && 128 <= a[this.g++] && 128 <= a[this.g++] && 128 <= a[this.g++] && this.g++;
        return c;
      };
      Ma.prototype.o = function() {
        var a = this.h[this.g], b = this.h[this.g + 1];
        var c = this.h[this.g + 2];
        var d = this.h[this.g + 3];
        this.g += 4;
        c = (a << 0 | b << 8 | c << 16 | d << 24) >>> 0;
        a = 2 * (c >> 31) + 1;
        b = c >>> 23 & 255;
        c &= 8388607;
        return 255 == b ? c ? NaN : Infinity * a : 0 == b ? a * Math.pow(2, -149) * c : a * Math.pow(2, b - 150) * (c + Math.pow(2, 23));
      };
      var Pa = [];
      function Qa() {
        this.g = new Uint8Array(64);
        this.h = 0;
      }
      Qa.prototype.push = function(a) {
        if (!(this.h + 1 < this.g.length)) {
          var b = this.g;
          this.g = new Uint8Array(Math.ceil(1 + 2 * this.g.length));
          this.g.set(b);
        }
        this.g[this.h++] = a;
      };
      Qa.prototype.length = function() {
        return this.h;
      };
      Qa.prototype.end = function() {
        var a = this.g, b = this.h;
        this.h = 0;
        return La(a, 0, b);
      };
      function Ra(a, b) {
        for (; 127 < b; ) a.push(b & 127 | 128), b >>>= 7;
        a.push(b);
      }
      ;
      function Sa(a) {
        var b = {}, c = void 0 === b.N ? false : b.N;
        this.o = { v: void 0 === b.v ? false : b.v };
        this.N = c;
        b = this.o;
        Pa.length ? (c = Pa.pop(), b && (c.v = b.v), a && Na(c, a), a = c) : a = new Ma(a, b);
        this.g = a;
        this.m = this.g.g;
        this.h = this.i = this.l = -1;
        this.j = false;
      }
      Sa.prototype.reset = function() {
        this.g.reset();
        this.h = this.l = -1;
      };
      function S2(a) {
        var b = a.g;
        (b = b.g == b.j) || (b = a.j) || (b = a.g, b = b.m || 0 > b.g || b.g > b.j);
        if (b) return false;
        a.m = a.g.g;
        b = a.g.i();
        var c = b & 7;
        if (0 != c && 5 != c && 1 != c && 2 != c && 3 != c && 4 != c) return a.j = true, false;
        a.i = b;
        a.l = b >>> 3;
        a.h = c;
        return true;
      }
      function Ta(a) {
        switch (a.h) {
          case 0:
            if (0 != a.h) Ta(a);
            else {
              for (a = a.g; a.h[a.g] & 128; ) a.g++;
              a.g++;
            }
            break;
          case 1:
            1 != a.h ? Ta(a) : (a = a.g, a.g += 8);
            break;
          case 2:
            if (2 != a.h) Ta(a);
            else {
              var b = a.g.i();
              a = a.g;
              a.g += b;
            }
            break;
          case 5:
            5 != a.h ? Ta(a) : (a = a.g, a.g += 4);
            break;
          case 3:
            b = a.l;
            do {
              if (!S2(a)) {
                a.j = true;
                break;
              }
              if (4 == a.h) {
                a.l != b && (a.j = true);
                break;
              }
              Ta(a);
            } while (1);
            break;
          default:
            a.j = true;
        }
      }
      function Ua(a, b, c) {
        var d = a.g.j, e = a.g.i(), g = a.g.g + e;
        a.g.j = g;
        c(b, a);
        c = g - a.g.g;
        if (0 !== c) throw Error("Message parsing ended unexpectedly. Expected to read " + e + " bytes, instead read " + (e - c) + " bytes, either the data ended unexpectedly or the message misreported its own length");
        a.g.g = g;
        a.g.j = d;
        return b;
      }
      function T(a) {
        return a.g.o();
      }
      function Va(a) {
        var b = a.g.i();
        a = a.g;
        var c = a.g;
        a.g += b;
        a = a.h;
        var d;
        if (za) (d = ya) || (d = ya = new TextDecoder("utf-8", { fatal: false })), d = d.decode(a.subarray(c, c + b));
        else {
          b = c + b;
          for (var e = [], g = null, f, h, k; c < b; ) f = a[c++], 128 > f ? e.push(f) : 224 > f ? c >= b ? e.push(65533) : (h = a[c++], 194 > f || 128 !== (h & 192) ? (c--, e.push(65533)) : e.push((f & 31) << 6 | h & 63)) : 240 > f ? c >= b - 1 ? e.push(65533) : (h = a[c++], 128 !== (h & 192) || 224 === f && 160 > h || 237 === f && 160 <= h || 128 !== ((d = a[c++]) & 192) ? (c--, e.push(65533)) : e.push((f & 15) << 12 | (h & 63) << 6 | d & 63)) : 244 >= f ? c >= b - 2 ? e.push(65533) : (h = a[c++], 128 !== (h & 192) || 0 !== (f << 28) + (h - 144) >> 30 || 128 !== ((d = a[c++]) & 192) || 128 !== ((k = a[c++]) & 192) ? (c--, e.push(65533)) : (f = (f & 7) << 18 | (h & 63) << 12 | (d & 63) << 6 | k & 63, f -= 65536, e.push((f >> 10 & 1023) + 55296, (f & 1023) + 56320))) : e.push(65533), 8192 <= e.length && (g = xa(g, e), e.length = 0);
          d = xa(g, e);
        }
        return d;
      }
      function Wa(a, b, c) {
        var d = a.g.i();
        for (d = a.g.g + d; a.g.g < d; ) c.push(b.call(a.g));
      }
      function Xa(a, b) {
        2 == a.h ? Wa(a, Ma.prototype.o, b) : b.push(T(a));
      }
      ;
      function Ya() {
        this.h = [];
        this.i = 0;
        this.g = new Qa();
      }
      function Za(a, b) {
        0 !== b.length && (a.h.push(b), a.i += b.length);
      }
      function $a(a) {
        var b = a.i + a.g.length();
        if (0 === b) return new Uint8Array(0);
        b = new Uint8Array(b);
        for (var c = a.h, d = c.length, e = 0, g = 0; g < d; g++) {
          var f = c[g];
          0 !== f.length && (b.set(f, e), e += f.length);
        }
        c = a.g;
        d = c.h;
        0 !== d && (b.set(c.g.subarray(0, d), e), c.h = 0);
        a.h = [b];
        return b;
      }
      function U(a, b, c) {
        if (null != c) {
          Ra(a.g, 8 * b + 5);
          a = a.g;
          var d = c;
          d = (c = 0 > d ? 1 : 0) ? -d : d;
          0 === d ? 0 < 1 / d ? Q = R = 0 : (R = 0, Q = 2147483648) : isNaN(d) ? (R = 0, Q = 2147483647) : 34028234663852886e22 < d ? (R = 0, Q = (c << 31 | 2139095040) >>> 0) : 11754943508222875e-54 > d ? (d = Math.round(d / Math.pow(2, -149)), R = 0, Q = (c << 31 | d) >>> 0) : (b = Math.floor(Math.log(d) / Math.LN2), d *= Math.pow(2, -b), d = Math.round(8388608 * d), 16777216 <= d && ++b, R = 0, Q = (c << 31 | b + 127 << 23 | d & 8388607) >>> 0);
          c = Q;
          a.push(c >>> 0 & 255);
          a.push(c >>> 8 & 255);
          a.push(c >>> 16 & 255);
          a.push(c >>> 24 & 255);
        }
      }
      ;
      var ab = "function" === typeof Uint8Array;
      function bb(a, b, c) {
        if (null != a) return "object" === typeof a ? ab && a instanceof Uint8Array ? c(a) : cb(a, b, c) : b(a);
      }
      function cb(a, b, c) {
        if (Array.isArray(a)) {
          for (var d = Array(a.length), e = 0; e < a.length; e++) d[e] = bb(a[e], b, c);
          Array.isArray(a) && a.W && db(d);
          return d;
        }
        d = {};
        for (e in a) d[e] = bb(a[e], b, c);
        return d;
      }
      function eb(a) {
        return "number" === typeof a ? isFinite(a) ? a : String(a) : a;
      }
      var fb = { W: { value: true, configurable: true } };
      function db(a) {
        Array.isArray(a) && !Object.isFrozen(a) && Object.defineProperties(a, fb);
        return a;
      }
      ;
      var gb;
      function V(a, b, c) {
        var d = gb;
        gb = null;
        a || (a = d);
        d = this.constructor.ca;
        a || (a = d ? [d] : []);
        this.j = d ? 0 : -1;
        this.m = this.g = null;
        this.h = a;
        a: {
          d = this.h.length;
          a = d - 1;
          if (d && (d = this.h[a], !(null === d || "object" != typeof d || Array.isArray(d) || ab && d instanceof Uint8Array))) {
            this.l = a - this.j;
            this.i = d;
            break a;
          }
          void 0 !== b && -1 < b ? (this.l = Math.max(b, a + 1 - this.j), this.i = null) : this.l = Number.MAX_VALUE;
        }
        if (c) for (b = 0; b < c.length; b++) a = c[b], a < this.l ? (a += this.j, (d = this.h[a]) ? db(d) : this.h[a] = hb) : (ib(this), (d = this.i[a]) ? db(d) : this.i[a] = hb);
      }
      var hb = Object.freeze(db([]));
      function ib(a) {
        var b = a.l + a.j;
        a.h[b] || (a.i = a.h[b] = {});
      }
      function W(a, b, c) {
        return -1 === b ? null : (void 0 === c ? 0 : c) || b >= a.l ? a.i ? a.i[b] : void 0 : a.h[b + a.j];
      }
      function jb(a, b) {
        var c = void 0 === c ? false : c;
        var d = W(a, b, c);
        null == d && (d = hb);
        d === hb && (d = db([]), X(a, b, d, c));
        return d;
      }
      function kb(a) {
        var b = jb(a, 3);
        a.m || (a.m = {});
        if (!a.m[3]) {
          for (var c = 0; c < b.length; c++) b[c] = +b[c];
          a.m[3] = true;
        }
        return b;
      }
      function lb(a, b, c) {
        a = W(a, b);
        return null == a ? c : a;
      }
      function Y(a, b, c) {
        a = W(a, b);
        a = null == a ? a : +a;
        return null == a ? void 0 === c ? 0 : c : a;
      }
      function X(a, b, c, d) {
        (void 0 === d ? 0 : d) || b >= a.l ? (ib(a), a.i[b] = c) : a.h[b + a.j] = c;
      }
      function mb(a, b, c) {
        if (-1 === c) return null;
        a.g || (a.g = {});
        if (!a.g[c]) {
          var d = W(a, c, false);
          d && (a.g[c] = new b(d));
        }
        return a.g[c];
      }
      function nb(a, b) {
        a.g || (a.g = {});
        var c = a.g[1];
        if (!c) {
          var d = jb(a, 1);
          c = [];
          for (var e = 0; e < d.length; e++) c[e] = new b(d[e]);
          a.g[1] = c;
        }
        return c;
      }
      function ob(a, b, c) {
        var d = void 0 === d ? false : d;
        a.g || (a.g = {});
        var e = c ? pb(c, false) : c;
        a.g[b] = c;
        X(a, b, e, d);
      }
      function qb(a, b, c, d) {
        var e = nb(a, c);
        b = b ? b : new c();
        a = jb(a, 1);
        void 0 != d ? (e.splice(d, 0, b), a.splice(d, 0, pb(b, false))) : (e.push(b), a.push(pb(b, false)));
      }
      V.prototype.toJSON = function() {
        var a = pb(this, false);
        return cb(a, eb, Fa);
      };
      function pb(a, b) {
        if (a.g) for (var c in a.g) {
          var d = a.g[c];
          if (Array.isArray(d)) for (var e = 0; e < d.length; e++) d[e] && pb(d[e], b);
          else d && pb(d, b);
        }
        return a.h;
      }
      V.prototype.toString = function() {
        return pb(this, false).toString();
      };
      function rb(a, b) {
        if (a = a.o) {
          Za(b, b.g.end());
          for (var c = 0; c < a.length; c++) Za(b, a[c]);
        }
      }
      function sb(a, b) {
        if (4 == b.h) return false;
        var c = b.m;
        Ta(b);
        b.N || (b = La(b.g.h, c, b.g.g), (c = a.o) ? c.push(b) : a.o = [b]);
        return true;
      }
      ;
      function tb(a) {
        V.call(this, a, -1, ub);
      }
      M(tb, V);
      tb.prototype.getRows = function() {
        return W(this, 1);
      };
      tb.prototype.getCols = function() {
        return W(this, 2);
      };
      tb.prototype.getPackedDataList = function() {
        return kb(this);
      };
      tb.prototype.getLayout = function() {
        return lb(this, 4, 0);
      };
      function vb(a, b) {
        for (; S2(b); ) switch (b.i) {
          case 8:
            var c = b.g.i();
            X(a, 1, c);
            break;
          case 16:
            c = b.g.i();
            X(a, 2, c);
            break;
          case 29:
          case 26:
            Xa(b, a.getPackedDataList());
            break;
          case 32:
            c = Oa(b.g);
            X(a, 4, c);
            break;
          default:
            if (!sb(a, b)) return a;
        }
        return a;
      }
      var ub = [3];
      function Z(a, b) {
        var c = void 0;
        return new (c || (c = Promise))(function(d, e) {
          function g(k) {
            try {
              h(b.next(k));
            } catch (l) {
              e(l);
            }
          }
          function f(k) {
            try {
              h(b["throw"](k));
            } catch (l) {
              e(l);
            }
          }
          function h(k) {
            k.done ? d(k.value) : new c(function(l) {
              l(k.value);
            }).then(g, f);
          }
          h((b = b.apply(a, void 0)).next());
        });
      }
      ;
      function wb(a) {
        V.call(this, a);
      }
      M(wb, V);
      function xb(a, b) {
        for (; S2(b); ) switch (b.i) {
          case 8:
            var c = b.g.i();
            X(a, 1, c);
            break;
          case 21:
            c = T(b);
            X(a, 2, c);
            break;
          case 26:
            c = Va(b);
            X(a, 3, c);
            break;
          case 34:
            c = Va(b);
            X(a, 4, c);
            break;
          default:
            if (!sb(a, b)) return a;
        }
        return a;
      }
      ;
      function yb(a) {
        V.call(this, a, -1, zb);
      }
      M(yb, V);
      yb.prototype.addClassification = function(a, b) {
        qb(this, a, wb, b);
        return this;
      };
      var zb = [1];
      function Ab(a) {
        V.call(this, a);
      }
      M(Ab, V);
      function Bb(a, b) {
        for (; S2(b); ) switch (b.i) {
          case 13:
            var c = T(b);
            X(a, 1, c);
            break;
          case 21:
            c = T(b);
            X(a, 2, c);
            break;
          case 29:
            c = T(b);
            X(a, 3, c);
            break;
          case 37:
            c = T(b);
            X(a, 4, c);
            break;
          case 45:
            c = T(b);
            X(a, 5, c);
            break;
          default:
            if (!sb(a, b)) return a;
        }
        return a;
      }
      ;
      function Cb(a) {
        V.call(this, a, -1, Db);
      }
      M(Cb, V);
      function Eb(a) {
        a: {
          var b = new Cb();
          for (a = new Sa(a); S2(a); ) switch (a.i) {
            case 10:
              var c = Ua(a, new Ab(), Bb);
              qb(b, c, Ab, void 0);
              break;
            default:
              if (!sb(b, a)) break a;
          }
        }
        return b;
      }
      var Db = [1];
      function Fb(a) {
        V.call(this, a);
      }
      M(Fb, V);
      function Gb(a) {
        V.call(this, a, -1, Hb);
      }
      M(Gb, V);
      Gb.prototype.getVertexType = function() {
        return lb(this, 1, 0);
      };
      Gb.prototype.getPrimitiveType = function() {
        return lb(this, 2, 0);
      };
      Gb.prototype.getVertexBufferList = function() {
        return kb(this);
      };
      Gb.prototype.getIndexBufferList = function() {
        return jb(this, 4);
      };
      function Ib(a, b) {
        for (; S2(b); ) switch (b.i) {
          case 8:
            var c = Oa(b.g);
            X(a, 1, c);
            break;
          case 16:
            c = Oa(b.g);
            X(a, 2, c);
            break;
          case 29:
          case 26:
            Xa(b, a.getVertexBufferList());
            break;
          case 32:
          case 34:
            c = b;
            var d = a.getIndexBufferList();
            2 == c.h ? Wa(c, Ma.prototype.i, d) : d.push(c.g.i());
            break;
          default:
            if (!sb(a, b)) return a;
        }
        return a;
      }
      var Hb = [3, 4];
      function Jb(a) {
        V.call(this, a);
      }
      M(Jb, V);
      Jb.prototype.getMesh = function() {
        return mb(this, Gb, 1);
      };
      Jb.prototype.getPoseTransformMatrix = function() {
        return mb(this, tb, 2);
      };
      function Kb(a) {
        a: {
          var b = new Jb();
          for (a = new Sa(a); S2(a); ) switch (a.i) {
            case 10:
              var c = Ua(a, new Gb(), Ib);
              ob(b, 1, c);
              break;
            case 18:
              c = Ua(a, new tb(), vb);
              ob(b, 2, c);
              break;
            default:
              if (!sb(b, a)) break a;
          }
        }
        return b;
      }
      ;
      function Lb(a, b, c) {
        c = a.createShader(0 === c ? a.VERTEX_SHADER : a.FRAGMENT_SHADER);
        a.shaderSource(c, b);
        a.compileShader(c);
        if (!a.getShaderParameter(c, a.COMPILE_STATUS)) throw Error("Could not compile WebGL shader.\n\n" + a.getShaderInfoLog(c));
        return c;
      }
      ;
      function Mb(a) {
        return nb(a, wb).map(function(b) {
          return { index: lb(b, 1, 0), Y: Y(b, 2), label: null != W(b, 3) ? lb(b, 3, "") : void 0, displayName: null != W(b, 4) ? lb(b, 4, "") : void 0 };
        });
      }
      ;
      function Nb(a) {
        return { x: Y(a, 1), y: Y(a, 2), z: Y(a, 3), visibility: null != W(a, 4) ? Y(a, 4) : void 0 };
      }
      ;
      function Ob(a, b) {
        this.h = a;
        this.g = b;
        this.l = 0;
      }
      function Pb(a, b, c) {
        Qb(a, b);
        if ("function" === typeof a.g.canvas.transferToImageBitmap) return Promise.resolve(a.g.canvas.transferToImageBitmap());
        if (c) return Promise.resolve(a.g.canvas);
        if ("function" === typeof createImageBitmap) return createImageBitmap(a.g.canvas);
        void 0 === a.i && (a.i = document.createElement("canvas"));
        return new Promise(function(d) {
          a.i.height = a.g.canvas.height;
          a.i.width = a.g.canvas.width;
          a.i.getContext("2d", {}).drawImage(a.g.canvas, 0, 0, a.g.canvas.width, a.g.canvas.height);
          d(a.i);
        });
      }
      function Qb(a, b) {
        var c = a.g;
        if (void 0 === a.m) {
          var d = Lb(c, "\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }", 0), e = Lb(c, "\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }", 1), g = c.createProgram();
          c.attachShader(g, d);
          c.attachShader(g, e);
          c.linkProgram(g);
          if (!c.getProgramParameter(g, c.LINK_STATUS)) throw Error("Could not compile WebGL program.\n\n" + c.getProgramInfoLog(g));
          d = a.m = g;
          c.useProgram(d);
          e = c.getUniformLocation(d, "sampler0");
          a.j = { I: c.getAttribLocation(d, "aVertex"), H: c.getAttribLocation(d, "aTex"), da: e };
          a.s = c.createBuffer();
          c.bindBuffer(c.ARRAY_BUFFER, a.s);
          c.enableVertexAttribArray(a.j.I);
          c.vertexAttribPointer(a.j.I, 2, c.FLOAT, false, 0, 0);
          c.bufferData(c.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), c.STATIC_DRAW);
          c.bindBuffer(c.ARRAY_BUFFER, null);
          a.o = c.createBuffer();
          c.bindBuffer(c.ARRAY_BUFFER, a.o);
          c.enableVertexAttribArray(a.j.H);
          c.vertexAttribPointer(
            a.j.H,
            2,
            c.FLOAT,
            false,
            0,
            0
          );
          c.bufferData(c.ARRAY_BUFFER, new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]), c.STATIC_DRAW);
          c.bindBuffer(c.ARRAY_BUFFER, null);
          c.uniform1i(e, 0);
        }
        d = a.j;
        c.useProgram(a.m);
        c.canvas.width = b.width;
        c.canvas.height = b.height;
        c.viewport(0, 0, b.width, b.height);
        c.activeTexture(c.TEXTURE0);
        a.h.bindTexture2d(b.glName);
        c.enableVertexAttribArray(d.I);
        c.bindBuffer(c.ARRAY_BUFFER, a.s);
        c.vertexAttribPointer(d.I, 2, c.FLOAT, false, 0, 0);
        c.enableVertexAttribArray(d.H);
        c.bindBuffer(c.ARRAY_BUFFER, a.o);
        c.vertexAttribPointer(
          d.H,
          2,
          c.FLOAT,
          false,
          0,
          0
        );
        c.bindFramebuffer(c.DRAW_FRAMEBUFFER ? c.DRAW_FRAMEBUFFER : c.FRAMEBUFFER, null);
        c.clearColor(0, 0, 0, 0);
        c.clear(c.COLOR_BUFFER_BIT);
        c.colorMask(true, true, true, true);
        c.drawArrays(c.TRIANGLE_FAN, 0, 4);
        c.disableVertexAttribArray(d.I);
        c.disableVertexAttribArray(d.H);
        c.bindBuffer(c.ARRAY_BUFFER, null);
        a.h.bindTexture2d(0);
      }
      function Rb(a) {
        this.g = a;
      }
      ;
      var Sb = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11]);
      function Tb(a, b) {
        return b + a;
      }
      function Ub(a, b) {
        window[a] = b;
      }
      function Vb(a) {
        var b = document.createElement("script");
        b.setAttribute("src", a);
        b.setAttribute("crossorigin", "anonymous");
        return new Promise(function(c) {
          b.addEventListener("load", function() {
            c();
          }, false);
          b.addEventListener("error", function() {
            c();
          }, false);
          document.body.appendChild(b);
        });
      }
      function Wb() {
        return Z(this, function b() {
          return O(b, function(c) {
            switch (c.g) {
              case 1:
                return c.m = 2, N(c, WebAssembly.instantiate(Sb), 4);
              case 4:
                c.g = 3;
                c.m = 0;
                break;
              case 2:
                return c.m = 0, c.j = null, c.return(false);
              case 3:
                return c.return(true);
            }
          });
        });
      }
      function Xb(a) {
        this.g = a;
        this.listeners = {};
        this.j = {};
        this.F = {};
        this.m = {};
        this.s = {};
        this.G = this.o = this.R = true;
        this.C = Promise.resolve();
        this.P = "";
        this.B = {};
        this.locateFile = a && a.locateFile || Tb;
        if ("object" === typeof window) var b = window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf("/")) + "/";
        else if ("undefined" !== typeof location) b = location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf("/")) + "/";
        else throw Error("solutions can only be loaded on a web page or in a web worker");
        this.S = b;
        if (a.options) {
          b = K(Object.keys(a.options));
          for (var c = b.next(); !c.done; c = b.next()) {
            c = c.value;
            var d = a.options[c].default;
            void 0 !== d && (this.j[c] = "function" === typeof d ? d() : d);
          }
        }
      }
      v = Xb.prototype;
      v.close = function() {
        this.i && this.i.delete();
        return Promise.resolve();
      };
      function Yb(a, b) {
        return void 0 === a.g.files ? [] : "function" === typeof a.g.files ? a.g.files(b) : a.g.files;
      }
      function Zb(a) {
        return Z(a, function c() {
          var d = this, e, g, f, h, k, l, n, u2, w, r, y;
          return O(c, function(m) {
            switch (m.g) {
              case 1:
                e = d;
                if (!d.R) return m.return();
                g = Yb(d, d.j);
                return N(m, Wb(), 2);
              case 2:
                f = m.h;
                if ("object" === typeof window) return Ub("createMediapipeSolutionsWasm", { locateFile: d.locateFile }), Ub("createMediapipeSolutionsPackedAssets", { locateFile: d.locateFile }), l = g.filter(function(t2) {
                  return void 0 !== t2.data;
                }), n = g.filter(function(t2) {
                  return void 0 === t2.data;
                }), u2 = Promise.all(l.map(function(t2) {
                  var x = $b(e, t2.url);
                  if (void 0 !== t2.path) {
                    var z = t2.path;
                    x = x.then(function(E) {
                      e.overrideFile(z, E);
                      return Promise.resolve(E);
                    });
                  }
                  return x;
                })), w = Promise.all(n.map(function(t2) {
                  return void 0 === t2.simd || t2.simd && f || !t2.simd && !f ? Vb(e.locateFile(t2.url, e.S)) : Promise.resolve();
                })).then(function() {
                  return Z(e, function x() {
                    var z, E, F = this;
                    return O(x, function(I) {
                      if (1 == I.g) return z = window.createMediapipeSolutionsWasm, E = window.createMediapipeSolutionsPackedAssets, N(I, z(E), 2);
                      F.h = I.h;
                      I.g = 0;
                    });
                  });
                }), r = function() {
                  return Z(e, function x() {
                    var z = this;
                    return O(x, function(E) {
                      z.g.graph && z.g.graph.url ? E = N(E, $b(z, z.g.graph.url), 0) : (E.g = 0, E = void 0);
                      return E;
                    });
                  });
                }(), N(m, Promise.all([w, u2, r]), 7);
                if ("function" !== typeof importScripts) throw Error("solutions can only be loaded on a web page or in a web worker");
                h = g.filter(function(t2) {
                  return void 0 === t2.simd || t2.simd && f || !t2.simd && !f;
                }).map(function(t2) {
                  return e.locateFile(t2.url, e.S);
                });
                importScripts.apply(null, L(h));
                return N(m, createMediapipeSolutionsWasm(Module), 6);
              case 6:
                d.h = m.h;
                d.l = new OffscreenCanvas(1, 1);
                d.h.canvas = d.l;
                k = d.h.GL.createContext(
                  d.l,
                  { antialias: false, alpha: false, ba: "undefined" !== typeof WebGL2RenderingContext ? 2 : 1 }
                );
                d.h.GL.makeContextCurrent(k);
                m.g = 4;
                break;
              case 7:
                d.l = document.createElement("canvas");
                y = d.l.getContext("webgl2", {});
                if (!y && (y = d.l.getContext("webgl", {}), !y)) return alert("Failed to create WebGL canvas context when passing video frame."), m.return();
                d.D = y;
                d.h.canvas = d.l;
                d.h.createContext(d.l, true, true, {});
              case 4:
                d.i = new d.h.SolutionWasm(), d.R = false, m.g = 0;
            }
          });
        });
      }
      function ac(a) {
        return Z(a, function c() {
          var d = this, e, g, f, h, k, l, n, u2;
          return O(c, function(w) {
            if (1 == w.g) {
              if (d.g.graph && d.g.graph.url && d.P === d.g.graph.url) return w.return();
              d.o = true;
              if (!d.g.graph || !d.g.graph.url) {
                w.g = 2;
                return;
              }
              d.P = d.g.graph.url;
              return N(w, $b(d, d.g.graph.url), 3);
            }
            2 != w.g && (e = w.h, d.i.loadGraph(e));
            g = K(Object.keys(d.B));
            for (f = g.next(); !f.done; f = g.next()) h = f.value, d.i.overrideFile(h, d.B[h]);
            d.B = {};
            if (d.g.listeners) for (k = K(d.g.listeners), l = k.next(); !l.done; l = k.next()) n = l.value, bc(d, n);
            u2 = d.j;
            d.j = {};
            d.setOptions(u2);
            w.g = 0;
          });
        });
      }
      v.reset = function() {
        return Z(this, function b() {
          var c = this;
          return O(b, function(d) {
            c.i && (c.i.reset(), c.m = {}, c.s = {});
            d.g = 0;
          });
        });
      };
      v.setOptions = function(a, b) {
        var c = this;
        if (b = b || this.g.options) {
          for (var d = [], e = [], g = {}, f = K(Object.keys(a)), h = f.next(); !h.done; g = { K: g.K, L: g.L }, h = f.next()) {
            var k = h.value;
            k in this.j && this.j[k] === a[k] || (this.j[k] = a[k], h = b[k], void 0 !== h && (h.onChange && (g.K = h.onChange, g.L = a[k], d.push(/* @__PURE__ */ function(l) {
              return function() {
                return Z(c, function u2() {
                  var w, r = this;
                  return O(u2, function(y) {
                    if (1 == y.g) return N(y, l.K(l.L), 2);
                    w = y.h;
                    true === w && (r.o = true);
                    y.g = 0;
                  });
                });
              };
            }(g))), h.graphOptionXref && (k = { valueNumber: 1 === h.type ? a[k] : 0, valueBoolean: 0 === h.type ? a[k] : false, valueString: 2 === h.type ? a[k] : "" }, h = Object.assign(Object.assign(Object.assign({}, { calculatorName: "", calculatorIndex: 0 }), h.graphOptionXref), k), e.push(h))));
          }
          if (0 !== d.length || 0 !== e.length) this.o = true, this.A = (void 0 === this.A ? [] : this.A).concat(e), this.u = (void 0 === this.u ? [] : this.u).concat(d);
        }
      };
      function cc(a) {
        return Z(a, function c() {
          var d = this, e, g, f, h, k, l, n;
          return O(c, function(u2) {
            switch (u2.g) {
              case 1:
                if (!d.o) return u2.return();
                if (!d.u) {
                  u2.g = 2;
                  break;
                }
                e = K(d.u);
                g = e.next();
              case 3:
                if (g.done) {
                  u2.g = 5;
                  break;
                }
                f = g.value;
                return N(u2, f(), 4);
              case 4:
                g = e.next();
                u2.g = 3;
                break;
              case 5:
                d.u = void 0;
              case 2:
                if (d.A) {
                  h = new d.h.GraphOptionChangeRequestList();
                  k = K(d.A);
                  for (l = k.next(); !l.done; l = k.next()) n = l.value, h.push_back(n);
                  d.i.changeOptions(h);
                  h.delete();
                  d.A = void 0;
                }
                d.o = false;
                u2.g = 0;
            }
          });
        });
      }
      v.initialize = function() {
        return Z(this, function b() {
          var c = this;
          return O(b, function(d) {
            return 1 == d.g ? N(d, Zb(c), 2) : 3 != d.g ? N(d, ac(c), 3) : N(d, cc(c), 0);
          });
        });
      };
      function $b(a, b) {
        return Z(a, function d() {
          var e = this, g, f;
          return O(d, function(h) {
            if (b in e.F) return h.return(e.F[b]);
            g = e.locateFile(b, "");
            f = fetch(g).then(function(k) {
              return k.arrayBuffer();
            });
            e.F[b] = f;
            return h.return(f);
          });
        });
      }
      v.overrideFile = function(a, b) {
        this.i ? this.i.overrideFile(a, b) : this.B[a] = b;
      };
      v.clearOverriddenFiles = function() {
        this.B = {};
        this.i && this.i.clearOverriddenFiles();
      };
      v.send = function(a, b) {
        return Z(this, function d() {
          var e = this, g, f, h, k, l, n, u2, w, r;
          return O(d, function(y) {
            switch (y.g) {
              case 1:
                if (!e.g.inputs) return y.return();
                g = 1e3 * (void 0 === b || null === b ? performance.now() : b);
                return N(y, e.C, 2);
              case 2:
                return N(y, e.initialize(), 3);
              case 3:
                f = new e.h.PacketDataList();
                h = K(Object.keys(a));
                for (k = h.next(); !k.done; k = h.next()) if (l = k.value, n = e.g.inputs[l]) {
                  a: {
                    var m = e;
                    var t2 = a[l];
                    switch (n.type) {
                      case "video":
                        var x = m.m[n.stream];
                        x || (x = new Ob(m.h, m.D), m.m[n.stream] = x);
                        m = x;
                        0 === m.l && (m.l = m.h.createTexture());
                        if ("undefined" !== typeof HTMLVideoElement && t2 instanceof HTMLVideoElement) {
                          var z = t2.videoWidth;
                          x = t2.videoHeight;
                        } else "undefined" !== typeof HTMLImageElement && t2 instanceof HTMLImageElement ? (z = t2.naturalWidth, x = t2.naturalHeight) : (z = t2.width, x = t2.height);
                        x = { glName: m.l, width: z, height: x };
                        z = m.g;
                        z.canvas.width = x.width;
                        z.canvas.height = x.height;
                        z.activeTexture(z.TEXTURE0);
                        m.h.bindTexture2d(m.l);
                        z.texImage2D(z.TEXTURE_2D, 0, z.RGBA, z.RGBA, z.UNSIGNED_BYTE, t2);
                        m.h.bindTexture2d(0);
                        m = x;
                        break a;
                      case "detections":
                        x = m.m[n.stream];
                        x || (x = new Rb(m.h), m.m[n.stream] = x);
                        m = x;
                        m.data || (m.data = new m.g.DetectionListData());
                        m.data.reset(t2.length);
                        for (x = 0; x < t2.length; ++x) {
                          z = t2[x];
                          var E = m.data, F = E.setBoundingBox, I = x;
                          var H = z.T;
                          var p = new Fb();
                          X(p, 1, H.Z);
                          X(p, 2, H.$);
                          X(p, 3, H.height);
                          X(p, 4, H.width);
                          X(p, 5, H.rotation);
                          X(p, 6, H.X);
                          var A = H = new Ya();
                          U(A, 1, W(p, 1));
                          U(A, 2, W(p, 2));
                          U(A, 3, W(p, 3));
                          U(A, 4, W(p, 4));
                          U(A, 5, W(p, 5));
                          var C2 = W(p, 6);
                          if (null != C2 && null != C2) {
                            Ra(A.g, 48);
                            var q = A.g, B = C2;
                            C2 = 0 > B;
                            B = Math.abs(B);
                            var D = B >>> 0;
                            B = Math.floor((B - D) / 4294967296);
                            B >>>= 0;
                            C2 && (B = ~B >>> 0, D = (~D >>> 0) + 1, 4294967295 < D && (D = 0, B++, 4294967295 < B && (B = 0)));
                            Q = D;
                            R = B;
                            C2 = Q;
                            for (D = R; 0 < D || 127 < C2; ) q.push(C2 & 127 | 128), C2 = (C2 >>> 7 | D << 25) >>> 0, D >>>= 7;
                            q.push(C2);
                          }
                          rb(p, A);
                          H = $a(H);
                          F.call(E, I, H);
                          if (z.O) for (E = 0; E < z.O.length; ++E) p = z.O[E], A = p.visibility ? true : false, F = m.data, I = F.addNormalizedLandmark, H = x, p = Object.assign(Object.assign({}, p), { visibility: A ? p.visibility : 0 }), A = new Ab(), X(A, 1, p.x), X(A, 2, p.y), X(A, 3, p.z), p.visibility && X(A, 4, p.visibility), q = p = new Ya(), U(q, 1, W(A, 1)), U(q, 2, W(A, 2)), U(q, 3, W(A, 3)), U(q, 4, W(A, 4)), U(q, 5, W(A, 5)), rb(A, q), p = $a(p), I.call(F, H, p);
                          if (z.M) for (E = 0; E < z.M.length; ++E) {
                            F = m.data;
                            I = F.addClassification;
                            H = x;
                            p = z.M[E];
                            A = new wb();
                            X(A, 2, p.Y);
                            p.index && X(A, 1, p.index);
                            p.label && X(A, 3, p.label);
                            p.displayName && X(A, 4, p.displayName);
                            q = p = new Ya();
                            D = W(A, 1);
                            if (null != D && null != D) if (Ra(q.g, 8), C2 = q.g, 0 <= D) Ra(C2, D);
                            else {
                              for (B = 0; 9 > B; B++) C2.push(D & 127 | 128), D >>= 7;
                              C2.push(1);
                            }
                            U(q, 2, W(A, 2));
                            C2 = W(A, 3);
                            null != C2 && (C2 = Ca(C2), Ra(q.g, 26), Ra(q.g, C2.length), Za(q, q.g.end()), Za(q, C2));
                            C2 = W(A, 4);
                            null != C2 && (C2 = Ca(C2), Ra(q.g, 34), Ra(q.g, C2.length), Za(q, q.g.end()), Za(q, C2));
                            rb(A, q);
                            p = $a(p);
                            I.call(F, H, p);
                          }
                        }
                        m = m.data;
                        break a;
                      default:
                        m = {};
                    }
                  }
                  u2 = m;
                  w = n.stream;
                  switch (n.type) {
                    case "video":
                      f.pushTexture2d(Object.assign(Object.assign({}, u2), { stream: w, timestamp: g }));
                      break;
                    case "detections":
                      r = u2;
                      r.stream = w;
                      r.timestamp = g;
                      f.pushDetectionList(r);
                      break;
                    default:
                      throw Error("Unknown input config type: '" + n.type + "'");
                  }
                }
                e.i.send(f);
                return N(y, e.C, 4);
              case 4:
                f.delete(), y.g = 0;
            }
          });
        });
      };
      function dc(a, b, c) {
        return Z(a, function e() {
          var g, f, h, k, l, n, u2 = this, w, r, y, m, t2, x, z, E;
          return O(e, function(F) {
            switch (F.g) {
              case 1:
                if (!c) return F.return(b);
                g = {};
                f = 0;
                h = K(Object.keys(c));
                for (k = h.next(); !k.done; k = h.next()) l = k.value, n = c[l], "string" !== typeof n && "texture" === n.type && void 0 !== b[n.stream] && ++f;
                1 < f && (u2.G = false);
                w = K(Object.keys(c));
                k = w.next();
              case 2:
                if (k.done) {
                  F.g = 4;
                  break;
                }
                r = k.value;
                y = c[r];
                if ("string" === typeof y) return z = g, E = r, N(F, ec(u2, r, b[y]), 14);
                m = b[y.stream];
                if ("detection_list" === y.type) {
                  if (m) {
                    var I = m.getRectList();
                    for (var H = m.getLandmarksList(), p = m.getClassificationsList(), A = [], C2 = 0; C2 < I.size(); ++C2) {
                      var q = I.get(C2);
                      a: {
                        var B = new Fb();
                        for (q = new Sa(q); S2(q); ) switch (q.i) {
                          case 13:
                            var D = T(q);
                            X(B, 1, D);
                            break;
                          case 21:
                            D = T(q);
                            X(B, 2, D);
                            break;
                          case 29:
                            D = T(q);
                            X(B, 3, D);
                            break;
                          case 37:
                            D = T(q);
                            X(B, 4, D);
                            break;
                          case 45:
                            D = T(q);
                            X(B, 5, D);
                            break;
                          case 48:
                            D = Oa(q.g);
                            X(B, 6, D);
                            break;
                          default:
                            if (!sb(B, q)) break a;
                        }
                      }
                      B = { Z: Y(B, 1), $: Y(B, 2), height: Y(B, 3), width: Y(B, 4), rotation: Y(B, 5, 0), X: lb(B, 6, 0) };
                      q = nb(Eb(H.get(C2)), Ab).map(Nb);
                      var la = p.get(C2);
                      a: for (D = new yb(), la = new Sa(la); S2(la); ) switch (la.i) {
                        case 10:
                          D.addClassification(Ua(la, new wb(), xb));
                          break;
                        default:
                          if (!sb(D, la)) break a;
                      }
                      B = { T: B, O: q, M: Mb(D) };
                      A.push(B);
                    }
                    I = A;
                  } else I = [];
                  g[r] = I;
                  F.g = 7;
                  break;
                }
                if ("proto_list" === y.type) {
                  if (m) {
                    I = Array(m.size());
                    for (H = 0; H < m.size(); H++) I[H] = m.get(H);
                    m.delete();
                  } else I = [];
                  g[r] = I;
                  F.g = 7;
                  break;
                }
                if (void 0 === m) {
                  F.g = 3;
                  break;
                }
                if ("float_list" === y.type) {
                  g[r] = m;
                  F.g = 7;
                  break;
                }
                if ("proto" === y.type) {
                  g[r] = m;
                  F.g = 7;
                  break;
                }
                if ("texture" !== y.type) throw Error("Unknown output config type: '" + y.type + "'");
                t2 = u2.s[r];
                t2 || (t2 = new Ob(u2.h, u2.D), u2.s[r] = t2);
                return N(F, Pb(t2, m, u2.G), 13);
              case 13:
                x = F.h, g[r] = x;
              case 7:
                y.transform && g[r] && (g[r] = y.transform(g[r]));
                F.g = 3;
                break;
              case 14:
                z[E] = F.h;
              case 3:
                k = w.next();
                F.g = 2;
                break;
              case 4:
                return F.return(g);
            }
          });
        });
      }
      function ec(a, b, c) {
        return Z(a, function e() {
          var g = this, f;
          return O(e, function(h) {
            return "number" === typeof c || c instanceof Uint8Array || c instanceof g.h.Uint8BlobList ? h.return(c) : c instanceof g.h.Texture2dDataOut ? (f = g.s[b], f || (f = new Ob(g.h, g.D), g.s[b] = f), h.return(Pb(f, c, g.G))) : h.return(void 0);
          });
        });
      }
      function bc(a, b) {
        for (var c = b.name || "$", d = [].concat(L(b.wants)), e = new a.h.StringList(), g = K(b.wants), f = g.next(); !f.done; f = g.next()) e.push_back(f.value);
        g = a.h.PacketListener.implement({ onResults: function(h) {
          for (var k = {}, l = 0; l < b.wants.length; ++l) k[d[l]] = h.get(l);
          var n = a.listeners[c];
          n && (a.C = dc(a, k, b.outs).then(function(u2) {
            u2 = n(u2);
            for (var w = 0; w < b.wants.length; ++w) {
              var r = k[d[w]];
              "object" === typeof r && r.hasOwnProperty && r.hasOwnProperty("delete") && r.delete();
            }
            u2 && (a.C = u2);
          }));
        } });
        a.i.attachMultiListener(e, g);
        e.delete();
      }
      v.onResults = function(a, b) {
        this.listeners[b || "$"] = a;
      };
      P("Solution", Xb);
      P("OptionType", { BOOL: 0, NUMBER: 1, aa: 2, 0: "BOOL", 1: "NUMBER", 2: "STRING" });
      function fc(a) {
        a = Kb(a);
        var b = a.getMesh();
        if (!b) return a;
        var c = new Float32Array(b.getVertexBufferList());
        b.getVertexBufferList = function() {
          return c;
        };
        var d = new Uint32Array(b.getIndexBufferList());
        b.getIndexBufferList = function() {
          return d;
        };
        return a;
      }
      ;
      var gc = { files: [{ url: "face_mesh_solution_packed_assets_loader.js" }, { simd: true, url: "face_mesh_solution_simd_wasm_bin.js" }, { simd: false, url: "face_mesh_solution_wasm_bin.js" }], graph: { url: "face_mesh.binarypb" }, listeners: [{ wants: ["multi_face_geometry", "image_transformed", "multi_face_landmarks"], outs: { image: "image_transformed", multiFaceGeometry: { type: "proto_list", stream: "multi_face_geometry", transform: function(a) {
        return a.map(fc);
      } }, multiFaceLandmarks: { type: "proto_list", stream: "multi_face_landmarks", transform: function(a) {
        return a.map(function(b) {
          return nb(
            Eb(b),
            Ab
          ).map(Nb);
        });
      } } } }], inputs: { image: { type: "video", stream: "input_frames_gpu" } }, options: { useCpuInference: { type: 0, graphOptionXref: { calculatorType: "InferenceCalculator", fieldName: "use_cpu_inference" }, default: "iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document }, enableFaceGeometry: { type: 0, graphOptionXref: {
        calculatorName: "EnableFaceGeometryConstant",
        calculatorType: "ConstantSidePacketCalculator",
        fieldName: "bool_value"
      } }, selfieMode: { type: 0, graphOptionXref: { calculatorType: "GlScalerCalculator", calculatorIndex: 1, fieldName: "flip_horizontal" } }, maxNumFaces: { type: 1, graphOptionXref: { calculatorType: "ConstantSidePacketCalculator", calculatorName: "ConstantSidePacketCalculatorNumFaces", fieldName: "int_value" } }, refineLandmarks: { type: 0, graphOptionXref: { calculatorType: "ConstantSidePacketCalculator", calculatorName: "ConstantSidePacketCalculatorRefineLandmarks", fieldName: "bool_value" } }, minDetectionConfidence: {
        type: 1,
        graphOptionXref: { calculatorType: "TensorsToDetectionsCalculator", calculatorName: "facelandmarkfrontgpu__facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator", fieldName: "min_score_thresh" }
      }, minTrackingConfidence: { type: 1, graphOptionXref: { calculatorType: "ThresholdingCalculator", calculatorName: "facelandmarkfrontgpu__facelandmarkgpu__ThresholdingCalculator", fieldName: "threshold" } }, cameraNear: { type: 1, graphOptionXref: {
        calculatorType: "FaceGeometryEnvGeneratorCalculator",
        fieldName: "near"
      } }, cameraFar: { type: 1, graphOptionXref: { calculatorType: "FaceGeometryEnvGeneratorCalculator", fieldName: "far" } }, cameraVerticalFovDegrees: { type: 1, graphOptionXref: { calculatorType: "FaceGeometryEnvGeneratorCalculator", fieldName: "vertical_fov_degrees" } } } };
      var hc = [[61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314], [314, 405], [405, 321], [321, 375], [375, 291], [61, 185], [185, 40], [40, 39], [39, 37], [37, 0], [0, 267], [267, 269], [269, 270], [270, 409], [409, 291], [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317], [317, 402], [402, 318], [318, 324], [324, 308], [78, 191], [191, 80], [80, 81], [81, 82], [82, 13], [13, 312], [312, 311], [311, 310], [310, 415], [415, 308]], ic = [[263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [
        386,
        385
      ], [385, 384], [384, 398], [398, 362]], jc = [[276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]], kc = [[33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]], lc = [[46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]], mc = [
        [10, 338],
        [338, 297],
        [297, 332],
        [332, 284],
        [284, 251],
        [251, 389],
        [389, 356],
        [356, 454],
        [454, 323],
        [323, 361],
        [361, 288],
        [288, 397],
        [397, 365],
        [365, 379],
        [379, 378],
        [378, 400],
        [400, 377],
        [377, 152],
        [152, 148],
        [148, 176],
        [176, 149],
        [149, 150],
        [150, 136],
        [136, 172],
        [172, 58],
        [58, 132],
        [132, 93],
        [93, 234],
        [234, 127],
        [127, 162],
        [162, 21],
        [21, 54],
        [54, 103],
        [103, 67],
        [67, 109],
        [109, 10]
      ], nc = [].concat(L(hc), L(ic), L(jc), L(kc), L(lc), L(mc));
      function oc(a) {
        a = a || {};
        a = Object.assign(Object.assign({}, gc), a);
        this.g = new Xb(a);
      }
      v = oc.prototype;
      v.close = function() {
        this.g.close();
        return Promise.resolve();
      };
      v.onResults = function(a) {
        this.g.onResults(a);
      };
      v.initialize = function() {
        return Z(this, function b() {
          var c = this;
          return O(b, function(d) {
            return N(d, c.g.initialize(), 0);
          });
        });
      };
      v.reset = function() {
        this.g.reset();
      };
      v.send = function(a) {
        return Z(this, function c() {
          var d = this;
          return O(c, function(e) {
            return N(e, d.g.send(a), 0);
          });
        });
      };
      v.setOptions = function(a) {
        this.g.setOptions(a);
      };
      P("FACE_GEOMETRY", { Layout: { COLUMN_MAJOR: 0, ROW_MAJOR: 1, 0: "COLUMN_MAJOR", 1: "ROW_MAJOR" }, PrimitiveType: { TRIANGLE: 0, 0: "TRIANGLE" }, VertexType: { VERTEX_PT: 0, 0: "VERTEX_PT" }, DEFAULT_CAMERA_PARAMS: { verticalFovDegrees: 63, near: 1, far: 1e4 } });
      P("FaceMesh", oc);
      P("FACEMESH_LIPS", hc);
      P("FACEMESH_LEFT_EYE", ic);
      P("FACEMESH_LEFT_EYEBROW", jc);
      P("FACEMESH_LEFT_IRIS", [[474, 475], [475, 476], [476, 477], [477, 474]]);
      P("FACEMESH_RIGHT_EYE", kc);
      P("FACEMESH_RIGHT_EYEBROW", lc);
      P("FACEMESH_RIGHT_IRIS", [[469, 470], [470, 471], [471, 472], [472, 469]]);
      P("FACEMESH_FACE_OVAL", mc);
      P("FACEMESH_CONTOURS", nc);
      P("FACEMESH_TESSELATION", [
        [127, 34],
        [34, 139],
        [139, 127],
        [11, 0],
        [0, 37],
        [37, 11],
        [232, 231],
        [231, 120],
        [120, 232],
        [72, 37],
        [37, 39],
        [39, 72],
        [128, 121],
        [121, 47],
        [47, 128],
        [232, 121],
        [121, 128],
        [128, 232],
        [104, 69],
        [69, 67],
        [67, 104],
        [175, 171],
        [171, 148],
        [148, 175],
        [118, 50],
        [50, 101],
        [101, 118],
        [73, 39],
        [39, 40],
        [40, 73],
        [9, 151],
        [151, 108],
        [108, 9],
        [48, 115],
        [115, 131],
        [131, 48],
        [194, 204],
        [204, 211],
        [211, 194],
        [74, 40],
        [40, 185],
        [185, 74],
        [80, 42],
        [42, 183],
        [183, 80],
        [40, 92],
        [92, 186],
        [186, 40],
        [230, 229],
        [229, 118],
        [118, 230],
        [202, 212],
        [
          212,
          214
        ],
        [214, 202],
        [83, 18],
        [18, 17],
        [17, 83],
        [76, 61],
        [61, 146],
        [146, 76],
        [160, 29],
        [29, 30],
        [30, 160],
        [56, 157],
        [157, 173],
        [173, 56],
        [106, 204],
        [204, 194],
        [194, 106],
        [135, 214],
        [214, 192],
        [192, 135],
        [203, 165],
        [165, 98],
        [98, 203],
        [21, 71],
        [71, 68],
        [68, 21],
        [51, 45],
        [45, 4],
        [4, 51],
        [144, 24],
        [24, 23],
        [23, 144],
        [77, 146],
        [146, 91],
        [91, 77],
        [205, 50],
        [50, 187],
        [187, 205],
        [201, 200],
        [200, 18],
        [18, 201],
        [91, 106],
        [106, 182],
        [182, 91],
        [90, 91],
        [91, 181],
        [181, 90],
        [85, 84],
        [84, 17],
        [17, 85],
        [206, 203],
        [203, 36],
        [36, 206],
        [148, 171],
        [171, 140],
        [140, 148],
        [
          92,
          40
        ],
        [40, 39],
        [39, 92],
        [193, 189],
        [189, 244],
        [244, 193],
        [159, 158],
        [158, 28],
        [28, 159],
        [247, 246],
        [246, 161],
        [161, 247],
        [236, 3],
        [3, 196],
        [196, 236],
        [54, 68],
        [68, 104],
        [104, 54],
        [193, 168],
        [168, 8],
        [8, 193],
        [117, 228],
        [228, 31],
        [31, 117],
        [189, 193],
        [193, 55],
        [55, 189],
        [98, 97],
        [97, 99],
        [99, 98],
        [126, 47],
        [47, 100],
        [100, 126],
        [166, 79],
        [79, 218],
        [218, 166],
        [155, 154],
        [154, 26],
        [26, 155],
        [209, 49],
        [49, 131],
        [131, 209],
        [135, 136],
        [136, 150],
        [150, 135],
        [47, 126],
        [126, 217],
        [217, 47],
        [223, 52],
        [52, 53],
        [53, 223],
        [45, 51],
        [51, 134],
        [134, 45],
        [211, 170],
        [
          170,
          140
        ],
        [140, 211],
        [67, 69],
        [69, 108],
        [108, 67],
        [43, 106],
        [106, 91],
        [91, 43],
        [230, 119],
        [119, 120],
        [120, 230],
        [226, 130],
        [130, 247],
        [247, 226],
        [63, 53],
        [53, 52],
        [52, 63],
        [238, 20],
        [20, 242],
        [242, 238],
        [46, 70],
        [70, 156],
        [156, 46],
        [78, 62],
        [62, 96],
        [96, 78],
        [46, 53],
        [53, 63],
        [63, 46],
        [143, 34],
        [34, 227],
        [227, 143],
        [123, 117],
        [117, 111],
        [111, 123],
        [44, 125],
        [125, 19],
        [19, 44],
        [236, 134],
        [134, 51],
        [51, 236],
        [216, 206],
        [206, 205],
        [205, 216],
        [154, 153],
        [153, 22],
        [22, 154],
        [39, 37],
        [37, 167],
        [167, 39],
        [200, 201],
        [201, 208],
        [208, 200],
        [36, 142],
        [142, 100],
        [
          100,
          36
        ],
        [57, 212],
        [212, 202],
        [202, 57],
        [20, 60],
        [60, 99],
        [99, 20],
        [28, 158],
        [158, 157],
        [157, 28],
        [35, 226],
        [226, 113],
        [113, 35],
        [160, 159],
        [159, 27],
        [27, 160],
        [204, 202],
        [202, 210],
        [210, 204],
        [113, 225],
        [225, 46],
        [46, 113],
        [43, 202],
        [202, 204],
        [204, 43],
        [62, 76],
        [76, 77],
        [77, 62],
        [137, 123],
        [123, 116],
        [116, 137],
        [41, 38],
        [38, 72],
        [72, 41],
        [203, 129],
        [129, 142],
        [142, 203],
        [64, 98],
        [98, 240],
        [240, 64],
        [49, 102],
        [102, 64],
        [64, 49],
        [41, 73],
        [73, 74],
        [74, 41],
        [212, 216],
        [216, 207],
        [207, 212],
        [42, 74],
        [74, 184],
        [184, 42],
        [169, 170],
        [170, 211],
        [211, 169],
        [
          170,
          149
        ],
        [149, 176],
        [176, 170],
        [105, 66],
        [66, 69],
        [69, 105],
        [122, 6],
        [6, 168],
        [168, 122],
        [123, 147],
        [147, 187],
        [187, 123],
        [96, 77],
        [77, 90],
        [90, 96],
        [65, 55],
        [55, 107],
        [107, 65],
        [89, 90],
        [90, 180],
        [180, 89],
        [101, 100],
        [100, 120],
        [120, 101],
        [63, 105],
        [105, 104],
        [104, 63],
        [93, 137],
        [137, 227],
        [227, 93],
        [15, 86],
        [86, 85],
        [85, 15],
        [129, 102],
        [102, 49],
        [49, 129],
        [14, 87],
        [87, 86],
        [86, 14],
        [55, 8],
        [8, 9],
        [9, 55],
        [100, 47],
        [47, 121],
        [121, 100],
        [145, 23],
        [23, 22],
        [22, 145],
        [88, 89],
        [89, 179],
        [179, 88],
        [6, 122],
        [122, 196],
        [196, 6],
        [88, 95],
        [95, 96],
        [96, 88],
        [138, 172],
        [172, 136],
        [136, 138],
        [215, 58],
        [58, 172],
        [172, 215],
        [115, 48],
        [48, 219],
        [219, 115],
        [42, 80],
        [80, 81],
        [81, 42],
        [195, 3],
        [3, 51],
        [51, 195],
        [43, 146],
        [146, 61],
        [61, 43],
        [171, 175],
        [175, 199],
        [199, 171],
        [81, 82],
        [82, 38],
        [38, 81],
        [53, 46],
        [46, 225],
        [225, 53],
        [144, 163],
        [163, 110],
        [110, 144],
        [52, 65],
        [65, 66],
        [66, 52],
        [229, 228],
        [228, 117],
        [117, 229],
        [34, 127],
        [127, 234],
        [234, 34],
        [107, 108],
        [108, 69],
        [69, 107],
        [109, 108],
        [108, 151],
        [151, 109],
        [48, 64],
        [64, 235],
        [235, 48],
        [62, 78],
        [78, 191],
        [191, 62],
        [129, 209],
        [209, 126],
        [126, 129],
        [111, 35],
        [35, 143],
        [
          143,
          111
        ],
        [117, 123],
        [123, 50],
        [50, 117],
        [222, 65],
        [65, 52],
        [52, 222],
        [19, 125],
        [125, 141],
        [141, 19],
        [221, 55],
        [55, 65],
        [65, 221],
        [3, 195],
        [195, 197],
        [197, 3],
        [25, 7],
        [7, 33],
        [33, 25],
        [220, 237],
        [237, 44],
        [44, 220],
        [70, 71],
        [71, 139],
        [139, 70],
        [122, 193],
        [193, 245],
        [245, 122],
        [247, 130],
        [130, 33],
        [33, 247],
        [71, 21],
        [21, 162],
        [162, 71],
        [170, 169],
        [169, 150],
        [150, 170],
        [188, 174],
        [174, 196],
        [196, 188],
        [216, 186],
        [186, 92],
        [92, 216],
        [2, 97],
        [97, 167],
        [167, 2],
        [141, 125],
        [125, 241],
        [241, 141],
        [164, 167],
        [167, 37],
        [37, 164],
        [72, 38],
        [38, 12],
        [12, 72],
        [38, 82],
        [82, 13],
        [13, 38],
        [63, 68],
        [68, 71],
        [71, 63],
        [226, 35],
        [35, 111],
        [111, 226],
        [101, 50],
        [50, 205],
        [205, 101],
        [206, 92],
        [92, 165],
        [165, 206],
        [209, 198],
        [198, 217],
        [217, 209],
        [165, 167],
        [167, 97],
        [97, 165],
        [220, 115],
        [115, 218],
        [218, 220],
        [133, 112],
        [112, 243],
        [243, 133],
        [239, 238],
        [238, 241],
        [241, 239],
        [214, 135],
        [135, 169],
        [169, 214],
        [190, 173],
        [173, 133],
        [133, 190],
        [171, 208],
        [208, 32],
        [32, 171],
        [125, 44],
        [44, 237],
        [237, 125],
        [86, 87],
        [87, 178],
        [178, 86],
        [85, 86],
        [86, 179],
        [179, 85],
        [84, 85],
        [85, 180],
        [180, 84],
        [83, 84],
        [84, 181],
        [181, 83],
        [201, 83],
        [83, 182],
        [182, 201],
        [137, 93],
        [93, 132],
        [132, 137],
        [76, 62],
        [62, 183],
        [183, 76],
        [61, 76],
        [76, 184],
        [184, 61],
        [57, 61],
        [61, 185],
        [185, 57],
        [212, 57],
        [57, 186],
        [186, 212],
        [214, 207],
        [207, 187],
        [187, 214],
        [34, 143],
        [143, 156],
        [156, 34],
        [79, 239],
        [239, 237],
        [237, 79],
        [123, 137],
        [137, 177],
        [177, 123],
        [44, 1],
        [1, 4],
        [4, 44],
        [201, 194],
        [194, 32],
        [32, 201],
        [64, 102],
        [102, 129],
        [129, 64],
        [213, 215],
        [215, 138],
        [138, 213],
        [59, 166],
        [166, 219],
        [219, 59],
        [242, 99],
        [99, 97],
        [97, 242],
        [2, 94],
        [94, 141],
        [141, 2],
        [75, 59],
        [59, 235],
        [235, 75],
        [24, 110],
        [110, 228],
        [
          228,
          24
        ],
        [25, 130],
        [130, 226],
        [226, 25],
        [23, 24],
        [24, 229],
        [229, 23],
        [22, 23],
        [23, 230],
        [230, 22],
        [26, 22],
        [22, 231],
        [231, 26],
        [112, 26],
        [26, 232],
        [232, 112],
        [189, 190],
        [190, 243],
        [243, 189],
        [221, 56],
        [56, 190],
        [190, 221],
        [28, 56],
        [56, 221],
        [221, 28],
        [27, 28],
        [28, 222],
        [222, 27],
        [29, 27],
        [27, 223],
        [223, 29],
        [30, 29],
        [29, 224],
        [224, 30],
        [247, 30],
        [30, 225],
        [225, 247],
        [238, 79],
        [79, 20],
        [20, 238],
        [166, 59],
        [59, 75],
        [75, 166],
        [60, 75],
        [75, 240],
        [240, 60],
        [147, 177],
        [177, 215],
        [215, 147],
        [20, 79],
        [79, 166],
        [166, 20],
        [187, 147],
        [147, 213],
        [213, 187],
        [112, 233],
        [233, 244],
        [244, 112],
        [233, 128],
        [128, 245],
        [245, 233],
        [128, 114],
        [114, 188],
        [188, 128],
        [114, 217],
        [217, 174],
        [174, 114],
        [131, 115],
        [115, 220],
        [220, 131],
        [217, 198],
        [198, 236],
        [236, 217],
        [198, 131],
        [131, 134],
        [134, 198],
        [177, 132],
        [132, 58],
        [58, 177],
        [143, 35],
        [35, 124],
        [124, 143],
        [110, 163],
        [163, 7],
        [7, 110],
        [228, 110],
        [110, 25],
        [25, 228],
        [356, 389],
        [389, 368],
        [368, 356],
        [11, 302],
        [302, 267],
        [267, 11],
        [452, 350],
        [350, 349],
        [349, 452],
        [302, 303],
        [303, 269],
        [269, 302],
        [357, 343],
        [343, 277],
        [277, 357],
        [452, 453],
        [453, 357],
        [357, 452],
        [333, 332],
        [
          332,
          297
        ],
        [297, 333],
        [175, 152],
        [152, 377],
        [377, 175],
        [347, 348],
        [348, 330],
        [330, 347],
        [303, 304],
        [304, 270],
        [270, 303],
        [9, 336],
        [336, 337],
        [337, 9],
        [278, 279],
        [279, 360],
        [360, 278],
        [418, 262],
        [262, 431],
        [431, 418],
        [304, 408],
        [408, 409],
        [409, 304],
        [310, 415],
        [415, 407],
        [407, 310],
        [270, 409],
        [409, 410],
        [410, 270],
        [450, 348],
        [348, 347],
        [347, 450],
        [422, 430],
        [430, 434],
        [434, 422],
        [313, 314],
        [314, 17],
        [17, 313],
        [306, 307],
        [307, 375],
        [375, 306],
        [387, 388],
        [388, 260],
        [260, 387],
        [286, 414],
        [414, 398],
        [398, 286],
        [335, 406],
        [406, 418],
        [418, 335],
        [364, 367],
        [
          367,
          416
        ],
        [416, 364],
        [423, 358],
        [358, 327],
        [327, 423],
        [251, 284],
        [284, 298],
        [298, 251],
        [281, 5],
        [5, 4],
        [4, 281],
        [373, 374],
        [374, 253],
        [253, 373],
        [307, 320],
        [320, 321],
        [321, 307],
        [425, 427],
        [427, 411],
        [411, 425],
        [421, 313],
        [313, 18],
        [18, 421],
        [321, 405],
        [405, 406],
        [406, 321],
        [320, 404],
        [404, 405],
        [405, 320],
        [315, 16],
        [16, 17],
        [17, 315],
        [426, 425],
        [425, 266],
        [266, 426],
        [377, 400],
        [400, 369],
        [369, 377],
        [322, 391],
        [391, 269],
        [269, 322],
        [417, 465],
        [465, 464],
        [464, 417],
        [386, 257],
        [257, 258],
        [258, 386],
        [466, 260],
        [260, 388],
        [388, 466],
        [456, 399],
        [399, 419],
        [419, 456],
        [284, 332],
        [332, 333],
        [333, 284],
        [417, 285],
        [285, 8],
        [8, 417],
        [346, 340],
        [340, 261],
        [261, 346],
        [413, 441],
        [441, 285],
        [285, 413],
        [327, 460],
        [460, 328],
        [328, 327],
        [355, 371],
        [371, 329],
        [329, 355],
        [392, 439],
        [439, 438],
        [438, 392],
        [382, 341],
        [341, 256],
        [256, 382],
        [429, 420],
        [420, 360],
        [360, 429],
        [364, 394],
        [394, 379],
        [379, 364],
        [277, 343],
        [343, 437],
        [437, 277],
        [443, 444],
        [444, 283],
        [283, 443],
        [275, 440],
        [440, 363],
        [363, 275],
        [431, 262],
        [262, 369],
        [369, 431],
        [297, 338],
        [338, 337],
        [337, 297],
        [273, 375],
        [375, 321],
        [321, 273],
        [450, 451],
        [
          451,
          349
        ],
        [349, 450],
        [446, 342],
        [342, 467],
        [467, 446],
        [293, 334],
        [334, 282],
        [282, 293],
        [458, 461],
        [461, 462],
        [462, 458],
        [276, 353],
        [353, 383],
        [383, 276],
        [308, 324],
        [324, 325],
        [325, 308],
        [276, 300],
        [300, 293],
        [293, 276],
        [372, 345],
        [345, 447],
        [447, 372],
        [352, 345],
        [345, 340],
        [340, 352],
        [274, 1],
        [1, 19],
        [19, 274],
        [456, 248],
        [248, 281],
        [281, 456],
        [436, 427],
        [427, 425],
        [425, 436],
        [381, 256],
        [256, 252],
        [252, 381],
        [269, 391],
        [391, 393],
        [393, 269],
        [200, 199],
        [199, 428],
        [428, 200],
        [266, 330],
        [330, 329],
        [329, 266],
        [287, 273],
        [273, 422],
        [422, 287],
        [250, 462],
        [
          462,
          328
        ],
        [328, 250],
        [258, 286],
        [286, 384],
        [384, 258],
        [265, 353],
        [353, 342],
        [342, 265],
        [387, 259],
        [259, 257],
        [257, 387],
        [424, 431],
        [431, 430],
        [430, 424],
        [342, 353],
        [353, 276],
        [276, 342],
        [273, 335],
        [335, 424],
        [424, 273],
        [292, 325],
        [325, 307],
        [307, 292],
        [366, 447],
        [447, 345],
        [345, 366],
        [271, 303],
        [303, 302],
        [302, 271],
        [423, 266],
        [266, 371],
        [371, 423],
        [294, 455],
        [455, 460],
        [460, 294],
        [279, 278],
        [278, 294],
        [294, 279],
        [271, 272],
        [272, 304],
        [304, 271],
        [432, 434],
        [434, 427],
        [427, 432],
        [272, 407],
        [407, 408],
        [408, 272],
        [394, 430],
        [430, 431],
        [431, 394],
        [395, 369],
        [369, 400],
        [400, 395],
        [334, 333],
        [333, 299],
        [299, 334],
        [351, 417],
        [417, 168],
        [168, 351],
        [352, 280],
        [280, 411],
        [411, 352],
        [325, 319],
        [319, 320],
        [320, 325],
        [295, 296],
        [296, 336],
        [336, 295],
        [319, 403],
        [403, 404],
        [404, 319],
        [330, 348],
        [348, 349],
        [349, 330],
        [293, 298],
        [298, 333],
        [333, 293],
        [323, 454],
        [454, 447],
        [447, 323],
        [15, 16],
        [16, 315],
        [315, 15],
        [358, 429],
        [429, 279],
        [279, 358],
        [14, 15],
        [15, 316],
        [316, 14],
        [285, 336],
        [336, 9],
        [9, 285],
        [329, 349],
        [349, 350],
        [350, 329],
        [374, 380],
        [380, 252],
        [252, 374],
        [318, 402],
        [402, 403],
        [403, 318],
        [6, 197],
        [
          197,
          419
        ],
        [419, 6],
        [318, 319],
        [319, 325],
        [325, 318],
        [367, 364],
        [364, 365],
        [365, 367],
        [435, 367],
        [367, 397],
        [397, 435],
        [344, 438],
        [438, 439],
        [439, 344],
        [272, 271],
        [271, 311],
        [311, 272],
        [195, 5],
        [5, 281],
        [281, 195],
        [273, 287],
        [287, 291],
        [291, 273],
        [396, 428],
        [428, 199],
        [199, 396],
        [311, 271],
        [271, 268],
        [268, 311],
        [283, 444],
        [444, 445],
        [445, 283],
        [373, 254],
        [254, 339],
        [339, 373],
        [282, 334],
        [334, 296],
        [296, 282],
        [449, 347],
        [347, 346],
        [346, 449],
        [264, 447],
        [447, 454],
        [454, 264],
        [336, 296],
        [296, 299],
        [299, 336],
        [338, 10],
        [10, 151],
        [151, 338],
        [278, 439],
        [
          439,
          455
        ],
        [455, 278],
        [292, 407],
        [407, 415],
        [415, 292],
        [358, 371],
        [371, 355],
        [355, 358],
        [340, 345],
        [345, 372],
        [372, 340],
        [346, 347],
        [347, 280],
        [280, 346],
        [442, 443],
        [443, 282],
        [282, 442],
        [19, 94],
        [94, 370],
        [370, 19],
        [441, 442],
        [442, 295],
        [295, 441],
        [248, 419],
        [419, 197],
        [197, 248],
        [263, 255],
        [255, 359],
        [359, 263],
        [440, 275],
        [275, 274],
        [274, 440],
        [300, 383],
        [383, 368],
        [368, 300],
        [351, 412],
        [412, 465],
        [465, 351],
        [263, 467],
        [467, 466],
        [466, 263],
        [301, 368],
        [368, 389],
        [389, 301],
        [395, 378],
        [378, 379],
        [379, 395],
        [412, 351],
        [351, 419],
        [419, 412],
        [436, 426],
        [426, 322],
        [322, 436],
        [2, 164],
        [164, 393],
        [393, 2],
        [370, 462],
        [462, 461],
        [461, 370],
        [164, 0],
        [0, 267],
        [267, 164],
        [302, 11],
        [11, 12],
        [12, 302],
        [268, 12],
        [12, 13],
        [13, 268],
        [293, 300],
        [300, 301],
        [301, 293],
        [446, 261],
        [261, 340],
        [340, 446],
        [330, 266],
        [266, 425],
        [425, 330],
        [426, 423],
        [423, 391],
        [391, 426],
        [429, 355],
        [355, 437],
        [437, 429],
        [391, 327],
        [327, 326],
        [326, 391],
        [440, 457],
        [457, 438],
        [438, 440],
        [341, 382],
        [382, 362],
        [362, 341],
        [459, 457],
        [457, 461],
        [461, 459],
        [434, 430],
        [430, 394],
        [394, 434],
        [414, 463],
        [463, 362],
        [362, 414],
        [396, 369],
        [369, 262],
        [262, 396],
        [354, 461],
        [461, 457],
        [457, 354],
        [316, 403],
        [403, 402],
        [402, 316],
        [315, 404],
        [404, 403],
        [403, 315],
        [314, 405],
        [405, 404],
        [404, 314],
        [313, 406],
        [406, 405],
        [405, 313],
        [421, 418],
        [418, 406],
        [406, 421],
        [366, 401],
        [401, 361],
        [361, 366],
        [306, 408],
        [408, 407],
        [407, 306],
        [291, 409],
        [409, 408],
        [408, 291],
        [287, 410],
        [410, 409],
        [409, 287],
        [432, 436],
        [436, 410],
        [410, 432],
        [434, 416],
        [416, 411],
        [411, 434],
        [264, 368],
        [368, 383],
        [383, 264],
        [309, 438],
        [438, 457],
        [457, 309],
        [352, 376],
        [376, 401],
        [401, 352],
        [274, 275],
        [275, 4],
        [4, 274],
        [421, 428],
        [
          428,
          262
        ],
        [262, 421],
        [294, 327],
        [327, 358],
        [358, 294],
        [433, 416],
        [416, 367],
        [367, 433],
        [289, 455],
        [455, 439],
        [439, 289],
        [462, 370],
        [370, 326],
        [326, 462],
        [2, 326],
        [326, 370],
        [370, 2],
        [305, 460],
        [460, 455],
        [455, 305],
        [254, 449],
        [449, 448],
        [448, 254],
        [255, 261],
        [261, 446],
        [446, 255],
        [253, 450],
        [450, 449],
        [449, 253],
        [252, 451],
        [451, 450],
        [450, 252],
        [256, 452],
        [452, 451],
        [451, 256],
        [341, 453],
        [453, 452],
        [452, 341],
        [413, 464],
        [464, 463],
        [463, 413],
        [441, 413],
        [413, 414],
        [414, 441],
        [258, 442],
        [442, 441],
        [441, 258],
        [257, 443],
        [443, 442],
        [442, 257],
        [259, 444],
        [444, 443],
        [443, 259],
        [260, 445],
        [445, 444],
        [444, 260],
        [467, 342],
        [342, 445],
        [445, 467],
        [459, 458],
        [458, 250],
        [250, 459],
        [289, 392],
        [392, 290],
        [290, 289],
        [290, 328],
        [328, 460],
        [460, 290],
        [376, 433],
        [433, 435],
        [435, 376],
        [250, 290],
        [290, 392],
        [392, 250],
        [411, 416],
        [416, 433],
        [433, 411],
        [341, 463],
        [463, 464],
        [464, 341],
        [453, 464],
        [464, 465],
        [465, 453],
        [357, 465],
        [465, 412],
        [412, 357],
        [343, 412],
        [412, 399],
        [399, 343],
        [360, 363],
        [363, 440],
        [440, 360],
        [437, 399],
        [399, 456],
        [456, 437],
        [420, 456],
        [456, 363],
        [363, 420],
        [401, 435],
        [435, 288],
        [288, 401],
        [
          372,
          383
        ],
        [383, 353],
        [353, 372],
        [339, 255],
        [255, 249],
        [249, 339],
        [448, 261],
        [261, 255],
        [255, 448],
        [133, 243],
        [243, 190],
        [190, 133],
        [133, 155],
        [155, 112],
        [112, 133],
        [33, 246],
        [246, 247],
        [247, 33],
        [33, 130],
        [130, 25],
        [25, 33],
        [398, 384],
        [384, 286],
        [286, 398],
        [362, 398],
        [398, 414],
        [414, 362],
        [362, 463],
        [463, 341],
        [341, 362],
        [263, 359],
        [359, 467],
        [467, 263],
        [263, 249],
        [249, 255],
        [255, 263],
        [466, 467],
        [467, 260],
        [260, 466],
        [75, 60],
        [60, 166],
        [166, 75],
        [238, 239],
        [239, 79],
        [79, 238],
        [162, 127],
        [127, 139],
        [139, 162],
        [72, 11],
        [11, 37],
        [37, 72],
        [121, 232],
        [
          232,
          120
        ],
        [120, 121],
        [73, 72],
        [72, 39],
        [39, 73],
        [114, 128],
        [128, 47],
        [47, 114],
        [233, 232],
        [232, 128],
        [128, 233],
        [103, 104],
        [104, 67],
        [67, 103],
        [152, 175],
        [175, 148],
        [148, 152],
        [119, 118],
        [118, 101],
        [101, 119],
        [74, 73],
        [73, 40],
        [40, 74],
        [107, 9],
        [9, 108],
        [108, 107],
        [49, 48],
        [48, 131],
        [131, 49],
        [32, 194],
        [194, 211],
        [211, 32],
        [184, 74],
        [74, 185],
        [185, 184],
        [191, 80],
        [80, 183],
        [183, 191],
        [185, 40],
        [40, 186],
        [186, 185],
        [119, 230],
        [230, 118],
        [118, 119],
        [210, 202],
        [202, 214],
        [214, 210],
        [84, 83],
        [83, 17],
        [17, 84],
        [77, 76],
        [76, 146],
        [146, 77],
        [161, 160],
        [160, 30],
        [30, 161],
        [190, 56],
        [56, 173],
        [173, 190],
        [182, 106],
        [106, 194],
        [194, 182],
        [138, 135],
        [135, 192],
        [192, 138],
        [129, 203],
        [203, 98],
        [98, 129],
        [54, 21],
        [21, 68],
        [68, 54],
        [5, 51],
        [51, 4],
        [4, 5],
        [145, 144],
        [144, 23],
        [23, 145],
        [90, 77],
        [77, 91],
        [91, 90],
        [207, 205],
        [205, 187],
        [187, 207],
        [83, 201],
        [201, 18],
        [18, 83],
        [181, 91],
        [91, 182],
        [182, 181],
        [180, 90],
        [90, 181],
        [181, 180],
        [16, 85],
        [85, 17],
        [17, 16],
        [205, 206],
        [206, 36],
        [36, 205],
        [176, 148],
        [148, 140],
        [140, 176],
        [165, 92],
        [92, 39],
        [39, 165],
        [245, 193],
        [193, 244],
        [244, 245],
        [27, 159],
        [159, 28],
        [28, 27],
        [
          30,
          247
        ],
        [247, 161],
        [161, 30],
        [174, 236],
        [236, 196],
        [196, 174],
        [103, 54],
        [54, 104],
        [104, 103],
        [55, 193],
        [193, 8],
        [8, 55],
        [111, 117],
        [117, 31],
        [31, 111],
        [221, 189],
        [189, 55],
        [55, 221],
        [240, 98],
        [98, 99],
        [99, 240],
        [142, 126],
        [126, 100],
        [100, 142],
        [219, 166],
        [166, 218],
        [218, 219],
        [112, 155],
        [155, 26],
        [26, 112],
        [198, 209],
        [209, 131],
        [131, 198],
        [169, 135],
        [135, 150],
        [150, 169],
        [114, 47],
        [47, 217],
        [217, 114],
        [224, 223],
        [223, 53],
        [53, 224],
        [220, 45],
        [45, 134],
        [134, 220],
        [32, 211],
        [211, 140],
        [140, 32],
        [109, 67],
        [67, 108],
        [108, 109],
        [146, 43],
        [43, 91],
        [91, 146],
        [231, 230],
        [230, 120],
        [120, 231],
        [113, 226],
        [226, 247],
        [247, 113],
        [105, 63],
        [63, 52],
        [52, 105],
        [241, 238],
        [238, 242],
        [242, 241],
        [124, 46],
        [46, 156],
        [156, 124],
        [95, 78],
        [78, 96],
        [96, 95],
        [70, 46],
        [46, 63],
        [63, 70],
        [116, 143],
        [143, 227],
        [227, 116],
        [116, 123],
        [123, 111],
        [111, 116],
        [1, 44],
        [44, 19],
        [19, 1],
        [3, 236],
        [236, 51],
        [51, 3],
        [207, 216],
        [216, 205],
        [205, 207],
        [26, 154],
        [154, 22],
        [22, 26],
        [165, 39],
        [39, 167],
        [167, 165],
        [199, 200],
        [200, 208],
        [208, 199],
        [101, 36],
        [36, 100],
        [100, 101],
        [43, 57],
        [57, 202],
        [202, 43],
        [242, 20],
        [20, 99],
        [99, 242],
        [56, 28],
        [
          28,
          157
        ],
        [157, 56],
        [124, 35],
        [35, 113],
        [113, 124],
        [29, 160],
        [160, 27],
        [27, 29],
        [211, 204],
        [204, 210],
        [210, 211],
        [124, 113],
        [113, 46],
        [46, 124],
        [106, 43],
        [43, 204],
        [204, 106],
        [96, 62],
        [62, 77],
        [77, 96],
        [227, 137],
        [137, 116],
        [116, 227],
        [73, 41],
        [41, 72],
        [72, 73],
        [36, 203],
        [203, 142],
        [142, 36],
        [235, 64],
        [64, 240],
        [240, 235],
        [48, 49],
        [49, 64],
        [64, 48],
        [42, 41],
        [41, 74],
        [74, 42],
        [214, 212],
        [212, 207],
        [207, 214],
        [183, 42],
        [42, 184],
        [184, 183],
        [210, 169],
        [169, 211],
        [211, 210],
        [140, 170],
        [170, 176],
        [176, 140],
        [104, 105],
        [105, 69],
        [69, 104],
        [193, 122],
        [122, 168],
        [168, 193],
        [50, 123],
        [123, 187],
        [187, 50],
        [89, 96],
        [96, 90],
        [90, 89],
        [66, 65],
        [65, 107],
        [107, 66],
        [179, 89],
        [89, 180],
        [180, 179],
        [119, 101],
        [101, 120],
        [120, 119],
        [68, 63],
        [63, 104],
        [104, 68],
        [234, 93],
        [93, 227],
        [227, 234],
        [16, 15],
        [15, 85],
        [85, 16],
        [209, 129],
        [129, 49],
        [49, 209],
        [15, 14],
        [14, 86],
        [86, 15],
        [107, 55],
        [55, 9],
        [9, 107],
        [120, 100],
        [100, 121],
        [121, 120],
        [153, 145],
        [145, 22],
        [22, 153],
        [178, 88],
        [88, 179],
        [179, 178],
        [197, 6],
        [6, 196],
        [196, 197],
        [89, 88],
        [88, 96],
        [96, 89],
        [135, 138],
        [138, 136],
        [136, 135],
        [138, 215],
        [215, 172],
        [172, 138],
        [
          218,
          115
        ],
        [115, 219],
        [219, 218],
        [41, 42],
        [42, 81],
        [81, 41],
        [5, 195],
        [195, 51],
        [51, 5],
        [57, 43],
        [43, 61],
        [61, 57],
        [208, 171],
        [171, 199],
        [199, 208],
        [41, 81],
        [81, 38],
        [38, 41],
        [224, 53],
        [53, 225],
        [225, 224],
        [24, 144],
        [144, 110],
        [110, 24],
        [105, 52],
        [52, 66],
        [66, 105],
        [118, 229],
        [229, 117],
        [117, 118],
        [227, 34],
        [34, 234],
        [234, 227],
        [66, 107],
        [107, 69],
        [69, 66],
        [10, 109],
        [109, 151],
        [151, 10],
        [219, 48],
        [48, 235],
        [235, 219],
        [183, 62],
        [62, 191],
        [191, 183],
        [142, 129],
        [129, 126],
        [126, 142],
        [116, 111],
        [111, 143],
        [143, 116],
        [118, 117],
        [117, 50],
        [50, 118],
        [223, 222],
        [
          222,
          52
        ],
        [52, 223],
        [94, 19],
        [19, 141],
        [141, 94],
        [222, 221],
        [221, 65],
        [65, 222],
        [196, 3],
        [3, 197],
        [197, 196],
        [45, 220],
        [220, 44],
        [44, 45],
        [156, 70],
        [70, 139],
        [139, 156],
        [188, 122],
        [122, 245],
        [245, 188],
        [139, 71],
        [71, 162],
        [162, 139],
        [149, 170],
        [170, 150],
        [150, 149],
        [122, 188],
        [188, 196],
        [196, 122],
        [206, 216],
        [216, 92],
        [92, 206],
        [164, 2],
        [2, 167],
        [167, 164],
        [242, 141],
        [141, 241],
        [241, 242],
        [0, 164],
        [164, 37],
        [37, 0],
        [11, 72],
        [72, 12],
        [12, 11],
        [12, 38],
        [38, 13],
        [13, 12],
        [70, 63],
        [63, 71],
        [71, 70],
        [31, 226],
        [226, 111],
        [111, 31],
        [36, 101],
        [101, 205],
        [205, 36],
        [203, 206],
        [206, 165],
        [165, 203],
        [126, 209],
        [209, 217],
        [217, 126],
        [98, 165],
        [165, 97],
        [97, 98],
        [237, 220],
        [220, 218],
        [218, 237],
        [237, 239],
        [239, 241],
        [241, 237],
        [210, 214],
        [214, 169],
        [169, 210],
        [140, 171],
        [171, 32],
        [32, 140],
        [241, 125],
        [125, 237],
        [237, 241],
        [179, 86],
        [86, 178],
        [178, 179],
        [180, 85],
        [85, 179],
        [179, 180],
        [181, 84],
        [84, 180],
        [180, 181],
        [182, 83],
        [83, 181],
        [181, 182],
        [194, 201],
        [201, 182],
        [182, 194],
        [177, 137],
        [137, 132],
        [132, 177],
        [184, 76],
        [76, 183],
        [183, 184],
        [185, 61],
        [61, 184],
        [184, 185],
        [186, 57],
        [57, 185],
        [185, 186],
        [216, 212],
        [
          212,
          186
        ],
        [186, 216],
        [192, 214],
        [214, 187],
        [187, 192],
        [139, 34],
        [34, 156],
        [156, 139],
        [218, 79],
        [79, 237],
        [237, 218],
        [147, 123],
        [123, 177],
        [177, 147],
        [45, 44],
        [44, 4],
        [4, 45],
        [208, 201],
        [201, 32],
        [32, 208],
        [98, 64],
        [64, 129],
        [129, 98],
        [192, 213],
        [213, 138],
        [138, 192],
        [235, 59],
        [59, 219],
        [219, 235],
        [141, 242],
        [242, 97],
        [97, 141],
        [97, 2],
        [2, 141],
        [141, 97],
        [240, 75],
        [75, 235],
        [235, 240],
        [229, 24],
        [24, 228],
        [228, 229],
        [31, 25],
        [25, 226],
        [226, 31],
        [230, 23],
        [23, 229],
        [229, 230],
        [231, 22],
        [22, 230],
        [230, 231],
        [232, 26],
        [26, 231],
        [231, 232],
        [233, 112],
        [112, 232],
        [232, 233],
        [244, 189],
        [189, 243],
        [243, 244],
        [189, 221],
        [221, 190],
        [190, 189],
        [222, 28],
        [28, 221],
        [221, 222],
        [223, 27],
        [27, 222],
        [222, 223],
        [224, 29],
        [29, 223],
        [223, 224],
        [225, 30],
        [30, 224],
        [224, 225],
        [113, 247],
        [247, 225],
        [225, 113],
        [99, 60],
        [60, 240],
        [240, 99],
        [213, 147],
        [147, 215],
        [215, 213],
        [60, 20],
        [20, 166],
        [166, 60],
        [192, 187],
        [187, 213],
        [213, 192],
        [243, 112],
        [112, 244],
        [244, 243],
        [244, 233],
        [233, 245],
        [245, 244],
        [245, 128],
        [128, 188],
        [188, 245],
        [188, 114],
        [114, 174],
        [174, 188],
        [134, 131],
        [131, 220],
        [220, 134],
        [174, 217],
        [217, 236],
        [236, 174],
        [236, 198],
        [198, 134],
        [134, 236],
        [215, 177],
        [177, 58],
        [58, 215],
        [156, 143],
        [143, 124],
        [124, 156],
        [25, 110],
        [110, 7],
        [7, 25],
        [31, 228],
        [228, 25],
        [25, 31],
        [264, 356],
        [356, 368],
        [368, 264],
        [0, 11],
        [11, 267],
        [267, 0],
        [451, 452],
        [452, 349],
        [349, 451],
        [267, 302],
        [302, 269],
        [269, 267],
        [350, 357],
        [357, 277],
        [277, 350],
        [350, 452],
        [452, 357],
        [357, 350],
        [299, 333],
        [333, 297],
        [297, 299],
        [396, 175],
        [175, 377],
        [377, 396],
        [280, 347],
        [347, 330],
        [330, 280],
        [269, 303],
        [303, 270],
        [270, 269],
        [151, 9],
        [9, 337],
        [337, 151],
        [344, 278],
        [278, 360],
        [360, 344],
        [424, 418],
        [
          418,
          431
        ],
        [431, 424],
        [270, 304],
        [304, 409],
        [409, 270],
        [272, 310],
        [310, 407],
        [407, 272],
        [322, 270],
        [270, 410],
        [410, 322],
        [449, 450],
        [450, 347],
        [347, 449],
        [432, 422],
        [422, 434],
        [434, 432],
        [18, 313],
        [313, 17],
        [17, 18],
        [291, 306],
        [306, 375],
        [375, 291],
        [259, 387],
        [387, 260],
        [260, 259],
        [424, 335],
        [335, 418],
        [418, 424],
        [434, 364],
        [364, 416],
        [416, 434],
        [391, 423],
        [423, 327],
        [327, 391],
        [301, 251],
        [251, 298],
        [298, 301],
        [275, 281],
        [281, 4],
        [4, 275],
        [254, 373],
        [373, 253],
        [253, 254],
        [375, 307],
        [307, 321],
        [321, 375],
        [280, 425],
        [425, 411],
        [411, 280],
        [200, 421],
        [
          421,
          18
        ],
        [18, 200],
        [335, 321],
        [321, 406],
        [406, 335],
        [321, 320],
        [320, 405],
        [405, 321],
        [314, 315],
        [315, 17],
        [17, 314],
        [423, 426],
        [426, 266],
        [266, 423],
        [396, 377],
        [377, 369],
        [369, 396],
        [270, 322],
        [322, 269],
        [269, 270],
        [413, 417],
        [417, 464],
        [464, 413],
        [385, 386],
        [386, 258],
        [258, 385],
        [248, 456],
        [456, 419],
        [419, 248],
        [298, 284],
        [284, 333],
        [333, 298],
        [168, 417],
        [417, 8],
        [8, 168],
        [448, 346],
        [346, 261],
        [261, 448],
        [417, 413],
        [413, 285],
        [285, 417],
        [326, 327],
        [327, 328],
        [328, 326],
        [277, 355],
        [355, 329],
        [329, 277],
        [309, 392],
        [392, 438],
        [438, 309],
        [381, 382],
        [
          382,
          256
        ],
        [256, 381],
        [279, 429],
        [429, 360],
        [360, 279],
        [365, 364],
        [364, 379],
        [379, 365],
        [355, 277],
        [277, 437],
        [437, 355],
        [282, 443],
        [443, 283],
        [283, 282],
        [281, 275],
        [275, 363],
        [363, 281],
        [395, 431],
        [431, 369],
        [369, 395],
        [299, 297],
        [297, 337],
        [337, 299],
        [335, 273],
        [273, 321],
        [321, 335],
        [348, 450],
        [450, 349],
        [349, 348],
        [359, 446],
        [446, 467],
        [467, 359],
        [283, 293],
        [293, 282],
        [282, 283],
        [250, 458],
        [458, 462],
        [462, 250],
        [300, 276],
        [276, 383],
        [383, 300],
        [292, 308],
        [308, 325],
        [325, 292],
        [283, 276],
        [276, 293],
        [293, 283],
        [264, 372],
        [372, 447],
        [447, 264],
        [346, 352],
        [352, 340],
        [340, 346],
        [354, 274],
        [274, 19],
        [19, 354],
        [363, 456],
        [456, 281],
        [281, 363],
        [426, 436],
        [436, 425],
        [425, 426],
        [380, 381],
        [381, 252],
        [252, 380],
        [267, 269],
        [269, 393],
        [393, 267],
        [421, 200],
        [200, 428],
        [428, 421],
        [371, 266],
        [266, 329],
        [329, 371],
        [432, 287],
        [287, 422],
        [422, 432],
        [290, 250],
        [250, 328],
        [328, 290],
        [385, 258],
        [258, 384],
        [384, 385],
        [446, 265],
        [265, 342],
        [342, 446],
        [386, 387],
        [387, 257],
        [257, 386],
        [422, 424],
        [424, 430],
        [430, 422],
        [445, 342],
        [342, 276],
        [276, 445],
        [422, 273],
        [273, 424],
        [424, 422],
        [306, 292],
        [292, 307],
        [307, 306],
        [
          352,
          366
        ],
        [366, 345],
        [345, 352],
        [268, 271],
        [271, 302],
        [302, 268],
        [358, 423],
        [423, 371],
        [371, 358],
        [327, 294],
        [294, 460],
        [460, 327],
        [331, 279],
        [279, 294],
        [294, 331],
        [303, 271],
        [271, 304],
        [304, 303],
        [436, 432],
        [432, 427],
        [427, 436],
        [304, 272],
        [272, 408],
        [408, 304],
        [395, 394],
        [394, 431],
        [431, 395],
        [378, 395],
        [395, 400],
        [400, 378],
        [296, 334],
        [334, 299],
        [299, 296],
        [6, 351],
        [351, 168],
        [168, 6],
        [376, 352],
        [352, 411],
        [411, 376],
        [307, 325],
        [325, 320],
        [320, 307],
        [285, 295],
        [295, 336],
        [336, 285],
        [320, 319],
        [319, 404],
        [404, 320],
        [329, 330],
        [330, 349],
        [349, 329],
        [334, 293],
        [293, 333],
        [333, 334],
        [366, 323],
        [323, 447],
        [447, 366],
        [316, 15],
        [15, 315],
        [315, 316],
        [331, 358],
        [358, 279],
        [279, 331],
        [317, 14],
        [14, 316],
        [316, 317],
        [8, 285],
        [285, 9],
        [9, 8],
        [277, 329],
        [329, 350],
        [350, 277],
        [253, 374],
        [374, 252],
        [252, 253],
        [319, 318],
        [318, 403],
        [403, 319],
        [351, 6],
        [6, 419],
        [419, 351],
        [324, 318],
        [318, 325],
        [325, 324],
        [397, 367],
        [367, 365],
        [365, 397],
        [288, 435],
        [435, 397],
        [397, 288],
        [278, 344],
        [344, 439],
        [439, 278],
        [310, 272],
        [272, 311],
        [311, 310],
        [248, 195],
        [195, 281],
        [281, 248],
        [375, 273],
        [273, 291],
        [291, 375],
        [175, 396],
        [396, 199],
        [199, 175],
        [312, 311],
        [311, 268],
        [268, 312],
        [276, 283],
        [283, 445],
        [445, 276],
        [390, 373],
        [373, 339],
        [339, 390],
        [295, 282],
        [282, 296],
        [296, 295],
        [448, 449],
        [449, 346],
        [346, 448],
        [356, 264],
        [264, 454],
        [454, 356],
        [337, 336],
        [336, 299],
        [299, 337],
        [337, 338],
        [338, 151],
        [151, 337],
        [294, 278],
        [278, 455],
        [455, 294],
        [308, 292],
        [292, 415],
        [415, 308],
        [429, 358],
        [358, 355],
        [355, 429],
        [265, 340],
        [340, 372],
        [372, 265],
        [352, 346],
        [346, 280],
        [280, 352],
        [295, 442],
        [442, 282],
        [282, 295],
        [354, 19],
        [19, 370],
        [370, 354],
        [285, 441],
        [441, 295],
        [295, 285],
        [
          195,
          248
        ],
        [248, 197],
        [197, 195],
        [457, 440],
        [440, 274],
        [274, 457],
        [301, 300],
        [300, 368],
        [368, 301],
        [417, 351],
        [351, 465],
        [465, 417],
        [251, 301],
        [301, 389],
        [389, 251],
        [394, 395],
        [395, 379],
        [379, 394],
        [399, 412],
        [412, 419],
        [419, 399],
        [410, 436],
        [436, 322],
        [322, 410],
        [326, 2],
        [2, 393],
        [393, 326],
        [354, 370],
        [370, 461],
        [461, 354],
        [393, 164],
        [164, 267],
        [267, 393],
        [268, 302],
        [302, 12],
        [12, 268],
        [312, 268],
        [268, 13],
        [13, 312],
        [298, 293],
        [293, 301],
        [301, 298],
        [265, 446],
        [446, 340],
        [340, 265],
        [280, 330],
        [330, 425],
        [425, 280],
        [322, 426],
        [426, 391],
        [391, 322],
        [
          420,
          429
        ],
        [429, 437],
        [437, 420],
        [393, 391],
        [391, 326],
        [326, 393],
        [344, 440],
        [440, 438],
        [438, 344],
        [458, 459],
        [459, 461],
        [461, 458],
        [364, 434],
        [434, 394],
        [394, 364],
        [428, 396],
        [396, 262],
        [262, 428],
        [274, 354],
        [354, 457],
        [457, 274],
        [317, 316],
        [316, 402],
        [402, 317],
        [316, 315],
        [315, 403],
        [403, 316],
        [315, 314],
        [314, 404],
        [404, 315],
        [314, 313],
        [313, 405],
        [405, 314],
        [313, 421],
        [421, 406],
        [406, 313],
        [323, 366],
        [366, 361],
        [361, 323],
        [292, 306],
        [306, 407],
        [407, 292],
        [306, 291],
        [291, 408],
        [408, 306],
        [291, 287],
        [287, 409],
        [409, 291],
        [287, 432],
        [432, 410],
        [410, 287],
        [427, 434],
        [434, 411],
        [411, 427],
        [372, 264],
        [264, 383],
        [383, 372],
        [459, 309],
        [309, 457],
        [457, 459],
        [366, 352],
        [352, 401],
        [401, 366],
        [1, 274],
        [274, 4],
        [4, 1],
        [418, 421],
        [421, 262],
        [262, 418],
        [331, 294],
        [294, 358],
        [358, 331],
        [435, 433],
        [433, 367],
        [367, 435],
        [392, 289],
        [289, 439],
        [439, 392],
        [328, 462],
        [462, 326],
        [326, 328],
        [94, 2],
        [2, 370],
        [370, 94],
        [289, 305],
        [305, 455],
        [455, 289],
        [339, 254],
        [254, 448],
        [448, 339],
        [359, 255],
        [255, 446],
        [446, 359],
        [254, 253],
        [253, 449],
        [449, 254],
        [253, 252],
        [252, 450],
        [450, 253],
        [252, 256],
        [256, 451],
        [451, 252],
        [
          256,
          341
        ],
        [341, 452],
        [452, 256],
        [414, 413],
        [413, 463],
        [463, 414],
        [286, 441],
        [441, 414],
        [414, 286],
        [286, 258],
        [258, 441],
        [441, 286],
        [258, 257],
        [257, 442],
        [442, 258],
        [257, 259],
        [259, 443],
        [443, 257],
        [259, 260],
        [260, 444],
        [444, 259],
        [260, 467],
        [467, 445],
        [445, 260],
        [309, 459],
        [459, 250],
        [250, 309],
        [305, 289],
        [289, 290],
        [290, 305],
        [305, 290],
        [290, 460],
        [460, 305],
        [401, 376],
        [376, 435],
        [435, 401],
        [309, 250],
        [250, 392],
        [392, 309],
        [376, 411],
        [411, 433],
        [433, 376],
        [453, 341],
        [341, 464],
        [464, 453],
        [357, 453],
        [453, 465],
        [465, 357],
        [343, 357],
        [357, 412],
        [412, 343],
        [437, 343],
        [343, 399],
        [399, 437],
        [344, 360],
        [360, 440],
        [440, 344],
        [420, 437],
        [437, 456],
        [456, 420],
        [360, 420],
        [420, 363],
        [363, 360],
        [361, 401],
        [401, 288],
        [288, 361],
        [265, 372],
        [372, 353],
        [353, 265],
        [390, 339],
        [339, 249],
        [249, 390],
        [339, 448],
        [448, 255],
        [255, 339]
      ]);
      P("matrixDataToMatrix", function(a) {
        for (var b = a.getCols(), c = a.getRows(), d = a.getPackedDataList(), e = [], g = 0; g < c; g++) e.push(Array(b));
        for (g = 0; g < c; g++) for (var f = 0; f < b; f++) {
          var h = 1 === a.getLayout() ? g * b + f : f * c + g;
          e[g][f] = d[h];
        }
        return e;
      });
      P("VERSION", "0.4.1633559619");
    }).call(exports);
  }
});

// src/app/dashboard/gazeTracker.ts
function updateIntrinsicsFromCamera() {
  const { width, height } = cameraModel;
  const fx = 0.9 * Math.min(width, height);
  cameraModel.fx = fx;
  cameraModel.fy = fx;
  cameraModel.cx = width / 2;
  cameraModel.cy = height / 2;
}
function setCameraFromVideo(videoEl) {
  const w = videoEl.videoWidth || videoEl.clientWidth || 640;
  const h = videoEl.videoHeight || videoEl.clientHeight || 480;
  cameraModel.width = Math.max(2, w);
  cameraModel.height = Math.max(2, h);
  updateIntrinsicsFromCamera();
}
function kalmanStepGaze(xm, ym, nowMs, cal) {
  const { xn, yn } = measurementToNormalized(xm, ym);
  const { xw, yw } = warpEdgeNonlinearity(xn, yn, cal);
  const depthComp = cameraModel.width / cameraModel.fx * 1e-3;
  const xp = xw + depthComp * (xw - 0.5);
  const yp = yw + depthComp * (yw - 0.5);
  const dt = lastKalmanT === 0 ? 1 / 60 : Math.min(0.1, Math.max(1 / 240, (nowMs - lastKalmanT) / 1e3));
  lastKalmanT = nowMs;
  const F = [
    [1, 0, dt, 0],
    [0, 1, 0, dt],
    [0, 0, 1, 0],
    [0, 0, 0, 1]
  ];
  const H = [
    [1, 0, 0, 0],
    [0, 1, 0, 0]
  ];
  const edgeX = Math.min(1, Math.abs(xp - 0.5) * 2);
  const edgeY = Math.min(1, Math.abs(yp - 0.5) * 2);
  const qScaleX = 0.3 + 0.7 * edgeX;
  const qScaleY = 0.3 + 0.7 * edgeY;
  const Qs = [
    [kalmanQbase[0][0] * qScaleX, 0, 0, 0],
    [0, kalmanQbase[1][1] * qScaleY, 0, 0],
    [0, 0, kalmanQbase[2][2] * qScaleX, 0],
    [0, 0, 0, kalmanQbase[3][3] * qScaleY]
  ];
  kalmanX = matMulVecNum(F, kalmanX);
  const Ft = transpose(F);
  kalmanP = matAddNum(matMulFFNum(matMulFFNum(F, kalmanP), Ft), Qs);
  const z = [xp, yp];
  const HX = matMulVecNum(H, kalmanX);
  const innov = [z[0] - HX[0], z[1] - HX[1]];
  const Ht = transpose(H);
  const S2 = matAddNum(matMulFFNum(matMulFFNum(H, kalmanP), Ht), kalmanR);
  const K = matMulFFNum(matMulFFNum(kalmanP, Ht), inv2(S2));
  kalmanX = matAddVec(kalmanX, matMulVecNum(K, innov));
  const I = eye(4, 1);
  const KH = matMulFFNum(K, H);
  const IKH = matSubNum(I, KH);
  const term1 = matMulFFNum(matMulFFNum(IKH, kalmanP), transpose(IKH));
  const term2 = matMulFFNum(matMulFFNum(K, kalmanR), transpose(K));
  kalmanP = matAddNum(term1, term2);
  return {
    xk: Math.max(-0.5, Math.min(1.5, kalmanX[0])),
    yk: Math.max(-0.5, Math.min(1.5, kalmanX[1]))
  };
}
function measurementToNormalized(xm, ym) {
  const { width, height, fx, fy, cx, cy, tiltX, tiltY, roll, homography } = cameraModel;
  const u2 = xm * (width - 1);
  const v = ym * (height - 1);
  let uDeskew = u2, vDeskew = v;
  if (homography) {
    const denom = homography[2][0] * u2 + homography[2][1] * v + homography[2][2];
    const s = Math.abs(denom) < 1e-9 ? denom >= 0 ? 1e-9 : -1e-9 : denom;
    uDeskew = (homography[0][0] * u2 + homography[0][1] * v + homography[0][2]) / s;
    vDeskew = (homography[1][0] * u2 + homography[1][1] * v + homography[1][2]) / s;
  } else if (tiltX || tiltY || roll) {
    const x = (u2 - cx) / fx;
    const y = (v - cy) / fy;
    const ray = [x, y, 1];
    const Rz = rotZ(-roll), Rx = rotX(-tiltX), Ry = rotY(-tiltY);
    const R = matMulFFNum(matMulFFNum(Rz, Rx), Ry);
    const r = matMulVecNum(R, ray);
    const Xp = r[0] / r[2];
    const Yp = r[1] / r[2];
    uDeskew = fx * Xp + cx;
    vDeskew = fy * Yp + cy;
  }
  return { xn: uDeskew / (width - 1), yn: vDeskew / (height - 1) };
}
function warpEdgeNonlinearity(x, y, cal) {
  const { leftTh, rightTh } = computeThresholds(cal || {});
  const L = clamp01(leftTh);
  const R = clamp01(rightTh);
  if (R - L <= 1e-6)
    return { xw: x, yw: y };
  let t2 = (x - L) / (R - L);
  t2 = clamp01(t2);
  const a0 = 0, a1 = 0.25, a2 = 0.75, a3 = 1;
  const k = 0.07;
  let xw;
  if (t2 < 1 / 3) {
    const u2 = t2 / (1 / 3);
    xw = a0 * (1 - u2) + a1 * u2;
  } else if (t2 < 2 / 3) {
    const u2 = (t2 - 1 / 3) / (1 / 3);
    xw = a1 * (1 - u2) + a2 * u2;
  } else {
    const u2 = (t2 - 2 / 3) / (1 / 3);
    xw = a2 * (1 - u2) + a3 * u2;
  }
  xw += (t2 - 0.5) * k * (1 - Math.abs(t2 - 0.5));
  return { xw: clamp01(xw), yw: y };
}
function rotX(a) {
  const c = Math.cos(a), s = Math.sin(a);
  return [
    [1, 0, 0],
    [0, c, -s],
    [0, s, c]
  ];
}
function rotY(a) {
  const c = Math.cos(a), s = Math.sin(a);
  return [
    [c, 0, s],
    [0, 1, 0],
    [-s, 0, c]
  ];
}
function rotZ(a) {
  const c = Math.cos(a), s = Math.sin(a);
  return [
    [c, -s, 0],
    [s, c, 0],
    [0, 0, 1]
  ];
}
function ensureOverlay() {
  if (!overlayCanvas) {
    overlayCanvas = document.createElement("canvas");
    overlayCanvas.id = "gaze-overlay";
    Object.assign(overlayCanvas.style, {
      position: "fixed",
      pointerEvents: "none",
      zIndex: "999999",
      top: "0",
      left: "0",
      width: "100vw",
      height: "100vh"
    });
    document.body.appendChild(overlayCanvas);
    overlayCtx = overlayCanvas.getContext("2d");
  } else if (!overlayCtx) {
    overlayCtx = overlayCanvas.getContext("2d");
  }
}
function resizeOverlay() {
  if (!overlayCanvas || !overlayCtx)
    return;
  const dpr = window.devicePixelRatio || 1;
  const cssW = Math.floor(window.innerWidth);
  const cssH = Math.floor(window.innerHeight);
  const reqW = Math.floor(cssW * dpr);
  const reqH = Math.floor(cssH * dpr);
  if (overlayCanvas.width !== reqW || overlayCanvas.height !== reqH) {
    overlayCanvas.width = reqW;
    overlayCanvas.height = reqH;
    overlayCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
}
function computeGazeDot(lm, cal) {
  const feat = featuresFromLandmarks(lm);
  if (!feat)
    return { x: -1, y: -1 };
  const { h, v } = feat;
  const { hs, vs } = adaptiveSmooth(h, v);
  const { xNorm, yNorm } = mapToScreen(hs, vs, cal);
  const now = performance.now();
  const { xk, yk } = kalmanStepGaze(xNorm, yNorm, now, cal);
  const { xo, yo } = interpolateOut(xk, yk, now);
  return {
    x: xo * window.innerWidth,
    y: yo * window.innerHeight
  };
}
function updateGazePresence(lm, cal, callback) {
  const now = Date.now();
  const screenW = window.innerWidth;
  const screenH = window.innerHeight;
  const margin = 0.1;
  if (!lm) {
    if (faceDetected) {
      faceDetected = false;
      lastOnScreenTime = now;
    }
    if (now - lastOnScreenTime > 3e3) {
      if (currentPresence !== "offscreen") {
        currentPresence = "offscreen";
        drawPresenceBorder("offscreen");
      }
      if (now - lastGazeBroadcast >= GAZE_BROADCAST_THROTTLE) {
        callback("offscreen");
        lastGazeBroadcast = now;
      }
    }
    return;
  }
  faceDetected = true;
  const { x, y } = computeGazeDot(lm, cal);
  const inside2 = x >= -screenW * margin && x <= screenW * (1 + margin) && y >= -screenH * margin && y <= screenH * (1 + margin);
  if (inside2) {
    lastOnScreenTime = now;
    const feat = lm && featuresFromLandmarks(lm);
    let status = "CENTER";
    if (feat && cal?.["top-center"]) {
      const topCal = cal["top-center"].vert;
      const margin2 = 0.02;
      const pupilDistUp = feat.upRatio > 0.6;
      if (feat.v < topCal - margin2 && pupilDistUp) {
        status = "UP";
      }
    }
    if (currentPresence !== status) {
      currentPresence = status;
      drawPresenceBorder("CENTER");
    }
    if (now - lastGazeBroadcast >= GAZE_BROADCAST_THROTTLE) {
      callback(status);
      lastGazeBroadcast = now;
    }
  } else if (now - lastOnScreenTime > 3e3) {
    if (currentPresence !== "offscreen") {
      currentPresence = "offscreen";
      drawPresenceBorder("offscreen");
    }
    if (now - lastGazeBroadcast >= GAZE_BROADCAST_THROTTLE) {
      callback("offscreen");
      lastGazeBroadcast = now;
    }
  }
}
function drawPresenceBorder(status) {
  if (!overlayCtx || !overlayCanvas)
    return;
  const now = performance.now();
  if (now - lastBorderDraw < 200)
    return;
  lastBorderDraw = now;
  const ctx = overlayCtx;
  const w = window.innerWidth;
  const h = window.innerHeight;
  ctx.save();
  ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
  ctx.lineWidth = 10;
  ctx.strokeStyle = status === "offscreen" ? "rgba(255,0,0,0.6)" : "rgba(0,255,0,0.6)";
  ctx.strokeRect(5, 5, w - 10, h - 10);
  ctx.font = "20px Arial";
  ctx.fillStyle = status === "offscreen" ? "red" : "lime";
  ctx.fillText(status === "offscreen" ? "OFFSCREEN" : "ONSCREEN", 20, 40);
  ctx.restore();
}
function startGazeTracking(videoEl, socket, userName, callback, calibrationThresholds, debugMode = true) {
  return __async(this, null, function* () {
    if (running)
      return;
    running = true;
    debug = debugMode;
    faceMesh = new import_face_mesh.FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });
    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.6
    });
    yield faceMesh.initialize();
    ensureOverlay();
    resizeOverlay();
    window.addEventListener("resize", resizeOverlay);
    faceMesh.onResults((results) => {
      if (!overlayCtx || !overlayCanvas)
        return;
      const ctx = overlayCtx;
      ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      if (cameraModel.fx === 1)
        setCameraFromVideo(videoEl);
      if (!results.multiFaceLandmarks?.length) {
        updateGazePresence(null, calibrationThresholds, callback || (() => {
        }));
        return;
      }
      const lm = results.multiFaceLandmarks[0];
      window.lastFaceLandmarks = lm;
      updateGazePresence(lm, calibrationThresholds, callback || (() => {
      }));
    });
    const loop = () => __async(null, null, function* () {
      if (!running)
        return;
      if (videoEl.readyState >= 2 && faceMesh) {
        try {
          yield faceMesh.send({ image: videoEl });
        } catch (e) {
          console.warn("FaceMesh error", e);
        }
      }
      rafId = requestAnimationFrame(loop);
    });
    loop();
  });
}
function stopGazeTracking() {
  if (!running)
    return;
  running = false;
  if (rafId)
    cancelAnimationFrame(rafId);
  rafId = null;
  faceMesh?.close();
  faceMesh = null;
  window.removeEventListener("resize", resizeOverlay);
  gazeHistory.length = 0;
  model2 = null;
  samples.length = 0;
  emaH = emaV = lastH = lastV = 0.5;
  avgSpeed = 8;
  stableGaze = "CENTER";
  lastDiscreteStatus = "CENTER";
  calScaleH = calScaleV = 1;
  deviceRatio = 1;
  lastOut = lastTarget = null;
  kalmanX = [0.5, 0.5, 0, 0];
  kalmanP = eye(4, 0.01);
  lastKalmanT = 0;
  lastGazeBroadcast = 0;
}
function startCalibration() {
  return __async(this, null, function* () {
    emaH = emaV = lastH = lastV = 0.5;
    avgSpeed = 8;
    lastOut = lastTarget = null;
    const prevDisplay = overlayCanvas?.style.display;
    if (overlayCanvas)
      overlayCanvas.style.display = "none";
    const calCanvas = document.createElement("canvas");
    Object.assign(calCanvas.style, {
      position: "fixed",
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      backgroundColor: "rgba(0,0,0,0.75)",
      zIndex: "999999",
      cursor: "none"
    });
    document.body.appendChild(calCanvas);
    const dpr = window.devicePixelRatio || 1;
    const cssW = window.innerWidth;
    const cssH = window.innerHeight;
    calCanvas.width = cssW * dpr;
    calCanvas.height = cssH * dpr;
    const cctx = calCanvas.getContext("2d");
    cctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    try {
      const fn = (calCanvas.requestFullscreen || calCanvas.webkitRequestFullscreen || calCanvas.mozRequestFullScreen || calCanvas.msRequestFullscreen) ?? null;
      if (typeof fn === "function")
        yield fn.call(calCanvas);
    } catch {
    }
    const positions = [
      { name: "top-left", x: 0.2, y: 0.2 },
      { name: "top-center", x: 0.5, y: 0.2 },
      { name: "top-right", x: 0.8, y: 0.2 },
      { name: "mid-left", x: 0.2, y: 0.5 },
      { name: "center", x: 0.5, y: 0.5 },
      { name: "mid-right", x: 0.8, y: 0.5 },
      { name: "bottom-left", x: 0.2, y: 0.8 },
      { name: "bottom-center", x: 0.5, y: 0.8 },
      { name: "bottom-right", x: 0.8, y: 0.8 }
    ];
    const samplesByPoint = {};
    positions.forEach((p) => samplesByPoint[p.name] = { h: [], v: [] });
    for (let i = 0; i < positions.length; i++) {
      const p = positions[i];
      const start = performance.now();
      while (performance.now() - start < 2500) {
        cctx.clearRect(0, 0, cssW, cssH);
        cctx.beginPath();
        cctx.arc(p.x * cssW, p.y * cssH, Math.max(10, cssH * 0.015), 0, Math.PI * 2);
        cctx.fillStyle = "rgba(255,0,0,0.95)";
        cctx.fill();
        cctx.fillStyle = "#fff";
        cctx.font = "20px Arial";
        cctx.fillText(`Point ${i + 1}/9`, 24, 42);
        const lm = window.lastFaceLandmarks;
        const feat = lm && featuresFromLandmarks(lm);
        if (feat) {
          samplesByPoint[p.name].h.push(feat.h);
          samplesByPoint[p.name].v.push(feat.v);
        }
        yield new Promise((r) => requestAnimationFrame(() => r()));
      }
      yield new Promise((r) => setTimeout(r, 200));
    }
    const cal = {};
    for (const k of Object.keys(samplesByPoint)) {
      const H = samplesByPoint[k].h.sort((a, b) => a - b);
      const V = samplesByPoint[k].v.sort((a, b) => a - b);
      const hm = H.length ? H[Math.floor(H.length / 2)] : 0.5;
      const vm = V.length ? V[Math.floor(V.length / 2)] : 0.5;
      cal[k] = { horiz: hm, vert: vm };
    }
    try {
      if (document.fullscreenElement)
        yield document.exitFullscreen();
    } catch {
    }
    calCanvas.remove();
    if (overlayCanvas)
      overlayCanvas.style.display = prevDisplay || "";
    lastOut = lastTarget = null;
    return cal;
  });
}
function clamp2(v, min, max) {
  return Math.max(min, Math.min(max, v));
}
function clamp01(v) {
  return Math.max(0, Math.min(1, v));
}
function eye(n, scale = 1) {
  const M = Array.from({ length: n }, () => Array(n).fill(0));
  for (let i = 0; i < n; i++)
    M[i][i] = scale;
  return M;
}
function matAddNum(A, B) {
  return A.map((r, i) => r.map((v, j) => v + B[i][j]));
}
function matSubNum(A, B) {
  return A.map((r, i) => r.map((v, j) => v - B[i][j]));
}
function matMulFFNum(A, B, transB = false) {
  const aR = A.length, aC = A[0].length;
  const bR = transB ? B[0].length : B.length;
  const bC = transB ? B.length : B[0].length;
  const out = Array.from({ length: aR }, () => Array(bC).fill(0));
  for (let i = 0; i < aR; i++) {
    for (let k = 0; k < aC; k++) {
      const aik = A[i][k];
      for (let j = 0; j < bC; j++) {
        out[i][j] += aik * (transB ? B[j][k] : B[k][j]);
      }
    }
  }
  return out;
}
function matMulVecNum(A, x) {
  return A.map((r) => r.reduce((sum, v, j) => sum + v * x[j], 0));
}
function matAddVec(a, b) {
  return a.map((v, i) => v + b[i]);
}
function transpose(A) {
  const r = A.length, c = A[0].length;
  const T = Array.from({ length: c }, () => Array(r).fill(0));
  for (let i = 0; i < r; i++)
    for (let j = 0; j < c; j++)
      T[j][i] = A[i][j];
  return T;
}
function inv2(S2) {
  const a = S2[0][0], b = S2[0][1], c = S2[1][0], d = S2[1][1];
  const det = a * d - b * c || 1e-9;
  return [
    [d / det, -b / det],
    [-c / det, a / det]
  ];
}
function featuresFromLandmarks(lm) {
  if (!lm || lm.length < 478)
    return null;
  const irisL = lm[468];
  const irisR = lm[473];
  const iris = {
    x: (irisL.x + irisR.x) / 2,
    y: (irisL.y + irisR.y) / 2
  };
  const leftCorner = lm[33];
  const rightCorner = lm[263];
  const topLid = lm[159];
  const bottomLid = lm[145];
  const h = (iris.x - leftCorner.x) / (rightCorner.x - leftCorner.x);
  const v = (iris.y - topLid.y) / (bottomLid.y - topLid.y);
  const pupilBottomDist = bottomLid.y - iris.y;
  const baseline = bottomLid.y - topLid.y;
  const upRatio = pupilBottomDist / baseline;
  return { h: clamp01(h), v: clamp01(v), upRatio };
}
function computeThresholds(cal) {
  const leftTh = cal["top-left"]?.horiz ?? cal["mid-left"]?.horiz ?? cal["bottom-left"]?.horiz ?? 0.45;
  const rightTh = cal["top-right"]?.horiz ?? cal["mid-right"]?.horiz ?? cal["bottom-right"]?.horiz ?? 0.55;
  return { leftTh, rightTh };
}
function adaptiveSmooth(h, v) {
  const dh = Math.abs(h - lastH);
  const dv = Math.abs(v - lastV);
  const speed = Math.sqrt(dh * dh + dv * dv) * 1e3;
  avgSpeed = 0.8 * avgSpeed + 0.2 * speed;
  const alpha = clamp01(MIN_ALPHA + (MAX_ALPHA - MIN_ALPHA) * Math.exp(-avgSpeed / 20));
  emaH = emaH * (1 - alpha) + h * alpha;
  emaV = emaV * (1 - alpha) + v * alpha;
  lastH = h;
  lastV = v;
  return { hs: emaH, vs: emaV };
}
function mapToScreen(h, v, cal) {
  const baseX = (h - (cal?.["mid-left"]?.horiz ?? 0.45)) / ((cal?.["mid-right"]?.horiz ?? 0.55) - (cal?.["mid-left"]?.horiz ?? 0.45));
  const baseY = (v - (cal?.["top-center"]?.vert ?? 0.35)) / ((cal?.["bottom-center"]?.vert ?? 0.45) - (cal?.["top-center"]?.vert ?? 0.35));
  const xNorm = Math.max(-0.5, Math.min(1.5, baseX));
  const yNorm = Math.max(-0.5, Math.min(1.5, baseY));
  return { xNorm, yNorm };
}
function interpolateOut(x, y, now) {
  const target = { x, y, t: now };
  if (!lastOut) {
    lastOut = target;
    lastTarget = target;
    return { xo: x, yo: y };
  }
  const dt = (now - lastOut.t) / 1e3;
  const rate = clamp2(dt * 5, 0, 1);
  const xo = lastOut.x + (target.x - lastOut.x) * rate;
  const yo = lastOut.y + (target.y - lastOut.y) * rate;
  lastOut = { x: xo, y: yo, t: now };
  lastTarget = target;
  return { xo, yo };
}
var import_face_mesh, faceMesh, running, rafId, overlayCanvas, overlayCtx, debug, gazeHistory, stableGaze, lastDiscreteStatus, emaH, emaV, lastH, lastV, avgSpeed, MIN_ALPHA, MAX_ALPHA, model2, samples, calScaleH, calScaleV, deviceRatio, lastOut, lastTarget, cameraModel, kalmanX, kalmanP, kalmanQbase, kalmanR, lastKalmanT, lastOnScreenTime, faceDetected, currentPresence, lastBorderDraw, lastGazeBroadcast, GAZE_BROADCAST_THROTTLE;
var init_gazeTracker = __esm({
  "src/app/dashboard/gazeTracker.ts"() {
    "use strict";
    import_face_mesh = __toESM(require_face_mesh());
    faceMesh = null;
    running = false;
    rafId = null;
    overlayCanvas = null;
    overlayCtx = null;
    debug = true;
    gazeHistory = [];
    stableGaze = "CENTER";
    lastDiscreteStatus = "CENTER";
    emaH = 0.5;
    emaV = 0.5;
    lastH = 0.5;
    lastV = 0.5;
    avgSpeed = 8;
    MIN_ALPHA = 0.03;
    MAX_ALPHA = 0.25;
    model2 = null;
    samples = [];
    calScaleH = 1;
    calScaleV = 1;
    deviceRatio = 1;
    lastOut = null;
    lastTarget = null;
    cameraModel = {
      width: 640,
      height: 480,
      fx: 1,
      fy: 1,
      cx: 0.5,
      cy: 0.5,
      tiltX: 0,
      tiltY: 0,
      roll: 0,
      homography: null
    };
    kalmanX = [0.5, 0.5, 0, 0];
    kalmanP = eye(4, 0.01);
    kalmanQbase = [
      [1e-6, 0, 0, 0],
      [0, 1e-6, 0, 0],
      [0, 0, 2e-4, 0],
      [0, 0, 0, 2e-4]
    ];
    kalmanR = [
      [2e-4, 0],
      [0, 2e-4]
    ];
    lastKalmanT = 0;
    lastOnScreenTime = Date.now();
    faceDetected = false;
    currentPresence = "offscreen";
    lastBorderDraw = 0;
    lastGazeBroadcast = 0;
    GAZE_BROADCAST_THROTTLE = 150;
  }
});

// src/app/dashboard/voiceAnalyzer.ts
function initModel() {
  return __async(this, null, function* () {
    console.log("\u2705 Using backend API for speaker verification (no frontend model needed)");
    return Promise.resolve();
  });
}
var init_voiceAnalyzer = __esm({
  "src/app/dashboard/voiceAnalyzer.ts"() {
    "use strict";
  }
});

// src/app/dashboard/voice.service.ts
var VoiceService;
var init_voice_service = __esm({
  "src/app/dashboard/voice.service.ts"() {
    "use strict";
    init_core();
    init_esm();
    init_operators();
    init_core();
    init_http();
    VoiceService = class _VoiceService {
      http;
      API_BASE = "video-call/api/voice";
      constructor(http) {
        this.http = http;
      }
      /**
       * Enroll a voice sample
       */
      enrollVoice(audioBlob, room, username) {
        const formData = new FormData();
        formData.append("audio", audioBlob, "audio.webm");
        formData.append("room", room);
        formData.append("username", username);
        return this.http.post(`${this.API_BASE}/enroll`, formData).pipe(catchError((error) => {
          console.error("Enrollment error:", error);
          return throwError(() => new Error(error.error?.message || "Enrollment failed"));
        }));
      }
      /**
       * Verify a voice sample against stored baseline
       * (Assumes client-side has already filtered silence / noise)
       */
      verifyVoice(audioBlob, room, username) {
        const formData = new FormData();
        formData.append("audio", audioBlob, "audio.webm");
        formData.append("room", room);
        formData.append("username", username);
        return this.http.post(`${this.API_BASE}/verify`, formData).pipe(catchError((error) => {
          console.error("Verification error:", error);
          return throwError(() => new Error(error.error?.message || "Verification failed"));
        }));
      }
      static \u0275fac = function VoiceService_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _VoiceService)(\u0275\u0275inject(HttpClient));
      };
      static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _VoiceService, factory: _VoiceService.\u0275fac, providedIn: "root" });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(VoiceService, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], () => [{ type: HttpClient }], null);
    })();
  }
});

// src/app/dashboard/dashboard.ts
function Dashboard_div_0_span_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 24);
    \u0275\u0275text(1, "\u2713");
    \u0275\u0275elementEnd();
  }
}
function Dashboard_div_0_span_25_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 24);
    \u0275\u0275text(1, "\u2713");
    \u0275\u0275elementEnd();
  }
}
function Dashboard_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 5)(1, "div", 6)(2, "div", 7)(3, "div", 8);
    \u0275\u0275element(4, "i", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "h2", 10);
    \u0275\u0275text(6, "Camera & Microphone Access");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "p", 11);
    \u0275\u0275text(8, "This app needs access to your camera and microphone to work properly.");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(9, "div", 12)(10, "div", 13);
    \u0275\u0275element(11, "i", 14);
    \u0275\u0275elementStart(12, "div", 15)(13, "div", 16);
    \u0275\u0275text(14, "Camera");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "div", 17);
    \u0275\u0275text(16, "Required for video calls");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(17, Dashboard_div_0_span_17_Template, 2, 0, "span", 18);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(18, "div", 13);
    \u0275\u0275element(19, "i", 19);
    \u0275\u0275elementStart(20, "div", 15)(21, "div", 16);
    \u0275\u0275text(22, "Microphone");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(23, "div", 17);
    \u0275\u0275text(24, "Required for audio calls");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(25, Dashboard_div_0_span_25_Template, 2, 0, "span", 18);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(26, "div", 20)(27, "button", 21);
    \u0275\u0275listener("click", function Dashboard_div_0_Template_button_click_27_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.requestPermissions());
    });
    \u0275\u0275text(28, " Grant Access ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(29, "button", 22);
    \u0275\u0275listener("click", function Dashboard_div_0_Template_button_click_29_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.closePermissionPopup());
    });
    \u0275\u0275text(30, " Skip ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(31, "p", 23);
    \u0275\u0275text(32, " You can change these permissions later in your browser settings ");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(17);
    \u0275\u0275property("ngIf", ctx_r1.permissionStatus.camera);
    \u0275\u0275advance(8);
    \u0275\u0275property("ngIf", ctx_r1.permissionStatus.microphone);
  }
}
function Dashboard_main_1_p_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "p", 48);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("Progress: ", ctx_r1.progressPercent, "%");
  }
}
function Dashboard_main_1_div_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 49)(1, "p", 50);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "blockquote", 51);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate2(" Prompt ", ctx_r1.takeIndex + 1, " of ", ctx_r1.totalTakes, " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", ctx_r1.currentPrompt, " ");
  }
}
function Dashboard_main_1_button_23_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 52);
    \u0275\u0275listener("click", function Dashboard_main_1_button_23_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.startEnrollment());
    });
    \u0275\u0275text(1, " Start Enrollment ");
    \u0275\u0275elementEnd();
  }
}
function Dashboard_main_1_button_24_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 53);
    \u0275\u0275listener("click", function Dashboard_main_1_button_24_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.handleRecordClick());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("disabled", !ctx_r1.canUseRecorder);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.isRecording ? "Stop Recording" : "Record", " ");
  }
}
function Dashboard_main_1_p_25_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "p", 54);
    \u0275\u0275text(1, " Voice profile saved. You can re-enroll anytime. ");
    \u0275\u0275elementEnd();
  }
}
function Dashboard_main_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "main")(1, "div", 25)(2, "div", 26)(3, "h2", 27);
    \u0275\u0275text(4, "Join the Room");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "label", 28)(6, "span", 29);
    \u0275\u0275text(7, "Enter your name");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "input", 30);
    \u0275\u0275twoWayListener("ngModelChange", function Dashboard_main_1_Template_input_ngModelChange_8_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.userName, $event) || (ctx_r1.userName = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(9, "div", 31)(10, "div", 32)(11, "div", 33);
    \u0275\u0275element(12, "i", 34);
    \u0275\u0275elementStart(13, "span");
    \u0275\u0275text(14, "Voice Enrollment");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(15, "div", 35)(16, "p", 36);
    \u0275\u0275text(17);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(18, "div", 37);
    \u0275\u0275element(19, "div", 38);
    \u0275\u0275elementEnd();
    \u0275\u0275template(20, Dashboard_main_1_p_20_Template, 2, 1, "p", 39);
    \u0275\u0275elementEnd();
    \u0275\u0275template(21, Dashboard_main_1_div_21_Template, 5, 3, "div", 40);
    \u0275\u0275elementStart(22, "div", 41);
    \u0275\u0275template(23, Dashboard_main_1_button_23_Template, 2, 0, "button", 42)(24, Dashboard_main_1_button_24_Template, 2, 2, "button", 43);
    \u0275\u0275elementEnd();
    \u0275\u0275template(25, Dashboard_main_1_p_25_Template, 2, 0, "p", 44);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(26, "label", 45)(27, "input", 46);
    \u0275\u0275twoWayListener("ngModelChange", function Dashboard_main_1_Template_input_ngModelChange_27_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.termsCheckbox, $event) || (ctx_r1.termsCheckbox = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(28, "span", 29);
    \u0275\u0275text(29, "I agree to the Terms & Conditions");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(30, "button", 47);
    \u0275\u0275listener("click", function Dashboard_main_1_Template_button_click_30_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateNameFirst());
    });
    \u0275\u0275text(31, " Join Room ");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(8);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.userName);
    \u0275\u0275advance(9);
    \u0275\u0275textInterpolate(ctx_r1.statusMessage);
    \u0275\u0275advance(2);
    \u0275\u0275styleProp("width", ctx_r1.progressPercent, "%");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.progressPercent > 0);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.currentPrompt);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", !ctx_r1.enrollmentInProgress && ctx_r1.isEnrollmentComplete);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.enrollmentInProgress);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.hasVoiceBaseline);
    \u0275\u0275advance(2);
    \u0275\u0275property("disabled", !ctx_r1.hasVoiceBaseline);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.termsCheckbox);
  }
}
function Dashboard_main_2_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 84)(1, "div", 85);
    \u0275\u0275text(2, "Room: ");
    \u0275\u0275elementStart(3, "strong");
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(5, "button", 86);
    \u0275\u0275listener("click", function Dashboard_main_2_div_2_Template_button_click_5_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.toggleChat());
    });
    \u0275\u0275element(6, "i", 87);
    \u0275\u0275text(7, " Menu ");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1("#", ctx_r1.roomName);
  }
}
function Dashboard_main_2_div_4_div_1_video_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "video", 98);
  }
  if (rf & 2) {
    const p_r8 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("appSrcObject", p_r8.stream)("muted", !!p_r8.isYou);
    \u0275\u0275attribute("data-chan", p_r8.isYou ? "__you__" : p_r8.channel);
  }
}
function Dashboard_main_2_div_4_div_1_audio_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "audio", 99);
  }
  if (rf & 2) {
    const p_r8 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("appSrcObject", p_r8.stream);
  }
}
function Dashboard_main_2_div_4_div_1_div_3_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const p_r8 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(p_r8.initials);
  }
}
function Dashboard_main_2_div_4_div_1_div_3_span_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 103);
    \u0275\u0275text(1, "\u270B");
    \u0275\u0275elementEnd();
  }
}
function Dashboard_main_2_div_4_div_1_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 100)(1, "div", 101);
    \u0275\u0275template(2, Dashboard_main_2_div_4_div_1_div_3_span_2_Template, 2, 1, "span", 2)(3, Dashboard_main_2_div_4_div_1_div_3_span_3_Template, 2, 0, "span", 102);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const p_r8 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275styleProp("background", ctx_r1.getGradientForParticipant(p_r8.channel));
    \u0275\u0275advance();
    \u0275\u0275classProp("hand-raised", p_r8.handRaised);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !p_r8.handRaised);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", p_r8.handRaised);
  }
}
function Dashboard_main_2_div_4_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 90);
    \u0275\u0275template(1, Dashboard_main_2_div_4_div_1_video_1_Template, 1, 3, "video", 91)(2, Dashboard_main_2_div_4_div_1_audio_2_Template, 1, 1, "audio", 92)(3, Dashboard_main_2_div_4_div_1_div_3_Template, 4, 6, "div", 93);
    \u0275\u0275elementStart(4, "span", 94);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "span", 95);
    \u0275\u0275text(7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "div", 96);
    \u0275\u0275element(9, "span", 97);
    \u0275\u0275text(10);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const p_r8 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275classProp("video-on", p_r8.videoOn)("hide-when-pip", p_r8.isYou && ctx_r1.shouldShowSelfVideo && ctx_r1.gridParticipants.length > 1)("hand-raised", p_r8.handRaised);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", p_r8.stream && p_r8.videoOn);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", p_r8.stream && !p_r8.isYou);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !p_r8.videoOn);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" \u{1F441}\uFE0F ", p_r8.gaze, " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" \u{1F3A4} ", p_r8.voice, " ");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction2(13, _c4, p_r8.mic === "on", p_r8.mic === "off"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", p_r8.name, " ");
  }
}
function Dashboard_main_2_div_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 88);
    \u0275\u0275template(1, Dashboard_main_2_div_4_div_1_Template, 11, 16, "div", 89);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction5(3, _c3, ctx_r1.gridParticipants.length === 1, ctx_r1.gridParticipants.length === 2, ctx_r1.gridParticipants.length === 3, ctx_r1.gridParticipants.length === 4, ctx_r1.gridParticipants.length > 4));
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.gridParticipants)("ngForTrackBy", ctx_r1.trackByParticipant);
  }
}
function Dashboard_main_2_div_34_video_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "video", 106);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("appSrcObject", ctx_r1.you == null ? null : ctx_r1.you.stream)("muted", true);
  }
}
function Dashboard_main_2_div_34_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 104);
    \u0275\u0275template(1, Dashboard_main_2_div_34_video_1_Template, 1, 2, "video", 105);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.you == null ? null : ctx_r1.you.stream);
  }
}
function Dashboard_main_2_button_48_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 107);
    \u0275\u0275listener("click", function Dashboard_main_2_button_48_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r9);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.closeChat());
    });
    \u0275\u0275text(1, "Close");
    \u0275\u0275elementEnd();
  }
}
function Dashboard_main_2_div_50_div_3_span_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const p_r10 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(p_r10.initials);
  }
}
function Dashboard_main_2_div_50_div_3_span_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 117);
    \u0275\u0275text(1, "\u270B");
    \u0275\u0275elementEnd();
  }
}
function Dashboard_main_2_div_50_div_3_span_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 118);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const p_r10 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("\u{1F441}\uFE0F ", p_r10.gaze);
  }
}
function Dashboard_main_2_div_50_div_3_span_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 119);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const p_r10 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("\u{1F3A4} ", p_r10.voice);
  }
}
function Dashboard_main_2_div_50_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 111)(1, "div", 112)(2, "div", 113);
    \u0275\u0275template(3, Dashboard_main_2_div_50_div_3_span_3_Template, 2, 1, "span", 2)(4, Dashboard_main_2_div_50_div_3_span_4_Template, 2, 0, "span", 114);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "span");
    \u0275\u0275text(6);
    \u0275\u0275elementEnd();
    \u0275\u0275template(7, Dashboard_main_2_div_50_div_3_span_7_Template, 2, 1, "span", 115)(8, Dashboard_main_2_div_50_div_3_span_8_Template, 2, 1, "span", 116);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "div");
    \u0275\u0275element(10, "i", 62)(11, "i", 62);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const p_r10 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(2);
    \u0275\u0275styleProp("background", ctx_r1.getGradientForParticipant(p_r10.channel));
    \u0275\u0275classProp("hand-raised", p_r10.handRaised);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !p_r10.handRaised);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", p_r10.handRaised);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(p_r10.name);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", p_r10.gaze);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", p_r10.voice);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngClass", p_r10.mic === "on" ? "ph-microphone" : "ph-microphone-slash");
    \u0275\u0275advance();
    \u0275\u0275property("ngClass", p_r10.cam === "on" ? "ph-video-camera" : "ph-camera-slash");
  }
}
function Dashboard_main_2_div_50_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 108)(1, "h3", 109);
    \u0275\u0275text(2, "Participants");
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, Dashboard_main_2_div_50_div_3_Template, 12, 11, "div", 110);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx_r1.participants);
  }
}
function Dashboard_main_2_div_51_div_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 122)(1, "div", 123);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "div", 85);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const m_r11 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(m_r11.by);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(m_r11.text);
  }
}
function Dashboard_main_2_div_51_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 120, 0)(2, "h3", 109);
    \u0275\u0275text(3, "Chat");
    \u0275\u0275elementEnd();
    \u0275\u0275template(4, Dashboard_main_2_div_51_div_4_Template, 5, 2, "div", 121);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngForOf", ctx_r1.chatMessages);
  }
}
function Dashboard_main_2_form_52_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "form", 124);
    \u0275\u0275listener("ngSubmit", function Dashboard_main_2_form_52_Template_form_ngSubmit_0_listener() {
      \u0275\u0275restoreView(_r12);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.sendChat());
    });
    \u0275\u0275elementStart(1, "input", 125);
    \u0275\u0275twoWayListener("ngModelChange", function Dashboard_main_2_form_52_Template_input_ngModelChange_1_listener($event) {
      \u0275\u0275restoreView(_r12);
      const ctx_r1 = \u0275\u0275nextContext(2);
      \u0275\u0275twoWayBindingSet(ctx_r1.chatText, $event) || (ctx_r1.chatText = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "button", 126);
    \u0275\u0275text(3, "Send");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.chatText);
  }
}
function Dashboard_main_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "main", 55)(1, "section", 56);
    \u0275\u0275template(2, Dashboard_main_2_div_2_Template, 8, 1, "div", 57);
    \u0275\u0275elementStart(3, "div", 58);
    \u0275\u0275template(4, Dashboard_main_2_div_4_Template, 2, 9, "div", 59);
    \u0275\u0275elementStart(5, "div", 60)(6, "button", 61);
    \u0275\u0275listener("click", function Dashboard_main_2_Template_button_click_6_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.toggleMic());
    });
    \u0275\u0275element(7, "i", 62);
    \u0275\u0275elementStart(8, "span");
    \u0275\u0275text(9, "Mic");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(10, "button", 61);
    \u0275\u0275listener("click", function Dashboard_main_2_Template_button_click_10_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.toggleCam());
    });
    \u0275\u0275element(11, "i", 62);
    \u0275\u0275elementStart(12, "span");
    \u0275\u0275text(13, "Video");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(14, "button", 61);
    \u0275\u0275listener("click", function Dashboard_main_2_Template_button_click_14_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.shareScreen());
    });
    \u0275\u0275element(15, "i", 63);
    \u0275\u0275elementStart(16, "span");
    \u0275\u0275text(17, "Share");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(18, "button", 61);
    \u0275\u0275listener("click", function Dashboard_main_2_Template_button_click_18_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.raiseHand());
    });
    \u0275\u0275element(19, "i", 64);
    \u0275\u0275elementStart(20, "span");
    \u0275\u0275text(21, "Hand");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(22, "button", 61);
    \u0275\u0275listener("click", function Dashboard_main_2_Template_button_click_22_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.startNotes());
    });
    \u0275\u0275element(23, "i", 65);
    \u0275\u0275elementStart(24, "span");
    \u0275\u0275text(25, "Notepad");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(26, "button", 61);
    \u0275\u0275listener("click", function Dashboard_main_2_Template_button_click_26_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.runGazeSession());
    });
    \u0275\u0275element(27, "i", 66);
    \u0275\u0275elementStart(28, "span");
    \u0275\u0275text(29, "Start Calibration");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(30, "button", 67);
    \u0275\u0275listener("click", function Dashboard_main_2_Template_button_click_30_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.leaveCall());
    });
    \u0275\u0275element(31, "i", 68);
    \u0275\u0275elementStart(32, "span");
    \u0275\u0275text(33, "Leave");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275template(34, Dashboard_main_2_div_34_Template, 2, 1, "div", 69);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(35, "aside", 70)(36, "div", 71)(37, "div", 72);
    \u0275\u0275element(38, "i", 73);
    \u0275\u0275elementStart(39, "input", 74);
    \u0275\u0275listener("change", function Dashboard_main_2_Template_input_change_39_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateName($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(40, "label", 75);
    \u0275\u0275text(41, "update display name from here.");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(42, "div", 76)(43, "div", 77)(44, "button", 78);
    \u0275\u0275listener("click", function Dashboard_main_2_Template_button_click_44_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.activeTab = "participants");
    });
    \u0275\u0275text(45, "Participants");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(46, "button", 78);
    \u0275\u0275listener("click", function Dashboard_main_2_Template_button_click_46_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.activeTab = "chat");
    });
    \u0275\u0275text(47, "Chat");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(48, Dashboard_main_2_button_48_Template, 2, 0, "button", 79);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(49, "div", 80);
    \u0275\u0275template(50, Dashboard_main_2_div_50_Template, 4, 1, "div", 81)(51, Dashboard_main_2_div_51_Template, 5, 1, "div", 82);
    \u0275\u0275elementEnd();
    \u0275\u0275template(52, Dashboard_main_2_form_52_Template, 4, 1, "form", 83);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classProp("chat-open", !ctx_r1.chatCollapsed);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", !ctx_r1.isDesktop);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r1.gridParticipants.length > 0);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngClass", (ctx_r1.you == null ? null : ctx_r1.you.mic) === "on" ? "ph-microphone" : "ph-microphone-slash");
    \u0275\u0275advance(4);
    \u0275\u0275property("ngClass", (ctx_r1.you == null ? null : ctx_r1.you.cam) === "on" ? "ph-video-camera" : "ph-camera-slash");
    \u0275\u0275advance(23);
    \u0275\u0275property("ngIf", ctx_r1.shouldShowSelfVideo);
    \u0275\u0275advance();
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction2(17, _c22, ctx_r1.chatCollapsed && !ctx_r1.isDesktop, !ctx_r1.chatCollapsed || ctx_r1.isDesktop));
    \u0275\u0275advance(4);
    \u0275\u0275property("value", (ctx_r1.you == null ? null : ctx_r1.you.name) || "You");
    \u0275\u0275advance(5);
    \u0275\u0275classProp("active", ctx_r1.activeTab === "participants");
    \u0275\u0275advance(2);
    \u0275\u0275classProp("active", ctx_r1.activeTab === "chat");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", !ctx_r1.isDesktop);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r1.activeTab === "participants");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.activeTab === "chat");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.activeTab === "chat");
  }
}
function Dashboard_app_notepad_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "app-notepad", 127);
    \u0275\u0275listener("close", function Dashboard_app_notepad_3_Template_app_notepad_close_0_listener() {
      \u0275\u0275restoreView(_r13);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.closeNotes());
    });
    \u0275\u0275elementEnd();
  }
}
var _c03, _c13, _c22, _c3, _c4, MediaSrcObjectDirective, Dashboard;
var init_dashboard = __esm({
  "src/app/dashboard/dashboard.ts"() {
    "use strict";
    init_core();
    init_common();
    init_forms();
    init_signaling_service();
    init_src_object_directive();
    init_drag_drop();
    init_notepad_component();
    init_gazeTracker();
    init_voiceAnalyzer();
    init_voice_service();
    init_http();
    init_core();
    init_signaling_service();
    init_voice_service();
    init_common();
    init_forms();
    init_drag_drop();
    _c03 = ["chatScroll"];
    _c13 = ["enrollmentVideo"];
    _c22 = (a0, a1) => ({ "translate-x-full": a0, "translate-x-0": a1 });
    _c3 = (a0, a1, a2, a3, a4) => ({ "layout-1": a0, "layout-2": a1, "layout-3": a2, "layout-4": a3, "layout-more": a4 });
    _c4 = (a0, a1) => ({ "bg-green-400": a0, "bg-red-400": a1 });
    MediaSrcObjectDirective = class _MediaSrcObjectDirective {
      el;
      muted = false;
      constructor(el) {
        this.el = el;
      }
      set appSrcObject(stream) {
        const media = this.el.nativeElement;
        media.autoplay = true;
        media.playsInline = true;
        media.srcObject = stream ?? null;
        media.muted = this.muted;
        if (stream) {
          media.play().catch((e) => {
            if (e?.name === "NotAllowedError") {
              const oneClick = () => {
                media.play().catch(() => {
                });
                document.removeEventListener("click", oneClick);
              };
              document.addEventListener("click", oneClick, { once: true });
            }
          });
        }
      }
      static \u0275fac = function MediaSrcObjectDirective_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _MediaSrcObjectDirective)(\u0275\u0275directiveInject(ElementRef));
      };
      static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({ type: _MediaSrcObjectDirective, selectors: [["video", "appSrcObject", ""], ["audio", "appSrcObject", ""]], inputs: { muted: "muted", appSrcObject: "appSrcObject" } });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MediaSrcObjectDirective, [{
        type: Directive,
        args: [{ selector: "video[appSrcObject],audio[appSrcObject]", standalone: true }]
      }], () => [{ type: ElementRef }], { muted: [{
        type: Input
      }], appSrcObject: [{
        type: Input
      }] });
    })();
    Dashboard = class _Dashboard {
      signaling;
      voiceService;
      cdr;
      // ==============voice detection helper==============
      _pendingChunks = [];
      _lastVerifyTime = 0;
      _lastMatchPct = 0;
      VAD_THRESHOLD = 0.03;
      SPEECH_MIN_FRAMES = 0.2;
      BATCH_WINDOW_MS = 1e4;
      enrollmentInProgress = false;
      isEnrollmentComplete = true;
      isRecording = false;
      currentPrompt = "";
      takeIndex = 0;
      totalTakes = 3;
      prompts = [
        "Please read aloud: 'I confirm my identity and consent to voice authentication for secure access to this platform.'",
        "Please read aloud: 'My voice signature is unique and will be used to verify my identity during this session.'",
        "Please read aloud: 'I understand that voice biometrics enhance security and protect against unauthorized access.'"
      ];
      recordedSamples = [];
      statusMessage = 'Click "Start Enrollment" to begin.';
      progressPercent = 0;
      // ====== UI state ======
      isDesktop = window.innerWidth >= 1024;
      chatCollapsed = true;
      participants = [];
      chatMessages = [];
      chatText = "";
      tileColsManual = null;
      roomName = "testroom";
      activeTab = "chat";
      isNameUpdated = false;
      chatScroll;
      enrollmentVideo;
      // ====== Signaling ======
      signalingSub = null;
      myServerChan = null;
      myPolite = true;
      // ====== Stores ======
      participantsMap = /* @__PURE__ */ new Map();
      // key: channel id; '__you__' for local
      peers = /* @__PURE__ */ new Map();
      // key: remote channel id
      iceQueue = /* @__PURE__ */ new Map();
      // queued ICE per remote channel
      // ====== Local media ======
      localVideoTrack = null;
      localAudioTrack = null;
      localPreviewStream = new MediaStream();
      // stable instance
      userName;
      termsCheckbox;
      monitorLoopRunning = false;
      gazeThresholds;
      isNotesOpen = false;
      // Voice recognition state
      isRecordingVoice = false;
      voiceRecordingProgress = 0;
      hasVoiceBaseline = false;
      isVoiceMonitoring = false;
      voice = "N/A";
      // MediaRecorder-based voice
      mediaRecorder = null;
      mediaStream = null;
      audioChunks = [];
      verificationTimer = null;
      RECORD_MS = 4e3;
      // 2-second chunks
      ENROLL_SAMPLES = 3;
      VERIFICATION_WINDOW = 3;
      verificationScores = [];
      ngZone;
      // Face capture during enrollment
      enrollmentCameraStream = null;
      showEnrollmentCamera = false;
      facePositionCorrect = true;
      facePositionMessage = "";
      currentReadingText = "";
      faceDetectionInterval = null;
      enrollmentSuccessCount = 0;
      // Professional reading texts for each sample
      READING_TEXTS = [
        "Please read aloud: 'I confirm my identity and consent to voice authentication for secure access to this platform.'",
        "Please read aloud: 'My voice signature is unique and will be used to verify my identity during this session.'",
        "Please read aloud: 'I understand that voice biometrics enhance security and protect against unauthorized access.'"
      ];
      _batchStartTime;
      chunks = [];
      // ====== Derived getters ======
      get you() {
        return this.participantsMap.get("__you__");
      }
      get tileCount() {
        return this.participants.length;
      }
      get tileCols() {
        if (this.tileColsManual)
          return this.tileColsManual;
        return Math.min(4, Math.max(1, Math.ceil(Math.sqrt(this.tileCount || 1))));
      }
      get layoutCount() {
        return this.participants.length;
      }
      get fullParticipant() {
        const remotes = this.participants.filter((p) => !p.isYou);
        if (remotes.length === 0 && this.you?.videoOn)
          return this.you;
        return remotes.find((p) => p.videoOn);
      }
      get gridParticipants() {
        const remotes = this.participants.filter((p) => !p.isYou);
        if (remotes.length > 0) {
          return remotes;
        }
        return this.participants;
      }
      get canUseRecorder() {
        return !!this.mediaRecorder && this.enrollmentInProgress;
      }
      //========= GazeTracking ==============
      gazeSocket;
      isGazeTracking = false;
      //========= Fullscreen ==============
      escPressCount = 0;
      escPressTimer = null;
      hasShownEscAlert = false;
      isInFullscreen = false;
      fullscreenChangeHandler = null;
      //========= Permissions ==============
      showPermissionPopup = false;
      permissionStatus = {
        camera: false,
        microphone: false
      };
      constructor(signaling, ngZone, voiceService, cdr) {
        this.signaling = signaling;
        this.voiceService = voiceService;
        this.cdr = cdr;
        this.ngZone = ngZone;
        initModel().catch((err) => console.warn("Model init (background) failed:", err));
      }
      // ====== Lifecycle ======
      ngOnInit() {
        return __async(this, null, function* () {
          yield this.checkMediaPermissions();
        });
      }
      ngAfterViewInit() {
        if (this.enrollmentVideo?.nativeElement && this.enrollmentCameraStream) {
          const video = this.enrollmentVideo.nativeElement;
          video.srcObject = this.enrollmentCameraStream;
          video.muted = true;
          video.autoplay = true;
          video.playsInline = true;
          video.play().catch((err) => console.warn("Video play error:", err));
        }
      }
      joinRoom() {
        this.localPreviewStream = new MediaStream();
        this.participantsMap.set("__you__", this.makeLocalParticipant(this.userName));
        this.syncParticipantsArray();
        this.signaling.connect(this.roomName);
        this.signalingSub = this.signaling.messages$.subscribe((msg) => this.onSignal(msg));
        this.setupFullscreenListener();
        this.enterFullscreen();
      }
      ngOnDestroy() {
        try {
          this.sendSig({ type: "bye" });
        } catch {
        }
        stopGazeTracking();
        this.stopAllStreams();
        this.signalingSub?.unsubscribe();
        this.signaling.disconnect();
        this.peers.forEach((st) => {
          try {
            st.pc.close();
          } catch {
          }
        });
        this.peers.clear();
        this.stopAndClearLocalTracks();
        this.participantsMap.clear();
        this.iceQueue.clear();
        this.removeFullscreenListener();
      }
      handleGazeStatus(status) {
        const me = this.participantsMap.get("__you__");
        if (me) {
          const updated = __spreadProps(__spreadValues({}, me), { gaze: status });
          this.participantsMap.set("__you__", updated);
          this.syncParticipantsArray();
        }
      }
      onBeforeUnload() {
        try {
          this.sendSig({ type: "bye" });
          stopGazeTracking();
          this.signaling.disconnect();
        } catch {
        }
      }
      onResize() {
        this.isDesktop = window.innerWidth >= 1024;
      }
      onEscapeKey() {
        if (!this.isNameUpdated)
          return;
        if (this.isInFullscreen)
          return;
        this.escPressCount++;
        if (this.escPressCount === 1 && !this.hasShownEscAlert) {
          alert("You are not allowed to pres ESC key, If you do so it will notify interviewer immidiately.");
          this.hasShownEscAlert = true;
          if (this.escPressTimer)
            clearTimeout(this.escPressTimer);
          this.escPressTimer = setTimeout(() => {
            this.escPressCount = 0;
          }, 2e3);
        } else if (this.escPressCount >= 2) {
          this.exitFullscreen();
          this.escPressCount = 0;
          if (this.escPressTimer)
            clearTimeout(this.escPressTimer);
        }
      }
      setupFullscreenListener() {
        this.fullscreenChangeHandler = () => {
          const isCurrentlyFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
          const wasFullscreen = this.isInFullscreen;
          this.isInFullscreen = isCurrentlyFullscreen;
          if (wasFullscreen && !isCurrentlyFullscreen && this.isNameUpdated) {
            this.escPressCount++;
            if (this.escPressCount === 1 && !this.hasShownEscAlert) {
              alert("Press ESC again to exit fullscreen");
              this.hasShownEscAlert = true;
              this.enterFullscreen();
              if (this.escPressTimer)
                clearTimeout(this.escPressTimer);
              this.escPressTimer = setTimeout(() => {
                this.escPressCount = 0;
              }, 2e3);
            } else if (this.escPressCount >= 2) {
              this.escPressCount = 0;
              if (this.escPressTimer)
                clearTimeout(this.escPressTimer);
            }
          }
        };
        document.addEventListener("fullscreenchange", this.fullscreenChangeHandler);
        document.addEventListener("webkitfullscreenchange", this.fullscreenChangeHandler);
        document.addEventListener("mozfullscreenchange", this.fullscreenChangeHandler);
        document.addEventListener("MSFullscreenChange", this.fullscreenChangeHandler);
      }
      removeFullscreenListener() {
        if (this.fullscreenChangeHandler) {
          document.removeEventListener("fullscreenchange", this.fullscreenChangeHandler);
          document.removeEventListener("webkitfullscreenchange", this.fullscreenChangeHandler);
          document.removeEventListener("mozfullscreenchange", this.fullscreenChangeHandler);
          document.removeEventListener("MSFullscreenChange", this.fullscreenChangeHandler);
          this.fullscreenChangeHandler = null;
        }
      }
      // ====== Utilities ======
      sendSig(payload) {
        this.signaling.sendMessage(__spreadValues({}, payload));
      }
      initialsFromName(name2) {
        const parts = (name2 || "").trim().split(/\s+/);
        const letters = parts.slice(0, 2).map((s) => (s[0] || "").toUpperCase());
        return letters.join("") || "?";
      }
      participantChan(row) {
        return row?.channel;
      }
      asOffer(msg) {
        return msg?.offer && msg.offer.type && msg.offer.sdp ? msg.offer : null;
      }
      asAnswer(msg) {
        return msg?.answer && msg.answer.type && msg.answer.sdp ? msg.answer : null;
      }
      asCandidate(msg) {
        return msg?.ice_candidate || null;
      }
      senderChan(msg) {
        return msg?.sender_channel || msg?.from;
      }
      messageIsForMe(msg) {
        return msg?.to ? msg.to === this.myServerChan : true;
      }
      // ====== Participants store helpers ======
      syncParticipantsArray() {
        this.participants = Array.from(this.participantsMap.values()).filter((p) => p.channel !== "__you__").concat(this.you ? [this.you] : []);
      }
      makeLocalParticipant(name2) {
        return {
          name: name2,
          mic: "off",
          cam: "off",
          videoOn: false,
          initials: this.initialsFromName(name2),
          isYou: true,
          channel: "__you__",
          stream: null,
          // preview stream will be attached when camera turns on
          handRaised: false,
          gaze: "",
          voice: "N/A"
        };
      }
      computeVideoOn(cam, stream) {
        if (cam !== "on" || !stream)
          return false;
        const vt = stream.getVideoTracks();
        return vt.length > 0 && vt.some((t2) => t2.enabled !== false);
      }
      upsertParticipantFromPayload(row) {
        const ch = this.participantChan(row);
        if (!ch)
          return;
        if (this.myServerChan && ch === this.myServerChan)
          return;
        const existingByName = Array.from(this.participantsMap.values()).find((p) => p.name === row?.name && !p.isYou);
        const prev = existingByName ?? this.participantsMap.get(ch);
        const nextCam = row?.cam ?? prev?.cam ?? "off";
        const nextMic = row?.mic ?? prev?.mic ?? "off";
        const existingStream = prev?.stream ?? null;
        const next = {
          name: row?.name ?? prev?.name ?? "Guest",
          mic: nextMic,
          cam: nextCam,
          videoOn: existingStream ? this.computeVideoOn(nextCam, existingStream) : false,
          initials: this.initialsFromName(row?.name ?? prev?.name ?? "Guest"),
          isYou: false,
          channel: prev?.channel ?? ch,
          //  stick to the first channel we saw
          stream: existingStream,
          gaze: row?.gaze ?? prev?.gaze ?? "",
          voice: row?.voice ?? prev?.voice ?? "N/A",
          handRaised: typeof row?.handRaised === "boolean" ? row.handRaised : prev?.handRaised ?? false
        };
        this.participantsMap.set(next.channel, next);
        this.syncParticipantsArray();
      }
      ensureParticipantStream(ch) {
        const p = this.participantsMap.get(ch);
        if (p?.stream)
          return p.stream;
        const ms = new MediaStream();
        if (p) {
          const updated = __spreadProps(__spreadValues({}, p), { stream: ms, videoOn: this.computeVideoOn(p.cam, ms) });
          this.participantsMap.set(ch, updated);
        }
        return ms;
      }
      // ====== Local media helpers ======
      stopAndClearLocalTracks() {
        try {
          this.localVideoTrack?.stop();
        } catch {
        }
        try {
          this.localAudioTrack?.stop();
        } catch {
        }
        this.localVideoTrack = null;
        this.localAudioTrack = null;
        this.localPreviewStream.getTracks().forEach((t2) => {
          try {
            t2.stop();
          } catch {
          }
        });
        this.localPreviewStream = new MediaStream();
        const me = this.participantsMap.get("__you__");
        if (me) {
          const updated = __spreadProps(__spreadValues({}, me), { cam: "off", mic: "off", stream: null, videoOn: false });
          this.participantsMap.set("__you__", updated);
          this.syncParticipantsArray();
        }
      }
      refreshLocalPreview() {
        const next = new MediaStream();
        if (this.localVideoTrack)
          next.addTrack(this.localVideoTrack);
        this.localPreviewStream = next;
        const me = this.participantsMap.get("__you__");
        if (me) {
          const hasCam = this.localVideoTrack != null;
          const updated = __spreadProps(__spreadValues({}, me), {
            stream: hasCam ? this.localPreviewStream : null,
            videoOn: this.computeVideoOn(hasCam ? "on" : "off", hasCam ? this.localPreviewStream : null),
            cam: hasCam ? "on" : "off"
          });
          this.participantsMap.set("__you__", updated);
        }
        this.peers.forEach((st) => {
          try {
            st.audioSender.replaceTrack(this.localAudioTrack);
          } catch {
          }
          try {
            st.videoSender.replaceTrack(this.localVideoTrack);
          } catch {
          }
        });
        this.syncParticipantsArray();
      }
      // ====== Peer creation & negotiation ======
      getOrCreatePeer(remoteChan) {
        let st = this.peers.get(remoteChan);
        if (st)
          return st;
        const pc = new RTCPeerConnection({
          iceServers: [
            // Google STUN (optional fallback)
            { urls: "stun:stun.l.google.com:19302" },
            // Your own STUN
            { urls: "stun:smartvid.live:3478" },
            // Your TURN with UDP/TCP/TLS
            {
              urls: [
                "turn:smartvid.live:3478?transport=udp",
                "turn:smartvid.live:5349?transport=tcp",
                "turns:smartvid.live:5349?transport=tcp"
              ],
              username: "test",
              credential: "test123"
            }
          ]
        });
        const at = pc.addTransceiver("audio", { direction: "sendrecv" });
        const vt = pc.addTransceiver("video", { direction: "sendrecv" });
        const h264Codecs = RTCRtpSender.getCapabilities("video")?.codecs.filter((c) => c.mimeType.toLowerCase() === "video/h264").filter((c) => !c.sdpFmtpLine || c.sdpFmtpLine.includes("42e01f"));
        if (h264Codecs?.length && vt.setCodecPreferences) {
          vt.setCodecPreferences(h264Codecs);
        }
        st = {
          pc,
          makingOffer: false,
          ignoreOffer: false,
          polite: this.myPolite,
          audioSender: at.sender,
          videoSender: vt.sender,
          remoteChan,
          isSettingRemoteAnswerPending: false
        };
        try {
          st.audioSender.replaceTrack(this.localAudioTrack);
        } catch {
        }
        try {
          st.videoSender.replaceTrack(this.localVideoTrack);
        } catch {
        }
        pc.onnegotiationneeded = () => __async(this, null, function* () {
          if (st.makingOffer || pc.signalingState !== "stable")
            return;
          try {
            st.makingOffer = true;
            yield pc.setLocalDescription(yield pc.createOffer());
            this.sendSig({ type: "offer", offer: pc.localDescription, to: remoteChan });
          } catch (err) {
            console.error("Negotiation error:", err);
          } finally {
            st.makingOffer = false;
          }
        });
        pc.ontrack = (ev) => {
          let pPrev = this.participantsMap.get(remoteChan);
          if (!pPrev) {
            pPrev = {
              name: "Unknown",
              initials: "?",
              mic: "off",
              cam: "off",
              videoOn: false,
              channel: remoteChan,
              isYou: false,
              stream: null,
              handRaised: false,
              gaze: "",
              voice: "N/A"
            };
          }
          const ms = this.ensureParticipantStream(remoteChan);
          const already = ms.getTracks().some((t2) => t2.id === ev.track.id);
          if (!already)
            ms.addTrack(ev.track);
          const updated = {
            name: pPrev.name,
            initials: pPrev.initials,
            isYou: pPrev.isYou,
            channel: pPrev.channel,
            handRaised: pPrev.handRaised,
            gaze: pPrev.gaze,
            voice: pPrev.voice,
            stream: ms,
            // Only update mic/cam if they were at default 'off' (meaning we haven't received server state yet)
            mic: pPrev.mic !== "off" ? pPrev.mic : ms.getAudioTracks().length > 0 ? "on" : "off",
            cam: pPrev.cam !== "off" ? pPrev.cam : ms.getVideoTracks().length > 0 ? "on" : "off",
            // videoOn should be based on the cam state from server, not just presence of tracks
            videoOn: this.computeVideoOn(pPrev.cam, ms)
          };
          this.participantsMap.set(remoteChan, updated);
          this.syncParticipantsArray();
        };
        pc.onicecandidate = ({ candidate }) => {
          if (!candidate)
            return;
          this.sendSig({ type: "ice_candidate", ice_candidate: candidate.toJSON?.() ?? candidate, to: remoteChan });
        };
        pc.onconnectionstatechange = () => {
          if (pc.connectionState === "failed") {
            console.error("Connection failed for", remoteChan);
          }
        };
        this.peers.set(remoteChan, st);
        return st;
      }
      renegotiate(remoteChan) {
        return __async(this, null, function* () {
          const st = this.peers.get(remoteChan);
          if (!st)
            return;
          const pc = st.pc;
          if (st.makingOffer || pc.signalingState !== "stable")
            return;
          try {
            st.makingOffer = true;
            yield pc.setLocalDescription(yield pc.createOffer());
            this.sendSig({ type: "offer", offer: pc.localDescription, to: remoteChan });
          } catch (err) {
            console.error("Renegotiation error:", err);
          } finally {
            st.makingOffer = false;
          }
        });
      }
      queueIce(remoteChan, cand) {
        const q = this.iceQueue.get(remoteChan) ?? [];
        q.push(cand);
        this.iceQueue.set(remoteChan, q);
      }
      flushIce(remoteChan) {
        return __async(this, null, function* () {
          const st = this.peers.get(remoteChan);
          if (!st || !st.pc.remoteDescription)
            return;
          const q = this.iceQueue.get(remoteChan);
          if (!q?.length)
            return;
          for (const c of q) {
            try {
              yield st.pc.addIceCandidate(c);
            } catch {
            }
          }
          this.iceQueue.delete(remoteChan);
        });
      }
      // ====== Incoming signaling ======
      onSignal(msg) {
        if (!msg)
          return;
        if (msg.type === "welcome") {
          this.myServerChan = msg.channel || msg.myServerChan || null;
          this.myPolite = !!msg.polite;
          const myName = this.you?.name || "You";
          this.sendSig({ type: "name_update", name: myName });
          return;
        }
        switch (msg.type) {
          case "participants": {
            const list = msg.participants || [];
            list.forEach((row) => {
              const ch = this.participantChan(row);
              if (!ch)
                return;
              if (this.myServerChan && ch === this.myServerChan)
                return;
              if (!this.participantsMap.has(ch)) {
                this.upsertParticipantFromPayload(row);
                this.getOrCreatePeer(ch);
                setTimeout(() => this.renegotiate(ch), 100);
              }
            });
            break;
          }
          case "participant_joined": {
            const row = msg.participant;
            const ch = this.participantChan(row);
            if (!ch)
              return;
            if (this.myServerChan && ch === this.myServerChan)
              return;
            if (!this.participantsMap.has(ch)) {
              this.upsertParticipantFromPayload(row);
              this.getOrCreatePeer(ch);
              setTimeout(() => this.renegotiate(ch), 100);
              this.monitorSelfVideo();
            }
            break;
          }
          case "participant_left": {
            const ch = msg.channel;
            if (!ch)
              break;
            this.participantsMap.delete(ch);
            const st = this.peers.get(ch);
            if (st) {
              try {
                st.pc.close();
              } catch {
              }
              this.peers.delete(ch);
            }
            this.syncParticipantsArray();
            this.monitorSelfVideo();
            break;
          }
          case "participant_updated": {
            const row = msg.participant;
            const ch = this.participantChan(row);
            if (!ch)
              return;
            if (this.myServerChan && ch === this.myServerChan)
              return;
            const prev = this.participantsMap.get(ch);
            const prevCam = prev?.cam;
            const prevMic = prev?.mic;
            this.upsertParticipantFromPayload(row);
            const updated = this.participantsMap.get(ch);
            const camChanged = updated && prevCam !== updated.cam;
            const micChanged = updated && prevMic !== updated.mic;
            if (camChanged || micChanged) {
              console.log(`\u{1F504} Participant ${ch} changed cam:${prevCam}\u2192${updated?.cam} mic:${prevMic}\u2192${updated?.mic}, renegotiating...`);
              setTimeout(() => this.renegotiate(ch), 100);
            }
            break;
          }
          case "chat_message": {
            const payload = msg.message ?? {};
            const text = payload.text ?? "";
            if (text) {
              const by = payload.by ?? "Guest";
              this.chatMessages = [...this.chatMessages, { by, text }];
              setTimeout(() => this.scrollToBottom(), 0);
            }
            break;
          }
          case "offer": {
            if (!this.messageIsForMe(msg))
              return;
            const from2 = this.senderChan(msg);
            if (!from2)
              return;
            const offer = this.asOffer(msg);
            if (!offer)
              return;
            const st = this.getOrCreatePeer(from2);
            const pc = st.pc;
            (() => __async(this, null, function* () {
              const offerCollision = st.makingOffer || pc.signalingState !== "stable";
              st.ignoreOffer = !st.polite && offerCollision;
              if (st.ignoreOffer)
                return;
              try {
                if (pc.signalingState !== "stable") {
                  yield pc.setLocalDescription({ type: "rollback" });
                }
                yield pc.setRemoteDescription(offer);
                try {
                  st.audioSender.replaceTrack(this.localAudioTrack);
                } catch {
                }
                try {
                  st.videoSender.replaceTrack(this.localVideoTrack);
                } catch {
                }
                yield pc.setLocalDescription(yield pc.createAnswer());
                this.sendSig({ type: "answer", answer: pc.localDescription, to: from2 });
                yield this.flushIce(from2);
              } catch (err) {
                console.error("error handling offer", err);
              }
            }))();
            break;
          }
          case "answer": {
            if (!this.messageIsForMe(msg))
              return;
            const from2 = this.senderChan(msg);
            if (!from2)
              return;
            const answer = this.asAnswer(msg);
            if (!answer)
              return;
            const st = this.peers.get(from2);
            if (!st)
              return;
            const pc = st.pc;
            (() => __async(this, null, function* () {
              try {
                st.isSettingRemoteAnswerPending = true;
                yield pc.setRemoteDescription(answer);
                yield this.flushIce(from2);
              } catch (err) {
                console.error("error applying answer", err);
              } finally {
                st.isSettingRemoteAnswerPending = false;
              }
            }))();
            break;
          }
          case "ice_candidate": {
            if (!this.messageIsForMe(msg))
              return;
            const from2 = this.senderChan(msg);
            if (!from2)
              return;
            const cand = this.asCandidate(msg);
            if (!cand)
              return;
            const st = this.peers.get(from2);
            if (!st) {
              this.queueIce(from2, cand);
              return;
            }
            (() => __async(this, null, function* () {
              try {
                if (st.pc.remoteDescription)
                  yield st.pc.addIceCandidate(cand);
                else
                  this.queueIce(from2, cand);
              } catch (e) {
                if (!st.ignoreOffer)
                  console.error("error adding ICE", e);
              }
            }))();
            break;
          }
          case "gaze_update": {
            const ch = msg.channel;
            const g = msg.gaze;
            if (ch && this.participantsMap.has(ch)) {
              const p = this.participantsMap.get(ch);
              this.participantsMap.set(ch, __spreadProps(__spreadValues({}, p), { gaze: g }));
              this.syncParticipantsArray();
            } else {
              const p = this.participants.find((pp) => pp.name === msg.user);
              if (p) {
                p.gaze = g;
                this.syncParticipantsArray();
              }
            }
            break;
          }
          case "voice_update": {
            const ch = msg.channel;
            const v = msg.voice;
            if (ch && this.participantsMap.has(ch)) {
              const p = this.participantsMap.get(ch);
              this.participantsMap.set(ch, __spreadProps(__spreadValues({}, p), { voice: v }));
              this.syncParticipantsArray();
            } else {
              const p = this.participants.find((pp) => pp.name === msg.user);
              if (p) {
                p.voice = v;
                this.syncParticipantsArray();
              }
            }
            break;
          }
        }
      }
      // ====== UI actions ======
      toggleChat() {
        this.chatCollapsed = !this.chatCollapsed;
      }
      closeChat() {
        this.chatCollapsed = true;
      }
      sendChat() {
        const text = this.chatText.trim();
        if (!text)
          return;
        const by = this.you?.name || "You";
        this.chatMessages = [...this.chatMessages, { by, text }];
        this.sendSig({ type: "chat", by, text });
        this.chatText = "";
        setTimeout(() => this.scrollToBottom(), 0);
      }
      scrollToBottom() {
        if (this.chatScroll) {
          this.chatScroll.nativeElement.scrollTop = this.chatScroll.nativeElement.scrollHeight;
        }
      }
      updateNameFirst() {
        return __async(this, null, function* () {
          if (!this.userName) {
            alert("Please Enter User Name");
            return;
          }
          if (!this.termsCheckbox) {
            alert("Please accept Terms & Conditions");
            return;
          }
          if (!this.hasVoiceBaseline) {
            alert("Please record your voice sample first");
            return;
          }
          this.isNameUpdated = true;
          this.joinRoom();
        });
      }
      // ============ Voice Integration (MediaRecorder-based) ============
      isSecureContext() {
        const origin = window.location.origin;
        return origin.startsWith("https://") || origin.includes("localhost") || origin.includes("127.0.0.1");
      }
      requestMicrophone() {
        return __async(this, null, function* () {
          if (!this.isSecureContext()) {
            throw new Error("Microphone requires secure origin (https) or localhost");
          }
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error("Browser does not support getUserMedia");
          }
          try {
            const stream = yield navigator.mediaDevices.getUserMedia({
              audio: { echoCancellation: true, noiseSuppression: true },
              video: false
            });
            this.mediaStream = stream;
            this.permissionStatus.microphone = true;
            return stream;
          } catch (err) {
            this.permissionStatus.microphone = false;
            if (err && err.name === "NotAllowedError")
              throw new Error("Microphone permission denied, please allow mic access in the browser");
            if (err && err.name === "NotFoundError")
              throw new Error("No microphone found");
            throw new Error(err?.message || "Could not get microphone");
          }
        });
      }
      stopAllStreams() {
        if (this.mediaStream) {
          this.mediaStream.getTracks().forEach((t2) => t2.stop());
          this.mediaStream = null;
        }
        if (this.mediaRecorder) {
          try {
            this.mediaRecorder.stop();
          } catch (_) {
          }
          this.mediaRecorder = null;
        }
        this.isRecordingVoice = false;
        this.isVoiceMonitoring = false;
      }
      // ---------------- Enrollment (baseline) flows ----------------
      // public async startEnrollment(): Promise<void> {
      //   try {
      //     if (this.isRecordingVoice) return;
      //     // ensure model loaded
      //     await initModel();
      //     // Start camera for face capture
      //     await this.startEnrollmentCamera();
      //     // request mic
      //     await this.requestMicrophone();
      //     // prepare MediaRecorder capturing 2s segments
      //     this.audioChunks = [];
      //     const options: MediaRecorderOptions = { 
      //        mimeType: 'audio/webm;codecs=opus',
      //        audioBitsPerSecond: 128000,
      //     };
      //     this.mediaRecorder = new MediaRecorder(this.mediaStream as MediaStream, options);
      //     this.mediaRecorder.ondataavailable = (ev: BlobEvent) => {
      //       if (ev.data && ev.data.size > 0) this.audioChunks.push(ev.data);
      //     };
      //     this.mediaRecorder.onstop = async () => {
      //       if (this.audioChunks.length === 0) return;
      //       const blob = new Blob(this.audioChunks, { type: 'audio/webm' });
      //       this.audioChunks = [];
      //       // Send to backend for enrollment
      //       this.voiceService.enrollVoice(blob, this.roomName, this.userName).subscribe({
      //         next: (response) => {
      //           if (response.success) {
      //             this.enrollmentSuccessCount++;
      //             this.voiceRecordingProgress++;
      //             console.log(' Enrollment sample captured:', this.voiceRecordingProgress);
      //           } else {
      //             console.error(' Enrollment failed:', response.message);
      //             alert('Failed to enroll voice sample: ' + response.message);
      //           }
      //         },
      //         error: (err) => {
      //           console.error(' Enrollment API error:', err);
      //           alert('Failed to enroll voice sample. Please try again.');
      //         }
      //       });
      //     };
      //     // Start simple loop: start recorder, wait RECORD_MS, stop, repeat until user clicks Record
      //     this.isRecordingVoice = true;
      //     this.showEnrollmentCamera = true;
      //     this.enrollmentSuccessCount = 0;
      //     // Set initial reading text
      //     this.updateReadingText();
      //     console.log('Enrollment started  click Record (2s) to capture a sample');
      //   } catch (err: any) {
      //     alert('Could not start enrollment: ' + (err.message || err));
      //     this.isRecordingVoice = false;
      //     this.stopAllStreams();
      //     this.stopEnrollmentCamera();
      //   }
      // }
      startEnrollment() {
        return __async(this, null, function* () {
          if (this.enrollmentInProgress) {
            return;
          }
          this.stopStream();
          this.enrollmentInProgress = true;
          this.isEnrollmentComplete = false;
          this.isRecording = false;
          this.takeIndex = 0;
          this.recordedSamples = [];
          this.chunks = [];
          this.currentPrompt = "";
          this.hasVoiceBaseline = false;
          this.statusMessage = "Preparing microphone...";
          this.progressPercent = 0;
          this.cdr.markForCheck();
          try {
            const stream = yield navigator.mediaDevices.getUserMedia({ audio: true });
            this.mediaStream = stream;
            this.mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm" });
            this.mediaRecorder.ondataavailable = (event) => {
              if (event.data && event.data.size > 0) {
                this.chunks.push(event.data);
              }
            };
            this.mediaRecorder.onstop = () => __async(this, null, function* () {
              if (this.chunks.length === 0) {
                this.ngZone.run(() => {
                  this.statusMessage = "No audio captured. Please try again.";
                  this.cdr.markForCheck();
                });
                this.chunks = [];
                return;
              }
              const blob = new Blob(this.chunks, { type: "audio/webm" });
              this.recordedSamples.push(blob);
              this.chunks = [];
              const samplesCollected = this.recordedSamples.length;
              this.ngZone.run(() => {
                this.progressPercent = Math.round(samplesCollected / this.totalTakes * 100);
                this.cdr.markForCheck();
              });
              if (samplesCollected >= this.totalTakes) {
                yield this.finalizeEnrollment();
                return;
              }
              this.ngZone.run(() => {
                this.takeIndex = samplesCollected;
                this.currentPrompt = this.prompts[samplesCollected];
                this.statusMessage = 'Click "Record" again, then Read the next text.';
                this.cdr.markForCheck();
              });
            });
            this.currentPrompt = this.prompts[0];
            this.statusMessage = 'Click "Record, then Read the text aloud.';
            this.cdr.markForCheck();
          } catch (error) {
            console.error("Mic access error", error);
            this.statusMessage = "Microphone access failed.";
            this.enrollmentInProgress = false;
            this.stopStream();
            this.cdr.markForCheck();
          }
        });
      }
      handleRecordClick() {
        return __async(this, null, function* () {
          if (!this.enrollmentInProgress || !this.mediaRecorder) {
            return;
          }
          if (this.isRecording) {
            this.isRecording = false;
            try {
              this.mediaRecorder.stop();
              this.statusMessage = "Processing recording...";
            } catch (error) {
              console.error("MediaRecorder stop error", error);
              this.statusMessage = "Unable to stop recording. Please try again.";
            }
            this.cdr.markForCheck();
            return;
          }
          this.isRecording = true;
          this.chunks = [];
          try {
            this.mediaRecorder.start();
            this.statusMessage = "Recording... speak clearly.";
          } catch (error) {
            console.error("MediaRecorder start error", error);
            this.isRecording = false;
            this.statusMessage = "Unable to start recording.";
          }
          this.cdr.markForCheck();
        });
      }
      finalizeEnrollment() {
        return __async(this, null, function* () {
          let timeoutId;
          const controller = new AbortController();
          try {
            this.enrollmentInProgress = false;
            this.statusMessage = "Uploading samples for enrollment...";
            this.cdr.markForCheck();
            const form = new FormData();
            this.recordedSamples.forEach((blob, index) => {
              form.append("files", blob, `sample${index + 1}.webm`);
            });
            form.append("room", this.roomName || "default");
            form.append("username", this.userName || "guest");
            const headers = {};
            const csrfToken = this.getCsrfToken();
            if (csrfToken) {
              headers["X-CSRFToken"] = csrfToken;
            }
            timeoutId = window.setTimeout(() => controller.abort(), 2e4);
            const response = yield fetch("/video-call/api/voice/enroll-batch", {
              method: "POST",
              body: form,
              headers,
              credentials: "same-origin",
              signal: controller.signal
            });
            if (timeoutId) {
              clearTimeout(timeoutId);
              timeoutId = void 0;
            }
            let result = null;
            try {
              result = yield response.json();
            } catch {
              result = null;
            }
            if (response.ok && result?.success) {
              this.statusMessage = "Enrollment complete! Voice profile ready.";
              this.progressPercent = 100;
              this.hasVoiceBaseline = true;
            } else {
              const message = result?.message ?? response.statusText ?? "Unknown error";
              this.statusMessage = `Enrollment failed: ${message}`;
              this.hasVoiceBaseline = false;
            }
          } catch (error) {
            console.error("Enrollment error", error);
            this.statusMessage = "Enrollment failed (network or server issue).";
            this.hasVoiceBaseline = false;
          } finally {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            this.stopStream();
            this.isEnrollmentComplete = true;
            this.isRecording = false;
            this.currentPrompt = "";
            this.takeIndex = 0;
            this.recordedSamples = [];
            this.cdr.markForCheck();
          }
        });
      }
      stopStream() {
        try {
          if (this.mediaRecorder && this.mediaRecorder.state !== "inactive") {
            this.mediaRecorder.stop();
          }
        } catch (error) {
          console.warn("MediaRecorder stop warning:", error);
        } finally {
          this.mediaRecorder = null;
        }
        if (this.mediaStream) {
          this.mediaStream.getTracks().forEach((track) => track.stop());
          this.mediaStream = null;
        }
        this.chunks = [];
        this.isRecording = false;
      }
      getCsrfToken() {
        if (typeof document === "undefined") {
          return null;
        }
        const match2 = document.cookie.match(/(^|;)\s*csrftoken=([^;]+)/);
        return match2 ? decodeURIComponent(match2[2]) : null;
      }
      captureBaselineSample() {
        return __async(this, null, function* () {
          if (!this.isRecordingVoice || !this.mediaRecorder) {
            alert("Please start enrollment first");
            return;
          }
          try {
            yield new Promise((r) => setTimeout(r, 300));
            this.mediaRecorder.start();
            setTimeout(() => {
              if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
                this.mediaRecorder.stop();
                setTimeout(() => this.updateReadingText(), 500);
              }
            }, this.RECORD_MS);
          } catch (err) {
            console.error("MediaRecorder start error:", err);
          }
        });
      }
      finishEnrollment() {
        if (!this.isRecordingVoice)
          return;
        if (this.voiceRecordingProgress < this.ENROLL_SAMPLES) {
          alert(`Please record at least ${this.ENROLL_SAMPLES} samples (currently ${this.voiceRecordingProgress})`);
          return;
        }
        if (this.enrollmentSuccessCount < this.ENROLL_SAMPLES) {
          alert(`Please wait for all samples to be processed successfully (${this.enrollmentSuccessCount}/${this.ENROLL_SAMPLES} completed)`);
          return;
        }
        this.hasVoiceBaseline = true;
        this.isRecordingVoice = false;
        this.voiceRecordingProgress = 0;
        this.enrollmentSuccessCount = 0;
        try {
          this.mediaStream?.getTracks().forEach((t2) => t2.stop());
        } catch (_) {
        }
        this.mediaStream = null;
        if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
          try {
            this.mediaRecorder.stop();
          } catch (_) {
          }
        }
        this.mediaRecorder = null;
        this.stopEnrollmentCamera();
      }
      // ---------------- Verification (monitoring) flows ----------------
      startVerification() {
        return __async(this, null, function* () {
          try {
            if (!this.hasVoiceBaseline) {
              alert("No baseline enrolled. Please enroll first.");
              return;
            }
            yield initModel();
            yield this.requestMicrophone();
            this.mediaRecorder = new MediaRecorder(this.mediaStream, { mimeType: "audio/webm;codecs=opus" });
            this.mediaRecorder.ondataavailable = (ev) => __async(this, null, function* () {
              try {
                if (!this.localAudioTrack || !this.localAudioTrack.enabled)
                  return;
                if (!ev.data || ev.data.size < 2e3)
                  return;
                const arrayBuffer = yield ev.data.arrayBuffer();
                const audioCtx = new AudioContext();
                const audioBuffer = yield audioCtx.decodeAudioData(arrayBuffer);
                const samples2 = audioBuffer.getChannelData(0);
                const rms = Math.sqrt(samples2.reduce((s, x) => s + x * x, 0) / samples2.length);
                audioCtx.close();
                const windowSize = 1024;
                let activeFrames = 0;
                for (let i = 0; i < samples2.length; i += windowSize) {
                  const slice = samples2.subarray(i, i + windowSize);
                  const frameRms = Math.sqrt(slice.reduce((s, x) => s + x * x, 0) / slice.length);
                  if (frameRms > 0.03)
                    activeFrames++;
                }
                const speechActive = activeFrames > samples2.length / windowSize * 0.2;
                if (!speechActive || rms < 0.015) {
                  console.log(`\u{1F92B} Silence or no speech (RMS=${rms.toFixed(4)}) \u2014 skipping verification`);
                  return;
                }
                const now = Date.now();
                if (!this._pendingChunks)
                  this._pendingChunks = [];
                if (!this._batchStartTime)
                  this._batchStartTime = now;
                this._pendingChunks.push(ev.data);
                const durationSinceBatch = now - this._batchStartTime;
                if (durationSinceBatch < 1e4) {
                  return;
                }
                const lastSent = this._lastVerifyTime || 0;
                const elapsed = now - lastSent;
                let interval2 = 5e3;
                if (this._lastMatchPct > 85)
                  interval2 = 8e3;
                else if (this._lastMatchPct < 65)
                  interval2 = 3e3;
                if (elapsed < interval2) {
                  console.log(`\u23F1\uFE0F Skipping verify \u2014 only ${Math.round(elapsed / 1e3)}s since last`);
                  return;
                }
                const combinedBlob = new Blob(this._pendingChunks, { type: "audio/webm" });
                this._pendingChunks = [];
                this._batchStartTime = now;
                this._lastVerifyTime = now;
                console.log(`\u{1F3A4} Sending ${Math.round(durationSinceBatch / 1e3)}s of speech for verification...`);
                this.voiceService.verifyVoice(combinedBlob, this.roomName, this.userName).subscribe({
                  next: (response) => {
                    if (response.success && response.percentage !== void 0) {
                      const pct = response.percentage;
                      this._lastMatchPct = pct;
                      this.verificationScores.push(pct);
                      if (this.verificationScores.length > this.VERIFICATION_WINDOW)
                        this.verificationScores.shift();
                      const weights = this.verificationScores.map((_, i, arr) => (i + 1) / arr.length);
                      const avg = Math.round(this.verificationScores.reduce((a, b, i) => a + b * weights[i], 0));
                      this.ngZone.run(() => {
                        this.voice = response.status === "suspicious" ? "Unmatch" : "Match";
                        console.log("\u{1F3A4} Voice match:", this.voice, `(Status: ${response.status})`);
                        const me = this.participantsMap.get("__you__");
                        if (me) {
                          this.participantsMap.set("__you__", __spreadProps(__spreadValues({}, me), { voice: this.voice }));
                          this.syncParticipantsArray();
                        }
                        this.sendSig({
                          type: "voice_update",
                          user: this.userName,
                          voice: this.voice,
                          ts: Date.now()
                        });
                      });
                      if (avg < 65) {
                        console.warn("\u26A0\uFE0F Possible mismatch detected \u2014 avg:", avg + "%");
                      }
                    } else {
                      console.error("\u274C Verification failed:", response.message);
                    }
                  },
                  error: (err) => {
                    console.error("\u274C Verification API error:", err);
                  }
                });
              } catch (err) {
                console.error("Error analyzing chunk:", err);
              }
            });
            this.isVoiceMonitoring = true;
            yield new Promise((r) => setTimeout(r, 300));
            this.mediaRecorder.start();
            this.verificationTimer = setInterval(() => {
              if (!this.mediaRecorder)
                return;
              if (this.mediaRecorder.state === "recording") {
                try {
                  this.mediaRecorder.stop();
                } catch (_) {
                }
                setTimeout(() => {
                  if (this.mediaRecorder && this.isVoiceMonitoring) {
                    try {
                      this.mediaRecorder.start();
                    } catch (_) {
                    }
                  }
                }, 150);
              } else {
                try {
                  this.mediaRecorder.start();
                } catch (err) {
                  console.warn("recorder start err", err);
                }
              }
            }, this.RECORD_MS + 200);
            alert("Verification started \u2014 speak to verify your voice.");
          } catch (err) {
            alert("Could not start verification: " + (err.message || err));
            this.stopVerification();
          }
        });
      }
      stopVerification() {
        try {
          this.mediaRecorder?.stop();
        } catch (_) {
        }
        if (this.mediaStream) {
          this.mediaStream.getTracks().forEach((t2) => {
            try {
              t2.stop();
            } catch {
            }
          });
          this.mediaStream = null;
        }
        if (this.verificationTimer) {
          clearInterval(this.verificationTimer);
          this.verificationTimer = null;
        }
        this.mediaRecorder = null;
        this.verificationScores = [];
        this.voice = "N/A";
        this.isVoiceMonitoring = false;
        console.log("Verification stopped");
      }
      updateName(e) {
        const v = e.target.value.trim() || "You";
        const me = this.participantsMap.get("__you__");
        if (me) {
          this.participantsMap.set("__you__", __spreadProps(__spreadValues({}, me), { name: v, initials: this.initialsFromName(v) }));
          this.syncParticipantsArray();
        }
        this.sendSig({ type: "name_update", name: v });
      }
      toggleMic() {
        return __async(this, null, function* () {
          const me = this.participantsMap.get("__you__");
          if (!me)
            return;
          const next = me.mic === "on" ? "off" : "on";
          if (next === "on") {
            try {
              const s = yield navigator.mediaDevices.getUserMedia({ audio: true, video: false });
              this.localAudioTrack = s.getAudioTracks()[0] || null;
              if (this.hasVoiceBaseline && !this.isVoiceMonitoring) {
                yield this.startVerification();
              }
            } catch (e) {
              alert("Microphone access denied: " + (e?.message || ""));
              return;
            }
          } else {
            if (this.isVoiceMonitoring) {
              this.stopVerification();
            }
            this.localAudioTrack?.stop();
            this.localAudioTrack = null;
          }
          this.refreshLocalPreview();
          this.participantsMap.set("__you__", __spreadProps(__spreadValues({}, me), { mic: next }));
          this.syncParticipantsArray();
          this.sendSig({ type: "mic_toggle", mic: next });
          this.peers.forEach((_st, ch) => this.renegotiate(ch));
        });
      }
      toggleCam() {
        return __async(this, null, function* () {
          const me = this.participantsMap.get("__you__");
          if (!me)
            return;
          const next = me.cam === "on" ? "off" : "on";
          if (next === "on") {
            try {
              const s = yield navigator.mediaDevices.getUserMedia({ video: true, audio: false });
              this.localVideoTrack = s.getVideoTracks()[0] || null;
              if (this.localVideoTrack) {
                this.localVideoTrack.enabled = true;
                this.localVideoTrack.onended = () => {
                  this.localVideoTrack = null;
                  this.refreshLocalPreview();
                  const me2 = this.participantsMap.get("__you__");
                  if (me2) {
                    this.participantsMap.set("__you__", __spreadProps(__spreadValues({}, me2), { cam: "off", videoOn: false }));
                    this.syncParticipantsArray();
                  }
                  this.sendSig({ type: "cam_toggle", cam: "off" });
                  this.peers.forEach((_st, ch) => this.renegotiate(ch));
                  this.monitorLoopRunning = false;
                  stopGazeTracking();
                  this.isGazeTracking = false;
                };
              }
            } catch (e) {
              alert("Camera access error: " + (e?.message || ""));
              return;
            }
          } else {
            this.localVideoTrack?.stop();
            this.localVideoTrack = null;
            this.monitorLoopRunning = false;
            stopGazeTracking();
            this.isGazeTracking = false;
          }
          this.refreshLocalPreview();
          this.participantsMap.set("__you__", __spreadProps(__spreadValues({}, me), { cam: next, videoOn: next === "on", stream: this.localPreviewStream }));
          this.syncParticipantsArray();
          this.sendSig({ type: "cam_toggle", cam: next });
          this.peers.forEach((_st, ch) => this.renegotiate(ch));
          if (next === "on") {
            this.monitorSelfVideo();
          }
        });
      }
      monitorSelfVideo() {
        const ws = this.signaling.getSocket();
        if (!ws || ws.readyState !== WebSocket.OPEN)
          return;
        const tryAttach = () => {
          const selfVideo = document.querySelector('video[data-chan="__you__"]');
          if (selfVideo && document.body.contains(selfVideo)) {
            startGazeTracking(selfVideo, ws, this.userName, (status) => {
              this.handleGazeStatus(status);
              this.sendSig({
                type: "gaze_status",
                user: this.userName,
                gaze: status,
                ts: Date.now()
              });
            }, this.gazeThresholds);
          } else {
            setTimeout(tryAttach, 500);
          }
        };
        tryAttach();
      }
      shareScreen() {
        return __async(this, null, function* () {
          try {
            const screenStream = yield navigator.mediaDevices.getDisplayMedia({ video: true });
            const screenTrack = screenStream.getVideoTracks()[0];
            if (!screenTrack)
              return;
            try {
              this.localVideoTrack?.stop();
            } catch {
            }
            this.localVideoTrack = screenTrack;
            screenTrack.onended = () => {
              this.localVideoTrack = null;
              this.refreshLocalPreview();
              const me2 = this.participantsMap.get("__you__");
              if (me2) {
                this.participantsMap.set("__you__", __spreadProps(__spreadValues({}, me2), { cam: "off", videoOn: false }));
                this.syncParticipantsArray();
              }
              this.sendSig({ type: "cam_toggle", cam: "off" });
              this.peers.forEach((_st, ch) => this.renegotiate(ch));
            };
            this.refreshLocalPreview();
            const me = this.participantsMap.get("__you__");
            if (me) {
              const up = __spreadProps(__spreadValues({}, me), { cam: "on", videoOn: this.computeVideoOn("on", this.localPreviewStream) });
              this.participantsMap.set("__you__", up);
              this.syncParticipantsArray();
            }
            this.sendSig({ type: "cam_toggle", cam: "on" });
            this.peers.forEach((_st, ch) => this.renegotiate(ch));
          } catch {
            alert("Screen share failed.");
          }
        });
      }
      cycleLayout() {
        if (this.tileColsManual == null)
          this.tileColsManual = 1;
        else if (this.tileColsManual < 4)
          this.tileColsManual += 1;
        else
          this.tileColsManual = null;
      }
      leaveCall() {
        this.sendSig({ type: "bye" });
        if (this.you?.stream) {
          this.you.stream.getTracks().forEach((track) => track.stop());
        }
        this.peers.forEach(({ pc }) => {
          try {
            pc.close();
          } catch {
          }
        });
        this.peers.clear();
        this.participantsMap.forEach((_p, ch) => {
          if (ch !== "__you__")
            this.participantsMap.delete(ch);
        });
        this.participantsMap.delete("__you__");
        this.syncParticipantsArray();
        this.exitFullscreen();
        this.hasShownEscAlert = false;
        this.escPressCount = 0;
        this.isNameUpdated = false;
      }
      raiseHand() {
        const me = this.participantsMap.get("__you__");
        if (!me)
          return;
        const next = !me.handRaised;
        this.participantsMap.set("__you__", __spreadProps(__spreadValues({}, me), { handRaised: next }));
        this.syncParticipantsArray();
        this.sendSig({ type: "hand_toggle", handRaised: next });
      }
      startNotes() {
        this.isNotesOpen = true;
      }
      closeNotes() {
        this.isNotesOpen = false;
      }
      runGazeSession() {
        return __async(this, null, function* () {
          const thresholds = yield startCalibration();
          const ws = this.signaling.getSocket();
          const selfVideo = document.querySelector('video[data-chan="__you__"]');
          if (!selfVideo || !ws) {
            alert("Please turn on your camera first");
            return;
          }
          startGazeTracking(selfVideo, ws, this.userName, (status) => {
            this.handleGazeStatus(status);
            this.sendSig({
              type: "gaze_status",
              user: this.userName,
              gaze: status,
              ts: Date.now()
            });
          }, thresholds);
        });
      }
      get shouldShowSelfVideo() {
        return !!this.you?.videoOn && !!this.you?.stream && this.gridParticipants.length > 0;
      }
      trackByParticipant(index, item) {
        return item.channel;
      }
      // ====== Permission Methods ======
      checkMediaPermissions() {
        return __async(this, null, function* () {
          try {
            if (navigator.permissions) {
              const cameraPermission = yield navigator.permissions.query({ name: "camera" });
              const micPermission = yield navigator.permissions.query({ name: "microphone" });
              this.permissionStatus.camera = cameraPermission.state === "granted";
              this.permissionStatus.microphone = micPermission.state === "granted";
              if (!this.permissionStatus.camera || !this.permissionStatus.microphone) {
                this.showPermissionPopup = true;
              }
            } else {
              try {
                const stream = yield navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                stream.getTracks().forEach((track) => track.stop());
                this.permissionStatus.camera = true;
                this.permissionStatus.microphone = true;
              } catch (err) {
                this.showPermissionPopup = true;
              }
            }
          } catch (error) {
            this.showPermissionPopup = true;
          }
        });
      }
      requestPermissions() {
        return __async(this, null, function* () {
          try {
            const stream = yield navigator.mediaDevices.getUserMedia({
              video: true,
              audio: true
            });
            stream.getTracks().forEach((track) => track.stop());
            this.permissionStatus.camera = true;
            this.permissionStatus.microphone = true;
            this.showPermissionPopup = false;
            alert("Permissions granted! You can now join the call.");
          } catch (error) {
            if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") {
              alert("Camera and microphone access denied. Please enable them in your browser settings to use this app.");
            } else if (error.name === "NotFoundError") {
              alert("No camera or microphone found. Please connect a device and try again.");
            } else {
              alert("Error accessing camera/microphone: " + error.message);
            }
          }
        });
      }
      closePermissionPopup() {
        this.showPermissionPopup = false;
      }
      // ====== Fullscreen Methods ======
      enterFullscreen() {
        const elem = document.documentElement;
        if (elem.requestFullscreen) {
          elem.requestFullscreen().catch((err) => {
            console.error("Fullscreen request failed:", err);
          });
        } else if (elem.webkitRequestFullscreen) {
          elem.webkitRequestFullscreen();
        } else if (elem.mozRequestFullScreen) {
          elem.mozRequestFullScreen();
        } else if (elem.msRequestFullscreen) {
          elem.msRequestFullscreen();
        }
      }
      exitFullscreen() {
        if (document.exitFullscreen) {
          document.exitFullscreen().catch(() => {
          });
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
          document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
      }
      // ====== Gradient Generator for Tiles ======
      getGradientForParticipant(channel) {
        const gradients = [
          "linear-gradient(135deg, rgba(102, 126, 234, 0.4) 0%, rgba(118, 75, 162, 0.4) 100%)",
          "linear-gradient(135deg, rgba(240, 147, 251, 0.4) 0%, rgba(245, 87, 108, 0.4) 100%)",
          "linear-gradient(135deg, rgba(79, 172, 254, 0.4) 0%, rgba(0, 242, 254, 0.4) 100%)",
          "linear-gradient(135deg, rgba(67, 233, 123, 0.4) 0%, rgba(56, 249, 215, 0.4) 100%)",
          "linear-gradient(135deg, rgba(250, 112, 154, 0.4) 0%, rgba(254, 225, 64, 0.4) 100%)",
          "linear-gradient(135deg, rgba(48, 207, 208, 0.4) 0%, rgba(51, 8, 103, 0.4) 100%)",
          "linear-gradient(135deg, rgba(168, 237, 234, 0.4) 0%, rgba(254, 214, 227, 0.4) 100%)",
          "linear-gradient(135deg, rgba(255, 154, 158, 0.4) 0%, rgba(254, 207, 239, 0.4) 100%)",
          "linear-gradient(135deg, rgba(255, 236, 210, 0.4) 0%, rgba(252, 182, 159, 0.4) 100%)",
          "linear-gradient(135deg, rgba(255, 110, 127, 0.4) 0%, rgba(191, 233, 255, 0.4) 100%)"
        ];
        let hash3 = 0;
        for (let i = 0; i < channel.length; i++) {
          hash3 = (hash3 << 5) - hash3 + channel.charCodeAt(i);
          hash3 = hash3 & hash3;
        }
        const index = Math.abs(hash3) % gradients.length;
        return gradients[index];
      }
      // ====== Face Capture Methods for Enrollment ======
      startEnrollmentCamera() {
        return __async(this, null, function* () {
          try {
            const stream = yield navigator.mediaDevices.getUserMedia({
              video: { width: 640, height: 480 },
              audio: false
            });
            this.enrollmentCameraStream = stream;
            this.permissionStatus.camera = true;
            this.startFacePositionCheck();
          } catch (err) {
            this.permissionStatus.camera = false;
            throw new Error("Camera access denied for enrollment: " + (err?.message || ""));
          }
        });
      }
      stopEnrollmentCamera() {
        if (this.enrollmentCameraStream) {
          this.enrollmentCameraStream.getTracks().forEach((track) => track.stop());
          this.enrollmentCameraStream = null;
        }
        if (this.faceDetectionInterval) {
          clearInterval(this.faceDetectionInterval);
          this.faceDetectionInterval = null;
        }
        this.showEnrollmentCamera = false;
        this.facePositionCorrect = true;
        this.facePositionMessage = "";
      }
      startFacePositionCheck() {
        this.facePositionCorrect = true;
        this.facePositionMessage = "";
        this.faceDetectionInterval = setInterval(() => {
          this.facePositionCorrect = true;
        }, 2e3);
      }
      updateReadingText() {
        const textIndex = Math.min(this.voiceRecordingProgress, this.READING_TEXTS.length - 1);
        this.currentReadingText = this.READING_TEXTS[textIndex];
      }
      // Getter to check if finish button should be enabled
      get canFinishEnrollment() {
        return this.enrollmentSuccessCount >= this.ENROLL_SAMPLES;
      }
      static \u0275fac = function Dashboard_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _Dashboard)(\u0275\u0275directiveInject(SignalingService), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(VoiceService), \u0275\u0275directiveInject(ChangeDetectorRef));
      };
      static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _Dashboard, selectors: [["app-dashboard"]], viewQuery: function Dashboard_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuery(_c03, 5);
          \u0275\u0275viewQuery(_c13, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.chatScroll = _t.first);
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.enrollmentVideo = _t.first);
        }
      }, hostBindings: function Dashboard_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("beforeunload", function Dashboard_beforeunload_HostBindingHandler() {
            return ctx.onBeforeUnload();
          }, \u0275\u0275resolveWindow)("resize", function Dashboard_resize_HostBindingHandler() {
            return ctx.onResize();
          }, \u0275\u0275resolveWindow)("keydown.escape", function Dashboard_keydown_escape_HostBindingHandler() {
            return ctx.onEscapeKey();
          }, \u0275\u0275resolveDocument);
        }
      }, features: [\u0275\u0275ProvidersFeature([SignalingService, VoiceService])], decls: 4, vars: 4, consts: [["chatScroll", ""], ["class", "fixed inset-0 bg-black/70 flex items-center justify-center z-[9999]", 4, "ngIf"], [4, "ngIf"], ["class", "h-screen text-white grid grid-cols-1 lg:grid-cols-[1fr_340px] gap-4 p-4 overflow-hidden items-stretch", 3, "chat-open", 4, "ngIf"], [3, "close", 4, "ngIf"], [1, "fixed", "inset-0", "bg-black/70", "flex", "items-center", "justify-center", "z-[9999]"], [1, "bg-slate-800", "p-8", "rounded-xl", "shadow-2xl", "w-96", "border", "border-sky-500/30"], [1, "text-center", "mb-6"], [1, "w-16", "h-16", "bg-sky-600/20", "rounded-full", "flex", "items-center", "justify-center", "mx-auto", "mb-4"], [1, "ph", "ph-video-camera", "text-4xl", "text-sky-400"], [1, "text-2xl", "font-bold", "mb-2"], [1, "text-slate-300", "text-sm"], [1, "space-y-3", "mb-6"], [1, "flex", "items-center", "gap-3", "p-3", "bg-slate-700/50", "rounded-lg"], [1, "ph", "ph-video-camera", "text-2xl", "text-sky-400"], [1, "flex-1"], [1, "font-semibold"], [1, "text-xs", "text-slate-400"], ["class", "text-green-400", 4, "ngIf"], [1, "ph", "ph-microphone", "text-2xl", "text-sky-400"], [1, "flex", "gap-3"], [1, "flex-1", "px-4", "py-3", "rounded-lg", "bg-sky-600", "hover:bg-sky-700", "font-semibold", "transition-colors", 3, "click"], [1, "px-4", "py-3", "rounded-lg", "bg-slate-700", "hover:bg-slate-600", "font-semibold", "transition-colors", 3, "click"], [1, "text-xs", "text-slate-400", "text-center", "mt-4"], [1, "text-green-400"], [1, "h-screen", "flex", "items-center", "justify-center", "bg-slate-900", "text-white"], [1, "bg-slate-800", "p-6", "rounded-xl", "shadow-xl", "w-96"], [1, "text-xl", "font-bold", "mb-4"], [1, "block", "mb-3"], [1, "text-sm"], ["id", "nameInput", "type", "text", "placeholder", "Enter Your name", 1, "mt-1", "w-full", "px-3", "py-2", "rounded-md", "bg-slate-700", "text-white", 3, "ngModelChange", "ngModel"], [1, "mb-4", "p-4", "bg-slate-700/50", "rounded-lg", "border", "border-sky-500/30"], [1, "space-y-4", "text-center"], [1, "flex", "items-center", "justify-center", "gap-2", "text-sm", "font-semibold", "text-slate-100"], [1, "ph", "ph-microphone", "text-sky-400"], [1, "bg-slate-800/80", "rounded-lg", "p-3"], [1, "text-sm", "text-slate-200"], [1, "mt-3", "h-2", "w-full", "bg-slate-900/50", "rounded", "overflow-hidden"], [1, "h-full", "bg-sky-500", "transition-all", "duration-300", "ease-out"], ["class", "mt-1 text-xs text-slate-400", 4, "ngIf"], ["class", "bg-slate-800/60 rounded-lg p-4 text-left", 4, "ngIf"], [1, "flex", "flex-col", "sm:flex-row", "sm:justify-center", "gap-2"], ["class", "px-4 py-2 rounded-lg bg-sky-600 hover:bg-sky-700 text-sm font-semibold transition-colors", 3, "click", 4, "ngIf"], ["class", "px-4 py-2 rounded-lg bg-amber-500 hover:bg-amber-600 disabled:opacity-60 text-sm font-semibold transition-colors", 3, "disabled", "click", 4, "ngIf"], ["class", "text-xs text-green-400 font-medium", 4, "ngIf"], [1, "flex", "items-center", "gap-2", "mb-4"], ["id", "termsCheckbox", "type", "checkbox", 1, "w-4", "h-4", 3, "ngModelChange", "disabled", "ngModel"], ["id", "joinBtn", 1, "w-full", "px-4", "py-2", "rounded-lg", "bg-sky-600", "hover:bg-sky-700", "disabled:opacity-50", 3, "click"], [1, "mt-1", "text-xs", "text-slate-400"], [1, "bg-slate-800/60", "rounded-lg", "p-4", "text-left"], [1, "text-xs", "uppercase", "tracking-wide", "text-sky-300", "font-semibold", "mb-1"], [1, "text-sm", "text-slate-100", "leading-relaxed"], [1, "px-4", "py-2", "rounded-lg", "bg-sky-600", "hover:bg-sky-700", "text-sm", "font-semibold", "transition-colors", 3, "click"], [1, "px-4", "py-2", "rounded-lg", "bg-amber-500", "hover:bg-amber-600", "disabled:opacity-60", "text-sm", "font-semibold", "transition-colors", 3, "click", "disabled"], [1, "text-xs", "text-green-400", "font-medium"], [1, "h-screen", "text-white", "grid", "grid-cols-1", "lg:grid-cols-[1fr_340px]", "gap-4", "p-4", "overflow-hidden", "items-stretch"], [1, "stage", "flex-1", "flex", "flex-col", "relative", "min-h-0"], ["class", "stage-header flex items-center justify-between px-3 py-2 rounded-t-md shrink-0", 4, "ngIf"], [1, "tile-grid-container", "flex-1", "min-h-0", "p-4", "gap-6", "border", "border-sky-700/40", "rounded-xl", "bg-slate-900/40", "flex", "flex-col", "overflow-hidden"], ["class", "tile-grid min-h-0 overflow-y-auto no-scrollbar", 3, "ngClass", 4, "ngIf"], [1, "controls", "shrink-0", "bg-slate-900/60", "backdrop-blur-sm", "p-4", "rounded-lg", "border-t", "border-sky-700/30", "flex", "flex-wrap", "gap-3", "justify-center"], [1, "ctrl", "secondary", "flex", "items-center", "gap-2", "px-4", "py-2", "rounded-full", 3, "click"], [1, "ph", 3, "ngClass"], [1, "ph", "ph-monitor"], [1, "ph", "ph-hand"], [1, "ph", "ph-note"], [1, "ph", "ph-grid-four"], [1, "ctrl", "danger", "flex", "items-center", "gap-2", "px-4", "py-2", "rounded-full", 3, "click"], [1, "ph", "ph-sign-out"], ["class", "self-video-floating", "cdkDrag", "", "cdkDragBoundary", ".stage", 4, "ngIf"], [1, "chat-panel", "frosted", "lg:static", "fixed", "inset-y-0", "right-0", "w-full", "max-w-sm", "transform", "transition-transform", "duration-300", "flex", "flex-col", "z-50", "min-h-0", "shadow-2xl", 3, "ngClass"], [1, "shrink-0", "p-3"], [1, "relative", "floating", "mt-2"], [1, "ph", "ph-user", "icon-left", "text-sky-300"], ["id", "username", "type", "text", 1, "floating-input", "pl-10", "pr-3", "py-2", "text-sm", "rounded-md", "w-full", "dark-input", 3, "change", "value"], ["for", "username", 1, "floating-label"], [1, "chat-header", "flex", "items-center", "justify-between", "px-4", "py-3", "border-b", "border-sky-700/20", "shrink-0"], [1, "flex", "gap-4"], [1, "tab-btn", 3, "click"], ["class", "hr-btn px-3 py-1 text-xs", 3, "click", 4, "ngIf"], [1, "flex-1", "min-h-0", "flex", "flex-col"], ["class", "flex-1 max-h-full overflow-y-auto participants-scroll p-4", 4, "ngIf"], ["class", "flex-1 max-h-full overflow-y-auto chat-scroll p-4", 4, "ngIf"], ["class", "flex border-t border-sky-700/10 p-2", 3, "ngSubmit", 4, "ngIf"], [1, "stage-header", "flex", "items-center", "justify-between", "px-3", "py-2", "rounded-t-md", "shrink-0"], [1, "text-sm", "text-sky-100"], [1, "hr-btn", "flex", "items-center", "gap-2", 3, "click"], [1, "ph", "ph-users"], [1, "tile-grid", "min-h-0", "overflow-y-auto", "no-scrollbar", 3, "ngClass"], ["class", "tile group relative rounded-xl overflow-hidden aspect-video flex items-center justify-center bg-gradient-to-b from-slate-800 to-slate-900 shadow-md hover:shadow-xl transition-all duration-300", 3, "video-on", "hide-when-pip", "hand-raised", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "tile", "group", "relative", "rounded-xl", "overflow-hidden", "aspect-video", "flex", "items-center", "justify-center", "bg-gradient-to-b", "from-slate-800", "to-slate-900", "shadow-md", "hover:shadow-xl", "transition-all", "duration-300"], ["autoplay", "", "playsinline", "", "class", "absolute inset-0 w-full h-full object-cover", 3, "appSrcObject", "muted", 4, "ngIf"], ["autoplay", "", 3, "appSrcObject", 4, "ngIf"], ["class", "placeholder flex items-center justify-center w-full h-full", 3, "background", 4, "ngIf"], [1, "nameplate", "absolute", "left-2", "top-9", "px-3", "py-1", "rounded-full", "text-xs", "font-semibold", "flex", "items-center", "gap-2", "bg-black/50", "backdrop-blur-sm", "text-sky-400"], [1, "nameplate", "absolute", "left-2", "top-16", "px-3", "py-1", "rounded-full", "text-xs", "font-semibold", "flex", "items-center", "gap-2", "bg-black/50", "backdrop-blur-sm", "text-purple-400"], [1, "nameplate", "absolute", "left-3", "bottom-3", "px-3", "py-1", "rounded-full", "text-xs", "font-semibold", "flex", "items-center", "gap-2", "bg-black/50", "backdrop-blur-sm"], [1, "badge", "w-2", "h-2", "rounded-full", 3, "ngClass"], ["autoplay", "", "playsinline", "", 1, "absolute", "inset-0", "w-full", "h-full", "object-cover", 3, "appSrcObject", "muted"], ["autoplay", "", 3, "appSrcObject"], [1, "placeholder", "flex", "items-center", "justify-center", "w-full", "h-full"], [1, "initials", "w-32", "h-32", "rounded-full", "flex", "items-center", "justify-center", "font-extrabold", "text-4xl", "bg-black/30", "text-white", "backdrop-blur-sm"], ["class", "hand-emoji", 4, "ngIf"], [1, "hand-emoji"], ["cdkDrag", "", "cdkDragBoundary", ".stage", 1, "self-video-floating"], ["autoplay", "", "playsinline", "", "data-chan", "__you__", "class", "w-full h-full object-cover rounded-lg shadow-lg", 3, "appSrcObject", "muted", 4, "ngIf"], ["autoplay", "", "playsinline", "", "data-chan", "__you__", 1, "w-full", "h-full", "object-cover", "rounded-lg", "shadow-lg", 3, "appSrcObject", "muted"], [1, "hr-btn", "px-3", "py-1", "text-xs", 3, "click"], [1, "flex-1", "max-h-full", "overflow-y-auto", "participants-scroll", "p-4"], [1, "text-sky-100", "text-sm", "mb-2"], ["class", "flex justify-between items-center p-2 bg-slate-800/50 rounded mb-1", 4, "ngFor", "ngForOf"], [1, "flex", "justify-between", "items-center", "p-2", "bg-slate-800/50", "rounded", "mb-1"], [1, "flex", "items-center", "gap-2"], [1, "w-8", "h-8", "rounded-full", "flex", "items-center", "justify-center", "text-sm", "font-bold"], ["class", "hand-emoji text-xs", 4, "ngIf"], ["class", "text-xs text-sky-400", 4, "ngIf"], ["class", "text-xs text-purple-400", 4, "ngIf"], [1, "hand-emoji", "text-xs"], [1, "text-xs", "text-sky-400"], [1, "text-xs", "text-purple-400"], [1, "flex-1", "max-h-full", "overflow-y-auto", "chat-scroll", "p-4"], ["class", "p-2 bg-slate-800/60 rounded mb-1", 4, "ngFor", "ngForOf"], [1, "p-2", "bg-slate-800/60", "rounded", "mb-1"], [1, "text-xs", "font-semibold", "text-sky-200"], [1, "flex", "border-t", "border-sky-700/10", "p-2", 3, "ngSubmit"], ["name", "chatText", "type", "text", "placeholder", "Message the room...", 1, "flex-1", "rounded-l-full", "px-3", "py-2", "text-sm", "dark-input", 3, "ngModelChange", "ngModel"], ["type", "submit", 1, "px-4", "py-2", "rounded-r-full", "hr-btn"], [3, "close"]], template: function Dashboard_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275template(0, Dashboard_div_0_Template, 33, 2, "div", 1)(1, Dashboard_main_1_Template, 32, 11, "main", 2)(2, Dashboard_main_2_Template, 53, 20, "main", 3)(3, Dashboard_app_notepad_3_Template, 1, 0, "app-notepad", 4);
        }
        if (rf & 2) {
          \u0275\u0275property("ngIf", ctx.showPermissionPopup);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", !ctx.isNameUpdated);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.isNameUpdated);
          \u0275\u0275advance();
          \u0275\u0275property("ngIf", ctx.isNotesOpen);
        }
      }, dependencies: [CommonModule, NgClass, NgForOf, NgIf, FormsModule, \u0275NgNoValidate, DefaultValueAccessor, CheckboxControlValueAccessor, NgControlStatus, NgControlStatusGroup, NgModel, NgForm, MediaSrcObjectDirective, SrcObjectDirective, DragDropModule, CdkDrag, NotepadComponent, HttpClientModule], styles: ['@charset "UTF-8";\n\n\n\n[_ngcontent-%COMP%]:root {\n  --c1: #09162b;\n  --c2: #1a3463;\n  --c3: #23293b;\n}\nhtml[_ngcontent-%COMP%] {\n  scroll-behavior: smooth;\n}\nbody[_ngcontent-%COMP%] {\n  font-family: "Inter", sans-serif;\n  color: #fff;\n  margin: 0;\n  background:\n    linear-gradient(\n      135deg,\n      var(--c1),\n      var(--c2),\n      var(--c3));\n  background-size: 400% 400%;\n  animation: _ngcontent-%COMP%_gradientShift 12s ease infinite;\n}\n@keyframes _ngcontent-%COMP%_gradientShift {\n  0% {\n    background-position: 0% 50%;\n  }\n  50% {\n    background-position: 100% 50%;\n  }\n  100% {\n    background-position: 0% 50%;\n  }\n}\n#mainHeader[_ngcontent-%COMP%] {\n  transition: background 500ms ease;\n}\n#mainHeader.overlay[_ngcontent-%COMP%] {\n  background:\n    linear-gradient(\n      to bottom,\n      rgba(2, 12, 27, 0.7),\n      rgba(2, 12, 27, 0));\n}\n.frosted[_ngcontent-%COMP%] {\n  -webkit-backdrop-filter: blur(25px);\n  backdrop-filter: blur(25px);\n  background-color: rgba(18, 27, 40, 0.62);\n  border: 1.5px solid rgba(0, 191, 255, 0.14);\n  box-shadow: 0 12px 40px 0 rgba(38, 112, 255, 0.14), -5px 0 25px rgba(0, 191, 255, 0.16);\n}\ninput[_ngcontent-%COMP%]:focus {\n  outline: none;\n  border-color: #0fd9ff;\n  box-shadow: 0 0 0 3px rgba(15, 217, 255, 0.5);\n}\nbutton[_ngcontent-%COMP%], \n.sign-in-btn[_ngcontent-%COMP%] {\n  background:\n    linear-gradient(\n      90deg,\n      #0fd9ff 0%,\n      #2e57ff 100%);\n  box-shadow: 0 2px 30px 0 rgba(40, 75, 255, 0.16);\n  border-radius: 9999px;\n  padding: 0.6rem 1rem;\n}\nbutton[_ngcontent-%COMP%]:hover, \n.sign-in-btn[_ngcontent-%COMP%]:hover {\n  background:\n    linear-gradient(\n      90deg,\n      #51e2f5 0%,\n      #284bff 100%);\n  box-shadow: 0 4px 32px 0 rgba(40, 75, 255, 0.28);\n  color: #fff;\n}\n.text-xl[_ngcontent-%COMP%], \nh1[_ngcontent-%COMP%], \n.font-bold[_ngcontent-%COMP%] {\n  text-shadow: 1px 1px 8px rgba(40, 75, 255, 0.08);\n}\n.placeholder-gray-400[_ngcontent-%COMP%]::placeholder {\n  color: #a8b0c5;\n  opacity: 1;\n}\ncanvas#particles[_ngcontent-%COMP%] {\n  position: fixed;\n  inset: 0;\n  z-index: -1;\n  background:\n    linear-gradient(\n      135deg,\n      var(--c1),\n      var(--c2),\n      var(--c3));\n  background-size: 400% 400%;\n  animation: _ngcontent-%COMP%_gradientShift 12s ease infinite;\n  pointer-events: none;\n}\n#closeLogin[_ngcontent-%COMP%] {\n  z-index: 9999;\n  position: absolute;\n  top: 1.5rem;\n  right: 1.5rem;\n  background: transparent;\n  border: none;\n  cursor: pointer;\n}\n.floating[_ngcontent-%COMP%] {\n  position: relative;\n}\n.floating[_ngcontent-%COMP%]   input.floating-input[_ngcontent-%COMP%] {\n  width: 100%;\n  padding-left: 2.5rem;\n  padding-top: 1.25rem;\n  padding-bottom: 0.5rem;\n  border-radius: 0.5rem;\n  background: rgba(18, 27, 40, 0.55);\n  border: 1px solid rgba(148, 163, 184, 0.12);\n  color: #fff;\n  transition: box-shadow 0.18s ease, border-color 0.18s ease;\n}\n.floating[_ngcontent-%COMP%]   label.floating-label[_ngcontent-%COMP%] {\n  position: absolute;\n  left: 2.5rem;\n  top: 50%;\n  transform: translateY(-50%);\n  font-size: 1rem;\n  color: #a8b0c5;\n  pointer-events: none;\n  transition: all 180ms ease;\n}\n.floating[_ngcontent-%COMP%]   input.floating-input[_ngcontent-%COMP%]:focus    + label.floating-label[_ngcontent-%COMP%], \n.floating[_ngcontent-%COMP%]   input.floating-input[_ngcontent-%COMP%]:not(:placeholder-shown)    + label.floating-label[_ngcontent-%COMP%] {\n  top: 0.3rem;\n  transform: translateY(0);\n  font-size: 0.78rem;\n  color: #0fd9ff;\n}\n.floating[_ngcontent-%COMP%]   input.floating-input[type=password][_ngcontent-%COMP%] {\n  letter-spacing: 0.25em;\n}\n.floating[_ngcontent-%COMP%]   .icon-left[_ngcontent-%COMP%] {\n  pointer-events: none;\n  position: absolute;\n  left: 0.75rem;\n  top: 50%;\n  transform: translateY(-50%);\n  color: #9aa6bb;\n}\n#openLoginBtn[_ngcontent-%COMP%] {\n  z-index: 45;\n}\n.tile-grid-container[_ngcontent-%COMP%] {\n  flex: 1 1 auto;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  position: relative;\n}\n.tile-grid[_ngcontent-%COMP%] {\n  display: grid;\n  width: 100%;\n  height: 100%;\n  gap: 1rem;\n  justify-items: center;\n  grid-auto-rows: 1fr;\n  overflow: hidden;\n}\n.tile-grid.layout-1[_ngcontent-%COMP%] {\n  grid-template-columns: 1fr;\n}\n.tile-grid.layout-2[_ngcontent-%COMP%] {\n  grid-template-columns: 1fr;\n}\n@media (min-width: 768px) {\n  .tile-grid.layout-2[_ngcontent-%COMP%] {\n    grid-template-columns: 1fr 1fr;\n  }\n}\n.tile-grid.layout-3[_ngcontent-%COMP%] {\n  grid-template-columns: 1fr 1fr;\n}\n.tile-grid.layout-4[_ngcontent-%COMP%] {\n  grid-template-columns: 1fr 1fr;\n  grid-template-rows: 1fr 1fr;\n}\n.tile-grid.layout-more[_ngcontent-%COMP%] {\n  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));\n}\n.tile[_ngcontent-%COMP%] {\n  border: 1px solid rgba(0, 191, 255, 0.14);\n  -webkit-backdrop-filter: blur(12px);\n  backdrop-filter: blur(12px);\n  background: rgba(18, 27, 40, 0.55);\n  border-radius: 1rem;\n  overflow: hidden;\n  position: relative;\n  transition: transform 0.3s ease, box-shadow 0.3s ease;\n  width: 100%;\n  height: 100%;\n  min-height: 200px;\n  aspect-ratio: 16/9;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.tile[_ngcontent-%COMP%]   video[_ngcontent-%COMP%] {\n  position: absolute;\n  inset: 0;\n  width: 100%;\n  height: 100%;\n  object-fit: fill;\n  z-index: 1;\n  transform: translateZ(0);\n  will-change: transform;\n  mix-blend-mode: normal;\n}\n.tile[_ngcontent-%COMP%]   .placeholder[_ngcontent-%COMP%] {\n  position: absolute;\n  inset: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: rgba(18, 27, 40, 0.85);\n  z-index: 15;\n}\n.tile[_ngcontent-%COMP%]   .canvas[data-role=overlay][_ngcontent-%COMP%] {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 50;\n  pointer-events: none;\n  display: block;\n  background: transparent;\n  border: 2px solid green;\n  transform: translateZ(0);\n  will-change: transform;\n}\n.nameplate[_ngcontent-%COMP%] {\n  border: 1px solid rgba(0, 191, 255, 0.25);\n  transition: background 0.3s ease, transform 0.3s ease;\n  z-index: 30;\n}\n.nameplate[_ngcontent-%COMP%]:hover {\n  background: rgba(0, 191, 255, 0.25);\n  transform: translateY(-2px);\n}\n.tile[_ngcontent-%COMP%], \n.tile[_ngcontent-%COMP%]   *[_ngcontent-%COMP%] {\n  scrollbar-width: none;\n}\n.tile[_ngcontent-%COMP%]::-webkit-scrollbar, \n.tile[_ngcontent-%COMP%]   *[_ngcontent-%COMP%]::-webkit-scrollbar {\n  display: none;\n}\n@media (max-width: 640px) {\n  .tile-grid[_ngcontent-%COMP%] {\n    grid-template-columns: 1fr;\n    gap: 0.5rem;\n  }\n  .tile[_ngcontent-%COMP%] {\n    min-height: 200px;\n    max-width: 100%;\n  }\n}\n.controls[_ngcontent-%COMP%] {\n  flex-wrap: wrap;\n  gap: 0.75rem;\n  justify-content: center;\n  background: rgba(18, 27, 40, 0.55);\n  border-top: 1px solid rgba(148, 163, 184, 0.12);\n  -webkit-backdrop-filter: blur(12px);\n  backdrop-filter: blur(12px);\n  padding: 1rem;\n  border-radius: 1rem;\n}\n.controls[_ngcontent-%COMP%]   button[_ngcontent-%COMP%] {\n  background: rgba(18, 27, 40, 0.55);\n  border: 1px solid rgba(148, 163, 184, 0.12);\n  -webkit-backdrop-filter: blur(12px);\n  backdrop-filter: blur(12px);\n  transition:\n    background 0.3s ease,\n    box-shadow 0.25s ease,\n    transform 0.15s ease;\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 0.6rem 1rem;\n  border-radius: 9999px;\n}\n.controls[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:active {\n  transform: scale(0.98);\n}\n.controls[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]   i[_ngcontent-%COMP%] {\n  font-size: 1.25rem;\n}\n.controls[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]   span[_ngcontent-%COMP%] {\n  display: inline;\n}\n@media (max-width: 640px) {\n  .controls[_ngcontent-%COMP%] {\n    justify-content: space-around;\n  }\n  .controls[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]   span[_ngcontent-%COMP%] {\n    display: none;\n  }\n}\n.controls[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:hover {\n  background: rgba(40, 75, 255, 0.35);\n  box-shadow: 0 6px 20px rgba(40, 75, 255, 0.25);\n}\n.hr-btn[_ngcontent-%COMP%] {\n  border-radius: 9999px;\n  padding: 0.6rem 1rem;\n  background:\n    linear-gradient(\n      90deg,\n      #0fd9ff 0%,\n      #2e57ff 100%);\n  color: #fff;\n  font-weight: 600;\n  letter-spacing: 0.02em;\n  border: 1px solid rgba(148, 163, 184, 0.12);\n}\n.hr-btn[_ngcontent-%COMP%]:hover {\n  box-shadow: 0 6px 18px rgba(40, 75, 255, 0.28);\n}\n.dark-input[_ngcontent-%COMP%], \ninput[type=text][_ngcontent-%COMP%], \ninput[type=password][_ngcontent-%COMP%], \ntextarea[_ngcontent-%COMP%] {\n  background: rgba(18, 27, 40, 0.55);\n  border: 1px solid rgba(148, 163, 184, 0.12);\n  border-radius: 0.75rem;\n  color: #fff;\n  padding: 0.6rem 0.8rem;\n  transition: border-color 0.2s ease, box-shadow 0.2s ease;\n}\n.dark-input[_ngcontent-%COMP%]:focus, \ninput[type=text][_ngcontent-%COMP%]:focus, \ninput[type=password][_ngcontent-%COMP%]:focus, \ntextarea[_ngcontent-%COMP%]:focus {\n  outline: none;\n  border-color: #0fd9ff;\n  box-shadow: 0 0 0 3px rgba(15, 217, 255, 0.4);\n}\n.chat-panel[_ngcontent-%COMP%]   .participants-scroll[_ngcontent-%COMP%], \n.chat-panel[_ngcontent-%COMP%]   .chat-scroll[_ngcontent-%COMP%] {\n  flex: 1 1 auto;\n  min-height: 0;\n  overflow-y: auto;\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n  scroll-behavior: smooth;\n  -webkit-overflow-scrolling: touch;\n}\n.chat-panel[_ngcontent-%COMP%]   .participants-scroll[_ngcontent-%COMP%]::-webkit-scrollbar, \n.chat-panel[_ngcontent-%COMP%]   .chat-scroll[_ngcontent-%COMP%]::-webkit-scrollbar {\n  display: none;\n}\n.tab-btn[_ngcontent-%COMP%] {\n  position: relative;\n  font-size: 0.875rem;\n  font-weight: 500;\n  padding: 0.4rem 0.75rem;\n  border-radius: 9999px;\n  background: transparent;\n  color: #a8b0c5;\n  transition: all 0.25s ease;\n}\n.tab-btn[_ngcontent-%COMP%]:hover {\n  background: rgba(40, 75, 255, 0.15);\n  color: #fff;\n}\n.tab-btn.active[_ngcontent-%COMP%] {\n  background:\n    linear-gradient(\n      90deg,\n      #0fd9ff 0%,\n      #2e57ff 100%);\n  color: #fff;\n  font-weight: 600;\n  box-shadow: 0 0 12px rgba(40, 75, 255, 0.35);\n}\n.self-placeholder[_ngcontent-%COMP%] {\n  background: rgba(30, 41, 59, 0.7);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.self-video-floating[_ngcontent-%COMP%] {\n  position: absolute;\n  bottom: 1rem;\n  right: 1rem;\n  width: 200px;\n  height: 150px;\n  z-index: 60;\n  border-radius: 0.5rem;\n  overflow: hidden;\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);\n  background: rgba(18, 27, 40, 0.9);\n  border: 1px solid rgba(0, 191, 255, 0.14);\n  transition: opacity 0.3s ease;\n}\n.self-video-floating[_ngcontent-%COMP%]:hover {\n  box-shadow: 0 6px 24px rgba(40, 75, 255, 0.25);\n}\n.tile.hand-raised[_ngcontent-%COMP%] {\n  border-color: #FFD700;\n  box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);\n}\n.hand-emoji[_ngcontent-%COMP%] {\n  font-size: 1.2em;\n  margin-left: 0.2em;\n}\n.tile.suspicious[_ngcontent-%COMP%] {\n  border-color: #ff3b3b;\n  box-shadow: 0 0 25px rgba(255, 59, 59, 0.8), 0 0 45px rgba(255, 59, 59, 0.6);\n  animation: _ngcontent-%COMP%_suspiciousPulse 1.5s infinite alternate;\n}\n@keyframes _ngcontent-%COMP%_suspiciousPulse {\n  0% {\n    box-shadow: 0 0 15px rgba(255, 59, 59, 0.6), 0 0 25px rgba(255, 59, 59, 0.4);\n  }\n  100% {\n    box-shadow: 0 0 35px rgba(255, 59, 59, 0.9), 0 0 55px rgba(255, 59, 59, 0.7);\n  }\n}\n.tile[_ngcontent-%COMP%] {\n  position: relative;\n}\n.tile[_ngcontent-%COMP%]   .video-el[_ngcontent-%COMP%] {\n  position: absolute;\n  inset: 0;\n  width: 100%;\n  height: 100%;\n  object-fit: fill;\n  background: #000;\n  z-index: 1;\n  transform: translateZ(0);\n  will-change: transform;\n  mix-blend-mode: normal;\n}\n.tile[_ngcontent-%COMP%]   .overlay-el[_ngcontent-%COMP%] {\n  position: absolute;\n  inset: 0;\n  width: 100% !important;\n  height: 100% !important;\n  display: block;\n  background: transparent;\n  pointer-events: none;\n  z-index: 5;\n}\n.tile[_ngcontent-%COMP%]   .placeholder[_ngcontent-%COMP%] {\n  z-index: 2;\n}\n.tile[_ngcontent-%COMP%]   .nameplate[_ngcontent-%COMP%] {\n  z-index: 10;\n}\n.tile.suspicious[_ngcontent-%COMP%] {\n  border-color: #ff3b3b;\n  box-shadow: 0 0 25px rgba(255, 59, 59, 0.8), 0 0 45px rgba(255, 59, 59, 0.6);\n  animation: _ngcontent-%COMP%_suspiciousPulse 1.5s infinite alternate;\n}\n@keyframes _ngcontent-%COMP%_suspiciousPulse {\n  0% {\n    box-shadow: 0 0 15px rgba(255, 59, 59, 0.6), 0 0 25px rgba(255, 59, 59, 0.4);\n  }\n  100% {\n    box-shadow: 0 0 35px rgba(255, 59, 59, 0.9), 0 0 55px rgba(255, 59, 59, 0.7);\n  }\n}\n/*# sourceMappingURL=dashboard.css.map */'] });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Dashboard, [{
        type: Component,
        args: [{ selector: "app-dashboard", standalone: true, imports: [CommonModule, FormsModule, MediaSrcObjectDirective, SrcObjectDirective, DragDropModule, NotepadComponent, HttpClientModule], providers: [SignalingService, VoiceService], template: `<!-- Permission Popup -->\r
<div *ngIf="showPermissionPopup" class="fixed inset-0 bg-black/70 flex items-center justify-center z-[9999]">\r
  <div class="bg-slate-800 p-8 rounded-xl shadow-2xl w-96 border border-sky-500/30">\r
    <div class="text-center mb-6">\r
      <div class="w-16 h-16 bg-sky-600/20 rounded-full flex items-center justify-center mx-auto mb-4">\r
        <i class="ph ph-video-camera text-4xl text-sky-400"></i>\r
      </div>\r
      <h2 class="text-2xl font-bold mb-2">Camera & Microphone Access</h2>\r
      <p class="text-slate-300 text-sm">This app needs access to your camera and microphone to work properly.</p>\r
    </div>\r
    \r
    <div class="space-y-3 mb-6">\r
      <div class="flex items-center gap-3 p-3 bg-slate-700/50 rounded-lg">\r
        <i class="ph ph-video-camera text-2xl text-sky-400"></i>\r
        <div class="flex-1">\r
          <div class="font-semibold">Camera</div>\r
          <div class="text-xs text-slate-400">Required for video calls</div>\r
        </div>\r
        <span *ngIf="permissionStatus.camera" class="text-green-400">\u2713</span>\r
      </div>\r
      \r
      <div class="flex items-center gap-3 p-3 bg-slate-700/50 rounded-lg">\r
        <i class="ph ph-microphone text-2xl text-sky-400"></i>\r
        <div class="flex-1">\r
          <div class="font-semibold">Microphone</div>\r
          <div class="text-xs text-slate-400">Required for audio calls</div>\r
        </div>\r
        <span *ngIf="permissionStatus.microphone" class="text-green-400">\u2713</span>\r
      </div>\r
    </div>\r
    \r
    <div class="flex gap-3">\r
      <button (click)="requestPermissions()" \r
              class="flex-1 px-4 py-3 rounded-lg bg-sky-600 hover:bg-sky-700 font-semibold transition-colors">\r
        Grant Access\r
      </button>\r
      <button (click)="closePermissionPopup()" \r
              class="px-4 py-3 rounded-lg bg-slate-700 hover:bg-slate-600 font-semibold transition-colors">\r
        Skip\r
      </button>\r
    </div>\r
    \r
    <p class="text-xs text-slate-400 text-center mt-4">\r
      You can change these permissions later in your browser settings\r
    </p>\r
  </div>\r
</div>\r
\r
<main *ngIf="!isNameUpdated">\r
<div class="h-screen flex items-center justify-center bg-slate-900 text-white">\r
  <div class="bg-slate-800 p-6 rounded-xl shadow-xl w-96">\r
    <h2 class="text-xl font-bold mb-4">Join the Room</h2>\r
\r
    <label class="block mb-3">\r
      <span class="text-sm">Enter your name</span>\r
      <input id="nameInput" type="text" placeholder="Enter Your name" [(ngModel)]="userName"\r
        class="mt-1 w-full px-3 py-2 rounded-md bg-slate-700 text-white" />\r
    </label>\r
\r
    <!-- Voice Enrollment Section -->\r
    <div class="mb-4 p-4 bg-slate-700/50 rounded-lg border border-sky-500/30">\r
      <div class="space-y-4 text-center">\r
        <div class="flex items-center justify-center gap-2 text-sm font-semibold text-slate-100">\r
          <i class="ph ph-microphone text-sky-400"></i>\r
          <span>Voice Enrollment</span>\r
        </div>\r
\r
        <div class="bg-slate-800/80 rounded-lg p-3">\r
          <p class="text-sm text-slate-200">{{ statusMessage }}</p>\r
          <div class="mt-3 h-2 w-full bg-slate-900/50 rounded overflow-hidden">\r
            <div class="h-full bg-sky-500 transition-all duration-300 ease-out" [style.width.%]="progressPercent"></div>\r
          </div>\r
          <p *ngIf="progressPercent > 0" class="mt-1 text-xs text-slate-400">Progress: {{ progressPercent }}%</p>\r
        </div>\r
\r
        <div *ngIf="currentPrompt" class="bg-slate-800/60 rounded-lg p-4 text-left">\r
          <p class="text-xs uppercase tracking-wide text-sky-300 font-semibold mb-1">\r
            Prompt {{ takeIndex + 1 }} of {{ totalTakes }}\r
          </p>\r
          <blockquote class="text-sm text-slate-100 leading-relaxed">\r
            {{ currentPrompt }}\r
          </blockquote>\r
        </div>\r
\r
        <div class="flex flex-col sm:flex-row sm:justify-center gap-2">\r
          <button\r
            *ngIf="!enrollmentInProgress && isEnrollmentComplete"\r
            (click)="startEnrollment()"\r
            class="px-4 py-2 rounded-lg bg-sky-600 hover:bg-sky-700 text-sm font-semibold transition-colors">\r
            Start Enrollment\r
          </button>\r
\r
          <button\r
            *ngIf="enrollmentInProgress"\r
            (click)="handleRecordClick()"\r
            [disabled]="!canUseRecorder"\r
            class="px-4 py-2 rounded-lg bg-amber-500 hover:bg-amber-600 disabled:opacity-60 text-sm font-semibold transition-colors">\r
            {{ isRecording ? 'Stop Recording' : 'Record' }}\r
          </button>\r
        </div>\r
\r
        <p *ngIf="hasVoiceBaseline" class="text-xs text-green-400 font-medium">\r
          Voice profile saved. You can re-enroll anytime.\r
        </p>\r
      </div>\r
    </div>\r
\r
    <label class="flex items-center gap-2 mb-4">\r
      <input id="termsCheckbox" [disabled]="!this.hasVoiceBaseline" type="checkbox" [(ngModel)]="termsCheckbox" class="w-4 h-4"/>\r
      <span class="text-sm">I agree to the Terms & Conditions</span>\r
    </label>\r
    \r
    <button id="joinBtn" (click)="updateNameFirst()"\r
      class="w-full px-4 py-2 rounded-lg bg-sky-600 hover:bg-sky-700 disabled:opacity-50">\r
      Join Room\r
    </button>\r
  </div>\r
</div>\r
</main>\r
\r
<main *ngIf="isNameUpdated" class="h-screen text-white grid grid-cols-1 lg:grid-cols-[1fr_340px] gap-4 p-4 overflow-hidden items-stretch"\r
      [class.chat-open]="!chatCollapsed">\r
\r
  <!-- Stage -->\r
  <section class="stage flex-1 flex flex-col relative min-h-0">\r
    <div *ngIf="!isDesktop" class="stage-header flex items-center justify-between px-3 py-2 rounded-t-md shrink-0">\r
      <div class="text-sm text-sky-100">Room: <strong>#{{ roomName }}</strong></div>\r
      <button class="hr-btn flex items-center gap-2" (click)="toggleChat()">\r
        <i class="ph ph-users"></i> Menu\r
      </button>\r
    </div>\r
\r
    <div class="tile-grid-container flex-1 min-h-0 p-4 gap-6 border border-sky-700/40 rounded-xl bg-slate-900/40 flex flex-col overflow-hidden">\r
      <!-- Full Video (when one person has video on)\r
      <div *ngIf="fullParticipant" class="full-video-container flex-1 min-h-0">\r
        <div class="tile group rounded-xl overflow-hidden flex items-center justify-center bg-gradient-to-b from-slate-800 to-slate-900 shadow-md hover:shadow-xl transition-all duration-300">\r
          <video *ngIf="fullParticipant.stream"\r
                 [appSrcObject]="fullParticipant.stream"\r
                 [muted]="!!fullParticipant.isYou"\r
                 autoplay playsinline\r
                 class="absolute inset-0 w-full h-full object-cover"></video>\r
          <audio *ngIf="fullParticipant.stream && !fullParticipant.isYou"\r
                 [appSrcObject]="fullParticipant.stream" autoplay></audio>\r
          <div class="placeholder flex items-center justify-center w-full h-full"\r
               *ngIf="!fullParticipant.stream">\r
            <div class="initials w-24 h-24 rounded-full flex items-center justify-center font-extrabold text-2xl bg-sky-700/40 text-white">\r
              {{ fullParticipant.initials }}\r
            </div>\r
          </div>\r
          <div class="nameplate absolute left-3 bottom-3 px-3 py-1 rounded-full text-xs font-semibold flex items-center gap-2 bg-black/50 backdrop-blur-sm">\r
            <span class="badge w-2 h-2 rounded-full"\r
                  [ngClass]="{ 'bg-green-400': fullParticipant.mic==='on', 'bg-red-400': fullParticipant.mic==='off' }"></span>\r
            {{ fullParticipant.name }}\r
          </div>\r
        </div>\r
      </div> -->\r
\r
      <!-- Video Tiles Grid -->\r
      <div class="tile-grid min-h-0 overflow-y-auto no-scrollbar"\r
           [ngClass]="{\r
             'layout-1': gridParticipants.length === 1,\r
             'layout-2': gridParticipants.length === 2,\r
             'layout-3': gridParticipants.length === 3,\r
             'layout-4': gridParticipants.length === 4,\r
             'layout-more': gridParticipants.length > 4\r
           }"\r
           *ngIf="gridParticipants.length > 0">\r
        <div class="tile group relative rounded-xl overflow-hidden aspect-video flex items-center justify-center bg-gradient-to-b from-slate-800 to-slate-900 shadow-md hover:shadow-xl transition-all duration-300"\r
             *ngFor="let p of gridParticipants; let i = index; trackBy: trackByParticipant"\r
             [class.video-on]="p.videoOn"\r
             [class.hide-when-pip]="p.isYou && shouldShowSelfVideo && gridParticipants.length > 1"\r
             [class.hand-raised]="p.handRaised">\r
\r
             <video *ngIf="p.stream && p.videoOn"\r
             [appSrcObject]="p.stream"\r
             [muted]="!!p.isYou"\r
             autoplay playsinline\r
             [attr.data-chan]="p.isYou ? '__you__' : p.channel"\r
             class="absolute inset-0 w-full h-full object-cover"></video>\r
\r
             <audio *ngIf="p.stream && !p.isYou"\r
             [appSrcObject]="p.stream" autoplay></audio>\r
\r
          <div class="placeholder flex items-center justify-center w-full h-full"\r
               *ngIf="!p.videoOn"\r
               [style.background]="getGradientForParticipant(p.channel)">\r
            <div class="initials w-32 h-32 rounded-full flex items-center justify-center font-extrabold text-4xl bg-black/30 text-white backdrop-blur-sm"\r
                 [class.hand-raised]="p.handRaised">\r
              <span *ngIf="!p.handRaised">{{ p.initials }}</span>\r
              <span *ngIf="p.handRaised" class="hand-emoji">\u270B</span>\r
            </div>\r
          </div>\r
          <span class="nameplate absolute left-2 top-9 px-3 py-1 rounded-full text-xs font-semibold flex items-center gap-2 bg-black/50 backdrop-blur-sm text-sky-400">\r
            \u{1F441}\uFE0F {{ p.gaze }}\r
          </span>\r
          <span class="nameplate absolute left-2 top-16 px-3 py-1 rounded-full text-xs font-semibold flex items-center gap-2 bg-black/50 backdrop-blur-sm text-purple-400">\r
            \u{1F3A4} {{ p.voice }}\r
          </span>\r
          <div class="nameplate absolute left-3 bottom-3 px-3 py-1 rounded-full text-xs font-semibold flex items-center gap-2 bg-black/50 backdrop-blur-sm">\r
            <span class="badge w-2 h-2 rounded-full"\r
                  [ngClass]="{ 'bg-green-400': p.mic==='on', 'bg-red-400': p.mic==='off' }"></span>\r
            {{ p.name }}\r
          </div>\r
        </div>\r
      </div>\r
\r
      <!-- Controls -->\r
      <div class="controls shrink-0 bg-slate-900/60 backdrop-blur-sm p-4 rounded-lg border-t border-sky-700/30 flex flex-wrap gap-3 justify-center">\r
        <button (click)="toggleMic()" class="ctrl secondary flex items-center gap-2 px-4 py-2 rounded-full">\r
          <i class="ph" [ngClass]="you?.mic === 'on' ? 'ph-microphone' : 'ph-microphone-slash'"></i>\r
          <span>Mic</span>\r
        </button>\r
        <button (click)="toggleCam()" class="ctrl secondary flex items-center gap-2 px-4 py-2 rounded-full">\r
          <i class="ph" [ngClass]="you?.cam === 'on' ? 'ph-video-camera' : 'ph-camera-slash'"></i>\r
          <span>Video</span>\r
        </button>\r
        <button (click)="shareScreen()" class="ctrl secondary flex items-center gap-2 px-4 py-2 rounded-full">\r
          <i class="ph ph-monitor"></i><span>Share</span>\r
        </button>\r
        <button (click)="raiseHand()" class="ctrl secondary flex items-center gap-2 px-4 py-2 rounded-full">\r
          <i class="ph ph-hand"></i><span>Hand</span>\r
        </button>\r
        <button (click)="startNotes()" class="ctrl secondary flex items-center gap-2 px-4 py-2 rounded-full">\r
          <i class="ph ph-note"></i><span>Notepad</span>\r
        </button>\r
        <button (click)="runGazeSession()" class="ctrl secondary flex items-center gap-2 px-4 py-2 rounded-full">\r
          <i class="ph ph-grid-four"></i><span>Start Calibration</span>\r
        </button>\r
        <button (click)="leaveCall()" class="ctrl danger flex items-center gap-2 px-4 py-2 rounded-full">\r
          <i class="ph ph-sign-out"></i><span>Leave</span>\r
        </button>\r
      </div>\r
    </div>\r
\r
    <!-- Floating Self Video (PiP) -->\r
    <div class="self-video-floating"\r
         *ngIf="shouldShowSelfVideo"\r
         cdkDrag\r
         cdkDragBoundary=".stage">\r
         <video *ngIf="you?.stream"\r
         [appSrcObject]="you?.stream"\r
         [muted]="true"\r
         autoplay playsinline\r
         data-chan= "__you__"\r
         class="w-full h-full object-cover rounded-lg shadow-lg"></video>\r
    </div>\r
  </section>\r
\r
  <!-- Side Panel with Tabs -->\r
  <aside class="chat-panel frosted lg:static fixed inset-y-0 right-0 w-full max-w-sm transform transition-transform duration-300 flex flex-col z-50 min-h-0 shadow-2xl"\r
         [ngClass]="{ 'translate-x-full': chatCollapsed && !isDesktop, 'translate-x-0': !chatCollapsed || isDesktop }">\r
\r
    <!-- Username -->\r
    <div class="shrink-0 p-3">\r
      <div class="relative floating mt-2">\r
        <i class="ph ph-user icon-left text-sky-300"></i>\r
        <input\r
          id="username"\r
          type="text"\r
          [value]="you?.name || 'You'"\r
          (change)="updateName($event)"\r
          class="floating-input pl-10 pr-3 py-2 text-sm rounded-md w-full dark-input"\r
        />\r
        <label for="username" class="floating-label">update display name from here.</label>\r
      </div>\r
    </div>\r
\r
    <div class="chat-header flex items-center justify-between px-4 py-3 border-b border-sky-700/20 shrink-0">\r
      <div class="flex gap-4">\r
        <button class="tab-btn" [class.active]="activeTab==='participants'" (click)="activeTab='participants'">Participants</button>\r
        <button class="tab-btn" [class.active]="activeTab==='chat'" (click)="activeTab='chat'">Chat</button>\r
      </div>\r
      <button (click)="closeChat()" *ngIf="!isDesktop" class="hr-btn px-3 py-1 text-xs">Close</button>\r
    </div>\r
\r
    <div class="flex-1 min-h-0 flex flex-col">\r
      <!-- Participants Tab -->\r
      <div class="flex-1 max-h-full overflow-y-auto participants-scroll p-4"\r
           *ngIf="activeTab==='participants'">\r
        <h3 class="text-sky-100 text-sm mb-2">Participants</h3>\r
        <div *ngFor="let p of participants" class="flex justify-between items-center p-2 bg-slate-800/50 rounded mb-1">\r
          <div class="flex items-center gap-2">\r
            <div class="w-8 h-8 rounded-full flex items-center justify-center text-sm font-bold"\r
                 [style.background]="getGradientForParticipant(p.channel)"\r
                 [class.hand-raised]="p.handRaised">\r
              <span *ngIf="!p.handRaised">{{ p.initials }}</span>\r
              <span *ngIf="p.handRaised" class="hand-emoji text-xs">\u270B</span>\r
            </div>\r
            <span>{{ p.name }}</span>\r
            <span *ngIf="p.gaze" class="text-xs text-sky-400">\u{1F441}\uFE0F {{ p.gaze }}</span>\r
            <span *ngIf="p.voice" class="text-xs text-purple-400">\u{1F3A4} {{ p.voice }}</span>\r
          </div>\r
          <div>\r
            <i class="ph" [ngClass]="p.mic==='on' ? 'ph-microphone' : 'ph-microphone-slash'"></i>\r
            <i class="ph" [ngClass]="p.cam==='on' ? 'ph-video-camera' : 'ph-camera-slash'"></i>\r
          </div>\r
        </div>\r
      </div>\r
\r
      <!-- Chat Tab -->\r
      <div #chatScroll class="flex-1 max-h-full overflow-y-auto chat-scroll p-4"\r
           *ngIf="activeTab==='chat'">\r
        <h3 class="text-sky-100 text-sm mb-2">Chat</h3>\r
        <div *ngFor="let m of chatMessages" class="p-2 bg-slate-800/60 rounded mb-1">\r
          <div class="text-xs font-semibold text-sky-200">{{ m.by }}</div>\r
          <div class="text-sm text-sky-100">{{ m.text }}</div>\r
        </div>\r
      </div>\r
    </div>\r
\r
    <!-- Chat Input (only show when chat tab is active) -->\r
    <form *ngIf="activeTab==='chat'" (ngSubmit)="sendChat()" class="flex border-t border-sky-700/10 p-2">\r
      <input [(ngModel)]="chatText" name="chatText" type="text" placeholder="Message the room..."\r
             class="flex-1 rounded-l-full px-3 py-2 text-sm dark-input"/>\r
      <button type="submit" class="px-4 py-2 rounded-r-full hr-btn">Send</button>\r
    </form>\r
  </aside>\r
</main>\r
\r
<!-- Notepad Component -->\r
<app-notepad *ngIf="isNotesOpen" (close)="closeNotes()"></app-notepad>\r
`, styles: ['@charset "UTF-8";\n\n/* src/app/dashboard/dashboard.scss */\n:root {\n  --c1: #09162b;\n  --c2: #1a3463;\n  --c3: #23293b;\n}\nhtml {\n  scroll-behavior: smooth;\n}\nbody {\n  font-family: "Inter", sans-serif;\n  color: #fff;\n  margin: 0;\n  background:\n    linear-gradient(\n      135deg,\n      var(--c1),\n      var(--c2),\n      var(--c3));\n  background-size: 400% 400%;\n  animation: gradientShift 12s ease infinite;\n}\n@keyframes gradientShift {\n  0% {\n    background-position: 0% 50%;\n  }\n  50% {\n    background-position: 100% 50%;\n  }\n  100% {\n    background-position: 0% 50%;\n  }\n}\n#mainHeader {\n  transition: background 500ms ease;\n}\n#mainHeader.overlay {\n  background:\n    linear-gradient(\n      to bottom,\n      rgba(2, 12, 27, 0.7),\n      rgba(2, 12, 27, 0));\n}\n.frosted {\n  -webkit-backdrop-filter: blur(25px);\n  backdrop-filter: blur(25px);\n  background-color: rgba(18, 27, 40, 0.62);\n  border: 1.5px solid rgba(0, 191, 255, 0.14);\n  box-shadow: 0 12px 40px 0 rgba(38, 112, 255, 0.14), -5px 0 25px rgba(0, 191, 255, 0.16);\n}\ninput:focus {\n  outline: none;\n  border-color: #0fd9ff;\n  box-shadow: 0 0 0 3px rgba(15, 217, 255, 0.5);\n}\nbutton,\n.sign-in-btn {\n  background:\n    linear-gradient(\n      90deg,\n      #0fd9ff 0%,\n      #2e57ff 100%);\n  box-shadow: 0 2px 30px 0 rgba(40, 75, 255, 0.16);\n  border-radius: 9999px;\n  padding: 0.6rem 1rem;\n}\nbutton:hover,\n.sign-in-btn:hover {\n  background:\n    linear-gradient(\n      90deg,\n      #51e2f5 0%,\n      #284bff 100%);\n  box-shadow: 0 4px 32px 0 rgba(40, 75, 255, 0.28);\n  color: #fff;\n}\n.text-xl,\nh1,\n.font-bold {\n  text-shadow: 1px 1px 8px rgba(40, 75, 255, 0.08);\n}\n.placeholder-gray-400::placeholder {\n  color: #a8b0c5;\n  opacity: 1;\n}\ncanvas#particles {\n  position: fixed;\n  inset: 0;\n  z-index: -1;\n  background:\n    linear-gradient(\n      135deg,\n      var(--c1),\n      var(--c2),\n      var(--c3));\n  background-size: 400% 400%;\n  animation: gradientShift 12s ease infinite;\n  pointer-events: none;\n}\n#closeLogin {\n  z-index: 9999;\n  position: absolute;\n  top: 1.5rem;\n  right: 1.5rem;\n  background: transparent;\n  border: none;\n  cursor: pointer;\n}\n.floating {\n  position: relative;\n}\n.floating input.floating-input {\n  width: 100%;\n  padding-left: 2.5rem;\n  padding-top: 1.25rem;\n  padding-bottom: 0.5rem;\n  border-radius: 0.5rem;\n  background: rgba(18, 27, 40, 0.55);\n  border: 1px solid rgba(148, 163, 184, 0.12);\n  color: #fff;\n  transition: box-shadow 0.18s ease, border-color 0.18s ease;\n}\n.floating label.floating-label {\n  position: absolute;\n  left: 2.5rem;\n  top: 50%;\n  transform: translateY(-50%);\n  font-size: 1rem;\n  color: #a8b0c5;\n  pointer-events: none;\n  transition: all 180ms ease;\n}\n.floating input.floating-input:focus + label.floating-label,\n.floating input.floating-input:not(:placeholder-shown) + label.floating-label {\n  top: 0.3rem;\n  transform: translateY(0);\n  font-size: 0.78rem;\n  color: #0fd9ff;\n}\n.floating input.floating-input[type=password] {\n  letter-spacing: 0.25em;\n}\n.floating .icon-left {\n  pointer-events: none;\n  position: absolute;\n  left: 0.75rem;\n  top: 50%;\n  transform: translateY(-50%);\n  color: #9aa6bb;\n}\n#openLoginBtn {\n  z-index: 45;\n}\n.tile-grid-container {\n  flex: 1 1 auto;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  position: relative;\n}\n.tile-grid {\n  display: grid;\n  width: 100%;\n  height: 100%;\n  gap: 1rem;\n  justify-items: center;\n  grid-auto-rows: 1fr;\n  overflow: hidden;\n}\n.tile-grid.layout-1 {\n  grid-template-columns: 1fr;\n}\n.tile-grid.layout-2 {\n  grid-template-columns: 1fr;\n}\n@media (min-width: 768px) {\n  .tile-grid.layout-2 {\n    grid-template-columns: 1fr 1fr;\n  }\n}\n.tile-grid.layout-3 {\n  grid-template-columns: 1fr 1fr;\n}\n.tile-grid.layout-4 {\n  grid-template-columns: 1fr 1fr;\n  grid-template-rows: 1fr 1fr;\n}\n.tile-grid.layout-more {\n  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));\n}\n.tile {\n  border: 1px solid rgba(0, 191, 255, 0.14);\n  -webkit-backdrop-filter: blur(12px);\n  backdrop-filter: blur(12px);\n  background: rgba(18, 27, 40, 0.55);\n  border-radius: 1rem;\n  overflow: hidden;\n  position: relative;\n  transition: transform 0.3s ease, box-shadow 0.3s ease;\n  width: 100%;\n  height: 100%;\n  min-height: 200px;\n  aspect-ratio: 16/9;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.tile video {\n  position: absolute;\n  inset: 0;\n  width: 100%;\n  height: 100%;\n  object-fit: fill;\n  z-index: 1;\n  transform: translateZ(0);\n  will-change: transform;\n  mix-blend-mode: normal;\n}\n.tile .placeholder {\n  position: absolute;\n  inset: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: rgba(18, 27, 40, 0.85);\n  z-index: 15;\n}\n.tile .canvas[data-role=overlay] {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 50;\n  pointer-events: none;\n  display: block;\n  background: transparent;\n  border: 2px solid green;\n  transform: translateZ(0);\n  will-change: transform;\n}\n.nameplate {\n  border: 1px solid rgba(0, 191, 255, 0.25);\n  transition: background 0.3s ease, transform 0.3s ease;\n  z-index: 30;\n}\n.nameplate:hover {\n  background: rgba(0, 191, 255, 0.25);\n  transform: translateY(-2px);\n}\n.tile,\n.tile * {\n  scrollbar-width: none;\n}\n.tile::-webkit-scrollbar,\n.tile *::-webkit-scrollbar {\n  display: none;\n}\n@media (max-width: 640px) {\n  .tile-grid {\n    grid-template-columns: 1fr;\n    gap: 0.5rem;\n  }\n  .tile {\n    min-height: 200px;\n    max-width: 100%;\n  }\n}\n.controls {\n  flex-wrap: wrap;\n  gap: 0.75rem;\n  justify-content: center;\n  background: rgba(18, 27, 40, 0.55);\n  border-top: 1px solid rgba(148, 163, 184, 0.12);\n  -webkit-backdrop-filter: blur(12px);\n  backdrop-filter: blur(12px);\n  padding: 1rem;\n  border-radius: 1rem;\n}\n.controls button {\n  background: rgba(18, 27, 40, 0.55);\n  border: 1px solid rgba(148, 163, 184, 0.12);\n  -webkit-backdrop-filter: blur(12px);\n  backdrop-filter: blur(12px);\n  transition:\n    background 0.3s ease,\n    box-shadow 0.25s ease,\n    transform 0.15s ease;\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 0.6rem 1rem;\n  border-radius: 9999px;\n}\n.controls button:active {\n  transform: scale(0.98);\n}\n.controls button i {\n  font-size: 1.25rem;\n}\n.controls button span {\n  display: inline;\n}\n@media (max-width: 640px) {\n  .controls {\n    justify-content: space-around;\n  }\n  .controls button span {\n    display: none;\n  }\n}\n.controls button:hover {\n  background: rgba(40, 75, 255, 0.35);\n  box-shadow: 0 6px 20px rgba(40, 75, 255, 0.25);\n}\n.hr-btn {\n  border-radius: 9999px;\n  padding: 0.6rem 1rem;\n  background:\n    linear-gradient(\n      90deg,\n      #0fd9ff 0%,\n      #2e57ff 100%);\n  color: #fff;\n  font-weight: 600;\n  letter-spacing: 0.02em;\n  border: 1px solid rgba(148, 163, 184, 0.12);\n}\n.hr-btn:hover {\n  box-shadow: 0 6px 18px rgba(40, 75, 255, 0.28);\n}\n.dark-input,\ninput[type=text],\ninput[type=password],\ntextarea {\n  background: rgba(18, 27, 40, 0.55);\n  border: 1px solid rgba(148, 163, 184, 0.12);\n  border-radius: 0.75rem;\n  color: #fff;\n  padding: 0.6rem 0.8rem;\n  transition: border-color 0.2s ease, box-shadow 0.2s ease;\n}\n.dark-input:focus,\ninput[type=text]:focus,\ninput[type=password]:focus,\ntextarea:focus {\n  outline: none;\n  border-color: #0fd9ff;\n  box-shadow: 0 0 0 3px rgba(15, 217, 255, 0.4);\n}\n.chat-panel .participants-scroll,\n.chat-panel .chat-scroll {\n  flex: 1 1 auto;\n  min-height: 0;\n  overflow-y: auto;\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n  scroll-behavior: smooth;\n  -webkit-overflow-scrolling: touch;\n}\n.chat-panel .participants-scroll::-webkit-scrollbar,\n.chat-panel .chat-scroll::-webkit-scrollbar {\n  display: none;\n}\n.tab-btn {\n  position: relative;\n  font-size: 0.875rem;\n  font-weight: 500;\n  padding: 0.4rem 0.75rem;\n  border-radius: 9999px;\n  background: transparent;\n  color: #a8b0c5;\n  transition: all 0.25s ease;\n}\n.tab-btn:hover {\n  background: rgba(40, 75, 255, 0.15);\n  color: #fff;\n}\n.tab-btn.active {\n  background:\n    linear-gradient(\n      90deg,\n      #0fd9ff 0%,\n      #2e57ff 100%);\n  color: #fff;\n  font-weight: 600;\n  box-shadow: 0 0 12px rgba(40, 75, 255, 0.35);\n}\n.self-placeholder {\n  background: rgba(30, 41, 59, 0.7);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.self-video-floating {\n  position: absolute;\n  bottom: 1rem;\n  right: 1rem;\n  width: 200px;\n  height: 150px;\n  z-index: 60;\n  border-radius: 0.5rem;\n  overflow: hidden;\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);\n  background: rgba(18, 27, 40, 0.9);\n  border: 1px solid rgba(0, 191, 255, 0.14);\n  transition: opacity 0.3s ease;\n}\n.self-video-floating:hover {\n  box-shadow: 0 6px 24px rgba(40, 75, 255, 0.25);\n}\n.tile.hand-raised {\n  border-color: #FFD700;\n  box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);\n}\n.hand-emoji {\n  font-size: 1.2em;\n  margin-left: 0.2em;\n}\n.tile.suspicious {\n  border-color: #ff3b3b;\n  box-shadow: 0 0 25px rgba(255, 59, 59, 0.8), 0 0 45px rgba(255, 59, 59, 0.6);\n  animation: suspiciousPulse 1.5s infinite alternate;\n}\n@keyframes suspiciousPulse {\n  0% {\n    box-shadow: 0 0 15px rgba(255, 59, 59, 0.6), 0 0 25px rgba(255, 59, 59, 0.4);\n  }\n  100% {\n    box-shadow: 0 0 35px rgba(255, 59, 59, 0.9), 0 0 55px rgba(255, 59, 59, 0.7);\n  }\n}\n.tile {\n  position: relative;\n}\n.tile .video-el {\n  position: absolute;\n  inset: 0;\n  width: 100%;\n  height: 100%;\n  object-fit: fill;\n  background: #000;\n  z-index: 1;\n  transform: translateZ(0);\n  will-change: transform;\n  mix-blend-mode: normal;\n}\n.tile .overlay-el {\n  position: absolute;\n  inset: 0;\n  width: 100% !important;\n  height: 100% !important;\n  display: block;\n  background: transparent;\n  pointer-events: none;\n  z-index: 5;\n}\n.tile .placeholder {\n  z-index: 2;\n}\n.tile .nameplate {\n  z-index: 10;\n}\n.tile.suspicious {\n  border-color: #ff3b3b;\n  box-shadow: 0 0 25px rgba(255, 59, 59, 0.8), 0 0 45px rgba(255, 59, 59, 0.6);\n  animation: suspiciousPulse 1.5s infinite alternate;\n}\n@keyframes suspiciousPulse {\n  0% {\n    box-shadow: 0 0 15px rgba(255, 59, 59, 0.6), 0 0 25px rgba(255, 59, 59, 0.4);\n  }\n  100% {\n    box-shadow: 0 0 35px rgba(255, 59, 59, 0.9), 0 0 55px rgba(255, 59, 59, 0.7);\n  }\n}\n/*# sourceMappingURL=dashboard.css.map */\n'] }]
      }], () => [{ type: SignalingService }, { type: NgZone }, { type: VoiceService }, { type: ChangeDetectorRef }], { chatScroll: [{
        type: ViewChild,
        args: ["chatScroll"]
      }], enrollmentVideo: [{
        type: ViewChild,
        args: ["enrollmentVideo"]
      }], onBeforeUnload: [{
        type: HostListener,
        args: ["window:beforeunload"]
      }], onResize: [{
        type: HostListener,
        args: ["window:resize"]
      }], onEscapeKey: [{
        type: HostListener,
        args: ["document:keydown.escape"]
      }] });
    })();
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(Dashboard, { className: "Dashboard", filePath: "src/app/dashboard/dashboard.ts", lineNumber: 96 });
    })();
  }
});

// src/app/app.routes.ts
var routes;
var init_app_routes = __esm({
  "src/app/app.routes.ts"() {
    "use strict";
    init_dashboard();
    routes = [
      {
        path: "video-call",
        component: Dashboard
      },
      {
        path: "",
        redirectTo: "video-call",
        pathMatch: "full"
      }
    ];
  }
});

// src/app/app.config.ts
var appConfig;
var init_app_config = __esm({
  "src/app/app.config.ts"() {
    "use strict";
    init_core();
    init_router();
    init_app_routes();
    appConfig = {
      providers: [
        provideBrowserGlobalErrorListeners(),
        provideZoneChangeDetection({ eventCoalescing: true }),
        provideRouter(routes)
      ]
    };
  }
});

// src/app/app.ts
var App;
var init_app = __esm({
  "src/app/app.ts"() {
    "use strict";
    init_core();
    init_dashboard();
    init_http();
    init_core();
    App = class _App {
      title = signal("frontend", ...ngDevMode ? [{ debugName: "title" }] : []);
      static \u0275fac = function App_Factory(__ngFactoryType__) {
        return new (__ngFactoryType__ || _App)();
      };
      static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _App, selectors: [["app-root"]], decls: 2, vars: 0, template: function App_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "div");
          \u0275\u0275element(1, "app-dashboard");
          \u0275\u0275elementEnd();
        }
      }, dependencies: [
        Dashboard,
        HttpClientModule
      ], styles: ["\n\n#particles[_ngcontent-%COMP%] {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 50%;\n  z-index: 0;\n  pointer-events: none;\n}\n/*# sourceMappingURL=app.css.map */"] });
    };
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(App, [{
        type: Component,
        args: [{ selector: "app-root", imports: [
          Dashboard,
          HttpClientModule
        ], template: "<div>\r\n  <app-dashboard></app-dashboard>\r\n</div>\r\n", styles: ["/* src/app/app.scss */\n#particles {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 50%;\n  z-index: 0;\n  pointer-events: none;\n}\n/*# sourceMappingURL=app.css.map */\n"] }]
      }], null, null);
    })();
    (() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(App, { className: "App", filePath: "src/app/app.ts", lineNumber: 14 });
    })();
  }
});

// src/main.ts
var require_main = __commonJS({
  "src/main.ts"() {
    init_platform_browser();
    init_app_config();
    init_app();
    bootstrapApplication(App, appConfig).catch((err) => console.error(err));
  }
});
export default require_main();
/*! Bundled license information:

@angular/core/fesm2022/not_found.mjs:
@angular/core/fesm2022/signal.mjs:
@angular/core/fesm2022/untracked.mjs:
@angular/core/fesm2022/primitives/signals.mjs:
@angular/core/fesm2022/primitives/di.mjs:
@angular/core/fesm2022/root_effect_scheduler.mjs:
@angular/core/fesm2022/resource.mjs:
@angular/common/fesm2022/location.mjs:
@angular/common/fesm2022/common_module.mjs:
@angular/common/fesm2022/xhr.mjs:
@angular/common/fesm2022/common.mjs:
@angular/platform-browser/fesm2022/dom_renderer.mjs:
@angular/platform-browser/fesm2022/browser.mjs:
@angular/common/fesm2022/module.mjs:
@angular/common/fesm2022/http.mjs:
@angular/platform-browser/fesm2022/platform-browser.mjs:
@angular/router/fesm2022/router2.mjs:
@angular/router/fesm2022/router_module.mjs:
@angular/router/fesm2022/router.mjs:
@angular/forms/fesm2022/forms.mjs:
  (**
   * @license Angular v20.1.7
   * (c) 2010-2025 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/core/fesm2022/debug_node.mjs:
@angular/core/fesm2022/core.mjs:
  (**
   * @license Angular v20.1.7
   * (c) 2010-2025 Google LLC. https://angular.io/
   * License: MIT
   *)
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.dev/license
   *)
*/
//# sourceMappingURL=main.js.map
